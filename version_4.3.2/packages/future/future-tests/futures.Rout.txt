
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:04:40.762] plan(): Setting new future strategy stack:
[16:04:40.763] List of future strategies:
[16:04:40.763] 1. sequential:
[16:04:40.763]    - args: function (..., envir = parent.frame())
[16:04:40.763]    - tweaked: FALSE
[16:04:40.763]    - call: future::plan("sequential")
[16:04:40.776] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[16:04:40.826] plan(): Setting new future strategy stack:
[16:04:40.827] List of future strategies:
[16:04:40.827] 1. sequential:
[16:04:40.827]    - args: function (..., envir = parent.frame())
[16:04:40.827]    - tweaked: FALSE
[16:04:40.827]    - call: plan(strategy)
[16:04:40.837] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[16:04:40.838] getGlobalsAndPackages() ...
[16:04:40.838] Searching for globals...
[16:04:40.841] 
[16:04:40.841] Searching for globals ... DONE
[16:04:40.841] - globals: [0] <none>
[16:04:40.841] getGlobalsAndPackages() ... DONE
[16:04:40.842] run() for ‘Future’ ...
[16:04:40.842] - state: ‘created’
[16:04:40.842] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:40.842] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:40.842] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:40.842]   - Field: ‘label’
[16:04:40.843]   - Field: ‘local’
[16:04:40.843]   - Field: ‘owner’
[16:04:40.843]   - Field: ‘envir’
[16:04:40.843]   - Field: ‘packages’
[16:04:40.843]   - Field: ‘gc’
[16:04:40.843]   - Field: ‘conditions’
[16:04:40.843]   - Field: ‘expr’
[16:04:40.843]   - Field: ‘uuid’
[16:04:40.843]   - Field: ‘seed’
[16:04:40.843]   - Field: ‘version’
[16:04:40.843]   - Field: ‘result’
[16:04:40.844]   - Field: ‘asynchronous’
[16:04:40.844]   - Field: ‘calls’
[16:04:40.844]   - Field: ‘globals’
[16:04:40.844]   - Field: ‘stdout’
[16:04:40.844]   - Field: ‘earlySignal’
[16:04:40.844]   - Field: ‘lazy’
[16:04:40.844]   - Field: ‘state’
[16:04:40.844] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:40.844] - Launch lazy future ...
[16:04:40.845] Packages needed by the future expression (n = 0): <none>
[16:04:40.845] Packages needed by future strategies (n = 0): <none>
[16:04:40.846] {
[16:04:40.846]     {
[16:04:40.846]         {
[16:04:40.846]             ...future.startTime <- base::Sys.time()
[16:04:40.846]             {
[16:04:40.846]                 {
[16:04:40.846]                   {
[16:04:40.846]                     base::local({
[16:04:40.846]                       has_future <- base::requireNamespace("future", 
[16:04:40.846]                         quietly = TRUE)
[16:04:40.846]                       if (has_future) {
[16:04:40.846]                         ns <- base::getNamespace("future")
[16:04:40.846]                         version <- ns[[".package"]][["version"]]
[16:04:40.846]                         if (is.null(version)) 
[16:04:40.846]                           version <- utils::packageVersion("future")
[16:04:40.846]                       }
[16:04:40.846]                       else {
[16:04:40.846]                         version <- NULL
[16:04:40.846]                       }
[16:04:40.846]                       if (!has_future || version < "1.8.0") {
[16:04:40.846]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:40.846]                           "", base::R.version$version.string), 
[16:04:40.846]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:40.846]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:40.846]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:40.846]                             "release", "version")], collapse = " "), 
[16:04:40.846]                           hostname = base::Sys.info()[["nodename"]])
[16:04:40.846]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:40.846]                           info)
[16:04:40.846]                         info <- base::paste(info, collapse = "; ")
[16:04:40.846]                         if (!has_future) {
[16:04:40.846]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:40.846]                             info)
[16:04:40.846]                         }
[16:04:40.846]                         else {
[16:04:40.846]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:40.846]                             info, version)
[16:04:40.846]                         }
[16:04:40.846]                         base::stop(msg)
[16:04:40.846]                       }
[16:04:40.846]                     })
[16:04:40.846]                   }
[16:04:40.846]                   options(future.plan = NULL)
[16:04:40.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.846]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:40.846]                 }
[16:04:40.846]                 ...future.workdir <- getwd()
[16:04:40.846]             }
[16:04:40.846]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:40.846]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:40.846]         }
[16:04:40.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:40.846]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:40.846]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:40.846]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:40.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:40.846]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:40.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:40.846]             base::names(...future.oldOptions))
[16:04:40.846]     }
[16:04:40.846]     if (FALSE) {
[16:04:40.846]     }
[16:04:40.846]     else {
[16:04:40.846]         if (TRUE) {
[16:04:40.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:40.846]                 open = "w")
[16:04:40.846]         }
[16:04:40.846]         else {
[16:04:40.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:40.846]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:40.846]         }
[16:04:40.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:40.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:40.846]             base::sink(type = "output", split = FALSE)
[16:04:40.846]             base::close(...future.stdout)
[16:04:40.846]         }, add = TRUE)
[16:04:40.846]     }
[16:04:40.846]     ...future.frame <- base::sys.nframe()
[16:04:40.846]     ...future.conditions <- base::list()
[16:04:40.846]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:40.846]     if (FALSE) {
[16:04:40.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:40.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:40.846]     }
[16:04:40.846]     ...future.result <- base::tryCatch({
[16:04:40.846]         base::withCallingHandlers({
[16:04:40.846]             ...future.value <- base::withVisible(base::local(2))
[16:04:40.846]             future::FutureResult(value = ...future.value$value, 
[16:04:40.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.846]                   ...future.rng), globalenv = if (FALSE) 
[16:04:40.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:40.846]                     ...future.globalenv.names))
[16:04:40.846]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:40.846]         }, condition = base::local({
[16:04:40.846]             c <- base::c
[16:04:40.846]             inherits <- base::inherits
[16:04:40.846]             invokeRestart <- base::invokeRestart
[16:04:40.846]             length <- base::length
[16:04:40.846]             list <- base::list
[16:04:40.846]             seq.int <- base::seq.int
[16:04:40.846]             signalCondition <- base::signalCondition
[16:04:40.846]             sys.calls <- base::sys.calls
[16:04:40.846]             `[[` <- base::`[[`
[16:04:40.846]             `+` <- base::`+`
[16:04:40.846]             `<<-` <- base::`<<-`
[16:04:40.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:40.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:40.846]                   3L)]
[16:04:40.846]             }
[16:04:40.846]             function(cond) {
[16:04:40.846]                 is_error <- inherits(cond, "error")
[16:04:40.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:40.846]                   NULL)
[16:04:40.846]                 if (is_error) {
[16:04:40.846]                   sessionInformation <- function() {
[16:04:40.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:40.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:40.846]                       search = base::search(), system = base::Sys.info())
[16:04:40.846]                   }
[16:04:40.846]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:40.846]                     cond$call), session = sessionInformation(), 
[16:04:40.846]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:40.846]                   signalCondition(cond)
[16:04:40.846]                 }
[16:04:40.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:40.846]                 "immediateCondition"))) {
[16:04:40.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:40.846]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:40.846]                   if (TRUE && !signal) {
[16:04:40.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.846]                     {
[16:04:40.846]                       inherits <- base::inherits
[16:04:40.846]                       invokeRestart <- base::invokeRestart
[16:04:40.846]                       is.null <- base::is.null
[16:04:40.846]                       muffled <- FALSE
[16:04:40.846]                       if (inherits(cond, "message")) {
[16:04:40.846]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.846]                         if (muffled) 
[16:04:40.846]                           invokeRestart("muffleMessage")
[16:04:40.846]                       }
[16:04:40.846]                       else if (inherits(cond, "warning")) {
[16:04:40.846]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.846]                         if (muffled) 
[16:04:40.846]                           invokeRestart("muffleWarning")
[16:04:40.846]                       }
[16:04:40.846]                       else if (inherits(cond, "condition")) {
[16:04:40.846]                         if (!is.null(pattern)) {
[16:04:40.846]                           computeRestarts <- base::computeRestarts
[16:04:40.846]                           grepl <- base::grepl
[16:04:40.846]                           restarts <- computeRestarts(cond)
[16:04:40.846]                           for (restart in restarts) {
[16:04:40.846]                             name <- restart$name
[16:04:40.846]                             if (is.null(name)) 
[16:04:40.846]                               next
[16:04:40.846]                             if (!grepl(pattern, name)) 
[16:04:40.846]                               next
[16:04:40.846]                             invokeRestart(restart)
[16:04:40.846]                             muffled <- TRUE
[16:04:40.846]                             break
[16:04:40.846]                           }
[16:04:40.846]                         }
[16:04:40.846]                       }
[16:04:40.846]                       invisible(muffled)
[16:04:40.846]                     }
[16:04:40.846]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.846]                   }
[16:04:40.846]                 }
[16:04:40.846]                 else {
[16:04:40.846]                   if (TRUE) {
[16:04:40.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.846]                     {
[16:04:40.846]                       inherits <- base::inherits
[16:04:40.846]                       invokeRestart <- base::invokeRestart
[16:04:40.846]                       is.null <- base::is.null
[16:04:40.846]                       muffled <- FALSE
[16:04:40.846]                       if (inherits(cond, "message")) {
[16:04:40.846]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.846]                         if (muffled) 
[16:04:40.846]                           invokeRestart("muffleMessage")
[16:04:40.846]                       }
[16:04:40.846]                       else if (inherits(cond, "warning")) {
[16:04:40.846]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.846]                         if (muffled) 
[16:04:40.846]                           invokeRestart("muffleWarning")
[16:04:40.846]                       }
[16:04:40.846]                       else if (inherits(cond, "condition")) {
[16:04:40.846]                         if (!is.null(pattern)) {
[16:04:40.846]                           computeRestarts <- base::computeRestarts
[16:04:40.846]                           grepl <- base::grepl
[16:04:40.846]                           restarts <- computeRestarts(cond)
[16:04:40.846]                           for (restart in restarts) {
[16:04:40.846]                             name <- restart$name
[16:04:40.846]                             if (is.null(name)) 
[16:04:40.846]                               next
[16:04:40.846]                             if (!grepl(pattern, name)) 
[16:04:40.846]                               next
[16:04:40.846]                             invokeRestart(restart)
[16:04:40.846]                             muffled <- TRUE
[16:04:40.846]                             break
[16:04:40.846]                           }
[16:04:40.846]                         }
[16:04:40.846]                       }
[16:04:40.846]                       invisible(muffled)
[16:04:40.846]                     }
[16:04:40.846]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.846]                   }
[16:04:40.846]                 }
[16:04:40.846]             }
[16:04:40.846]         }))
[16:04:40.846]     }, error = function(ex) {
[16:04:40.846]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:40.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.846]                 ...future.rng), started = ...future.startTime, 
[16:04:40.846]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:40.846]             version = "1.8"), class = "FutureResult")
[16:04:40.846]     }, finally = {
[16:04:40.846]         if (!identical(...future.workdir, getwd())) 
[16:04:40.846]             setwd(...future.workdir)
[16:04:40.846]         {
[16:04:40.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:40.846]                 ...future.oldOptions$nwarnings <- NULL
[16:04:40.846]             }
[16:04:40.846]             base::options(...future.oldOptions)
[16:04:40.846]             if (.Platform$OS.type == "windows") {
[16:04:40.846]                 old_names <- names(...future.oldEnvVars)
[16:04:40.846]                 envs <- base::Sys.getenv()
[16:04:40.846]                 names <- names(envs)
[16:04:40.846]                 common <- intersect(names, old_names)
[16:04:40.846]                 added <- setdiff(names, old_names)
[16:04:40.846]                 removed <- setdiff(old_names, names)
[16:04:40.846]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:40.846]                   envs[common]]
[16:04:40.846]                 NAMES <- toupper(changed)
[16:04:40.846]                 args <- list()
[16:04:40.846]                 for (kk in seq_along(NAMES)) {
[16:04:40.846]                   name <- changed[[kk]]
[16:04:40.846]                   NAME <- NAMES[[kk]]
[16:04:40.846]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.846]                     next
[16:04:40.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.846]                 }
[16:04:40.846]                 NAMES <- toupper(added)
[16:04:40.846]                 for (kk in seq_along(NAMES)) {
[16:04:40.846]                   name <- added[[kk]]
[16:04:40.846]                   NAME <- NAMES[[kk]]
[16:04:40.846]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.846]                     next
[16:04:40.846]                   args[[name]] <- ""
[16:04:40.846]                 }
[16:04:40.846]                 NAMES <- toupper(removed)
[16:04:40.846]                 for (kk in seq_along(NAMES)) {
[16:04:40.846]                   name <- removed[[kk]]
[16:04:40.846]                   NAME <- NAMES[[kk]]
[16:04:40.846]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.846]                     next
[16:04:40.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.846]                 }
[16:04:40.846]                 if (length(args) > 0) 
[16:04:40.846]                   base::do.call(base::Sys.setenv, args = args)
[16:04:40.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:40.846]             }
[16:04:40.846]             else {
[16:04:40.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:40.846]             }
[16:04:40.846]             {
[16:04:40.846]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:40.846]                   0L) {
[16:04:40.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:40.846]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:40.846]                   base::options(opts)
[16:04:40.846]                 }
[16:04:40.846]                 {
[16:04:40.846]                   {
[16:04:40.846]                     NULL
[16:04:40.846]                     RNGkind("Mersenne-Twister")
[16:04:40.846]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:40.846]                       inherits = FALSE)
[16:04:40.846]                   }
[16:04:40.846]                   options(future.plan = NULL)
[16:04:40.846]                   if (is.na(NA_character_)) 
[16:04:40.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:40.846]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:40.846]                   {
[16:04:40.846]                     future <- SequentialFuture(..., envir = envir)
[16:04:40.846]                     if (!future$lazy) 
[16:04:40.846]                       future <- run(future)
[16:04:40.846]                     invisible(future)
[16:04:40.846]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:40.846]                 }
[16:04:40.846]             }
[16:04:40.846]         }
[16:04:40.846]     })
[16:04:40.846]     if (TRUE) {
[16:04:40.846]         base::sink(type = "output", split = FALSE)
[16:04:40.846]         if (TRUE) {
[16:04:40.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:40.846]         }
[16:04:40.846]         else {
[16:04:40.846]             ...future.result["stdout"] <- base::list(NULL)
[16:04:40.846]         }
[16:04:40.846]         base::close(...future.stdout)
[16:04:40.846]         ...future.stdout <- NULL
[16:04:40.846]     }
[16:04:40.846]     ...future.result$conditions <- ...future.conditions
[16:04:40.846]     ...future.result$finished <- base::Sys.time()
[16:04:40.846]     ...future.result
[16:04:40.846] }
[16:04:40.848] plan(): Setting new future strategy stack:
[16:04:40.848] List of future strategies:
[16:04:40.848] 1. sequential:
[16:04:40.848]    - args: function (..., envir = parent.frame())
[16:04:40.848]    - tweaked: FALSE
[16:04:40.848]    - call: NULL
[16:04:40.848] plan(): nbrOfWorkers() = 1
[16:04:40.849] plan(): Setting new future strategy stack:
[16:04:40.849] List of future strategies:
[16:04:40.849] 1. sequential:
[16:04:40.849]    - args: function (..., envir = parent.frame())
[16:04:40.849]    - tweaked: FALSE
[16:04:40.849]    - call: plan(strategy)
[16:04:40.850] plan(): nbrOfWorkers() = 1
[16:04:40.850] SequentialFuture started (and completed)
[16:04:40.850] - Launch lazy future ... done
[16:04:40.851] run() for ‘SequentialFuture’ ... done
[16:04:40.851] getGlobalsAndPackages() ...
[16:04:40.851] Searching for globals...
[16:04:40.851] 
[16:04:40.851] Searching for globals ... DONE
[16:04:40.851] - globals: [0] <none>
[16:04:40.851] getGlobalsAndPackages() ... DONE
[16:04:40.852] run() for ‘Future’ ...
[16:04:40.852] - state: ‘created’
[16:04:40.852] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:40.852] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:40.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:40.852]   - Field: ‘label’
[16:04:40.852]   - Field: ‘local’
[16:04:40.852]   - Field: ‘owner’
[16:04:40.852]   - Field: ‘envir’
[16:04:40.853]   - Field: ‘packages’
[16:04:40.853]   - Field: ‘gc’
[16:04:40.853]   - Field: ‘conditions’
[16:04:40.853]   - Field: ‘expr’
[16:04:40.853]   - Field: ‘uuid’
[16:04:40.853]   - Field: ‘seed’
[16:04:40.853]   - Field: ‘version’
[16:04:40.853]   - Field: ‘result’
[16:04:40.853]   - Field: ‘asynchronous’
[16:04:40.853]   - Field: ‘calls’
[16:04:40.853]   - Field: ‘globals’
[16:04:40.854]   - Field: ‘stdout’
[16:04:40.854]   - Field: ‘earlySignal’
[16:04:40.854]   - Field: ‘lazy’
[16:04:40.854]   - Field: ‘state’
[16:04:40.854] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:40.854] - Launch lazy future ...
[16:04:40.854] Packages needed by the future expression (n = 0): <none>
[16:04:40.854] Packages needed by future strategies (n = 0): <none>
[16:04:40.855] {
[16:04:40.855]     {
[16:04:40.855]         {
[16:04:40.855]             ...future.startTime <- base::Sys.time()
[16:04:40.855]             {
[16:04:40.855]                 {
[16:04:40.855]                   {
[16:04:40.855]                     base::local({
[16:04:40.855]                       has_future <- base::requireNamespace("future", 
[16:04:40.855]                         quietly = TRUE)
[16:04:40.855]                       if (has_future) {
[16:04:40.855]                         ns <- base::getNamespace("future")
[16:04:40.855]                         version <- ns[[".package"]][["version"]]
[16:04:40.855]                         if (is.null(version)) 
[16:04:40.855]                           version <- utils::packageVersion("future")
[16:04:40.855]                       }
[16:04:40.855]                       else {
[16:04:40.855]                         version <- NULL
[16:04:40.855]                       }
[16:04:40.855]                       if (!has_future || version < "1.8.0") {
[16:04:40.855]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:40.855]                           "", base::R.version$version.string), 
[16:04:40.855]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:40.855]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:40.855]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:40.855]                             "release", "version")], collapse = " "), 
[16:04:40.855]                           hostname = base::Sys.info()[["nodename"]])
[16:04:40.855]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:40.855]                           info)
[16:04:40.855]                         info <- base::paste(info, collapse = "; ")
[16:04:40.855]                         if (!has_future) {
[16:04:40.855]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:40.855]                             info)
[16:04:40.855]                         }
[16:04:40.855]                         else {
[16:04:40.855]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:40.855]                             info, version)
[16:04:40.855]                         }
[16:04:40.855]                         base::stop(msg)
[16:04:40.855]                       }
[16:04:40.855]                     })
[16:04:40.855]                   }
[16:04:40.855]                   options(future.plan = NULL)
[16:04:40.855]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.855]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:40.855]                 }
[16:04:40.855]                 ...future.workdir <- getwd()
[16:04:40.855]             }
[16:04:40.855]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:40.855]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:40.855]         }
[16:04:40.855]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:40.855]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:40.855]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:40.855]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:40.855]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:40.855]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:40.855]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:40.855]             base::names(...future.oldOptions))
[16:04:40.855]     }
[16:04:40.855]     if (FALSE) {
[16:04:40.855]     }
[16:04:40.855]     else {
[16:04:40.855]         if (TRUE) {
[16:04:40.855]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:40.855]                 open = "w")
[16:04:40.855]         }
[16:04:40.855]         else {
[16:04:40.855]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:40.855]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:40.855]         }
[16:04:40.855]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:40.855]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:40.855]             base::sink(type = "output", split = FALSE)
[16:04:40.855]             base::close(...future.stdout)
[16:04:40.855]         }, add = TRUE)
[16:04:40.855]     }
[16:04:40.855]     ...future.frame <- base::sys.nframe()
[16:04:40.855]     ...future.conditions <- base::list()
[16:04:40.855]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:40.855]     if (FALSE) {
[16:04:40.855]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:40.855]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:40.855]     }
[16:04:40.855]     ...future.result <- base::tryCatch({
[16:04:40.855]         base::withCallingHandlers({
[16:04:40.855]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:40.855]             future::FutureResult(value = ...future.value$value, 
[16:04:40.855]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.855]                   ...future.rng), globalenv = if (FALSE) 
[16:04:40.855]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:40.855]                     ...future.globalenv.names))
[16:04:40.855]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:40.855]         }, condition = base::local({
[16:04:40.855]             c <- base::c
[16:04:40.855]             inherits <- base::inherits
[16:04:40.855]             invokeRestart <- base::invokeRestart
[16:04:40.855]             length <- base::length
[16:04:40.855]             list <- base::list
[16:04:40.855]             seq.int <- base::seq.int
[16:04:40.855]             signalCondition <- base::signalCondition
[16:04:40.855]             sys.calls <- base::sys.calls
[16:04:40.855]             `[[` <- base::`[[`
[16:04:40.855]             `+` <- base::`+`
[16:04:40.855]             `<<-` <- base::`<<-`
[16:04:40.855]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:40.855]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:40.855]                   3L)]
[16:04:40.855]             }
[16:04:40.855]             function(cond) {
[16:04:40.855]                 is_error <- inherits(cond, "error")
[16:04:40.855]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:40.855]                   NULL)
[16:04:40.855]                 if (is_error) {
[16:04:40.855]                   sessionInformation <- function() {
[16:04:40.855]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:40.855]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:40.855]                       search = base::search(), system = base::Sys.info())
[16:04:40.855]                   }
[16:04:40.855]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.855]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:40.855]                     cond$call), session = sessionInformation(), 
[16:04:40.855]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:40.855]                   signalCondition(cond)
[16:04:40.855]                 }
[16:04:40.855]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:40.855]                 "immediateCondition"))) {
[16:04:40.855]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:40.855]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.855]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:40.855]                   if (TRUE && !signal) {
[16:04:40.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.855]                     {
[16:04:40.855]                       inherits <- base::inherits
[16:04:40.855]                       invokeRestart <- base::invokeRestart
[16:04:40.855]                       is.null <- base::is.null
[16:04:40.855]                       muffled <- FALSE
[16:04:40.855]                       if (inherits(cond, "message")) {
[16:04:40.855]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.855]                         if (muffled) 
[16:04:40.855]                           invokeRestart("muffleMessage")
[16:04:40.855]                       }
[16:04:40.855]                       else if (inherits(cond, "warning")) {
[16:04:40.855]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.855]                         if (muffled) 
[16:04:40.855]                           invokeRestart("muffleWarning")
[16:04:40.855]                       }
[16:04:40.855]                       else if (inherits(cond, "condition")) {
[16:04:40.855]                         if (!is.null(pattern)) {
[16:04:40.855]                           computeRestarts <- base::computeRestarts
[16:04:40.855]                           grepl <- base::grepl
[16:04:40.855]                           restarts <- computeRestarts(cond)
[16:04:40.855]                           for (restart in restarts) {
[16:04:40.855]                             name <- restart$name
[16:04:40.855]                             if (is.null(name)) 
[16:04:40.855]                               next
[16:04:40.855]                             if (!grepl(pattern, name)) 
[16:04:40.855]                               next
[16:04:40.855]                             invokeRestart(restart)
[16:04:40.855]                             muffled <- TRUE
[16:04:40.855]                             break
[16:04:40.855]                           }
[16:04:40.855]                         }
[16:04:40.855]                       }
[16:04:40.855]                       invisible(muffled)
[16:04:40.855]                     }
[16:04:40.855]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.855]                   }
[16:04:40.855]                 }
[16:04:40.855]                 else {
[16:04:40.855]                   if (TRUE) {
[16:04:40.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.855]                     {
[16:04:40.855]                       inherits <- base::inherits
[16:04:40.855]                       invokeRestart <- base::invokeRestart
[16:04:40.855]                       is.null <- base::is.null
[16:04:40.855]                       muffled <- FALSE
[16:04:40.855]                       if (inherits(cond, "message")) {
[16:04:40.855]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.855]                         if (muffled) 
[16:04:40.855]                           invokeRestart("muffleMessage")
[16:04:40.855]                       }
[16:04:40.855]                       else if (inherits(cond, "warning")) {
[16:04:40.855]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.855]                         if (muffled) 
[16:04:40.855]                           invokeRestart("muffleWarning")
[16:04:40.855]                       }
[16:04:40.855]                       else if (inherits(cond, "condition")) {
[16:04:40.855]                         if (!is.null(pattern)) {
[16:04:40.855]                           computeRestarts <- base::computeRestarts
[16:04:40.855]                           grepl <- base::grepl
[16:04:40.855]                           restarts <- computeRestarts(cond)
[16:04:40.855]                           for (restart in restarts) {
[16:04:40.855]                             name <- restart$name
[16:04:40.855]                             if (is.null(name)) 
[16:04:40.855]                               next
[16:04:40.855]                             if (!grepl(pattern, name)) 
[16:04:40.855]                               next
[16:04:40.855]                             invokeRestart(restart)
[16:04:40.855]                             muffled <- TRUE
[16:04:40.855]                             break
[16:04:40.855]                           }
[16:04:40.855]                         }
[16:04:40.855]                       }
[16:04:40.855]                       invisible(muffled)
[16:04:40.855]                     }
[16:04:40.855]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.855]                   }
[16:04:40.855]                 }
[16:04:40.855]             }
[16:04:40.855]         }))
[16:04:40.855]     }, error = function(ex) {
[16:04:40.855]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:40.855]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.855]                 ...future.rng), started = ...future.startTime, 
[16:04:40.855]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:40.855]             version = "1.8"), class = "FutureResult")
[16:04:40.855]     }, finally = {
[16:04:40.855]         if (!identical(...future.workdir, getwd())) 
[16:04:40.855]             setwd(...future.workdir)
[16:04:40.855]         {
[16:04:40.855]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:40.855]                 ...future.oldOptions$nwarnings <- NULL
[16:04:40.855]             }
[16:04:40.855]             base::options(...future.oldOptions)
[16:04:40.855]             if (.Platform$OS.type == "windows") {
[16:04:40.855]                 old_names <- names(...future.oldEnvVars)
[16:04:40.855]                 envs <- base::Sys.getenv()
[16:04:40.855]                 names <- names(envs)
[16:04:40.855]                 common <- intersect(names, old_names)
[16:04:40.855]                 added <- setdiff(names, old_names)
[16:04:40.855]                 removed <- setdiff(old_names, names)
[16:04:40.855]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:40.855]                   envs[common]]
[16:04:40.855]                 NAMES <- toupper(changed)
[16:04:40.855]                 args <- list()
[16:04:40.855]                 for (kk in seq_along(NAMES)) {
[16:04:40.855]                   name <- changed[[kk]]
[16:04:40.855]                   NAME <- NAMES[[kk]]
[16:04:40.855]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.855]                     next
[16:04:40.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.855]                 }
[16:04:40.855]                 NAMES <- toupper(added)
[16:04:40.855]                 for (kk in seq_along(NAMES)) {
[16:04:40.855]                   name <- added[[kk]]
[16:04:40.855]                   NAME <- NAMES[[kk]]
[16:04:40.855]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.855]                     next
[16:04:40.855]                   args[[name]] <- ""
[16:04:40.855]                 }
[16:04:40.855]                 NAMES <- toupper(removed)
[16:04:40.855]                 for (kk in seq_along(NAMES)) {
[16:04:40.855]                   name <- removed[[kk]]
[16:04:40.855]                   NAME <- NAMES[[kk]]
[16:04:40.855]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.855]                     next
[16:04:40.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.855]                 }
[16:04:40.855]                 if (length(args) > 0) 
[16:04:40.855]                   base::do.call(base::Sys.setenv, args = args)
[16:04:40.855]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:40.855]             }
[16:04:40.855]             else {
[16:04:40.855]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:40.855]             }
[16:04:40.855]             {
[16:04:40.855]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:40.855]                   0L) {
[16:04:40.855]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:40.855]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:40.855]                   base::options(opts)
[16:04:40.855]                 }
[16:04:40.855]                 {
[16:04:40.855]                   {
[16:04:40.855]                     NULL
[16:04:40.855]                     RNGkind("Mersenne-Twister")
[16:04:40.855]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:40.855]                       inherits = FALSE)
[16:04:40.855]                   }
[16:04:40.855]                   options(future.plan = NULL)
[16:04:40.855]                   if (is.na(NA_character_)) 
[16:04:40.855]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.855]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:40.855]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:40.855]                   {
[16:04:40.855]                     future <- SequentialFuture(..., envir = envir)
[16:04:40.855]                     if (!future$lazy) 
[16:04:40.855]                       future <- run(future)
[16:04:40.855]                     invisible(future)
[16:04:40.855]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:40.855]                 }
[16:04:40.855]             }
[16:04:40.855]         }
[16:04:40.855]     })
[16:04:40.855]     if (TRUE) {
[16:04:40.855]         base::sink(type = "output", split = FALSE)
[16:04:40.855]         if (TRUE) {
[16:04:40.855]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:40.855]         }
[16:04:40.855]         else {
[16:04:40.855]             ...future.result["stdout"] <- base::list(NULL)
[16:04:40.855]         }
[16:04:40.855]         base::close(...future.stdout)
[16:04:40.855]         ...future.stdout <- NULL
[16:04:40.855]     }
[16:04:40.855]     ...future.result$conditions <- ...future.conditions
[16:04:40.855]     ...future.result$finished <- base::Sys.time()
[16:04:40.855]     ...future.result
[16:04:40.855] }
[16:04:40.856] plan(): Setting new future strategy stack:
[16:04:40.856] List of future strategies:
[16:04:40.856] 1. sequential:
[16:04:40.856]    - args: function (..., envir = parent.frame())
[16:04:40.856]    - tweaked: FALSE
[16:04:40.856]    - call: NULL
[16:04:40.857] plan(): nbrOfWorkers() = 1
[16:04:40.857] plan(): Setting new future strategy stack:
[16:04:40.858] List of future strategies:
[16:04:40.858] 1. sequential:
[16:04:40.858]    - args: function (..., envir = parent.frame())
[16:04:40.858]    - tweaked: FALSE
[16:04:40.858]    - call: plan(strategy)
[16:04:40.858] plan(): nbrOfWorkers() = 1
[16:04:40.858] SequentialFuture started (and completed)
[16:04:40.858] - Launch lazy future ... done
[16:04:40.858] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874d142c68> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874d8f7f10> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874d142c68> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874d8f7f10> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:04:40.864] resolved() for ‘SequentialFuture’ ...
[16:04:40.864] - state: ‘finished’
[16:04:40.864] - run: TRUE
[16:04:40.865] - result: ‘FutureResult’
[16:04:40.865] resolved() for ‘SequentialFuture’ ... done
[16:04:40.865] resolved() for ‘SequentialFuture’ ...
[16:04:40.865] - state: ‘finished’
[16:04:40.865] - run: TRUE
[16:04:40.865] - result: ‘FutureResult’
[16:04:40.865] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:40.866] resolve() on list ...
[16:04:40.866]  recursive: 0
[16:04:40.866]  length: 6
[16:04:40.867]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:40.867] signalConditionsASAP(numeric, pos=1) ...
[16:04:40.867] - nx: 6
[16:04:40.867] - relay: TRUE
[16:04:40.867] - stdout: TRUE
[16:04:40.867] - signal: TRUE
[16:04:40.867] - resignal: FALSE
[16:04:40.867] - force: TRUE
[16:04:40.867] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.867] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.867]  - until=2
[16:04:40.868]  - relaying element #2
[16:04:40.868] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.868] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.868] signalConditionsASAP(NULL, pos=1) ... done
[16:04:40.868]  length: 5 (resolved future 1)
[16:04:40.868] resolved() for ‘SequentialFuture’ ...
[16:04:40.868] - state: ‘finished’
[16:04:40.868] - run: TRUE
[16:04:40.868] - result: ‘FutureResult’
[16:04:40.868] resolved() for ‘SequentialFuture’ ... done
[16:04:40.868] Future #2
[16:04:40.869] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:40.869] - nx: 6
[16:04:40.869] - relay: TRUE
[16:04:40.869] - stdout: TRUE
[16:04:40.869] - signal: TRUE
[16:04:40.869] - resignal: FALSE
[16:04:40.869] - force: TRUE
[16:04:40.869] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.869] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.870]  - until=2
[16:04:40.870]  - relaying element #2
[16:04:40.870] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.870] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.870] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:40.870]  length: 4 (resolved future 2)
[16:04:40.870] resolved() for ‘SequentialFuture’ ...
[16:04:40.872] - state: ‘finished’
[16:04:40.872] - run: TRUE
[16:04:40.872] - result: ‘FutureResult’
[16:04:40.872] resolved() for ‘SequentialFuture’ ... done
[16:04:40.872] Future #3
[16:04:40.872] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:40.873] - nx: 6
[16:04:40.873] - relay: TRUE
[16:04:40.873] - stdout: TRUE
[16:04:40.873] - signal: TRUE
[16:04:40.873] - resignal: FALSE
[16:04:40.873] - force: TRUE
[16:04:40.873] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.873] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.873]  - until=3
[16:04:40.873]  - relaying element #3
[16:04:40.873] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.874] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.874] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:40.874]  length: 3 (resolved future 3)
[16:04:40.874] signalConditionsASAP(NULL, pos=4) ...
[16:04:40.874] - nx: 6
[16:04:40.874] - relay: TRUE
[16:04:40.874] - stdout: TRUE
[16:04:40.874] - signal: TRUE
[16:04:40.874] - resignal: FALSE
[16:04:40.874] - force: TRUE
[16:04:40.874] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.874] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.875]  - until=5
[16:04:40.875]  - relaying element #5
[16:04:40.875] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:40.875] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.875] signalConditionsASAP(NULL, pos=4) ... done
[16:04:40.875]  length: 2 (resolved future 4)
[16:04:40.875] signalConditionsASAP(NULL, pos=5) ...
[16:04:40.875] - nx: 6
[16:04:40.875] - relay: TRUE
[16:04:40.875] - stdout: TRUE
[16:04:40.875] - signal: TRUE
[16:04:40.875] - resignal: FALSE
[16:04:40.876] - force: TRUE
[16:04:40.876] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:40.876] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.876]  - until=6
[16:04:40.876]  - relaying element #6
[16:04:40.876] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:40.876] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.876] signalConditionsASAP(NULL, pos=5) ... done
[16:04:40.876]  length: 1 (resolved future 5)
[16:04:40.876] signalConditionsASAP(numeric, pos=6) ...
[16:04:40.876] - nx: 6
[16:04:40.876] - relay: TRUE
[16:04:40.876] - stdout: TRUE
[16:04:40.877] - signal: TRUE
[16:04:40.877] - resignal: FALSE
[16:04:40.877] - force: TRUE
[16:04:40.877] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:40.877] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.877]  - until=6
[16:04:40.877] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:40.877] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.877] signalConditionsASAP(numeric, pos=6) ... done
[16:04:40.877]  length: 0 (resolved future 6)
[16:04:40.877] Relaying remaining futures
[16:04:40.877] signalConditionsASAP(NULL, pos=0) ...
[16:04:40.878] - nx: 6
[16:04:40.878] - relay: TRUE
[16:04:40.878] - stdout: TRUE
[16:04:40.878] - signal: TRUE
[16:04:40.878] - resignal: FALSE
[16:04:40.878] - force: TRUE
[16:04:40.878] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:40.878] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:40.878] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:40.878] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.878] signalConditionsASAP(NULL, pos=0) ... done
[16:04:40.878] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[16:04:40.881] getGlobalsAndPackages() ...
[16:04:40.881] Searching for globals...
[16:04:40.881] 
[16:04:40.881] Searching for globals ... DONE
[16:04:40.881] - globals: [0] <none>
[16:04:40.881] getGlobalsAndPackages() ... DONE
[16:04:40.881] run() for ‘Future’ ...
[16:04:40.881] - state: ‘created’
[16:04:40.882] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:40.882] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:40.882] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:40.882]   - Field: ‘label’
[16:04:40.882]   - Field: ‘local’
[16:04:40.882]   - Field: ‘owner’
[16:04:40.882]   - Field: ‘envir’
[16:04:40.882]   - Field: ‘packages’
[16:04:40.882]   - Field: ‘gc’
[16:04:40.883]   - Field: ‘conditions’
[16:04:40.883]   - Field: ‘expr’
[16:04:40.883]   - Field: ‘uuid’
[16:04:40.883]   - Field: ‘seed’
[16:04:40.883]   - Field: ‘version’
[16:04:40.883]   - Field: ‘result’
[16:04:40.883]   - Field: ‘asynchronous’
[16:04:40.883]   - Field: ‘calls’
[16:04:40.883]   - Field: ‘globals’
[16:04:40.883]   - Field: ‘stdout’
[16:04:40.883]   - Field: ‘earlySignal’
[16:04:40.884]   - Field: ‘lazy’
[16:04:40.884]   - Field: ‘state’
[16:04:40.884] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:40.884] - Launch lazy future ...
[16:04:40.884] Packages needed by the future expression (n = 0): <none>
[16:04:40.884] Packages needed by future strategies (n = 0): <none>
[16:04:40.884] {
[16:04:40.884]     {
[16:04:40.884]         {
[16:04:40.884]             ...future.startTime <- base::Sys.time()
[16:04:40.884]             {
[16:04:40.884]                 {
[16:04:40.884]                   {
[16:04:40.884]                     base::local({
[16:04:40.884]                       has_future <- base::requireNamespace("future", 
[16:04:40.884]                         quietly = TRUE)
[16:04:40.884]                       if (has_future) {
[16:04:40.884]                         ns <- base::getNamespace("future")
[16:04:40.884]                         version <- ns[[".package"]][["version"]]
[16:04:40.884]                         if (is.null(version)) 
[16:04:40.884]                           version <- utils::packageVersion("future")
[16:04:40.884]                       }
[16:04:40.884]                       else {
[16:04:40.884]                         version <- NULL
[16:04:40.884]                       }
[16:04:40.884]                       if (!has_future || version < "1.8.0") {
[16:04:40.884]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:40.884]                           "", base::R.version$version.string), 
[16:04:40.884]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:40.884]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:40.884]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:40.884]                             "release", "version")], collapse = " "), 
[16:04:40.884]                           hostname = base::Sys.info()[["nodename"]])
[16:04:40.884]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:40.884]                           info)
[16:04:40.884]                         info <- base::paste(info, collapse = "; ")
[16:04:40.884]                         if (!has_future) {
[16:04:40.884]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:40.884]                             info)
[16:04:40.884]                         }
[16:04:40.884]                         else {
[16:04:40.884]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:40.884]                             info, version)
[16:04:40.884]                         }
[16:04:40.884]                         base::stop(msg)
[16:04:40.884]                       }
[16:04:40.884]                     })
[16:04:40.884]                   }
[16:04:40.884]                   options(future.plan = NULL)
[16:04:40.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:40.884]                 }
[16:04:40.884]                 ...future.workdir <- getwd()
[16:04:40.884]             }
[16:04:40.884]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:40.884]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:40.884]         }
[16:04:40.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:40.884]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:40.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:40.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:40.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:40.884]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:40.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:40.884]             base::names(...future.oldOptions))
[16:04:40.884]     }
[16:04:40.884]     if (FALSE) {
[16:04:40.884]     }
[16:04:40.884]     else {
[16:04:40.884]         if (TRUE) {
[16:04:40.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:40.884]                 open = "w")
[16:04:40.884]         }
[16:04:40.884]         else {
[16:04:40.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:40.884]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:40.884]         }
[16:04:40.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:40.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:40.884]             base::sink(type = "output", split = FALSE)
[16:04:40.884]             base::close(...future.stdout)
[16:04:40.884]         }, add = TRUE)
[16:04:40.884]     }
[16:04:40.884]     ...future.frame <- base::sys.nframe()
[16:04:40.884]     ...future.conditions <- base::list()
[16:04:40.884]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:40.884]     if (FALSE) {
[16:04:40.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:40.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:40.884]     }
[16:04:40.884]     ...future.result <- base::tryCatch({
[16:04:40.884]         base::withCallingHandlers({
[16:04:40.884]             ...future.value <- base::withVisible(base::local(2))
[16:04:40.884]             future::FutureResult(value = ...future.value$value, 
[16:04:40.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.884]                   ...future.rng), globalenv = if (FALSE) 
[16:04:40.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:40.884]                     ...future.globalenv.names))
[16:04:40.884]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:40.884]         }, condition = base::local({
[16:04:40.884]             c <- base::c
[16:04:40.884]             inherits <- base::inherits
[16:04:40.884]             invokeRestart <- base::invokeRestart
[16:04:40.884]             length <- base::length
[16:04:40.884]             list <- base::list
[16:04:40.884]             seq.int <- base::seq.int
[16:04:40.884]             signalCondition <- base::signalCondition
[16:04:40.884]             sys.calls <- base::sys.calls
[16:04:40.884]             `[[` <- base::`[[`
[16:04:40.884]             `+` <- base::`+`
[16:04:40.884]             `<<-` <- base::`<<-`
[16:04:40.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:40.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:40.884]                   3L)]
[16:04:40.884]             }
[16:04:40.884]             function(cond) {
[16:04:40.884]                 is_error <- inherits(cond, "error")
[16:04:40.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:40.884]                   NULL)
[16:04:40.884]                 if (is_error) {
[16:04:40.884]                   sessionInformation <- function() {
[16:04:40.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:40.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:40.884]                       search = base::search(), system = base::Sys.info())
[16:04:40.884]                   }
[16:04:40.884]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:40.884]                     cond$call), session = sessionInformation(), 
[16:04:40.884]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:40.884]                   signalCondition(cond)
[16:04:40.884]                 }
[16:04:40.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:40.884]                 "immediateCondition"))) {
[16:04:40.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:40.884]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:40.884]                   if (TRUE && !signal) {
[16:04:40.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.884]                     {
[16:04:40.884]                       inherits <- base::inherits
[16:04:40.884]                       invokeRestart <- base::invokeRestart
[16:04:40.884]                       is.null <- base::is.null
[16:04:40.884]                       muffled <- FALSE
[16:04:40.884]                       if (inherits(cond, "message")) {
[16:04:40.884]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.884]                         if (muffled) 
[16:04:40.884]                           invokeRestart("muffleMessage")
[16:04:40.884]                       }
[16:04:40.884]                       else if (inherits(cond, "warning")) {
[16:04:40.884]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.884]                         if (muffled) 
[16:04:40.884]                           invokeRestart("muffleWarning")
[16:04:40.884]                       }
[16:04:40.884]                       else if (inherits(cond, "condition")) {
[16:04:40.884]                         if (!is.null(pattern)) {
[16:04:40.884]                           computeRestarts <- base::computeRestarts
[16:04:40.884]                           grepl <- base::grepl
[16:04:40.884]                           restarts <- computeRestarts(cond)
[16:04:40.884]                           for (restart in restarts) {
[16:04:40.884]                             name <- restart$name
[16:04:40.884]                             if (is.null(name)) 
[16:04:40.884]                               next
[16:04:40.884]                             if (!grepl(pattern, name)) 
[16:04:40.884]                               next
[16:04:40.884]                             invokeRestart(restart)
[16:04:40.884]                             muffled <- TRUE
[16:04:40.884]                             break
[16:04:40.884]                           }
[16:04:40.884]                         }
[16:04:40.884]                       }
[16:04:40.884]                       invisible(muffled)
[16:04:40.884]                     }
[16:04:40.884]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.884]                   }
[16:04:40.884]                 }
[16:04:40.884]                 else {
[16:04:40.884]                   if (TRUE) {
[16:04:40.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.884]                     {
[16:04:40.884]                       inherits <- base::inherits
[16:04:40.884]                       invokeRestart <- base::invokeRestart
[16:04:40.884]                       is.null <- base::is.null
[16:04:40.884]                       muffled <- FALSE
[16:04:40.884]                       if (inherits(cond, "message")) {
[16:04:40.884]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.884]                         if (muffled) 
[16:04:40.884]                           invokeRestart("muffleMessage")
[16:04:40.884]                       }
[16:04:40.884]                       else if (inherits(cond, "warning")) {
[16:04:40.884]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.884]                         if (muffled) 
[16:04:40.884]                           invokeRestart("muffleWarning")
[16:04:40.884]                       }
[16:04:40.884]                       else if (inherits(cond, "condition")) {
[16:04:40.884]                         if (!is.null(pattern)) {
[16:04:40.884]                           computeRestarts <- base::computeRestarts
[16:04:40.884]                           grepl <- base::grepl
[16:04:40.884]                           restarts <- computeRestarts(cond)
[16:04:40.884]                           for (restart in restarts) {
[16:04:40.884]                             name <- restart$name
[16:04:40.884]                             if (is.null(name)) 
[16:04:40.884]                               next
[16:04:40.884]                             if (!grepl(pattern, name)) 
[16:04:40.884]                               next
[16:04:40.884]                             invokeRestart(restart)
[16:04:40.884]                             muffled <- TRUE
[16:04:40.884]                             break
[16:04:40.884]                           }
[16:04:40.884]                         }
[16:04:40.884]                       }
[16:04:40.884]                       invisible(muffled)
[16:04:40.884]                     }
[16:04:40.884]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.884]                   }
[16:04:40.884]                 }
[16:04:40.884]             }
[16:04:40.884]         }))
[16:04:40.884]     }, error = function(ex) {
[16:04:40.884]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:40.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.884]                 ...future.rng), started = ...future.startTime, 
[16:04:40.884]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:40.884]             version = "1.8"), class = "FutureResult")
[16:04:40.884]     }, finally = {
[16:04:40.884]         if (!identical(...future.workdir, getwd())) 
[16:04:40.884]             setwd(...future.workdir)
[16:04:40.884]         {
[16:04:40.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:40.884]                 ...future.oldOptions$nwarnings <- NULL
[16:04:40.884]             }
[16:04:40.884]             base::options(...future.oldOptions)
[16:04:40.884]             if (.Platform$OS.type == "windows") {
[16:04:40.884]                 old_names <- names(...future.oldEnvVars)
[16:04:40.884]                 envs <- base::Sys.getenv()
[16:04:40.884]                 names <- names(envs)
[16:04:40.884]                 common <- intersect(names, old_names)
[16:04:40.884]                 added <- setdiff(names, old_names)
[16:04:40.884]                 removed <- setdiff(old_names, names)
[16:04:40.884]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:40.884]                   envs[common]]
[16:04:40.884]                 NAMES <- toupper(changed)
[16:04:40.884]                 args <- list()
[16:04:40.884]                 for (kk in seq_along(NAMES)) {
[16:04:40.884]                   name <- changed[[kk]]
[16:04:40.884]                   NAME <- NAMES[[kk]]
[16:04:40.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.884]                     next
[16:04:40.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.884]                 }
[16:04:40.884]                 NAMES <- toupper(added)
[16:04:40.884]                 for (kk in seq_along(NAMES)) {
[16:04:40.884]                   name <- added[[kk]]
[16:04:40.884]                   NAME <- NAMES[[kk]]
[16:04:40.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.884]                     next
[16:04:40.884]                   args[[name]] <- ""
[16:04:40.884]                 }
[16:04:40.884]                 NAMES <- toupper(removed)
[16:04:40.884]                 for (kk in seq_along(NAMES)) {
[16:04:40.884]                   name <- removed[[kk]]
[16:04:40.884]                   NAME <- NAMES[[kk]]
[16:04:40.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.884]                     next
[16:04:40.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.884]                 }
[16:04:40.884]                 if (length(args) > 0) 
[16:04:40.884]                   base::do.call(base::Sys.setenv, args = args)
[16:04:40.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:40.884]             }
[16:04:40.884]             else {
[16:04:40.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:40.884]             }
[16:04:40.884]             {
[16:04:40.884]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:40.884]                   0L) {
[16:04:40.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:40.884]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:40.884]                   base::options(opts)
[16:04:40.884]                 }
[16:04:40.884]                 {
[16:04:40.884]                   {
[16:04:40.884]                     NULL
[16:04:40.884]                     RNGkind("Mersenne-Twister")
[16:04:40.884]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:40.884]                       inherits = FALSE)
[16:04:40.884]                   }
[16:04:40.884]                   options(future.plan = NULL)
[16:04:40.884]                   if (is.na(NA_character_)) 
[16:04:40.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:40.884]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:40.884]                   {
[16:04:40.884]                     future <- SequentialFuture(..., envir = envir)
[16:04:40.884]                     if (!future$lazy) 
[16:04:40.884]                       future <- run(future)
[16:04:40.884]                     invisible(future)
[16:04:40.884]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:40.884]                 }
[16:04:40.884]             }
[16:04:40.884]         }
[16:04:40.884]     })
[16:04:40.884]     if (TRUE) {
[16:04:40.884]         base::sink(type = "output", split = FALSE)
[16:04:40.884]         if (TRUE) {
[16:04:40.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:40.884]         }
[16:04:40.884]         else {
[16:04:40.884]             ...future.result["stdout"] <- base::list(NULL)
[16:04:40.884]         }
[16:04:40.884]         base::close(...future.stdout)
[16:04:40.884]         ...future.stdout <- NULL
[16:04:40.884]     }
[16:04:40.884]     ...future.result$conditions <- ...future.conditions
[16:04:40.884]     ...future.result$finished <- base::Sys.time()
[16:04:40.884]     ...future.result
[16:04:40.884] }
[16:04:40.886] plan(): Setting new future strategy stack:
[16:04:40.886] List of future strategies:
[16:04:40.886] 1. sequential:
[16:04:40.886]    - args: function (..., envir = parent.frame())
[16:04:40.886]    - tweaked: FALSE
[16:04:40.886]    - call: NULL
[16:04:40.887] plan(): nbrOfWorkers() = 1
[16:04:40.887] plan(): Setting new future strategy stack:
[16:04:40.887] List of future strategies:
[16:04:40.887] 1. sequential:
[16:04:40.887]    - args: function (..., envir = parent.frame())
[16:04:40.887]    - tweaked: FALSE
[16:04:40.887]    - call: plan(strategy)
[16:04:40.888] plan(): nbrOfWorkers() = 1
[16:04:40.888] SequentialFuture started (and completed)
[16:04:40.888] - Launch lazy future ... done
[16:04:40.888] run() for ‘SequentialFuture’ ... done
[16:04:40.888] getGlobalsAndPackages() ...
[16:04:40.888] Searching for globals...
[16:04:40.889] 
[16:04:40.889] Searching for globals ... DONE
[16:04:40.889] - globals: [0] <none>
[16:04:40.889] getGlobalsAndPackages() ... DONE
[16:04:40.889] run() for ‘Future’ ...
[16:04:40.889] - state: ‘created’
[16:04:40.890] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:40.890] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:40.890] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:40.890]   - Field: ‘label’
[16:04:40.890]   - Field: ‘local’
[16:04:40.890]   - Field: ‘owner’
[16:04:40.890]   - Field: ‘envir’
[16:04:40.890]   - Field: ‘packages’
[16:04:40.890]   - Field: ‘gc’
[16:04:40.890]   - Field: ‘conditions’
[16:04:40.891]   - Field: ‘expr’
[16:04:40.891]   - Field: ‘uuid’
[16:04:40.891]   - Field: ‘seed’
[16:04:40.891]   - Field: ‘version’
[16:04:40.891]   - Field: ‘result’
[16:04:40.891]   - Field: ‘asynchronous’
[16:04:40.891]   - Field: ‘calls’
[16:04:40.891]   - Field: ‘globals’
[16:04:40.891]   - Field: ‘stdout’
[16:04:40.891]   - Field: ‘earlySignal’
[16:04:40.892]   - Field: ‘lazy’
[16:04:40.892]   - Field: ‘state’
[16:04:40.892] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:40.892] - Launch lazy future ...
[16:04:40.892] Packages needed by the future expression (n = 0): <none>
[16:04:40.892] Packages needed by future strategies (n = 0): <none>
[16:04:40.892] {
[16:04:40.892]     {
[16:04:40.892]         {
[16:04:40.892]             ...future.startTime <- base::Sys.time()
[16:04:40.892]             {
[16:04:40.892]                 {
[16:04:40.892]                   {
[16:04:40.892]                     base::local({
[16:04:40.892]                       has_future <- base::requireNamespace("future", 
[16:04:40.892]                         quietly = TRUE)
[16:04:40.892]                       if (has_future) {
[16:04:40.892]                         ns <- base::getNamespace("future")
[16:04:40.892]                         version <- ns[[".package"]][["version"]]
[16:04:40.892]                         if (is.null(version)) 
[16:04:40.892]                           version <- utils::packageVersion("future")
[16:04:40.892]                       }
[16:04:40.892]                       else {
[16:04:40.892]                         version <- NULL
[16:04:40.892]                       }
[16:04:40.892]                       if (!has_future || version < "1.8.0") {
[16:04:40.892]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:40.892]                           "", base::R.version$version.string), 
[16:04:40.892]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:40.892]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:40.892]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:40.892]                             "release", "version")], collapse = " "), 
[16:04:40.892]                           hostname = base::Sys.info()[["nodename"]])
[16:04:40.892]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:40.892]                           info)
[16:04:40.892]                         info <- base::paste(info, collapse = "; ")
[16:04:40.892]                         if (!has_future) {
[16:04:40.892]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:40.892]                             info)
[16:04:40.892]                         }
[16:04:40.892]                         else {
[16:04:40.892]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:40.892]                             info, version)
[16:04:40.892]                         }
[16:04:40.892]                         base::stop(msg)
[16:04:40.892]                       }
[16:04:40.892]                     })
[16:04:40.892]                   }
[16:04:40.892]                   options(future.plan = NULL)
[16:04:40.892]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.892]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:40.892]                 }
[16:04:40.892]                 ...future.workdir <- getwd()
[16:04:40.892]             }
[16:04:40.892]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:40.892]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:40.892]         }
[16:04:40.892]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:40.892]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:40.892]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:40.892]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:40.892]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:40.892]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:40.892]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:40.892]             base::names(...future.oldOptions))
[16:04:40.892]     }
[16:04:40.892]     if (FALSE) {
[16:04:40.892]     }
[16:04:40.892]     else {
[16:04:40.892]         if (TRUE) {
[16:04:40.892]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:40.892]                 open = "w")
[16:04:40.892]         }
[16:04:40.892]         else {
[16:04:40.892]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:40.892]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:40.892]         }
[16:04:40.892]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:40.892]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:40.892]             base::sink(type = "output", split = FALSE)
[16:04:40.892]             base::close(...future.stdout)
[16:04:40.892]         }, add = TRUE)
[16:04:40.892]     }
[16:04:40.892]     ...future.frame <- base::sys.nframe()
[16:04:40.892]     ...future.conditions <- base::list()
[16:04:40.892]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:40.892]     if (FALSE) {
[16:04:40.892]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:40.892]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:40.892]     }
[16:04:40.892]     ...future.result <- base::tryCatch({
[16:04:40.892]         base::withCallingHandlers({
[16:04:40.892]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:40.892]             future::FutureResult(value = ...future.value$value, 
[16:04:40.892]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.892]                   ...future.rng), globalenv = if (FALSE) 
[16:04:40.892]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:40.892]                     ...future.globalenv.names))
[16:04:40.892]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:40.892]         }, condition = base::local({
[16:04:40.892]             c <- base::c
[16:04:40.892]             inherits <- base::inherits
[16:04:40.892]             invokeRestart <- base::invokeRestart
[16:04:40.892]             length <- base::length
[16:04:40.892]             list <- base::list
[16:04:40.892]             seq.int <- base::seq.int
[16:04:40.892]             signalCondition <- base::signalCondition
[16:04:40.892]             sys.calls <- base::sys.calls
[16:04:40.892]             `[[` <- base::`[[`
[16:04:40.892]             `+` <- base::`+`
[16:04:40.892]             `<<-` <- base::`<<-`
[16:04:40.892]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:40.892]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:40.892]                   3L)]
[16:04:40.892]             }
[16:04:40.892]             function(cond) {
[16:04:40.892]                 is_error <- inherits(cond, "error")
[16:04:40.892]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:40.892]                   NULL)
[16:04:40.892]                 if (is_error) {
[16:04:40.892]                   sessionInformation <- function() {
[16:04:40.892]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:40.892]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:40.892]                       search = base::search(), system = base::Sys.info())
[16:04:40.892]                   }
[16:04:40.892]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.892]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:40.892]                     cond$call), session = sessionInformation(), 
[16:04:40.892]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:40.892]                   signalCondition(cond)
[16:04:40.892]                 }
[16:04:40.892]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:40.892]                 "immediateCondition"))) {
[16:04:40.892]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:40.892]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.892]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:40.892]                   if (TRUE && !signal) {
[16:04:40.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.892]                     {
[16:04:40.892]                       inherits <- base::inherits
[16:04:40.892]                       invokeRestart <- base::invokeRestart
[16:04:40.892]                       is.null <- base::is.null
[16:04:40.892]                       muffled <- FALSE
[16:04:40.892]                       if (inherits(cond, "message")) {
[16:04:40.892]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.892]                         if (muffled) 
[16:04:40.892]                           invokeRestart("muffleMessage")
[16:04:40.892]                       }
[16:04:40.892]                       else if (inherits(cond, "warning")) {
[16:04:40.892]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.892]                         if (muffled) 
[16:04:40.892]                           invokeRestart("muffleWarning")
[16:04:40.892]                       }
[16:04:40.892]                       else if (inherits(cond, "condition")) {
[16:04:40.892]                         if (!is.null(pattern)) {
[16:04:40.892]                           computeRestarts <- base::computeRestarts
[16:04:40.892]                           grepl <- base::grepl
[16:04:40.892]                           restarts <- computeRestarts(cond)
[16:04:40.892]                           for (restart in restarts) {
[16:04:40.892]                             name <- restart$name
[16:04:40.892]                             if (is.null(name)) 
[16:04:40.892]                               next
[16:04:40.892]                             if (!grepl(pattern, name)) 
[16:04:40.892]                               next
[16:04:40.892]                             invokeRestart(restart)
[16:04:40.892]                             muffled <- TRUE
[16:04:40.892]                             break
[16:04:40.892]                           }
[16:04:40.892]                         }
[16:04:40.892]                       }
[16:04:40.892]                       invisible(muffled)
[16:04:40.892]                     }
[16:04:40.892]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.892]                   }
[16:04:40.892]                 }
[16:04:40.892]                 else {
[16:04:40.892]                   if (TRUE) {
[16:04:40.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.892]                     {
[16:04:40.892]                       inherits <- base::inherits
[16:04:40.892]                       invokeRestart <- base::invokeRestart
[16:04:40.892]                       is.null <- base::is.null
[16:04:40.892]                       muffled <- FALSE
[16:04:40.892]                       if (inherits(cond, "message")) {
[16:04:40.892]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.892]                         if (muffled) 
[16:04:40.892]                           invokeRestart("muffleMessage")
[16:04:40.892]                       }
[16:04:40.892]                       else if (inherits(cond, "warning")) {
[16:04:40.892]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.892]                         if (muffled) 
[16:04:40.892]                           invokeRestart("muffleWarning")
[16:04:40.892]                       }
[16:04:40.892]                       else if (inherits(cond, "condition")) {
[16:04:40.892]                         if (!is.null(pattern)) {
[16:04:40.892]                           computeRestarts <- base::computeRestarts
[16:04:40.892]                           grepl <- base::grepl
[16:04:40.892]                           restarts <- computeRestarts(cond)
[16:04:40.892]                           for (restart in restarts) {
[16:04:40.892]                             name <- restart$name
[16:04:40.892]                             if (is.null(name)) 
[16:04:40.892]                               next
[16:04:40.892]                             if (!grepl(pattern, name)) 
[16:04:40.892]                               next
[16:04:40.892]                             invokeRestart(restart)
[16:04:40.892]                             muffled <- TRUE
[16:04:40.892]                             break
[16:04:40.892]                           }
[16:04:40.892]                         }
[16:04:40.892]                       }
[16:04:40.892]                       invisible(muffled)
[16:04:40.892]                     }
[16:04:40.892]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.892]                   }
[16:04:40.892]                 }
[16:04:40.892]             }
[16:04:40.892]         }))
[16:04:40.892]     }, error = function(ex) {
[16:04:40.892]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:40.892]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.892]                 ...future.rng), started = ...future.startTime, 
[16:04:40.892]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:40.892]             version = "1.8"), class = "FutureResult")
[16:04:40.892]     }, finally = {
[16:04:40.892]         if (!identical(...future.workdir, getwd())) 
[16:04:40.892]             setwd(...future.workdir)
[16:04:40.892]         {
[16:04:40.892]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:40.892]                 ...future.oldOptions$nwarnings <- NULL
[16:04:40.892]             }
[16:04:40.892]             base::options(...future.oldOptions)
[16:04:40.892]             if (.Platform$OS.type == "windows") {
[16:04:40.892]                 old_names <- names(...future.oldEnvVars)
[16:04:40.892]                 envs <- base::Sys.getenv()
[16:04:40.892]                 names <- names(envs)
[16:04:40.892]                 common <- intersect(names, old_names)
[16:04:40.892]                 added <- setdiff(names, old_names)
[16:04:40.892]                 removed <- setdiff(old_names, names)
[16:04:40.892]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:40.892]                   envs[common]]
[16:04:40.892]                 NAMES <- toupper(changed)
[16:04:40.892]                 args <- list()
[16:04:40.892]                 for (kk in seq_along(NAMES)) {
[16:04:40.892]                   name <- changed[[kk]]
[16:04:40.892]                   NAME <- NAMES[[kk]]
[16:04:40.892]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.892]                     next
[16:04:40.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.892]                 }
[16:04:40.892]                 NAMES <- toupper(added)
[16:04:40.892]                 for (kk in seq_along(NAMES)) {
[16:04:40.892]                   name <- added[[kk]]
[16:04:40.892]                   NAME <- NAMES[[kk]]
[16:04:40.892]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.892]                     next
[16:04:40.892]                   args[[name]] <- ""
[16:04:40.892]                 }
[16:04:40.892]                 NAMES <- toupper(removed)
[16:04:40.892]                 for (kk in seq_along(NAMES)) {
[16:04:40.892]                   name <- removed[[kk]]
[16:04:40.892]                   NAME <- NAMES[[kk]]
[16:04:40.892]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.892]                     next
[16:04:40.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.892]                 }
[16:04:40.892]                 if (length(args) > 0) 
[16:04:40.892]                   base::do.call(base::Sys.setenv, args = args)
[16:04:40.892]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:40.892]             }
[16:04:40.892]             else {
[16:04:40.892]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:40.892]             }
[16:04:40.892]             {
[16:04:40.892]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:40.892]                   0L) {
[16:04:40.892]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:40.892]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:40.892]                   base::options(opts)
[16:04:40.892]                 }
[16:04:40.892]                 {
[16:04:40.892]                   {
[16:04:40.892]                     NULL
[16:04:40.892]                     RNGkind("Mersenne-Twister")
[16:04:40.892]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:40.892]                       inherits = FALSE)
[16:04:40.892]                   }
[16:04:40.892]                   options(future.plan = NULL)
[16:04:40.892]                   if (is.na(NA_character_)) 
[16:04:40.892]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.892]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:40.892]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:40.892]                   {
[16:04:40.892]                     future <- SequentialFuture(..., envir = envir)
[16:04:40.892]                     if (!future$lazy) 
[16:04:40.892]                       future <- run(future)
[16:04:40.892]                     invisible(future)
[16:04:40.892]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:40.892]                 }
[16:04:40.892]             }
[16:04:40.892]         }
[16:04:40.892]     })
[16:04:40.892]     if (TRUE) {
[16:04:40.892]         base::sink(type = "output", split = FALSE)
[16:04:40.892]         if (TRUE) {
[16:04:40.892]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:40.892]         }
[16:04:40.892]         else {
[16:04:40.892]             ...future.result["stdout"] <- base::list(NULL)
[16:04:40.892]         }
[16:04:40.892]         base::close(...future.stdout)
[16:04:40.892]         ...future.stdout <- NULL
[16:04:40.892]     }
[16:04:40.892]     ...future.result$conditions <- ...future.conditions
[16:04:40.892]     ...future.result$finished <- base::Sys.time()
[16:04:40.892]     ...future.result
[16:04:40.892] }
[16:04:40.894] plan(): Setting new future strategy stack:
[16:04:40.894] List of future strategies:
[16:04:40.894] 1. sequential:
[16:04:40.894]    - args: function (..., envir = parent.frame())
[16:04:40.894]    - tweaked: FALSE
[16:04:40.894]    - call: NULL
[16:04:40.895] plan(): nbrOfWorkers() = 1
[16:04:40.895] plan(): Setting new future strategy stack:
[16:04:40.896] List of future strategies:
[16:04:40.896] 1. sequential:
[16:04:40.896]    - args: function (..., envir = parent.frame())
[16:04:40.896]    - tweaked: FALSE
[16:04:40.896]    - call: plan(strategy)
[16:04:40.896] plan(): nbrOfWorkers() = 1
[16:04:40.896] SequentialFuture started (and completed)
[16:04:40.896] - Launch lazy future ... done
[16:04:40.896] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874d810930> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874dcb2960> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874d810930> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874dcb2960> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:04:40.902] resolved() for ‘SequentialFuture’ ...
[16:04:40.902] - state: ‘finished’
[16:04:40.902] - run: TRUE
[16:04:40.902] - result: ‘FutureResult’
[16:04:40.903] resolved() for ‘SequentialFuture’ ... done
[16:04:40.903] resolved() for ‘SequentialFuture’ ...
[16:04:40.903] - state: ‘finished’
[16:04:40.903] - run: TRUE
[16:04:40.903] - result: ‘FutureResult’
[16:04:40.903] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:40.905] resolve() on list ...
[16:04:40.905]  recursive: 0
[16:04:40.905]  length: 6
[16:04:40.905]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:40.905] signalConditionsASAP(numeric, pos=1) ...
[16:04:40.905] - nx: 6
[16:04:40.905] - relay: TRUE
[16:04:40.906] - stdout: TRUE
[16:04:40.906] - signal: TRUE
[16:04:40.906] - resignal: FALSE
[16:04:40.906] - force: TRUE
[16:04:40.906] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.906] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.906]  - until=2
[16:04:40.906]  - relaying element #2
[16:04:40.906] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.906] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.906] signalConditionsASAP(NULL, pos=1) ... done
[16:04:40.906]  length: 5 (resolved future 1)
[16:04:40.907] resolved() for ‘SequentialFuture’ ...
[16:04:40.907] - state: ‘finished’
[16:04:40.907] - run: TRUE
[16:04:40.907] - result: ‘FutureResult’
[16:04:40.907] resolved() for ‘SequentialFuture’ ... done
[16:04:40.907] Future #2
[16:04:40.907] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:40.907] - nx: 6
[16:04:40.907] - relay: TRUE
[16:04:40.907] - stdout: TRUE
[16:04:40.908] - signal: TRUE
[16:04:40.908] - resignal: FALSE
[16:04:40.908] - force: TRUE
[16:04:40.908] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.908] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.908]  - until=2
[16:04:40.908]  - relaying element #2
[16:04:40.908] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.908] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.908] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:40.909]  length: 4 (resolved future 2)
[16:04:40.909] resolved() for ‘SequentialFuture’ ...
[16:04:40.909] - state: ‘finished’
[16:04:40.909] - run: TRUE
[16:04:40.909] - result: ‘FutureResult’
[16:04:40.909] resolved() for ‘SequentialFuture’ ... done
[16:04:40.909] Future #3
[16:04:40.909] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:40.909] - nx: 6
[16:04:40.909] - relay: TRUE
[16:04:40.909] - stdout: TRUE
[16:04:40.910] - signal: TRUE
[16:04:40.910] - resignal: FALSE
[16:04:40.910] - force: TRUE
[16:04:40.910] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.910] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.910]  - until=3
[16:04:40.910]  - relaying element #3
[16:04:40.910] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.910] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.910] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:40.910]  length: 3 (resolved future 3)
[16:04:40.911] signalConditionsASAP(NULL, pos=4) ...
[16:04:40.911] - nx: 6
[16:04:40.911] - relay: TRUE
[16:04:40.911] - stdout: TRUE
[16:04:40.911] - signal: TRUE
[16:04:40.911] - resignal: FALSE
[16:04:40.911] - force: TRUE
[16:04:40.911] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.911] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.911]  - until=5
[16:04:40.911]  - relaying element #5
[16:04:40.912] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:40.912] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.912] signalConditionsASAP(NULL, pos=4) ... done
[16:04:40.912]  length: 2 (resolved future 4)
[16:04:40.912] signalConditionsASAP(NULL, pos=5) ...
[16:04:40.912] - nx: 6
[16:04:40.912] - relay: TRUE
[16:04:40.912] - stdout: TRUE
[16:04:40.912] - signal: TRUE
[16:04:40.912] - resignal: FALSE
[16:04:40.912] - force: TRUE
[16:04:40.912] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:40.912] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.913]  - until=6
[16:04:40.913]  - relaying element #6
[16:04:40.913] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:40.913] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.913] signalConditionsASAP(NULL, pos=5) ... done
[16:04:40.913]  length: 1 (resolved future 5)
[16:04:40.913] signalConditionsASAP(numeric, pos=6) ...
[16:04:40.913] - nx: 6
[16:04:40.913] - relay: TRUE
[16:04:40.913] - stdout: TRUE
[16:04:40.913] - signal: TRUE
[16:04:40.913] - resignal: FALSE
[16:04:40.914] - force: TRUE
[16:04:40.914] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:40.914] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.914]  - until=6
[16:04:40.914] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:40.914] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.914] signalConditionsASAP(numeric, pos=6) ... done
[16:04:40.914]  length: 0 (resolved future 6)
[16:04:40.914] Relaying remaining futures
[16:04:40.914] signalConditionsASAP(NULL, pos=0) ...
[16:04:40.914] - nx: 6
[16:04:40.914] - relay: TRUE
[16:04:40.915] - stdout: TRUE
[16:04:40.915] - signal: TRUE
[16:04:40.915] - resignal: FALSE
[16:04:40.915] - force: TRUE
[16:04:40.915] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:40.915] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:40.915] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:40.915] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.915] signalConditionsASAP(NULL, pos=0) ... done
[16:04:40.915] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:04:40.918] getGlobalsAndPackages() ...
[16:04:40.918] Searching for globals...
[16:04:40.919] 
[16:04:40.919] Searching for globals ... DONE
[16:04:40.919] - globals: [0] <none>
[16:04:40.919] getGlobalsAndPackages() ... DONE
[16:04:40.919] run() for ‘Future’ ...
[16:04:40.919] - state: ‘created’
[16:04:40.919] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:40.920] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:40.920] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:40.920]   - Field: ‘label’
[16:04:40.920]   - Field: ‘local’
[16:04:40.920]   - Field: ‘owner’
[16:04:40.920]   - Field: ‘envir’
[16:04:40.920]   - Field: ‘packages’
[16:04:40.920]   - Field: ‘gc’
[16:04:40.920]   - Field: ‘conditions’
[16:04:40.921]   - Field: ‘expr’
[16:04:40.921]   - Field: ‘uuid’
[16:04:40.921]   - Field: ‘seed’
[16:04:40.921]   - Field: ‘version’
[16:04:40.921]   - Field: ‘result’
[16:04:40.921]   - Field: ‘asynchronous’
[16:04:40.921]   - Field: ‘calls’
[16:04:40.921]   - Field: ‘globals’
[16:04:40.921]   - Field: ‘stdout’
[16:04:40.921]   - Field: ‘earlySignal’
[16:04:40.921]   - Field: ‘lazy’
[16:04:40.921]   - Field: ‘state’
[16:04:40.922] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:40.922] - Launch lazy future ...
[16:04:40.922] Packages needed by the future expression (n = 0): <none>
[16:04:40.922] Packages needed by future strategies (n = 0): <none>
[16:04:40.922] {
[16:04:40.922]     {
[16:04:40.922]         {
[16:04:40.922]             ...future.startTime <- base::Sys.time()
[16:04:40.922]             {
[16:04:40.922]                 {
[16:04:40.922]                   {
[16:04:40.922]                     base::local({
[16:04:40.922]                       has_future <- base::requireNamespace("future", 
[16:04:40.922]                         quietly = TRUE)
[16:04:40.922]                       if (has_future) {
[16:04:40.922]                         ns <- base::getNamespace("future")
[16:04:40.922]                         version <- ns[[".package"]][["version"]]
[16:04:40.922]                         if (is.null(version)) 
[16:04:40.922]                           version <- utils::packageVersion("future")
[16:04:40.922]                       }
[16:04:40.922]                       else {
[16:04:40.922]                         version <- NULL
[16:04:40.922]                       }
[16:04:40.922]                       if (!has_future || version < "1.8.0") {
[16:04:40.922]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:40.922]                           "", base::R.version$version.string), 
[16:04:40.922]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:40.922]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:40.922]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:40.922]                             "release", "version")], collapse = " "), 
[16:04:40.922]                           hostname = base::Sys.info()[["nodename"]])
[16:04:40.922]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:40.922]                           info)
[16:04:40.922]                         info <- base::paste(info, collapse = "; ")
[16:04:40.922]                         if (!has_future) {
[16:04:40.922]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:40.922]                             info)
[16:04:40.922]                         }
[16:04:40.922]                         else {
[16:04:40.922]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:40.922]                             info, version)
[16:04:40.922]                         }
[16:04:40.922]                         base::stop(msg)
[16:04:40.922]                       }
[16:04:40.922]                     })
[16:04:40.922]                   }
[16:04:40.922]                   options(future.plan = NULL)
[16:04:40.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:40.922]                 }
[16:04:40.922]                 ...future.workdir <- getwd()
[16:04:40.922]             }
[16:04:40.922]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:40.922]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:40.922]         }
[16:04:40.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:40.922]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:40.922]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:40.922]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:40.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:40.922]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:40.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:40.922]             base::names(...future.oldOptions))
[16:04:40.922]     }
[16:04:40.922]     if (FALSE) {
[16:04:40.922]     }
[16:04:40.922]     else {
[16:04:40.922]         if (TRUE) {
[16:04:40.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:40.922]                 open = "w")
[16:04:40.922]         }
[16:04:40.922]         else {
[16:04:40.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:40.922]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:40.922]         }
[16:04:40.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:40.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:40.922]             base::sink(type = "output", split = FALSE)
[16:04:40.922]             base::close(...future.stdout)
[16:04:40.922]         }, add = TRUE)
[16:04:40.922]     }
[16:04:40.922]     ...future.frame <- base::sys.nframe()
[16:04:40.922]     ...future.conditions <- base::list()
[16:04:40.922]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:40.922]     if (FALSE) {
[16:04:40.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:40.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:40.922]     }
[16:04:40.922]     ...future.result <- base::tryCatch({
[16:04:40.922]         base::withCallingHandlers({
[16:04:40.922]             ...future.value <- base::withVisible(base::local(2))
[16:04:40.922]             future::FutureResult(value = ...future.value$value, 
[16:04:40.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.922]                   ...future.rng), globalenv = if (FALSE) 
[16:04:40.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:40.922]                     ...future.globalenv.names))
[16:04:40.922]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:40.922]         }, condition = base::local({
[16:04:40.922]             c <- base::c
[16:04:40.922]             inherits <- base::inherits
[16:04:40.922]             invokeRestart <- base::invokeRestart
[16:04:40.922]             length <- base::length
[16:04:40.922]             list <- base::list
[16:04:40.922]             seq.int <- base::seq.int
[16:04:40.922]             signalCondition <- base::signalCondition
[16:04:40.922]             sys.calls <- base::sys.calls
[16:04:40.922]             `[[` <- base::`[[`
[16:04:40.922]             `+` <- base::`+`
[16:04:40.922]             `<<-` <- base::`<<-`
[16:04:40.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:40.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:40.922]                   3L)]
[16:04:40.922]             }
[16:04:40.922]             function(cond) {
[16:04:40.922]                 is_error <- inherits(cond, "error")
[16:04:40.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:40.922]                   NULL)
[16:04:40.922]                 if (is_error) {
[16:04:40.922]                   sessionInformation <- function() {
[16:04:40.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:40.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:40.922]                       search = base::search(), system = base::Sys.info())
[16:04:40.922]                   }
[16:04:40.922]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:40.922]                     cond$call), session = sessionInformation(), 
[16:04:40.922]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:40.922]                   signalCondition(cond)
[16:04:40.922]                 }
[16:04:40.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:40.922]                 "immediateCondition"))) {
[16:04:40.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:40.922]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:40.922]                   if (TRUE && !signal) {
[16:04:40.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.922]                     {
[16:04:40.922]                       inherits <- base::inherits
[16:04:40.922]                       invokeRestart <- base::invokeRestart
[16:04:40.922]                       is.null <- base::is.null
[16:04:40.922]                       muffled <- FALSE
[16:04:40.922]                       if (inherits(cond, "message")) {
[16:04:40.922]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.922]                         if (muffled) 
[16:04:40.922]                           invokeRestart("muffleMessage")
[16:04:40.922]                       }
[16:04:40.922]                       else if (inherits(cond, "warning")) {
[16:04:40.922]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.922]                         if (muffled) 
[16:04:40.922]                           invokeRestart("muffleWarning")
[16:04:40.922]                       }
[16:04:40.922]                       else if (inherits(cond, "condition")) {
[16:04:40.922]                         if (!is.null(pattern)) {
[16:04:40.922]                           computeRestarts <- base::computeRestarts
[16:04:40.922]                           grepl <- base::grepl
[16:04:40.922]                           restarts <- computeRestarts(cond)
[16:04:40.922]                           for (restart in restarts) {
[16:04:40.922]                             name <- restart$name
[16:04:40.922]                             if (is.null(name)) 
[16:04:40.922]                               next
[16:04:40.922]                             if (!grepl(pattern, name)) 
[16:04:40.922]                               next
[16:04:40.922]                             invokeRestart(restart)
[16:04:40.922]                             muffled <- TRUE
[16:04:40.922]                             break
[16:04:40.922]                           }
[16:04:40.922]                         }
[16:04:40.922]                       }
[16:04:40.922]                       invisible(muffled)
[16:04:40.922]                     }
[16:04:40.922]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.922]                   }
[16:04:40.922]                 }
[16:04:40.922]                 else {
[16:04:40.922]                   if (TRUE) {
[16:04:40.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.922]                     {
[16:04:40.922]                       inherits <- base::inherits
[16:04:40.922]                       invokeRestart <- base::invokeRestart
[16:04:40.922]                       is.null <- base::is.null
[16:04:40.922]                       muffled <- FALSE
[16:04:40.922]                       if (inherits(cond, "message")) {
[16:04:40.922]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.922]                         if (muffled) 
[16:04:40.922]                           invokeRestart("muffleMessage")
[16:04:40.922]                       }
[16:04:40.922]                       else if (inherits(cond, "warning")) {
[16:04:40.922]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.922]                         if (muffled) 
[16:04:40.922]                           invokeRestart("muffleWarning")
[16:04:40.922]                       }
[16:04:40.922]                       else if (inherits(cond, "condition")) {
[16:04:40.922]                         if (!is.null(pattern)) {
[16:04:40.922]                           computeRestarts <- base::computeRestarts
[16:04:40.922]                           grepl <- base::grepl
[16:04:40.922]                           restarts <- computeRestarts(cond)
[16:04:40.922]                           for (restart in restarts) {
[16:04:40.922]                             name <- restart$name
[16:04:40.922]                             if (is.null(name)) 
[16:04:40.922]                               next
[16:04:40.922]                             if (!grepl(pattern, name)) 
[16:04:40.922]                               next
[16:04:40.922]                             invokeRestart(restart)
[16:04:40.922]                             muffled <- TRUE
[16:04:40.922]                             break
[16:04:40.922]                           }
[16:04:40.922]                         }
[16:04:40.922]                       }
[16:04:40.922]                       invisible(muffled)
[16:04:40.922]                     }
[16:04:40.922]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.922]                   }
[16:04:40.922]                 }
[16:04:40.922]             }
[16:04:40.922]         }))
[16:04:40.922]     }, error = function(ex) {
[16:04:40.922]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:40.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.922]                 ...future.rng), started = ...future.startTime, 
[16:04:40.922]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:40.922]             version = "1.8"), class = "FutureResult")
[16:04:40.922]     }, finally = {
[16:04:40.922]         if (!identical(...future.workdir, getwd())) 
[16:04:40.922]             setwd(...future.workdir)
[16:04:40.922]         {
[16:04:40.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:40.922]                 ...future.oldOptions$nwarnings <- NULL
[16:04:40.922]             }
[16:04:40.922]             base::options(...future.oldOptions)
[16:04:40.922]             if (.Platform$OS.type == "windows") {
[16:04:40.922]                 old_names <- names(...future.oldEnvVars)
[16:04:40.922]                 envs <- base::Sys.getenv()
[16:04:40.922]                 names <- names(envs)
[16:04:40.922]                 common <- intersect(names, old_names)
[16:04:40.922]                 added <- setdiff(names, old_names)
[16:04:40.922]                 removed <- setdiff(old_names, names)
[16:04:40.922]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:40.922]                   envs[common]]
[16:04:40.922]                 NAMES <- toupper(changed)
[16:04:40.922]                 args <- list()
[16:04:40.922]                 for (kk in seq_along(NAMES)) {
[16:04:40.922]                   name <- changed[[kk]]
[16:04:40.922]                   NAME <- NAMES[[kk]]
[16:04:40.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.922]                     next
[16:04:40.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.922]                 }
[16:04:40.922]                 NAMES <- toupper(added)
[16:04:40.922]                 for (kk in seq_along(NAMES)) {
[16:04:40.922]                   name <- added[[kk]]
[16:04:40.922]                   NAME <- NAMES[[kk]]
[16:04:40.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.922]                     next
[16:04:40.922]                   args[[name]] <- ""
[16:04:40.922]                 }
[16:04:40.922]                 NAMES <- toupper(removed)
[16:04:40.922]                 for (kk in seq_along(NAMES)) {
[16:04:40.922]                   name <- removed[[kk]]
[16:04:40.922]                   NAME <- NAMES[[kk]]
[16:04:40.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.922]                     next
[16:04:40.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.922]                 }
[16:04:40.922]                 if (length(args) > 0) 
[16:04:40.922]                   base::do.call(base::Sys.setenv, args = args)
[16:04:40.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:40.922]             }
[16:04:40.922]             else {
[16:04:40.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:40.922]             }
[16:04:40.922]             {
[16:04:40.922]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:40.922]                   0L) {
[16:04:40.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:40.922]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:40.922]                   base::options(opts)
[16:04:40.922]                 }
[16:04:40.922]                 {
[16:04:40.922]                   {
[16:04:40.922]                     NULL
[16:04:40.922]                     RNGkind("Mersenne-Twister")
[16:04:40.922]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:40.922]                       inherits = FALSE)
[16:04:40.922]                   }
[16:04:40.922]                   options(future.plan = NULL)
[16:04:40.922]                   if (is.na(NA_character_)) 
[16:04:40.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:40.922]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:40.922]                   {
[16:04:40.922]                     future <- SequentialFuture(..., envir = envir)
[16:04:40.922]                     if (!future$lazy) 
[16:04:40.922]                       future <- run(future)
[16:04:40.922]                     invisible(future)
[16:04:40.922]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:40.922]                 }
[16:04:40.922]             }
[16:04:40.922]         }
[16:04:40.922]     })
[16:04:40.922]     if (TRUE) {
[16:04:40.922]         base::sink(type = "output", split = FALSE)
[16:04:40.922]         if (TRUE) {
[16:04:40.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:40.922]         }
[16:04:40.922]         else {
[16:04:40.922]             ...future.result["stdout"] <- base::list(NULL)
[16:04:40.922]         }
[16:04:40.922]         base::close(...future.stdout)
[16:04:40.922]         ...future.stdout <- NULL
[16:04:40.922]     }
[16:04:40.922]     ...future.result$conditions <- ...future.conditions
[16:04:40.922]     ...future.result$finished <- base::Sys.time()
[16:04:40.922]     ...future.result
[16:04:40.922] }
[16:04:40.924] plan(): Setting new future strategy stack:
[16:04:40.924] List of future strategies:
[16:04:40.924] 1. sequential:
[16:04:40.924]    - args: function (..., envir = parent.frame())
[16:04:40.924]    - tweaked: FALSE
[16:04:40.924]    - call: NULL
[16:04:40.924] plan(): nbrOfWorkers() = 1
[16:04:40.925] plan(): Setting new future strategy stack:
[16:04:40.925] List of future strategies:
[16:04:40.925] 1. sequential:
[16:04:40.925]    - args: function (..., envir = parent.frame())
[16:04:40.925]    - tweaked: FALSE
[16:04:40.925]    - call: plan(strategy)
[16:04:40.926] plan(): nbrOfWorkers() = 1
[16:04:40.926] SequentialFuture started (and completed)
[16:04:40.926] - Launch lazy future ... done
[16:04:40.926] run() for ‘SequentialFuture’ ... done
[16:04:40.926] getGlobalsAndPackages() ...
[16:04:40.926] Searching for globals...
[16:04:40.926] 
[16:04:40.926] Searching for globals ... DONE
[16:04:40.927] - globals: [0] <none>
[16:04:40.928] getGlobalsAndPackages() ... DONE
[16:04:40.928] run() for ‘Future’ ...
[16:04:40.928] - state: ‘created’
[16:04:40.928] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:40.928] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:40.928] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:40.929]   - Field: ‘label’
[16:04:40.929]   - Field: ‘local’
[16:04:40.929]   - Field: ‘owner’
[16:04:40.929]   - Field: ‘envir’
[16:04:40.929]   - Field: ‘packages’
[16:04:40.929]   - Field: ‘gc’
[16:04:40.929]   - Field: ‘conditions’
[16:04:40.929]   - Field: ‘expr’
[16:04:40.929]   - Field: ‘uuid’
[16:04:40.929]   - Field: ‘seed’
[16:04:40.930]   - Field: ‘version’
[16:04:40.930]   - Field: ‘result’
[16:04:40.930]   - Field: ‘asynchronous’
[16:04:40.930]   - Field: ‘calls’
[16:04:40.930]   - Field: ‘globals’
[16:04:40.930]   - Field: ‘stdout’
[16:04:40.930]   - Field: ‘earlySignal’
[16:04:40.930]   - Field: ‘lazy’
[16:04:40.930]   - Field: ‘state’
[16:04:40.930] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:40.930] - Launch lazy future ...
[16:04:40.931] Packages needed by the future expression (n = 0): <none>
[16:04:40.931] Packages needed by future strategies (n = 0): <none>
[16:04:40.931] {
[16:04:40.931]     {
[16:04:40.931]         {
[16:04:40.931]             ...future.startTime <- base::Sys.time()
[16:04:40.931]             {
[16:04:40.931]                 {
[16:04:40.931]                   {
[16:04:40.931]                     base::local({
[16:04:40.931]                       has_future <- base::requireNamespace("future", 
[16:04:40.931]                         quietly = TRUE)
[16:04:40.931]                       if (has_future) {
[16:04:40.931]                         ns <- base::getNamespace("future")
[16:04:40.931]                         version <- ns[[".package"]][["version"]]
[16:04:40.931]                         if (is.null(version)) 
[16:04:40.931]                           version <- utils::packageVersion("future")
[16:04:40.931]                       }
[16:04:40.931]                       else {
[16:04:40.931]                         version <- NULL
[16:04:40.931]                       }
[16:04:40.931]                       if (!has_future || version < "1.8.0") {
[16:04:40.931]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:40.931]                           "", base::R.version$version.string), 
[16:04:40.931]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:40.931]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:40.931]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:40.931]                             "release", "version")], collapse = " "), 
[16:04:40.931]                           hostname = base::Sys.info()[["nodename"]])
[16:04:40.931]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:40.931]                           info)
[16:04:40.931]                         info <- base::paste(info, collapse = "; ")
[16:04:40.931]                         if (!has_future) {
[16:04:40.931]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:40.931]                             info)
[16:04:40.931]                         }
[16:04:40.931]                         else {
[16:04:40.931]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:40.931]                             info, version)
[16:04:40.931]                         }
[16:04:40.931]                         base::stop(msg)
[16:04:40.931]                       }
[16:04:40.931]                     })
[16:04:40.931]                   }
[16:04:40.931]                   options(future.plan = NULL)
[16:04:40.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:40.931]                 }
[16:04:40.931]                 ...future.workdir <- getwd()
[16:04:40.931]             }
[16:04:40.931]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:40.931]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:40.931]         }
[16:04:40.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:40.931]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:40.931]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:40.931]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:40.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:40.931]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:40.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:40.931]             base::names(...future.oldOptions))
[16:04:40.931]     }
[16:04:40.931]     if (FALSE) {
[16:04:40.931]     }
[16:04:40.931]     else {
[16:04:40.931]         if (TRUE) {
[16:04:40.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:40.931]                 open = "w")
[16:04:40.931]         }
[16:04:40.931]         else {
[16:04:40.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:40.931]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:40.931]         }
[16:04:40.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:40.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:40.931]             base::sink(type = "output", split = FALSE)
[16:04:40.931]             base::close(...future.stdout)
[16:04:40.931]         }, add = TRUE)
[16:04:40.931]     }
[16:04:40.931]     ...future.frame <- base::sys.nframe()
[16:04:40.931]     ...future.conditions <- base::list()
[16:04:40.931]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:40.931]     if (FALSE) {
[16:04:40.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:40.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:40.931]     }
[16:04:40.931]     ...future.result <- base::tryCatch({
[16:04:40.931]         base::withCallingHandlers({
[16:04:40.931]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:40.931]             future::FutureResult(value = ...future.value$value, 
[16:04:40.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.931]                   ...future.rng), globalenv = if (FALSE) 
[16:04:40.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:40.931]                     ...future.globalenv.names))
[16:04:40.931]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:40.931]         }, condition = base::local({
[16:04:40.931]             c <- base::c
[16:04:40.931]             inherits <- base::inherits
[16:04:40.931]             invokeRestart <- base::invokeRestart
[16:04:40.931]             length <- base::length
[16:04:40.931]             list <- base::list
[16:04:40.931]             seq.int <- base::seq.int
[16:04:40.931]             signalCondition <- base::signalCondition
[16:04:40.931]             sys.calls <- base::sys.calls
[16:04:40.931]             `[[` <- base::`[[`
[16:04:40.931]             `+` <- base::`+`
[16:04:40.931]             `<<-` <- base::`<<-`
[16:04:40.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:40.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:40.931]                   3L)]
[16:04:40.931]             }
[16:04:40.931]             function(cond) {
[16:04:40.931]                 is_error <- inherits(cond, "error")
[16:04:40.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:40.931]                   NULL)
[16:04:40.931]                 if (is_error) {
[16:04:40.931]                   sessionInformation <- function() {
[16:04:40.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:40.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:40.931]                       search = base::search(), system = base::Sys.info())
[16:04:40.931]                   }
[16:04:40.931]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:40.931]                     cond$call), session = sessionInformation(), 
[16:04:40.931]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:40.931]                   signalCondition(cond)
[16:04:40.931]                 }
[16:04:40.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:40.931]                 "immediateCondition"))) {
[16:04:40.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:40.931]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:40.931]                   if (TRUE && !signal) {
[16:04:40.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.931]                     {
[16:04:40.931]                       inherits <- base::inherits
[16:04:40.931]                       invokeRestart <- base::invokeRestart
[16:04:40.931]                       is.null <- base::is.null
[16:04:40.931]                       muffled <- FALSE
[16:04:40.931]                       if (inherits(cond, "message")) {
[16:04:40.931]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.931]                         if (muffled) 
[16:04:40.931]                           invokeRestart("muffleMessage")
[16:04:40.931]                       }
[16:04:40.931]                       else if (inherits(cond, "warning")) {
[16:04:40.931]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.931]                         if (muffled) 
[16:04:40.931]                           invokeRestart("muffleWarning")
[16:04:40.931]                       }
[16:04:40.931]                       else if (inherits(cond, "condition")) {
[16:04:40.931]                         if (!is.null(pattern)) {
[16:04:40.931]                           computeRestarts <- base::computeRestarts
[16:04:40.931]                           grepl <- base::grepl
[16:04:40.931]                           restarts <- computeRestarts(cond)
[16:04:40.931]                           for (restart in restarts) {
[16:04:40.931]                             name <- restart$name
[16:04:40.931]                             if (is.null(name)) 
[16:04:40.931]                               next
[16:04:40.931]                             if (!grepl(pattern, name)) 
[16:04:40.931]                               next
[16:04:40.931]                             invokeRestart(restart)
[16:04:40.931]                             muffled <- TRUE
[16:04:40.931]                             break
[16:04:40.931]                           }
[16:04:40.931]                         }
[16:04:40.931]                       }
[16:04:40.931]                       invisible(muffled)
[16:04:40.931]                     }
[16:04:40.931]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.931]                   }
[16:04:40.931]                 }
[16:04:40.931]                 else {
[16:04:40.931]                   if (TRUE) {
[16:04:40.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.931]                     {
[16:04:40.931]                       inherits <- base::inherits
[16:04:40.931]                       invokeRestart <- base::invokeRestart
[16:04:40.931]                       is.null <- base::is.null
[16:04:40.931]                       muffled <- FALSE
[16:04:40.931]                       if (inherits(cond, "message")) {
[16:04:40.931]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.931]                         if (muffled) 
[16:04:40.931]                           invokeRestart("muffleMessage")
[16:04:40.931]                       }
[16:04:40.931]                       else if (inherits(cond, "warning")) {
[16:04:40.931]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.931]                         if (muffled) 
[16:04:40.931]                           invokeRestart("muffleWarning")
[16:04:40.931]                       }
[16:04:40.931]                       else if (inherits(cond, "condition")) {
[16:04:40.931]                         if (!is.null(pattern)) {
[16:04:40.931]                           computeRestarts <- base::computeRestarts
[16:04:40.931]                           grepl <- base::grepl
[16:04:40.931]                           restarts <- computeRestarts(cond)
[16:04:40.931]                           for (restart in restarts) {
[16:04:40.931]                             name <- restart$name
[16:04:40.931]                             if (is.null(name)) 
[16:04:40.931]                               next
[16:04:40.931]                             if (!grepl(pattern, name)) 
[16:04:40.931]                               next
[16:04:40.931]                             invokeRestart(restart)
[16:04:40.931]                             muffled <- TRUE
[16:04:40.931]                             break
[16:04:40.931]                           }
[16:04:40.931]                         }
[16:04:40.931]                       }
[16:04:40.931]                       invisible(muffled)
[16:04:40.931]                     }
[16:04:40.931]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.931]                   }
[16:04:40.931]                 }
[16:04:40.931]             }
[16:04:40.931]         }))
[16:04:40.931]     }, error = function(ex) {
[16:04:40.931]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:40.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.931]                 ...future.rng), started = ...future.startTime, 
[16:04:40.931]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:40.931]             version = "1.8"), class = "FutureResult")
[16:04:40.931]     }, finally = {
[16:04:40.931]         if (!identical(...future.workdir, getwd())) 
[16:04:40.931]             setwd(...future.workdir)
[16:04:40.931]         {
[16:04:40.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:40.931]                 ...future.oldOptions$nwarnings <- NULL
[16:04:40.931]             }
[16:04:40.931]             base::options(...future.oldOptions)
[16:04:40.931]             if (.Platform$OS.type == "windows") {
[16:04:40.931]                 old_names <- names(...future.oldEnvVars)
[16:04:40.931]                 envs <- base::Sys.getenv()
[16:04:40.931]                 names <- names(envs)
[16:04:40.931]                 common <- intersect(names, old_names)
[16:04:40.931]                 added <- setdiff(names, old_names)
[16:04:40.931]                 removed <- setdiff(old_names, names)
[16:04:40.931]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:40.931]                   envs[common]]
[16:04:40.931]                 NAMES <- toupper(changed)
[16:04:40.931]                 args <- list()
[16:04:40.931]                 for (kk in seq_along(NAMES)) {
[16:04:40.931]                   name <- changed[[kk]]
[16:04:40.931]                   NAME <- NAMES[[kk]]
[16:04:40.931]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.931]                     next
[16:04:40.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.931]                 }
[16:04:40.931]                 NAMES <- toupper(added)
[16:04:40.931]                 for (kk in seq_along(NAMES)) {
[16:04:40.931]                   name <- added[[kk]]
[16:04:40.931]                   NAME <- NAMES[[kk]]
[16:04:40.931]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.931]                     next
[16:04:40.931]                   args[[name]] <- ""
[16:04:40.931]                 }
[16:04:40.931]                 NAMES <- toupper(removed)
[16:04:40.931]                 for (kk in seq_along(NAMES)) {
[16:04:40.931]                   name <- removed[[kk]]
[16:04:40.931]                   NAME <- NAMES[[kk]]
[16:04:40.931]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.931]                     next
[16:04:40.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.931]                 }
[16:04:40.931]                 if (length(args) > 0) 
[16:04:40.931]                   base::do.call(base::Sys.setenv, args = args)
[16:04:40.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:40.931]             }
[16:04:40.931]             else {
[16:04:40.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:40.931]             }
[16:04:40.931]             {
[16:04:40.931]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:40.931]                   0L) {
[16:04:40.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:40.931]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:40.931]                   base::options(opts)
[16:04:40.931]                 }
[16:04:40.931]                 {
[16:04:40.931]                   {
[16:04:40.931]                     NULL
[16:04:40.931]                     RNGkind("Mersenne-Twister")
[16:04:40.931]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:40.931]                       inherits = FALSE)
[16:04:40.931]                   }
[16:04:40.931]                   options(future.plan = NULL)
[16:04:40.931]                   if (is.na(NA_character_)) 
[16:04:40.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:40.931]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:40.931]                   {
[16:04:40.931]                     future <- SequentialFuture(..., envir = envir)
[16:04:40.931]                     if (!future$lazy) 
[16:04:40.931]                       future <- run(future)
[16:04:40.931]                     invisible(future)
[16:04:40.931]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:40.931]                 }
[16:04:40.931]             }
[16:04:40.931]         }
[16:04:40.931]     })
[16:04:40.931]     if (TRUE) {
[16:04:40.931]         base::sink(type = "output", split = FALSE)
[16:04:40.931]         if (TRUE) {
[16:04:40.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:40.931]         }
[16:04:40.931]         else {
[16:04:40.931]             ...future.result["stdout"] <- base::list(NULL)
[16:04:40.931]         }
[16:04:40.931]         base::close(...future.stdout)
[16:04:40.931]         ...future.stdout <- NULL
[16:04:40.931]     }
[16:04:40.931]     ...future.result$conditions <- ...future.conditions
[16:04:40.931]     ...future.result$finished <- base::Sys.time()
[16:04:40.931]     ...future.result
[16:04:40.931] }
[16:04:40.933] plan(): Setting new future strategy stack:
[16:04:40.933] List of future strategies:
[16:04:40.933] 1. sequential:
[16:04:40.933]    - args: function (..., envir = parent.frame())
[16:04:40.933]    - tweaked: FALSE
[16:04:40.933]    - call: NULL
[16:04:40.933] plan(): nbrOfWorkers() = 1
[16:04:40.934] plan(): Setting new future strategy stack:
[16:04:40.934] List of future strategies:
[16:04:40.934] 1. sequential:
[16:04:40.934]    - args: function (..., envir = parent.frame())
[16:04:40.934]    - tweaked: FALSE
[16:04:40.934]    - call: plan(strategy)
[16:04:40.934] plan(): nbrOfWorkers() = 1
[16:04:40.934] SequentialFuture started (and completed)
[16:04:40.935] - Launch lazy future ... done
[16:04:40.935] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874de3d330> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874d1bb300> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874de3d330> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874d1bb300> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:04:40.939] resolved() for ‘SequentialFuture’ ...
[16:04:40.940] - state: ‘finished’
[16:04:40.940] - run: TRUE
[16:04:40.940] - result: ‘FutureResult’
[16:04:40.940] resolved() for ‘SequentialFuture’ ... done
[16:04:40.940] resolved() for ‘SequentialFuture’ ...
[16:04:40.940] - state: ‘finished’
[16:04:40.940] - run: TRUE
[16:04:40.940] - result: ‘FutureResult’
[16:04:40.940] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:40.942] resolve() on list ...
[16:04:40.942]  recursive: 0
[16:04:40.942]  length: 6
[16:04:40.942]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:40.942] signalConditionsASAP(numeric, pos=1) ...
[16:04:40.942] - nx: 6
[16:04:40.942] - relay: TRUE
[16:04:40.942] - stdout: TRUE
[16:04:40.942] - signal: TRUE
[16:04:40.942] - resignal: FALSE
[16:04:40.943] - force: TRUE
[16:04:40.943] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.943] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.943]  - until=2
[16:04:40.943]  - relaying element #2
[16:04:40.943] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.943] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.943] signalConditionsASAP(NULL, pos=1) ... done
[16:04:40.943]  length: 5 (resolved future 1)
[16:04:40.943] resolved() for ‘SequentialFuture’ ...
[16:04:40.943] - state: ‘finished’
[16:04:40.944] - run: TRUE
[16:04:40.944] - result: ‘FutureResult’
[16:04:40.944] resolved() for ‘SequentialFuture’ ... done
[16:04:40.944] Future #2
[16:04:40.944] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:40.944] - nx: 6
[16:04:40.944] - relay: TRUE
[16:04:40.944] - stdout: TRUE
[16:04:40.944] - signal: TRUE
[16:04:40.944] - resignal: FALSE
[16:04:40.944] - force: TRUE
[16:04:40.944] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.945] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.945]  - until=2
[16:04:40.945]  - relaying element #2
[16:04:40.945] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.945] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.945] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:40.945]  length: 4 (resolved future 2)
[16:04:40.945] resolved() for ‘SequentialFuture’ ...
[16:04:40.945] - state: ‘finished’
[16:04:40.945] - run: TRUE
[16:04:40.946] - result: ‘FutureResult’
[16:04:40.946] resolved() for ‘SequentialFuture’ ... done
[16:04:40.946] Future #3
[16:04:40.946] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:40.946] - nx: 6
[16:04:40.946] - relay: TRUE
[16:04:40.946] - stdout: TRUE
[16:04:40.946] - signal: TRUE
[16:04:40.946] - resignal: FALSE
[16:04:40.946] - force: TRUE
[16:04:40.946] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.946] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.947]  - until=3
[16:04:40.947]  - relaying element #3
[16:04:40.947] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.947] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.947] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:40.947]  length: 3 (resolved future 3)
[16:04:40.947] signalConditionsASAP(NULL, pos=4) ...
[16:04:40.947] - nx: 6
[16:04:40.947] - relay: TRUE
[16:04:40.947] - stdout: TRUE
[16:04:40.947] - signal: TRUE
[16:04:40.948] - resignal: FALSE
[16:04:40.948] - force: TRUE
[16:04:40.948] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.948] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.948]  - until=5
[16:04:40.948]  - relaying element #5
[16:04:40.948] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:40.948] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.948] signalConditionsASAP(NULL, pos=4) ... done
[16:04:40.948]  length: 2 (resolved future 4)
[16:04:40.948] signalConditionsASAP(NULL, pos=5) ...
[16:04:40.948] - nx: 6
[16:04:40.949] - relay: TRUE
[16:04:40.949] - stdout: TRUE
[16:04:40.949] - signal: TRUE
[16:04:40.949] - resignal: FALSE
[16:04:40.949] - force: TRUE
[16:04:40.949] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:40.949] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.949]  - until=6
[16:04:40.949]  - relaying element #6
[16:04:40.949] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:40.949] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.949] signalConditionsASAP(NULL, pos=5) ... done
[16:04:40.949]  length: 1 (resolved future 5)
[16:04:40.950] signalConditionsASAP(numeric, pos=6) ...
[16:04:40.950] - nx: 6
[16:04:40.950] - relay: TRUE
[16:04:40.950] - stdout: TRUE
[16:04:40.950] - signal: TRUE
[16:04:40.950] - resignal: FALSE
[16:04:40.950] - force: TRUE
[16:04:40.950] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:40.950] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.950]  - until=6
[16:04:40.950] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:40.950] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.951] signalConditionsASAP(numeric, pos=6) ... done
[16:04:40.951]  length: 0 (resolved future 6)
[16:04:40.951] Relaying remaining futures
[16:04:40.951] signalConditionsASAP(NULL, pos=0) ...
[16:04:40.951] - nx: 6
[16:04:40.951] - relay: TRUE
[16:04:40.951] - stdout: TRUE
[16:04:40.951] - signal: TRUE
[16:04:40.951] - resignal: FALSE
[16:04:40.951] - force: TRUE
[16:04:40.951] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:40.951] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:40.952] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:40.952] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.952] signalConditionsASAP(NULL, pos=0) ... done
[16:04:40.952] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:04:40.956] getGlobalsAndPackages() ...
[16:04:40.956] Searching for globals...
[16:04:40.956] 
[16:04:40.956] Searching for globals ... DONE
[16:04:40.956] - globals: [0] <none>
[16:04:40.956] getGlobalsAndPackages() ... DONE
[16:04:40.957] run() for ‘Future’ ...
[16:04:40.957] - state: ‘created’
[16:04:40.957] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:40.957] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:40.957] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:40.957]   - Field: ‘label’
[16:04:40.957]   - Field: ‘local’
[16:04:40.958]   - Field: ‘owner’
[16:04:40.958]   - Field: ‘envir’
[16:04:40.958]   - Field: ‘packages’
[16:04:40.958]   - Field: ‘gc’
[16:04:40.958]   - Field: ‘conditions’
[16:04:40.958]   - Field: ‘expr’
[16:04:40.958]   - Field: ‘uuid’
[16:04:40.958]   - Field: ‘seed’
[16:04:40.958]   - Field: ‘version’
[16:04:40.958]   - Field: ‘result’
[16:04:40.958]   - Field: ‘asynchronous’
[16:04:40.959]   - Field: ‘calls’
[16:04:40.959]   - Field: ‘globals’
[16:04:40.959]   - Field: ‘stdout’
[16:04:40.959]   - Field: ‘earlySignal’
[16:04:40.959]   - Field: ‘lazy’
[16:04:40.959]   - Field: ‘state’
[16:04:40.959] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:40.959] - Launch lazy future ...
[16:04:40.959] Packages needed by the future expression (n = 0): <none>
[16:04:40.959] Packages needed by future strategies (n = 0): <none>
[16:04:40.960] {
[16:04:40.960]     {
[16:04:40.960]         {
[16:04:40.960]             ...future.startTime <- base::Sys.time()
[16:04:40.960]             {
[16:04:40.960]                 {
[16:04:40.960]                   {
[16:04:40.960]                     base::local({
[16:04:40.960]                       has_future <- base::requireNamespace("future", 
[16:04:40.960]                         quietly = TRUE)
[16:04:40.960]                       if (has_future) {
[16:04:40.960]                         ns <- base::getNamespace("future")
[16:04:40.960]                         version <- ns[[".package"]][["version"]]
[16:04:40.960]                         if (is.null(version)) 
[16:04:40.960]                           version <- utils::packageVersion("future")
[16:04:40.960]                       }
[16:04:40.960]                       else {
[16:04:40.960]                         version <- NULL
[16:04:40.960]                       }
[16:04:40.960]                       if (!has_future || version < "1.8.0") {
[16:04:40.960]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:40.960]                           "", base::R.version$version.string), 
[16:04:40.960]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:40.960]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:40.960]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:40.960]                             "release", "version")], collapse = " "), 
[16:04:40.960]                           hostname = base::Sys.info()[["nodename"]])
[16:04:40.960]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:40.960]                           info)
[16:04:40.960]                         info <- base::paste(info, collapse = "; ")
[16:04:40.960]                         if (!has_future) {
[16:04:40.960]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:40.960]                             info)
[16:04:40.960]                         }
[16:04:40.960]                         else {
[16:04:40.960]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:40.960]                             info, version)
[16:04:40.960]                         }
[16:04:40.960]                         base::stop(msg)
[16:04:40.960]                       }
[16:04:40.960]                     })
[16:04:40.960]                   }
[16:04:40.960]                   options(future.plan = NULL)
[16:04:40.960]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.960]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:40.960]                 }
[16:04:40.960]                 ...future.workdir <- getwd()
[16:04:40.960]             }
[16:04:40.960]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:40.960]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:40.960]         }
[16:04:40.960]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:40.960]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:40.960]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:40.960]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:40.960]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:40.960]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:40.960]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:40.960]             base::names(...future.oldOptions))
[16:04:40.960]     }
[16:04:40.960]     if (FALSE) {
[16:04:40.960]     }
[16:04:40.960]     else {
[16:04:40.960]         if (TRUE) {
[16:04:40.960]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:40.960]                 open = "w")
[16:04:40.960]         }
[16:04:40.960]         else {
[16:04:40.960]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:40.960]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:40.960]         }
[16:04:40.960]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:40.960]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:40.960]             base::sink(type = "output", split = FALSE)
[16:04:40.960]             base::close(...future.stdout)
[16:04:40.960]         }, add = TRUE)
[16:04:40.960]     }
[16:04:40.960]     ...future.frame <- base::sys.nframe()
[16:04:40.960]     ...future.conditions <- base::list()
[16:04:40.960]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:40.960]     if (FALSE) {
[16:04:40.960]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:40.960]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:40.960]     }
[16:04:40.960]     ...future.result <- base::tryCatch({
[16:04:40.960]         base::withCallingHandlers({
[16:04:40.960]             ...future.value <- base::withVisible(base::local(2))
[16:04:40.960]             future::FutureResult(value = ...future.value$value, 
[16:04:40.960]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.960]                   ...future.rng), globalenv = if (FALSE) 
[16:04:40.960]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:40.960]                     ...future.globalenv.names))
[16:04:40.960]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:40.960]         }, condition = base::local({
[16:04:40.960]             c <- base::c
[16:04:40.960]             inherits <- base::inherits
[16:04:40.960]             invokeRestart <- base::invokeRestart
[16:04:40.960]             length <- base::length
[16:04:40.960]             list <- base::list
[16:04:40.960]             seq.int <- base::seq.int
[16:04:40.960]             signalCondition <- base::signalCondition
[16:04:40.960]             sys.calls <- base::sys.calls
[16:04:40.960]             `[[` <- base::`[[`
[16:04:40.960]             `+` <- base::`+`
[16:04:40.960]             `<<-` <- base::`<<-`
[16:04:40.960]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:40.960]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:40.960]                   3L)]
[16:04:40.960]             }
[16:04:40.960]             function(cond) {
[16:04:40.960]                 is_error <- inherits(cond, "error")
[16:04:40.960]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:40.960]                   NULL)
[16:04:40.960]                 if (is_error) {
[16:04:40.960]                   sessionInformation <- function() {
[16:04:40.960]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:40.960]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:40.960]                       search = base::search(), system = base::Sys.info())
[16:04:40.960]                   }
[16:04:40.960]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.960]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:40.960]                     cond$call), session = sessionInformation(), 
[16:04:40.960]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:40.960]                   signalCondition(cond)
[16:04:40.960]                 }
[16:04:40.960]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:40.960]                 "immediateCondition"))) {
[16:04:40.960]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:40.960]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.960]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:40.960]                   if (TRUE && !signal) {
[16:04:40.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.960]                     {
[16:04:40.960]                       inherits <- base::inherits
[16:04:40.960]                       invokeRestart <- base::invokeRestart
[16:04:40.960]                       is.null <- base::is.null
[16:04:40.960]                       muffled <- FALSE
[16:04:40.960]                       if (inherits(cond, "message")) {
[16:04:40.960]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.960]                         if (muffled) 
[16:04:40.960]                           invokeRestart("muffleMessage")
[16:04:40.960]                       }
[16:04:40.960]                       else if (inherits(cond, "warning")) {
[16:04:40.960]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.960]                         if (muffled) 
[16:04:40.960]                           invokeRestart("muffleWarning")
[16:04:40.960]                       }
[16:04:40.960]                       else if (inherits(cond, "condition")) {
[16:04:40.960]                         if (!is.null(pattern)) {
[16:04:40.960]                           computeRestarts <- base::computeRestarts
[16:04:40.960]                           grepl <- base::grepl
[16:04:40.960]                           restarts <- computeRestarts(cond)
[16:04:40.960]                           for (restart in restarts) {
[16:04:40.960]                             name <- restart$name
[16:04:40.960]                             if (is.null(name)) 
[16:04:40.960]                               next
[16:04:40.960]                             if (!grepl(pattern, name)) 
[16:04:40.960]                               next
[16:04:40.960]                             invokeRestart(restart)
[16:04:40.960]                             muffled <- TRUE
[16:04:40.960]                             break
[16:04:40.960]                           }
[16:04:40.960]                         }
[16:04:40.960]                       }
[16:04:40.960]                       invisible(muffled)
[16:04:40.960]                     }
[16:04:40.960]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.960]                   }
[16:04:40.960]                 }
[16:04:40.960]                 else {
[16:04:40.960]                   if (TRUE) {
[16:04:40.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.960]                     {
[16:04:40.960]                       inherits <- base::inherits
[16:04:40.960]                       invokeRestart <- base::invokeRestart
[16:04:40.960]                       is.null <- base::is.null
[16:04:40.960]                       muffled <- FALSE
[16:04:40.960]                       if (inherits(cond, "message")) {
[16:04:40.960]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.960]                         if (muffled) 
[16:04:40.960]                           invokeRestart("muffleMessage")
[16:04:40.960]                       }
[16:04:40.960]                       else if (inherits(cond, "warning")) {
[16:04:40.960]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.960]                         if (muffled) 
[16:04:40.960]                           invokeRestart("muffleWarning")
[16:04:40.960]                       }
[16:04:40.960]                       else if (inherits(cond, "condition")) {
[16:04:40.960]                         if (!is.null(pattern)) {
[16:04:40.960]                           computeRestarts <- base::computeRestarts
[16:04:40.960]                           grepl <- base::grepl
[16:04:40.960]                           restarts <- computeRestarts(cond)
[16:04:40.960]                           for (restart in restarts) {
[16:04:40.960]                             name <- restart$name
[16:04:40.960]                             if (is.null(name)) 
[16:04:40.960]                               next
[16:04:40.960]                             if (!grepl(pattern, name)) 
[16:04:40.960]                               next
[16:04:40.960]                             invokeRestart(restart)
[16:04:40.960]                             muffled <- TRUE
[16:04:40.960]                             break
[16:04:40.960]                           }
[16:04:40.960]                         }
[16:04:40.960]                       }
[16:04:40.960]                       invisible(muffled)
[16:04:40.960]                     }
[16:04:40.960]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.960]                   }
[16:04:40.960]                 }
[16:04:40.960]             }
[16:04:40.960]         }))
[16:04:40.960]     }, error = function(ex) {
[16:04:40.960]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:40.960]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.960]                 ...future.rng), started = ...future.startTime, 
[16:04:40.960]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:40.960]             version = "1.8"), class = "FutureResult")
[16:04:40.960]     }, finally = {
[16:04:40.960]         if (!identical(...future.workdir, getwd())) 
[16:04:40.960]             setwd(...future.workdir)
[16:04:40.960]         {
[16:04:40.960]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:40.960]                 ...future.oldOptions$nwarnings <- NULL
[16:04:40.960]             }
[16:04:40.960]             base::options(...future.oldOptions)
[16:04:40.960]             if (.Platform$OS.type == "windows") {
[16:04:40.960]                 old_names <- names(...future.oldEnvVars)
[16:04:40.960]                 envs <- base::Sys.getenv()
[16:04:40.960]                 names <- names(envs)
[16:04:40.960]                 common <- intersect(names, old_names)
[16:04:40.960]                 added <- setdiff(names, old_names)
[16:04:40.960]                 removed <- setdiff(old_names, names)
[16:04:40.960]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:40.960]                   envs[common]]
[16:04:40.960]                 NAMES <- toupper(changed)
[16:04:40.960]                 args <- list()
[16:04:40.960]                 for (kk in seq_along(NAMES)) {
[16:04:40.960]                   name <- changed[[kk]]
[16:04:40.960]                   NAME <- NAMES[[kk]]
[16:04:40.960]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.960]                     next
[16:04:40.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.960]                 }
[16:04:40.960]                 NAMES <- toupper(added)
[16:04:40.960]                 for (kk in seq_along(NAMES)) {
[16:04:40.960]                   name <- added[[kk]]
[16:04:40.960]                   NAME <- NAMES[[kk]]
[16:04:40.960]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.960]                     next
[16:04:40.960]                   args[[name]] <- ""
[16:04:40.960]                 }
[16:04:40.960]                 NAMES <- toupper(removed)
[16:04:40.960]                 for (kk in seq_along(NAMES)) {
[16:04:40.960]                   name <- removed[[kk]]
[16:04:40.960]                   NAME <- NAMES[[kk]]
[16:04:40.960]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.960]                     next
[16:04:40.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.960]                 }
[16:04:40.960]                 if (length(args) > 0) 
[16:04:40.960]                   base::do.call(base::Sys.setenv, args = args)
[16:04:40.960]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:40.960]             }
[16:04:40.960]             else {
[16:04:40.960]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:40.960]             }
[16:04:40.960]             {
[16:04:40.960]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:40.960]                   0L) {
[16:04:40.960]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:40.960]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:40.960]                   base::options(opts)
[16:04:40.960]                 }
[16:04:40.960]                 {
[16:04:40.960]                   {
[16:04:40.960]                     NULL
[16:04:40.960]                     RNGkind("Mersenne-Twister")
[16:04:40.960]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:40.960]                       inherits = FALSE)
[16:04:40.960]                   }
[16:04:40.960]                   options(future.plan = NULL)
[16:04:40.960]                   if (is.na(NA_character_)) 
[16:04:40.960]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.960]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:40.960]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:40.960]                   {
[16:04:40.960]                     future <- SequentialFuture(..., envir = envir)
[16:04:40.960]                     if (!future$lazy) 
[16:04:40.960]                       future <- run(future)
[16:04:40.960]                     invisible(future)
[16:04:40.960]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:40.960]                 }
[16:04:40.960]             }
[16:04:40.960]         }
[16:04:40.960]     })
[16:04:40.960]     if (TRUE) {
[16:04:40.960]         base::sink(type = "output", split = FALSE)
[16:04:40.960]         if (TRUE) {
[16:04:40.960]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:40.960]         }
[16:04:40.960]         else {
[16:04:40.960]             ...future.result["stdout"] <- base::list(NULL)
[16:04:40.960]         }
[16:04:40.960]         base::close(...future.stdout)
[16:04:40.960]         ...future.stdout <- NULL
[16:04:40.960]     }
[16:04:40.960]     ...future.result$conditions <- ...future.conditions
[16:04:40.960]     ...future.result$finished <- base::Sys.time()
[16:04:40.960]     ...future.result
[16:04:40.960] }
[16:04:40.961] plan(): Setting new future strategy stack:
[16:04:40.962] List of future strategies:
[16:04:40.962] 1. sequential:
[16:04:40.962]    - args: function (..., envir = parent.frame())
[16:04:40.962]    - tweaked: FALSE
[16:04:40.962]    - call: NULL
[16:04:40.962] plan(): nbrOfWorkers() = 1
[16:04:40.963] plan(): Setting new future strategy stack:
[16:04:40.963] List of future strategies:
[16:04:40.963] 1. sequential:
[16:04:40.963]    - args: function (..., envir = parent.frame())
[16:04:40.963]    - tweaked: FALSE
[16:04:40.963]    - call: plan(strategy)
[16:04:40.963] plan(): nbrOfWorkers() = 1
[16:04:40.963] SequentialFuture started (and completed)
[16:04:40.963] - Launch lazy future ... done
[16:04:40.963] run() for ‘SequentialFuture’ ... done
[16:04:40.964] getGlobalsAndPackages() ...
[16:04:40.964] Searching for globals...
[16:04:40.964] 
[16:04:40.964] Searching for globals ... DONE
[16:04:40.964] - globals: [0] <none>
[16:04:40.964] getGlobalsAndPackages() ... DONE
[16:04:40.964] run() for ‘Future’ ...
[16:04:40.964] - state: ‘created’
[16:04:40.965] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:40.965] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:40.965] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:40.965]   - Field: ‘label’
[16:04:40.965]   - Field: ‘local’
[16:04:40.965]   - Field: ‘owner’
[16:04:40.965]   - Field: ‘envir’
[16:04:40.965]   - Field: ‘packages’
[16:04:40.965]   - Field: ‘gc’
[16:04:40.966]   - Field: ‘conditions’
[16:04:40.966]   - Field: ‘expr’
[16:04:40.966]   - Field: ‘uuid’
[16:04:40.966]   - Field: ‘seed’
[16:04:40.966]   - Field: ‘version’
[16:04:40.966]   - Field: ‘result’
[16:04:40.966]   - Field: ‘asynchronous’
[16:04:40.966]   - Field: ‘calls’
[16:04:40.966]   - Field: ‘globals’
[16:04:40.966]   - Field: ‘stdout’
[16:04:40.966]   - Field: ‘earlySignal’
[16:04:40.966]   - Field: ‘lazy’
[16:04:40.967]   - Field: ‘state’
[16:04:40.967] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:40.967] - Launch lazy future ...
[16:04:40.967] Packages needed by the future expression (n = 0): <none>
[16:04:40.967] Packages needed by future strategies (n = 0): <none>
[16:04:40.967] {
[16:04:40.967]     {
[16:04:40.967]         {
[16:04:40.967]             ...future.startTime <- base::Sys.time()
[16:04:40.967]             {
[16:04:40.967]                 {
[16:04:40.967]                   {
[16:04:40.967]                     base::local({
[16:04:40.967]                       has_future <- base::requireNamespace("future", 
[16:04:40.967]                         quietly = TRUE)
[16:04:40.967]                       if (has_future) {
[16:04:40.967]                         ns <- base::getNamespace("future")
[16:04:40.967]                         version <- ns[[".package"]][["version"]]
[16:04:40.967]                         if (is.null(version)) 
[16:04:40.967]                           version <- utils::packageVersion("future")
[16:04:40.967]                       }
[16:04:40.967]                       else {
[16:04:40.967]                         version <- NULL
[16:04:40.967]                       }
[16:04:40.967]                       if (!has_future || version < "1.8.0") {
[16:04:40.967]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:40.967]                           "", base::R.version$version.string), 
[16:04:40.967]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:40.967]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:40.967]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:40.967]                             "release", "version")], collapse = " "), 
[16:04:40.967]                           hostname = base::Sys.info()[["nodename"]])
[16:04:40.967]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:40.967]                           info)
[16:04:40.967]                         info <- base::paste(info, collapse = "; ")
[16:04:40.967]                         if (!has_future) {
[16:04:40.967]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:40.967]                             info)
[16:04:40.967]                         }
[16:04:40.967]                         else {
[16:04:40.967]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:40.967]                             info, version)
[16:04:40.967]                         }
[16:04:40.967]                         base::stop(msg)
[16:04:40.967]                       }
[16:04:40.967]                     })
[16:04:40.967]                   }
[16:04:40.967]                   options(future.plan = NULL)
[16:04:40.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:40.967]                 }
[16:04:40.967]                 ...future.workdir <- getwd()
[16:04:40.967]             }
[16:04:40.967]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:40.967]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:40.967]         }
[16:04:40.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:40.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:40.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:40.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:40.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:40.967]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:40.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:40.967]             base::names(...future.oldOptions))
[16:04:40.967]     }
[16:04:40.967]     if (FALSE) {
[16:04:40.967]     }
[16:04:40.967]     else {
[16:04:40.967]         if (TRUE) {
[16:04:40.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:40.967]                 open = "w")
[16:04:40.967]         }
[16:04:40.967]         else {
[16:04:40.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:40.967]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:40.967]         }
[16:04:40.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:40.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:40.967]             base::sink(type = "output", split = FALSE)
[16:04:40.967]             base::close(...future.stdout)
[16:04:40.967]         }, add = TRUE)
[16:04:40.967]     }
[16:04:40.967]     ...future.frame <- base::sys.nframe()
[16:04:40.967]     ...future.conditions <- base::list()
[16:04:40.967]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:40.967]     if (FALSE) {
[16:04:40.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:40.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:40.967]     }
[16:04:40.967]     ...future.result <- base::tryCatch({
[16:04:40.967]         base::withCallingHandlers({
[16:04:40.967]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:40.967]             future::FutureResult(value = ...future.value$value, 
[16:04:40.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.967]                   ...future.rng), globalenv = if (FALSE) 
[16:04:40.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:40.967]                     ...future.globalenv.names))
[16:04:40.967]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:40.967]         }, condition = base::local({
[16:04:40.967]             c <- base::c
[16:04:40.967]             inherits <- base::inherits
[16:04:40.967]             invokeRestart <- base::invokeRestart
[16:04:40.967]             length <- base::length
[16:04:40.967]             list <- base::list
[16:04:40.967]             seq.int <- base::seq.int
[16:04:40.967]             signalCondition <- base::signalCondition
[16:04:40.967]             sys.calls <- base::sys.calls
[16:04:40.967]             `[[` <- base::`[[`
[16:04:40.967]             `+` <- base::`+`
[16:04:40.967]             `<<-` <- base::`<<-`
[16:04:40.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:40.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:40.967]                   3L)]
[16:04:40.967]             }
[16:04:40.967]             function(cond) {
[16:04:40.967]                 is_error <- inherits(cond, "error")
[16:04:40.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:40.967]                   NULL)
[16:04:40.967]                 if (is_error) {
[16:04:40.967]                   sessionInformation <- function() {
[16:04:40.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:40.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:40.967]                       search = base::search(), system = base::Sys.info())
[16:04:40.967]                   }
[16:04:40.967]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:40.967]                     cond$call), session = sessionInformation(), 
[16:04:40.967]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:40.967]                   signalCondition(cond)
[16:04:40.967]                 }
[16:04:40.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:40.967]                 "immediateCondition"))) {
[16:04:40.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:40.967]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:40.967]                   if (TRUE && !signal) {
[16:04:40.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.967]                     {
[16:04:40.967]                       inherits <- base::inherits
[16:04:40.967]                       invokeRestart <- base::invokeRestart
[16:04:40.967]                       is.null <- base::is.null
[16:04:40.967]                       muffled <- FALSE
[16:04:40.967]                       if (inherits(cond, "message")) {
[16:04:40.967]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.967]                         if (muffled) 
[16:04:40.967]                           invokeRestart("muffleMessage")
[16:04:40.967]                       }
[16:04:40.967]                       else if (inherits(cond, "warning")) {
[16:04:40.967]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.967]                         if (muffled) 
[16:04:40.967]                           invokeRestart("muffleWarning")
[16:04:40.967]                       }
[16:04:40.967]                       else if (inherits(cond, "condition")) {
[16:04:40.967]                         if (!is.null(pattern)) {
[16:04:40.967]                           computeRestarts <- base::computeRestarts
[16:04:40.967]                           grepl <- base::grepl
[16:04:40.967]                           restarts <- computeRestarts(cond)
[16:04:40.967]                           for (restart in restarts) {
[16:04:40.967]                             name <- restart$name
[16:04:40.967]                             if (is.null(name)) 
[16:04:40.967]                               next
[16:04:40.967]                             if (!grepl(pattern, name)) 
[16:04:40.967]                               next
[16:04:40.967]                             invokeRestart(restart)
[16:04:40.967]                             muffled <- TRUE
[16:04:40.967]                             break
[16:04:40.967]                           }
[16:04:40.967]                         }
[16:04:40.967]                       }
[16:04:40.967]                       invisible(muffled)
[16:04:40.967]                     }
[16:04:40.967]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.967]                   }
[16:04:40.967]                 }
[16:04:40.967]                 else {
[16:04:40.967]                   if (TRUE) {
[16:04:40.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.967]                     {
[16:04:40.967]                       inherits <- base::inherits
[16:04:40.967]                       invokeRestart <- base::invokeRestart
[16:04:40.967]                       is.null <- base::is.null
[16:04:40.967]                       muffled <- FALSE
[16:04:40.967]                       if (inherits(cond, "message")) {
[16:04:40.967]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.967]                         if (muffled) 
[16:04:40.967]                           invokeRestart("muffleMessage")
[16:04:40.967]                       }
[16:04:40.967]                       else if (inherits(cond, "warning")) {
[16:04:40.967]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.967]                         if (muffled) 
[16:04:40.967]                           invokeRestart("muffleWarning")
[16:04:40.967]                       }
[16:04:40.967]                       else if (inherits(cond, "condition")) {
[16:04:40.967]                         if (!is.null(pattern)) {
[16:04:40.967]                           computeRestarts <- base::computeRestarts
[16:04:40.967]                           grepl <- base::grepl
[16:04:40.967]                           restarts <- computeRestarts(cond)
[16:04:40.967]                           for (restart in restarts) {
[16:04:40.967]                             name <- restart$name
[16:04:40.967]                             if (is.null(name)) 
[16:04:40.967]                               next
[16:04:40.967]                             if (!grepl(pattern, name)) 
[16:04:40.967]                               next
[16:04:40.967]                             invokeRestart(restart)
[16:04:40.967]                             muffled <- TRUE
[16:04:40.967]                             break
[16:04:40.967]                           }
[16:04:40.967]                         }
[16:04:40.967]                       }
[16:04:40.967]                       invisible(muffled)
[16:04:40.967]                     }
[16:04:40.967]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.967]                   }
[16:04:40.967]                 }
[16:04:40.967]             }
[16:04:40.967]         }))
[16:04:40.967]     }, error = function(ex) {
[16:04:40.967]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:40.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.967]                 ...future.rng), started = ...future.startTime, 
[16:04:40.967]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:40.967]             version = "1.8"), class = "FutureResult")
[16:04:40.967]     }, finally = {
[16:04:40.967]         if (!identical(...future.workdir, getwd())) 
[16:04:40.967]             setwd(...future.workdir)
[16:04:40.967]         {
[16:04:40.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:40.967]                 ...future.oldOptions$nwarnings <- NULL
[16:04:40.967]             }
[16:04:40.967]             base::options(...future.oldOptions)
[16:04:40.967]             if (.Platform$OS.type == "windows") {
[16:04:40.967]                 old_names <- names(...future.oldEnvVars)
[16:04:40.967]                 envs <- base::Sys.getenv()
[16:04:40.967]                 names <- names(envs)
[16:04:40.967]                 common <- intersect(names, old_names)
[16:04:40.967]                 added <- setdiff(names, old_names)
[16:04:40.967]                 removed <- setdiff(old_names, names)
[16:04:40.967]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:40.967]                   envs[common]]
[16:04:40.967]                 NAMES <- toupper(changed)
[16:04:40.967]                 args <- list()
[16:04:40.967]                 for (kk in seq_along(NAMES)) {
[16:04:40.967]                   name <- changed[[kk]]
[16:04:40.967]                   NAME <- NAMES[[kk]]
[16:04:40.967]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.967]                     next
[16:04:40.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.967]                 }
[16:04:40.967]                 NAMES <- toupper(added)
[16:04:40.967]                 for (kk in seq_along(NAMES)) {
[16:04:40.967]                   name <- added[[kk]]
[16:04:40.967]                   NAME <- NAMES[[kk]]
[16:04:40.967]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.967]                     next
[16:04:40.967]                   args[[name]] <- ""
[16:04:40.967]                 }
[16:04:40.967]                 NAMES <- toupper(removed)
[16:04:40.967]                 for (kk in seq_along(NAMES)) {
[16:04:40.967]                   name <- removed[[kk]]
[16:04:40.967]                   NAME <- NAMES[[kk]]
[16:04:40.967]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.967]                     next
[16:04:40.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.967]                 }
[16:04:40.967]                 if (length(args) > 0) 
[16:04:40.967]                   base::do.call(base::Sys.setenv, args = args)
[16:04:40.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:40.967]             }
[16:04:40.967]             else {
[16:04:40.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:40.967]             }
[16:04:40.967]             {
[16:04:40.967]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:40.967]                   0L) {
[16:04:40.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:40.967]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:40.967]                   base::options(opts)
[16:04:40.967]                 }
[16:04:40.967]                 {
[16:04:40.967]                   {
[16:04:40.967]                     NULL
[16:04:40.967]                     RNGkind("Mersenne-Twister")
[16:04:40.967]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:40.967]                       inherits = FALSE)
[16:04:40.967]                   }
[16:04:40.967]                   options(future.plan = NULL)
[16:04:40.967]                   if (is.na(NA_character_)) 
[16:04:40.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:40.967]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:40.967]                   {
[16:04:40.967]                     future <- SequentialFuture(..., envir = envir)
[16:04:40.967]                     if (!future$lazy) 
[16:04:40.967]                       future <- run(future)
[16:04:40.967]                     invisible(future)
[16:04:40.967]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:40.967]                 }
[16:04:40.967]             }
[16:04:40.967]         }
[16:04:40.967]     })
[16:04:40.967]     if (TRUE) {
[16:04:40.967]         base::sink(type = "output", split = FALSE)
[16:04:40.967]         if (TRUE) {
[16:04:40.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:40.967]         }
[16:04:40.967]         else {
[16:04:40.967]             ...future.result["stdout"] <- base::list(NULL)
[16:04:40.967]         }
[16:04:40.967]         base::close(...future.stdout)
[16:04:40.967]         ...future.stdout <- NULL
[16:04:40.967]     }
[16:04:40.967]     ...future.result$conditions <- ...future.conditions
[16:04:40.967]     ...future.result$finished <- base::Sys.time()
[16:04:40.967]     ...future.result
[16:04:40.967] }
[16:04:40.969] plan(): Setting new future strategy stack:
[16:04:40.969] List of future strategies:
[16:04:40.969] 1. sequential:
[16:04:40.969]    - args: function (..., envir = parent.frame())
[16:04:40.969]    - tweaked: FALSE
[16:04:40.969]    - call: NULL
[16:04:40.970] plan(): nbrOfWorkers() = 1
[16:04:40.970] plan(): Setting new future strategy stack:
[16:04:40.970] List of future strategies:
[16:04:40.970] 1. sequential:
[16:04:40.970]    - args: function (..., envir = parent.frame())
[16:04:40.970]    - tweaked: FALSE
[16:04:40.970]    - call: plan(strategy)
[16:04:40.971] plan(): nbrOfWorkers() = 1
[16:04:40.971] SequentialFuture started (and completed)
[16:04:40.971] - Launch lazy future ... done
[16:04:40.971] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874c235ae8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874d6d0f10> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874c235ae8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874d6d0f10> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:04:40.976] resolved() for ‘SequentialFuture’ ...
[16:04:40.976] - state: ‘finished’
[16:04:40.976] - run: TRUE
[16:04:40.976] - result: ‘FutureResult’
[16:04:40.976] resolved() for ‘SequentialFuture’ ... done
[16:04:40.976] resolved() for ‘SequentialFuture’ ...
[16:04:40.976] - state: ‘finished’
[16:04:40.976] - run: TRUE
[16:04:40.977] - result: ‘FutureResult’
[16:04:40.977] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:40.978] resolve() on list ...
[16:04:40.978]  recursive: 0
[16:04:40.978]  length: 6
[16:04:40.979]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:40.979] signalConditionsASAP(numeric, pos=1) ...
[16:04:40.979] - nx: 6
[16:04:40.979] - relay: TRUE
[16:04:40.979] - stdout: TRUE
[16:04:40.979] - signal: TRUE
[16:04:40.979] - resignal: FALSE
[16:04:40.979] - force: TRUE
[16:04:40.979] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.979] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.979]  - until=2
[16:04:40.980]  - relaying element #2
[16:04:40.980] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.980] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.980] signalConditionsASAP(NULL, pos=1) ... done
[16:04:40.980]  length: 5 (resolved future 1)
[16:04:40.980] resolved() for ‘SequentialFuture’ ...
[16:04:40.980] - state: ‘finished’
[16:04:40.980] - run: TRUE
[16:04:40.980] - result: ‘FutureResult’
[16:04:40.980] resolved() for ‘SequentialFuture’ ... done
[16:04:40.980] Future #2
[16:04:40.982] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:40.982] - nx: 6
[16:04:40.982] - relay: TRUE
[16:04:40.982] - stdout: TRUE
[16:04:40.982] - signal: TRUE
[16:04:40.982] - resignal: FALSE
[16:04:40.982] - force: TRUE
[16:04:40.982] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.982] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:40.982]  - until=2
[16:04:40.982]  - relaying element #2
[16:04:40.983] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.983] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.983] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:40.983]  length: 4 (resolved future 2)
[16:04:40.983] resolved() for ‘SequentialFuture’ ...
[16:04:40.983] - state: ‘finished’
[16:04:40.983] - run: TRUE
[16:04:40.983] - result: ‘FutureResult’
[16:04:40.983] resolved() for ‘SequentialFuture’ ... done
[16:04:40.983] Future #3
[16:04:40.984] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:40.984] - nx: 6
[16:04:40.984] - relay: TRUE
[16:04:40.984] - stdout: TRUE
[16:04:40.984] - signal: TRUE
[16:04:40.984] - resignal: FALSE
[16:04:40.984] - force: TRUE
[16:04:40.984] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.984] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:40.984]  - until=3
[16:04:40.984]  - relaying element #3
[16:04:40.985] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.985] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.985] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:40.985]  length: 3 (resolved future 3)
[16:04:40.985] signalConditionsASAP(NULL, pos=4) ...
[16:04:40.985] - nx: 6
[16:04:40.985] - relay: TRUE
[16:04:40.985] - stdout: TRUE
[16:04:40.985] - signal: TRUE
[16:04:40.985] - resignal: FALSE
[16:04:40.985] - force: TRUE
[16:04:40.985] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.986] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.986]  - until=5
[16:04:40.986]  - relaying element #5
[16:04:40.986] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:40.986] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.986] signalConditionsASAP(NULL, pos=4) ... done
[16:04:40.986]  length: 2 (resolved future 4)
[16:04:40.986] signalConditionsASAP(NULL, pos=5) ...
[16:04:40.986] - nx: 6
[16:04:40.986] - relay: TRUE
[16:04:40.986] - stdout: TRUE
[16:04:40.986] - signal: TRUE
[16:04:40.987] - resignal: FALSE
[16:04:40.987] - force: TRUE
[16:04:40.987] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:40.987] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.987]  - until=6
[16:04:40.987]  - relaying element #6
[16:04:40.987] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:40.987] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.987] signalConditionsASAP(NULL, pos=5) ... done
[16:04:40.987]  length: 1 (resolved future 5)
[16:04:40.987] signalConditionsASAP(numeric, pos=6) ...
[16:04:40.987] - nx: 6
[16:04:40.988] - relay: TRUE
[16:04:40.988] - stdout: TRUE
[16:04:40.988] - signal: TRUE
[16:04:40.988] - resignal: FALSE
[16:04:40.988] - force: TRUE
[16:04:40.988] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:40.988] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.988]  - until=6
[16:04:40.988] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:40.988] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.988] signalConditionsASAP(numeric, pos=6) ... done
[16:04:40.988]  length: 0 (resolved future 6)
[16:04:40.989] Relaying remaining futures
[16:04:40.989] signalConditionsASAP(NULL, pos=0) ...
[16:04:40.989] - nx: 6
[16:04:40.989] - relay: TRUE
[16:04:40.989] - stdout: TRUE
[16:04:40.989] - signal: TRUE
[16:04:40.989] - resignal: FALSE
[16:04:40.989] - force: TRUE
[16:04:40.989] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:40.989] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:40.989] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:40.989] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:40.990] signalConditionsASAP(NULL, pos=0) ... done
[16:04:40.990] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:04:40.993] getGlobalsAndPackages() ...
[16:04:40.993] Searching for globals...
[16:04:40.993] 
[16:04:40.993] Searching for globals ... DONE
[16:04:40.993] - globals: [0] <none>
[16:04:40.993] getGlobalsAndPackages() ... DONE
[16:04:40.994] run() for ‘Future’ ...
[16:04:40.994] - state: ‘created’
[16:04:40.994] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:40.994] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:40.994] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:40.994]   - Field: ‘label’
[16:04:40.994]   - Field: ‘local’
[16:04:40.995]   - Field: ‘owner’
[16:04:40.995]   - Field: ‘envir’
[16:04:40.995]   - Field: ‘packages’
[16:04:40.995]   - Field: ‘gc’
[16:04:40.995]   - Field: ‘conditions’
[16:04:40.995]   - Field: ‘expr’
[16:04:40.995]   - Field: ‘uuid’
[16:04:40.995]   - Field: ‘seed’
[16:04:40.995]   - Field: ‘version’
[16:04:40.995]   - Field: ‘result’
[16:04:40.995]   - Field: ‘asynchronous’
[16:04:40.996]   - Field: ‘calls’
[16:04:40.996]   - Field: ‘globals’
[16:04:40.996]   - Field: ‘stdout’
[16:04:40.996]   - Field: ‘earlySignal’
[16:04:40.996]   - Field: ‘lazy’
[16:04:40.996]   - Field: ‘state’
[16:04:40.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:40.996] - Launch lazy future ...
[16:04:40.996] Packages needed by the future expression (n = 0): <none>
[16:04:40.996] Packages needed by future strategies (n = 0): <none>
[16:04:40.997] {
[16:04:40.997]     {
[16:04:40.997]         {
[16:04:40.997]             ...future.startTime <- base::Sys.time()
[16:04:40.997]             {
[16:04:40.997]                 {
[16:04:40.997]                   {
[16:04:40.997]                     base::local({
[16:04:40.997]                       has_future <- base::requireNamespace("future", 
[16:04:40.997]                         quietly = TRUE)
[16:04:40.997]                       if (has_future) {
[16:04:40.997]                         ns <- base::getNamespace("future")
[16:04:40.997]                         version <- ns[[".package"]][["version"]]
[16:04:40.997]                         if (is.null(version)) 
[16:04:40.997]                           version <- utils::packageVersion("future")
[16:04:40.997]                       }
[16:04:40.997]                       else {
[16:04:40.997]                         version <- NULL
[16:04:40.997]                       }
[16:04:40.997]                       if (!has_future || version < "1.8.0") {
[16:04:40.997]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:40.997]                           "", base::R.version$version.string), 
[16:04:40.997]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:40.997]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:40.997]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:40.997]                             "release", "version")], collapse = " "), 
[16:04:40.997]                           hostname = base::Sys.info()[["nodename"]])
[16:04:40.997]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:40.997]                           info)
[16:04:40.997]                         info <- base::paste(info, collapse = "; ")
[16:04:40.997]                         if (!has_future) {
[16:04:40.997]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:40.997]                             info)
[16:04:40.997]                         }
[16:04:40.997]                         else {
[16:04:40.997]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:40.997]                             info, version)
[16:04:40.997]                         }
[16:04:40.997]                         base::stop(msg)
[16:04:40.997]                       }
[16:04:40.997]                     })
[16:04:40.997]                   }
[16:04:40.997]                   options(future.plan = NULL)
[16:04:40.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:40.997]                 }
[16:04:40.997]                 ...future.workdir <- getwd()
[16:04:40.997]             }
[16:04:40.997]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:40.997]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:40.997]         }
[16:04:40.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:40.997]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:40.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:40.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:40.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:40.997]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:40.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:40.997]             base::names(...future.oldOptions))
[16:04:40.997]     }
[16:04:40.997]     if (FALSE) {
[16:04:40.997]     }
[16:04:40.997]     else {
[16:04:40.997]         if (TRUE) {
[16:04:40.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:40.997]                 open = "w")
[16:04:40.997]         }
[16:04:40.997]         else {
[16:04:40.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:40.997]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:40.997]         }
[16:04:40.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:40.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:40.997]             base::sink(type = "output", split = FALSE)
[16:04:40.997]             base::close(...future.stdout)
[16:04:40.997]         }, add = TRUE)
[16:04:40.997]     }
[16:04:40.997]     ...future.frame <- base::sys.nframe()
[16:04:40.997]     ...future.conditions <- base::list()
[16:04:40.997]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:40.997]     if (FALSE) {
[16:04:40.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:40.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:40.997]     }
[16:04:40.997]     ...future.result <- base::tryCatch({
[16:04:40.997]         base::withCallingHandlers({
[16:04:40.997]             ...future.value <- base::withVisible(base::local(2))
[16:04:40.997]             future::FutureResult(value = ...future.value$value, 
[16:04:40.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.997]                   ...future.rng), globalenv = if (FALSE) 
[16:04:40.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:40.997]                     ...future.globalenv.names))
[16:04:40.997]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:40.997]         }, condition = base::local({
[16:04:40.997]             c <- base::c
[16:04:40.997]             inherits <- base::inherits
[16:04:40.997]             invokeRestart <- base::invokeRestart
[16:04:40.997]             length <- base::length
[16:04:40.997]             list <- base::list
[16:04:40.997]             seq.int <- base::seq.int
[16:04:40.997]             signalCondition <- base::signalCondition
[16:04:40.997]             sys.calls <- base::sys.calls
[16:04:40.997]             `[[` <- base::`[[`
[16:04:40.997]             `+` <- base::`+`
[16:04:40.997]             `<<-` <- base::`<<-`
[16:04:40.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:40.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:40.997]                   3L)]
[16:04:40.997]             }
[16:04:40.997]             function(cond) {
[16:04:40.997]                 is_error <- inherits(cond, "error")
[16:04:40.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:40.997]                   NULL)
[16:04:40.997]                 if (is_error) {
[16:04:40.997]                   sessionInformation <- function() {
[16:04:40.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:40.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:40.997]                       search = base::search(), system = base::Sys.info())
[16:04:40.997]                   }
[16:04:40.997]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:40.997]                     cond$call), session = sessionInformation(), 
[16:04:40.997]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:40.997]                   signalCondition(cond)
[16:04:40.997]                 }
[16:04:40.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:40.997]                 "immediateCondition"))) {
[16:04:40.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:40.997]                   ...future.conditions[[length(...future.conditions) + 
[16:04:40.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:40.997]                   if (TRUE && !signal) {
[16:04:40.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.997]                     {
[16:04:40.997]                       inherits <- base::inherits
[16:04:40.997]                       invokeRestart <- base::invokeRestart
[16:04:40.997]                       is.null <- base::is.null
[16:04:40.997]                       muffled <- FALSE
[16:04:40.997]                       if (inherits(cond, "message")) {
[16:04:40.997]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.997]                         if (muffled) 
[16:04:40.997]                           invokeRestart("muffleMessage")
[16:04:40.997]                       }
[16:04:40.997]                       else if (inherits(cond, "warning")) {
[16:04:40.997]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.997]                         if (muffled) 
[16:04:40.997]                           invokeRestart("muffleWarning")
[16:04:40.997]                       }
[16:04:40.997]                       else if (inherits(cond, "condition")) {
[16:04:40.997]                         if (!is.null(pattern)) {
[16:04:40.997]                           computeRestarts <- base::computeRestarts
[16:04:40.997]                           grepl <- base::grepl
[16:04:40.997]                           restarts <- computeRestarts(cond)
[16:04:40.997]                           for (restart in restarts) {
[16:04:40.997]                             name <- restart$name
[16:04:40.997]                             if (is.null(name)) 
[16:04:40.997]                               next
[16:04:40.997]                             if (!grepl(pattern, name)) 
[16:04:40.997]                               next
[16:04:40.997]                             invokeRestart(restart)
[16:04:40.997]                             muffled <- TRUE
[16:04:40.997]                             break
[16:04:40.997]                           }
[16:04:40.997]                         }
[16:04:40.997]                       }
[16:04:40.997]                       invisible(muffled)
[16:04:40.997]                     }
[16:04:40.997]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.997]                   }
[16:04:40.997]                 }
[16:04:40.997]                 else {
[16:04:40.997]                   if (TRUE) {
[16:04:40.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:40.997]                     {
[16:04:40.997]                       inherits <- base::inherits
[16:04:40.997]                       invokeRestart <- base::invokeRestart
[16:04:40.997]                       is.null <- base::is.null
[16:04:40.997]                       muffled <- FALSE
[16:04:40.997]                       if (inherits(cond, "message")) {
[16:04:40.997]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:40.997]                         if (muffled) 
[16:04:40.997]                           invokeRestart("muffleMessage")
[16:04:40.997]                       }
[16:04:40.997]                       else if (inherits(cond, "warning")) {
[16:04:40.997]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:40.997]                         if (muffled) 
[16:04:40.997]                           invokeRestart("muffleWarning")
[16:04:40.997]                       }
[16:04:40.997]                       else if (inherits(cond, "condition")) {
[16:04:40.997]                         if (!is.null(pattern)) {
[16:04:40.997]                           computeRestarts <- base::computeRestarts
[16:04:40.997]                           grepl <- base::grepl
[16:04:40.997]                           restarts <- computeRestarts(cond)
[16:04:40.997]                           for (restart in restarts) {
[16:04:40.997]                             name <- restart$name
[16:04:40.997]                             if (is.null(name)) 
[16:04:40.997]                               next
[16:04:40.997]                             if (!grepl(pattern, name)) 
[16:04:40.997]                               next
[16:04:40.997]                             invokeRestart(restart)
[16:04:40.997]                             muffled <- TRUE
[16:04:40.997]                             break
[16:04:40.997]                           }
[16:04:40.997]                         }
[16:04:40.997]                       }
[16:04:40.997]                       invisible(muffled)
[16:04:40.997]                     }
[16:04:40.997]                     muffleCondition(cond, pattern = "^muffle")
[16:04:40.997]                   }
[16:04:40.997]                 }
[16:04:40.997]             }
[16:04:40.997]         }))
[16:04:40.997]     }, error = function(ex) {
[16:04:40.997]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:40.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:40.997]                 ...future.rng), started = ...future.startTime, 
[16:04:40.997]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:40.997]             version = "1.8"), class = "FutureResult")
[16:04:40.997]     }, finally = {
[16:04:40.997]         if (!identical(...future.workdir, getwd())) 
[16:04:40.997]             setwd(...future.workdir)
[16:04:40.997]         {
[16:04:40.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:40.997]                 ...future.oldOptions$nwarnings <- NULL
[16:04:40.997]             }
[16:04:40.997]             base::options(...future.oldOptions)
[16:04:40.997]             if (.Platform$OS.type == "windows") {
[16:04:40.997]                 old_names <- names(...future.oldEnvVars)
[16:04:40.997]                 envs <- base::Sys.getenv()
[16:04:40.997]                 names <- names(envs)
[16:04:40.997]                 common <- intersect(names, old_names)
[16:04:40.997]                 added <- setdiff(names, old_names)
[16:04:40.997]                 removed <- setdiff(old_names, names)
[16:04:40.997]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:40.997]                   envs[common]]
[16:04:40.997]                 NAMES <- toupper(changed)
[16:04:40.997]                 args <- list()
[16:04:40.997]                 for (kk in seq_along(NAMES)) {
[16:04:40.997]                   name <- changed[[kk]]
[16:04:40.997]                   NAME <- NAMES[[kk]]
[16:04:40.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.997]                     next
[16:04:40.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.997]                 }
[16:04:40.997]                 NAMES <- toupper(added)
[16:04:40.997]                 for (kk in seq_along(NAMES)) {
[16:04:40.997]                   name <- added[[kk]]
[16:04:40.997]                   NAME <- NAMES[[kk]]
[16:04:40.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.997]                     next
[16:04:40.997]                   args[[name]] <- ""
[16:04:40.997]                 }
[16:04:40.997]                 NAMES <- toupper(removed)
[16:04:40.997]                 for (kk in seq_along(NAMES)) {
[16:04:40.997]                   name <- removed[[kk]]
[16:04:40.997]                   NAME <- NAMES[[kk]]
[16:04:40.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:40.997]                     next
[16:04:40.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:40.997]                 }
[16:04:40.997]                 if (length(args) > 0) 
[16:04:40.997]                   base::do.call(base::Sys.setenv, args = args)
[16:04:40.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:40.997]             }
[16:04:40.997]             else {
[16:04:40.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:40.997]             }
[16:04:40.997]             {
[16:04:40.997]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:40.997]                   0L) {
[16:04:40.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:40.997]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:40.997]                   base::options(opts)
[16:04:40.997]                 }
[16:04:40.997]                 {
[16:04:40.997]                   {
[16:04:40.997]                     NULL
[16:04:40.997]                     RNGkind("Mersenne-Twister")
[16:04:40.997]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:40.997]                       inherits = FALSE)
[16:04:40.997]                   }
[16:04:40.997]                   options(future.plan = NULL)
[16:04:40.997]                   if (is.na(NA_character_)) 
[16:04:40.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:40.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:40.997]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:40.997]                   {
[16:04:40.997]                     future <- SequentialFuture(..., envir = envir)
[16:04:40.997]                     if (!future$lazy) 
[16:04:40.997]                       future <- run(future)
[16:04:40.997]                     invisible(future)
[16:04:40.997]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:40.997]                 }
[16:04:40.997]             }
[16:04:40.997]         }
[16:04:40.997]     })
[16:04:40.997]     if (TRUE) {
[16:04:40.997]         base::sink(type = "output", split = FALSE)
[16:04:40.997]         if (TRUE) {
[16:04:40.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:40.997]         }
[16:04:40.997]         else {
[16:04:40.997]             ...future.result["stdout"] <- base::list(NULL)
[16:04:40.997]         }
[16:04:40.997]         base::close(...future.stdout)
[16:04:40.997]         ...future.stdout <- NULL
[16:04:40.997]     }
[16:04:40.997]     ...future.result$conditions <- ...future.conditions
[16:04:40.997]     ...future.result$finished <- base::Sys.time()
[16:04:40.997]     ...future.result
[16:04:40.997] }
[16:04:40.999] plan(): Setting new future strategy stack:
[16:04:40.999] List of future strategies:
[16:04:40.999] 1. sequential:
[16:04:40.999]    - args: function (..., envir = parent.frame())
[16:04:40.999]    - tweaked: FALSE
[16:04:40.999]    - call: NULL
[16:04:40.999] plan(): nbrOfWorkers() = 1
[16:04:41.000] plan(): Setting new future strategy stack:
[16:04:41.000] List of future strategies:
[16:04:41.000] 1. sequential:
[16:04:41.000]    - args: function (..., envir = parent.frame())
[16:04:41.000]    - tweaked: FALSE
[16:04:41.000]    - call: plan(strategy)
[16:04:41.000] plan(): nbrOfWorkers() = 1
[16:04:41.000] SequentialFuture started (and completed)
[16:04:41.000] - Launch lazy future ... done
[16:04:41.000] run() for ‘SequentialFuture’ ... done
[16:04:41.001] getGlobalsAndPackages() ...
[16:04:41.001] Searching for globals...
[16:04:41.001] 
[16:04:41.001] Searching for globals ... DONE
[16:04:41.001] - globals: [0] <none>
[16:04:41.001] getGlobalsAndPackages() ... DONE
[16:04:41.001] run() for ‘Future’ ...
[16:04:41.001] - state: ‘created’
[16:04:41.002] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.002] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.002] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.002]   - Field: ‘label’
[16:04:41.002]   - Field: ‘local’
[16:04:41.002]   - Field: ‘owner’
[16:04:41.002]   - Field: ‘envir’
[16:04:41.002]   - Field: ‘packages’
[16:04:41.002]   - Field: ‘gc’
[16:04:41.003]   - Field: ‘conditions’
[16:04:41.003]   - Field: ‘expr’
[16:04:41.003]   - Field: ‘uuid’
[16:04:41.003]   - Field: ‘seed’
[16:04:41.003]   - Field: ‘version’
[16:04:41.003]   - Field: ‘result’
[16:04:41.003]   - Field: ‘asynchronous’
[16:04:41.003]   - Field: ‘calls’
[16:04:41.003]   - Field: ‘globals’
[16:04:41.003]   - Field: ‘stdout’
[16:04:41.003]   - Field: ‘earlySignal’
[16:04:41.004]   - Field: ‘lazy’
[16:04:41.004]   - Field: ‘state’
[16:04:41.004] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.004] - Launch lazy future ...
[16:04:41.004] Packages needed by the future expression (n = 0): <none>
[16:04:41.004] Packages needed by future strategies (n = 0): <none>
[16:04:41.004] {
[16:04:41.004]     {
[16:04:41.004]         {
[16:04:41.004]             ...future.startTime <- base::Sys.time()
[16:04:41.004]             {
[16:04:41.004]                 {
[16:04:41.004]                   {
[16:04:41.004]                     base::local({
[16:04:41.004]                       has_future <- base::requireNamespace("future", 
[16:04:41.004]                         quietly = TRUE)
[16:04:41.004]                       if (has_future) {
[16:04:41.004]                         ns <- base::getNamespace("future")
[16:04:41.004]                         version <- ns[[".package"]][["version"]]
[16:04:41.004]                         if (is.null(version)) 
[16:04:41.004]                           version <- utils::packageVersion("future")
[16:04:41.004]                       }
[16:04:41.004]                       else {
[16:04:41.004]                         version <- NULL
[16:04:41.004]                       }
[16:04:41.004]                       if (!has_future || version < "1.8.0") {
[16:04:41.004]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.004]                           "", base::R.version$version.string), 
[16:04:41.004]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.004]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.004]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.004]                             "release", "version")], collapse = " "), 
[16:04:41.004]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.004]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.004]                           info)
[16:04:41.004]                         info <- base::paste(info, collapse = "; ")
[16:04:41.004]                         if (!has_future) {
[16:04:41.004]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.004]                             info)
[16:04:41.004]                         }
[16:04:41.004]                         else {
[16:04:41.004]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.004]                             info, version)
[16:04:41.004]                         }
[16:04:41.004]                         base::stop(msg)
[16:04:41.004]                       }
[16:04:41.004]                     })
[16:04:41.004]                   }
[16:04:41.004]                   options(future.plan = NULL)
[16:04:41.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.004]                 }
[16:04:41.004]                 ...future.workdir <- getwd()
[16:04:41.004]             }
[16:04:41.004]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.004]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.004]         }
[16:04:41.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.004]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.004]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.004]             base::names(...future.oldOptions))
[16:04:41.004]     }
[16:04:41.004]     if (FALSE) {
[16:04:41.004]     }
[16:04:41.004]     else {
[16:04:41.004]         if (TRUE) {
[16:04:41.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.004]                 open = "w")
[16:04:41.004]         }
[16:04:41.004]         else {
[16:04:41.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.004]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.004]         }
[16:04:41.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.004]             base::sink(type = "output", split = FALSE)
[16:04:41.004]             base::close(...future.stdout)
[16:04:41.004]         }, add = TRUE)
[16:04:41.004]     }
[16:04:41.004]     ...future.frame <- base::sys.nframe()
[16:04:41.004]     ...future.conditions <- base::list()
[16:04:41.004]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.004]     if (FALSE) {
[16:04:41.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.004]     }
[16:04:41.004]     ...future.result <- base::tryCatch({
[16:04:41.004]         base::withCallingHandlers({
[16:04:41.004]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:41.004]             future::FutureResult(value = ...future.value$value, 
[16:04:41.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.004]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.004]                     ...future.globalenv.names))
[16:04:41.004]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.004]         }, condition = base::local({
[16:04:41.004]             c <- base::c
[16:04:41.004]             inherits <- base::inherits
[16:04:41.004]             invokeRestart <- base::invokeRestart
[16:04:41.004]             length <- base::length
[16:04:41.004]             list <- base::list
[16:04:41.004]             seq.int <- base::seq.int
[16:04:41.004]             signalCondition <- base::signalCondition
[16:04:41.004]             sys.calls <- base::sys.calls
[16:04:41.004]             `[[` <- base::`[[`
[16:04:41.004]             `+` <- base::`+`
[16:04:41.004]             `<<-` <- base::`<<-`
[16:04:41.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.004]                   3L)]
[16:04:41.004]             }
[16:04:41.004]             function(cond) {
[16:04:41.004]                 is_error <- inherits(cond, "error")
[16:04:41.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.004]                   NULL)
[16:04:41.004]                 if (is_error) {
[16:04:41.004]                   sessionInformation <- function() {
[16:04:41.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.004]                       search = base::search(), system = base::Sys.info())
[16:04:41.004]                   }
[16:04:41.004]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.004]                     cond$call), session = sessionInformation(), 
[16:04:41.004]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.004]                   signalCondition(cond)
[16:04:41.004]                 }
[16:04:41.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.004]                 "immediateCondition"))) {
[16:04:41.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.004]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.004]                   if (TRUE && !signal) {
[16:04:41.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.004]                     {
[16:04:41.004]                       inherits <- base::inherits
[16:04:41.004]                       invokeRestart <- base::invokeRestart
[16:04:41.004]                       is.null <- base::is.null
[16:04:41.004]                       muffled <- FALSE
[16:04:41.004]                       if (inherits(cond, "message")) {
[16:04:41.004]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.004]                         if (muffled) 
[16:04:41.004]                           invokeRestart("muffleMessage")
[16:04:41.004]                       }
[16:04:41.004]                       else if (inherits(cond, "warning")) {
[16:04:41.004]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.004]                         if (muffled) 
[16:04:41.004]                           invokeRestart("muffleWarning")
[16:04:41.004]                       }
[16:04:41.004]                       else if (inherits(cond, "condition")) {
[16:04:41.004]                         if (!is.null(pattern)) {
[16:04:41.004]                           computeRestarts <- base::computeRestarts
[16:04:41.004]                           grepl <- base::grepl
[16:04:41.004]                           restarts <- computeRestarts(cond)
[16:04:41.004]                           for (restart in restarts) {
[16:04:41.004]                             name <- restart$name
[16:04:41.004]                             if (is.null(name)) 
[16:04:41.004]                               next
[16:04:41.004]                             if (!grepl(pattern, name)) 
[16:04:41.004]                               next
[16:04:41.004]                             invokeRestart(restart)
[16:04:41.004]                             muffled <- TRUE
[16:04:41.004]                             break
[16:04:41.004]                           }
[16:04:41.004]                         }
[16:04:41.004]                       }
[16:04:41.004]                       invisible(muffled)
[16:04:41.004]                     }
[16:04:41.004]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.004]                   }
[16:04:41.004]                 }
[16:04:41.004]                 else {
[16:04:41.004]                   if (TRUE) {
[16:04:41.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.004]                     {
[16:04:41.004]                       inherits <- base::inherits
[16:04:41.004]                       invokeRestart <- base::invokeRestart
[16:04:41.004]                       is.null <- base::is.null
[16:04:41.004]                       muffled <- FALSE
[16:04:41.004]                       if (inherits(cond, "message")) {
[16:04:41.004]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.004]                         if (muffled) 
[16:04:41.004]                           invokeRestart("muffleMessage")
[16:04:41.004]                       }
[16:04:41.004]                       else if (inherits(cond, "warning")) {
[16:04:41.004]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.004]                         if (muffled) 
[16:04:41.004]                           invokeRestart("muffleWarning")
[16:04:41.004]                       }
[16:04:41.004]                       else if (inherits(cond, "condition")) {
[16:04:41.004]                         if (!is.null(pattern)) {
[16:04:41.004]                           computeRestarts <- base::computeRestarts
[16:04:41.004]                           grepl <- base::grepl
[16:04:41.004]                           restarts <- computeRestarts(cond)
[16:04:41.004]                           for (restart in restarts) {
[16:04:41.004]                             name <- restart$name
[16:04:41.004]                             if (is.null(name)) 
[16:04:41.004]                               next
[16:04:41.004]                             if (!grepl(pattern, name)) 
[16:04:41.004]                               next
[16:04:41.004]                             invokeRestart(restart)
[16:04:41.004]                             muffled <- TRUE
[16:04:41.004]                             break
[16:04:41.004]                           }
[16:04:41.004]                         }
[16:04:41.004]                       }
[16:04:41.004]                       invisible(muffled)
[16:04:41.004]                     }
[16:04:41.004]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.004]                   }
[16:04:41.004]                 }
[16:04:41.004]             }
[16:04:41.004]         }))
[16:04:41.004]     }, error = function(ex) {
[16:04:41.004]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.004]                 ...future.rng), started = ...future.startTime, 
[16:04:41.004]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.004]             version = "1.8"), class = "FutureResult")
[16:04:41.004]     }, finally = {
[16:04:41.004]         if (!identical(...future.workdir, getwd())) 
[16:04:41.004]             setwd(...future.workdir)
[16:04:41.004]         {
[16:04:41.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.004]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.004]             }
[16:04:41.004]             base::options(...future.oldOptions)
[16:04:41.004]             if (.Platform$OS.type == "windows") {
[16:04:41.004]                 old_names <- names(...future.oldEnvVars)
[16:04:41.004]                 envs <- base::Sys.getenv()
[16:04:41.004]                 names <- names(envs)
[16:04:41.004]                 common <- intersect(names, old_names)
[16:04:41.004]                 added <- setdiff(names, old_names)
[16:04:41.004]                 removed <- setdiff(old_names, names)
[16:04:41.004]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.004]                   envs[common]]
[16:04:41.004]                 NAMES <- toupper(changed)
[16:04:41.004]                 args <- list()
[16:04:41.004]                 for (kk in seq_along(NAMES)) {
[16:04:41.004]                   name <- changed[[kk]]
[16:04:41.004]                   NAME <- NAMES[[kk]]
[16:04:41.004]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.004]                     next
[16:04:41.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.004]                 }
[16:04:41.004]                 NAMES <- toupper(added)
[16:04:41.004]                 for (kk in seq_along(NAMES)) {
[16:04:41.004]                   name <- added[[kk]]
[16:04:41.004]                   NAME <- NAMES[[kk]]
[16:04:41.004]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.004]                     next
[16:04:41.004]                   args[[name]] <- ""
[16:04:41.004]                 }
[16:04:41.004]                 NAMES <- toupper(removed)
[16:04:41.004]                 for (kk in seq_along(NAMES)) {
[16:04:41.004]                   name <- removed[[kk]]
[16:04:41.004]                   NAME <- NAMES[[kk]]
[16:04:41.004]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.004]                     next
[16:04:41.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.004]                 }
[16:04:41.004]                 if (length(args) > 0) 
[16:04:41.004]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.004]             }
[16:04:41.004]             else {
[16:04:41.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.004]             }
[16:04:41.004]             {
[16:04:41.004]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.004]                   0L) {
[16:04:41.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.004]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.004]                   base::options(opts)
[16:04:41.004]                 }
[16:04:41.004]                 {
[16:04:41.004]                   {
[16:04:41.004]                     NULL
[16:04:41.004]                     RNGkind("Mersenne-Twister")
[16:04:41.004]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.004]                       inherits = FALSE)
[16:04:41.004]                   }
[16:04:41.004]                   options(future.plan = NULL)
[16:04:41.004]                   if (is.na(NA_character_)) 
[16:04:41.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.004]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.004]                   {
[16:04:41.004]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.004]                     if (!future$lazy) 
[16:04:41.004]                       future <- run(future)
[16:04:41.004]                     invisible(future)
[16:04:41.004]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.004]                 }
[16:04:41.004]             }
[16:04:41.004]         }
[16:04:41.004]     })
[16:04:41.004]     if (TRUE) {
[16:04:41.004]         base::sink(type = "output", split = FALSE)
[16:04:41.004]         if (TRUE) {
[16:04:41.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.004]         }
[16:04:41.004]         else {
[16:04:41.004]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.004]         }
[16:04:41.004]         base::close(...future.stdout)
[16:04:41.004]         ...future.stdout <- NULL
[16:04:41.004]     }
[16:04:41.004]     ...future.result$conditions <- ...future.conditions
[16:04:41.004]     ...future.result$finished <- base::Sys.time()
[16:04:41.004]     ...future.result
[16:04:41.004] }
[16:04:41.006] plan(): Setting new future strategy stack:
[16:04:41.006] List of future strategies:
[16:04:41.006] 1. sequential:
[16:04:41.006]    - args: function (..., envir = parent.frame())
[16:04:41.006]    - tweaked: FALSE
[16:04:41.006]    - call: NULL
[16:04:41.007] plan(): nbrOfWorkers() = 1
[16:04:41.007] plan(): Setting new future strategy stack:
[16:04:41.007] List of future strategies:
[16:04:41.007] 1. sequential:
[16:04:41.007]    - args: function (..., envir = parent.frame())
[16:04:41.007]    - tweaked: FALSE
[16:04:41.007]    - call: plan(strategy)
[16:04:41.008] plan(): nbrOfWorkers() = 1
[16:04:41.009] SequentialFuture started (and completed)
[16:04:41.009] - Launch lazy future ... done
[16:04:41.009] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874da7e110> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874de6b510> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874da7e110> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55874de6b510> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:04:41.014] resolved() for ‘SequentialFuture’ ...
[16:04:41.014] - state: ‘finished’
[16:04:41.015] - run: TRUE
[16:04:41.015] - result: ‘FutureResult’
[16:04:41.015] resolved() for ‘SequentialFuture’ ... done
[16:04:41.015] resolved() for ‘SequentialFuture’ ...
[16:04:41.015] - state: ‘finished’
[16:04:41.015] - run: TRUE
[16:04:41.015] - result: ‘FutureResult’
[16:04:41.015] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:41.017] resolve() on list ...
[16:04:41.017]  recursive: 0
[16:04:41.017]  length: 6
[16:04:41.017]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:41.017] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.018] - nx: 6
[16:04:41.018] - relay: TRUE
[16:04:41.018] - stdout: TRUE
[16:04:41.018] - signal: TRUE
[16:04:41.018] - resignal: FALSE
[16:04:41.018] - force: TRUE
[16:04:41.018] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.018] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.018]  - until=2
[16:04:41.018]  - relaying element #2
[16:04:41.018] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.018] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.019] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.019]  length: 5 (resolved future 1)
[16:04:41.019] resolved() for ‘SequentialFuture’ ...
[16:04:41.019] - state: ‘finished’
[16:04:41.019] - run: TRUE
[16:04:41.019] - result: ‘FutureResult’
[16:04:41.019] resolved() for ‘SequentialFuture’ ... done
[16:04:41.019] Future #2
[16:04:41.019] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:41.019] - nx: 6
[16:04:41.019] - relay: TRUE
[16:04:41.020] - stdout: TRUE
[16:04:41.020] - signal: TRUE
[16:04:41.020] - resignal: FALSE
[16:04:41.020] - force: TRUE
[16:04:41.020] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.020] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.020]  - until=2
[16:04:41.020]  - relaying element #2
[16:04:41.020] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.020] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.020] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:41.021]  length: 4 (resolved future 2)
[16:04:41.021] resolved() for ‘SequentialFuture’ ...
[16:04:41.021] - state: ‘finished’
[16:04:41.021] - run: TRUE
[16:04:41.021] - result: ‘FutureResult’
[16:04:41.021] resolved() for ‘SequentialFuture’ ... done
[16:04:41.021] Future #3
[16:04:41.021] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:41.021] - nx: 6
[16:04:41.021] - relay: TRUE
[16:04:41.021] - stdout: TRUE
[16:04:41.022] - signal: TRUE
[16:04:41.022] - resignal: FALSE
[16:04:41.022] - force: TRUE
[16:04:41.022] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.022] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.022]  - until=3
[16:04:41.022]  - relaying element #3
[16:04:41.022] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.022] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.022] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:41.022]  length: 3 (resolved future 3)
[16:04:41.023] signalConditionsASAP(NULL, pos=4) ...
[16:04:41.023] - nx: 6
[16:04:41.023] - relay: TRUE
[16:04:41.023] - stdout: TRUE
[16:04:41.023] - signal: TRUE
[16:04:41.023] - resignal: FALSE
[16:04:41.023] - force: TRUE
[16:04:41.023] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.023] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.023]  - until=5
[16:04:41.023]  - relaying element #5
[16:04:41.024] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.024] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.024] signalConditionsASAP(NULL, pos=4) ... done
[16:04:41.024]  length: 2 (resolved future 4)
[16:04:41.024] signalConditionsASAP(NULL, pos=5) ...
[16:04:41.024] - nx: 6
[16:04:41.024] - relay: TRUE
[16:04:41.024] - stdout: TRUE
[16:04:41.024] - signal: TRUE
[16:04:41.024] - resignal: FALSE
[16:04:41.024] - force: TRUE
[16:04:41.024] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.025] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.025]  - until=6
[16:04:41.025]  - relaying element #6
[16:04:41.025] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.025] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.025] signalConditionsASAP(NULL, pos=5) ... done
[16:04:41.025]  length: 1 (resolved future 5)
[16:04:41.025] signalConditionsASAP(numeric, pos=6) ...
[16:04:41.025] - nx: 6
[16:04:41.025] - relay: TRUE
[16:04:41.025] - stdout: TRUE
[16:04:41.025] - signal: TRUE
[16:04:41.025] - resignal: FALSE
[16:04:41.026] - force: TRUE
[16:04:41.026] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.026] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.026]  - until=6
[16:04:41.026] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.026] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.026] signalConditionsASAP(numeric, pos=6) ... done
[16:04:41.026]  length: 0 (resolved future 6)
[16:04:41.026] Relaying remaining futures
[16:04:41.026] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.026] - nx: 6
[16:04:41.026] - relay: TRUE
[16:04:41.026] - stdout: TRUE
[16:04:41.027] - signal: TRUE
[16:04:41.027] - resignal: FALSE
[16:04:41.027] - force: TRUE
[16:04:41.027] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.027] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:41.027] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.027] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.027] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.027] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[16:04:41.037] plan(): Setting new future strategy stack:
[16:04:41.037] List of future strategies:
[16:04:41.037] 1. sequential:
[16:04:41.037]    - args: function (..., envir = parent.frame())
[16:04:41.037]    - tweaked: FALSE
[16:04:41.037]    - call: plan(strategy)
[16:04:41.037] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[16:04:41.037] getGlobalsAndPackages() ...
[16:04:41.037] Searching for globals...
[16:04:41.037] 
[16:04:41.038] Searching for globals ... DONE
[16:04:41.038] - globals: [0] <none>
[16:04:41.038] getGlobalsAndPackages() ... DONE
[16:04:41.038] run() for ‘Future’ ...
[16:04:41.038] - state: ‘created’
[16:04:41.038] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.038] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.039] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.039]   - Field: ‘label’
[16:04:41.039]   - Field: ‘local’
[16:04:41.039]   - Field: ‘owner’
[16:04:41.039]   - Field: ‘envir’
[16:04:41.039]   - Field: ‘packages’
[16:04:41.039]   - Field: ‘gc’
[16:04:41.039]   - Field: ‘conditions’
[16:04:41.039]   - Field: ‘expr’
[16:04:41.039]   - Field: ‘uuid’
[16:04:41.039]   - Field: ‘seed’
[16:04:41.040]   - Field: ‘version’
[16:04:41.040]   - Field: ‘result’
[16:04:41.040]   - Field: ‘asynchronous’
[16:04:41.040]   - Field: ‘calls’
[16:04:41.040]   - Field: ‘globals’
[16:04:41.040]   - Field: ‘stdout’
[16:04:41.040]   - Field: ‘earlySignal’
[16:04:41.040]   - Field: ‘lazy’
[16:04:41.040]   - Field: ‘state’
[16:04:41.040] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.040] - Launch lazy future ...
[16:04:41.041] Packages needed by the future expression (n = 0): <none>
[16:04:41.041] Packages needed by future strategies (n = 0): <none>
[16:04:41.041] {
[16:04:41.041]     {
[16:04:41.041]         {
[16:04:41.041]             ...future.startTime <- base::Sys.time()
[16:04:41.041]             {
[16:04:41.041]                 {
[16:04:41.041]                   {
[16:04:41.041]                     base::local({
[16:04:41.041]                       has_future <- base::requireNamespace("future", 
[16:04:41.041]                         quietly = TRUE)
[16:04:41.041]                       if (has_future) {
[16:04:41.041]                         ns <- base::getNamespace("future")
[16:04:41.041]                         version <- ns[[".package"]][["version"]]
[16:04:41.041]                         if (is.null(version)) 
[16:04:41.041]                           version <- utils::packageVersion("future")
[16:04:41.041]                       }
[16:04:41.041]                       else {
[16:04:41.041]                         version <- NULL
[16:04:41.041]                       }
[16:04:41.041]                       if (!has_future || version < "1.8.0") {
[16:04:41.041]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.041]                           "", base::R.version$version.string), 
[16:04:41.041]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.041]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.041]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.041]                             "release", "version")], collapse = " "), 
[16:04:41.041]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.041]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.041]                           info)
[16:04:41.041]                         info <- base::paste(info, collapse = "; ")
[16:04:41.041]                         if (!has_future) {
[16:04:41.041]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.041]                             info)
[16:04:41.041]                         }
[16:04:41.041]                         else {
[16:04:41.041]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.041]                             info, version)
[16:04:41.041]                         }
[16:04:41.041]                         base::stop(msg)
[16:04:41.041]                       }
[16:04:41.041]                     })
[16:04:41.041]                   }
[16:04:41.041]                   options(future.plan = NULL)
[16:04:41.041]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.041]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.041]                 }
[16:04:41.041]                 ...future.workdir <- getwd()
[16:04:41.041]             }
[16:04:41.041]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.041]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.041]         }
[16:04:41.041]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.041]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.041]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.041]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.041]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.041]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.041]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.041]             base::names(...future.oldOptions))
[16:04:41.041]     }
[16:04:41.041]     if (FALSE) {
[16:04:41.041]     }
[16:04:41.041]     else {
[16:04:41.041]         if (TRUE) {
[16:04:41.041]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.041]                 open = "w")
[16:04:41.041]         }
[16:04:41.041]         else {
[16:04:41.041]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.041]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.041]         }
[16:04:41.041]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.041]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.041]             base::sink(type = "output", split = FALSE)
[16:04:41.041]             base::close(...future.stdout)
[16:04:41.041]         }, add = TRUE)
[16:04:41.041]     }
[16:04:41.041]     ...future.frame <- base::sys.nframe()
[16:04:41.041]     ...future.conditions <- base::list()
[16:04:41.041]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.041]     if (FALSE) {
[16:04:41.041]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.041]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.041]     }
[16:04:41.041]     ...future.result <- base::tryCatch({
[16:04:41.041]         base::withCallingHandlers({
[16:04:41.041]             ...future.value <- base::withVisible(base::local(2))
[16:04:41.041]             future::FutureResult(value = ...future.value$value, 
[16:04:41.041]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.041]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.041]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.041]                     ...future.globalenv.names))
[16:04:41.041]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.041]         }, condition = base::local({
[16:04:41.041]             c <- base::c
[16:04:41.041]             inherits <- base::inherits
[16:04:41.041]             invokeRestart <- base::invokeRestart
[16:04:41.041]             length <- base::length
[16:04:41.041]             list <- base::list
[16:04:41.041]             seq.int <- base::seq.int
[16:04:41.041]             signalCondition <- base::signalCondition
[16:04:41.041]             sys.calls <- base::sys.calls
[16:04:41.041]             `[[` <- base::`[[`
[16:04:41.041]             `+` <- base::`+`
[16:04:41.041]             `<<-` <- base::`<<-`
[16:04:41.041]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.041]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.041]                   3L)]
[16:04:41.041]             }
[16:04:41.041]             function(cond) {
[16:04:41.041]                 is_error <- inherits(cond, "error")
[16:04:41.041]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.041]                   NULL)
[16:04:41.041]                 if (is_error) {
[16:04:41.041]                   sessionInformation <- function() {
[16:04:41.041]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.041]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.041]                       search = base::search(), system = base::Sys.info())
[16:04:41.041]                   }
[16:04:41.041]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.041]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.041]                     cond$call), session = sessionInformation(), 
[16:04:41.041]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.041]                   signalCondition(cond)
[16:04:41.041]                 }
[16:04:41.041]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.041]                 "immediateCondition"))) {
[16:04:41.041]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.041]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.041]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.041]                   if (TRUE && !signal) {
[16:04:41.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.041]                     {
[16:04:41.041]                       inherits <- base::inherits
[16:04:41.041]                       invokeRestart <- base::invokeRestart
[16:04:41.041]                       is.null <- base::is.null
[16:04:41.041]                       muffled <- FALSE
[16:04:41.041]                       if (inherits(cond, "message")) {
[16:04:41.041]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.041]                         if (muffled) 
[16:04:41.041]                           invokeRestart("muffleMessage")
[16:04:41.041]                       }
[16:04:41.041]                       else if (inherits(cond, "warning")) {
[16:04:41.041]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.041]                         if (muffled) 
[16:04:41.041]                           invokeRestart("muffleWarning")
[16:04:41.041]                       }
[16:04:41.041]                       else if (inherits(cond, "condition")) {
[16:04:41.041]                         if (!is.null(pattern)) {
[16:04:41.041]                           computeRestarts <- base::computeRestarts
[16:04:41.041]                           grepl <- base::grepl
[16:04:41.041]                           restarts <- computeRestarts(cond)
[16:04:41.041]                           for (restart in restarts) {
[16:04:41.041]                             name <- restart$name
[16:04:41.041]                             if (is.null(name)) 
[16:04:41.041]                               next
[16:04:41.041]                             if (!grepl(pattern, name)) 
[16:04:41.041]                               next
[16:04:41.041]                             invokeRestart(restart)
[16:04:41.041]                             muffled <- TRUE
[16:04:41.041]                             break
[16:04:41.041]                           }
[16:04:41.041]                         }
[16:04:41.041]                       }
[16:04:41.041]                       invisible(muffled)
[16:04:41.041]                     }
[16:04:41.041]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.041]                   }
[16:04:41.041]                 }
[16:04:41.041]                 else {
[16:04:41.041]                   if (TRUE) {
[16:04:41.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.041]                     {
[16:04:41.041]                       inherits <- base::inherits
[16:04:41.041]                       invokeRestart <- base::invokeRestart
[16:04:41.041]                       is.null <- base::is.null
[16:04:41.041]                       muffled <- FALSE
[16:04:41.041]                       if (inherits(cond, "message")) {
[16:04:41.041]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.041]                         if (muffled) 
[16:04:41.041]                           invokeRestart("muffleMessage")
[16:04:41.041]                       }
[16:04:41.041]                       else if (inherits(cond, "warning")) {
[16:04:41.041]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.041]                         if (muffled) 
[16:04:41.041]                           invokeRestart("muffleWarning")
[16:04:41.041]                       }
[16:04:41.041]                       else if (inherits(cond, "condition")) {
[16:04:41.041]                         if (!is.null(pattern)) {
[16:04:41.041]                           computeRestarts <- base::computeRestarts
[16:04:41.041]                           grepl <- base::grepl
[16:04:41.041]                           restarts <- computeRestarts(cond)
[16:04:41.041]                           for (restart in restarts) {
[16:04:41.041]                             name <- restart$name
[16:04:41.041]                             if (is.null(name)) 
[16:04:41.041]                               next
[16:04:41.041]                             if (!grepl(pattern, name)) 
[16:04:41.041]                               next
[16:04:41.041]                             invokeRestart(restart)
[16:04:41.041]                             muffled <- TRUE
[16:04:41.041]                             break
[16:04:41.041]                           }
[16:04:41.041]                         }
[16:04:41.041]                       }
[16:04:41.041]                       invisible(muffled)
[16:04:41.041]                     }
[16:04:41.041]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.041]                   }
[16:04:41.041]                 }
[16:04:41.041]             }
[16:04:41.041]         }))
[16:04:41.041]     }, error = function(ex) {
[16:04:41.041]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.041]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.041]                 ...future.rng), started = ...future.startTime, 
[16:04:41.041]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.041]             version = "1.8"), class = "FutureResult")
[16:04:41.041]     }, finally = {
[16:04:41.041]         if (!identical(...future.workdir, getwd())) 
[16:04:41.041]             setwd(...future.workdir)
[16:04:41.041]         {
[16:04:41.041]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.041]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.041]             }
[16:04:41.041]             base::options(...future.oldOptions)
[16:04:41.041]             if (.Platform$OS.type == "windows") {
[16:04:41.041]                 old_names <- names(...future.oldEnvVars)
[16:04:41.041]                 envs <- base::Sys.getenv()
[16:04:41.041]                 names <- names(envs)
[16:04:41.041]                 common <- intersect(names, old_names)
[16:04:41.041]                 added <- setdiff(names, old_names)
[16:04:41.041]                 removed <- setdiff(old_names, names)
[16:04:41.041]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.041]                   envs[common]]
[16:04:41.041]                 NAMES <- toupper(changed)
[16:04:41.041]                 args <- list()
[16:04:41.041]                 for (kk in seq_along(NAMES)) {
[16:04:41.041]                   name <- changed[[kk]]
[16:04:41.041]                   NAME <- NAMES[[kk]]
[16:04:41.041]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.041]                     next
[16:04:41.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.041]                 }
[16:04:41.041]                 NAMES <- toupper(added)
[16:04:41.041]                 for (kk in seq_along(NAMES)) {
[16:04:41.041]                   name <- added[[kk]]
[16:04:41.041]                   NAME <- NAMES[[kk]]
[16:04:41.041]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.041]                     next
[16:04:41.041]                   args[[name]] <- ""
[16:04:41.041]                 }
[16:04:41.041]                 NAMES <- toupper(removed)
[16:04:41.041]                 for (kk in seq_along(NAMES)) {
[16:04:41.041]                   name <- removed[[kk]]
[16:04:41.041]                   NAME <- NAMES[[kk]]
[16:04:41.041]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.041]                     next
[16:04:41.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.041]                 }
[16:04:41.041]                 if (length(args) > 0) 
[16:04:41.041]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.041]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.041]             }
[16:04:41.041]             else {
[16:04:41.041]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.041]             }
[16:04:41.041]             {
[16:04:41.041]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.041]                   0L) {
[16:04:41.041]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.041]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.041]                   base::options(opts)
[16:04:41.041]                 }
[16:04:41.041]                 {
[16:04:41.041]                   {
[16:04:41.041]                     NULL
[16:04:41.041]                     RNGkind("Mersenne-Twister")
[16:04:41.041]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.041]                       inherits = FALSE)
[16:04:41.041]                   }
[16:04:41.041]                   options(future.plan = NULL)
[16:04:41.041]                   if (is.na(NA_character_)) 
[16:04:41.041]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.041]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.041]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.041]                   {
[16:04:41.041]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.041]                     if (!future$lazy) 
[16:04:41.041]                       future <- run(future)
[16:04:41.041]                     invisible(future)
[16:04:41.041]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.041]                 }
[16:04:41.041]             }
[16:04:41.041]         }
[16:04:41.041]     })
[16:04:41.041]     if (TRUE) {
[16:04:41.041]         base::sink(type = "output", split = FALSE)
[16:04:41.041]         if (TRUE) {
[16:04:41.041]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.041]         }
[16:04:41.041]         else {
[16:04:41.041]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.041]         }
[16:04:41.041]         base::close(...future.stdout)
[16:04:41.041]         ...future.stdout <- NULL
[16:04:41.041]     }
[16:04:41.041]     ...future.result$conditions <- ...future.conditions
[16:04:41.041]     ...future.result$finished <- base::Sys.time()
[16:04:41.041]     ...future.result
[16:04:41.041] }
[16:04:41.043] plan(): Setting new future strategy stack:
[16:04:41.043] List of future strategies:
[16:04:41.043] 1. sequential:
[16:04:41.043]    - args: function (..., envir = parent.frame())
[16:04:41.043]    - tweaked: FALSE
[16:04:41.043]    - call: NULL
[16:04:41.043] plan(): nbrOfWorkers() = 1
[16:04:41.044] plan(): Setting new future strategy stack:
[16:04:41.044] List of future strategies:
[16:04:41.044] 1. sequential:
[16:04:41.044]    - args: function (..., envir = parent.frame())
[16:04:41.044]    - tweaked: FALSE
[16:04:41.044]    - call: plan(strategy)
[16:04:41.044] plan(): nbrOfWorkers() = 1
[16:04:41.044] SequentialFuture started (and completed)
[16:04:41.045] - Launch lazy future ... done
[16:04:41.045] run() for ‘SequentialFuture’ ... done
[16:04:41.045] getGlobalsAndPackages() ...
[16:04:41.045] Searching for globals...
[16:04:41.045] 
[16:04:41.045] Searching for globals ... DONE
[16:04:41.045] - globals: [0] <none>
[16:04:41.045] getGlobalsAndPackages() ... DONE
[16:04:41.046] run() for ‘Future’ ...
[16:04:41.046] - state: ‘created’
[16:04:41.046] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.046] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.046] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.046]   - Field: ‘label’
[16:04:41.046]   - Field: ‘local’
[16:04:41.046]   - Field: ‘owner’
[16:04:41.047]   - Field: ‘envir’
[16:04:41.047]   - Field: ‘packages’
[16:04:41.047]   - Field: ‘gc’
[16:04:41.047]   - Field: ‘conditions’
[16:04:41.047]   - Field: ‘expr’
[16:04:41.047]   - Field: ‘uuid’
[16:04:41.047]   - Field: ‘seed’
[16:04:41.047]   - Field: ‘version’
[16:04:41.047]   - Field: ‘result’
[16:04:41.047]   - Field: ‘asynchronous’
[16:04:41.047]   - Field: ‘calls’
[16:04:41.048]   - Field: ‘globals’
[16:04:41.048]   - Field: ‘stdout’
[16:04:41.048]   - Field: ‘earlySignal’
[16:04:41.048]   - Field: ‘lazy’
[16:04:41.048]   - Field: ‘state’
[16:04:41.048] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.048] - Launch lazy future ...
[16:04:41.048] Packages needed by the future expression (n = 0): <none>
[16:04:41.048] Packages needed by future strategies (n = 0): <none>
[16:04:41.049] {
[16:04:41.049]     {
[16:04:41.049]         {
[16:04:41.049]             ...future.startTime <- base::Sys.time()
[16:04:41.049]             {
[16:04:41.049]                 {
[16:04:41.049]                   {
[16:04:41.049]                     base::local({
[16:04:41.049]                       has_future <- base::requireNamespace("future", 
[16:04:41.049]                         quietly = TRUE)
[16:04:41.049]                       if (has_future) {
[16:04:41.049]                         ns <- base::getNamespace("future")
[16:04:41.049]                         version <- ns[[".package"]][["version"]]
[16:04:41.049]                         if (is.null(version)) 
[16:04:41.049]                           version <- utils::packageVersion("future")
[16:04:41.049]                       }
[16:04:41.049]                       else {
[16:04:41.049]                         version <- NULL
[16:04:41.049]                       }
[16:04:41.049]                       if (!has_future || version < "1.8.0") {
[16:04:41.049]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.049]                           "", base::R.version$version.string), 
[16:04:41.049]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.049]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.049]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.049]                             "release", "version")], collapse = " "), 
[16:04:41.049]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.049]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.049]                           info)
[16:04:41.049]                         info <- base::paste(info, collapse = "; ")
[16:04:41.049]                         if (!has_future) {
[16:04:41.049]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.049]                             info)
[16:04:41.049]                         }
[16:04:41.049]                         else {
[16:04:41.049]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.049]                             info, version)
[16:04:41.049]                         }
[16:04:41.049]                         base::stop(msg)
[16:04:41.049]                       }
[16:04:41.049]                     })
[16:04:41.049]                   }
[16:04:41.049]                   options(future.plan = NULL)
[16:04:41.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.049]                 }
[16:04:41.049]                 ...future.workdir <- getwd()
[16:04:41.049]             }
[16:04:41.049]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.049]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.049]         }
[16:04:41.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.049]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.049]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.049]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.049]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.049]             base::names(...future.oldOptions))
[16:04:41.049]     }
[16:04:41.049]     if (FALSE) {
[16:04:41.049]     }
[16:04:41.049]     else {
[16:04:41.049]         if (TRUE) {
[16:04:41.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.049]                 open = "w")
[16:04:41.049]         }
[16:04:41.049]         else {
[16:04:41.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.049]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.049]         }
[16:04:41.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.049]             base::sink(type = "output", split = FALSE)
[16:04:41.049]             base::close(...future.stdout)
[16:04:41.049]         }, add = TRUE)
[16:04:41.049]     }
[16:04:41.049]     ...future.frame <- base::sys.nframe()
[16:04:41.049]     ...future.conditions <- base::list()
[16:04:41.049]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.049]     if (FALSE) {
[16:04:41.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.049]     }
[16:04:41.049]     ...future.result <- base::tryCatch({
[16:04:41.049]         base::withCallingHandlers({
[16:04:41.049]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:41.049]             future::FutureResult(value = ...future.value$value, 
[16:04:41.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.049]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.049]                     ...future.globalenv.names))
[16:04:41.049]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.049]         }, condition = base::local({
[16:04:41.049]             c <- base::c
[16:04:41.049]             inherits <- base::inherits
[16:04:41.049]             invokeRestart <- base::invokeRestart
[16:04:41.049]             length <- base::length
[16:04:41.049]             list <- base::list
[16:04:41.049]             seq.int <- base::seq.int
[16:04:41.049]             signalCondition <- base::signalCondition
[16:04:41.049]             sys.calls <- base::sys.calls
[16:04:41.049]             `[[` <- base::`[[`
[16:04:41.049]             `+` <- base::`+`
[16:04:41.049]             `<<-` <- base::`<<-`
[16:04:41.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.049]                   3L)]
[16:04:41.049]             }
[16:04:41.049]             function(cond) {
[16:04:41.049]                 is_error <- inherits(cond, "error")
[16:04:41.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.049]                   NULL)
[16:04:41.049]                 if (is_error) {
[16:04:41.049]                   sessionInformation <- function() {
[16:04:41.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.049]                       search = base::search(), system = base::Sys.info())
[16:04:41.049]                   }
[16:04:41.049]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.049]                     cond$call), session = sessionInformation(), 
[16:04:41.049]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.049]                   signalCondition(cond)
[16:04:41.049]                 }
[16:04:41.049]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.049]                 "immediateCondition"))) {
[16:04:41.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.049]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.049]                   if (TRUE && !signal) {
[16:04:41.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.049]                     {
[16:04:41.049]                       inherits <- base::inherits
[16:04:41.049]                       invokeRestart <- base::invokeRestart
[16:04:41.049]                       is.null <- base::is.null
[16:04:41.049]                       muffled <- FALSE
[16:04:41.049]                       if (inherits(cond, "message")) {
[16:04:41.049]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.049]                         if (muffled) 
[16:04:41.049]                           invokeRestart("muffleMessage")
[16:04:41.049]                       }
[16:04:41.049]                       else if (inherits(cond, "warning")) {
[16:04:41.049]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.049]                         if (muffled) 
[16:04:41.049]                           invokeRestart("muffleWarning")
[16:04:41.049]                       }
[16:04:41.049]                       else if (inherits(cond, "condition")) {
[16:04:41.049]                         if (!is.null(pattern)) {
[16:04:41.049]                           computeRestarts <- base::computeRestarts
[16:04:41.049]                           grepl <- base::grepl
[16:04:41.049]                           restarts <- computeRestarts(cond)
[16:04:41.049]                           for (restart in restarts) {
[16:04:41.049]                             name <- restart$name
[16:04:41.049]                             if (is.null(name)) 
[16:04:41.049]                               next
[16:04:41.049]                             if (!grepl(pattern, name)) 
[16:04:41.049]                               next
[16:04:41.049]                             invokeRestart(restart)
[16:04:41.049]                             muffled <- TRUE
[16:04:41.049]                             break
[16:04:41.049]                           }
[16:04:41.049]                         }
[16:04:41.049]                       }
[16:04:41.049]                       invisible(muffled)
[16:04:41.049]                     }
[16:04:41.049]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.049]                   }
[16:04:41.049]                 }
[16:04:41.049]                 else {
[16:04:41.049]                   if (TRUE) {
[16:04:41.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.049]                     {
[16:04:41.049]                       inherits <- base::inherits
[16:04:41.049]                       invokeRestart <- base::invokeRestart
[16:04:41.049]                       is.null <- base::is.null
[16:04:41.049]                       muffled <- FALSE
[16:04:41.049]                       if (inherits(cond, "message")) {
[16:04:41.049]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.049]                         if (muffled) 
[16:04:41.049]                           invokeRestart("muffleMessage")
[16:04:41.049]                       }
[16:04:41.049]                       else if (inherits(cond, "warning")) {
[16:04:41.049]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.049]                         if (muffled) 
[16:04:41.049]                           invokeRestart("muffleWarning")
[16:04:41.049]                       }
[16:04:41.049]                       else if (inherits(cond, "condition")) {
[16:04:41.049]                         if (!is.null(pattern)) {
[16:04:41.049]                           computeRestarts <- base::computeRestarts
[16:04:41.049]                           grepl <- base::grepl
[16:04:41.049]                           restarts <- computeRestarts(cond)
[16:04:41.049]                           for (restart in restarts) {
[16:04:41.049]                             name <- restart$name
[16:04:41.049]                             if (is.null(name)) 
[16:04:41.049]                               next
[16:04:41.049]                             if (!grepl(pattern, name)) 
[16:04:41.049]                               next
[16:04:41.049]                             invokeRestart(restart)
[16:04:41.049]                             muffled <- TRUE
[16:04:41.049]                             break
[16:04:41.049]                           }
[16:04:41.049]                         }
[16:04:41.049]                       }
[16:04:41.049]                       invisible(muffled)
[16:04:41.049]                     }
[16:04:41.049]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.049]                   }
[16:04:41.049]                 }
[16:04:41.049]             }
[16:04:41.049]         }))
[16:04:41.049]     }, error = function(ex) {
[16:04:41.049]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.049]                 ...future.rng), started = ...future.startTime, 
[16:04:41.049]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.049]             version = "1.8"), class = "FutureResult")
[16:04:41.049]     }, finally = {
[16:04:41.049]         if (!identical(...future.workdir, getwd())) 
[16:04:41.049]             setwd(...future.workdir)
[16:04:41.049]         {
[16:04:41.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.049]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.049]             }
[16:04:41.049]             base::options(...future.oldOptions)
[16:04:41.049]             if (.Platform$OS.type == "windows") {
[16:04:41.049]                 old_names <- names(...future.oldEnvVars)
[16:04:41.049]                 envs <- base::Sys.getenv()
[16:04:41.049]                 names <- names(envs)
[16:04:41.049]                 common <- intersect(names, old_names)
[16:04:41.049]                 added <- setdiff(names, old_names)
[16:04:41.049]                 removed <- setdiff(old_names, names)
[16:04:41.049]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.049]                   envs[common]]
[16:04:41.049]                 NAMES <- toupper(changed)
[16:04:41.049]                 args <- list()
[16:04:41.049]                 for (kk in seq_along(NAMES)) {
[16:04:41.049]                   name <- changed[[kk]]
[16:04:41.049]                   NAME <- NAMES[[kk]]
[16:04:41.049]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.049]                     next
[16:04:41.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.049]                 }
[16:04:41.049]                 NAMES <- toupper(added)
[16:04:41.049]                 for (kk in seq_along(NAMES)) {
[16:04:41.049]                   name <- added[[kk]]
[16:04:41.049]                   NAME <- NAMES[[kk]]
[16:04:41.049]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.049]                     next
[16:04:41.049]                   args[[name]] <- ""
[16:04:41.049]                 }
[16:04:41.049]                 NAMES <- toupper(removed)
[16:04:41.049]                 for (kk in seq_along(NAMES)) {
[16:04:41.049]                   name <- removed[[kk]]
[16:04:41.049]                   NAME <- NAMES[[kk]]
[16:04:41.049]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.049]                     next
[16:04:41.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.049]                 }
[16:04:41.049]                 if (length(args) > 0) 
[16:04:41.049]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.049]             }
[16:04:41.049]             else {
[16:04:41.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.049]             }
[16:04:41.049]             {
[16:04:41.049]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.049]                   0L) {
[16:04:41.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.049]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.049]                   base::options(opts)
[16:04:41.049]                 }
[16:04:41.049]                 {
[16:04:41.049]                   {
[16:04:41.049]                     NULL
[16:04:41.049]                     RNGkind("Mersenne-Twister")
[16:04:41.049]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.049]                       inherits = FALSE)
[16:04:41.049]                   }
[16:04:41.049]                   options(future.plan = NULL)
[16:04:41.049]                   if (is.na(NA_character_)) 
[16:04:41.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.049]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.049]                   {
[16:04:41.049]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.049]                     if (!future$lazy) 
[16:04:41.049]                       future <- run(future)
[16:04:41.049]                     invisible(future)
[16:04:41.049]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.049]                 }
[16:04:41.049]             }
[16:04:41.049]         }
[16:04:41.049]     })
[16:04:41.049]     if (TRUE) {
[16:04:41.049]         base::sink(type = "output", split = FALSE)
[16:04:41.049]         if (TRUE) {
[16:04:41.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.049]         }
[16:04:41.049]         else {
[16:04:41.049]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.049]         }
[16:04:41.049]         base::close(...future.stdout)
[16:04:41.049]         ...future.stdout <- NULL
[16:04:41.049]     }
[16:04:41.049]     ...future.result$conditions <- ...future.conditions
[16:04:41.049]     ...future.result$finished <- base::Sys.time()
[16:04:41.049]     ...future.result
[16:04:41.049] }
[16:04:41.050] plan(): Setting new future strategy stack:
[16:04:41.050] List of future strategies:
[16:04:41.050] 1. sequential:
[16:04:41.050]    - args: function (..., envir = parent.frame())
[16:04:41.050]    - tweaked: FALSE
[16:04:41.050]    - call: NULL
[16:04:41.051] plan(): nbrOfWorkers() = 1
[16:04:41.051] plan(): Setting new future strategy stack:
[16:04:41.052] List of future strategies:
[16:04:41.052] 1. sequential:
[16:04:41.052]    - args: function (..., envir = parent.frame())
[16:04:41.052]    - tweaked: FALSE
[16:04:41.052]    - call: plan(strategy)
[16:04:41.052] plan(): nbrOfWorkers() = 1
[16:04:41.052] SequentialFuture started (and completed)
[16:04:41.052] - Launch lazy future ... done
[16:04:41.052] run() for ‘SequentialFuture’ ... done
[16:04:41.053] getGlobalsAndPackages() ...
[16:04:41.053] Searching for globals...
[16:04:41.055] - globals found: [1] ‘{’
[16:04:41.055] Searching for globals ... DONE
[16:04:41.055] Resolving globals: FALSE
[16:04:41.055] 
[16:04:41.055] 
[16:04:41.056] getGlobalsAndPackages() ... DONE
[16:04:41.056] run() for ‘Future’ ...
[16:04:41.056] - state: ‘created’
[16:04:41.056] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.056] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.056]   - Field: ‘label’
[16:04:41.057]   - Field: ‘local’
[16:04:41.057]   - Field: ‘owner’
[16:04:41.057]   - Field: ‘envir’
[16:04:41.057]   - Field: ‘packages’
[16:04:41.057]   - Field: ‘gc’
[16:04:41.057]   - Field: ‘conditions’
[16:04:41.057]   - Field: ‘expr’
[16:04:41.057]   - Field: ‘uuid’
[16:04:41.057]   - Field: ‘seed’
[16:04:41.057]   - Field: ‘version’
[16:04:41.057]   - Field: ‘result’
[16:04:41.058]   - Field: ‘asynchronous’
[16:04:41.058]   - Field: ‘calls’
[16:04:41.058]   - Field: ‘globals’
[16:04:41.058]   - Field: ‘stdout’
[16:04:41.058]   - Field: ‘earlySignal’
[16:04:41.058]   - Field: ‘lazy’
[16:04:41.058]   - Field: ‘state’
[16:04:41.058] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.058] - Launch lazy future ...
[16:04:41.058] Packages needed by the future expression (n = 0): <none>
[16:04:41.058] Packages needed by future strategies (n = 0): <none>
[16:04:41.060] {
[16:04:41.060]     {
[16:04:41.060]         {
[16:04:41.060]             ...future.startTime <- base::Sys.time()
[16:04:41.060]             {
[16:04:41.060]                 {
[16:04:41.060]                   {
[16:04:41.060]                     base::local({
[16:04:41.060]                       has_future <- base::requireNamespace("future", 
[16:04:41.060]                         quietly = TRUE)
[16:04:41.060]                       if (has_future) {
[16:04:41.060]                         ns <- base::getNamespace("future")
[16:04:41.060]                         version <- ns[[".package"]][["version"]]
[16:04:41.060]                         if (is.null(version)) 
[16:04:41.060]                           version <- utils::packageVersion("future")
[16:04:41.060]                       }
[16:04:41.060]                       else {
[16:04:41.060]                         version <- NULL
[16:04:41.060]                       }
[16:04:41.060]                       if (!has_future || version < "1.8.0") {
[16:04:41.060]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.060]                           "", base::R.version$version.string), 
[16:04:41.060]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.060]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.060]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.060]                             "release", "version")], collapse = " "), 
[16:04:41.060]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.060]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.060]                           info)
[16:04:41.060]                         info <- base::paste(info, collapse = "; ")
[16:04:41.060]                         if (!has_future) {
[16:04:41.060]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.060]                             info)
[16:04:41.060]                         }
[16:04:41.060]                         else {
[16:04:41.060]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.060]                             info, version)
[16:04:41.060]                         }
[16:04:41.060]                         base::stop(msg)
[16:04:41.060]                       }
[16:04:41.060]                     })
[16:04:41.060]                   }
[16:04:41.060]                   options(future.plan = NULL)
[16:04:41.060]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.060]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.060]                 }
[16:04:41.060]                 ...future.workdir <- getwd()
[16:04:41.060]             }
[16:04:41.060]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.060]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.060]         }
[16:04:41.060]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.060]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.060]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.060]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.060]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.060]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.060]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.060]             base::names(...future.oldOptions))
[16:04:41.060]     }
[16:04:41.060]     if (FALSE) {
[16:04:41.060]     }
[16:04:41.060]     else {
[16:04:41.060]         if (TRUE) {
[16:04:41.060]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.060]                 open = "w")
[16:04:41.060]         }
[16:04:41.060]         else {
[16:04:41.060]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.060]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.060]         }
[16:04:41.060]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.060]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.060]             base::sink(type = "output", split = FALSE)
[16:04:41.060]             base::close(...future.stdout)
[16:04:41.060]         }, add = TRUE)
[16:04:41.060]     }
[16:04:41.060]     ...future.frame <- base::sys.nframe()
[16:04:41.060]     ...future.conditions <- base::list()
[16:04:41.060]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.060]     if (FALSE) {
[16:04:41.060]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.060]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.060]     }
[16:04:41.060]     ...future.result <- base::tryCatch({
[16:04:41.060]         base::withCallingHandlers({
[16:04:41.060]             ...future.value <- base::withVisible(base::local({
[16:04:41.060]                 4
[16:04:41.060]             }))
[16:04:41.060]             future::FutureResult(value = ...future.value$value, 
[16:04:41.060]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.060]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.060]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.060]                     ...future.globalenv.names))
[16:04:41.060]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.060]         }, condition = base::local({
[16:04:41.060]             c <- base::c
[16:04:41.060]             inherits <- base::inherits
[16:04:41.060]             invokeRestart <- base::invokeRestart
[16:04:41.060]             length <- base::length
[16:04:41.060]             list <- base::list
[16:04:41.060]             seq.int <- base::seq.int
[16:04:41.060]             signalCondition <- base::signalCondition
[16:04:41.060]             sys.calls <- base::sys.calls
[16:04:41.060]             `[[` <- base::`[[`
[16:04:41.060]             `+` <- base::`+`
[16:04:41.060]             `<<-` <- base::`<<-`
[16:04:41.060]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.060]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.060]                   3L)]
[16:04:41.060]             }
[16:04:41.060]             function(cond) {
[16:04:41.060]                 is_error <- inherits(cond, "error")
[16:04:41.060]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.060]                   NULL)
[16:04:41.060]                 if (is_error) {
[16:04:41.060]                   sessionInformation <- function() {
[16:04:41.060]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.060]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.060]                       search = base::search(), system = base::Sys.info())
[16:04:41.060]                   }
[16:04:41.060]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.060]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.060]                     cond$call), session = sessionInformation(), 
[16:04:41.060]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.060]                   signalCondition(cond)
[16:04:41.060]                 }
[16:04:41.060]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.060]                 "immediateCondition"))) {
[16:04:41.060]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.060]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.060]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.060]                   if (TRUE && !signal) {
[16:04:41.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.060]                     {
[16:04:41.060]                       inherits <- base::inherits
[16:04:41.060]                       invokeRestart <- base::invokeRestart
[16:04:41.060]                       is.null <- base::is.null
[16:04:41.060]                       muffled <- FALSE
[16:04:41.060]                       if (inherits(cond, "message")) {
[16:04:41.060]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.060]                         if (muffled) 
[16:04:41.060]                           invokeRestart("muffleMessage")
[16:04:41.060]                       }
[16:04:41.060]                       else if (inherits(cond, "warning")) {
[16:04:41.060]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.060]                         if (muffled) 
[16:04:41.060]                           invokeRestart("muffleWarning")
[16:04:41.060]                       }
[16:04:41.060]                       else if (inherits(cond, "condition")) {
[16:04:41.060]                         if (!is.null(pattern)) {
[16:04:41.060]                           computeRestarts <- base::computeRestarts
[16:04:41.060]                           grepl <- base::grepl
[16:04:41.060]                           restarts <- computeRestarts(cond)
[16:04:41.060]                           for (restart in restarts) {
[16:04:41.060]                             name <- restart$name
[16:04:41.060]                             if (is.null(name)) 
[16:04:41.060]                               next
[16:04:41.060]                             if (!grepl(pattern, name)) 
[16:04:41.060]                               next
[16:04:41.060]                             invokeRestart(restart)
[16:04:41.060]                             muffled <- TRUE
[16:04:41.060]                             break
[16:04:41.060]                           }
[16:04:41.060]                         }
[16:04:41.060]                       }
[16:04:41.060]                       invisible(muffled)
[16:04:41.060]                     }
[16:04:41.060]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.060]                   }
[16:04:41.060]                 }
[16:04:41.060]                 else {
[16:04:41.060]                   if (TRUE) {
[16:04:41.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.060]                     {
[16:04:41.060]                       inherits <- base::inherits
[16:04:41.060]                       invokeRestart <- base::invokeRestart
[16:04:41.060]                       is.null <- base::is.null
[16:04:41.060]                       muffled <- FALSE
[16:04:41.060]                       if (inherits(cond, "message")) {
[16:04:41.060]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.060]                         if (muffled) 
[16:04:41.060]                           invokeRestart("muffleMessage")
[16:04:41.060]                       }
[16:04:41.060]                       else if (inherits(cond, "warning")) {
[16:04:41.060]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.060]                         if (muffled) 
[16:04:41.060]                           invokeRestart("muffleWarning")
[16:04:41.060]                       }
[16:04:41.060]                       else if (inherits(cond, "condition")) {
[16:04:41.060]                         if (!is.null(pattern)) {
[16:04:41.060]                           computeRestarts <- base::computeRestarts
[16:04:41.060]                           grepl <- base::grepl
[16:04:41.060]                           restarts <- computeRestarts(cond)
[16:04:41.060]                           for (restart in restarts) {
[16:04:41.060]                             name <- restart$name
[16:04:41.060]                             if (is.null(name)) 
[16:04:41.060]                               next
[16:04:41.060]                             if (!grepl(pattern, name)) 
[16:04:41.060]                               next
[16:04:41.060]                             invokeRestart(restart)
[16:04:41.060]                             muffled <- TRUE
[16:04:41.060]                             break
[16:04:41.060]                           }
[16:04:41.060]                         }
[16:04:41.060]                       }
[16:04:41.060]                       invisible(muffled)
[16:04:41.060]                     }
[16:04:41.060]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.060]                   }
[16:04:41.060]                 }
[16:04:41.060]             }
[16:04:41.060]         }))
[16:04:41.060]     }, error = function(ex) {
[16:04:41.060]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.060]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.060]                 ...future.rng), started = ...future.startTime, 
[16:04:41.060]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.060]             version = "1.8"), class = "FutureResult")
[16:04:41.060]     }, finally = {
[16:04:41.060]         if (!identical(...future.workdir, getwd())) 
[16:04:41.060]             setwd(...future.workdir)
[16:04:41.060]         {
[16:04:41.060]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.060]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.060]             }
[16:04:41.060]             base::options(...future.oldOptions)
[16:04:41.060]             if (.Platform$OS.type == "windows") {
[16:04:41.060]                 old_names <- names(...future.oldEnvVars)
[16:04:41.060]                 envs <- base::Sys.getenv()
[16:04:41.060]                 names <- names(envs)
[16:04:41.060]                 common <- intersect(names, old_names)
[16:04:41.060]                 added <- setdiff(names, old_names)
[16:04:41.060]                 removed <- setdiff(old_names, names)
[16:04:41.060]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.060]                   envs[common]]
[16:04:41.060]                 NAMES <- toupper(changed)
[16:04:41.060]                 args <- list()
[16:04:41.060]                 for (kk in seq_along(NAMES)) {
[16:04:41.060]                   name <- changed[[kk]]
[16:04:41.060]                   NAME <- NAMES[[kk]]
[16:04:41.060]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.060]                     next
[16:04:41.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.060]                 }
[16:04:41.060]                 NAMES <- toupper(added)
[16:04:41.060]                 for (kk in seq_along(NAMES)) {
[16:04:41.060]                   name <- added[[kk]]
[16:04:41.060]                   NAME <- NAMES[[kk]]
[16:04:41.060]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.060]                     next
[16:04:41.060]                   args[[name]] <- ""
[16:04:41.060]                 }
[16:04:41.060]                 NAMES <- toupper(removed)
[16:04:41.060]                 for (kk in seq_along(NAMES)) {
[16:04:41.060]                   name <- removed[[kk]]
[16:04:41.060]                   NAME <- NAMES[[kk]]
[16:04:41.060]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.060]                     next
[16:04:41.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.060]                 }
[16:04:41.060]                 if (length(args) > 0) 
[16:04:41.060]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.060]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.060]             }
[16:04:41.060]             else {
[16:04:41.060]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.060]             }
[16:04:41.060]             {
[16:04:41.060]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.060]                   0L) {
[16:04:41.060]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.060]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.060]                   base::options(opts)
[16:04:41.060]                 }
[16:04:41.060]                 {
[16:04:41.060]                   {
[16:04:41.060]                     NULL
[16:04:41.060]                     RNGkind("Mersenne-Twister")
[16:04:41.060]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.060]                       inherits = FALSE)
[16:04:41.060]                   }
[16:04:41.060]                   options(future.plan = NULL)
[16:04:41.060]                   if (is.na(NA_character_)) 
[16:04:41.060]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.060]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.060]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.060]                   {
[16:04:41.060]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.060]                     if (!future$lazy) 
[16:04:41.060]                       future <- run(future)
[16:04:41.060]                     invisible(future)
[16:04:41.060]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.060]                 }
[16:04:41.060]             }
[16:04:41.060]         }
[16:04:41.060]     })
[16:04:41.060]     if (TRUE) {
[16:04:41.060]         base::sink(type = "output", split = FALSE)
[16:04:41.060]         if (TRUE) {
[16:04:41.060]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.060]         }
[16:04:41.060]         else {
[16:04:41.060]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.060]         }
[16:04:41.060]         base::close(...future.stdout)
[16:04:41.060]         ...future.stdout <- NULL
[16:04:41.060]     }
[16:04:41.060]     ...future.result$conditions <- ...future.conditions
[16:04:41.060]     ...future.result$finished <- base::Sys.time()
[16:04:41.060]     ...future.result
[16:04:41.060] }
[16:04:41.062] plan(): Setting new future strategy stack:
[16:04:41.062] List of future strategies:
[16:04:41.062] 1. sequential:
[16:04:41.062]    - args: function (..., envir = parent.frame())
[16:04:41.062]    - tweaked: FALSE
[16:04:41.062]    - call: NULL
[16:04:41.062] plan(): nbrOfWorkers() = 1
[16:04:41.063] plan(): Setting new future strategy stack:
[16:04:41.063] List of future strategies:
[16:04:41.063] 1. sequential:
[16:04:41.063]    - args: function (..., envir = parent.frame())
[16:04:41.063]    - tweaked: FALSE
[16:04:41.063]    - call: plan(strategy)
[16:04:41.063] plan(): nbrOfWorkers() = 1
[16:04:41.063] SequentialFuture started (and completed)
[16:04:41.064] - Launch lazy future ... done
[16:04:41.064] run() for ‘SequentialFuture’ ... done
<environment: 0x55874c6fdd48> 
<environment: 0x55874c2d9b58> 
[16:04:41.065] resolved() for ‘SequentialFuture’ ...
[16:04:41.065] - state: ‘finished’
[16:04:41.065] - run: TRUE
[16:04:41.065] - result: ‘FutureResult’
[16:04:41.065] resolved() for ‘SequentialFuture’ ... done
[16:04:41.066] resolved() for ‘SequentialFuture’ ...
[16:04:41.066] - state: ‘finished’
[16:04:41.066] - run: TRUE
[16:04:41.066] - result: ‘FutureResult’
[16:04:41.066] resolved() for ‘SequentialFuture’ ... done
[16:04:41.066] resolved() for ‘SequentialFuture’ ...
[16:04:41.066] - state: ‘finished’
[16:04:41.066] - run: TRUE
[16:04:41.066] - result: ‘FutureResult’
[16:04:41.066] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:41.068] resolve() on environment ...
[16:04:41.068]  recursive: 0
[16:04:41.068]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:41.068] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.068] - nx: 4
[16:04:41.068] - relay: TRUE
[16:04:41.069] - stdout: TRUE
[16:04:41.069] - signal: TRUE
[16:04:41.069] - resignal: FALSE
[16:04:41.069] - force: TRUE
[16:04:41.069] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.069] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.069]  - until=2
[16:04:41.069]  - relaying element #2
[16:04:41.069] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:41.069] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.069] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.069]  length: 3 (resolved future 1)
[16:04:41.070] resolved() for ‘SequentialFuture’ ...
[16:04:41.070] - state: ‘finished’
[16:04:41.070] - run: TRUE
[16:04:41.070] - result: ‘FutureResult’
[16:04:41.070] resolved() for ‘SequentialFuture’ ... done
[16:04:41.070] Future #2
[16:04:41.070] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:41.070] - nx: 4
[16:04:41.070] - relay: TRUE
[16:04:41.070] - stdout: TRUE
[16:04:41.070] - signal: TRUE
[16:04:41.071] - resignal: FALSE
[16:04:41.071] - force: TRUE
[16:04:41.071] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:41.071] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.071]  - until=2
[16:04:41.071]  - relaying element #2
[16:04:41.071] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:41.071] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:41.071] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:41.071]  length: 2 (resolved future 2)
[16:04:41.072] resolved() for ‘SequentialFuture’ ...
[16:04:41.072] - state: ‘finished’
[16:04:41.072] - run: TRUE
[16:04:41.072] - result: ‘FutureResult’
[16:04:41.072] resolved() for ‘SequentialFuture’ ... done
[16:04:41.072] Future #3
[16:04:41.072] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:41.072] - nx: 4
[16:04:41.072] - relay: TRUE
[16:04:41.072] - stdout: TRUE
[16:04:41.072] - signal: TRUE
[16:04:41.073] - resignal: FALSE
[16:04:41.073] - force: TRUE
[16:04:41.073] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:41.073] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:41.073]  - until=3
[16:04:41.073]  - relaying element #3
[16:04:41.073] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:41.073] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:41.073] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:41.073]  length: 1 (resolved future 3)
[16:04:41.073] resolved() for ‘SequentialFuture’ ...
[16:04:41.074] - state: ‘finished’
[16:04:41.074] - run: TRUE
[16:04:41.074] - result: ‘FutureResult’
[16:04:41.074] resolved() for ‘SequentialFuture’ ... done
[16:04:41.074] Future #4
[16:04:41.074] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:04:41.074] - nx: 4
[16:04:41.074] - relay: TRUE
[16:04:41.074] - stdout: TRUE
[16:04:41.074] - signal: TRUE
[16:04:41.074] - resignal: FALSE
[16:04:41.074] - force: TRUE
[16:04:41.075] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:41.075] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:41.075]  - until=4
[16:04:41.075]  - relaying element #4
[16:04:41.075] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.075] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:41.075] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:04:41.075]  length: 0 (resolved future 4)
[16:04:41.075] Relaying remaining futures
[16:04:41.075] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.076] - nx: 4
[16:04:41.076] - relay: TRUE
[16:04:41.076] - stdout: TRUE
[16:04:41.076] - signal: TRUE
[16:04:41.076] - resignal: FALSE
[16:04:41.076] - force: TRUE
[16:04:41.076] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.076] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:41.076] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.076] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:41.076] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.076] resolve() on environment ... DONE
<environment: 0x55874bb413a0> 
Dimensions: c(1, 6)
[16:04:41.077] getGlobalsAndPackages() ...
[16:04:41.077] Searching for globals...
[16:04:41.077] 
[16:04:41.077] Searching for globals ... DONE
[16:04:41.077] - globals: [0] <none>
[16:04:41.078] getGlobalsAndPackages() ... DONE
[16:04:41.078] run() for ‘Future’ ...
[16:04:41.078] - state: ‘created’
[16:04:41.078] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.078] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.078] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.078]   - Field: ‘label’
[16:04:41.078]   - Field: ‘local’
[16:04:41.079]   - Field: ‘owner’
[16:04:41.079]   - Field: ‘envir’
[16:04:41.079]   - Field: ‘packages’
[16:04:41.079]   - Field: ‘gc’
[16:04:41.079]   - Field: ‘conditions’
[16:04:41.079]   - Field: ‘expr’
[16:04:41.079]   - Field: ‘uuid’
[16:04:41.079]   - Field: ‘seed’
[16:04:41.079]   - Field: ‘version’
[16:04:41.079]   - Field: ‘result’
[16:04:41.079]   - Field: ‘asynchronous’
[16:04:41.080]   - Field: ‘calls’
[16:04:41.080]   - Field: ‘globals’
[16:04:41.080]   - Field: ‘stdout’
[16:04:41.080]   - Field: ‘earlySignal’
[16:04:41.080]   - Field: ‘lazy’
[16:04:41.080]   - Field: ‘state’
[16:04:41.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.080] - Launch lazy future ...
[16:04:41.080] Packages needed by the future expression (n = 0): <none>
[16:04:41.080] Packages needed by future strategies (n = 0): <none>
[16:04:41.081] {
[16:04:41.081]     {
[16:04:41.081]         {
[16:04:41.081]             ...future.startTime <- base::Sys.time()
[16:04:41.081]             {
[16:04:41.081]                 {
[16:04:41.081]                   {
[16:04:41.081]                     base::local({
[16:04:41.081]                       has_future <- base::requireNamespace("future", 
[16:04:41.081]                         quietly = TRUE)
[16:04:41.081]                       if (has_future) {
[16:04:41.081]                         ns <- base::getNamespace("future")
[16:04:41.081]                         version <- ns[[".package"]][["version"]]
[16:04:41.081]                         if (is.null(version)) 
[16:04:41.081]                           version <- utils::packageVersion("future")
[16:04:41.081]                       }
[16:04:41.081]                       else {
[16:04:41.081]                         version <- NULL
[16:04:41.081]                       }
[16:04:41.081]                       if (!has_future || version < "1.8.0") {
[16:04:41.081]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.081]                           "", base::R.version$version.string), 
[16:04:41.081]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.081]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.081]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.081]                             "release", "version")], collapse = " "), 
[16:04:41.081]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.081]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.081]                           info)
[16:04:41.081]                         info <- base::paste(info, collapse = "; ")
[16:04:41.081]                         if (!has_future) {
[16:04:41.081]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.081]                             info)
[16:04:41.081]                         }
[16:04:41.081]                         else {
[16:04:41.081]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.081]                             info, version)
[16:04:41.081]                         }
[16:04:41.081]                         base::stop(msg)
[16:04:41.081]                       }
[16:04:41.081]                     })
[16:04:41.081]                   }
[16:04:41.081]                   options(future.plan = NULL)
[16:04:41.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.081]                 }
[16:04:41.081]                 ...future.workdir <- getwd()
[16:04:41.081]             }
[16:04:41.081]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.081]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.081]         }
[16:04:41.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.081]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.081]             base::names(...future.oldOptions))
[16:04:41.081]     }
[16:04:41.081]     if (FALSE) {
[16:04:41.081]     }
[16:04:41.081]     else {
[16:04:41.081]         if (TRUE) {
[16:04:41.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.081]                 open = "w")
[16:04:41.081]         }
[16:04:41.081]         else {
[16:04:41.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.081]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.081]         }
[16:04:41.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.081]             base::sink(type = "output", split = FALSE)
[16:04:41.081]             base::close(...future.stdout)
[16:04:41.081]         }, add = TRUE)
[16:04:41.081]     }
[16:04:41.081]     ...future.frame <- base::sys.nframe()
[16:04:41.081]     ...future.conditions <- base::list()
[16:04:41.081]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.081]     if (FALSE) {
[16:04:41.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.081]     }
[16:04:41.081]     ...future.result <- base::tryCatch({
[16:04:41.081]         base::withCallingHandlers({
[16:04:41.081]             ...future.value <- base::withVisible(base::local(2))
[16:04:41.081]             future::FutureResult(value = ...future.value$value, 
[16:04:41.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.081]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.081]                     ...future.globalenv.names))
[16:04:41.081]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.081]         }, condition = base::local({
[16:04:41.081]             c <- base::c
[16:04:41.081]             inherits <- base::inherits
[16:04:41.081]             invokeRestart <- base::invokeRestart
[16:04:41.081]             length <- base::length
[16:04:41.081]             list <- base::list
[16:04:41.081]             seq.int <- base::seq.int
[16:04:41.081]             signalCondition <- base::signalCondition
[16:04:41.081]             sys.calls <- base::sys.calls
[16:04:41.081]             `[[` <- base::`[[`
[16:04:41.081]             `+` <- base::`+`
[16:04:41.081]             `<<-` <- base::`<<-`
[16:04:41.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.081]                   3L)]
[16:04:41.081]             }
[16:04:41.081]             function(cond) {
[16:04:41.081]                 is_error <- inherits(cond, "error")
[16:04:41.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.081]                   NULL)
[16:04:41.081]                 if (is_error) {
[16:04:41.081]                   sessionInformation <- function() {
[16:04:41.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.081]                       search = base::search(), system = base::Sys.info())
[16:04:41.081]                   }
[16:04:41.081]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.081]                     cond$call), session = sessionInformation(), 
[16:04:41.081]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.081]                   signalCondition(cond)
[16:04:41.081]                 }
[16:04:41.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.081]                 "immediateCondition"))) {
[16:04:41.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.081]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.081]                   if (TRUE && !signal) {
[16:04:41.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.081]                     {
[16:04:41.081]                       inherits <- base::inherits
[16:04:41.081]                       invokeRestart <- base::invokeRestart
[16:04:41.081]                       is.null <- base::is.null
[16:04:41.081]                       muffled <- FALSE
[16:04:41.081]                       if (inherits(cond, "message")) {
[16:04:41.081]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.081]                         if (muffled) 
[16:04:41.081]                           invokeRestart("muffleMessage")
[16:04:41.081]                       }
[16:04:41.081]                       else if (inherits(cond, "warning")) {
[16:04:41.081]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.081]                         if (muffled) 
[16:04:41.081]                           invokeRestart("muffleWarning")
[16:04:41.081]                       }
[16:04:41.081]                       else if (inherits(cond, "condition")) {
[16:04:41.081]                         if (!is.null(pattern)) {
[16:04:41.081]                           computeRestarts <- base::computeRestarts
[16:04:41.081]                           grepl <- base::grepl
[16:04:41.081]                           restarts <- computeRestarts(cond)
[16:04:41.081]                           for (restart in restarts) {
[16:04:41.081]                             name <- restart$name
[16:04:41.081]                             if (is.null(name)) 
[16:04:41.081]                               next
[16:04:41.081]                             if (!grepl(pattern, name)) 
[16:04:41.081]                               next
[16:04:41.081]                             invokeRestart(restart)
[16:04:41.081]                             muffled <- TRUE
[16:04:41.081]                             break
[16:04:41.081]                           }
[16:04:41.081]                         }
[16:04:41.081]                       }
[16:04:41.081]                       invisible(muffled)
[16:04:41.081]                     }
[16:04:41.081]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.081]                   }
[16:04:41.081]                 }
[16:04:41.081]                 else {
[16:04:41.081]                   if (TRUE) {
[16:04:41.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.081]                     {
[16:04:41.081]                       inherits <- base::inherits
[16:04:41.081]                       invokeRestart <- base::invokeRestart
[16:04:41.081]                       is.null <- base::is.null
[16:04:41.081]                       muffled <- FALSE
[16:04:41.081]                       if (inherits(cond, "message")) {
[16:04:41.081]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.081]                         if (muffled) 
[16:04:41.081]                           invokeRestart("muffleMessage")
[16:04:41.081]                       }
[16:04:41.081]                       else if (inherits(cond, "warning")) {
[16:04:41.081]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.081]                         if (muffled) 
[16:04:41.081]                           invokeRestart("muffleWarning")
[16:04:41.081]                       }
[16:04:41.081]                       else if (inherits(cond, "condition")) {
[16:04:41.081]                         if (!is.null(pattern)) {
[16:04:41.081]                           computeRestarts <- base::computeRestarts
[16:04:41.081]                           grepl <- base::grepl
[16:04:41.081]                           restarts <- computeRestarts(cond)
[16:04:41.081]                           for (restart in restarts) {
[16:04:41.081]                             name <- restart$name
[16:04:41.081]                             if (is.null(name)) 
[16:04:41.081]                               next
[16:04:41.081]                             if (!grepl(pattern, name)) 
[16:04:41.081]                               next
[16:04:41.081]                             invokeRestart(restart)
[16:04:41.081]                             muffled <- TRUE
[16:04:41.081]                             break
[16:04:41.081]                           }
[16:04:41.081]                         }
[16:04:41.081]                       }
[16:04:41.081]                       invisible(muffled)
[16:04:41.081]                     }
[16:04:41.081]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.081]                   }
[16:04:41.081]                 }
[16:04:41.081]             }
[16:04:41.081]         }))
[16:04:41.081]     }, error = function(ex) {
[16:04:41.081]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.081]                 ...future.rng), started = ...future.startTime, 
[16:04:41.081]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.081]             version = "1.8"), class = "FutureResult")
[16:04:41.081]     }, finally = {
[16:04:41.081]         if (!identical(...future.workdir, getwd())) 
[16:04:41.081]             setwd(...future.workdir)
[16:04:41.081]         {
[16:04:41.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.081]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.081]             }
[16:04:41.081]             base::options(...future.oldOptions)
[16:04:41.081]             if (.Platform$OS.type == "windows") {
[16:04:41.081]                 old_names <- names(...future.oldEnvVars)
[16:04:41.081]                 envs <- base::Sys.getenv()
[16:04:41.081]                 names <- names(envs)
[16:04:41.081]                 common <- intersect(names, old_names)
[16:04:41.081]                 added <- setdiff(names, old_names)
[16:04:41.081]                 removed <- setdiff(old_names, names)
[16:04:41.081]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.081]                   envs[common]]
[16:04:41.081]                 NAMES <- toupper(changed)
[16:04:41.081]                 args <- list()
[16:04:41.081]                 for (kk in seq_along(NAMES)) {
[16:04:41.081]                   name <- changed[[kk]]
[16:04:41.081]                   NAME <- NAMES[[kk]]
[16:04:41.081]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.081]                     next
[16:04:41.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.081]                 }
[16:04:41.081]                 NAMES <- toupper(added)
[16:04:41.081]                 for (kk in seq_along(NAMES)) {
[16:04:41.081]                   name <- added[[kk]]
[16:04:41.081]                   NAME <- NAMES[[kk]]
[16:04:41.081]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.081]                     next
[16:04:41.081]                   args[[name]] <- ""
[16:04:41.081]                 }
[16:04:41.081]                 NAMES <- toupper(removed)
[16:04:41.081]                 for (kk in seq_along(NAMES)) {
[16:04:41.081]                   name <- removed[[kk]]
[16:04:41.081]                   NAME <- NAMES[[kk]]
[16:04:41.081]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.081]                     next
[16:04:41.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.081]                 }
[16:04:41.081]                 if (length(args) > 0) 
[16:04:41.081]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.081]             }
[16:04:41.081]             else {
[16:04:41.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.081]             }
[16:04:41.081]             {
[16:04:41.081]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.081]                   0L) {
[16:04:41.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.081]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.081]                   base::options(opts)
[16:04:41.081]                 }
[16:04:41.081]                 {
[16:04:41.081]                   {
[16:04:41.081]                     NULL
[16:04:41.081]                     RNGkind("Mersenne-Twister")
[16:04:41.081]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.081]                       inherits = FALSE)
[16:04:41.081]                   }
[16:04:41.081]                   options(future.plan = NULL)
[16:04:41.081]                   if (is.na(NA_character_)) 
[16:04:41.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.081]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.081]                   {
[16:04:41.081]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.081]                     if (!future$lazy) 
[16:04:41.081]                       future <- run(future)
[16:04:41.081]                     invisible(future)
[16:04:41.081]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.081]                 }
[16:04:41.081]             }
[16:04:41.081]         }
[16:04:41.081]     })
[16:04:41.081]     if (TRUE) {
[16:04:41.081]         base::sink(type = "output", split = FALSE)
[16:04:41.081]         if (TRUE) {
[16:04:41.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.081]         }
[16:04:41.081]         else {
[16:04:41.081]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.081]         }
[16:04:41.081]         base::close(...future.stdout)
[16:04:41.081]         ...future.stdout <- NULL
[16:04:41.081]     }
[16:04:41.081]     ...future.result$conditions <- ...future.conditions
[16:04:41.081]     ...future.result$finished <- base::Sys.time()
[16:04:41.081]     ...future.result
[16:04:41.081] }
[16:04:41.082] plan(): Setting new future strategy stack:
[16:04:41.083] List of future strategies:
[16:04:41.083] 1. sequential:
[16:04:41.083]    - args: function (..., envir = parent.frame())
[16:04:41.083]    - tweaked: FALSE
[16:04:41.083]    - call: NULL
[16:04:41.083] plan(): nbrOfWorkers() = 1
[16:04:41.084] plan(): Setting new future strategy stack:
[16:04:41.084] List of future strategies:
[16:04:41.084] 1. sequential:
[16:04:41.084]    - args: function (..., envir = parent.frame())
[16:04:41.084]    - tweaked: FALSE
[16:04:41.084]    - call: plan(strategy)
[16:04:41.084] plan(): nbrOfWorkers() = 1
[16:04:41.084] SequentialFuture started (and completed)
[16:04:41.084] - Launch lazy future ... done
[16:04:41.084] run() for ‘SequentialFuture’ ... done
[16:04:41.084] getGlobalsAndPackages() ...
[16:04:41.085] Searching for globals...
[16:04:41.085] 
[16:04:41.085] Searching for globals ... DONE
[16:04:41.085] - globals: [0] <none>
[16:04:41.085] getGlobalsAndPackages() ... DONE
[16:04:41.086] run() for ‘Future’ ...
[16:04:41.086] - state: ‘created’
[16:04:41.087] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.087] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.087] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.087]   - Field: ‘label’
[16:04:41.087]   - Field: ‘local’
[16:04:41.087]   - Field: ‘owner’
[16:04:41.087]   - Field: ‘envir’
[16:04:41.087]   - Field: ‘packages’
[16:04:41.088]   - Field: ‘gc’
[16:04:41.088]   - Field: ‘conditions’
[16:04:41.088]   - Field: ‘expr’
[16:04:41.088]   - Field: ‘uuid’
[16:04:41.088]   - Field: ‘seed’
[16:04:41.088]   - Field: ‘version’
[16:04:41.088]   - Field: ‘result’
[16:04:41.088]   - Field: ‘asynchronous’
[16:04:41.088]   - Field: ‘calls’
[16:04:41.088]   - Field: ‘globals’
[16:04:41.088]   - Field: ‘stdout’
[16:04:41.088]   - Field: ‘earlySignal’
[16:04:41.089]   - Field: ‘lazy’
[16:04:41.089]   - Field: ‘state’
[16:04:41.089] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.089] - Launch lazy future ...
[16:04:41.089] Packages needed by the future expression (n = 0): <none>
[16:04:41.089] Packages needed by future strategies (n = 0): <none>
[16:04:41.089] {
[16:04:41.089]     {
[16:04:41.089]         {
[16:04:41.089]             ...future.startTime <- base::Sys.time()
[16:04:41.089]             {
[16:04:41.089]                 {
[16:04:41.089]                   {
[16:04:41.089]                     base::local({
[16:04:41.089]                       has_future <- base::requireNamespace("future", 
[16:04:41.089]                         quietly = TRUE)
[16:04:41.089]                       if (has_future) {
[16:04:41.089]                         ns <- base::getNamespace("future")
[16:04:41.089]                         version <- ns[[".package"]][["version"]]
[16:04:41.089]                         if (is.null(version)) 
[16:04:41.089]                           version <- utils::packageVersion("future")
[16:04:41.089]                       }
[16:04:41.089]                       else {
[16:04:41.089]                         version <- NULL
[16:04:41.089]                       }
[16:04:41.089]                       if (!has_future || version < "1.8.0") {
[16:04:41.089]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.089]                           "", base::R.version$version.string), 
[16:04:41.089]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.089]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.089]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.089]                             "release", "version")], collapse = " "), 
[16:04:41.089]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.089]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.089]                           info)
[16:04:41.089]                         info <- base::paste(info, collapse = "; ")
[16:04:41.089]                         if (!has_future) {
[16:04:41.089]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.089]                             info)
[16:04:41.089]                         }
[16:04:41.089]                         else {
[16:04:41.089]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.089]                             info, version)
[16:04:41.089]                         }
[16:04:41.089]                         base::stop(msg)
[16:04:41.089]                       }
[16:04:41.089]                     })
[16:04:41.089]                   }
[16:04:41.089]                   options(future.plan = NULL)
[16:04:41.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.089]                 }
[16:04:41.089]                 ...future.workdir <- getwd()
[16:04:41.089]             }
[16:04:41.089]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.089]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.089]         }
[16:04:41.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.089]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.089]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.089]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.089]             base::names(...future.oldOptions))
[16:04:41.089]     }
[16:04:41.089]     if (FALSE) {
[16:04:41.089]     }
[16:04:41.089]     else {
[16:04:41.089]         if (TRUE) {
[16:04:41.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.089]                 open = "w")
[16:04:41.089]         }
[16:04:41.089]         else {
[16:04:41.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.089]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.089]         }
[16:04:41.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.089]             base::sink(type = "output", split = FALSE)
[16:04:41.089]             base::close(...future.stdout)
[16:04:41.089]         }, add = TRUE)
[16:04:41.089]     }
[16:04:41.089]     ...future.frame <- base::sys.nframe()
[16:04:41.089]     ...future.conditions <- base::list()
[16:04:41.089]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.089]     if (FALSE) {
[16:04:41.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.089]     }
[16:04:41.089]     ...future.result <- base::tryCatch({
[16:04:41.089]         base::withCallingHandlers({
[16:04:41.089]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:41.089]             future::FutureResult(value = ...future.value$value, 
[16:04:41.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.089]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.089]                     ...future.globalenv.names))
[16:04:41.089]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.089]         }, condition = base::local({
[16:04:41.089]             c <- base::c
[16:04:41.089]             inherits <- base::inherits
[16:04:41.089]             invokeRestart <- base::invokeRestart
[16:04:41.089]             length <- base::length
[16:04:41.089]             list <- base::list
[16:04:41.089]             seq.int <- base::seq.int
[16:04:41.089]             signalCondition <- base::signalCondition
[16:04:41.089]             sys.calls <- base::sys.calls
[16:04:41.089]             `[[` <- base::`[[`
[16:04:41.089]             `+` <- base::`+`
[16:04:41.089]             `<<-` <- base::`<<-`
[16:04:41.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.089]                   3L)]
[16:04:41.089]             }
[16:04:41.089]             function(cond) {
[16:04:41.089]                 is_error <- inherits(cond, "error")
[16:04:41.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.089]                   NULL)
[16:04:41.089]                 if (is_error) {
[16:04:41.089]                   sessionInformation <- function() {
[16:04:41.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.089]                       search = base::search(), system = base::Sys.info())
[16:04:41.089]                   }
[16:04:41.089]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.089]                     cond$call), session = sessionInformation(), 
[16:04:41.089]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.089]                   signalCondition(cond)
[16:04:41.089]                 }
[16:04:41.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.089]                 "immediateCondition"))) {
[16:04:41.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.089]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.089]                   if (TRUE && !signal) {
[16:04:41.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.089]                     {
[16:04:41.089]                       inherits <- base::inherits
[16:04:41.089]                       invokeRestart <- base::invokeRestart
[16:04:41.089]                       is.null <- base::is.null
[16:04:41.089]                       muffled <- FALSE
[16:04:41.089]                       if (inherits(cond, "message")) {
[16:04:41.089]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.089]                         if (muffled) 
[16:04:41.089]                           invokeRestart("muffleMessage")
[16:04:41.089]                       }
[16:04:41.089]                       else if (inherits(cond, "warning")) {
[16:04:41.089]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.089]                         if (muffled) 
[16:04:41.089]                           invokeRestart("muffleWarning")
[16:04:41.089]                       }
[16:04:41.089]                       else if (inherits(cond, "condition")) {
[16:04:41.089]                         if (!is.null(pattern)) {
[16:04:41.089]                           computeRestarts <- base::computeRestarts
[16:04:41.089]                           grepl <- base::grepl
[16:04:41.089]                           restarts <- computeRestarts(cond)
[16:04:41.089]                           for (restart in restarts) {
[16:04:41.089]                             name <- restart$name
[16:04:41.089]                             if (is.null(name)) 
[16:04:41.089]                               next
[16:04:41.089]                             if (!grepl(pattern, name)) 
[16:04:41.089]                               next
[16:04:41.089]                             invokeRestart(restart)
[16:04:41.089]                             muffled <- TRUE
[16:04:41.089]                             break
[16:04:41.089]                           }
[16:04:41.089]                         }
[16:04:41.089]                       }
[16:04:41.089]                       invisible(muffled)
[16:04:41.089]                     }
[16:04:41.089]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.089]                   }
[16:04:41.089]                 }
[16:04:41.089]                 else {
[16:04:41.089]                   if (TRUE) {
[16:04:41.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.089]                     {
[16:04:41.089]                       inherits <- base::inherits
[16:04:41.089]                       invokeRestart <- base::invokeRestart
[16:04:41.089]                       is.null <- base::is.null
[16:04:41.089]                       muffled <- FALSE
[16:04:41.089]                       if (inherits(cond, "message")) {
[16:04:41.089]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.089]                         if (muffled) 
[16:04:41.089]                           invokeRestart("muffleMessage")
[16:04:41.089]                       }
[16:04:41.089]                       else if (inherits(cond, "warning")) {
[16:04:41.089]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.089]                         if (muffled) 
[16:04:41.089]                           invokeRestart("muffleWarning")
[16:04:41.089]                       }
[16:04:41.089]                       else if (inherits(cond, "condition")) {
[16:04:41.089]                         if (!is.null(pattern)) {
[16:04:41.089]                           computeRestarts <- base::computeRestarts
[16:04:41.089]                           grepl <- base::grepl
[16:04:41.089]                           restarts <- computeRestarts(cond)
[16:04:41.089]                           for (restart in restarts) {
[16:04:41.089]                             name <- restart$name
[16:04:41.089]                             if (is.null(name)) 
[16:04:41.089]                               next
[16:04:41.089]                             if (!grepl(pattern, name)) 
[16:04:41.089]                               next
[16:04:41.089]                             invokeRestart(restart)
[16:04:41.089]                             muffled <- TRUE
[16:04:41.089]                             break
[16:04:41.089]                           }
[16:04:41.089]                         }
[16:04:41.089]                       }
[16:04:41.089]                       invisible(muffled)
[16:04:41.089]                     }
[16:04:41.089]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.089]                   }
[16:04:41.089]                 }
[16:04:41.089]             }
[16:04:41.089]         }))
[16:04:41.089]     }, error = function(ex) {
[16:04:41.089]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.089]                 ...future.rng), started = ...future.startTime, 
[16:04:41.089]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.089]             version = "1.8"), class = "FutureResult")
[16:04:41.089]     }, finally = {
[16:04:41.089]         if (!identical(...future.workdir, getwd())) 
[16:04:41.089]             setwd(...future.workdir)
[16:04:41.089]         {
[16:04:41.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.089]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.089]             }
[16:04:41.089]             base::options(...future.oldOptions)
[16:04:41.089]             if (.Platform$OS.type == "windows") {
[16:04:41.089]                 old_names <- names(...future.oldEnvVars)
[16:04:41.089]                 envs <- base::Sys.getenv()
[16:04:41.089]                 names <- names(envs)
[16:04:41.089]                 common <- intersect(names, old_names)
[16:04:41.089]                 added <- setdiff(names, old_names)
[16:04:41.089]                 removed <- setdiff(old_names, names)
[16:04:41.089]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.089]                   envs[common]]
[16:04:41.089]                 NAMES <- toupper(changed)
[16:04:41.089]                 args <- list()
[16:04:41.089]                 for (kk in seq_along(NAMES)) {
[16:04:41.089]                   name <- changed[[kk]]
[16:04:41.089]                   NAME <- NAMES[[kk]]
[16:04:41.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.089]                     next
[16:04:41.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.089]                 }
[16:04:41.089]                 NAMES <- toupper(added)
[16:04:41.089]                 for (kk in seq_along(NAMES)) {
[16:04:41.089]                   name <- added[[kk]]
[16:04:41.089]                   NAME <- NAMES[[kk]]
[16:04:41.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.089]                     next
[16:04:41.089]                   args[[name]] <- ""
[16:04:41.089]                 }
[16:04:41.089]                 NAMES <- toupper(removed)
[16:04:41.089]                 for (kk in seq_along(NAMES)) {
[16:04:41.089]                   name <- removed[[kk]]
[16:04:41.089]                   NAME <- NAMES[[kk]]
[16:04:41.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.089]                     next
[16:04:41.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.089]                 }
[16:04:41.089]                 if (length(args) > 0) 
[16:04:41.089]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.089]             }
[16:04:41.089]             else {
[16:04:41.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.089]             }
[16:04:41.089]             {
[16:04:41.089]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.089]                   0L) {
[16:04:41.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.089]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.089]                   base::options(opts)
[16:04:41.089]                 }
[16:04:41.089]                 {
[16:04:41.089]                   {
[16:04:41.089]                     NULL
[16:04:41.089]                     RNGkind("Mersenne-Twister")
[16:04:41.089]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.089]                       inherits = FALSE)
[16:04:41.089]                   }
[16:04:41.089]                   options(future.plan = NULL)
[16:04:41.089]                   if (is.na(NA_character_)) 
[16:04:41.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.089]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.089]                   {
[16:04:41.089]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.089]                     if (!future$lazy) 
[16:04:41.089]                       future <- run(future)
[16:04:41.089]                     invisible(future)
[16:04:41.089]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.089]                 }
[16:04:41.089]             }
[16:04:41.089]         }
[16:04:41.089]     })
[16:04:41.089]     if (TRUE) {
[16:04:41.089]         base::sink(type = "output", split = FALSE)
[16:04:41.089]         if (TRUE) {
[16:04:41.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.089]         }
[16:04:41.089]         else {
[16:04:41.089]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.089]         }
[16:04:41.089]         base::close(...future.stdout)
[16:04:41.089]         ...future.stdout <- NULL
[16:04:41.089]     }
[16:04:41.089]     ...future.result$conditions <- ...future.conditions
[16:04:41.089]     ...future.result$finished <- base::Sys.time()
[16:04:41.089]     ...future.result
[16:04:41.089] }
[16:04:41.091] plan(): Setting new future strategy stack:
[16:04:41.091] List of future strategies:
[16:04:41.091] 1. sequential:
[16:04:41.091]    - args: function (..., envir = parent.frame())
[16:04:41.091]    - tweaked: FALSE
[16:04:41.091]    - call: NULL
[16:04:41.092] plan(): nbrOfWorkers() = 1
[16:04:41.092] plan(): Setting new future strategy stack:
[16:04:41.092] List of future strategies:
[16:04:41.092] 1. sequential:
[16:04:41.092]    - args: function (..., envir = parent.frame())
[16:04:41.092]    - tweaked: FALSE
[16:04:41.092]    - call: plan(strategy)
[16:04:41.093] plan(): nbrOfWorkers() = 1
[16:04:41.093] SequentialFuture started (and completed)
[16:04:41.093] - Launch lazy future ... done
[16:04:41.093] run() for ‘SequentialFuture’ ... done
[16:04:41.093] getGlobalsAndPackages() ...
[16:04:41.093] Searching for globals...
[16:04:41.094] - globals found: [1] ‘{’
[16:04:41.094] Searching for globals ... DONE
[16:04:41.094] Resolving globals: FALSE
[16:04:41.094] 
[16:04:41.094] 
[16:04:41.095] getGlobalsAndPackages() ... DONE
[16:04:41.095] run() for ‘Future’ ...
[16:04:41.095] - state: ‘created’
[16:04:41.095] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.095] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.095] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.095]   - Field: ‘label’
[16:04:41.096]   - Field: ‘local’
[16:04:41.096]   - Field: ‘owner’
[16:04:41.096]   - Field: ‘envir’
[16:04:41.096]   - Field: ‘packages’
[16:04:41.096]   - Field: ‘gc’
[16:04:41.096]   - Field: ‘conditions’
[16:04:41.096]   - Field: ‘expr’
[16:04:41.096]   - Field: ‘uuid’
[16:04:41.096]   - Field: ‘seed’
[16:04:41.096]   - Field: ‘version’
[16:04:41.096]   - Field: ‘result’
[16:04:41.096]   - Field: ‘asynchronous’
[16:04:41.097]   - Field: ‘calls’
[16:04:41.097]   - Field: ‘globals’
[16:04:41.097]   - Field: ‘stdout’
[16:04:41.097]   - Field: ‘earlySignal’
[16:04:41.097]   - Field: ‘lazy’
[16:04:41.097]   - Field: ‘state’
[16:04:41.097] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.097] - Launch lazy future ...
[16:04:41.097] Packages needed by the future expression (n = 0): <none>
[16:04:41.097] Packages needed by future strategies (n = 0): <none>
[16:04:41.098] {
[16:04:41.098]     {
[16:04:41.098]         {
[16:04:41.098]             ...future.startTime <- base::Sys.time()
[16:04:41.098]             {
[16:04:41.098]                 {
[16:04:41.098]                   {
[16:04:41.098]                     base::local({
[16:04:41.098]                       has_future <- base::requireNamespace("future", 
[16:04:41.098]                         quietly = TRUE)
[16:04:41.098]                       if (has_future) {
[16:04:41.098]                         ns <- base::getNamespace("future")
[16:04:41.098]                         version <- ns[[".package"]][["version"]]
[16:04:41.098]                         if (is.null(version)) 
[16:04:41.098]                           version <- utils::packageVersion("future")
[16:04:41.098]                       }
[16:04:41.098]                       else {
[16:04:41.098]                         version <- NULL
[16:04:41.098]                       }
[16:04:41.098]                       if (!has_future || version < "1.8.0") {
[16:04:41.098]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.098]                           "", base::R.version$version.string), 
[16:04:41.098]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.098]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.098]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.098]                             "release", "version")], collapse = " "), 
[16:04:41.098]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.098]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.098]                           info)
[16:04:41.098]                         info <- base::paste(info, collapse = "; ")
[16:04:41.098]                         if (!has_future) {
[16:04:41.098]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.098]                             info)
[16:04:41.098]                         }
[16:04:41.098]                         else {
[16:04:41.098]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.098]                             info, version)
[16:04:41.098]                         }
[16:04:41.098]                         base::stop(msg)
[16:04:41.098]                       }
[16:04:41.098]                     })
[16:04:41.098]                   }
[16:04:41.098]                   options(future.plan = NULL)
[16:04:41.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.098]                 }
[16:04:41.098]                 ...future.workdir <- getwd()
[16:04:41.098]             }
[16:04:41.098]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.098]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.098]         }
[16:04:41.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.098]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.098]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.098]             base::names(...future.oldOptions))
[16:04:41.098]     }
[16:04:41.098]     if (FALSE) {
[16:04:41.098]     }
[16:04:41.098]     else {
[16:04:41.098]         if (TRUE) {
[16:04:41.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.098]                 open = "w")
[16:04:41.098]         }
[16:04:41.098]         else {
[16:04:41.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.098]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.098]         }
[16:04:41.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.098]             base::sink(type = "output", split = FALSE)
[16:04:41.098]             base::close(...future.stdout)
[16:04:41.098]         }, add = TRUE)
[16:04:41.098]     }
[16:04:41.098]     ...future.frame <- base::sys.nframe()
[16:04:41.098]     ...future.conditions <- base::list()
[16:04:41.098]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.098]     if (FALSE) {
[16:04:41.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.098]     }
[16:04:41.098]     ...future.result <- base::tryCatch({
[16:04:41.098]         base::withCallingHandlers({
[16:04:41.098]             ...future.value <- base::withVisible(base::local({
[16:04:41.098]                 4
[16:04:41.098]             }))
[16:04:41.098]             future::FutureResult(value = ...future.value$value, 
[16:04:41.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.098]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.098]                     ...future.globalenv.names))
[16:04:41.098]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.098]         }, condition = base::local({
[16:04:41.098]             c <- base::c
[16:04:41.098]             inherits <- base::inherits
[16:04:41.098]             invokeRestart <- base::invokeRestart
[16:04:41.098]             length <- base::length
[16:04:41.098]             list <- base::list
[16:04:41.098]             seq.int <- base::seq.int
[16:04:41.098]             signalCondition <- base::signalCondition
[16:04:41.098]             sys.calls <- base::sys.calls
[16:04:41.098]             `[[` <- base::`[[`
[16:04:41.098]             `+` <- base::`+`
[16:04:41.098]             `<<-` <- base::`<<-`
[16:04:41.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.098]                   3L)]
[16:04:41.098]             }
[16:04:41.098]             function(cond) {
[16:04:41.098]                 is_error <- inherits(cond, "error")
[16:04:41.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.098]                   NULL)
[16:04:41.098]                 if (is_error) {
[16:04:41.098]                   sessionInformation <- function() {
[16:04:41.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.098]                       search = base::search(), system = base::Sys.info())
[16:04:41.098]                   }
[16:04:41.098]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.098]                     cond$call), session = sessionInformation(), 
[16:04:41.098]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.098]                   signalCondition(cond)
[16:04:41.098]                 }
[16:04:41.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.098]                 "immediateCondition"))) {
[16:04:41.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.098]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.098]                   if (TRUE && !signal) {
[16:04:41.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.098]                     {
[16:04:41.098]                       inherits <- base::inherits
[16:04:41.098]                       invokeRestart <- base::invokeRestart
[16:04:41.098]                       is.null <- base::is.null
[16:04:41.098]                       muffled <- FALSE
[16:04:41.098]                       if (inherits(cond, "message")) {
[16:04:41.098]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.098]                         if (muffled) 
[16:04:41.098]                           invokeRestart("muffleMessage")
[16:04:41.098]                       }
[16:04:41.098]                       else if (inherits(cond, "warning")) {
[16:04:41.098]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.098]                         if (muffled) 
[16:04:41.098]                           invokeRestart("muffleWarning")
[16:04:41.098]                       }
[16:04:41.098]                       else if (inherits(cond, "condition")) {
[16:04:41.098]                         if (!is.null(pattern)) {
[16:04:41.098]                           computeRestarts <- base::computeRestarts
[16:04:41.098]                           grepl <- base::grepl
[16:04:41.098]                           restarts <- computeRestarts(cond)
[16:04:41.098]                           for (restart in restarts) {
[16:04:41.098]                             name <- restart$name
[16:04:41.098]                             if (is.null(name)) 
[16:04:41.098]                               next
[16:04:41.098]                             if (!grepl(pattern, name)) 
[16:04:41.098]                               next
[16:04:41.098]                             invokeRestart(restart)
[16:04:41.098]                             muffled <- TRUE
[16:04:41.098]                             break
[16:04:41.098]                           }
[16:04:41.098]                         }
[16:04:41.098]                       }
[16:04:41.098]                       invisible(muffled)
[16:04:41.098]                     }
[16:04:41.098]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.098]                   }
[16:04:41.098]                 }
[16:04:41.098]                 else {
[16:04:41.098]                   if (TRUE) {
[16:04:41.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.098]                     {
[16:04:41.098]                       inherits <- base::inherits
[16:04:41.098]                       invokeRestart <- base::invokeRestart
[16:04:41.098]                       is.null <- base::is.null
[16:04:41.098]                       muffled <- FALSE
[16:04:41.098]                       if (inherits(cond, "message")) {
[16:04:41.098]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.098]                         if (muffled) 
[16:04:41.098]                           invokeRestart("muffleMessage")
[16:04:41.098]                       }
[16:04:41.098]                       else if (inherits(cond, "warning")) {
[16:04:41.098]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.098]                         if (muffled) 
[16:04:41.098]                           invokeRestart("muffleWarning")
[16:04:41.098]                       }
[16:04:41.098]                       else if (inherits(cond, "condition")) {
[16:04:41.098]                         if (!is.null(pattern)) {
[16:04:41.098]                           computeRestarts <- base::computeRestarts
[16:04:41.098]                           grepl <- base::grepl
[16:04:41.098]                           restarts <- computeRestarts(cond)
[16:04:41.098]                           for (restart in restarts) {
[16:04:41.098]                             name <- restart$name
[16:04:41.098]                             if (is.null(name)) 
[16:04:41.098]                               next
[16:04:41.098]                             if (!grepl(pattern, name)) 
[16:04:41.098]                               next
[16:04:41.098]                             invokeRestart(restart)
[16:04:41.098]                             muffled <- TRUE
[16:04:41.098]                             break
[16:04:41.098]                           }
[16:04:41.098]                         }
[16:04:41.098]                       }
[16:04:41.098]                       invisible(muffled)
[16:04:41.098]                     }
[16:04:41.098]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.098]                   }
[16:04:41.098]                 }
[16:04:41.098]             }
[16:04:41.098]         }))
[16:04:41.098]     }, error = function(ex) {
[16:04:41.098]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.098]                 ...future.rng), started = ...future.startTime, 
[16:04:41.098]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.098]             version = "1.8"), class = "FutureResult")
[16:04:41.098]     }, finally = {
[16:04:41.098]         if (!identical(...future.workdir, getwd())) 
[16:04:41.098]             setwd(...future.workdir)
[16:04:41.098]         {
[16:04:41.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.098]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.098]             }
[16:04:41.098]             base::options(...future.oldOptions)
[16:04:41.098]             if (.Platform$OS.type == "windows") {
[16:04:41.098]                 old_names <- names(...future.oldEnvVars)
[16:04:41.098]                 envs <- base::Sys.getenv()
[16:04:41.098]                 names <- names(envs)
[16:04:41.098]                 common <- intersect(names, old_names)
[16:04:41.098]                 added <- setdiff(names, old_names)
[16:04:41.098]                 removed <- setdiff(old_names, names)
[16:04:41.098]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.098]                   envs[common]]
[16:04:41.098]                 NAMES <- toupper(changed)
[16:04:41.098]                 args <- list()
[16:04:41.098]                 for (kk in seq_along(NAMES)) {
[16:04:41.098]                   name <- changed[[kk]]
[16:04:41.098]                   NAME <- NAMES[[kk]]
[16:04:41.098]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.098]                     next
[16:04:41.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.098]                 }
[16:04:41.098]                 NAMES <- toupper(added)
[16:04:41.098]                 for (kk in seq_along(NAMES)) {
[16:04:41.098]                   name <- added[[kk]]
[16:04:41.098]                   NAME <- NAMES[[kk]]
[16:04:41.098]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.098]                     next
[16:04:41.098]                   args[[name]] <- ""
[16:04:41.098]                 }
[16:04:41.098]                 NAMES <- toupper(removed)
[16:04:41.098]                 for (kk in seq_along(NAMES)) {
[16:04:41.098]                   name <- removed[[kk]]
[16:04:41.098]                   NAME <- NAMES[[kk]]
[16:04:41.098]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.098]                     next
[16:04:41.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.098]                 }
[16:04:41.098]                 if (length(args) > 0) 
[16:04:41.098]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.098]             }
[16:04:41.098]             else {
[16:04:41.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.098]             }
[16:04:41.098]             {
[16:04:41.098]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.098]                   0L) {
[16:04:41.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.098]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.098]                   base::options(opts)
[16:04:41.098]                 }
[16:04:41.098]                 {
[16:04:41.098]                   {
[16:04:41.098]                     NULL
[16:04:41.098]                     RNGkind("Mersenne-Twister")
[16:04:41.098]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.098]                       inherits = FALSE)
[16:04:41.098]                   }
[16:04:41.098]                   options(future.plan = NULL)
[16:04:41.098]                   if (is.na(NA_character_)) 
[16:04:41.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.098]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.098]                   {
[16:04:41.098]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.098]                     if (!future$lazy) 
[16:04:41.098]                       future <- run(future)
[16:04:41.098]                     invisible(future)
[16:04:41.098]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.098]                 }
[16:04:41.098]             }
[16:04:41.098]         }
[16:04:41.098]     })
[16:04:41.098]     if (TRUE) {
[16:04:41.098]         base::sink(type = "output", split = FALSE)
[16:04:41.098]         if (TRUE) {
[16:04:41.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.098]         }
[16:04:41.098]         else {
[16:04:41.098]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.098]         }
[16:04:41.098]         base::close(...future.stdout)
[16:04:41.098]         ...future.stdout <- NULL
[16:04:41.098]     }
[16:04:41.098]     ...future.result$conditions <- ...future.conditions
[16:04:41.098]     ...future.result$finished <- base::Sys.time()
[16:04:41.098]     ...future.result
[16:04:41.098] }
[16:04:41.099] plan(): Setting new future strategy stack:
[16:04:41.100] List of future strategies:
[16:04:41.100] 1. sequential:
[16:04:41.100]    - args: function (..., envir = parent.frame())
[16:04:41.100]    - tweaked: FALSE
[16:04:41.100]    - call: NULL
[16:04:41.100] plan(): nbrOfWorkers() = 1
[16:04:41.101] plan(): Setting new future strategy stack:
[16:04:41.101] List of future strategies:
[16:04:41.101] 1. sequential:
[16:04:41.101]    - args: function (..., envir = parent.frame())
[16:04:41.101]    - tweaked: FALSE
[16:04:41.101]    - call: plan(strategy)
[16:04:41.101] plan(): nbrOfWorkers() = 1
[16:04:41.101] SequentialFuture started (and completed)
[16:04:41.101] - Launch lazy future ... done
[16:04:41.101] run() for ‘SequentialFuture’ ... done
<environment: 0x55874dc99bc0> 
<environment: 0x55874da64888> 
[16:04:41.102] resolved() for ‘SequentialFuture’ ...
[16:04:41.103] - state: ‘finished’
[16:04:41.103] - run: TRUE
[16:04:41.103] - result: ‘FutureResult’
[16:04:41.103] resolved() for ‘SequentialFuture’ ... done
[16:04:41.103] resolved() for ‘SequentialFuture’ ...
[16:04:41.103] - state: ‘finished’
[16:04:41.103] - run: TRUE
[16:04:41.103] - result: ‘FutureResult’
[16:04:41.103] resolved() for ‘SequentialFuture’ ... done
[16:04:41.103] resolved() for ‘SequentialFuture’ ...
[16:04:41.103] - state: ‘finished’
[16:04:41.104] - run: TRUE
[16:04:41.104] - result: ‘FutureResult’
[16:04:41.104] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:41.105] resolve() on environment ...
[16:04:41.105]  recursive: 0
[16:04:41.105]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:41.105] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.106] - nx: 4
[16:04:41.106] - relay: TRUE
[16:04:41.106] - stdout: TRUE
[16:04:41.106] - signal: TRUE
[16:04:41.106] - resignal: FALSE
[16:04:41.106] - force: TRUE
[16:04:41.106] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.106] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.106]  - until=2
[16:04:41.106]  - relaying element #2
[16:04:41.106] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:41.106] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.106] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.107]  length: 3 (resolved future 1)
[16:04:41.107] resolved() for ‘SequentialFuture’ ...
[16:04:41.107] - state: ‘finished’
[16:04:41.107] - run: TRUE
[16:04:41.107] - result: ‘FutureResult’
[16:04:41.107] resolved() for ‘SequentialFuture’ ... done
[16:04:41.107] Future #2
[16:04:41.107] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:41.107] - nx: 4
[16:04:41.107] - relay: TRUE
[16:04:41.108] - stdout: TRUE
[16:04:41.108] - signal: TRUE
[16:04:41.108] - resignal: FALSE
[16:04:41.108] - force: TRUE
[16:04:41.108] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:41.108] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.108]  - until=2
[16:04:41.108]  - relaying element #2
[16:04:41.108] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:41.108] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:41.108] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:41.109]  length: 2 (resolved future 2)
[16:04:41.109] resolved() for ‘SequentialFuture’ ...
[16:04:41.109] - state: ‘finished’
[16:04:41.109] - run: TRUE
[16:04:41.109] - result: ‘FutureResult’
[16:04:41.109] resolved() for ‘SequentialFuture’ ... done
[16:04:41.109] Future #3
[16:04:41.109] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:41.109] - nx: 4
[16:04:41.109] - relay: TRUE
[16:04:41.109] - stdout: TRUE
[16:04:41.109] - signal: TRUE
[16:04:41.110] - resignal: FALSE
[16:04:41.110] - force: TRUE
[16:04:41.110] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:41.110] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:41.110]  - until=3
[16:04:41.110]  - relaying element #3
[16:04:41.110] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:41.110] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:41.110] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:41.110]  length: 1 (resolved future 3)
[16:04:41.110] resolved() for ‘SequentialFuture’ ...
[16:04:41.111] - state: ‘finished’
[16:04:41.111] - run: TRUE
[16:04:41.111] - result: ‘FutureResult’
[16:04:41.111] resolved() for ‘SequentialFuture’ ... done
[16:04:41.111] Future #4
[16:04:41.112] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:04:41.112] - nx: 4
[16:04:41.112] - relay: TRUE
[16:04:41.112] - stdout: TRUE
[16:04:41.112] - signal: TRUE
[16:04:41.113] - resignal: FALSE
[16:04:41.113] - force: TRUE
[16:04:41.113] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:41.113] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:41.113]  - until=4
[16:04:41.113]  - relaying element #4
[16:04:41.113] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.113] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:41.113] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:04:41.113]  length: 0 (resolved future 4)
[16:04:41.113] Relaying remaining futures
[16:04:41.114] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.114] - nx: 4
[16:04:41.114] - relay: TRUE
[16:04:41.114] - stdout: TRUE
[16:04:41.114] - signal: TRUE
[16:04:41.114] - resignal: FALSE
[16:04:41.114] - force: TRUE
[16:04:41.114] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.114] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:41.114] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.114] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:41.114] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.115] resolve() on environment ... DONE
<environment: 0x55874dc95f78> 
Dimensions: c(2, 3)
[16:04:41.115] getGlobalsAndPackages() ...
[16:04:41.115] Searching for globals...
[16:04:41.115] 
[16:04:41.116] Searching for globals ... DONE
[16:04:41.116] - globals: [0] <none>
[16:04:41.116] getGlobalsAndPackages() ... DONE
[16:04:41.116] run() for ‘Future’ ...
[16:04:41.116] - state: ‘created’
[16:04:41.116] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.116] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.116] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.117]   - Field: ‘label’
[16:04:41.117]   - Field: ‘local’
[16:04:41.117]   - Field: ‘owner’
[16:04:41.117]   - Field: ‘envir’
[16:04:41.117]   - Field: ‘packages’
[16:04:41.117]   - Field: ‘gc’
[16:04:41.117]   - Field: ‘conditions’
[16:04:41.117]   - Field: ‘expr’
[16:04:41.117]   - Field: ‘uuid’
[16:04:41.117]   - Field: ‘seed’
[16:04:41.117]   - Field: ‘version’
[16:04:41.118]   - Field: ‘result’
[16:04:41.118]   - Field: ‘asynchronous’
[16:04:41.118]   - Field: ‘calls’
[16:04:41.118]   - Field: ‘globals’
[16:04:41.118]   - Field: ‘stdout’
[16:04:41.118]   - Field: ‘earlySignal’
[16:04:41.118]   - Field: ‘lazy’
[16:04:41.118]   - Field: ‘state’
[16:04:41.118] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.118] - Launch lazy future ...
[16:04:41.118] Packages needed by the future expression (n = 0): <none>
[16:04:41.119] Packages needed by future strategies (n = 0): <none>
[16:04:41.119] {
[16:04:41.119]     {
[16:04:41.119]         {
[16:04:41.119]             ...future.startTime <- base::Sys.time()
[16:04:41.119]             {
[16:04:41.119]                 {
[16:04:41.119]                   {
[16:04:41.119]                     base::local({
[16:04:41.119]                       has_future <- base::requireNamespace("future", 
[16:04:41.119]                         quietly = TRUE)
[16:04:41.119]                       if (has_future) {
[16:04:41.119]                         ns <- base::getNamespace("future")
[16:04:41.119]                         version <- ns[[".package"]][["version"]]
[16:04:41.119]                         if (is.null(version)) 
[16:04:41.119]                           version <- utils::packageVersion("future")
[16:04:41.119]                       }
[16:04:41.119]                       else {
[16:04:41.119]                         version <- NULL
[16:04:41.119]                       }
[16:04:41.119]                       if (!has_future || version < "1.8.0") {
[16:04:41.119]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.119]                           "", base::R.version$version.string), 
[16:04:41.119]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.119]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.119]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.119]                             "release", "version")], collapse = " "), 
[16:04:41.119]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.119]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.119]                           info)
[16:04:41.119]                         info <- base::paste(info, collapse = "; ")
[16:04:41.119]                         if (!has_future) {
[16:04:41.119]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.119]                             info)
[16:04:41.119]                         }
[16:04:41.119]                         else {
[16:04:41.119]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.119]                             info, version)
[16:04:41.119]                         }
[16:04:41.119]                         base::stop(msg)
[16:04:41.119]                       }
[16:04:41.119]                     })
[16:04:41.119]                   }
[16:04:41.119]                   options(future.plan = NULL)
[16:04:41.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.119]                 }
[16:04:41.119]                 ...future.workdir <- getwd()
[16:04:41.119]             }
[16:04:41.119]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.119]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.119]         }
[16:04:41.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.119]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.119]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.119]             base::names(...future.oldOptions))
[16:04:41.119]     }
[16:04:41.119]     if (FALSE) {
[16:04:41.119]     }
[16:04:41.119]     else {
[16:04:41.119]         if (TRUE) {
[16:04:41.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.119]                 open = "w")
[16:04:41.119]         }
[16:04:41.119]         else {
[16:04:41.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.119]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.119]         }
[16:04:41.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.119]             base::sink(type = "output", split = FALSE)
[16:04:41.119]             base::close(...future.stdout)
[16:04:41.119]         }, add = TRUE)
[16:04:41.119]     }
[16:04:41.119]     ...future.frame <- base::sys.nframe()
[16:04:41.119]     ...future.conditions <- base::list()
[16:04:41.119]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.119]     if (FALSE) {
[16:04:41.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.119]     }
[16:04:41.119]     ...future.result <- base::tryCatch({
[16:04:41.119]         base::withCallingHandlers({
[16:04:41.119]             ...future.value <- base::withVisible(base::local(2))
[16:04:41.119]             future::FutureResult(value = ...future.value$value, 
[16:04:41.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.119]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.119]                     ...future.globalenv.names))
[16:04:41.119]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.119]         }, condition = base::local({
[16:04:41.119]             c <- base::c
[16:04:41.119]             inherits <- base::inherits
[16:04:41.119]             invokeRestart <- base::invokeRestart
[16:04:41.119]             length <- base::length
[16:04:41.119]             list <- base::list
[16:04:41.119]             seq.int <- base::seq.int
[16:04:41.119]             signalCondition <- base::signalCondition
[16:04:41.119]             sys.calls <- base::sys.calls
[16:04:41.119]             `[[` <- base::`[[`
[16:04:41.119]             `+` <- base::`+`
[16:04:41.119]             `<<-` <- base::`<<-`
[16:04:41.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.119]                   3L)]
[16:04:41.119]             }
[16:04:41.119]             function(cond) {
[16:04:41.119]                 is_error <- inherits(cond, "error")
[16:04:41.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.119]                   NULL)
[16:04:41.119]                 if (is_error) {
[16:04:41.119]                   sessionInformation <- function() {
[16:04:41.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.119]                       search = base::search(), system = base::Sys.info())
[16:04:41.119]                   }
[16:04:41.119]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.119]                     cond$call), session = sessionInformation(), 
[16:04:41.119]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.119]                   signalCondition(cond)
[16:04:41.119]                 }
[16:04:41.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.119]                 "immediateCondition"))) {
[16:04:41.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.119]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.119]                   if (TRUE && !signal) {
[16:04:41.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.119]                     {
[16:04:41.119]                       inherits <- base::inherits
[16:04:41.119]                       invokeRestart <- base::invokeRestart
[16:04:41.119]                       is.null <- base::is.null
[16:04:41.119]                       muffled <- FALSE
[16:04:41.119]                       if (inherits(cond, "message")) {
[16:04:41.119]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.119]                         if (muffled) 
[16:04:41.119]                           invokeRestart("muffleMessage")
[16:04:41.119]                       }
[16:04:41.119]                       else if (inherits(cond, "warning")) {
[16:04:41.119]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.119]                         if (muffled) 
[16:04:41.119]                           invokeRestart("muffleWarning")
[16:04:41.119]                       }
[16:04:41.119]                       else if (inherits(cond, "condition")) {
[16:04:41.119]                         if (!is.null(pattern)) {
[16:04:41.119]                           computeRestarts <- base::computeRestarts
[16:04:41.119]                           grepl <- base::grepl
[16:04:41.119]                           restarts <- computeRestarts(cond)
[16:04:41.119]                           for (restart in restarts) {
[16:04:41.119]                             name <- restart$name
[16:04:41.119]                             if (is.null(name)) 
[16:04:41.119]                               next
[16:04:41.119]                             if (!grepl(pattern, name)) 
[16:04:41.119]                               next
[16:04:41.119]                             invokeRestart(restart)
[16:04:41.119]                             muffled <- TRUE
[16:04:41.119]                             break
[16:04:41.119]                           }
[16:04:41.119]                         }
[16:04:41.119]                       }
[16:04:41.119]                       invisible(muffled)
[16:04:41.119]                     }
[16:04:41.119]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.119]                   }
[16:04:41.119]                 }
[16:04:41.119]                 else {
[16:04:41.119]                   if (TRUE) {
[16:04:41.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.119]                     {
[16:04:41.119]                       inherits <- base::inherits
[16:04:41.119]                       invokeRestart <- base::invokeRestart
[16:04:41.119]                       is.null <- base::is.null
[16:04:41.119]                       muffled <- FALSE
[16:04:41.119]                       if (inherits(cond, "message")) {
[16:04:41.119]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.119]                         if (muffled) 
[16:04:41.119]                           invokeRestart("muffleMessage")
[16:04:41.119]                       }
[16:04:41.119]                       else if (inherits(cond, "warning")) {
[16:04:41.119]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.119]                         if (muffled) 
[16:04:41.119]                           invokeRestart("muffleWarning")
[16:04:41.119]                       }
[16:04:41.119]                       else if (inherits(cond, "condition")) {
[16:04:41.119]                         if (!is.null(pattern)) {
[16:04:41.119]                           computeRestarts <- base::computeRestarts
[16:04:41.119]                           grepl <- base::grepl
[16:04:41.119]                           restarts <- computeRestarts(cond)
[16:04:41.119]                           for (restart in restarts) {
[16:04:41.119]                             name <- restart$name
[16:04:41.119]                             if (is.null(name)) 
[16:04:41.119]                               next
[16:04:41.119]                             if (!grepl(pattern, name)) 
[16:04:41.119]                               next
[16:04:41.119]                             invokeRestart(restart)
[16:04:41.119]                             muffled <- TRUE
[16:04:41.119]                             break
[16:04:41.119]                           }
[16:04:41.119]                         }
[16:04:41.119]                       }
[16:04:41.119]                       invisible(muffled)
[16:04:41.119]                     }
[16:04:41.119]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.119]                   }
[16:04:41.119]                 }
[16:04:41.119]             }
[16:04:41.119]         }))
[16:04:41.119]     }, error = function(ex) {
[16:04:41.119]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.119]                 ...future.rng), started = ...future.startTime, 
[16:04:41.119]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.119]             version = "1.8"), class = "FutureResult")
[16:04:41.119]     }, finally = {
[16:04:41.119]         if (!identical(...future.workdir, getwd())) 
[16:04:41.119]             setwd(...future.workdir)
[16:04:41.119]         {
[16:04:41.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.119]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.119]             }
[16:04:41.119]             base::options(...future.oldOptions)
[16:04:41.119]             if (.Platform$OS.type == "windows") {
[16:04:41.119]                 old_names <- names(...future.oldEnvVars)
[16:04:41.119]                 envs <- base::Sys.getenv()
[16:04:41.119]                 names <- names(envs)
[16:04:41.119]                 common <- intersect(names, old_names)
[16:04:41.119]                 added <- setdiff(names, old_names)
[16:04:41.119]                 removed <- setdiff(old_names, names)
[16:04:41.119]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.119]                   envs[common]]
[16:04:41.119]                 NAMES <- toupper(changed)
[16:04:41.119]                 args <- list()
[16:04:41.119]                 for (kk in seq_along(NAMES)) {
[16:04:41.119]                   name <- changed[[kk]]
[16:04:41.119]                   NAME <- NAMES[[kk]]
[16:04:41.119]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.119]                     next
[16:04:41.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.119]                 }
[16:04:41.119]                 NAMES <- toupper(added)
[16:04:41.119]                 for (kk in seq_along(NAMES)) {
[16:04:41.119]                   name <- added[[kk]]
[16:04:41.119]                   NAME <- NAMES[[kk]]
[16:04:41.119]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.119]                     next
[16:04:41.119]                   args[[name]] <- ""
[16:04:41.119]                 }
[16:04:41.119]                 NAMES <- toupper(removed)
[16:04:41.119]                 for (kk in seq_along(NAMES)) {
[16:04:41.119]                   name <- removed[[kk]]
[16:04:41.119]                   NAME <- NAMES[[kk]]
[16:04:41.119]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.119]                     next
[16:04:41.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.119]                 }
[16:04:41.119]                 if (length(args) > 0) 
[16:04:41.119]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.119]             }
[16:04:41.119]             else {
[16:04:41.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.119]             }
[16:04:41.119]             {
[16:04:41.119]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.119]                   0L) {
[16:04:41.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.119]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.119]                   base::options(opts)
[16:04:41.119]                 }
[16:04:41.119]                 {
[16:04:41.119]                   {
[16:04:41.119]                     NULL
[16:04:41.119]                     RNGkind("Mersenne-Twister")
[16:04:41.119]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.119]                       inherits = FALSE)
[16:04:41.119]                   }
[16:04:41.119]                   options(future.plan = NULL)
[16:04:41.119]                   if (is.na(NA_character_)) 
[16:04:41.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.119]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.119]                   {
[16:04:41.119]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.119]                     if (!future$lazy) 
[16:04:41.119]                       future <- run(future)
[16:04:41.119]                     invisible(future)
[16:04:41.119]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.119]                 }
[16:04:41.119]             }
[16:04:41.119]         }
[16:04:41.119]     })
[16:04:41.119]     if (TRUE) {
[16:04:41.119]         base::sink(type = "output", split = FALSE)
[16:04:41.119]         if (TRUE) {
[16:04:41.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.119]         }
[16:04:41.119]         else {
[16:04:41.119]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.119]         }
[16:04:41.119]         base::close(...future.stdout)
[16:04:41.119]         ...future.stdout <- NULL
[16:04:41.119]     }
[16:04:41.119]     ...future.result$conditions <- ...future.conditions
[16:04:41.119]     ...future.result$finished <- base::Sys.time()
[16:04:41.119]     ...future.result
[16:04:41.119] }
[16:04:41.121] plan(): Setting new future strategy stack:
[16:04:41.121] List of future strategies:
[16:04:41.121] 1. sequential:
[16:04:41.121]    - args: function (..., envir = parent.frame())
[16:04:41.121]    - tweaked: FALSE
[16:04:41.121]    - call: NULL
[16:04:41.121] plan(): nbrOfWorkers() = 1
[16:04:41.122] plan(): Setting new future strategy stack:
[16:04:41.122] List of future strategies:
[16:04:41.122] 1. sequential:
[16:04:41.122]    - args: function (..., envir = parent.frame())
[16:04:41.122]    - tweaked: FALSE
[16:04:41.122]    - call: plan(strategy)
[16:04:41.122] plan(): nbrOfWorkers() = 1
[16:04:41.122] SequentialFuture started (and completed)
[16:04:41.122] - Launch lazy future ... done
[16:04:41.122] run() for ‘SequentialFuture’ ... done
[16:04:41.123] getGlobalsAndPackages() ...
[16:04:41.123] Searching for globals...
[16:04:41.123] 
[16:04:41.123] Searching for globals ... DONE
[16:04:41.123] - globals: [0] <none>
[16:04:41.123] getGlobalsAndPackages() ... DONE
[16:04:41.123] run() for ‘Future’ ...
[16:04:41.124] - state: ‘created’
[16:04:41.124] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.124] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.124] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.124]   - Field: ‘label’
[16:04:41.124]   - Field: ‘local’
[16:04:41.124]   - Field: ‘owner’
[16:04:41.124]   - Field: ‘envir’
[16:04:41.124]   - Field: ‘packages’
[16:04:41.125]   - Field: ‘gc’
[16:04:41.125]   - Field: ‘conditions’
[16:04:41.125]   - Field: ‘expr’
[16:04:41.125]   - Field: ‘uuid’
[16:04:41.125]   - Field: ‘seed’
[16:04:41.125]   - Field: ‘version’
[16:04:41.125]   - Field: ‘result’
[16:04:41.125]   - Field: ‘asynchronous’
[16:04:41.125]   - Field: ‘calls’
[16:04:41.125]   - Field: ‘globals’
[16:04:41.125]   - Field: ‘stdout’
[16:04:41.125]   - Field: ‘earlySignal’
[16:04:41.126]   - Field: ‘lazy’
[16:04:41.126]   - Field: ‘state’
[16:04:41.126] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.126] - Launch lazy future ...
[16:04:41.126] Packages needed by the future expression (n = 0): <none>
[16:04:41.126] Packages needed by future strategies (n = 0): <none>
[16:04:41.126] {
[16:04:41.126]     {
[16:04:41.126]         {
[16:04:41.126]             ...future.startTime <- base::Sys.time()
[16:04:41.126]             {
[16:04:41.126]                 {
[16:04:41.126]                   {
[16:04:41.126]                     base::local({
[16:04:41.126]                       has_future <- base::requireNamespace("future", 
[16:04:41.126]                         quietly = TRUE)
[16:04:41.126]                       if (has_future) {
[16:04:41.126]                         ns <- base::getNamespace("future")
[16:04:41.126]                         version <- ns[[".package"]][["version"]]
[16:04:41.126]                         if (is.null(version)) 
[16:04:41.126]                           version <- utils::packageVersion("future")
[16:04:41.126]                       }
[16:04:41.126]                       else {
[16:04:41.126]                         version <- NULL
[16:04:41.126]                       }
[16:04:41.126]                       if (!has_future || version < "1.8.0") {
[16:04:41.126]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.126]                           "", base::R.version$version.string), 
[16:04:41.126]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.126]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.126]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.126]                             "release", "version")], collapse = " "), 
[16:04:41.126]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.126]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.126]                           info)
[16:04:41.126]                         info <- base::paste(info, collapse = "; ")
[16:04:41.126]                         if (!has_future) {
[16:04:41.126]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.126]                             info)
[16:04:41.126]                         }
[16:04:41.126]                         else {
[16:04:41.126]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.126]                             info, version)
[16:04:41.126]                         }
[16:04:41.126]                         base::stop(msg)
[16:04:41.126]                       }
[16:04:41.126]                     })
[16:04:41.126]                   }
[16:04:41.126]                   options(future.plan = NULL)
[16:04:41.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.126]                 }
[16:04:41.126]                 ...future.workdir <- getwd()
[16:04:41.126]             }
[16:04:41.126]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.126]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.126]         }
[16:04:41.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.126]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.126]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.126]             base::names(...future.oldOptions))
[16:04:41.126]     }
[16:04:41.126]     if (FALSE) {
[16:04:41.126]     }
[16:04:41.126]     else {
[16:04:41.126]         if (TRUE) {
[16:04:41.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.126]                 open = "w")
[16:04:41.126]         }
[16:04:41.126]         else {
[16:04:41.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.126]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.126]         }
[16:04:41.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.126]             base::sink(type = "output", split = FALSE)
[16:04:41.126]             base::close(...future.stdout)
[16:04:41.126]         }, add = TRUE)
[16:04:41.126]     }
[16:04:41.126]     ...future.frame <- base::sys.nframe()
[16:04:41.126]     ...future.conditions <- base::list()
[16:04:41.126]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.126]     if (FALSE) {
[16:04:41.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.126]     }
[16:04:41.126]     ...future.result <- base::tryCatch({
[16:04:41.126]         base::withCallingHandlers({
[16:04:41.126]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:41.126]             future::FutureResult(value = ...future.value$value, 
[16:04:41.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.126]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.126]                     ...future.globalenv.names))
[16:04:41.126]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.126]         }, condition = base::local({
[16:04:41.126]             c <- base::c
[16:04:41.126]             inherits <- base::inherits
[16:04:41.126]             invokeRestart <- base::invokeRestart
[16:04:41.126]             length <- base::length
[16:04:41.126]             list <- base::list
[16:04:41.126]             seq.int <- base::seq.int
[16:04:41.126]             signalCondition <- base::signalCondition
[16:04:41.126]             sys.calls <- base::sys.calls
[16:04:41.126]             `[[` <- base::`[[`
[16:04:41.126]             `+` <- base::`+`
[16:04:41.126]             `<<-` <- base::`<<-`
[16:04:41.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.126]                   3L)]
[16:04:41.126]             }
[16:04:41.126]             function(cond) {
[16:04:41.126]                 is_error <- inherits(cond, "error")
[16:04:41.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.126]                   NULL)
[16:04:41.126]                 if (is_error) {
[16:04:41.126]                   sessionInformation <- function() {
[16:04:41.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.126]                       search = base::search(), system = base::Sys.info())
[16:04:41.126]                   }
[16:04:41.126]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.126]                     cond$call), session = sessionInformation(), 
[16:04:41.126]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.126]                   signalCondition(cond)
[16:04:41.126]                 }
[16:04:41.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.126]                 "immediateCondition"))) {
[16:04:41.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.126]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.126]                   if (TRUE && !signal) {
[16:04:41.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.126]                     {
[16:04:41.126]                       inherits <- base::inherits
[16:04:41.126]                       invokeRestart <- base::invokeRestart
[16:04:41.126]                       is.null <- base::is.null
[16:04:41.126]                       muffled <- FALSE
[16:04:41.126]                       if (inherits(cond, "message")) {
[16:04:41.126]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.126]                         if (muffled) 
[16:04:41.126]                           invokeRestart("muffleMessage")
[16:04:41.126]                       }
[16:04:41.126]                       else if (inherits(cond, "warning")) {
[16:04:41.126]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.126]                         if (muffled) 
[16:04:41.126]                           invokeRestart("muffleWarning")
[16:04:41.126]                       }
[16:04:41.126]                       else if (inherits(cond, "condition")) {
[16:04:41.126]                         if (!is.null(pattern)) {
[16:04:41.126]                           computeRestarts <- base::computeRestarts
[16:04:41.126]                           grepl <- base::grepl
[16:04:41.126]                           restarts <- computeRestarts(cond)
[16:04:41.126]                           for (restart in restarts) {
[16:04:41.126]                             name <- restart$name
[16:04:41.126]                             if (is.null(name)) 
[16:04:41.126]                               next
[16:04:41.126]                             if (!grepl(pattern, name)) 
[16:04:41.126]                               next
[16:04:41.126]                             invokeRestart(restart)
[16:04:41.126]                             muffled <- TRUE
[16:04:41.126]                             break
[16:04:41.126]                           }
[16:04:41.126]                         }
[16:04:41.126]                       }
[16:04:41.126]                       invisible(muffled)
[16:04:41.126]                     }
[16:04:41.126]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.126]                   }
[16:04:41.126]                 }
[16:04:41.126]                 else {
[16:04:41.126]                   if (TRUE) {
[16:04:41.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.126]                     {
[16:04:41.126]                       inherits <- base::inherits
[16:04:41.126]                       invokeRestart <- base::invokeRestart
[16:04:41.126]                       is.null <- base::is.null
[16:04:41.126]                       muffled <- FALSE
[16:04:41.126]                       if (inherits(cond, "message")) {
[16:04:41.126]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.126]                         if (muffled) 
[16:04:41.126]                           invokeRestart("muffleMessage")
[16:04:41.126]                       }
[16:04:41.126]                       else if (inherits(cond, "warning")) {
[16:04:41.126]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.126]                         if (muffled) 
[16:04:41.126]                           invokeRestart("muffleWarning")
[16:04:41.126]                       }
[16:04:41.126]                       else if (inherits(cond, "condition")) {
[16:04:41.126]                         if (!is.null(pattern)) {
[16:04:41.126]                           computeRestarts <- base::computeRestarts
[16:04:41.126]                           grepl <- base::grepl
[16:04:41.126]                           restarts <- computeRestarts(cond)
[16:04:41.126]                           for (restart in restarts) {
[16:04:41.126]                             name <- restart$name
[16:04:41.126]                             if (is.null(name)) 
[16:04:41.126]                               next
[16:04:41.126]                             if (!grepl(pattern, name)) 
[16:04:41.126]                               next
[16:04:41.126]                             invokeRestart(restart)
[16:04:41.126]                             muffled <- TRUE
[16:04:41.126]                             break
[16:04:41.126]                           }
[16:04:41.126]                         }
[16:04:41.126]                       }
[16:04:41.126]                       invisible(muffled)
[16:04:41.126]                     }
[16:04:41.126]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.126]                   }
[16:04:41.126]                 }
[16:04:41.126]             }
[16:04:41.126]         }))
[16:04:41.126]     }, error = function(ex) {
[16:04:41.126]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.126]                 ...future.rng), started = ...future.startTime, 
[16:04:41.126]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.126]             version = "1.8"), class = "FutureResult")
[16:04:41.126]     }, finally = {
[16:04:41.126]         if (!identical(...future.workdir, getwd())) 
[16:04:41.126]             setwd(...future.workdir)
[16:04:41.126]         {
[16:04:41.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.126]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.126]             }
[16:04:41.126]             base::options(...future.oldOptions)
[16:04:41.126]             if (.Platform$OS.type == "windows") {
[16:04:41.126]                 old_names <- names(...future.oldEnvVars)
[16:04:41.126]                 envs <- base::Sys.getenv()
[16:04:41.126]                 names <- names(envs)
[16:04:41.126]                 common <- intersect(names, old_names)
[16:04:41.126]                 added <- setdiff(names, old_names)
[16:04:41.126]                 removed <- setdiff(old_names, names)
[16:04:41.126]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.126]                   envs[common]]
[16:04:41.126]                 NAMES <- toupper(changed)
[16:04:41.126]                 args <- list()
[16:04:41.126]                 for (kk in seq_along(NAMES)) {
[16:04:41.126]                   name <- changed[[kk]]
[16:04:41.126]                   NAME <- NAMES[[kk]]
[16:04:41.126]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.126]                     next
[16:04:41.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.126]                 }
[16:04:41.126]                 NAMES <- toupper(added)
[16:04:41.126]                 for (kk in seq_along(NAMES)) {
[16:04:41.126]                   name <- added[[kk]]
[16:04:41.126]                   NAME <- NAMES[[kk]]
[16:04:41.126]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.126]                     next
[16:04:41.126]                   args[[name]] <- ""
[16:04:41.126]                 }
[16:04:41.126]                 NAMES <- toupper(removed)
[16:04:41.126]                 for (kk in seq_along(NAMES)) {
[16:04:41.126]                   name <- removed[[kk]]
[16:04:41.126]                   NAME <- NAMES[[kk]]
[16:04:41.126]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.126]                     next
[16:04:41.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.126]                 }
[16:04:41.126]                 if (length(args) > 0) 
[16:04:41.126]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.126]             }
[16:04:41.126]             else {
[16:04:41.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.126]             }
[16:04:41.126]             {
[16:04:41.126]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.126]                   0L) {
[16:04:41.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.126]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.126]                   base::options(opts)
[16:04:41.126]                 }
[16:04:41.126]                 {
[16:04:41.126]                   {
[16:04:41.126]                     NULL
[16:04:41.126]                     RNGkind("Mersenne-Twister")
[16:04:41.126]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.126]                       inherits = FALSE)
[16:04:41.126]                   }
[16:04:41.126]                   options(future.plan = NULL)
[16:04:41.126]                   if (is.na(NA_character_)) 
[16:04:41.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.126]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.126]                   {
[16:04:41.126]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.126]                     if (!future$lazy) 
[16:04:41.126]                       future <- run(future)
[16:04:41.126]                     invisible(future)
[16:04:41.126]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.126]                 }
[16:04:41.126]             }
[16:04:41.126]         }
[16:04:41.126]     })
[16:04:41.126]     if (TRUE) {
[16:04:41.126]         base::sink(type = "output", split = FALSE)
[16:04:41.126]         if (TRUE) {
[16:04:41.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.126]         }
[16:04:41.126]         else {
[16:04:41.126]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.126]         }
[16:04:41.126]         base::close(...future.stdout)
[16:04:41.126]         ...future.stdout <- NULL
[16:04:41.126]     }
[16:04:41.126]     ...future.result$conditions <- ...future.conditions
[16:04:41.126]     ...future.result$finished <- base::Sys.time()
[16:04:41.126]     ...future.result
[16:04:41.126] }
[16:04:41.128] plan(): Setting new future strategy stack:
[16:04:41.128] List of future strategies:
[16:04:41.128] 1. sequential:
[16:04:41.128]    - args: function (..., envir = parent.frame())
[16:04:41.128]    - tweaked: FALSE
[16:04:41.128]    - call: NULL
[16:04:41.129] plan(): nbrOfWorkers() = 1
[16:04:41.129] plan(): Setting new future strategy stack:
[16:04:41.129] List of future strategies:
[16:04:41.129] 1. sequential:
[16:04:41.129]    - args: function (..., envir = parent.frame())
[16:04:41.129]    - tweaked: FALSE
[16:04:41.129]    - call: plan(strategy)
[16:04:41.130] plan(): nbrOfWorkers() = 1
[16:04:41.130] SequentialFuture started (and completed)
[16:04:41.130] - Launch lazy future ... done
[16:04:41.130] run() for ‘SequentialFuture’ ... done
[16:04:41.130] getGlobalsAndPackages() ...
[16:04:41.130] Searching for globals...
[16:04:41.131] - globals found: [1] ‘{’
[16:04:41.131] Searching for globals ... DONE
[16:04:41.131] Resolving globals: FALSE
[16:04:41.131] 
[16:04:41.132] 
[16:04:41.132] getGlobalsAndPackages() ... DONE
[16:04:41.132] run() for ‘Future’ ...
[16:04:41.132] - state: ‘created’
[16:04:41.132] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.132] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.132] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.132]   - Field: ‘label’
[16:04:41.133]   - Field: ‘local’
[16:04:41.133]   - Field: ‘owner’
[16:04:41.133]   - Field: ‘envir’
[16:04:41.133]   - Field: ‘packages’
[16:04:41.133]   - Field: ‘gc’
[16:04:41.133]   - Field: ‘conditions’
[16:04:41.133]   - Field: ‘expr’
[16:04:41.133]   - Field: ‘uuid’
[16:04:41.133]   - Field: ‘seed’
[16:04:41.133]   - Field: ‘version’
[16:04:41.133]   - Field: ‘result’
[16:04:41.133]   - Field: ‘asynchronous’
[16:04:41.134]   - Field: ‘calls’
[16:04:41.134]   - Field: ‘globals’
[16:04:41.134]   - Field: ‘stdout’
[16:04:41.134]   - Field: ‘earlySignal’
[16:04:41.134]   - Field: ‘lazy’
[16:04:41.134]   - Field: ‘state’
[16:04:41.134] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.134] - Launch lazy future ...
[16:04:41.134] Packages needed by the future expression (n = 0): <none>
[16:04:41.134] Packages needed by future strategies (n = 0): <none>
[16:04:41.135] {
[16:04:41.135]     {
[16:04:41.135]         {
[16:04:41.135]             ...future.startTime <- base::Sys.time()
[16:04:41.135]             {
[16:04:41.135]                 {
[16:04:41.135]                   {
[16:04:41.135]                     base::local({
[16:04:41.135]                       has_future <- base::requireNamespace("future", 
[16:04:41.135]                         quietly = TRUE)
[16:04:41.135]                       if (has_future) {
[16:04:41.135]                         ns <- base::getNamespace("future")
[16:04:41.135]                         version <- ns[[".package"]][["version"]]
[16:04:41.135]                         if (is.null(version)) 
[16:04:41.135]                           version <- utils::packageVersion("future")
[16:04:41.135]                       }
[16:04:41.135]                       else {
[16:04:41.135]                         version <- NULL
[16:04:41.135]                       }
[16:04:41.135]                       if (!has_future || version < "1.8.0") {
[16:04:41.135]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.135]                           "", base::R.version$version.string), 
[16:04:41.135]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.135]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.135]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.135]                             "release", "version")], collapse = " "), 
[16:04:41.135]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.135]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.135]                           info)
[16:04:41.135]                         info <- base::paste(info, collapse = "; ")
[16:04:41.135]                         if (!has_future) {
[16:04:41.135]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.135]                             info)
[16:04:41.135]                         }
[16:04:41.135]                         else {
[16:04:41.135]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.135]                             info, version)
[16:04:41.135]                         }
[16:04:41.135]                         base::stop(msg)
[16:04:41.135]                       }
[16:04:41.135]                     })
[16:04:41.135]                   }
[16:04:41.135]                   options(future.plan = NULL)
[16:04:41.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.135]                 }
[16:04:41.135]                 ...future.workdir <- getwd()
[16:04:41.135]             }
[16:04:41.135]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.135]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.135]         }
[16:04:41.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.135]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.135]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.135]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.135]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.135]             base::names(...future.oldOptions))
[16:04:41.135]     }
[16:04:41.135]     if (FALSE) {
[16:04:41.135]     }
[16:04:41.135]     else {
[16:04:41.135]         if (TRUE) {
[16:04:41.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.135]                 open = "w")
[16:04:41.135]         }
[16:04:41.135]         else {
[16:04:41.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.135]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.135]         }
[16:04:41.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.135]             base::sink(type = "output", split = FALSE)
[16:04:41.135]             base::close(...future.stdout)
[16:04:41.135]         }, add = TRUE)
[16:04:41.135]     }
[16:04:41.135]     ...future.frame <- base::sys.nframe()
[16:04:41.135]     ...future.conditions <- base::list()
[16:04:41.135]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.135]     if (FALSE) {
[16:04:41.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.135]     }
[16:04:41.135]     ...future.result <- base::tryCatch({
[16:04:41.135]         base::withCallingHandlers({
[16:04:41.135]             ...future.value <- base::withVisible(base::local({
[16:04:41.135]                 4
[16:04:41.135]             }))
[16:04:41.135]             future::FutureResult(value = ...future.value$value, 
[16:04:41.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.135]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.135]                     ...future.globalenv.names))
[16:04:41.135]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.135]         }, condition = base::local({
[16:04:41.135]             c <- base::c
[16:04:41.135]             inherits <- base::inherits
[16:04:41.135]             invokeRestart <- base::invokeRestart
[16:04:41.135]             length <- base::length
[16:04:41.135]             list <- base::list
[16:04:41.135]             seq.int <- base::seq.int
[16:04:41.135]             signalCondition <- base::signalCondition
[16:04:41.135]             sys.calls <- base::sys.calls
[16:04:41.135]             `[[` <- base::`[[`
[16:04:41.135]             `+` <- base::`+`
[16:04:41.135]             `<<-` <- base::`<<-`
[16:04:41.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.135]                   3L)]
[16:04:41.135]             }
[16:04:41.135]             function(cond) {
[16:04:41.135]                 is_error <- inherits(cond, "error")
[16:04:41.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.135]                   NULL)
[16:04:41.135]                 if (is_error) {
[16:04:41.135]                   sessionInformation <- function() {
[16:04:41.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.135]                       search = base::search(), system = base::Sys.info())
[16:04:41.135]                   }
[16:04:41.135]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.135]                     cond$call), session = sessionInformation(), 
[16:04:41.135]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.135]                   signalCondition(cond)
[16:04:41.135]                 }
[16:04:41.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.135]                 "immediateCondition"))) {
[16:04:41.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.135]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.135]                   if (TRUE && !signal) {
[16:04:41.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.135]                     {
[16:04:41.135]                       inherits <- base::inherits
[16:04:41.135]                       invokeRestart <- base::invokeRestart
[16:04:41.135]                       is.null <- base::is.null
[16:04:41.135]                       muffled <- FALSE
[16:04:41.135]                       if (inherits(cond, "message")) {
[16:04:41.135]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.135]                         if (muffled) 
[16:04:41.135]                           invokeRestart("muffleMessage")
[16:04:41.135]                       }
[16:04:41.135]                       else if (inherits(cond, "warning")) {
[16:04:41.135]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.135]                         if (muffled) 
[16:04:41.135]                           invokeRestart("muffleWarning")
[16:04:41.135]                       }
[16:04:41.135]                       else if (inherits(cond, "condition")) {
[16:04:41.135]                         if (!is.null(pattern)) {
[16:04:41.135]                           computeRestarts <- base::computeRestarts
[16:04:41.135]                           grepl <- base::grepl
[16:04:41.135]                           restarts <- computeRestarts(cond)
[16:04:41.135]                           for (restart in restarts) {
[16:04:41.135]                             name <- restart$name
[16:04:41.135]                             if (is.null(name)) 
[16:04:41.135]                               next
[16:04:41.135]                             if (!grepl(pattern, name)) 
[16:04:41.135]                               next
[16:04:41.135]                             invokeRestart(restart)
[16:04:41.135]                             muffled <- TRUE
[16:04:41.135]                             break
[16:04:41.135]                           }
[16:04:41.135]                         }
[16:04:41.135]                       }
[16:04:41.135]                       invisible(muffled)
[16:04:41.135]                     }
[16:04:41.135]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.135]                   }
[16:04:41.135]                 }
[16:04:41.135]                 else {
[16:04:41.135]                   if (TRUE) {
[16:04:41.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.135]                     {
[16:04:41.135]                       inherits <- base::inherits
[16:04:41.135]                       invokeRestart <- base::invokeRestart
[16:04:41.135]                       is.null <- base::is.null
[16:04:41.135]                       muffled <- FALSE
[16:04:41.135]                       if (inherits(cond, "message")) {
[16:04:41.135]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.135]                         if (muffled) 
[16:04:41.135]                           invokeRestart("muffleMessage")
[16:04:41.135]                       }
[16:04:41.135]                       else if (inherits(cond, "warning")) {
[16:04:41.135]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.135]                         if (muffled) 
[16:04:41.135]                           invokeRestart("muffleWarning")
[16:04:41.135]                       }
[16:04:41.135]                       else if (inherits(cond, "condition")) {
[16:04:41.135]                         if (!is.null(pattern)) {
[16:04:41.135]                           computeRestarts <- base::computeRestarts
[16:04:41.135]                           grepl <- base::grepl
[16:04:41.135]                           restarts <- computeRestarts(cond)
[16:04:41.135]                           for (restart in restarts) {
[16:04:41.135]                             name <- restart$name
[16:04:41.135]                             if (is.null(name)) 
[16:04:41.135]                               next
[16:04:41.135]                             if (!grepl(pattern, name)) 
[16:04:41.135]                               next
[16:04:41.135]                             invokeRestart(restart)
[16:04:41.135]                             muffled <- TRUE
[16:04:41.135]                             break
[16:04:41.135]                           }
[16:04:41.135]                         }
[16:04:41.135]                       }
[16:04:41.135]                       invisible(muffled)
[16:04:41.135]                     }
[16:04:41.135]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.135]                   }
[16:04:41.135]                 }
[16:04:41.135]             }
[16:04:41.135]         }))
[16:04:41.135]     }, error = function(ex) {
[16:04:41.135]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.135]                 ...future.rng), started = ...future.startTime, 
[16:04:41.135]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.135]             version = "1.8"), class = "FutureResult")
[16:04:41.135]     }, finally = {
[16:04:41.135]         if (!identical(...future.workdir, getwd())) 
[16:04:41.135]             setwd(...future.workdir)
[16:04:41.135]         {
[16:04:41.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.135]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.135]             }
[16:04:41.135]             base::options(...future.oldOptions)
[16:04:41.135]             if (.Platform$OS.type == "windows") {
[16:04:41.135]                 old_names <- names(...future.oldEnvVars)
[16:04:41.135]                 envs <- base::Sys.getenv()
[16:04:41.135]                 names <- names(envs)
[16:04:41.135]                 common <- intersect(names, old_names)
[16:04:41.135]                 added <- setdiff(names, old_names)
[16:04:41.135]                 removed <- setdiff(old_names, names)
[16:04:41.135]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.135]                   envs[common]]
[16:04:41.135]                 NAMES <- toupper(changed)
[16:04:41.135]                 args <- list()
[16:04:41.135]                 for (kk in seq_along(NAMES)) {
[16:04:41.135]                   name <- changed[[kk]]
[16:04:41.135]                   NAME <- NAMES[[kk]]
[16:04:41.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.135]                     next
[16:04:41.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.135]                 }
[16:04:41.135]                 NAMES <- toupper(added)
[16:04:41.135]                 for (kk in seq_along(NAMES)) {
[16:04:41.135]                   name <- added[[kk]]
[16:04:41.135]                   NAME <- NAMES[[kk]]
[16:04:41.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.135]                     next
[16:04:41.135]                   args[[name]] <- ""
[16:04:41.135]                 }
[16:04:41.135]                 NAMES <- toupper(removed)
[16:04:41.135]                 for (kk in seq_along(NAMES)) {
[16:04:41.135]                   name <- removed[[kk]]
[16:04:41.135]                   NAME <- NAMES[[kk]]
[16:04:41.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.135]                     next
[16:04:41.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.135]                 }
[16:04:41.135]                 if (length(args) > 0) 
[16:04:41.135]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.135]             }
[16:04:41.135]             else {
[16:04:41.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.135]             }
[16:04:41.135]             {
[16:04:41.135]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.135]                   0L) {
[16:04:41.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.135]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.135]                   base::options(opts)
[16:04:41.135]                 }
[16:04:41.135]                 {
[16:04:41.135]                   {
[16:04:41.135]                     NULL
[16:04:41.135]                     RNGkind("Mersenne-Twister")
[16:04:41.135]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.135]                       inherits = FALSE)
[16:04:41.135]                   }
[16:04:41.135]                   options(future.plan = NULL)
[16:04:41.135]                   if (is.na(NA_character_)) 
[16:04:41.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.135]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.135]                   {
[16:04:41.135]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.135]                     if (!future$lazy) 
[16:04:41.135]                       future <- run(future)
[16:04:41.135]                     invisible(future)
[16:04:41.135]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.135]                 }
[16:04:41.135]             }
[16:04:41.135]         }
[16:04:41.135]     })
[16:04:41.135]     if (TRUE) {
[16:04:41.135]         base::sink(type = "output", split = FALSE)
[16:04:41.135]         if (TRUE) {
[16:04:41.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.135]         }
[16:04:41.135]         else {
[16:04:41.135]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.135]         }
[16:04:41.135]         base::close(...future.stdout)
[16:04:41.135]         ...future.stdout <- NULL
[16:04:41.135]     }
[16:04:41.135]     ...future.result$conditions <- ...future.conditions
[16:04:41.135]     ...future.result$finished <- base::Sys.time()
[16:04:41.135]     ...future.result
[16:04:41.135] }
[16:04:41.137] plan(): Setting new future strategy stack:
[16:04:41.137] List of future strategies:
[16:04:41.137] 1. sequential:
[16:04:41.137]    - args: function (..., envir = parent.frame())
[16:04:41.137]    - tweaked: FALSE
[16:04:41.137]    - call: NULL
[16:04:41.137] plan(): nbrOfWorkers() = 1
[16:04:41.138] plan(): Setting new future strategy stack:
[16:04:41.138] List of future strategies:
[16:04:41.138] 1. sequential:
[16:04:41.138]    - args: function (..., envir = parent.frame())
[16:04:41.138]    - tweaked: FALSE
[16:04:41.138]    - call: plan(strategy)
[16:04:41.138] plan(): nbrOfWorkers() = 1
[16:04:41.138] SequentialFuture started (and completed)
[16:04:41.138] - Launch lazy future ... done
[16:04:41.139] run() for ‘SequentialFuture’ ... done
<environment: 0x55874bfd79e8> 
<environment: 0x55874d05b3c0> 
[16:04:41.141] resolved() for ‘SequentialFuture’ ...
[16:04:41.141] - state: ‘finished’
[16:04:41.141] - run: TRUE
[16:04:41.141] - result: ‘FutureResult’
[16:04:41.141] resolved() for ‘SequentialFuture’ ... done
[16:04:41.141] resolved() for ‘SequentialFuture’ ...
[16:04:41.141] - state: ‘finished’
[16:04:41.141] - run: TRUE
[16:04:41.142] - result: ‘FutureResult’
[16:04:41.142] resolved() for ‘SequentialFuture’ ... done
[16:04:41.142] resolved() for ‘SequentialFuture’ ...
[16:04:41.142] - state: ‘finished’
[16:04:41.142] - run: TRUE
[16:04:41.142] - result: ‘FutureResult’
[16:04:41.142] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:41.143] resolve() on environment ...
[16:04:41.143]  recursive: 0
[16:04:41.144]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:41.144] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.144] - nx: 4
[16:04:41.144] - relay: TRUE
[16:04:41.144] - stdout: TRUE
[16:04:41.144] - signal: TRUE
[16:04:41.144] - resignal: FALSE
[16:04:41.144] - force: TRUE
[16:04:41.144] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.144] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.145]  - until=2
[16:04:41.145]  - relaying element #2
[16:04:41.145] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:41.145] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.145] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.145]  length: 3 (resolved future 1)
[16:04:41.145] resolved() for ‘SequentialFuture’ ...
[16:04:41.145] - state: ‘finished’
[16:04:41.145] - run: TRUE
[16:04:41.145] - result: ‘FutureResult’
[16:04:41.145] resolved() for ‘SequentialFuture’ ... done
[16:04:41.146] Future #2
[16:04:41.146] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:41.146] - nx: 4
[16:04:41.146] - relay: TRUE
[16:04:41.146] - stdout: TRUE
[16:04:41.146] - signal: TRUE
[16:04:41.146] - resignal: FALSE
[16:04:41.146] - force: TRUE
[16:04:41.146] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:41.146] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.146]  - until=2
[16:04:41.146]  - relaying element #2
[16:04:41.147] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:41.147] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:41.147] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:41.147]  length: 2 (resolved future 2)
[16:04:41.147] resolved() for ‘SequentialFuture’ ...
[16:04:41.147] - state: ‘finished’
[16:04:41.147] - run: TRUE
[16:04:41.147] - result: ‘FutureResult’
[16:04:41.147] resolved() for ‘SequentialFuture’ ... done
[16:04:41.147] Future #3
[16:04:41.148] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:41.148] - nx: 4
[16:04:41.148] - relay: TRUE
[16:04:41.148] - stdout: TRUE
[16:04:41.148] - signal: TRUE
[16:04:41.148] - resignal: FALSE
[16:04:41.148] - force: TRUE
[16:04:41.148] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:41.148] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:41.148]  - until=3
[16:04:41.148]  - relaying element #3
[16:04:41.149] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:41.149] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:41.149] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:41.149]  length: 1 (resolved future 3)
[16:04:41.149] resolved() for ‘SequentialFuture’ ...
[16:04:41.149] - state: ‘finished’
[16:04:41.149] - run: TRUE
[16:04:41.149] - result: ‘FutureResult’
[16:04:41.149] resolved() for ‘SequentialFuture’ ... done
[16:04:41.149] Future #4
[16:04:41.149] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:04:41.150] - nx: 4
[16:04:41.150] - relay: TRUE
[16:04:41.150] - stdout: TRUE
[16:04:41.150] - signal: TRUE
[16:04:41.150] - resignal: FALSE
[16:04:41.150] - force: TRUE
[16:04:41.150] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:41.150] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:41.150]  - until=4
[16:04:41.150]  - relaying element #4
[16:04:41.150] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.150] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:41.151] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:04:41.151]  length: 0 (resolved future 4)
[16:04:41.151] Relaying remaining futures
[16:04:41.151] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.151] - nx: 4
[16:04:41.151] - relay: TRUE
[16:04:41.151] - stdout: TRUE
[16:04:41.151] - signal: TRUE
[16:04:41.151] - resignal: FALSE
[16:04:41.151] - force: TRUE
[16:04:41.151] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.151] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:41.152] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.152] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:41.152] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.152] resolve() on environment ... DONE
<environment: 0x55874bbee070> 
Dimensions: c(2, 3, 1)
[16:04:41.152] getGlobalsAndPackages() ...
[16:04:41.152] Searching for globals...
[16:04:41.153] 
[16:04:41.153] Searching for globals ... DONE
[16:04:41.153] - globals: [0] <none>
[16:04:41.153] getGlobalsAndPackages() ... DONE
[16:04:41.153] run() for ‘Future’ ...
[16:04:41.153] - state: ‘created’
[16:04:41.153] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.154] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.154] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.154]   - Field: ‘label’
[16:04:41.154]   - Field: ‘local’
[16:04:41.154]   - Field: ‘owner’
[16:04:41.154]   - Field: ‘envir’
[16:04:41.154]   - Field: ‘packages’
[16:04:41.154]   - Field: ‘gc’
[16:04:41.154]   - Field: ‘conditions’
[16:04:41.154]   - Field: ‘expr’
[16:04:41.154]   - Field: ‘uuid’
[16:04:41.155]   - Field: ‘seed’
[16:04:41.155]   - Field: ‘version’
[16:04:41.155]   - Field: ‘result’
[16:04:41.155]   - Field: ‘asynchronous’
[16:04:41.155]   - Field: ‘calls’
[16:04:41.155]   - Field: ‘globals’
[16:04:41.155]   - Field: ‘stdout’
[16:04:41.155]   - Field: ‘earlySignal’
[16:04:41.155]   - Field: ‘lazy’
[16:04:41.155]   - Field: ‘state’
[16:04:41.156] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.156] - Launch lazy future ...
[16:04:41.156] Packages needed by the future expression (n = 0): <none>
[16:04:41.156] Packages needed by future strategies (n = 0): <none>
[16:04:41.156] {
[16:04:41.156]     {
[16:04:41.156]         {
[16:04:41.156]             ...future.startTime <- base::Sys.time()
[16:04:41.156]             {
[16:04:41.156]                 {
[16:04:41.156]                   {
[16:04:41.156]                     base::local({
[16:04:41.156]                       has_future <- base::requireNamespace("future", 
[16:04:41.156]                         quietly = TRUE)
[16:04:41.156]                       if (has_future) {
[16:04:41.156]                         ns <- base::getNamespace("future")
[16:04:41.156]                         version <- ns[[".package"]][["version"]]
[16:04:41.156]                         if (is.null(version)) 
[16:04:41.156]                           version <- utils::packageVersion("future")
[16:04:41.156]                       }
[16:04:41.156]                       else {
[16:04:41.156]                         version <- NULL
[16:04:41.156]                       }
[16:04:41.156]                       if (!has_future || version < "1.8.0") {
[16:04:41.156]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.156]                           "", base::R.version$version.string), 
[16:04:41.156]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.156]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.156]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.156]                             "release", "version")], collapse = " "), 
[16:04:41.156]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.156]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.156]                           info)
[16:04:41.156]                         info <- base::paste(info, collapse = "; ")
[16:04:41.156]                         if (!has_future) {
[16:04:41.156]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.156]                             info)
[16:04:41.156]                         }
[16:04:41.156]                         else {
[16:04:41.156]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.156]                             info, version)
[16:04:41.156]                         }
[16:04:41.156]                         base::stop(msg)
[16:04:41.156]                       }
[16:04:41.156]                     })
[16:04:41.156]                   }
[16:04:41.156]                   options(future.plan = NULL)
[16:04:41.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.156]                 }
[16:04:41.156]                 ...future.workdir <- getwd()
[16:04:41.156]             }
[16:04:41.156]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.156]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.156]         }
[16:04:41.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.156]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.156]             base::names(...future.oldOptions))
[16:04:41.156]     }
[16:04:41.156]     if (FALSE) {
[16:04:41.156]     }
[16:04:41.156]     else {
[16:04:41.156]         if (TRUE) {
[16:04:41.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.156]                 open = "w")
[16:04:41.156]         }
[16:04:41.156]         else {
[16:04:41.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.156]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.156]         }
[16:04:41.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.156]             base::sink(type = "output", split = FALSE)
[16:04:41.156]             base::close(...future.stdout)
[16:04:41.156]         }, add = TRUE)
[16:04:41.156]     }
[16:04:41.156]     ...future.frame <- base::sys.nframe()
[16:04:41.156]     ...future.conditions <- base::list()
[16:04:41.156]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.156]     if (FALSE) {
[16:04:41.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.156]     }
[16:04:41.156]     ...future.result <- base::tryCatch({
[16:04:41.156]         base::withCallingHandlers({
[16:04:41.156]             ...future.value <- base::withVisible(base::local(2))
[16:04:41.156]             future::FutureResult(value = ...future.value$value, 
[16:04:41.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.156]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.156]                     ...future.globalenv.names))
[16:04:41.156]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.156]         }, condition = base::local({
[16:04:41.156]             c <- base::c
[16:04:41.156]             inherits <- base::inherits
[16:04:41.156]             invokeRestart <- base::invokeRestart
[16:04:41.156]             length <- base::length
[16:04:41.156]             list <- base::list
[16:04:41.156]             seq.int <- base::seq.int
[16:04:41.156]             signalCondition <- base::signalCondition
[16:04:41.156]             sys.calls <- base::sys.calls
[16:04:41.156]             `[[` <- base::`[[`
[16:04:41.156]             `+` <- base::`+`
[16:04:41.156]             `<<-` <- base::`<<-`
[16:04:41.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.156]                   3L)]
[16:04:41.156]             }
[16:04:41.156]             function(cond) {
[16:04:41.156]                 is_error <- inherits(cond, "error")
[16:04:41.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.156]                   NULL)
[16:04:41.156]                 if (is_error) {
[16:04:41.156]                   sessionInformation <- function() {
[16:04:41.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.156]                       search = base::search(), system = base::Sys.info())
[16:04:41.156]                   }
[16:04:41.156]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.156]                     cond$call), session = sessionInformation(), 
[16:04:41.156]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.156]                   signalCondition(cond)
[16:04:41.156]                 }
[16:04:41.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.156]                 "immediateCondition"))) {
[16:04:41.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.156]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.156]                   if (TRUE && !signal) {
[16:04:41.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.156]                     {
[16:04:41.156]                       inherits <- base::inherits
[16:04:41.156]                       invokeRestart <- base::invokeRestart
[16:04:41.156]                       is.null <- base::is.null
[16:04:41.156]                       muffled <- FALSE
[16:04:41.156]                       if (inherits(cond, "message")) {
[16:04:41.156]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.156]                         if (muffled) 
[16:04:41.156]                           invokeRestart("muffleMessage")
[16:04:41.156]                       }
[16:04:41.156]                       else if (inherits(cond, "warning")) {
[16:04:41.156]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.156]                         if (muffled) 
[16:04:41.156]                           invokeRestart("muffleWarning")
[16:04:41.156]                       }
[16:04:41.156]                       else if (inherits(cond, "condition")) {
[16:04:41.156]                         if (!is.null(pattern)) {
[16:04:41.156]                           computeRestarts <- base::computeRestarts
[16:04:41.156]                           grepl <- base::grepl
[16:04:41.156]                           restarts <- computeRestarts(cond)
[16:04:41.156]                           for (restart in restarts) {
[16:04:41.156]                             name <- restart$name
[16:04:41.156]                             if (is.null(name)) 
[16:04:41.156]                               next
[16:04:41.156]                             if (!grepl(pattern, name)) 
[16:04:41.156]                               next
[16:04:41.156]                             invokeRestart(restart)
[16:04:41.156]                             muffled <- TRUE
[16:04:41.156]                             break
[16:04:41.156]                           }
[16:04:41.156]                         }
[16:04:41.156]                       }
[16:04:41.156]                       invisible(muffled)
[16:04:41.156]                     }
[16:04:41.156]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.156]                   }
[16:04:41.156]                 }
[16:04:41.156]                 else {
[16:04:41.156]                   if (TRUE) {
[16:04:41.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.156]                     {
[16:04:41.156]                       inherits <- base::inherits
[16:04:41.156]                       invokeRestart <- base::invokeRestart
[16:04:41.156]                       is.null <- base::is.null
[16:04:41.156]                       muffled <- FALSE
[16:04:41.156]                       if (inherits(cond, "message")) {
[16:04:41.156]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.156]                         if (muffled) 
[16:04:41.156]                           invokeRestart("muffleMessage")
[16:04:41.156]                       }
[16:04:41.156]                       else if (inherits(cond, "warning")) {
[16:04:41.156]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.156]                         if (muffled) 
[16:04:41.156]                           invokeRestart("muffleWarning")
[16:04:41.156]                       }
[16:04:41.156]                       else if (inherits(cond, "condition")) {
[16:04:41.156]                         if (!is.null(pattern)) {
[16:04:41.156]                           computeRestarts <- base::computeRestarts
[16:04:41.156]                           grepl <- base::grepl
[16:04:41.156]                           restarts <- computeRestarts(cond)
[16:04:41.156]                           for (restart in restarts) {
[16:04:41.156]                             name <- restart$name
[16:04:41.156]                             if (is.null(name)) 
[16:04:41.156]                               next
[16:04:41.156]                             if (!grepl(pattern, name)) 
[16:04:41.156]                               next
[16:04:41.156]                             invokeRestart(restart)
[16:04:41.156]                             muffled <- TRUE
[16:04:41.156]                             break
[16:04:41.156]                           }
[16:04:41.156]                         }
[16:04:41.156]                       }
[16:04:41.156]                       invisible(muffled)
[16:04:41.156]                     }
[16:04:41.156]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.156]                   }
[16:04:41.156]                 }
[16:04:41.156]             }
[16:04:41.156]         }))
[16:04:41.156]     }, error = function(ex) {
[16:04:41.156]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.156]                 ...future.rng), started = ...future.startTime, 
[16:04:41.156]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.156]             version = "1.8"), class = "FutureResult")
[16:04:41.156]     }, finally = {
[16:04:41.156]         if (!identical(...future.workdir, getwd())) 
[16:04:41.156]             setwd(...future.workdir)
[16:04:41.156]         {
[16:04:41.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.156]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.156]             }
[16:04:41.156]             base::options(...future.oldOptions)
[16:04:41.156]             if (.Platform$OS.type == "windows") {
[16:04:41.156]                 old_names <- names(...future.oldEnvVars)
[16:04:41.156]                 envs <- base::Sys.getenv()
[16:04:41.156]                 names <- names(envs)
[16:04:41.156]                 common <- intersect(names, old_names)
[16:04:41.156]                 added <- setdiff(names, old_names)
[16:04:41.156]                 removed <- setdiff(old_names, names)
[16:04:41.156]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.156]                   envs[common]]
[16:04:41.156]                 NAMES <- toupper(changed)
[16:04:41.156]                 args <- list()
[16:04:41.156]                 for (kk in seq_along(NAMES)) {
[16:04:41.156]                   name <- changed[[kk]]
[16:04:41.156]                   NAME <- NAMES[[kk]]
[16:04:41.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.156]                     next
[16:04:41.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.156]                 }
[16:04:41.156]                 NAMES <- toupper(added)
[16:04:41.156]                 for (kk in seq_along(NAMES)) {
[16:04:41.156]                   name <- added[[kk]]
[16:04:41.156]                   NAME <- NAMES[[kk]]
[16:04:41.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.156]                     next
[16:04:41.156]                   args[[name]] <- ""
[16:04:41.156]                 }
[16:04:41.156]                 NAMES <- toupper(removed)
[16:04:41.156]                 for (kk in seq_along(NAMES)) {
[16:04:41.156]                   name <- removed[[kk]]
[16:04:41.156]                   NAME <- NAMES[[kk]]
[16:04:41.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.156]                     next
[16:04:41.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.156]                 }
[16:04:41.156]                 if (length(args) > 0) 
[16:04:41.156]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.156]             }
[16:04:41.156]             else {
[16:04:41.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.156]             }
[16:04:41.156]             {
[16:04:41.156]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.156]                   0L) {
[16:04:41.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.156]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.156]                   base::options(opts)
[16:04:41.156]                 }
[16:04:41.156]                 {
[16:04:41.156]                   {
[16:04:41.156]                     NULL
[16:04:41.156]                     RNGkind("Mersenne-Twister")
[16:04:41.156]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.156]                       inherits = FALSE)
[16:04:41.156]                   }
[16:04:41.156]                   options(future.plan = NULL)
[16:04:41.156]                   if (is.na(NA_character_)) 
[16:04:41.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.156]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.156]                   {
[16:04:41.156]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.156]                     if (!future$lazy) 
[16:04:41.156]                       future <- run(future)
[16:04:41.156]                     invisible(future)
[16:04:41.156]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.156]                 }
[16:04:41.156]             }
[16:04:41.156]         }
[16:04:41.156]     })
[16:04:41.156]     if (TRUE) {
[16:04:41.156]         base::sink(type = "output", split = FALSE)
[16:04:41.156]         if (TRUE) {
[16:04:41.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.156]         }
[16:04:41.156]         else {
[16:04:41.156]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.156]         }
[16:04:41.156]         base::close(...future.stdout)
[16:04:41.156]         ...future.stdout <- NULL
[16:04:41.156]     }
[16:04:41.156]     ...future.result$conditions <- ...future.conditions
[16:04:41.156]     ...future.result$finished <- base::Sys.time()
[16:04:41.156]     ...future.result
[16:04:41.156] }
[16:04:41.158] plan(): Setting new future strategy stack:
[16:04:41.158] List of future strategies:
[16:04:41.158] 1. sequential:
[16:04:41.158]    - args: function (..., envir = parent.frame())
[16:04:41.158]    - tweaked: FALSE
[16:04:41.158]    - call: NULL
[16:04:41.158] plan(): nbrOfWorkers() = 1
[16:04:41.159] plan(): Setting new future strategy stack:
[16:04:41.159] List of future strategies:
[16:04:41.159] 1. sequential:
[16:04:41.159]    - args: function (..., envir = parent.frame())
[16:04:41.159]    - tweaked: FALSE
[16:04:41.159]    - call: plan(strategy)
[16:04:41.160] plan(): nbrOfWorkers() = 1
[16:04:41.160] SequentialFuture started (and completed)
[16:04:41.160] - Launch lazy future ... done
[16:04:41.160] run() for ‘SequentialFuture’ ... done
[16:04:41.160] getGlobalsAndPackages() ...
[16:04:41.160] Searching for globals...
[16:04:41.160] 
[16:04:41.161] Searching for globals ... DONE
[16:04:41.161] - globals: [0] <none>
[16:04:41.161] getGlobalsAndPackages() ... DONE
[16:04:41.161] run() for ‘Future’ ...
[16:04:41.161] - state: ‘created’
[16:04:41.161] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.161] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.161] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.162]   - Field: ‘label’
[16:04:41.162]   - Field: ‘local’
[16:04:41.162]   - Field: ‘owner’
[16:04:41.162]   - Field: ‘envir’
[16:04:41.162]   - Field: ‘packages’
[16:04:41.162]   - Field: ‘gc’
[16:04:41.162]   - Field: ‘conditions’
[16:04:41.162]   - Field: ‘expr’
[16:04:41.162]   - Field: ‘uuid’
[16:04:41.162]   - Field: ‘seed’
[16:04:41.162]   - Field: ‘version’
[16:04:41.164]   - Field: ‘result’
[16:04:41.164]   - Field: ‘asynchronous’
[16:04:41.164]   - Field: ‘calls’
[16:04:41.164]   - Field: ‘globals’
[16:04:41.164]   - Field: ‘stdout’
[16:04:41.164]   - Field: ‘earlySignal’
[16:04:41.164]   - Field: ‘lazy’
[16:04:41.164]   - Field: ‘state’
[16:04:41.164] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.164] - Launch lazy future ...
[16:04:41.165] Packages needed by the future expression (n = 0): <none>
[16:04:41.165] Packages needed by future strategies (n = 0): <none>
[16:04:41.165] {
[16:04:41.165]     {
[16:04:41.165]         {
[16:04:41.165]             ...future.startTime <- base::Sys.time()
[16:04:41.165]             {
[16:04:41.165]                 {
[16:04:41.165]                   {
[16:04:41.165]                     base::local({
[16:04:41.165]                       has_future <- base::requireNamespace("future", 
[16:04:41.165]                         quietly = TRUE)
[16:04:41.165]                       if (has_future) {
[16:04:41.165]                         ns <- base::getNamespace("future")
[16:04:41.165]                         version <- ns[[".package"]][["version"]]
[16:04:41.165]                         if (is.null(version)) 
[16:04:41.165]                           version <- utils::packageVersion("future")
[16:04:41.165]                       }
[16:04:41.165]                       else {
[16:04:41.165]                         version <- NULL
[16:04:41.165]                       }
[16:04:41.165]                       if (!has_future || version < "1.8.0") {
[16:04:41.165]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.165]                           "", base::R.version$version.string), 
[16:04:41.165]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.165]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.165]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.165]                             "release", "version")], collapse = " "), 
[16:04:41.165]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.165]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.165]                           info)
[16:04:41.165]                         info <- base::paste(info, collapse = "; ")
[16:04:41.165]                         if (!has_future) {
[16:04:41.165]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.165]                             info)
[16:04:41.165]                         }
[16:04:41.165]                         else {
[16:04:41.165]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.165]                             info, version)
[16:04:41.165]                         }
[16:04:41.165]                         base::stop(msg)
[16:04:41.165]                       }
[16:04:41.165]                     })
[16:04:41.165]                   }
[16:04:41.165]                   options(future.plan = NULL)
[16:04:41.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.165]                 }
[16:04:41.165]                 ...future.workdir <- getwd()
[16:04:41.165]             }
[16:04:41.165]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.165]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.165]         }
[16:04:41.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.165]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.165]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.165]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.165]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.165]             base::names(...future.oldOptions))
[16:04:41.165]     }
[16:04:41.165]     if (FALSE) {
[16:04:41.165]     }
[16:04:41.165]     else {
[16:04:41.165]         if (TRUE) {
[16:04:41.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.165]                 open = "w")
[16:04:41.165]         }
[16:04:41.165]         else {
[16:04:41.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.165]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.165]         }
[16:04:41.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.165]             base::sink(type = "output", split = FALSE)
[16:04:41.165]             base::close(...future.stdout)
[16:04:41.165]         }, add = TRUE)
[16:04:41.165]     }
[16:04:41.165]     ...future.frame <- base::sys.nframe()
[16:04:41.165]     ...future.conditions <- base::list()
[16:04:41.165]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.165]     if (FALSE) {
[16:04:41.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.165]     }
[16:04:41.165]     ...future.result <- base::tryCatch({
[16:04:41.165]         base::withCallingHandlers({
[16:04:41.165]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:41.165]             future::FutureResult(value = ...future.value$value, 
[16:04:41.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.165]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.165]                     ...future.globalenv.names))
[16:04:41.165]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.165]         }, condition = base::local({
[16:04:41.165]             c <- base::c
[16:04:41.165]             inherits <- base::inherits
[16:04:41.165]             invokeRestart <- base::invokeRestart
[16:04:41.165]             length <- base::length
[16:04:41.165]             list <- base::list
[16:04:41.165]             seq.int <- base::seq.int
[16:04:41.165]             signalCondition <- base::signalCondition
[16:04:41.165]             sys.calls <- base::sys.calls
[16:04:41.165]             `[[` <- base::`[[`
[16:04:41.165]             `+` <- base::`+`
[16:04:41.165]             `<<-` <- base::`<<-`
[16:04:41.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.165]                   3L)]
[16:04:41.165]             }
[16:04:41.165]             function(cond) {
[16:04:41.165]                 is_error <- inherits(cond, "error")
[16:04:41.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.165]                   NULL)
[16:04:41.165]                 if (is_error) {
[16:04:41.165]                   sessionInformation <- function() {
[16:04:41.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.165]                       search = base::search(), system = base::Sys.info())
[16:04:41.165]                   }
[16:04:41.165]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.165]                     cond$call), session = sessionInformation(), 
[16:04:41.165]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.165]                   signalCondition(cond)
[16:04:41.165]                 }
[16:04:41.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.165]                 "immediateCondition"))) {
[16:04:41.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.165]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.165]                   if (TRUE && !signal) {
[16:04:41.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.165]                     {
[16:04:41.165]                       inherits <- base::inherits
[16:04:41.165]                       invokeRestart <- base::invokeRestart
[16:04:41.165]                       is.null <- base::is.null
[16:04:41.165]                       muffled <- FALSE
[16:04:41.165]                       if (inherits(cond, "message")) {
[16:04:41.165]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.165]                         if (muffled) 
[16:04:41.165]                           invokeRestart("muffleMessage")
[16:04:41.165]                       }
[16:04:41.165]                       else if (inherits(cond, "warning")) {
[16:04:41.165]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.165]                         if (muffled) 
[16:04:41.165]                           invokeRestart("muffleWarning")
[16:04:41.165]                       }
[16:04:41.165]                       else if (inherits(cond, "condition")) {
[16:04:41.165]                         if (!is.null(pattern)) {
[16:04:41.165]                           computeRestarts <- base::computeRestarts
[16:04:41.165]                           grepl <- base::grepl
[16:04:41.165]                           restarts <- computeRestarts(cond)
[16:04:41.165]                           for (restart in restarts) {
[16:04:41.165]                             name <- restart$name
[16:04:41.165]                             if (is.null(name)) 
[16:04:41.165]                               next
[16:04:41.165]                             if (!grepl(pattern, name)) 
[16:04:41.165]                               next
[16:04:41.165]                             invokeRestart(restart)
[16:04:41.165]                             muffled <- TRUE
[16:04:41.165]                             break
[16:04:41.165]                           }
[16:04:41.165]                         }
[16:04:41.165]                       }
[16:04:41.165]                       invisible(muffled)
[16:04:41.165]                     }
[16:04:41.165]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.165]                   }
[16:04:41.165]                 }
[16:04:41.165]                 else {
[16:04:41.165]                   if (TRUE) {
[16:04:41.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.165]                     {
[16:04:41.165]                       inherits <- base::inherits
[16:04:41.165]                       invokeRestart <- base::invokeRestart
[16:04:41.165]                       is.null <- base::is.null
[16:04:41.165]                       muffled <- FALSE
[16:04:41.165]                       if (inherits(cond, "message")) {
[16:04:41.165]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.165]                         if (muffled) 
[16:04:41.165]                           invokeRestart("muffleMessage")
[16:04:41.165]                       }
[16:04:41.165]                       else if (inherits(cond, "warning")) {
[16:04:41.165]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.165]                         if (muffled) 
[16:04:41.165]                           invokeRestart("muffleWarning")
[16:04:41.165]                       }
[16:04:41.165]                       else if (inherits(cond, "condition")) {
[16:04:41.165]                         if (!is.null(pattern)) {
[16:04:41.165]                           computeRestarts <- base::computeRestarts
[16:04:41.165]                           grepl <- base::grepl
[16:04:41.165]                           restarts <- computeRestarts(cond)
[16:04:41.165]                           for (restart in restarts) {
[16:04:41.165]                             name <- restart$name
[16:04:41.165]                             if (is.null(name)) 
[16:04:41.165]                               next
[16:04:41.165]                             if (!grepl(pattern, name)) 
[16:04:41.165]                               next
[16:04:41.165]                             invokeRestart(restart)
[16:04:41.165]                             muffled <- TRUE
[16:04:41.165]                             break
[16:04:41.165]                           }
[16:04:41.165]                         }
[16:04:41.165]                       }
[16:04:41.165]                       invisible(muffled)
[16:04:41.165]                     }
[16:04:41.165]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.165]                   }
[16:04:41.165]                 }
[16:04:41.165]             }
[16:04:41.165]         }))
[16:04:41.165]     }, error = function(ex) {
[16:04:41.165]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.165]                 ...future.rng), started = ...future.startTime, 
[16:04:41.165]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.165]             version = "1.8"), class = "FutureResult")
[16:04:41.165]     }, finally = {
[16:04:41.165]         if (!identical(...future.workdir, getwd())) 
[16:04:41.165]             setwd(...future.workdir)
[16:04:41.165]         {
[16:04:41.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.165]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.165]             }
[16:04:41.165]             base::options(...future.oldOptions)
[16:04:41.165]             if (.Platform$OS.type == "windows") {
[16:04:41.165]                 old_names <- names(...future.oldEnvVars)
[16:04:41.165]                 envs <- base::Sys.getenv()
[16:04:41.165]                 names <- names(envs)
[16:04:41.165]                 common <- intersect(names, old_names)
[16:04:41.165]                 added <- setdiff(names, old_names)
[16:04:41.165]                 removed <- setdiff(old_names, names)
[16:04:41.165]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.165]                   envs[common]]
[16:04:41.165]                 NAMES <- toupper(changed)
[16:04:41.165]                 args <- list()
[16:04:41.165]                 for (kk in seq_along(NAMES)) {
[16:04:41.165]                   name <- changed[[kk]]
[16:04:41.165]                   NAME <- NAMES[[kk]]
[16:04:41.165]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.165]                     next
[16:04:41.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.165]                 }
[16:04:41.165]                 NAMES <- toupper(added)
[16:04:41.165]                 for (kk in seq_along(NAMES)) {
[16:04:41.165]                   name <- added[[kk]]
[16:04:41.165]                   NAME <- NAMES[[kk]]
[16:04:41.165]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.165]                     next
[16:04:41.165]                   args[[name]] <- ""
[16:04:41.165]                 }
[16:04:41.165]                 NAMES <- toupper(removed)
[16:04:41.165]                 for (kk in seq_along(NAMES)) {
[16:04:41.165]                   name <- removed[[kk]]
[16:04:41.165]                   NAME <- NAMES[[kk]]
[16:04:41.165]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.165]                     next
[16:04:41.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.165]                 }
[16:04:41.165]                 if (length(args) > 0) 
[16:04:41.165]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.165]             }
[16:04:41.165]             else {
[16:04:41.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.165]             }
[16:04:41.165]             {
[16:04:41.165]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.165]                   0L) {
[16:04:41.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.165]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.165]                   base::options(opts)
[16:04:41.165]                 }
[16:04:41.165]                 {
[16:04:41.165]                   {
[16:04:41.165]                     NULL
[16:04:41.165]                     RNGkind("Mersenne-Twister")
[16:04:41.165]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.165]                       inherits = FALSE)
[16:04:41.165]                   }
[16:04:41.165]                   options(future.plan = NULL)
[16:04:41.165]                   if (is.na(NA_character_)) 
[16:04:41.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.165]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.165]                   {
[16:04:41.165]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.165]                     if (!future$lazy) 
[16:04:41.165]                       future <- run(future)
[16:04:41.165]                     invisible(future)
[16:04:41.165]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.165]                 }
[16:04:41.165]             }
[16:04:41.165]         }
[16:04:41.165]     })
[16:04:41.165]     if (TRUE) {
[16:04:41.165]         base::sink(type = "output", split = FALSE)
[16:04:41.165]         if (TRUE) {
[16:04:41.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.165]         }
[16:04:41.165]         else {
[16:04:41.165]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.165]         }
[16:04:41.165]         base::close(...future.stdout)
[16:04:41.165]         ...future.stdout <- NULL
[16:04:41.165]     }
[16:04:41.165]     ...future.result$conditions <- ...future.conditions
[16:04:41.165]     ...future.result$finished <- base::Sys.time()
[16:04:41.165]     ...future.result
[16:04:41.165] }
[16:04:41.167] plan(): Setting new future strategy stack:
[16:04:41.167] List of future strategies:
[16:04:41.167] 1. sequential:
[16:04:41.167]    - args: function (..., envir = parent.frame())
[16:04:41.167]    - tweaked: FALSE
[16:04:41.167]    - call: NULL
[16:04:41.167] plan(): nbrOfWorkers() = 1
[16:04:41.168] plan(): Setting new future strategy stack:
[16:04:41.168] List of future strategies:
[16:04:41.168] 1. sequential:
[16:04:41.168]    - args: function (..., envir = parent.frame())
[16:04:41.168]    - tweaked: FALSE
[16:04:41.168]    - call: plan(strategy)
[16:04:41.168] plan(): nbrOfWorkers() = 1
[16:04:41.168] SequentialFuture started (and completed)
[16:04:41.169] - Launch lazy future ... done
[16:04:41.169] run() for ‘SequentialFuture’ ... done
[16:04:41.169] getGlobalsAndPackages() ...
[16:04:41.169] Searching for globals...
[16:04:41.170] - globals found: [1] ‘{’
[16:04:41.170] Searching for globals ... DONE
[16:04:41.170] Resolving globals: FALSE
[16:04:41.170] 
[16:04:41.170] 
[16:04:41.170] getGlobalsAndPackages() ... DONE
[16:04:41.170] run() for ‘Future’ ...
[16:04:41.170] - state: ‘created’
[16:04:41.171] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.171] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.171] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.171]   - Field: ‘label’
[16:04:41.171]   - Field: ‘local’
[16:04:41.171]   - Field: ‘owner’
[16:04:41.171]   - Field: ‘envir’
[16:04:41.171]   - Field: ‘packages’
[16:04:41.172]   - Field: ‘gc’
[16:04:41.172]   - Field: ‘conditions’
[16:04:41.172]   - Field: ‘expr’
[16:04:41.172]   - Field: ‘uuid’
[16:04:41.172]   - Field: ‘seed’
[16:04:41.172]   - Field: ‘version’
[16:04:41.172]   - Field: ‘result’
[16:04:41.172]   - Field: ‘asynchronous’
[16:04:41.172]   - Field: ‘calls’
[16:04:41.172]   - Field: ‘globals’
[16:04:41.172]   - Field: ‘stdout’
[16:04:41.172]   - Field: ‘earlySignal’
[16:04:41.173]   - Field: ‘lazy’
[16:04:41.173]   - Field: ‘state’
[16:04:41.173] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.173] - Launch lazy future ...
[16:04:41.173] Packages needed by the future expression (n = 0): <none>
[16:04:41.173] Packages needed by future strategies (n = 0): <none>
[16:04:41.173] {
[16:04:41.173]     {
[16:04:41.173]         {
[16:04:41.173]             ...future.startTime <- base::Sys.time()
[16:04:41.173]             {
[16:04:41.173]                 {
[16:04:41.173]                   {
[16:04:41.173]                     base::local({
[16:04:41.173]                       has_future <- base::requireNamespace("future", 
[16:04:41.173]                         quietly = TRUE)
[16:04:41.173]                       if (has_future) {
[16:04:41.173]                         ns <- base::getNamespace("future")
[16:04:41.173]                         version <- ns[[".package"]][["version"]]
[16:04:41.173]                         if (is.null(version)) 
[16:04:41.173]                           version <- utils::packageVersion("future")
[16:04:41.173]                       }
[16:04:41.173]                       else {
[16:04:41.173]                         version <- NULL
[16:04:41.173]                       }
[16:04:41.173]                       if (!has_future || version < "1.8.0") {
[16:04:41.173]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.173]                           "", base::R.version$version.string), 
[16:04:41.173]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.173]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.173]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.173]                             "release", "version")], collapse = " "), 
[16:04:41.173]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.173]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.173]                           info)
[16:04:41.173]                         info <- base::paste(info, collapse = "; ")
[16:04:41.173]                         if (!has_future) {
[16:04:41.173]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.173]                             info)
[16:04:41.173]                         }
[16:04:41.173]                         else {
[16:04:41.173]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.173]                             info, version)
[16:04:41.173]                         }
[16:04:41.173]                         base::stop(msg)
[16:04:41.173]                       }
[16:04:41.173]                     })
[16:04:41.173]                   }
[16:04:41.173]                   options(future.plan = NULL)
[16:04:41.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.173]                 }
[16:04:41.173]                 ...future.workdir <- getwd()
[16:04:41.173]             }
[16:04:41.173]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.173]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.173]         }
[16:04:41.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.173]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.173]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.173]             base::names(...future.oldOptions))
[16:04:41.173]     }
[16:04:41.173]     if (FALSE) {
[16:04:41.173]     }
[16:04:41.173]     else {
[16:04:41.173]         if (TRUE) {
[16:04:41.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.173]                 open = "w")
[16:04:41.173]         }
[16:04:41.173]         else {
[16:04:41.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.173]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.173]         }
[16:04:41.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.173]             base::sink(type = "output", split = FALSE)
[16:04:41.173]             base::close(...future.stdout)
[16:04:41.173]         }, add = TRUE)
[16:04:41.173]     }
[16:04:41.173]     ...future.frame <- base::sys.nframe()
[16:04:41.173]     ...future.conditions <- base::list()
[16:04:41.173]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.173]     if (FALSE) {
[16:04:41.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.173]     }
[16:04:41.173]     ...future.result <- base::tryCatch({
[16:04:41.173]         base::withCallingHandlers({
[16:04:41.173]             ...future.value <- base::withVisible(base::local({
[16:04:41.173]                 4
[16:04:41.173]             }))
[16:04:41.173]             future::FutureResult(value = ...future.value$value, 
[16:04:41.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.173]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.173]                     ...future.globalenv.names))
[16:04:41.173]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.173]         }, condition = base::local({
[16:04:41.173]             c <- base::c
[16:04:41.173]             inherits <- base::inherits
[16:04:41.173]             invokeRestart <- base::invokeRestart
[16:04:41.173]             length <- base::length
[16:04:41.173]             list <- base::list
[16:04:41.173]             seq.int <- base::seq.int
[16:04:41.173]             signalCondition <- base::signalCondition
[16:04:41.173]             sys.calls <- base::sys.calls
[16:04:41.173]             `[[` <- base::`[[`
[16:04:41.173]             `+` <- base::`+`
[16:04:41.173]             `<<-` <- base::`<<-`
[16:04:41.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.173]                   3L)]
[16:04:41.173]             }
[16:04:41.173]             function(cond) {
[16:04:41.173]                 is_error <- inherits(cond, "error")
[16:04:41.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.173]                   NULL)
[16:04:41.173]                 if (is_error) {
[16:04:41.173]                   sessionInformation <- function() {
[16:04:41.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.173]                       search = base::search(), system = base::Sys.info())
[16:04:41.173]                   }
[16:04:41.173]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.173]                     cond$call), session = sessionInformation(), 
[16:04:41.173]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.173]                   signalCondition(cond)
[16:04:41.173]                 }
[16:04:41.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.173]                 "immediateCondition"))) {
[16:04:41.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.173]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.173]                   if (TRUE && !signal) {
[16:04:41.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.173]                     {
[16:04:41.173]                       inherits <- base::inherits
[16:04:41.173]                       invokeRestart <- base::invokeRestart
[16:04:41.173]                       is.null <- base::is.null
[16:04:41.173]                       muffled <- FALSE
[16:04:41.173]                       if (inherits(cond, "message")) {
[16:04:41.173]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.173]                         if (muffled) 
[16:04:41.173]                           invokeRestart("muffleMessage")
[16:04:41.173]                       }
[16:04:41.173]                       else if (inherits(cond, "warning")) {
[16:04:41.173]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.173]                         if (muffled) 
[16:04:41.173]                           invokeRestart("muffleWarning")
[16:04:41.173]                       }
[16:04:41.173]                       else if (inherits(cond, "condition")) {
[16:04:41.173]                         if (!is.null(pattern)) {
[16:04:41.173]                           computeRestarts <- base::computeRestarts
[16:04:41.173]                           grepl <- base::grepl
[16:04:41.173]                           restarts <- computeRestarts(cond)
[16:04:41.173]                           for (restart in restarts) {
[16:04:41.173]                             name <- restart$name
[16:04:41.173]                             if (is.null(name)) 
[16:04:41.173]                               next
[16:04:41.173]                             if (!grepl(pattern, name)) 
[16:04:41.173]                               next
[16:04:41.173]                             invokeRestart(restart)
[16:04:41.173]                             muffled <- TRUE
[16:04:41.173]                             break
[16:04:41.173]                           }
[16:04:41.173]                         }
[16:04:41.173]                       }
[16:04:41.173]                       invisible(muffled)
[16:04:41.173]                     }
[16:04:41.173]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.173]                   }
[16:04:41.173]                 }
[16:04:41.173]                 else {
[16:04:41.173]                   if (TRUE) {
[16:04:41.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.173]                     {
[16:04:41.173]                       inherits <- base::inherits
[16:04:41.173]                       invokeRestart <- base::invokeRestart
[16:04:41.173]                       is.null <- base::is.null
[16:04:41.173]                       muffled <- FALSE
[16:04:41.173]                       if (inherits(cond, "message")) {
[16:04:41.173]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.173]                         if (muffled) 
[16:04:41.173]                           invokeRestart("muffleMessage")
[16:04:41.173]                       }
[16:04:41.173]                       else if (inherits(cond, "warning")) {
[16:04:41.173]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.173]                         if (muffled) 
[16:04:41.173]                           invokeRestart("muffleWarning")
[16:04:41.173]                       }
[16:04:41.173]                       else if (inherits(cond, "condition")) {
[16:04:41.173]                         if (!is.null(pattern)) {
[16:04:41.173]                           computeRestarts <- base::computeRestarts
[16:04:41.173]                           grepl <- base::grepl
[16:04:41.173]                           restarts <- computeRestarts(cond)
[16:04:41.173]                           for (restart in restarts) {
[16:04:41.173]                             name <- restart$name
[16:04:41.173]                             if (is.null(name)) 
[16:04:41.173]                               next
[16:04:41.173]                             if (!grepl(pattern, name)) 
[16:04:41.173]                               next
[16:04:41.173]                             invokeRestart(restart)
[16:04:41.173]                             muffled <- TRUE
[16:04:41.173]                             break
[16:04:41.173]                           }
[16:04:41.173]                         }
[16:04:41.173]                       }
[16:04:41.173]                       invisible(muffled)
[16:04:41.173]                     }
[16:04:41.173]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.173]                   }
[16:04:41.173]                 }
[16:04:41.173]             }
[16:04:41.173]         }))
[16:04:41.173]     }, error = function(ex) {
[16:04:41.173]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.173]                 ...future.rng), started = ...future.startTime, 
[16:04:41.173]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.173]             version = "1.8"), class = "FutureResult")
[16:04:41.173]     }, finally = {
[16:04:41.173]         if (!identical(...future.workdir, getwd())) 
[16:04:41.173]             setwd(...future.workdir)
[16:04:41.173]         {
[16:04:41.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.173]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.173]             }
[16:04:41.173]             base::options(...future.oldOptions)
[16:04:41.173]             if (.Platform$OS.type == "windows") {
[16:04:41.173]                 old_names <- names(...future.oldEnvVars)
[16:04:41.173]                 envs <- base::Sys.getenv()
[16:04:41.173]                 names <- names(envs)
[16:04:41.173]                 common <- intersect(names, old_names)
[16:04:41.173]                 added <- setdiff(names, old_names)
[16:04:41.173]                 removed <- setdiff(old_names, names)
[16:04:41.173]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.173]                   envs[common]]
[16:04:41.173]                 NAMES <- toupper(changed)
[16:04:41.173]                 args <- list()
[16:04:41.173]                 for (kk in seq_along(NAMES)) {
[16:04:41.173]                   name <- changed[[kk]]
[16:04:41.173]                   NAME <- NAMES[[kk]]
[16:04:41.173]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.173]                     next
[16:04:41.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.173]                 }
[16:04:41.173]                 NAMES <- toupper(added)
[16:04:41.173]                 for (kk in seq_along(NAMES)) {
[16:04:41.173]                   name <- added[[kk]]
[16:04:41.173]                   NAME <- NAMES[[kk]]
[16:04:41.173]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.173]                     next
[16:04:41.173]                   args[[name]] <- ""
[16:04:41.173]                 }
[16:04:41.173]                 NAMES <- toupper(removed)
[16:04:41.173]                 for (kk in seq_along(NAMES)) {
[16:04:41.173]                   name <- removed[[kk]]
[16:04:41.173]                   NAME <- NAMES[[kk]]
[16:04:41.173]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.173]                     next
[16:04:41.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.173]                 }
[16:04:41.173]                 if (length(args) > 0) 
[16:04:41.173]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.173]             }
[16:04:41.173]             else {
[16:04:41.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.173]             }
[16:04:41.173]             {
[16:04:41.173]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.173]                   0L) {
[16:04:41.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.173]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.173]                   base::options(opts)
[16:04:41.173]                 }
[16:04:41.173]                 {
[16:04:41.173]                   {
[16:04:41.173]                     NULL
[16:04:41.173]                     RNGkind("Mersenne-Twister")
[16:04:41.173]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.173]                       inherits = FALSE)
[16:04:41.173]                   }
[16:04:41.173]                   options(future.plan = NULL)
[16:04:41.173]                   if (is.na(NA_character_)) 
[16:04:41.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.173]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.173]                   {
[16:04:41.173]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.173]                     if (!future$lazy) 
[16:04:41.173]                       future <- run(future)
[16:04:41.173]                     invisible(future)
[16:04:41.173]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.173]                 }
[16:04:41.173]             }
[16:04:41.173]         }
[16:04:41.173]     })
[16:04:41.173]     if (TRUE) {
[16:04:41.173]         base::sink(type = "output", split = FALSE)
[16:04:41.173]         if (TRUE) {
[16:04:41.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.173]         }
[16:04:41.173]         else {
[16:04:41.173]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.173]         }
[16:04:41.173]         base::close(...future.stdout)
[16:04:41.173]         ...future.stdout <- NULL
[16:04:41.173]     }
[16:04:41.173]     ...future.result$conditions <- ...future.conditions
[16:04:41.173]     ...future.result$finished <- base::Sys.time()
[16:04:41.173]     ...future.result
[16:04:41.173] }
[16:04:41.175] plan(): Setting new future strategy stack:
[16:04:41.175] List of future strategies:
[16:04:41.175] 1. sequential:
[16:04:41.175]    - args: function (..., envir = parent.frame())
[16:04:41.175]    - tweaked: FALSE
[16:04:41.175]    - call: NULL
[16:04:41.176] plan(): nbrOfWorkers() = 1
[16:04:41.176] plan(): Setting new future strategy stack:
[16:04:41.176] List of future strategies:
[16:04:41.176] 1. sequential:
[16:04:41.176]    - args: function (..., envir = parent.frame())
[16:04:41.176]    - tweaked: FALSE
[16:04:41.176]    - call: plan(strategy)
[16:04:41.177] plan(): nbrOfWorkers() = 1
[16:04:41.177] SequentialFuture started (and completed)
[16:04:41.177] - Launch lazy future ... done
[16:04:41.177] run() for ‘SequentialFuture’ ... done
<environment: 0x55874dae0df8> 
<environment: 0x55874d95fdc0> 
[16:04:41.178] resolved() for ‘SequentialFuture’ ...
[16:04:41.178] - state: ‘finished’
[16:04:41.178] - run: TRUE
[16:04:41.178] - result: ‘FutureResult’
[16:04:41.179] resolved() for ‘SequentialFuture’ ... done
[16:04:41.179] resolved() for ‘SequentialFuture’ ...
[16:04:41.179] - state: ‘finished’
[16:04:41.179] - run: TRUE
[16:04:41.179] - result: ‘FutureResult’
[16:04:41.179] resolved() for ‘SequentialFuture’ ... done
[16:04:41.179] resolved() for ‘SequentialFuture’ ...
[16:04:41.179] - state: ‘finished’
[16:04:41.179] - run: TRUE
[16:04:41.179] - result: ‘FutureResult’
[16:04:41.179] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:41.180] resolve() on environment ...
[16:04:41.181]  recursive: 0
[16:04:41.181]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:41.181] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.181] - nx: 4
[16:04:41.181] - relay: TRUE
[16:04:41.181] - stdout: TRUE
[16:04:41.181] - signal: TRUE
[16:04:41.181] - resignal: FALSE
[16:04:41.182] - force: TRUE
[16:04:41.182] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.182] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.182]  - until=2
[16:04:41.182]  - relaying element #2
[16:04:41.182] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:41.182] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.182] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.182]  length: 3 (resolved future 1)
[16:04:41.182] resolved() for ‘SequentialFuture’ ...
[16:04:41.182] - state: ‘finished’
[16:04:41.183] - run: TRUE
[16:04:41.183] - result: ‘FutureResult’
[16:04:41.183] resolved() for ‘SequentialFuture’ ... done
[16:04:41.183] Future #2
[16:04:41.183] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:41.183] - nx: 4
[16:04:41.183] - relay: TRUE
[16:04:41.183] - stdout: TRUE
[16:04:41.183] - signal: TRUE
[16:04:41.183] - resignal: FALSE
[16:04:41.183] - force: TRUE
[16:04:41.183] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:41.184] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.184]  - until=2
[16:04:41.184]  - relaying element #2
[16:04:41.184] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:41.184] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:41.184] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:41.184]  length: 2 (resolved future 2)
[16:04:41.184] resolved() for ‘SequentialFuture’ ...
[16:04:41.184] - state: ‘finished’
[16:04:41.184] - run: TRUE
[16:04:41.185] - result: ‘FutureResult’
[16:04:41.185] resolved() for ‘SequentialFuture’ ... done
[16:04:41.185] Future #3
[16:04:41.185] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:41.185] - nx: 4
[16:04:41.185] - relay: TRUE
[16:04:41.185] - stdout: TRUE
[16:04:41.185] - signal: TRUE
[16:04:41.185] - resignal: FALSE
[16:04:41.185] - force: TRUE
[16:04:41.185] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:41.185] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:41.186]  - until=3
[16:04:41.186]  - relaying element #3
[16:04:41.186] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:41.186] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:41.186] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:41.186]  length: 1 (resolved future 3)
[16:04:41.186] resolved() for ‘SequentialFuture’ ...
[16:04:41.186] - state: ‘finished’
[16:04:41.186] - run: TRUE
[16:04:41.186] - result: ‘FutureResult’
[16:04:41.187] resolved() for ‘SequentialFuture’ ... done
[16:04:41.187] Future #4
[16:04:41.187] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:04:41.187] - nx: 4
[16:04:41.187] - relay: TRUE
[16:04:41.187] - stdout: TRUE
[16:04:41.187] - signal: TRUE
[16:04:41.187] - resignal: FALSE
[16:04:41.187] - force: TRUE
[16:04:41.187] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:41.187] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:41.187]  - until=4
[16:04:41.188]  - relaying element #4
[16:04:41.189] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.189] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:41.189] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:04:41.189]  length: 0 (resolved future 4)
[16:04:41.189] Relaying remaining futures
[16:04:41.189] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.189] - nx: 4
[16:04:41.189] - relay: TRUE
[16:04:41.189] - stdout: TRUE
[16:04:41.190] - signal: TRUE
[16:04:41.190] - resignal: FALSE
[16:04:41.190] - force: TRUE
[16:04:41.190] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.190] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:41.190] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.190] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:41.190] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.190] resolve() on environment ... DONE
<environment: 0x55874db0a388> 
Dimensions: c(2, 1, 3, 1)
[16:04:41.191] getGlobalsAndPackages() ...
[16:04:41.191] Searching for globals...
[16:04:41.191] 
[16:04:41.191] Searching for globals ... DONE
[16:04:41.191] - globals: [0] <none>
[16:04:41.191] getGlobalsAndPackages() ... DONE
[16:04:41.192] run() for ‘Future’ ...
[16:04:41.192] - state: ‘created’
[16:04:41.192] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.192] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.192] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.192]   - Field: ‘label’
[16:04:41.192]   - Field: ‘local’
[16:04:41.192]   - Field: ‘owner’
[16:04:41.193]   - Field: ‘envir’
[16:04:41.193]   - Field: ‘packages’
[16:04:41.193]   - Field: ‘gc’
[16:04:41.193]   - Field: ‘conditions’
[16:04:41.193]   - Field: ‘expr’
[16:04:41.193]   - Field: ‘uuid’
[16:04:41.193]   - Field: ‘seed’
[16:04:41.193]   - Field: ‘version’
[16:04:41.193]   - Field: ‘result’
[16:04:41.193]   - Field: ‘asynchronous’
[16:04:41.193]   - Field: ‘calls’
[16:04:41.193]   - Field: ‘globals’
[16:04:41.194]   - Field: ‘stdout’
[16:04:41.194]   - Field: ‘earlySignal’
[16:04:41.194]   - Field: ‘lazy’
[16:04:41.194]   - Field: ‘state’
[16:04:41.194] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.194] - Launch lazy future ...
[16:04:41.194] Packages needed by the future expression (n = 0): <none>
[16:04:41.194] Packages needed by future strategies (n = 0): <none>
[16:04:41.195] {
[16:04:41.195]     {
[16:04:41.195]         {
[16:04:41.195]             ...future.startTime <- base::Sys.time()
[16:04:41.195]             {
[16:04:41.195]                 {
[16:04:41.195]                   {
[16:04:41.195]                     base::local({
[16:04:41.195]                       has_future <- base::requireNamespace("future", 
[16:04:41.195]                         quietly = TRUE)
[16:04:41.195]                       if (has_future) {
[16:04:41.195]                         ns <- base::getNamespace("future")
[16:04:41.195]                         version <- ns[[".package"]][["version"]]
[16:04:41.195]                         if (is.null(version)) 
[16:04:41.195]                           version <- utils::packageVersion("future")
[16:04:41.195]                       }
[16:04:41.195]                       else {
[16:04:41.195]                         version <- NULL
[16:04:41.195]                       }
[16:04:41.195]                       if (!has_future || version < "1.8.0") {
[16:04:41.195]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.195]                           "", base::R.version$version.string), 
[16:04:41.195]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.195]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.195]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.195]                             "release", "version")], collapse = " "), 
[16:04:41.195]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.195]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.195]                           info)
[16:04:41.195]                         info <- base::paste(info, collapse = "; ")
[16:04:41.195]                         if (!has_future) {
[16:04:41.195]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.195]                             info)
[16:04:41.195]                         }
[16:04:41.195]                         else {
[16:04:41.195]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.195]                             info, version)
[16:04:41.195]                         }
[16:04:41.195]                         base::stop(msg)
[16:04:41.195]                       }
[16:04:41.195]                     })
[16:04:41.195]                   }
[16:04:41.195]                   options(future.plan = NULL)
[16:04:41.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.195]                 }
[16:04:41.195]                 ...future.workdir <- getwd()
[16:04:41.195]             }
[16:04:41.195]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.195]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.195]         }
[16:04:41.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.195]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.195]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.195]             base::names(...future.oldOptions))
[16:04:41.195]     }
[16:04:41.195]     if (FALSE) {
[16:04:41.195]     }
[16:04:41.195]     else {
[16:04:41.195]         if (TRUE) {
[16:04:41.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.195]                 open = "w")
[16:04:41.195]         }
[16:04:41.195]         else {
[16:04:41.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.195]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.195]         }
[16:04:41.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.195]             base::sink(type = "output", split = FALSE)
[16:04:41.195]             base::close(...future.stdout)
[16:04:41.195]         }, add = TRUE)
[16:04:41.195]     }
[16:04:41.195]     ...future.frame <- base::sys.nframe()
[16:04:41.195]     ...future.conditions <- base::list()
[16:04:41.195]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.195]     if (FALSE) {
[16:04:41.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.195]     }
[16:04:41.195]     ...future.result <- base::tryCatch({
[16:04:41.195]         base::withCallingHandlers({
[16:04:41.195]             ...future.value <- base::withVisible(base::local(2))
[16:04:41.195]             future::FutureResult(value = ...future.value$value, 
[16:04:41.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.195]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.195]                     ...future.globalenv.names))
[16:04:41.195]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.195]         }, condition = base::local({
[16:04:41.195]             c <- base::c
[16:04:41.195]             inherits <- base::inherits
[16:04:41.195]             invokeRestart <- base::invokeRestart
[16:04:41.195]             length <- base::length
[16:04:41.195]             list <- base::list
[16:04:41.195]             seq.int <- base::seq.int
[16:04:41.195]             signalCondition <- base::signalCondition
[16:04:41.195]             sys.calls <- base::sys.calls
[16:04:41.195]             `[[` <- base::`[[`
[16:04:41.195]             `+` <- base::`+`
[16:04:41.195]             `<<-` <- base::`<<-`
[16:04:41.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.195]                   3L)]
[16:04:41.195]             }
[16:04:41.195]             function(cond) {
[16:04:41.195]                 is_error <- inherits(cond, "error")
[16:04:41.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.195]                   NULL)
[16:04:41.195]                 if (is_error) {
[16:04:41.195]                   sessionInformation <- function() {
[16:04:41.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.195]                       search = base::search(), system = base::Sys.info())
[16:04:41.195]                   }
[16:04:41.195]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.195]                     cond$call), session = sessionInformation(), 
[16:04:41.195]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.195]                   signalCondition(cond)
[16:04:41.195]                 }
[16:04:41.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.195]                 "immediateCondition"))) {
[16:04:41.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.195]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.195]                   if (TRUE && !signal) {
[16:04:41.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.195]                     {
[16:04:41.195]                       inherits <- base::inherits
[16:04:41.195]                       invokeRestart <- base::invokeRestart
[16:04:41.195]                       is.null <- base::is.null
[16:04:41.195]                       muffled <- FALSE
[16:04:41.195]                       if (inherits(cond, "message")) {
[16:04:41.195]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.195]                         if (muffled) 
[16:04:41.195]                           invokeRestart("muffleMessage")
[16:04:41.195]                       }
[16:04:41.195]                       else if (inherits(cond, "warning")) {
[16:04:41.195]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.195]                         if (muffled) 
[16:04:41.195]                           invokeRestart("muffleWarning")
[16:04:41.195]                       }
[16:04:41.195]                       else if (inherits(cond, "condition")) {
[16:04:41.195]                         if (!is.null(pattern)) {
[16:04:41.195]                           computeRestarts <- base::computeRestarts
[16:04:41.195]                           grepl <- base::grepl
[16:04:41.195]                           restarts <- computeRestarts(cond)
[16:04:41.195]                           for (restart in restarts) {
[16:04:41.195]                             name <- restart$name
[16:04:41.195]                             if (is.null(name)) 
[16:04:41.195]                               next
[16:04:41.195]                             if (!grepl(pattern, name)) 
[16:04:41.195]                               next
[16:04:41.195]                             invokeRestart(restart)
[16:04:41.195]                             muffled <- TRUE
[16:04:41.195]                             break
[16:04:41.195]                           }
[16:04:41.195]                         }
[16:04:41.195]                       }
[16:04:41.195]                       invisible(muffled)
[16:04:41.195]                     }
[16:04:41.195]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.195]                   }
[16:04:41.195]                 }
[16:04:41.195]                 else {
[16:04:41.195]                   if (TRUE) {
[16:04:41.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.195]                     {
[16:04:41.195]                       inherits <- base::inherits
[16:04:41.195]                       invokeRestart <- base::invokeRestart
[16:04:41.195]                       is.null <- base::is.null
[16:04:41.195]                       muffled <- FALSE
[16:04:41.195]                       if (inherits(cond, "message")) {
[16:04:41.195]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.195]                         if (muffled) 
[16:04:41.195]                           invokeRestart("muffleMessage")
[16:04:41.195]                       }
[16:04:41.195]                       else if (inherits(cond, "warning")) {
[16:04:41.195]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.195]                         if (muffled) 
[16:04:41.195]                           invokeRestart("muffleWarning")
[16:04:41.195]                       }
[16:04:41.195]                       else if (inherits(cond, "condition")) {
[16:04:41.195]                         if (!is.null(pattern)) {
[16:04:41.195]                           computeRestarts <- base::computeRestarts
[16:04:41.195]                           grepl <- base::grepl
[16:04:41.195]                           restarts <- computeRestarts(cond)
[16:04:41.195]                           for (restart in restarts) {
[16:04:41.195]                             name <- restart$name
[16:04:41.195]                             if (is.null(name)) 
[16:04:41.195]                               next
[16:04:41.195]                             if (!grepl(pattern, name)) 
[16:04:41.195]                               next
[16:04:41.195]                             invokeRestart(restart)
[16:04:41.195]                             muffled <- TRUE
[16:04:41.195]                             break
[16:04:41.195]                           }
[16:04:41.195]                         }
[16:04:41.195]                       }
[16:04:41.195]                       invisible(muffled)
[16:04:41.195]                     }
[16:04:41.195]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.195]                   }
[16:04:41.195]                 }
[16:04:41.195]             }
[16:04:41.195]         }))
[16:04:41.195]     }, error = function(ex) {
[16:04:41.195]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.195]                 ...future.rng), started = ...future.startTime, 
[16:04:41.195]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.195]             version = "1.8"), class = "FutureResult")
[16:04:41.195]     }, finally = {
[16:04:41.195]         if (!identical(...future.workdir, getwd())) 
[16:04:41.195]             setwd(...future.workdir)
[16:04:41.195]         {
[16:04:41.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.195]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.195]             }
[16:04:41.195]             base::options(...future.oldOptions)
[16:04:41.195]             if (.Platform$OS.type == "windows") {
[16:04:41.195]                 old_names <- names(...future.oldEnvVars)
[16:04:41.195]                 envs <- base::Sys.getenv()
[16:04:41.195]                 names <- names(envs)
[16:04:41.195]                 common <- intersect(names, old_names)
[16:04:41.195]                 added <- setdiff(names, old_names)
[16:04:41.195]                 removed <- setdiff(old_names, names)
[16:04:41.195]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.195]                   envs[common]]
[16:04:41.195]                 NAMES <- toupper(changed)
[16:04:41.195]                 args <- list()
[16:04:41.195]                 for (kk in seq_along(NAMES)) {
[16:04:41.195]                   name <- changed[[kk]]
[16:04:41.195]                   NAME <- NAMES[[kk]]
[16:04:41.195]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.195]                     next
[16:04:41.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.195]                 }
[16:04:41.195]                 NAMES <- toupper(added)
[16:04:41.195]                 for (kk in seq_along(NAMES)) {
[16:04:41.195]                   name <- added[[kk]]
[16:04:41.195]                   NAME <- NAMES[[kk]]
[16:04:41.195]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.195]                     next
[16:04:41.195]                   args[[name]] <- ""
[16:04:41.195]                 }
[16:04:41.195]                 NAMES <- toupper(removed)
[16:04:41.195]                 for (kk in seq_along(NAMES)) {
[16:04:41.195]                   name <- removed[[kk]]
[16:04:41.195]                   NAME <- NAMES[[kk]]
[16:04:41.195]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.195]                     next
[16:04:41.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.195]                 }
[16:04:41.195]                 if (length(args) > 0) 
[16:04:41.195]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.195]             }
[16:04:41.195]             else {
[16:04:41.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.195]             }
[16:04:41.195]             {
[16:04:41.195]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.195]                   0L) {
[16:04:41.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.195]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.195]                   base::options(opts)
[16:04:41.195]                 }
[16:04:41.195]                 {
[16:04:41.195]                   {
[16:04:41.195]                     NULL
[16:04:41.195]                     RNGkind("Mersenne-Twister")
[16:04:41.195]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.195]                       inherits = FALSE)
[16:04:41.195]                   }
[16:04:41.195]                   options(future.plan = NULL)
[16:04:41.195]                   if (is.na(NA_character_)) 
[16:04:41.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.195]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.195]                   {
[16:04:41.195]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.195]                     if (!future$lazy) 
[16:04:41.195]                       future <- run(future)
[16:04:41.195]                     invisible(future)
[16:04:41.195]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.195]                 }
[16:04:41.195]             }
[16:04:41.195]         }
[16:04:41.195]     })
[16:04:41.195]     if (TRUE) {
[16:04:41.195]         base::sink(type = "output", split = FALSE)
[16:04:41.195]         if (TRUE) {
[16:04:41.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.195]         }
[16:04:41.195]         else {
[16:04:41.195]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.195]         }
[16:04:41.195]         base::close(...future.stdout)
[16:04:41.195]         ...future.stdout <- NULL
[16:04:41.195]     }
[16:04:41.195]     ...future.result$conditions <- ...future.conditions
[16:04:41.195]     ...future.result$finished <- base::Sys.time()
[16:04:41.195]     ...future.result
[16:04:41.195] }
[16:04:41.196] plan(): Setting new future strategy stack:
[16:04:41.196] List of future strategies:
[16:04:41.196] 1. sequential:
[16:04:41.196]    - args: function (..., envir = parent.frame())
[16:04:41.196]    - tweaked: FALSE
[16:04:41.196]    - call: NULL
[16:04:41.197] plan(): nbrOfWorkers() = 1
[16:04:41.197] plan(): Setting new future strategy stack:
[16:04:41.198] List of future strategies:
[16:04:41.198] 1. sequential:
[16:04:41.198]    - args: function (..., envir = parent.frame())
[16:04:41.198]    - tweaked: FALSE
[16:04:41.198]    - call: plan(strategy)
[16:04:41.198] plan(): nbrOfWorkers() = 1
[16:04:41.198] SequentialFuture started (and completed)
[16:04:41.198] - Launch lazy future ... done
[16:04:41.198] run() for ‘SequentialFuture’ ... done
[16:04:41.198] getGlobalsAndPackages() ...
[16:04:41.198] Searching for globals...
[16:04:41.199] 
[16:04:41.199] Searching for globals ... DONE
[16:04:41.199] - globals: [0] <none>
[16:04:41.199] getGlobalsAndPackages() ... DONE
[16:04:41.199] run() for ‘Future’ ...
[16:04:41.199] - state: ‘created’
[16:04:41.199] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.200] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.200] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.200]   - Field: ‘label’
[16:04:41.200]   - Field: ‘local’
[16:04:41.200]   - Field: ‘owner’
[16:04:41.200]   - Field: ‘envir’
[16:04:41.200]   - Field: ‘packages’
[16:04:41.200]   - Field: ‘gc’
[16:04:41.200]   - Field: ‘conditions’
[16:04:41.200]   - Field: ‘expr’
[16:04:41.201]   - Field: ‘uuid’
[16:04:41.201]   - Field: ‘seed’
[16:04:41.201]   - Field: ‘version’
[16:04:41.201]   - Field: ‘result’
[16:04:41.201]   - Field: ‘asynchronous’
[16:04:41.201]   - Field: ‘calls’
[16:04:41.201]   - Field: ‘globals’
[16:04:41.201]   - Field: ‘stdout’
[16:04:41.201]   - Field: ‘earlySignal’
[16:04:41.201]   - Field: ‘lazy’
[16:04:41.201]   - Field: ‘state’
[16:04:41.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.202] - Launch lazy future ...
[16:04:41.202] Packages needed by the future expression (n = 0): <none>
[16:04:41.202] Packages needed by future strategies (n = 0): <none>
[16:04:41.202] {
[16:04:41.202]     {
[16:04:41.202]         {
[16:04:41.202]             ...future.startTime <- base::Sys.time()
[16:04:41.202]             {
[16:04:41.202]                 {
[16:04:41.202]                   {
[16:04:41.202]                     base::local({
[16:04:41.202]                       has_future <- base::requireNamespace("future", 
[16:04:41.202]                         quietly = TRUE)
[16:04:41.202]                       if (has_future) {
[16:04:41.202]                         ns <- base::getNamespace("future")
[16:04:41.202]                         version <- ns[[".package"]][["version"]]
[16:04:41.202]                         if (is.null(version)) 
[16:04:41.202]                           version <- utils::packageVersion("future")
[16:04:41.202]                       }
[16:04:41.202]                       else {
[16:04:41.202]                         version <- NULL
[16:04:41.202]                       }
[16:04:41.202]                       if (!has_future || version < "1.8.0") {
[16:04:41.202]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.202]                           "", base::R.version$version.string), 
[16:04:41.202]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.202]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.202]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.202]                             "release", "version")], collapse = " "), 
[16:04:41.202]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.202]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.202]                           info)
[16:04:41.202]                         info <- base::paste(info, collapse = "; ")
[16:04:41.202]                         if (!has_future) {
[16:04:41.202]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.202]                             info)
[16:04:41.202]                         }
[16:04:41.202]                         else {
[16:04:41.202]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.202]                             info, version)
[16:04:41.202]                         }
[16:04:41.202]                         base::stop(msg)
[16:04:41.202]                       }
[16:04:41.202]                     })
[16:04:41.202]                   }
[16:04:41.202]                   options(future.plan = NULL)
[16:04:41.202]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.202]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.202]                 }
[16:04:41.202]                 ...future.workdir <- getwd()
[16:04:41.202]             }
[16:04:41.202]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.202]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.202]         }
[16:04:41.202]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.202]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.202]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.202]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.202]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.202]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.202]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.202]             base::names(...future.oldOptions))
[16:04:41.202]     }
[16:04:41.202]     if (FALSE) {
[16:04:41.202]     }
[16:04:41.202]     else {
[16:04:41.202]         if (TRUE) {
[16:04:41.202]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.202]                 open = "w")
[16:04:41.202]         }
[16:04:41.202]         else {
[16:04:41.202]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.202]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.202]         }
[16:04:41.202]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.202]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.202]             base::sink(type = "output", split = FALSE)
[16:04:41.202]             base::close(...future.stdout)
[16:04:41.202]         }, add = TRUE)
[16:04:41.202]     }
[16:04:41.202]     ...future.frame <- base::sys.nframe()
[16:04:41.202]     ...future.conditions <- base::list()
[16:04:41.202]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.202]     if (FALSE) {
[16:04:41.202]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.202]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.202]     }
[16:04:41.202]     ...future.result <- base::tryCatch({
[16:04:41.202]         base::withCallingHandlers({
[16:04:41.202]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:41.202]             future::FutureResult(value = ...future.value$value, 
[16:04:41.202]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.202]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.202]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.202]                     ...future.globalenv.names))
[16:04:41.202]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.202]         }, condition = base::local({
[16:04:41.202]             c <- base::c
[16:04:41.202]             inherits <- base::inherits
[16:04:41.202]             invokeRestart <- base::invokeRestart
[16:04:41.202]             length <- base::length
[16:04:41.202]             list <- base::list
[16:04:41.202]             seq.int <- base::seq.int
[16:04:41.202]             signalCondition <- base::signalCondition
[16:04:41.202]             sys.calls <- base::sys.calls
[16:04:41.202]             `[[` <- base::`[[`
[16:04:41.202]             `+` <- base::`+`
[16:04:41.202]             `<<-` <- base::`<<-`
[16:04:41.202]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.202]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.202]                   3L)]
[16:04:41.202]             }
[16:04:41.202]             function(cond) {
[16:04:41.202]                 is_error <- inherits(cond, "error")
[16:04:41.202]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.202]                   NULL)
[16:04:41.202]                 if (is_error) {
[16:04:41.202]                   sessionInformation <- function() {
[16:04:41.202]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.202]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.202]                       search = base::search(), system = base::Sys.info())
[16:04:41.202]                   }
[16:04:41.202]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.202]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.202]                     cond$call), session = sessionInformation(), 
[16:04:41.202]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.202]                   signalCondition(cond)
[16:04:41.202]                 }
[16:04:41.202]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.202]                 "immediateCondition"))) {
[16:04:41.202]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.202]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.202]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.202]                   if (TRUE && !signal) {
[16:04:41.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.202]                     {
[16:04:41.202]                       inherits <- base::inherits
[16:04:41.202]                       invokeRestart <- base::invokeRestart
[16:04:41.202]                       is.null <- base::is.null
[16:04:41.202]                       muffled <- FALSE
[16:04:41.202]                       if (inherits(cond, "message")) {
[16:04:41.202]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.202]                         if (muffled) 
[16:04:41.202]                           invokeRestart("muffleMessage")
[16:04:41.202]                       }
[16:04:41.202]                       else if (inherits(cond, "warning")) {
[16:04:41.202]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.202]                         if (muffled) 
[16:04:41.202]                           invokeRestart("muffleWarning")
[16:04:41.202]                       }
[16:04:41.202]                       else if (inherits(cond, "condition")) {
[16:04:41.202]                         if (!is.null(pattern)) {
[16:04:41.202]                           computeRestarts <- base::computeRestarts
[16:04:41.202]                           grepl <- base::grepl
[16:04:41.202]                           restarts <- computeRestarts(cond)
[16:04:41.202]                           for (restart in restarts) {
[16:04:41.202]                             name <- restart$name
[16:04:41.202]                             if (is.null(name)) 
[16:04:41.202]                               next
[16:04:41.202]                             if (!grepl(pattern, name)) 
[16:04:41.202]                               next
[16:04:41.202]                             invokeRestart(restart)
[16:04:41.202]                             muffled <- TRUE
[16:04:41.202]                             break
[16:04:41.202]                           }
[16:04:41.202]                         }
[16:04:41.202]                       }
[16:04:41.202]                       invisible(muffled)
[16:04:41.202]                     }
[16:04:41.202]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.202]                   }
[16:04:41.202]                 }
[16:04:41.202]                 else {
[16:04:41.202]                   if (TRUE) {
[16:04:41.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.202]                     {
[16:04:41.202]                       inherits <- base::inherits
[16:04:41.202]                       invokeRestart <- base::invokeRestart
[16:04:41.202]                       is.null <- base::is.null
[16:04:41.202]                       muffled <- FALSE
[16:04:41.202]                       if (inherits(cond, "message")) {
[16:04:41.202]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.202]                         if (muffled) 
[16:04:41.202]                           invokeRestart("muffleMessage")
[16:04:41.202]                       }
[16:04:41.202]                       else if (inherits(cond, "warning")) {
[16:04:41.202]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.202]                         if (muffled) 
[16:04:41.202]                           invokeRestart("muffleWarning")
[16:04:41.202]                       }
[16:04:41.202]                       else if (inherits(cond, "condition")) {
[16:04:41.202]                         if (!is.null(pattern)) {
[16:04:41.202]                           computeRestarts <- base::computeRestarts
[16:04:41.202]                           grepl <- base::grepl
[16:04:41.202]                           restarts <- computeRestarts(cond)
[16:04:41.202]                           for (restart in restarts) {
[16:04:41.202]                             name <- restart$name
[16:04:41.202]                             if (is.null(name)) 
[16:04:41.202]                               next
[16:04:41.202]                             if (!grepl(pattern, name)) 
[16:04:41.202]                               next
[16:04:41.202]                             invokeRestart(restart)
[16:04:41.202]                             muffled <- TRUE
[16:04:41.202]                             break
[16:04:41.202]                           }
[16:04:41.202]                         }
[16:04:41.202]                       }
[16:04:41.202]                       invisible(muffled)
[16:04:41.202]                     }
[16:04:41.202]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.202]                   }
[16:04:41.202]                 }
[16:04:41.202]             }
[16:04:41.202]         }))
[16:04:41.202]     }, error = function(ex) {
[16:04:41.202]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.202]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.202]                 ...future.rng), started = ...future.startTime, 
[16:04:41.202]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.202]             version = "1.8"), class = "FutureResult")
[16:04:41.202]     }, finally = {
[16:04:41.202]         if (!identical(...future.workdir, getwd())) 
[16:04:41.202]             setwd(...future.workdir)
[16:04:41.202]         {
[16:04:41.202]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.202]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.202]             }
[16:04:41.202]             base::options(...future.oldOptions)
[16:04:41.202]             if (.Platform$OS.type == "windows") {
[16:04:41.202]                 old_names <- names(...future.oldEnvVars)
[16:04:41.202]                 envs <- base::Sys.getenv()
[16:04:41.202]                 names <- names(envs)
[16:04:41.202]                 common <- intersect(names, old_names)
[16:04:41.202]                 added <- setdiff(names, old_names)
[16:04:41.202]                 removed <- setdiff(old_names, names)
[16:04:41.202]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.202]                   envs[common]]
[16:04:41.202]                 NAMES <- toupper(changed)
[16:04:41.202]                 args <- list()
[16:04:41.202]                 for (kk in seq_along(NAMES)) {
[16:04:41.202]                   name <- changed[[kk]]
[16:04:41.202]                   NAME <- NAMES[[kk]]
[16:04:41.202]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.202]                     next
[16:04:41.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.202]                 }
[16:04:41.202]                 NAMES <- toupper(added)
[16:04:41.202]                 for (kk in seq_along(NAMES)) {
[16:04:41.202]                   name <- added[[kk]]
[16:04:41.202]                   NAME <- NAMES[[kk]]
[16:04:41.202]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.202]                     next
[16:04:41.202]                   args[[name]] <- ""
[16:04:41.202]                 }
[16:04:41.202]                 NAMES <- toupper(removed)
[16:04:41.202]                 for (kk in seq_along(NAMES)) {
[16:04:41.202]                   name <- removed[[kk]]
[16:04:41.202]                   NAME <- NAMES[[kk]]
[16:04:41.202]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.202]                     next
[16:04:41.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.202]                 }
[16:04:41.202]                 if (length(args) > 0) 
[16:04:41.202]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.202]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.202]             }
[16:04:41.202]             else {
[16:04:41.202]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.202]             }
[16:04:41.202]             {
[16:04:41.202]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.202]                   0L) {
[16:04:41.202]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.202]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.202]                   base::options(opts)
[16:04:41.202]                 }
[16:04:41.202]                 {
[16:04:41.202]                   {
[16:04:41.202]                     NULL
[16:04:41.202]                     RNGkind("Mersenne-Twister")
[16:04:41.202]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.202]                       inherits = FALSE)
[16:04:41.202]                   }
[16:04:41.202]                   options(future.plan = NULL)
[16:04:41.202]                   if (is.na(NA_character_)) 
[16:04:41.202]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.202]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.202]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.202]                   {
[16:04:41.202]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.202]                     if (!future$lazy) 
[16:04:41.202]                       future <- run(future)
[16:04:41.202]                     invisible(future)
[16:04:41.202]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.202]                 }
[16:04:41.202]             }
[16:04:41.202]         }
[16:04:41.202]     })
[16:04:41.202]     if (TRUE) {
[16:04:41.202]         base::sink(type = "output", split = FALSE)
[16:04:41.202]         if (TRUE) {
[16:04:41.202]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.202]         }
[16:04:41.202]         else {
[16:04:41.202]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.202]         }
[16:04:41.202]         base::close(...future.stdout)
[16:04:41.202]         ...future.stdout <- NULL
[16:04:41.202]     }
[16:04:41.202]     ...future.result$conditions <- ...future.conditions
[16:04:41.202]     ...future.result$finished <- base::Sys.time()
[16:04:41.202]     ...future.result
[16:04:41.202] }
[16:04:41.204] plan(): Setting new future strategy stack:
[16:04:41.204] List of future strategies:
[16:04:41.204] 1. sequential:
[16:04:41.204]    - args: function (..., envir = parent.frame())
[16:04:41.204]    - tweaked: FALSE
[16:04:41.204]    - call: NULL
[16:04:41.204] plan(): nbrOfWorkers() = 1
[16:04:41.205] plan(): Setting new future strategy stack:
[16:04:41.205] List of future strategies:
[16:04:41.205] 1. sequential:
[16:04:41.205]    - args: function (..., envir = parent.frame())
[16:04:41.205]    - tweaked: FALSE
[16:04:41.205]    - call: plan(strategy)
[16:04:41.205] plan(): nbrOfWorkers() = 1
[16:04:41.206] SequentialFuture started (and completed)
[16:04:41.206] - Launch lazy future ... done
[16:04:41.206] run() for ‘SequentialFuture’ ... done
[16:04:41.206] getGlobalsAndPackages() ...
[16:04:41.206] Searching for globals...
[16:04:41.207] - globals found: [1] ‘{’
[16:04:41.207] Searching for globals ... DONE
[16:04:41.207] Resolving globals: FALSE
[16:04:41.207] 
[16:04:41.207] 
[16:04:41.207] getGlobalsAndPackages() ... DONE
[16:04:41.208] run() for ‘Future’ ...
[16:04:41.208] - state: ‘created’
[16:04:41.208] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.208] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.208] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.208]   - Field: ‘label’
[16:04:41.208]   - Field: ‘local’
[16:04:41.208]   - Field: ‘owner’
[16:04:41.209]   - Field: ‘envir’
[16:04:41.209]   - Field: ‘packages’
[16:04:41.209]   - Field: ‘gc’
[16:04:41.209]   - Field: ‘conditions’
[16:04:41.209]   - Field: ‘expr’
[16:04:41.209]   - Field: ‘uuid’
[16:04:41.209]   - Field: ‘seed’
[16:04:41.209]   - Field: ‘version’
[16:04:41.209]   - Field: ‘result’
[16:04:41.209]   - Field: ‘asynchronous’
[16:04:41.209]   - Field: ‘calls’
[16:04:41.209]   - Field: ‘globals’
[16:04:41.210]   - Field: ‘stdout’
[16:04:41.210]   - Field: ‘earlySignal’
[16:04:41.210]   - Field: ‘lazy’
[16:04:41.210]   - Field: ‘state’
[16:04:41.210] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.210] - Launch lazy future ...
[16:04:41.210] Packages needed by the future expression (n = 0): <none>
[16:04:41.210] Packages needed by future strategies (n = 0): <none>
[16:04:41.211] {
[16:04:41.211]     {
[16:04:41.211]         {
[16:04:41.211]             ...future.startTime <- base::Sys.time()
[16:04:41.211]             {
[16:04:41.211]                 {
[16:04:41.211]                   {
[16:04:41.211]                     base::local({
[16:04:41.211]                       has_future <- base::requireNamespace("future", 
[16:04:41.211]                         quietly = TRUE)
[16:04:41.211]                       if (has_future) {
[16:04:41.211]                         ns <- base::getNamespace("future")
[16:04:41.211]                         version <- ns[[".package"]][["version"]]
[16:04:41.211]                         if (is.null(version)) 
[16:04:41.211]                           version <- utils::packageVersion("future")
[16:04:41.211]                       }
[16:04:41.211]                       else {
[16:04:41.211]                         version <- NULL
[16:04:41.211]                       }
[16:04:41.211]                       if (!has_future || version < "1.8.0") {
[16:04:41.211]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.211]                           "", base::R.version$version.string), 
[16:04:41.211]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.211]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.211]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.211]                             "release", "version")], collapse = " "), 
[16:04:41.211]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.211]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.211]                           info)
[16:04:41.211]                         info <- base::paste(info, collapse = "; ")
[16:04:41.211]                         if (!has_future) {
[16:04:41.211]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.211]                             info)
[16:04:41.211]                         }
[16:04:41.211]                         else {
[16:04:41.211]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.211]                             info, version)
[16:04:41.211]                         }
[16:04:41.211]                         base::stop(msg)
[16:04:41.211]                       }
[16:04:41.211]                     })
[16:04:41.211]                   }
[16:04:41.211]                   options(future.plan = NULL)
[16:04:41.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.211]                 }
[16:04:41.211]                 ...future.workdir <- getwd()
[16:04:41.211]             }
[16:04:41.211]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.211]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.211]         }
[16:04:41.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.211]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.211]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.211]             base::names(...future.oldOptions))
[16:04:41.211]     }
[16:04:41.211]     if (FALSE) {
[16:04:41.211]     }
[16:04:41.211]     else {
[16:04:41.211]         if (TRUE) {
[16:04:41.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.211]                 open = "w")
[16:04:41.211]         }
[16:04:41.211]         else {
[16:04:41.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.211]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.211]         }
[16:04:41.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.211]             base::sink(type = "output", split = FALSE)
[16:04:41.211]             base::close(...future.stdout)
[16:04:41.211]         }, add = TRUE)
[16:04:41.211]     }
[16:04:41.211]     ...future.frame <- base::sys.nframe()
[16:04:41.211]     ...future.conditions <- base::list()
[16:04:41.211]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.211]     if (FALSE) {
[16:04:41.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.211]     }
[16:04:41.211]     ...future.result <- base::tryCatch({
[16:04:41.211]         base::withCallingHandlers({
[16:04:41.211]             ...future.value <- base::withVisible(base::local({
[16:04:41.211]                 4
[16:04:41.211]             }))
[16:04:41.211]             future::FutureResult(value = ...future.value$value, 
[16:04:41.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.211]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.211]                     ...future.globalenv.names))
[16:04:41.211]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.211]         }, condition = base::local({
[16:04:41.211]             c <- base::c
[16:04:41.211]             inherits <- base::inherits
[16:04:41.211]             invokeRestart <- base::invokeRestart
[16:04:41.211]             length <- base::length
[16:04:41.211]             list <- base::list
[16:04:41.211]             seq.int <- base::seq.int
[16:04:41.211]             signalCondition <- base::signalCondition
[16:04:41.211]             sys.calls <- base::sys.calls
[16:04:41.211]             `[[` <- base::`[[`
[16:04:41.211]             `+` <- base::`+`
[16:04:41.211]             `<<-` <- base::`<<-`
[16:04:41.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.211]                   3L)]
[16:04:41.211]             }
[16:04:41.211]             function(cond) {
[16:04:41.211]                 is_error <- inherits(cond, "error")
[16:04:41.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.211]                   NULL)
[16:04:41.211]                 if (is_error) {
[16:04:41.211]                   sessionInformation <- function() {
[16:04:41.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.211]                       search = base::search(), system = base::Sys.info())
[16:04:41.211]                   }
[16:04:41.211]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.211]                     cond$call), session = sessionInformation(), 
[16:04:41.211]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.211]                   signalCondition(cond)
[16:04:41.211]                 }
[16:04:41.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.211]                 "immediateCondition"))) {
[16:04:41.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.211]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.211]                   if (TRUE && !signal) {
[16:04:41.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.211]                     {
[16:04:41.211]                       inherits <- base::inherits
[16:04:41.211]                       invokeRestart <- base::invokeRestart
[16:04:41.211]                       is.null <- base::is.null
[16:04:41.211]                       muffled <- FALSE
[16:04:41.211]                       if (inherits(cond, "message")) {
[16:04:41.211]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.211]                         if (muffled) 
[16:04:41.211]                           invokeRestart("muffleMessage")
[16:04:41.211]                       }
[16:04:41.211]                       else if (inherits(cond, "warning")) {
[16:04:41.211]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.211]                         if (muffled) 
[16:04:41.211]                           invokeRestart("muffleWarning")
[16:04:41.211]                       }
[16:04:41.211]                       else if (inherits(cond, "condition")) {
[16:04:41.211]                         if (!is.null(pattern)) {
[16:04:41.211]                           computeRestarts <- base::computeRestarts
[16:04:41.211]                           grepl <- base::grepl
[16:04:41.211]                           restarts <- computeRestarts(cond)
[16:04:41.211]                           for (restart in restarts) {
[16:04:41.211]                             name <- restart$name
[16:04:41.211]                             if (is.null(name)) 
[16:04:41.211]                               next
[16:04:41.211]                             if (!grepl(pattern, name)) 
[16:04:41.211]                               next
[16:04:41.211]                             invokeRestart(restart)
[16:04:41.211]                             muffled <- TRUE
[16:04:41.211]                             break
[16:04:41.211]                           }
[16:04:41.211]                         }
[16:04:41.211]                       }
[16:04:41.211]                       invisible(muffled)
[16:04:41.211]                     }
[16:04:41.211]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.211]                   }
[16:04:41.211]                 }
[16:04:41.211]                 else {
[16:04:41.211]                   if (TRUE) {
[16:04:41.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.211]                     {
[16:04:41.211]                       inherits <- base::inherits
[16:04:41.211]                       invokeRestart <- base::invokeRestart
[16:04:41.211]                       is.null <- base::is.null
[16:04:41.211]                       muffled <- FALSE
[16:04:41.211]                       if (inherits(cond, "message")) {
[16:04:41.211]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.211]                         if (muffled) 
[16:04:41.211]                           invokeRestart("muffleMessage")
[16:04:41.211]                       }
[16:04:41.211]                       else if (inherits(cond, "warning")) {
[16:04:41.211]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.211]                         if (muffled) 
[16:04:41.211]                           invokeRestart("muffleWarning")
[16:04:41.211]                       }
[16:04:41.211]                       else if (inherits(cond, "condition")) {
[16:04:41.211]                         if (!is.null(pattern)) {
[16:04:41.211]                           computeRestarts <- base::computeRestarts
[16:04:41.211]                           grepl <- base::grepl
[16:04:41.211]                           restarts <- computeRestarts(cond)
[16:04:41.211]                           for (restart in restarts) {
[16:04:41.211]                             name <- restart$name
[16:04:41.211]                             if (is.null(name)) 
[16:04:41.211]                               next
[16:04:41.211]                             if (!grepl(pattern, name)) 
[16:04:41.211]                               next
[16:04:41.211]                             invokeRestart(restart)
[16:04:41.211]                             muffled <- TRUE
[16:04:41.211]                             break
[16:04:41.211]                           }
[16:04:41.211]                         }
[16:04:41.211]                       }
[16:04:41.211]                       invisible(muffled)
[16:04:41.211]                     }
[16:04:41.211]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.211]                   }
[16:04:41.211]                 }
[16:04:41.211]             }
[16:04:41.211]         }))
[16:04:41.211]     }, error = function(ex) {
[16:04:41.211]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.211]                 ...future.rng), started = ...future.startTime, 
[16:04:41.211]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.211]             version = "1.8"), class = "FutureResult")
[16:04:41.211]     }, finally = {
[16:04:41.211]         if (!identical(...future.workdir, getwd())) 
[16:04:41.211]             setwd(...future.workdir)
[16:04:41.211]         {
[16:04:41.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.211]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.211]             }
[16:04:41.211]             base::options(...future.oldOptions)
[16:04:41.211]             if (.Platform$OS.type == "windows") {
[16:04:41.211]                 old_names <- names(...future.oldEnvVars)
[16:04:41.211]                 envs <- base::Sys.getenv()
[16:04:41.211]                 names <- names(envs)
[16:04:41.211]                 common <- intersect(names, old_names)
[16:04:41.211]                 added <- setdiff(names, old_names)
[16:04:41.211]                 removed <- setdiff(old_names, names)
[16:04:41.211]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.211]                   envs[common]]
[16:04:41.211]                 NAMES <- toupper(changed)
[16:04:41.211]                 args <- list()
[16:04:41.211]                 for (kk in seq_along(NAMES)) {
[16:04:41.211]                   name <- changed[[kk]]
[16:04:41.211]                   NAME <- NAMES[[kk]]
[16:04:41.211]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.211]                     next
[16:04:41.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.211]                 }
[16:04:41.211]                 NAMES <- toupper(added)
[16:04:41.211]                 for (kk in seq_along(NAMES)) {
[16:04:41.211]                   name <- added[[kk]]
[16:04:41.211]                   NAME <- NAMES[[kk]]
[16:04:41.211]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.211]                     next
[16:04:41.211]                   args[[name]] <- ""
[16:04:41.211]                 }
[16:04:41.211]                 NAMES <- toupper(removed)
[16:04:41.211]                 for (kk in seq_along(NAMES)) {
[16:04:41.211]                   name <- removed[[kk]]
[16:04:41.211]                   NAME <- NAMES[[kk]]
[16:04:41.211]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.211]                     next
[16:04:41.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.211]                 }
[16:04:41.211]                 if (length(args) > 0) 
[16:04:41.211]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.211]             }
[16:04:41.211]             else {
[16:04:41.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.211]             }
[16:04:41.211]             {
[16:04:41.211]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.211]                   0L) {
[16:04:41.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.211]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.211]                   base::options(opts)
[16:04:41.211]                 }
[16:04:41.211]                 {
[16:04:41.211]                   {
[16:04:41.211]                     NULL
[16:04:41.211]                     RNGkind("Mersenne-Twister")
[16:04:41.211]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.211]                       inherits = FALSE)
[16:04:41.211]                   }
[16:04:41.211]                   options(future.plan = NULL)
[16:04:41.211]                   if (is.na(NA_character_)) 
[16:04:41.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.211]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.211]                   {
[16:04:41.211]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.211]                     if (!future$lazy) 
[16:04:41.211]                       future <- run(future)
[16:04:41.211]                     invisible(future)
[16:04:41.211]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.211]                 }
[16:04:41.211]             }
[16:04:41.211]         }
[16:04:41.211]     })
[16:04:41.211]     if (TRUE) {
[16:04:41.211]         base::sink(type = "output", split = FALSE)
[16:04:41.211]         if (TRUE) {
[16:04:41.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.211]         }
[16:04:41.211]         else {
[16:04:41.211]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.211]         }
[16:04:41.211]         base::close(...future.stdout)
[16:04:41.211]         ...future.stdout <- NULL
[16:04:41.211]     }
[16:04:41.211]     ...future.result$conditions <- ...future.conditions
[16:04:41.211]     ...future.result$finished <- base::Sys.time()
[16:04:41.211]     ...future.result
[16:04:41.211] }
[16:04:41.212] plan(): Setting new future strategy stack:
[16:04:41.212] List of future strategies:
[16:04:41.212] 1. sequential:
[16:04:41.212]    - args: function (..., envir = parent.frame())
[16:04:41.212]    - tweaked: FALSE
[16:04:41.212]    - call: NULL
[16:04:41.213] plan(): nbrOfWorkers() = 1
[16:04:41.213] plan(): Setting new future strategy stack:
[16:04:41.214] List of future strategies:
[16:04:41.214] 1. sequential:
[16:04:41.214]    - args: function (..., envir = parent.frame())
[16:04:41.214]    - tweaked: FALSE
[16:04:41.214]    - call: plan(strategy)
[16:04:41.214] plan(): nbrOfWorkers() = 1
[16:04:41.214] SequentialFuture started (and completed)
[16:04:41.214] - Launch lazy future ... done
[16:04:41.214] run() for ‘SequentialFuture’ ... done
<environment: 0x55874c4a0eb0> 
<environment: 0x55874e175698> 
[16:04:41.217] resolved() for ‘SequentialFuture’ ...
[16:04:41.217] - state: ‘finished’
[16:04:41.217] - run: TRUE
[16:04:41.217] - result: ‘FutureResult’
[16:04:41.217] resolved() for ‘SequentialFuture’ ... done
[16:04:41.217] resolved() for ‘SequentialFuture’ ...
[16:04:41.217] - state: ‘finished’
[16:04:41.217] - run: TRUE
[16:04:41.217] - result: ‘FutureResult’
[16:04:41.217] resolved() for ‘SequentialFuture’ ... done
[16:04:41.217] resolved() for ‘SequentialFuture’ ...
[16:04:41.218] - state: ‘finished’
[16:04:41.218] - run: TRUE
[16:04:41.218] - result: ‘FutureResult’
[16:04:41.218] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:41.219] resolve() on environment ...
[16:04:41.219]  recursive: 0
[16:04:41.220]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:41.220] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.220] - nx: 4
[16:04:41.220] - relay: TRUE
[16:04:41.220] - stdout: TRUE
[16:04:41.220] - signal: TRUE
[16:04:41.220] - resignal: FALSE
[16:04:41.220] - force: TRUE
[16:04:41.220] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.220] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.220]  - until=2
[16:04:41.220]  - relaying element #2
[16:04:41.221] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:41.221] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.221] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.221]  length: 3 (resolved future 1)
[16:04:41.221] resolved() for ‘SequentialFuture’ ...
[16:04:41.221] - state: ‘finished’
[16:04:41.221] - run: TRUE
[16:04:41.221] - result: ‘FutureResult’
[16:04:41.221] resolved() for ‘SequentialFuture’ ... done
[16:04:41.221] Future #2
[16:04:41.221] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:41.222] - nx: 4
[16:04:41.222] - relay: TRUE
[16:04:41.222] - stdout: TRUE
[16:04:41.222] - signal: TRUE
[16:04:41.222] - resignal: FALSE
[16:04:41.222] - force: TRUE
[16:04:41.222] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:41.222] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:41.222]  - until=2
[16:04:41.222]  - relaying element #2
[16:04:41.222] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:41.223] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:41.223] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:41.223]  length: 2 (resolved future 2)
[16:04:41.223] resolved() for ‘SequentialFuture’ ...
[16:04:41.223] - state: ‘finished’
[16:04:41.223] - run: TRUE
[16:04:41.223] - result: ‘FutureResult’
[16:04:41.223] resolved() for ‘SequentialFuture’ ... done
[16:04:41.223] Future #3
[16:04:41.223] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:41.223] - nx: 4
[16:04:41.224] - relay: TRUE
[16:04:41.224] - stdout: TRUE
[16:04:41.224] - signal: TRUE
[16:04:41.224] - resignal: FALSE
[16:04:41.224] - force: TRUE
[16:04:41.224] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:41.224] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:41.224]  - until=3
[16:04:41.224]  - relaying element #3
[16:04:41.224] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:41.224] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:41.225] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:41.225]  length: 1 (resolved future 3)
[16:04:41.225] resolved() for ‘SequentialFuture’ ...
[16:04:41.225] - state: ‘finished’
[16:04:41.225] - run: TRUE
[16:04:41.225] - result: ‘FutureResult’
[16:04:41.225] resolved() for ‘SequentialFuture’ ... done
[16:04:41.225] Future #4
[16:04:41.225] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:04:41.225] - nx: 4
[16:04:41.225] - relay: TRUE
[16:04:41.225] - stdout: TRUE
[16:04:41.226] - signal: TRUE
[16:04:41.226] - resignal: FALSE
[16:04:41.226] - force: TRUE
[16:04:41.226] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:41.226] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:41.226]  - until=4
[16:04:41.226]  - relaying element #4
[16:04:41.226] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.226] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:41.226] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:04:41.226]  length: 0 (resolved future 4)
[16:04:41.227] Relaying remaining futures
[16:04:41.227] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.227] - nx: 4
[16:04:41.227] - relay: TRUE
[16:04:41.227] - stdout: TRUE
[16:04:41.227] - signal: TRUE
[16:04:41.227] - resignal: FALSE
[16:04:41.227] - force: TRUE
[16:04:41.227] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.227] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:41.227] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:41.227] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:41.228] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.228] resolve() on environment ... DONE
<environment: 0x55874c281f18> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[16:04:41.228] plan(): Setting new future strategy stack:
[16:04:41.229] List of future strategies:
[16:04:41.229] 1. sequential:
[16:04:41.229]    - args: function (..., envir = parent.frame())
[16:04:41.229]    - tweaked: FALSE
[16:04:41.229]    - call: plan(strategy)
[16:04:41.229] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[16:04:41.229] getGlobalsAndPackages() ...
[16:04:41.229] Searching for globals...
[16:04:41.230] 
[16:04:41.230] Searching for globals ... DONE
[16:04:41.230] - globals: [0] <none>
[16:04:41.230] getGlobalsAndPackages() ... DONE
[16:04:41.230] run() for ‘Future’ ...
[16:04:41.230] - state: ‘created’
[16:04:41.230] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.230] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.231] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.231]   - Field: ‘label’
[16:04:41.231]   - Field: ‘local’
[16:04:41.231]   - Field: ‘owner’
[16:04:41.231]   - Field: ‘envir’
[16:04:41.231]   - Field: ‘packages’
[16:04:41.231]   - Field: ‘gc’
[16:04:41.231]   - Field: ‘conditions’
[16:04:41.231]   - Field: ‘expr’
[16:04:41.231]   - Field: ‘uuid’
[16:04:41.232]   - Field: ‘seed’
[16:04:41.232]   - Field: ‘version’
[16:04:41.232]   - Field: ‘result’
[16:04:41.232]   - Field: ‘asynchronous’
[16:04:41.232]   - Field: ‘calls’
[16:04:41.232]   - Field: ‘globals’
[16:04:41.232]   - Field: ‘stdout’
[16:04:41.232]   - Field: ‘earlySignal’
[16:04:41.232]   - Field: ‘lazy’
[16:04:41.232]   - Field: ‘state’
[16:04:41.232] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.232] - Launch lazy future ...
[16:04:41.233] Packages needed by the future expression (n = 0): <none>
[16:04:41.233] Packages needed by future strategies (n = 0): <none>
[16:04:41.233] {
[16:04:41.233]     {
[16:04:41.233]         {
[16:04:41.233]             ...future.startTime <- base::Sys.time()
[16:04:41.233]             {
[16:04:41.233]                 {
[16:04:41.233]                   {
[16:04:41.233]                     base::local({
[16:04:41.233]                       has_future <- base::requireNamespace("future", 
[16:04:41.233]                         quietly = TRUE)
[16:04:41.233]                       if (has_future) {
[16:04:41.233]                         ns <- base::getNamespace("future")
[16:04:41.233]                         version <- ns[[".package"]][["version"]]
[16:04:41.233]                         if (is.null(version)) 
[16:04:41.233]                           version <- utils::packageVersion("future")
[16:04:41.233]                       }
[16:04:41.233]                       else {
[16:04:41.233]                         version <- NULL
[16:04:41.233]                       }
[16:04:41.233]                       if (!has_future || version < "1.8.0") {
[16:04:41.233]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.233]                           "", base::R.version$version.string), 
[16:04:41.233]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.233]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.233]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.233]                             "release", "version")], collapse = " "), 
[16:04:41.233]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.233]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.233]                           info)
[16:04:41.233]                         info <- base::paste(info, collapse = "; ")
[16:04:41.233]                         if (!has_future) {
[16:04:41.233]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.233]                             info)
[16:04:41.233]                         }
[16:04:41.233]                         else {
[16:04:41.233]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.233]                             info, version)
[16:04:41.233]                         }
[16:04:41.233]                         base::stop(msg)
[16:04:41.233]                       }
[16:04:41.233]                     })
[16:04:41.233]                   }
[16:04:41.233]                   options(future.plan = NULL)
[16:04:41.233]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.233]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.233]                 }
[16:04:41.233]                 ...future.workdir <- getwd()
[16:04:41.233]             }
[16:04:41.233]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.233]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.233]         }
[16:04:41.233]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.233]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.233]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.233]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.233]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.233]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.233]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.233]             base::names(...future.oldOptions))
[16:04:41.233]     }
[16:04:41.233]     if (FALSE) {
[16:04:41.233]     }
[16:04:41.233]     else {
[16:04:41.233]         if (TRUE) {
[16:04:41.233]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.233]                 open = "w")
[16:04:41.233]         }
[16:04:41.233]         else {
[16:04:41.233]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.233]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.233]         }
[16:04:41.233]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.233]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.233]             base::sink(type = "output", split = FALSE)
[16:04:41.233]             base::close(...future.stdout)
[16:04:41.233]         }, add = TRUE)
[16:04:41.233]     }
[16:04:41.233]     ...future.frame <- base::sys.nframe()
[16:04:41.233]     ...future.conditions <- base::list()
[16:04:41.233]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.233]     if (FALSE) {
[16:04:41.233]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.233]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.233]     }
[16:04:41.233]     ...future.result <- base::tryCatch({
[16:04:41.233]         base::withCallingHandlers({
[16:04:41.233]             ...future.value <- base::withVisible(base::local(2))
[16:04:41.233]             future::FutureResult(value = ...future.value$value, 
[16:04:41.233]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.233]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.233]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.233]                     ...future.globalenv.names))
[16:04:41.233]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.233]         }, condition = base::local({
[16:04:41.233]             c <- base::c
[16:04:41.233]             inherits <- base::inherits
[16:04:41.233]             invokeRestart <- base::invokeRestart
[16:04:41.233]             length <- base::length
[16:04:41.233]             list <- base::list
[16:04:41.233]             seq.int <- base::seq.int
[16:04:41.233]             signalCondition <- base::signalCondition
[16:04:41.233]             sys.calls <- base::sys.calls
[16:04:41.233]             `[[` <- base::`[[`
[16:04:41.233]             `+` <- base::`+`
[16:04:41.233]             `<<-` <- base::`<<-`
[16:04:41.233]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.233]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.233]                   3L)]
[16:04:41.233]             }
[16:04:41.233]             function(cond) {
[16:04:41.233]                 is_error <- inherits(cond, "error")
[16:04:41.233]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.233]                   NULL)
[16:04:41.233]                 if (is_error) {
[16:04:41.233]                   sessionInformation <- function() {
[16:04:41.233]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.233]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.233]                       search = base::search(), system = base::Sys.info())
[16:04:41.233]                   }
[16:04:41.233]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.233]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.233]                     cond$call), session = sessionInformation(), 
[16:04:41.233]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.233]                   signalCondition(cond)
[16:04:41.233]                 }
[16:04:41.233]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.233]                 "immediateCondition"))) {
[16:04:41.233]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.233]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.233]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.233]                   if (TRUE && !signal) {
[16:04:41.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.233]                     {
[16:04:41.233]                       inherits <- base::inherits
[16:04:41.233]                       invokeRestart <- base::invokeRestart
[16:04:41.233]                       is.null <- base::is.null
[16:04:41.233]                       muffled <- FALSE
[16:04:41.233]                       if (inherits(cond, "message")) {
[16:04:41.233]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.233]                         if (muffled) 
[16:04:41.233]                           invokeRestart("muffleMessage")
[16:04:41.233]                       }
[16:04:41.233]                       else if (inherits(cond, "warning")) {
[16:04:41.233]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.233]                         if (muffled) 
[16:04:41.233]                           invokeRestart("muffleWarning")
[16:04:41.233]                       }
[16:04:41.233]                       else if (inherits(cond, "condition")) {
[16:04:41.233]                         if (!is.null(pattern)) {
[16:04:41.233]                           computeRestarts <- base::computeRestarts
[16:04:41.233]                           grepl <- base::grepl
[16:04:41.233]                           restarts <- computeRestarts(cond)
[16:04:41.233]                           for (restart in restarts) {
[16:04:41.233]                             name <- restart$name
[16:04:41.233]                             if (is.null(name)) 
[16:04:41.233]                               next
[16:04:41.233]                             if (!grepl(pattern, name)) 
[16:04:41.233]                               next
[16:04:41.233]                             invokeRestart(restart)
[16:04:41.233]                             muffled <- TRUE
[16:04:41.233]                             break
[16:04:41.233]                           }
[16:04:41.233]                         }
[16:04:41.233]                       }
[16:04:41.233]                       invisible(muffled)
[16:04:41.233]                     }
[16:04:41.233]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.233]                   }
[16:04:41.233]                 }
[16:04:41.233]                 else {
[16:04:41.233]                   if (TRUE) {
[16:04:41.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.233]                     {
[16:04:41.233]                       inherits <- base::inherits
[16:04:41.233]                       invokeRestart <- base::invokeRestart
[16:04:41.233]                       is.null <- base::is.null
[16:04:41.233]                       muffled <- FALSE
[16:04:41.233]                       if (inherits(cond, "message")) {
[16:04:41.233]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.233]                         if (muffled) 
[16:04:41.233]                           invokeRestart("muffleMessage")
[16:04:41.233]                       }
[16:04:41.233]                       else if (inherits(cond, "warning")) {
[16:04:41.233]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.233]                         if (muffled) 
[16:04:41.233]                           invokeRestart("muffleWarning")
[16:04:41.233]                       }
[16:04:41.233]                       else if (inherits(cond, "condition")) {
[16:04:41.233]                         if (!is.null(pattern)) {
[16:04:41.233]                           computeRestarts <- base::computeRestarts
[16:04:41.233]                           grepl <- base::grepl
[16:04:41.233]                           restarts <- computeRestarts(cond)
[16:04:41.233]                           for (restart in restarts) {
[16:04:41.233]                             name <- restart$name
[16:04:41.233]                             if (is.null(name)) 
[16:04:41.233]                               next
[16:04:41.233]                             if (!grepl(pattern, name)) 
[16:04:41.233]                               next
[16:04:41.233]                             invokeRestart(restart)
[16:04:41.233]                             muffled <- TRUE
[16:04:41.233]                             break
[16:04:41.233]                           }
[16:04:41.233]                         }
[16:04:41.233]                       }
[16:04:41.233]                       invisible(muffled)
[16:04:41.233]                     }
[16:04:41.233]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.233]                   }
[16:04:41.233]                 }
[16:04:41.233]             }
[16:04:41.233]         }))
[16:04:41.233]     }, error = function(ex) {
[16:04:41.233]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.233]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.233]                 ...future.rng), started = ...future.startTime, 
[16:04:41.233]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.233]             version = "1.8"), class = "FutureResult")
[16:04:41.233]     }, finally = {
[16:04:41.233]         if (!identical(...future.workdir, getwd())) 
[16:04:41.233]             setwd(...future.workdir)
[16:04:41.233]         {
[16:04:41.233]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.233]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.233]             }
[16:04:41.233]             base::options(...future.oldOptions)
[16:04:41.233]             if (.Platform$OS.type == "windows") {
[16:04:41.233]                 old_names <- names(...future.oldEnvVars)
[16:04:41.233]                 envs <- base::Sys.getenv()
[16:04:41.233]                 names <- names(envs)
[16:04:41.233]                 common <- intersect(names, old_names)
[16:04:41.233]                 added <- setdiff(names, old_names)
[16:04:41.233]                 removed <- setdiff(old_names, names)
[16:04:41.233]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.233]                   envs[common]]
[16:04:41.233]                 NAMES <- toupper(changed)
[16:04:41.233]                 args <- list()
[16:04:41.233]                 for (kk in seq_along(NAMES)) {
[16:04:41.233]                   name <- changed[[kk]]
[16:04:41.233]                   NAME <- NAMES[[kk]]
[16:04:41.233]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.233]                     next
[16:04:41.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.233]                 }
[16:04:41.233]                 NAMES <- toupper(added)
[16:04:41.233]                 for (kk in seq_along(NAMES)) {
[16:04:41.233]                   name <- added[[kk]]
[16:04:41.233]                   NAME <- NAMES[[kk]]
[16:04:41.233]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.233]                     next
[16:04:41.233]                   args[[name]] <- ""
[16:04:41.233]                 }
[16:04:41.233]                 NAMES <- toupper(removed)
[16:04:41.233]                 for (kk in seq_along(NAMES)) {
[16:04:41.233]                   name <- removed[[kk]]
[16:04:41.233]                   NAME <- NAMES[[kk]]
[16:04:41.233]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.233]                     next
[16:04:41.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.233]                 }
[16:04:41.233]                 if (length(args) > 0) 
[16:04:41.233]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.233]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.233]             }
[16:04:41.233]             else {
[16:04:41.233]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.233]             }
[16:04:41.233]             {
[16:04:41.233]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.233]                   0L) {
[16:04:41.233]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.233]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.233]                   base::options(opts)
[16:04:41.233]                 }
[16:04:41.233]                 {
[16:04:41.233]                   {
[16:04:41.233]                     NULL
[16:04:41.233]                     RNGkind("Mersenne-Twister")
[16:04:41.233]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.233]                       inherits = FALSE)
[16:04:41.233]                   }
[16:04:41.233]                   options(future.plan = NULL)
[16:04:41.233]                   if (is.na(NA_character_)) 
[16:04:41.233]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.233]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.233]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.233]                   {
[16:04:41.233]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.233]                     if (!future$lazy) 
[16:04:41.233]                       future <- run(future)
[16:04:41.233]                     invisible(future)
[16:04:41.233]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.233]                 }
[16:04:41.233]             }
[16:04:41.233]         }
[16:04:41.233]     })
[16:04:41.233]     if (TRUE) {
[16:04:41.233]         base::sink(type = "output", split = FALSE)
[16:04:41.233]         if (TRUE) {
[16:04:41.233]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.233]         }
[16:04:41.233]         else {
[16:04:41.233]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.233]         }
[16:04:41.233]         base::close(...future.stdout)
[16:04:41.233]         ...future.stdout <- NULL
[16:04:41.233]     }
[16:04:41.233]     ...future.result$conditions <- ...future.conditions
[16:04:41.233]     ...future.result$finished <- base::Sys.time()
[16:04:41.233]     ...future.result
[16:04:41.233] }
[16:04:41.235] plan(): Setting new future strategy stack:
[16:04:41.235] List of future strategies:
[16:04:41.235] 1. sequential:
[16:04:41.235]    - args: function (..., envir = parent.frame())
[16:04:41.235]    - tweaked: FALSE
[16:04:41.235]    - call: NULL
[16:04:41.235] plan(): nbrOfWorkers() = 1
[16:04:41.236] plan(): Setting new future strategy stack:
[16:04:41.236] List of future strategies:
[16:04:41.236] 1. sequential:
[16:04:41.236]    - args: function (..., envir = parent.frame())
[16:04:41.236]    - tweaked: FALSE
[16:04:41.236]    - call: plan(strategy)
[16:04:41.236] plan(): nbrOfWorkers() = 1
[16:04:41.237] SequentialFuture started (and completed)
[16:04:41.237] - Launch lazy future ... done
[16:04:41.237] run() for ‘SequentialFuture’ ... done
[16:04:41.237] getGlobalsAndPackages() ...
[16:04:41.237] Searching for globals...
[16:04:41.237] 
[16:04:41.237] Searching for globals ... DONE
[16:04:41.237] - globals: [0] <none>
[16:04:41.237] getGlobalsAndPackages() ... DONE
[16:04:41.238] run() for ‘Future’ ...
[16:04:41.238] - state: ‘created’
[16:04:41.238] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.238] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.238] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.238]   - Field: ‘label’
[16:04:41.238]   - Field: ‘local’
[16:04:41.239]   - Field: ‘owner’
[16:04:41.240]   - Field: ‘envir’
[16:04:41.240]   - Field: ‘packages’
[16:04:41.240]   - Field: ‘gc’
[16:04:41.240]   - Field: ‘conditions’
[16:04:41.240]   - Field: ‘expr’
[16:04:41.240]   - Field: ‘uuid’
[16:04:41.240]   - Field: ‘seed’
[16:04:41.240]   - Field: ‘version’
[16:04:41.240]   - Field: ‘result’
[16:04:41.241]   - Field: ‘asynchronous’
[16:04:41.241]   - Field: ‘calls’
[16:04:41.241]   - Field: ‘globals’
[16:04:41.241]   - Field: ‘stdout’
[16:04:41.241]   - Field: ‘earlySignal’
[16:04:41.241]   - Field: ‘lazy’
[16:04:41.241]   - Field: ‘state’
[16:04:41.241] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.241] - Launch lazy future ...
[16:04:41.241] Packages needed by the future expression (n = 0): <none>
[16:04:41.241] Packages needed by future strategies (n = 0): <none>
[16:04:41.242] {
[16:04:41.242]     {
[16:04:41.242]         {
[16:04:41.242]             ...future.startTime <- base::Sys.time()
[16:04:41.242]             {
[16:04:41.242]                 {
[16:04:41.242]                   {
[16:04:41.242]                     base::local({
[16:04:41.242]                       has_future <- base::requireNamespace("future", 
[16:04:41.242]                         quietly = TRUE)
[16:04:41.242]                       if (has_future) {
[16:04:41.242]                         ns <- base::getNamespace("future")
[16:04:41.242]                         version <- ns[[".package"]][["version"]]
[16:04:41.242]                         if (is.null(version)) 
[16:04:41.242]                           version <- utils::packageVersion("future")
[16:04:41.242]                       }
[16:04:41.242]                       else {
[16:04:41.242]                         version <- NULL
[16:04:41.242]                       }
[16:04:41.242]                       if (!has_future || version < "1.8.0") {
[16:04:41.242]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.242]                           "", base::R.version$version.string), 
[16:04:41.242]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.242]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.242]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.242]                             "release", "version")], collapse = " "), 
[16:04:41.242]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.242]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.242]                           info)
[16:04:41.242]                         info <- base::paste(info, collapse = "; ")
[16:04:41.242]                         if (!has_future) {
[16:04:41.242]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.242]                             info)
[16:04:41.242]                         }
[16:04:41.242]                         else {
[16:04:41.242]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.242]                             info, version)
[16:04:41.242]                         }
[16:04:41.242]                         base::stop(msg)
[16:04:41.242]                       }
[16:04:41.242]                     })
[16:04:41.242]                   }
[16:04:41.242]                   options(future.plan = NULL)
[16:04:41.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.242]                 }
[16:04:41.242]                 ...future.workdir <- getwd()
[16:04:41.242]             }
[16:04:41.242]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.242]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.242]         }
[16:04:41.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.242]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.242]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.242]             base::names(...future.oldOptions))
[16:04:41.242]     }
[16:04:41.242]     if (FALSE) {
[16:04:41.242]     }
[16:04:41.242]     else {
[16:04:41.242]         if (TRUE) {
[16:04:41.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.242]                 open = "w")
[16:04:41.242]         }
[16:04:41.242]         else {
[16:04:41.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.242]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.242]         }
[16:04:41.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.242]             base::sink(type = "output", split = FALSE)
[16:04:41.242]             base::close(...future.stdout)
[16:04:41.242]         }, add = TRUE)
[16:04:41.242]     }
[16:04:41.242]     ...future.frame <- base::sys.nframe()
[16:04:41.242]     ...future.conditions <- base::list()
[16:04:41.242]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.242]     if (FALSE) {
[16:04:41.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.242]     }
[16:04:41.242]     ...future.result <- base::tryCatch({
[16:04:41.242]         base::withCallingHandlers({
[16:04:41.242]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:41.242]             future::FutureResult(value = ...future.value$value, 
[16:04:41.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.242]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.242]                     ...future.globalenv.names))
[16:04:41.242]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.242]         }, condition = base::local({
[16:04:41.242]             c <- base::c
[16:04:41.242]             inherits <- base::inherits
[16:04:41.242]             invokeRestart <- base::invokeRestart
[16:04:41.242]             length <- base::length
[16:04:41.242]             list <- base::list
[16:04:41.242]             seq.int <- base::seq.int
[16:04:41.242]             signalCondition <- base::signalCondition
[16:04:41.242]             sys.calls <- base::sys.calls
[16:04:41.242]             `[[` <- base::`[[`
[16:04:41.242]             `+` <- base::`+`
[16:04:41.242]             `<<-` <- base::`<<-`
[16:04:41.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.242]                   3L)]
[16:04:41.242]             }
[16:04:41.242]             function(cond) {
[16:04:41.242]                 is_error <- inherits(cond, "error")
[16:04:41.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.242]                   NULL)
[16:04:41.242]                 if (is_error) {
[16:04:41.242]                   sessionInformation <- function() {
[16:04:41.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.242]                       search = base::search(), system = base::Sys.info())
[16:04:41.242]                   }
[16:04:41.242]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.242]                     cond$call), session = sessionInformation(), 
[16:04:41.242]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.242]                   signalCondition(cond)
[16:04:41.242]                 }
[16:04:41.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.242]                 "immediateCondition"))) {
[16:04:41.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.242]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.242]                   if (TRUE && !signal) {
[16:04:41.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.242]                     {
[16:04:41.242]                       inherits <- base::inherits
[16:04:41.242]                       invokeRestart <- base::invokeRestart
[16:04:41.242]                       is.null <- base::is.null
[16:04:41.242]                       muffled <- FALSE
[16:04:41.242]                       if (inherits(cond, "message")) {
[16:04:41.242]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.242]                         if (muffled) 
[16:04:41.242]                           invokeRestart("muffleMessage")
[16:04:41.242]                       }
[16:04:41.242]                       else if (inherits(cond, "warning")) {
[16:04:41.242]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.242]                         if (muffled) 
[16:04:41.242]                           invokeRestart("muffleWarning")
[16:04:41.242]                       }
[16:04:41.242]                       else if (inherits(cond, "condition")) {
[16:04:41.242]                         if (!is.null(pattern)) {
[16:04:41.242]                           computeRestarts <- base::computeRestarts
[16:04:41.242]                           grepl <- base::grepl
[16:04:41.242]                           restarts <- computeRestarts(cond)
[16:04:41.242]                           for (restart in restarts) {
[16:04:41.242]                             name <- restart$name
[16:04:41.242]                             if (is.null(name)) 
[16:04:41.242]                               next
[16:04:41.242]                             if (!grepl(pattern, name)) 
[16:04:41.242]                               next
[16:04:41.242]                             invokeRestart(restart)
[16:04:41.242]                             muffled <- TRUE
[16:04:41.242]                             break
[16:04:41.242]                           }
[16:04:41.242]                         }
[16:04:41.242]                       }
[16:04:41.242]                       invisible(muffled)
[16:04:41.242]                     }
[16:04:41.242]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.242]                   }
[16:04:41.242]                 }
[16:04:41.242]                 else {
[16:04:41.242]                   if (TRUE) {
[16:04:41.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.242]                     {
[16:04:41.242]                       inherits <- base::inherits
[16:04:41.242]                       invokeRestart <- base::invokeRestart
[16:04:41.242]                       is.null <- base::is.null
[16:04:41.242]                       muffled <- FALSE
[16:04:41.242]                       if (inherits(cond, "message")) {
[16:04:41.242]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.242]                         if (muffled) 
[16:04:41.242]                           invokeRestart("muffleMessage")
[16:04:41.242]                       }
[16:04:41.242]                       else if (inherits(cond, "warning")) {
[16:04:41.242]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.242]                         if (muffled) 
[16:04:41.242]                           invokeRestart("muffleWarning")
[16:04:41.242]                       }
[16:04:41.242]                       else if (inherits(cond, "condition")) {
[16:04:41.242]                         if (!is.null(pattern)) {
[16:04:41.242]                           computeRestarts <- base::computeRestarts
[16:04:41.242]                           grepl <- base::grepl
[16:04:41.242]                           restarts <- computeRestarts(cond)
[16:04:41.242]                           for (restart in restarts) {
[16:04:41.242]                             name <- restart$name
[16:04:41.242]                             if (is.null(name)) 
[16:04:41.242]                               next
[16:04:41.242]                             if (!grepl(pattern, name)) 
[16:04:41.242]                               next
[16:04:41.242]                             invokeRestart(restart)
[16:04:41.242]                             muffled <- TRUE
[16:04:41.242]                             break
[16:04:41.242]                           }
[16:04:41.242]                         }
[16:04:41.242]                       }
[16:04:41.242]                       invisible(muffled)
[16:04:41.242]                     }
[16:04:41.242]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.242]                   }
[16:04:41.242]                 }
[16:04:41.242]             }
[16:04:41.242]         }))
[16:04:41.242]     }, error = function(ex) {
[16:04:41.242]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.242]                 ...future.rng), started = ...future.startTime, 
[16:04:41.242]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.242]             version = "1.8"), class = "FutureResult")
[16:04:41.242]     }, finally = {
[16:04:41.242]         if (!identical(...future.workdir, getwd())) 
[16:04:41.242]             setwd(...future.workdir)
[16:04:41.242]         {
[16:04:41.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.242]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.242]             }
[16:04:41.242]             base::options(...future.oldOptions)
[16:04:41.242]             if (.Platform$OS.type == "windows") {
[16:04:41.242]                 old_names <- names(...future.oldEnvVars)
[16:04:41.242]                 envs <- base::Sys.getenv()
[16:04:41.242]                 names <- names(envs)
[16:04:41.242]                 common <- intersect(names, old_names)
[16:04:41.242]                 added <- setdiff(names, old_names)
[16:04:41.242]                 removed <- setdiff(old_names, names)
[16:04:41.242]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.242]                   envs[common]]
[16:04:41.242]                 NAMES <- toupper(changed)
[16:04:41.242]                 args <- list()
[16:04:41.242]                 for (kk in seq_along(NAMES)) {
[16:04:41.242]                   name <- changed[[kk]]
[16:04:41.242]                   NAME <- NAMES[[kk]]
[16:04:41.242]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.242]                     next
[16:04:41.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.242]                 }
[16:04:41.242]                 NAMES <- toupper(added)
[16:04:41.242]                 for (kk in seq_along(NAMES)) {
[16:04:41.242]                   name <- added[[kk]]
[16:04:41.242]                   NAME <- NAMES[[kk]]
[16:04:41.242]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.242]                     next
[16:04:41.242]                   args[[name]] <- ""
[16:04:41.242]                 }
[16:04:41.242]                 NAMES <- toupper(removed)
[16:04:41.242]                 for (kk in seq_along(NAMES)) {
[16:04:41.242]                   name <- removed[[kk]]
[16:04:41.242]                   NAME <- NAMES[[kk]]
[16:04:41.242]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.242]                     next
[16:04:41.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.242]                 }
[16:04:41.242]                 if (length(args) > 0) 
[16:04:41.242]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.242]             }
[16:04:41.242]             else {
[16:04:41.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.242]             }
[16:04:41.242]             {
[16:04:41.242]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.242]                   0L) {
[16:04:41.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.242]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.242]                   base::options(opts)
[16:04:41.242]                 }
[16:04:41.242]                 {
[16:04:41.242]                   {
[16:04:41.242]                     NULL
[16:04:41.242]                     RNGkind("Mersenne-Twister")
[16:04:41.242]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.242]                       inherits = FALSE)
[16:04:41.242]                   }
[16:04:41.242]                   options(future.plan = NULL)
[16:04:41.242]                   if (is.na(NA_character_)) 
[16:04:41.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.242]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.242]                   {
[16:04:41.242]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.242]                     if (!future$lazy) 
[16:04:41.242]                       future <- run(future)
[16:04:41.242]                     invisible(future)
[16:04:41.242]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.242]                 }
[16:04:41.242]             }
[16:04:41.242]         }
[16:04:41.242]     })
[16:04:41.242]     if (TRUE) {
[16:04:41.242]         base::sink(type = "output", split = FALSE)
[16:04:41.242]         if (TRUE) {
[16:04:41.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.242]         }
[16:04:41.242]         else {
[16:04:41.242]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.242]         }
[16:04:41.242]         base::close(...future.stdout)
[16:04:41.242]         ...future.stdout <- NULL
[16:04:41.242]     }
[16:04:41.242]     ...future.result$conditions <- ...future.conditions
[16:04:41.242]     ...future.result$finished <- base::Sys.time()
[16:04:41.242]     ...future.result
[16:04:41.242] }
[16:04:41.244] plan(): Setting new future strategy stack:
[16:04:41.244] List of future strategies:
[16:04:41.244] 1. sequential:
[16:04:41.244]    - args: function (..., envir = parent.frame())
[16:04:41.244]    - tweaked: FALSE
[16:04:41.244]    - call: NULL
[16:04:41.244] plan(): nbrOfWorkers() = 1
[16:04:41.245] plan(): Setting new future strategy stack:
[16:04:41.245] List of future strategies:
[16:04:41.245] 1. sequential:
[16:04:41.245]    - args: function (..., envir = parent.frame())
[16:04:41.245]    - tweaked: FALSE
[16:04:41.245]    - call: plan(strategy)
[16:04:41.245] plan(): nbrOfWorkers() = 1
[16:04:41.245] SequentialFuture started (and completed)
[16:04:41.245] - Launch lazy future ... done
[16:04:41.245] run() for ‘SequentialFuture’ ... done
[16:04:41.246] getGlobalsAndPackages() ...
[16:04:41.246] Searching for globals...
[16:04:41.247] - globals found: [1] ‘{’
[16:04:41.247] Searching for globals ... DONE
[16:04:41.247] Resolving globals: FALSE
[16:04:41.247] 
[16:04:41.247] 
[16:04:41.247] getGlobalsAndPackages() ... DONE
[16:04:41.247] run() for ‘Future’ ...
[16:04:41.248] - state: ‘created’
[16:04:41.248] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.248] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.248] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.248]   - Field: ‘label’
[16:04:41.248]   - Field: ‘local’
[16:04:41.248]   - Field: ‘owner’
[16:04:41.248]   - Field: ‘envir’
[16:04:41.248]   - Field: ‘packages’
[16:04:41.249]   - Field: ‘gc’
[16:04:41.249]   - Field: ‘conditions’
[16:04:41.249]   - Field: ‘expr’
[16:04:41.249]   - Field: ‘uuid’
[16:04:41.249]   - Field: ‘seed’
[16:04:41.249]   - Field: ‘version’
[16:04:41.249]   - Field: ‘result’
[16:04:41.249]   - Field: ‘asynchronous’
[16:04:41.249]   - Field: ‘calls’
[16:04:41.249]   - Field: ‘globals’
[16:04:41.249]   - Field: ‘stdout’
[16:04:41.249]   - Field: ‘earlySignal’
[16:04:41.250]   - Field: ‘lazy’
[16:04:41.250]   - Field: ‘state’
[16:04:41.250] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.250] - Launch lazy future ...
[16:04:41.250] Packages needed by the future expression (n = 0): <none>
[16:04:41.250] Packages needed by future strategies (n = 0): <none>
[16:04:41.250] {
[16:04:41.250]     {
[16:04:41.250]         {
[16:04:41.250]             ...future.startTime <- base::Sys.time()
[16:04:41.250]             {
[16:04:41.250]                 {
[16:04:41.250]                   {
[16:04:41.250]                     base::local({
[16:04:41.250]                       has_future <- base::requireNamespace("future", 
[16:04:41.250]                         quietly = TRUE)
[16:04:41.250]                       if (has_future) {
[16:04:41.250]                         ns <- base::getNamespace("future")
[16:04:41.250]                         version <- ns[[".package"]][["version"]]
[16:04:41.250]                         if (is.null(version)) 
[16:04:41.250]                           version <- utils::packageVersion("future")
[16:04:41.250]                       }
[16:04:41.250]                       else {
[16:04:41.250]                         version <- NULL
[16:04:41.250]                       }
[16:04:41.250]                       if (!has_future || version < "1.8.0") {
[16:04:41.250]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.250]                           "", base::R.version$version.string), 
[16:04:41.250]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.250]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.250]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.250]                             "release", "version")], collapse = " "), 
[16:04:41.250]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.250]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.250]                           info)
[16:04:41.250]                         info <- base::paste(info, collapse = "; ")
[16:04:41.250]                         if (!has_future) {
[16:04:41.250]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.250]                             info)
[16:04:41.250]                         }
[16:04:41.250]                         else {
[16:04:41.250]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.250]                             info, version)
[16:04:41.250]                         }
[16:04:41.250]                         base::stop(msg)
[16:04:41.250]                       }
[16:04:41.250]                     })
[16:04:41.250]                   }
[16:04:41.250]                   options(future.plan = NULL)
[16:04:41.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.250]                 }
[16:04:41.250]                 ...future.workdir <- getwd()
[16:04:41.250]             }
[16:04:41.250]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.250]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.250]         }
[16:04:41.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.250]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.250]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.250]             base::names(...future.oldOptions))
[16:04:41.250]     }
[16:04:41.250]     if (FALSE) {
[16:04:41.250]     }
[16:04:41.250]     else {
[16:04:41.250]         if (TRUE) {
[16:04:41.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.250]                 open = "w")
[16:04:41.250]         }
[16:04:41.250]         else {
[16:04:41.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.250]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.250]         }
[16:04:41.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.250]             base::sink(type = "output", split = FALSE)
[16:04:41.250]             base::close(...future.stdout)
[16:04:41.250]         }, add = TRUE)
[16:04:41.250]     }
[16:04:41.250]     ...future.frame <- base::sys.nframe()
[16:04:41.250]     ...future.conditions <- base::list()
[16:04:41.250]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.250]     if (FALSE) {
[16:04:41.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.250]     }
[16:04:41.250]     ...future.result <- base::tryCatch({
[16:04:41.250]         base::withCallingHandlers({
[16:04:41.250]             ...future.value <- base::withVisible(base::local({
[16:04:41.250]                 4
[16:04:41.250]             }))
[16:04:41.250]             future::FutureResult(value = ...future.value$value, 
[16:04:41.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.250]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.250]                     ...future.globalenv.names))
[16:04:41.250]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.250]         }, condition = base::local({
[16:04:41.250]             c <- base::c
[16:04:41.250]             inherits <- base::inherits
[16:04:41.250]             invokeRestart <- base::invokeRestart
[16:04:41.250]             length <- base::length
[16:04:41.250]             list <- base::list
[16:04:41.250]             seq.int <- base::seq.int
[16:04:41.250]             signalCondition <- base::signalCondition
[16:04:41.250]             sys.calls <- base::sys.calls
[16:04:41.250]             `[[` <- base::`[[`
[16:04:41.250]             `+` <- base::`+`
[16:04:41.250]             `<<-` <- base::`<<-`
[16:04:41.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.250]                   3L)]
[16:04:41.250]             }
[16:04:41.250]             function(cond) {
[16:04:41.250]                 is_error <- inherits(cond, "error")
[16:04:41.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.250]                   NULL)
[16:04:41.250]                 if (is_error) {
[16:04:41.250]                   sessionInformation <- function() {
[16:04:41.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.250]                       search = base::search(), system = base::Sys.info())
[16:04:41.250]                   }
[16:04:41.250]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.250]                     cond$call), session = sessionInformation(), 
[16:04:41.250]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.250]                   signalCondition(cond)
[16:04:41.250]                 }
[16:04:41.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.250]                 "immediateCondition"))) {
[16:04:41.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.250]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.250]                   if (TRUE && !signal) {
[16:04:41.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.250]                     {
[16:04:41.250]                       inherits <- base::inherits
[16:04:41.250]                       invokeRestart <- base::invokeRestart
[16:04:41.250]                       is.null <- base::is.null
[16:04:41.250]                       muffled <- FALSE
[16:04:41.250]                       if (inherits(cond, "message")) {
[16:04:41.250]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.250]                         if (muffled) 
[16:04:41.250]                           invokeRestart("muffleMessage")
[16:04:41.250]                       }
[16:04:41.250]                       else if (inherits(cond, "warning")) {
[16:04:41.250]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.250]                         if (muffled) 
[16:04:41.250]                           invokeRestart("muffleWarning")
[16:04:41.250]                       }
[16:04:41.250]                       else if (inherits(cond, "condition")) {
[16:04:41.250]                         if (!is.null(pattern)) {
[16:04:41.250]                           computeRestarts <- base::computeRestarts
[16:04:41.250]                           grepl <- base::grepl
[16:04:41.250]                           restarts <- computeRestarts(cond)
[16:04:41.250]                           for (restart in restarts) {
[16:04:41.250]                             name <- restart$name
[16:04:41.250]                             if (is.null(name)) 
[16:04:41.250]                               next
[16:04:41.250]                             if (!grepl(pattern, name)) 
[16:04:41.250]                               next
[16:04:41.250]                             invokeRestart(restart)
[16:04:41.250]                             muffled <- TRUE
[16:04:41.250]                             break
[16:04:41.250]                           }
[16:04:41.250]                         }
[16:04:41.250]                       }
[16:04:41.250]                       invisible(muffled)
[16:04:41.250]                     }
[16:04:41.250]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.250]                   }
[16:04:41.250]                 }
[16:04:41.250]                 else {
[16:04:41.250]                   if (TRUE) {
[16:04:41.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.250]                     {
[16:04:41.250]                       inherits <- base::inherits
[16:04:41.250]                       invokeRestart <- base::invokeRestart
[16:04:41.250]                       is.null <- base::is.null
[16:04:41.250]                       muffled <- FALSE
[16:04:41.250]                       if (inherits(cond, "message")) {
[16:04:41.250]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.250]                         if (muffled) 
[16:04:41.250]                           invokeRestart("muffleMessage")
[16:04:41.250]                       }
[16:04:41.250]                       else if (inherits(cond, "warning")) {
[16:04:41.250]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.250]                         if (muffled) 
[16:04:41.250]                           invokeRestart("muffleWarning")
[16:04:41.250]                       }
[16:04:41.250]                       else if (inherits(cond, "condition")) {
[16:04:41.250]                         if (!is.null(pattern)) {
[16:04:41.250]                           computeRestarts <- base::computeRestarts
[16:04:41.250]                           grepl <- base::grepl
[16:04:41.250]                           restarts <- computeRestarts(cond)
[16:04:41.250]                           for (restart in restarts) {
[16:04:41.250]                             name <- restart$name
[16:04:41.250]                             if (is.null(name)) 
[16:04:41.250]                               next
[16:04:41.250]                             if (!grepl(pattern, name)) 
[16:04:41.250]                               next
[16:04:41.250]                             invokeRestart(restart)
[16:04:41.250]                             muffled <- TRUE
[16:04:41.250]                             break
[16:04:41.250]                           }
[16:04:41.250]                         }
[16:04:41.250]                       }
[16:04:41.250]                       invisible(muffled)
[16:04:41.250]                     }
[16:04:41.250]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.250]                   }
[16:04:41.250]                 }
[16:04:41.250]             }
[16:04:41.250]         }))
[16:04:41.250]     }, error = function(ex) {
[16:04:41.250]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.250]                 ...future.rng), started = ...future.startTime, 
[16:04:41.250]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.250]             version = "1.8"), class = "FutureResult")
[16:04:41.250]     }, finally = {
[16:04:41.250]         if (!identical(...future.workdir, getwd())) 
[16:04:41.250]             setwd(...future.workdir)
[16:04:41.250]         {
[16:04:41.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.250]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.250]             }
[16:04:41.250]             base::options(...future.oldOptions)
[16:04:41.250]             if (.Platform$OS.type == "windows") {
[16:04:41.250]                 old_names <- names(...future.oldEnvVars)
[16:04:41.250]                 envs <- base::Sys.getenv()
[16:04:41.250]                 names <- names(envs)
[16:04:41.250]                 common <- intersect(names, old_names)
[16:04:41.250]                 added <- setdiff(names, old_names)
[16:04:41.250]                 removed <- setdiff(old_names, names)
[16:04:41.250]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.250]                   envs[common]]
[16:04:41.250]                 NAMES <- toupper(changed)
[16:04:41.250]                 args <- list()
[16:04:41.250]                 for (kk in seq_along(NAMES)) {
[16:04:41.250]                   name <- changed[[kk]]
[16:04:41.250]                   NAME <- NAMES[[kk]]
[16:04:41.250]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.250]                     next
[16:04:41.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.250]                 }
[16:04:41.250]                 NAMES <- toupper(added)
[16:04:41.250]                 for (kk in seq_along(NAMES)) {
[16:04:41.250]                   name <- added[[kk]]
[16:04:41.250]                   NAME <- NAMES[[kk]]
[16:04:41.250]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.250]                     next
[16:04:41.250]                   args[[name]] <- ""
[16:04:41.250]                 }
[16:04:41.250]                 NAMES <- toupper(removed)
[16:04:41.250]                 for (kk in seq_along(NAMES)) {
[16:04:41.250]                   name <- removed[[kk]]
[16:04:41.250]                   NAME <- NAMES[[kk]]
[16:04:41.250]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.250]                     next
[16:04:41.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.250]                 }
[16:04:41.250]                 if (length(args) > 0) 
[16:04:41.250]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.250]             }
[16:04:41.250]             else {
[16:04:41.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.250]             }
[16:04:41.250]             {
[16:04:41.250]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.250]                   0L) {
[16:04:41.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.250]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.250]                   base::options(opts)
[16:04:41.250]                 }
[16:04:41.250]                 {
[16:04:41.250]                   {
[16:04:41.250]                     NULL
[16:04:41.250]                     RNGkind("Mersenne-Twister")
[16:04:41.250]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.250]                       inherits = FALSE)
[16:04:41.250]                   }
[16:04:41.250]                   options(future.plan = NULL)
[16:04:41.250]                   if (is.na(NA_character_)) 
[16:04:41.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.250]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.250]                   {
[16:04:41.250]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.250]                     if (!future$lazy) 
[16:04:41.250]                       future <- run(future)
[16:04:41.250]                     invisible(future)
[16:04:41.250]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.250]                 }
[16:04:41.250]             }
[16:04:41.250]         }
[16:04:41.250]     })
[16:04:41.250]     if (TRUE) {
[16:04:41.250]         base::sink(type = "output", split = FALSE)
[16:04:41.250]         if (TRUE) {
[16:04:41.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.250]         }
[16:04:41.250]         else {
[16:04:41.250]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.250]         }
[16:04:41.250]         base::close(...future.stdout)
[16:04:41.250]         ...future.stdout <- NULL
[16:04:41.250]     }
[16:04:41.250]     ...future.result$conditions <- ...future.conditions
[16:04:41.250]     ...future.result$finished <- base::Sys.time()
[16:04:41.250]     ...future.result
[16:04:41.250] }
[16:04:41.252] plan(): Setting new future strategy stack:
[16:04:41.252] List of future strategies:
[16:04:41.252] 1. sequential:
[16:04:41.252]    - args: function (..., envir = parent.frame())
[16:04:41.252]    - tweaked: FALSE
[16:04:41.252]    - call: NULL
[16:04:41.253] plan(): nbrOfWorkers() = 1
[16:04:41.253] plan(): Setting new future strategy stack:
[16:04:41.253] List of future strategies:
[16:04:41.253] 1. sequential:
[16:04:41.253]    - args: function (..., envir = parent.frame())
[16:04:41.253]    - tweaked: FALSE
[16:04:41.253]    - call: plan(strategy)
[16:04:41.254] plan(): nbrOfWorkers() = 1
[16:04:41.254] SequentialFuture started (and completed)
[16:04:41.254] - Launch lazy future ... done
[16:04:41.254] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55874dafda38> 
Classes 'listenv', 'environment' <environment: 0x55874da4d4d8> 
[16:04:41.257] resolved() for ‘SequentialFuture’ ...
[16:04:41.257] - state: ‘finished’
[16:04:41.257] - run: TRUE
[16:04:41.257] - result: ‘FutureResult’
[16:04:41.257] resolved() for ‘SequentialFuture’ ... done
[16:04:41.258] resolved() for ‘SequentialFuture’ ...
[16:04:41.258] - state: ‘finished’
[16:04:41.258] - run: TRUE
[16:04:41.258] - result: ‘FutureResult’
[16:04:41.258] resolved() for ‘SequentialFuture’ ... done
[16:04:41.258] resolved() for ‘SequentialFuture’ ...
[16:04:41.258] - state: ‘finished’
[16:04:41.258] - run: TRUE
[16:04:41.258] - result: ‘FutureResult’
[16:04:41.258] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:41.260] resolve() on list environment ...
[16:04:41.260]  recursive: 0
[16:04:41.261]  length: 6
[16:04:41.261]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:41.261] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.261] - nx: 6
[16:04:41.261] - relay: TRUE
[16:04:41.262] - stdout: TRUE
[16:04:41.262] - signal: TRUE
[16:04:41.262] - resignal: FALSE
[16:04:41.262] - force: TRUE
[16:04:41.262] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.262] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.262]  - until=2
[16:04:41.262]  - relaying element #2
[16:04:41.262] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.262] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.262] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.262]  length: 5 (resolved future 1)
[16:04:41.263] resolved() for ‘SequentialFuture’ ...
[16:04:41.263] - state: ‘finished’
[16:04:41.263] - run: TRUE
[16:04:41.263] - result: ‘FutureResult’
[16:04:41.263] resolved() for ‘SequentialFuture’ ... done
[16:04:41.263] Future #2
[16:04:41.263] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:41.263] - nx: 6
[16:04:41.263] - relay: TRUE
[16:04:41.263] - stdout: TRUE
[16:04:41.264] - signal: TRUE
[16:04:41.264] - resignal: FALSE
[16:04:41.264] - force: TRUE
[16:04:41.264] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.265] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.265]  - until=2
[16:04:41.265]  - relaying element #2
[16:04:41.265] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.265] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.266] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:41.266]  length: 4 (resolved future 2)
[16:04:41.266] resolved() for ‘SequentialFuture’ ...
[16:04:41.266] - state: ‘finished’
[16:04:41.266] - run: TRUE
[16:04:41.266] - result: ‘FutureResult’
[16:04:41.266] resolved() for ‘SequentialFuture’ ... done
[16:04:41.266] Future #3
[16:04:41.266] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:41.266] - nx: 6
[16:04:41.266] - relay: TRUE
[16:04:41.267] - stdout: TRUE
[16:04:41.267] - signal: TRUE
[16:04:41.267] - resignal: FALSE
[16:04:41.267] - force: TRUE
[16:04:41.267] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.267] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.267]  - until=3
[16:04:41.267]  - relaying element #3
[16:04:41.267] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.267] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.267] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:41.268]  length: 3 (resolved future 3)
[16:04:41.268] resolved() for ‘SequentialFuture’ ...
[16:04:41.268] - state: ‘finished’
[16:04:41.268] - run: TRUE
[16:04:41.268] - result: ‘FutureResult’
[16:04:41.268] resolved() for ‘SequentialFuture’ ... done
[16:04:41.268] Future #4
[16:04:41.268] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:04:41.268] - nx: 6
[16:04:41.268] - relay: TRUE
[16:04:41.269] - stdout: TRUE
[16:04:41.269] - signal: TRUE
[16:04:41.269] - resignal: FALSE
[16:04:41.269] - force: TRUE
[16:04:41.269] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.269] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.269]  - until=4
[16:04:41.269]  - relaying element #4
[16:04:41.269] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.269] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.269] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:04:41.270]  length: 2 (resolved future 4)
[16:04:41.270] signalConditionsASAP(NULL, pos=5) ...
[16:04:41.270] - nx: 6
[16:04:41.270] - relay: TRUE
[16:04:41.270] - stdout: TRUE
[16:04:41.270] - signal: TRUE
[16:04:41.270] - resignal: FALSE
[16:04:41.270] - force: TRUE
[16:04:41.270] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.270] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.270]  - until=6
[16:04:41.270]  - relaying element #6
[16:04:41.271] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.271] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.271] signalConditionsASAP(NULL, pos=5) ... done
[16:04:41.271]  length: 1 (resolved future 5)
[16:04:41.271] signalConditionsASAP(numeric, pos=6) ...
[16:04:41.271] - nx: 6
[16:04:41.271] - relay: TRUE
[16:04:41.271] - stdout: TRUE
[16:04:41.271] - signal: TRUE
[16:04:41.271] - resignal: FALSE
[16:04:41.271] - force: TRUE
[16:04:41.271] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.272] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.272]  - until=6
[16:04:41.272] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.272] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.272] signalConditionsASAP(numeric, pos=6) ... done
[16:04:41.272]  length: 0 (resolved future 6)
[16:04:41.272] Relaying remaining futures
[16:04:41.272] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.272] - nx: 6
[16:04:41.272] - relay: TRUE
[16:04:41.272] - stdout: TRUE
[16:04:41.272] - signal: TRUE
[16:04:41.273] - resignal: FALSE
[16:04:41.273] - force: TRUE
[16:04:41.273] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.273] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:41.273] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.273] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.273] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.273] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55874dd90168> 
Dimensions: c(1, 6)
[16:04:41.274] getGlobalsAndPackages() ...
[16:04:41.274] Searching for globals...
[16:04:41.274] 
[16:04:41.274] Searching for globals ... DONE
[16:04:41.274] - globals: [0] <none>
[16:04:41.274] getGlobalsAndPackages() ... DONE
[16:04:41.275] run() for ‘Future’ ...
[16:04:41.275] - state: ‘created’
[16:04:41.275] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.275] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.275] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.275]   - Field: ‘label’
[16:04:41.275]   - Field: ‘local’
[16:04:41.276]   - Field: ‘owner’
[16:04:41.276]   - Field: ‘envir’
[16:04:41.276]   - Field: ‘packages’
[16:04:41.276]   - Field: ‘gc’
[16:04:41.276]   - Field: ‘conditions’
[16:04:41.276]   - Field: ‘expr’
[16:04:41.276]   - Field: ‘uuid’
[16:04:41.276]   - Field: ‘seed’
[16:04:41.276]   - Field: ‘version’
[16:04:41.276]   - Field: ‘result’
[16:04:41.276]   - Field: ‘asynchronous’
[16:04:41.277]   - Field: ‘calls’
[16:04:41.277]   - Field: ‘globals’
[16:04:41.277]   - Field: ‘stdout’
[16:04:41.277]   - Field: ‘earlySignal’
[16:04:41.277]   - Field: ‘lazy’
[16:04:41.277]   - Field: ‘state’
[16:04:41.277] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.277] - Launch lazy future ...
[16:04:41.277] Packages needed by the future expression (n = 0): <none>
[16:04:41.277] Packages needed by future strategies (n = 0): <none>
[16:04:41.278] {
[16:04:41.278]     {
[16:04:41.278]         {
[16:04:41.278]             ...future.startTime <- base::Sys.time()
[16:04:41.278]             {
[16:04:41.278]                 {
[16:04:41.278]                   {
[16:04:41.278]                     base::local({
[16:04:41.278]                       has_future <- base::requireNamespace("future", 
[16:04:41.278]                         quietly = TRUE)
[16:04:41.278]                       if (has_future) {
[16:04:41.278]                         ns <- base::getNamespace("future")
[16:04:41.278]                         version <- ns[[".package"]][["version"]]
[16:04:41.278]                         if (is.null(version)) 
[16:04:41.278]                           version <- utils::packageVersion("future")
[16:04:41.278]                       }
[16:04:41.278]                       else {
[16:04:41.278]                         version <- NULL
[16:04:41.278]                       }
[16:04:41.278]                       if (!has_future || version < "1.8.0") {
[16:04:41.278]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.278]                           "", base::R.version$version.string), 
[16:04:41.278]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.278]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.278]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.278]                             "release", "version")], collapse = " "), 
[16:04:41.278]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.278]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.278]                           info)
[16:04:41.278]                         info <- base::paste(info, collapse = "; ")
[16:04:41.278]                         if (!has_future) {
[16:04:41.278]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.278]                             info)
[16:04:41.278]                         }
[16:04:41.278]                         else {
[16:04:41.278]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.278]                             info, version)
[16:04:41.278]                         }
[16:04:41.278]                         base::stop(msg)
[16:04:41.278]                       }
[16:04:41.278]                     })
[16:04:41.278]                   }
[16:04:41.278]                   options(future.plan = NULL)
[16:04:41.278]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.278]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.278]                 }
[16:04:41.278]                 ...future.workdir <- getwd()
[16:04:41.278]             }
[16:04:41.278]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.278]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.278]         }
[16:04:41.278]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.278]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.278]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.278]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.278]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.278]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.278]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.278]             base::names(...future.oldOptions))
[16:04:41.278]     }
[16:04:41.278]     if (FALSE) {
[16:04:41.278]     }
[16:04:41.278]     else {
[16:04:41.278]         if (TRUE) {
[16:04:41.278]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.278]                 open = "w")
[16:04:41.278]         }
[16:04:41.278]         else {
[16:04:41.278]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.278]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.278]         }
[16:04:41.278]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.278]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.278]             base::sink(type = "output", split = FALSE)
[16:04:41.278]             base::close(...future.stdout)
[16:04:41.278]         }, add = TRUE)
[16:04:41.278]     }
[16:04:41.278]     ...future.frame <- base::sys.nframe()
[16:04:41.278]     ...future.conditions <- base::list()
[16:04:41.278]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.278]     if (FALSE) {
[16:04:41.278]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.278]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.278]     }
[16:04:41.278]     ...future.result <- base::tryCatch({
[16:04:41.278]         base::withCallingHandlers({
[16:04:41.278]             ...future.value <- base::withVisible(base::local(2))
[16:04:41.278]             future::FutureResult(value = ...future.value$value, 
[16:04:41.278]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.278]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.278]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.278]                     ...future.globalenv.names))
[16:04:41.278]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.278]         }, condition = base::local({
[16:04:41.278]             c <- base::c
[16:04:41.278]             inherits <- base::inherits
[16:04:41.278]             invokeRestart <- base::invokeRestart
[16:04:41.278]             length <- base::length
[16:04:41.278]             list <- base::list
[16:04:41.278]             seq.int <- base::seq.int
[16:04:41.278]             signalCondition <- base::signalCondition
[16:04:41.278]             sys.calls <- base::sys.calls
[16:04:41.278]             `[[` <- base::`[[`
[16:04:41.278]             `+` <- base::`+`
[16:04:41.278]             `<<-` <- base::`<<-`
[16:04:41.278]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.278]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.278]                   3L)]
[16:04:41.278]             }
[16:04:41.278]             function(cond) {
[16:04:41.278]                 is_error <- inherits(cond, "error")
[16:04:41.278]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.278]                   NULL)
[16:04:41.278]                 if (is_error) {
[16:04:41.278]                   sessionInformation <- function() {
[16:04:41.278]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.278]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.278]                       search = base::search(), system = base::Sys.info())
[16:04:41.278]                   }
[16:04:41.278]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.278]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.278]                     cond$call), session = sessionInformation(), 
[16:04:41.278]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.278]                   signalCondition(cond)
[16:04:41.278]                 }
[16:04:41.278]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.278]                 "immediateCondition"))) {
[16:04:41.278]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.278]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.278]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.278]                   if (TRUE && !signal) {
[16:04:41.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.278]                     {
[16:04:41.278]                       inherits <- base::inherits
[16:04:41.278]                       invokeRestart <- base::invokeRestart
[16:04:41.278]                       is.null <- base::is.null
[16:04:41.278]                       muffled <- FALSE
[16:04:41.278]                       if (inherits(cond, "message")) {
[16:04:41.278]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.278]                         if (muffled) 
[16:04:41.278]                           invokeRestart("muffleMessage")
[16:04:41.278]                       }
[16:04:41.278]                       else if (inherits(cond, "warning")) {
[16:04:41.278]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.278]                         if (muffled) 
[16:04:41.278]                           invokeRestart("muffleWarning")
[16:04:41.278]                       }
[16:04:41.278]                       else if (inherits(cond, "condition")) {
[16:04:41.278]                         if (!is.null(pattern)) {
[16:04:41.278]                           computeRestarts <- base::computeRestarts
[16:04:41.278]                           grepl <- base::grepl
[16:04:41.278]                           restarts <- computeRestarts(cond)
[16:04:41.278]                           for (restart in restarts) {
[16:04:41.278]                             name <- restart$name
[16:04:41.278]                             if (is.null(name)) 
[16:04:41.278]                               next
[16:04:41.278]                             if (!grepl(pattern, name)) 
[16:04:41.278]                               next
[16:04:41.278]                             invokeRestart(restart)
[16:04:41.278]                             muffled <- TRUE
[16:04:41.278]                             break
[16:04:41.278]                           }
[16:04:41.278]                         }
[16:04:41.278]                       }
[16:04:41.278]                       invisible(muffled)
[16:04:41.278]                     }
[16:04:41.278]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.278]                   }
[16:04:41.278]                 }
[16:04:41.278]                 else {
[16:04:41.278]                   if (TRUE) {
[16:04:41.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.278]                     {
[16:04:41.278]                       inherits <- base::inherits
[16:04:41.278]                       invokeRestart <- base::invokeRestart
[16:04:41.278]                       is.null <- base::is.null
[16:04:41.278]                       muffled <- FALSE
[16:04:41.278]                       if (inherits(cond, "message")) {
[16:04:41.278]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.278]                         if (muffled) 
[16:04:41.278]                           invokeRestart("muffleMessage")
[16:04:41.278]                       }
[16:04:41.278]                       else if (inherits(cond, "warning")) {
[16:04:41.278]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.278]                         if (muffled) 
[16:04:41.278]                           invokeRestart("muffleWarning")
[16:04:41.278]                       }
[16:04:41.278]                       else if (inherits(cond, "condition")) {
[16:04:41.278]                         if (!is.null(pattern)) {
[16:04:41.278]                           computeRestarts <- base::computeRestarts
[16:04:41.278]                           grepl <- base::grepl
[16:04:41.278]                           restarts <- computeRestarts(cond)
[16:04:41.278]                           for (restart in restarts) {
[16:04:41.278]                             name <- restart$name
[16:04:41.278]                             if (is.null(name)) 
[16:04:41.278]                               next
[16:04:41.278]                             if (!grepl(pattern, name)) 
[16:04:41.278]                               next
[16:04:41.278]                             invokeRestart(restart)
[16:04:41.278]                             muffled <- TRUE
[16:04:41.278]                             break
[16:04:41.278]                           }
[16:04:41.278]                         }
[16:04:41.278]                       }
[16:04:41.278]                       invisible(muffled)
[16:04:41.278]                     }
[16:04:41.278]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.278]                   }
[16:04:41.278]                 }
[16:04:41.278]             }
[16:04:41.278]         }))
[16:04:41.278]     }, error = function(ex) {
[16:04:41.278]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.278]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.278]                 ...future.rng), started = ...future.startTime, 
[16:04:41.278]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.278]             version = "1.8"), class = "FutureResult")
[16:04:41.278]     }, finally = {
[16:04:41.278]         if (!identical(...future.workdir, getwd())) 
[16:04:41.278]             setwd(...future.workdir)
[16:04:41.278]         {
[16:04:41.278]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.278]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.278]             }
[16:04:41.278]             base::options(...future.oldOptions)
[16:04:41.278]             if (.Platform$OS.type == "windows") {
[16:04:41.278]                 old_names <- names(...future.oldEnvVars)
[16:04:41.278]                 envs <- base::Sys.getenv()
[16:04:41.278]                 names <- names(envs)
[16:04:41.278]                 common <- intersect(names, old_names)
[16:04:41.278]                 added <- setdiff(names, old_names)
[16:04:41.278]                 removed <- setdiff(old_names, names)
[16:04:41.278]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.278]                   envs[common]]
[16:04:41.278]                 NAMES <- toupper(changed)
[16:04:41.278]                 args <- list()
[16:04:41.278]                 for (kk in seq_along(NAMES)) {
[16:04:41.278]                   name <- changed[[kk]]
[16:04:41.278]                   NAME <- NAMES[[kk]]
[16:04:41.278]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.278]                     next
[16:04:41.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.278]                 }
[16:04:41.278]                 NAMES <- toupper(added)
[16:04:41.278]                 for (kk in seq_along(NAMES)) {
[16:04:41.278]                   name <- added[[kk]]
[16:04:41.278]                   NAME <- NAMES[[kk]]
[16:04:41.278]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.278]                     next
[16:04:41.278]                   args[[name]] <- ""
[16:04:41.278]                 }
[16:04:41.278]                 NAMES <- toupper(removed)
[16:04:41.278]                 for (kk in seq_along(NAMES)) {
[16:04:41.278]                   name <- removed[[kk]]
[16:04:41.278]                   NAME <- NAMES[[kk]]
[16:04:41.278]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.278]                     next
[16:04:41.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.278]                 }
[16:04:41.278]                 if (length(args) > 0) 
[16:04:41.278]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.278]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.278]             }
[16:04:41.278]             else {
[16:04:41.278]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.278]             }
[16:04:41.278]             {
[16:04:41.278]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.278]                   0L) {
[16:04:41.278]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.278]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.278]                   base::options(opts)
[16:04:41.278]                 }
[16:04:41.278]                 {
[16:04:41.278]                   {
[16:04:41.278]                     NULL
[16:04:41.278]                     RNGkind("Mersenne-Twister")
[16:04:41.278]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.278]                       inherits = FALSE)
[16:04:41.278]                   }
[16:04:41.278]                   options(future.plan = NULL)
[16:04:41.278]                   if (is.na(NA_character_)) 
[16:04:41.278]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.278]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.278]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.278]                   {
[16:04:41.278]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.278]                     if (!future$lazy) 
[16:04:41.278]                       future <- run(future)
[16:04:41.278]                     invisible(future)
[16:04:41.278]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.278]                 }
[16:04:41.278]             }
[16:04:41.278]         }
[16:04:41.278]     })
[16:04:41.278]     if (TRUE) {
[16:04:41.278]         base::sink(type = "output", split = FALSE)
[16:04:41.278]         if (TRUE) {
[16:04:41.278]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.278]         }
[16:04:41.278]         else {
[16:04:41.278]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.278]         }
[16:04:41.278]         base::close(...future.stdout)
[16:04:41.278]         ...future.stdout <- NULL
[16:04:41.278]     }
[16:04:41.278]     ...future.result$conditions <- ...future.conditions
[16:04:41.278]     ...future.result$finished <- base::Sys.time()
[16:04:41.278]     ...future.result
[16:04:41.278] }
[16:04:41.279] plan(): Setting new future strategy stack:
[16:04:41.280] List of future strategies:
[16:04:41.280] 1. sequential:
[16:04:41.280]    - args: function (..., envir = parent.frame())
[16:04:41.280]    - tweaked: FALSE
[16:04:41.280]    - call: NULL
[16:04:41.280] plan(): nbrOfWorkers() = 1
[16:04:41.281] plan(): Setting new future strategy stack:
[16:04:41.281] List of future strategies:
[16:04:41.281] 1. sequential:
[16:04:41.281]    - args: function (..., envir = parent.frame())
[16:04:41.281]    - tweaked: FALSE
[16:04:41.281]    - call: plan(strategy)
[16:04:41.281] plan(): nbrOfWorkers() = 1
[16:04:41.281] SequentialFuture started (and completed)
[16:04:41.281] - Launch lazy future ... done
[16:04:41.281] run() for ‘SequentialFuture’ ... done
[16:04:41.281] getGlobalsAndPackages() ...
[16:04:41.282] Searching for globals...
[16:04:41.282] 
[16:04:41.282] Searching for globals ... DONE
[16:04:41.282] - globals: [0] <none>
[16:04:41.282] getGlobalsAndPackages() ... DONE
[16:04:41.282] run() for ‘Future’ ...
[16:04:41.282] - state: ‘created’
[16:04:41.282] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.283] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.283] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.283]   - Field: ‘label’
[16:04:41.283]   - Field: ‘local’
[16:04:41.283]   - Field: ‘owner’
[16:04:41.283]   - Field: ‘envir’
[16:04:41.283]   - Field: ‘packages’
[16:04:41.283]   - Field: ‘gc’
[16:04:41.284]   - Field: ‘conditions’
[16:04:41.284]   - Field: ‘expr’
[16:04:41.284]   - Field: ‘uuid’
[16:04:41.284]   - Field: ‘seed’
[16:04:41.284]   - Field: ‘version’
[16:04:41.284]   - Field: ‘result’
[16:04:41.284]   - Field: ‘asynchronous’
[16:04:41.284]   - Field: ‘calls’
[16:04:41.284]   - Field: ‘globals’
[16:04:41.284]   - Field: ‘stdout’
[16:04:41.284]   - Field: ‘earlySignal’
[16:04:41.284]   - Field: ‘lazy’
[16:04:41.285]   - Field: ‘state’
[16:04:41.285] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.285] - Launch lazy future ...
[16:04:41.285] Packages needed by the future expression (n = 0): <none>
[16:04:41.285] Packages needed by future strategies (n = 0): <none>
[16:04:41.285] {
[16:04:41.285]     {
[16:04:41.285]         {
[16:04:41.285]             ...future.startTime <- base::Sys.time()
[16:04:41.285]             {
[16:04:41.285]                 {
[16:04:41.285]                   {
[16:04:41.285]                     base::local({
[16:04:41.285]                       has_future <- base::requireNamespace("future", 
[16:04:41.285]                         quietly = TRUE)
[16:04:41.285]                       if (has_future) {
[16:04:41.285]                         ns <- base::getNamespace("future")
[16:04:41.285]                         version <- ns[[".package"]][["version"]]
[16:04:41.285]                         if (is.null(version)) 
[16:04:41.285]                           version <- utils::packageVersion("future")
[16:04:41.285]                       }
[16:04:41.285]                       else {
[16:04:41.285]                         version <- NULL
[16:04:41.285]                       }
[16:04:41.285]                       if (!has_future || version < "1.8.0") {
[16:04:41.285]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.285]                           "", base::R.version$version.string), 
[16:04:41.285]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.285]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.285]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.285]                             "release", "version")], collapse = " "), 
[16:04:41.285]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.285]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.285]                           info)
[16:04:41.285]                         info <- base::paste(info, collapse = "; ")
[16:04:41.285]                         if (!has_future) {
[16:04:41.285]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.285]                             info)
[16:04:41.285]                         }
[16:04:41.285]                         else {
[16:04:41.285]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.285]                             info, version)
[16:04:41.285]                         }
[16:04:41.285]                         base::stop(msg)
[16:04:41.285]                       }
[16:04:41.285]                     })
[16:04:41.285]                   }
[16:04:41.285]                   options(future.plan = NULL)
[16:04:41.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.285]                 }
[16:04:41.285]                 ...future.workdir <- getwd()
[16:04:41.285]             }
[16:04:41.285]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.285]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.285]         }
[16:04:41.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.285]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.285]             base::names(...future.oldOptions))
[16:04:41.285]     }
[16:04:41.285]     if (FALSE) {
[16:04:41.285]     }
[16:04:41.285]     else {
[16:04:41.285]         if (TRUE) {
[16:04:41.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.285]                 open = "w")
[16:04:41.285]         }
[16:04:41.285]         else {
[16:04:41.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.285]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.285]         }
[16:04:41.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.285]             base::sink(type = "output", split = FALSE)
[16:04:41.285]             base::close(...future.stdout)
[16:04:41.285]         }, add = TRUE)
[16:04:41.285]     }
[16:04:41.285]     ...future.frame <- base::sys.nframe()
[16:04:41.285]     ...future.conditions <- base::list()
[16:04:41.285]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.285]     if (FALSE) {
[16:04:41.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.285]     }
[16:04:41.285]     ...future.result <- base::tryCatch({
[16:04:41.285]         base::withCallingHandlers({
[16:04:41.285]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:41.285]             future::FutureResult(value = ...future.value$value, 
[16:04:41.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.285]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.285]                     ...future.globalenv.names))
[16:04:41.285]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.285]         }, condition = base::local({
[16:04:41.285]             c <- base::c
[16:04:41.285]             inherits <- base::inherits
[16:04:41.285]             invokeRestart <- base::invokeRestart
[16:04:41.285]             length <- base::length
[16:04:41.285]             list <- base::list
[16:04:41.285]             seq.int <- base::seq.int
[16:04:41.285]             signalCondition <- base::signalCondition
[16:04:41.285]             sys.calls <- base::sys.calls
[16:04:41.285]             `[[` <- base::`[[`
[16:04:41.285]             `+` <- base::`+`
[16:04:41.285]             `<<-` <- base::`<<-`
[16:04:41.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.285]                   3L)]
[16:04:41.285]             }
[16:04:41.285]             function(cond) {
[16:04:41.285]                 is_error <- inherits(cond, "error")
[16:04:41.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.285]                   NULL)
[16:04:41.285]                 if (is_error) {
[16:04:41.285]                   sessionInformation <- function() {
[16:04:41.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.285]                       search = base::search(), system = base::Sys.info())
[16:04:41.285]                   }
[16:04:41.285]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.285]                     cond$call), session = sessionInformation(), 
[16:04:41.285]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.285]                   signalCondition(cond)
[16:04:41.285]                 }
[16:04:41.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.285]                 "immediateCondition"))) {
[16:04:41.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.285]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.285]                   if (TRUE && !signal) {
[16:04:41.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.285]                     {
[16:04:41.285]                       inherits <- base::inherits
[16:04:41.285]                       invokeRestart <- base::invokeRestart
[16:04:41.285]                       is.null <- base::is.null
[16:04:41.285]                       muffled <- FALSE
[16:04:41.285]                       if (inherits(cond, "message")) {
[16:04:41.285]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.285]                         if (muffled) 
[16:04:41.285]                           invokeRestart("muffleMessage")
[16:04:41.285]                       }
[16:04:41.285]                       else if (inherits(cond, "warning")) {
[16:04:41.285]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.285]                         if (muffled) 
[16:04:41.285]                           invokeRestart("muffleWarning")
[16:04:41.285]                       }
[16:04:41.285]                       else if (inherits(cond, "condition")) {
[16:04:41.285]                         if (!is.null(pattern)) {
[16:04:41.285]                           computeRestarts <- base::computeRestarts
[16:04:41.285]                           grepl <- base::grepl
[16:04:41.285]                           restarts <- computeRestarts(cond)
[16:04:41.285]                           for (restart in restarts) {
[16:04:41.285]                             name <- restart$name
[16:04:41.285]                             if (is.null(name)) 
[16:04:41.285]                               next
[16:04:41.285]                             if (!grepl(pattern, name)) 
[16:04:41.285]                               next
[16:04:41.285]                             invokeRestart(restart)
[16:04:41.285]                             muffled <- TRUE
[16:04:41.285]                             break
[16:04:41.285]                           }
[16:04:41.285]                         }
[16:04:41.285]                       }
[16:04:41.285]                       invisible(muffled)
[16:04:41.285]                     }
[16:04:41.285]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.285]                   }
[16:04:41.285]                 }
[16:04:41.285]                 else {
[16:04:41.285]                   if (TRUE) {
[16:04:41.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.285]                     {
[16:04:41.285]                       inherits <- base::inherits
[16:04:41.285]                       invokeRestart <- base::invokeRestart
[16:04:41.285]                       is.null <- base::is.null
[16:04:41.285]                       muffled <- FALSE
[16:04:41.285]                       if (inherits(cond, "message")) {
[16:04:41.285]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.285]                         if (muffled) 
[16:04:41.285]                           invokeRestart("muffleMessage")
[16:04:41.285]                       }
[16:04:41.285]                       else if (inherits(cond, "warning")) {
[16:04:41.285]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.285]                         if (muffled) 
[16:04:41.285]                           invokeRestart("muffleWarning")
[16:04:41.285]                       }
[16:04:41.285]                       else if (inherits(cond, "condition")) {
[16:04:41.285]                         if (!is.null(pattern)) {
[16:04:41.285]                           computeRestarts <- base::computeRestarts
[16:04:41.285]                           grepl <- base::grepl
[16:04:41.285]                           restarts <- computeRestarts(cond)
[16:04:41.285]                           for (restart in restarts) {
[16:04:41.285]                             name <- restart$name
[16:04:41.285]                             if (is.null(name)) 
[16:04:41.285]                               next
[16:04:41.285]                             if (!grepl(pattern, name)) 
[16:04:41.285]                               next
[16:04:41.285]                             invokeRestart(restart)
[16:04:41.285]                             muffled <- TRUE
[16:04:41.285]                             break
[16:04:41.285]                           }
[16:04:41.285]                         }
[16:04:41.285]                       }
[16:04:41.285]                       invisible(muffled)
[16:04:41.285]                     }
[16:04:41.285]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.285]                   }
[16:04:41.285]                 }
[16:04:41.285]             }
[16:04:41.285]         }))
[16:04:41.285]     }, error = function(ex) {
[16:04:41.285]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.285]                 ...future.rng), started = ...future.startTime, 
[16:04:41.285]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.285]             version = "1.8"), class = "FutureResult")
[16:04:41.285]     }, finally = {
[16:04:41.285]         if (!identical(...future.workdir, getwd())) 
[16:04:41.285]             setwd(...future.workdir)
[16:04:41.285]         {
[16:04:41.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.285]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.285]             }
[16:04:41.285]             base::options(...future.oldOptions)
[16:04:41.285]             if (.Platform$OS.type == "windows") {
[16:04:41.285]                 old_names <- names(...future.oldEnvVars)
[16:04:41.285]                 envs <- base::Sys.getenv()
[16:04:41.285]                 names <- names(envs)
[16:04:41.285]                 common <- intersect(names, old_names)
[16:04:41.285]                 added <- setdiff(names, old_names)
[16:04:41.285]                 removed <- setdiff(old_names, names)
[16:04:41.285]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.285]                   envs[common]]
[16:04:41.285]                 NAMES <- toupper(changed)
[16:04:41.285]                 args <- list()
[16:04:41.285]                 for (kk in seq_along(NAMES)) {
[16:04:41.285]                   name <- changed[[kk]]
[16:04:41.285]                   NAME <- NAMES[[kk]]
[16:04:41.285]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.285]                     next
[16:04:41.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.285]                 }
[16:04:41.285]                 NAMES <- toupper(added)
[16:04:41.285]                 for (kk in seq_along(NAMES)) {
[16:04:41.285]                   name <- added[[kk]]
[16:04:41.285]                   NAME <- NAMES[[kk]]
[16:04:41.285]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.285]                     next
[16:04:41.285]                   args[[name]] <- ""
[16:04:41.285]                 }
[16:04:41.285]                 NAMES <- toupper(removed)
[16:04:41.285]                 for (kk in seq_along(NAMES)) {
[16:04:41.285]                   name <- removed[[kk]]
[16:04:41.285]                   NAME <- NAMES[[kk]]
[16:04:41.285]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.285]                     next
[16:04:41.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.285]                 }
[16:04:41.285]                 if (length(args) > 0) 
[16:04:41.285]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.285]             }
[16:04:41.285]             else {
[16:04:41.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.285]             }
[16:04:41.285]             {
[16:04:41.285]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.285]                   0L) {
[16:04:41.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.285]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.285]                   base::options(opts)
[16:04:41.285]                 }
[16:04:41.285]                 {
[16:04:41.285]                   {
[16:04:41.285]                     NULL
[16:04:41.285]                     RNGkind("Mersenne-Twister")
[16:04:41.285]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.285]                       inherits = FALSE)
[16:04:41.285]                   }
[16:04:41.285]                   options(future.plan = NULL)
[16:04:41.285]                   if (is.na(NA_character_)) 
[16:04:41.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.285]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.285]                   {
[16:04:41.285]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.285]                     if (!future$lazy) 
[16:04:41.285]                       future <- run(future)
[16:04:41.285]                     invisible(future)
[16:04:41.285]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.285]                 }
[16:04:41.285]             }
[16:04:41.285]         }
[16:04:41.285]     })
[16:04:41.285]     if (TRUE) {
[16:04:41.285]         base::sink(type = "output", split = FALSE)
[16:04:41.285]         if (TRUE) {
[16:04:41.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.285]         }
[16:04:41.285]         else {
[16:04:41.285]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.285]         }
[16:04:41.285]         base::close(...future.stdout)
[16:04:41.285]         ...future.stdout <- NULL
[16:04:41.285]     }
[16:04:41.285]     ...future.result$conditions <- ...future.conditions
[16:04:41.285]     ...future.result$finished <- base::Sys.time()
[16:04:41.285]     ...future.result
[16:04:41.285] }
[16:04:41.287] plan(): Setting new future strategy stack:
[16:04:41.287] List of future strategies:
[16:04:41.287] 1. sequential:
[16:04:41.287]    - args: function (..., envir = parent.frame())
[16:04:41.287]    - tweaked: FALSE
[16:04:41.287]    - call: NULL
[16:04:41.288] plan(): nbrOfWorkers() = 1
[16:04:41.310] plan(): Setting new future strategy stack:
[16:04:41.310] List of future strategies:
[16:04:41.310] 1. sequential:
[16:04:41.310]    - args: function (..., envir = parent.frame())
[16:04:41.310]    - tweaked: FALSE
[16:04:41.310]    - call: plan(strategy)
[16:04:41.310] plan(): nbrOfWorkers() = 1
[16:04:41.311] SequentialFuture started (and completed)
[16:04:41.311] - Launch lazy future ... done
[16:04:41.311] run() for ‘SequentialFuture’ ... done
[16:04:41.311] getGlobalsAndPackages() ...
[16:04:41.311] Searching for globals...
[16:04:41.312] - globals found: [1] ‘{’
[16:04:41.312] Searching for globals ... DONE
[16:04:41.312] Resolving globals: FALSE
[16:04:41.312] 
[16:04:41.312] 
[16:04:41.312] getGlobalsAndPackages() ... DONE
[16:04:41.313] run() for ‘Future’ ...
[16:04:41.313] - state: ‘created’
[16:04:41.313] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.313] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.313] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.313]   - Field: ‘label’
[16:04:41.313]   - Field: ‘local’
[16:04:41.314]   - Field: ‘owner’
[16:04:41.314]   - Field: ‘envir’
[16:04:41.314]   - Field: ‘packages’
[16:04:41.314]   - Field: ‘gc’
[16:04:41.314]   - Field: ‘conditions’
[16:04:41.314]   - Field: ‘expr’
[16:04:41.314]   - Field: ‘uuid’
[16:04:41.314]   - Field: ‘seed’
[16:04:41.314]   - Field: ‘version’
[16:04:41.314]   - Field: ‘result’
[16:04:41.314]   - Field: ‘asynchronous’
[16:04:41.315]   - Field: ‘calls’
[16:04:41.315]   - Field: ‘globals’
[16:04:41.315]   - Field: ‘stdout’
[16:04:41.315]   - Field: ‘earlySignal’
[16:04:41.315]   - Field: ‘lazy’
[16:04:41.315]   - Field: ‘state’
[16:04:41.315] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.315] - Launch lazy future ...
[16:04:41.315] Packages needed by the future expression (n = 0): <none>
[16:04:41.315] Packages needed by future strategies (n = 0): <none>
[16:04:41.316] {
[16:04:41.316]     {
[16:04:41.316]         {
[16:04:41.316]             ...future.startTime <- base::Sys.time()
[16:04:41.316]             {
[16:04:41.316]                 {
[16:04:41.316]                   {
[16:04:41.316]                     base::local({
[16:04:41.316]                       has_future <- base::requireNamespace("future", 
[16:04:41.316]                         quietly = TRUE)
[16:04:41.316]                       if (has_future) {
[16:04:41.316]                         ns <- base::getNamespace("future")
[16:04:41.316]                         version <- ns[[".package"]][["version"]]
[16:04:41.316]                         if (is.null(version)) 
[16:04:41.316]                           version <- utils::packageVersion("future")
[16:04:41.316]                       }
[16:04:41.316]                       else {
[16:04:41.316]                         version <- NULL
[16:04:41.316]                       }
[16:04:41.316]                       if (!has_future || version < "1.8.0") {
[16:04:41.316]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.316]                           "", base::R.version$version.string), 
[16:04:41.316]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.316]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.316]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.316]                             "release", "version")], collapse = " "), 
[16:04:41.316]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.316]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.316]                           info)
[16:04:41.316]                         info <- base::paste(info, collapse = "; ")
[16:04:41.316]                         if (!has_future) {
[16:04:41.316]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.316]                             info)
[16:04:41.316]                         }
[16:04:41.316]                         else {
[16:04:41.316]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.316]                             info, version)
[16:04:41.316]                         }
[16:04:41.316]                         base::stop(msg)
[16:04:41.316]                       }
[16:04:41.316]                     })
[16:04:41.316]                   }
[16:04:41.316]                   options(future.plan = NULL)
[16:04:41.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.316]                 }
[16:04:41.316]                 ...future.workdir <- getwd()
[16:04:41.316]             }
[16:04:41.316]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.316]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.316]         }
[16:04:41.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.316]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.316]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.316]             base::names(...future.oldOptions))
[16:04:41.316]     }
[16:04:41.316]     if (FALSE) {
[16:04:41.316]     }
[16:04:41.316]     else {
[16:04:41.316]         if (TRUE) {
[16:04:41.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.316]                 open = "w")
[16:04:41.316]         }
[16:04:41.316]         else {
[16:04:41.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.316]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.316]         }
[16:04:41.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.316]             base::sink(type = "output", split = FALSE)
[16:04:41.316]             base::close(...future.stdout)
[16:04:41.316]         }, add = TRUE)
[16:04:41.316]     }
[16:04:41.316]     ...future.frame <- base::sys.nframe()
[16:04:41.316]     ...future.conditions <- base::list()
[16:04:41.316]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.316]     if (FALSE) {
[16:04:41.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.316]     }
[16:04:41.316]     ...future.result <- base::tryCatch({
[16:04:41.316]         base::withCallingHandlers({
[16:04:41.316]             ...future.value <- base::withVisible(base::local({
[16:04:41.316]                 4
[16:04:41.316]             }))
[16:04:41.316]             future::FutureResult(value = ...future.value$value, 
[16:04:41.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.316]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.316]                     ...future.globalenv.names))
[16:04:41.316]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.316]         }, condition = base::local({
[16:04:41.316]             c <- base::c
[16:04:41.316]             inherits <- base::inherits
[16:04:41.316]             invokeRestart <- base::invokeRestart
[16:04:41.316]             length <- base::length
[16:04:41.316]             list <- base::list
[16:04:41.316]             seq.int <- base::seq.int
[16:04:41.316]             signalCondition <- base::signalCondition
[16:04:41.316]             sys.calls <- base::sys.calls
[16:04:41.316]             `[[` <- base::`[[`
[16:04:41.316]             `+` <- base::`+`
[16:04:41.316]             `<<-` <- base::`<<-`
[16:04:41.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.316]                   3L)]
[16:04:41.316]             }
[16:04:41.316]             function(cond) {
[16:04:41.316]                 is_error <- inherits(cond, "error")
[16:04:41.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.316]                   NULL)
[16:04:41.316]                 if (is_error) {
[16:04:41.316]                   sessionInformation <- function() {
[16:04:41.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.316]                       search = base::search(), system = base::Sys.info())
[16:04:41.316]                   }
[16:04:41.316]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.316]                     cond$call), session = sessionInformation(), 
[16:04:41.316]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.316]                   signalCondition(cond)
[16:04:41.316]                 }
[16:04:41.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.316]                 "immediateCondition"))) {
[16:04:41.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.316]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.316]                   if (TRUE && !signal) {
[16:04:41.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.316]                     {
[16:04:41.316]                       inherits <- base::inherits
[16:04:41.316]                       invokeRestart <- base::invokeRestart
[16:04:41.316]                       is.null <- base::is.null
[16:04:41.316]                       muffled <- FALSE
[16:04:41.316]                       if (inherits(cond, "message")) {
[16:04:41.316]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.316]                         if (muffled) 
[16:04:41.316]                           invokeRestart("muffleMessage")
[16:04:41.316]                       }
[16:04:41.316]                       else if (inherits(cond, "warning")) {
[16:04:41.316]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.316]                         if (muffled) 
[16:04:41.316]                           invokeRestart("muffleWarning")
[16:04:41.316]                       }
[16:04:41.316]                       else if (inherits(cond, "condition")) {
[16:04:41.316]                         if (!is.null(pattern)) {
[16:04:41.316]                           computeRestarts <- base::computeRestarts
[16:04:41.316]                           grepl <- base::grepl
[16:04:41.316]                           restarts <- computeRestarts(cond)
[16:04:41.316]                           for (restart in restarts) {
[16:04:41.316]                             name <- restart$name
[16:04:41.316]                             if (is.null(name)) 
[16:04:41.316]                               next
[16:04:41.316]                             if (!grepl(pattern, name)) 
[16:04:41.316]                               next
[16:04:41.316]                             invokeRestart(restart)
[16:04:41.316]                             muffled <- TRUE
[16:04:41.316]                             break
[16:04:41.316]                           }
[16:04:41.316]                         }
[16:04:41.316]                       }
[16:04:41.316]                       invisible(muffled)
[16:04:41.316]                     }
[16:04:41.316]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.316]                   }
[16:04:41.316]                 }
[16:04:41.316]                 else {
[16:04:41.316]                   if (TRUE) {
[16:04:41.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.316]                     {
[16:04:41.316]                       inherits <- base::inherits
[16:04:41.316]                       invokeRestart <- base::invokeRestart
[16:04:41.316]                       is.null <- base::is.null
[16:04:41.316]                       muffled <- FALSE
[16:04:41.316]                       if (inherits(cond, "message")) {
[16:04:41.316]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.316]                         if (muffled) 
[16:04:41.316]                           invokeRestart("muffleMessage")
[16:04:41.316]                       }
[16:04:41.316]                       else if (inherits(cond, "warning")) {
[16:04:41.316]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.316]                         if (muffled) 
[16:04:41.316]                           invokeRestart("muffleWarning")
[16:04:41.316]                       }
[16:04:41.316]                       else if (inherits(cond, "condition")) {
[16:04:41.316]                         if (!is.null(pattern)) {
[16:04:41.316]                           computeRestarts <- base::computeRestarts
[16:04:41.316]                           grepl <- base::grepl
[16:04:41.316]                           restarts <- computeRestarts(cond)
[16:04:41.316]                           for (restart in restarts) {
[16:04:41.316]                             name <- restart$name
[16:04:41.316]                             if (is.null(name)) 
[16:04:41.316]                               next
[16:04:41.316]                             if (!grepl(pattern, name)) 
[16:04:41.316]                               next
[16:04:41.316]                             invokeRestart(restart)
[16:04:41.316]                             muffled <- TRUE
[16:04:41.316]                             break
[16:04:41.316]                           }
[16:04:41.316]                         }
[16:04:41.316]                       }
[16:04:41.316]                       invisible(muffled)
[16:04:41.316]                     }
[16:04:41.316]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.316]                   }
[16:04:41.316]                 }
[16:04:41.316]             }
[16:04:41.316]         }))
[16:04:41.316]     }, error = function(ex) {
[16:04:41.316]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.316]                 ...future.rng), started = ...future.startTime, 
[16:04:41.316]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.316]             version = "1.8"), class = "FutureResult")
[16:04:41.316]     }, finally = {
[16:04:41.316]         if (!identical(...future.workdir, getwd())) 
[16:04:41.316]             setwd(...future.workdir)
[16:04:41.316]         {
[16:04:41.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.316]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.316]             }
[16:04:41.316]             base::options(...future.oldOptions)
[16:04:41.316]             if (.Platform$OS.type == "windows") {
[16:04:41.316]                 old_names <- names(...future.oldEnvVars)
[16:04:41.316]                 envs <- base::Sys.getenv()
[16:04:41.316]                 names <- names(envs)
[16:04:41.316]                 common <- intersect(names, old_names)
[16:04:41.316]                 added <- setdiff(names, old_names)
[16:04:41.316]                 removed <- setdiff(old_names, names)
[16:04:41.316]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.316]                   envs[common]]
[16:04:41.316]                 NAMES <- toupper(changed)
[16:04:41.316]                 args <- list()
[16:04:41.316]                 for (kk in seq_along(NAMES)) {
[16:04:41.316]                   name <- changed[[kk]]
[16:04:41.316]                   NAME <- NAMES[[kk]]
[16:04:41.316]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.316]                     next
[16:04:41.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.316]                 }
[16:04:41.316]                 NAMES <- toupper(added)
[16:04:41.316]                 for (kk in seq_along(NAMES)) {
[16:04:41.316]                   name <- added[[kk]]
[16:04:41.316]                   NAME <- NAMES[[kk]]
[16:04:41.316]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.316]                     next
[16:04:41.316]                   args[[name]] <- ""
[16:04:41.316]                 }
[16:04:41.316]                 NAMES <- toupper(removed)
[16:04:41.316]                 for (kk in seq_along(NAMES)) {
[16:04:41.316]                   name <- removed[[kk]]
[16:04:41.316]                   NAME <- NAMES[[kk]]
[16:04:41.316]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.316]                     next
[16:04:41.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.316]                 }
[16:04:41.316]                 if (length(args) > 0) 
[16:04:41.316]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.316]             }
[16:04:41.316]             else {
[16:04:41.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.316]             }
[16:04:41.316]             {
[16:04:41.316]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.316]                   0L) {
[16:04:41.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.316]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.316]                   base::options(opts)
[16:04:41.316]                 }
[16:04:41.316]                 {
[16:04:41.316]                   {
[16:04:41.316]                     NULL
[16:04:41.316]                     RNGkind("Mersenne-Twister")
[16:04:41.316]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.316]                       inherits = FALSE)
[16:04:41.316]                   }
[16:04:41.316]                   options(future.plan = NULL)
[16:04:41.316]                   if (is.na(NA_character_)) 
[16:04:41.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.316]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.316]                   {
[16:04:41.316]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.316]                     if (!future$lazy) 
[16:04:41.316]                       future <- run(future)
[16:04:41.316]                     invisible(future)
[16:04:41.316]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.316]                 }
[16:04:41.316]             }
[16:04:41.316]         }
[16:04:41.316]     })
[16:04:41.316]     if (TRUE) {
[16:04:41.316]         base::sink(type = "output", split = FALSE)
[16:04:41.316]         if (TRUE) {
[16:04:41.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.316]         }
[16:04:41.316]         else {
[16:04:41.316]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.316]         }
[16:04:41.316]         base::close(...future.stdout)
[16:04:41.316]         ...future.stdout <- NULL
[16:04:41.316]     }
[16:04:41.316]     ...future.result$conditions <- ...future.conditions
[16:04:41.316]     ...future.result$finished <- base::Sys.time()
[16:04:41.316]     ...future.result
[16:04:41.316] }
[16:04:41.318] plan(): Setting new future strategy stack:
[16:04:41.318] List of future strategies:
[16:04:41.318] 1. sequential:
[16:04:41.318]    - args: function (..., envir = parent.frame())
[16:04:41.318]    - tweaked: FALSE
[16:04:41.318]    - call: NULL
[16:04:41.318] plan(): nbrOfWorkers() = 1
[16:04:41.319] plan(): Setting new future strategy stack:
[16:04:41.319] List of future strategies:
[16:04:41.319] 1. sequential:
[16:04:41.319]    - args: function (..., envir = parent.frame())
[16:04:41.319]    - tweaked: FALSE
[16:04:41.319]    - call: plan(strategy)
[16:04:41.319] plan(): nbrOfWorkers() = 1
[16:04:41.319] SequentialFuture started (and completed)
[16:04:41.319] - Launch lazy future ... done
[16:04:41.320] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55874d8919a0> 
Classes 'listenv', 'environment' <environment: 0x55874d5fe9d8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:04:41.323] resolved() for ‘SequentialFuture’ ...
[16:04:41.323] - state: ‘finished’
[16:04:41.323] - run: TRUE
[16:04:41.324] - result: ‘FutureResult’
[16:04:41.324] resolved() for ‘SequentialFuture’ ... done
[16:04:41.324] resolved() for ‘SequentialFuture’ ...
[16:04:41.324] - state: ‘finished’
[16:04:41.324] - run: TRUE
[16:04:41.324] - result: ‘FutureResult’
[16:04:41.324] resolved() for ‘SequentialFuture’ ... done
[16:04:41.324] resolved() for ‘SequentialFuture’ ...
[16:04:41.324] - state: ‘finished’
[16:04:41.324] - run: TRUE
[16:04:41.324] - result: ‘FutureResult’
[16:04:41.325] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:41.327] resolve() on list environment ...
[16:04:41.327]  recursive: 0
[16:04:41.328]  length: 6
[16:04:41.328]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:41.328] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.328] - nx: 6
[16:04:41.328] - relay: TRUE
[16:04:41.328] - stdout: TRUE
[16:04:41.328] - signal: TRUE
[16:04:41.328] - resignal: FALSE
[16:04:41.329] - force: TRUE
[16:04:41.329] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.329] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.329]  - until=2
[16:04:41.329]  - relaying element #2
[16:04:41.329] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.329] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.329] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.329]  length: 5 (resolved future 1)
[16:04:41.329] resolved() for ‘SequentialFuture’ ...
[16:04:41.329] - state: ‘finished’
[16:04:41.330] - run: TRUE
[16:04:41.330] - result: ‘FutureResult’
[16:04:41.330] resolved() for ‘SequentialFuture’ ... done
[16:04:41.330] Future #2
[16:04:41.330] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:41.330] - nx: 6
[16:04:41.330] - relay: TRUE
[16:04:41.330] - stdout: TRUE
[16:04:41.330] - signal: TRUE
[16:04:41.330] - resignal: FALSE
[16:04:41.330] - force: TRUE
[16:04:41.331] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.331] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.331]  - until=2
[16:04:41.331]  - relaying element #2
[16:04:41.331] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.331] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.331] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:41.331]  length: 4 (resolved future 2)
[16:04:41.331] resolved() for ‘SequentialFuture’ ...
[16:04:41.332] - state: ‘finished’
[16:04:41.332] - run: TRUE
[16:04:41.332] - result: ‘FutureResult’
[16:04:41.332] resolved() for ‘SequentialFuture’ ... done
[16:04:41.332] Future #3
[16:04:41.332] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:41.332] - nx: 6
[16:04:41.332] - relay: TRUE
[16:04:41.332] - stdout: TRUE
[16:04:41.332] - signal: TRUE
[16:04:41.332] - resignal: FALSE
[16:04:41.333] - force: TRUE
[16:04:41.333] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.333] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.333]  - until=3
[16:04:41.333]  - relaying element #3
[16:04:41.333] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.333] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.333] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:41.333]  length: 3 (resolved future 3)
[16:04:41.333] resolved() for ‘SequentialFuture’ ...
[16:04:41.334] - state: ‘finished’
[16:04:41.334] - run: TRUE
[16:04:41.334] - result: ‘FutureResult’
[16:04:41.334] resolved() for ‘SequentialFuture’ ... done
[16:04:41.334] Future #4
[16:04:41.334] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:04:41.334] - nx: 6
[16:04:41.334] - relay: TRUE
[16:04:41.334] - stdout: TRUE
[16:04:41.334] - signal: TRUE
[16:04:41.334] - resignal: FALSE
[16:04:41.335] - force: TRUE
[16:04:41.335] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.335] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.335]  - until=4
[16:04:41.336]  - relaying element #4
[16:04:41.336] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.336] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.337] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:04:41.337]  length: 2 (resolved future 4)
[16:04:41.337] signalConditionsASAP(NULL, pos=5) ...
[16:04:41.337] - nx: 6
[16:04:41.337] - relay: TRUE
[16:04:41.337] - stdout: TRUE
[16:04:41.337] - signal: TRUE
[16:04:41.337] - resignal: FALSE
[16:04:41.337] - force: TRUE
[16:04:41.337] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.337] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.338]  - until=6
[16:04:41.338]  - relaying element #6
[16:04:41.338] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.338] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.338] signalConditionsASAP(NULL, pos=5) ... done
[16:04:41.338]  length: 1 (resolved future 5)
[16:04:41.338] signalConditionsASAP(numeric, pos=6) ...
[16:04:41.338] - nx: 6
[16:04:41.338] - relay: TRUE
[16:04:41.338] - stdout: TRUE
[16:04:41.338] - signal: TRUE
[16:04:41.339] - resignal: FALSE
[16:04:41.339] - force: TRUE
[16:04:41.339] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.339] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.339]  - until=6
[16:04:41.339] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.339] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.339] signalConditionsASAP(numeric, pos=6) ... done
[16:04:41.339]  length: 0 (resolved future 6)
[16:04:41.339] Relaying remaining futures
[16:04:41.339] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.340] - nx: 6
[16:04:41.340] - relay: TRUE
[16:04:41.340] - stdout: TRUE
[16:04:41.340] - signal: TRUE
[16:04:41.340] - resignal: FALSE
[16:04:41.340] - force: TRUE
[16:04:41.340] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.340] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:41.340] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.340] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.341] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.341] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55874db2cb40> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:04:41.342] getGlobalsAndPackages() ...
[16:04:41.343] Searching for globals...
[16:04:41.343] 
[16:04:41.343] Searching for globals ... DONE
[16:04:41.343] - globals: [0] <none>
[16:04:41.343] getGlobalsAndPackages() ... DONE
[16:04:41.343] run() for ‘Future’ ...
[16:04:41.344] - state: ‘created’
[16:04:41.344] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.344] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.344] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.344]   - Field: ‘label’
[16:04:41.344]   - Field: ‘local’
[16:04:41.344]   - Field: ‘owner’
[16:04:41.344]   - Field: ‘envir’
[16:04:41.345]   - Field: ‘packages’
[16:04:41.345]   - Field: ‘gc’
[16:04:41.345]   - Field: ‘conditions’
[16:04:41.345]   - Field: ‘expr’
[16:04:41.345]   - Field: ‘uuid’
[16:04:41.345]   - Field: ‘seed’
[16:04:41.345]   - Field: ‘version’
[16:04:41.345]   - Field: ‘result’
[16:04:41.345]   - Field: ‘asynchronous’
[16:04:41.345]   - Field: ‘calls’
[16:04:41.345]   - Field: ‘globals’
[16:04:41.346]   - Field: ‘stdout’
[16:04:41.346]   - Field: ‘earlySignal’
[16:04:41.346]   - Field: ‘lazy’
[16:04:41.346]   - Field: ‘state’
[16:04:41.346] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.346] - Launch lazy future ...
[16:04:41.346] Packages needed by the future expression (n = 0): <none>
[16:04:41.346] Packages needed by future strategies (n = 0): <none>
[16:04:41.347] {
[16:04:41.347]     {
[16:04:41.347]         {
[16:04:41.347]             ...future.startTime <- base::Sys.time()
[16:04:41.347]             {
[16:04:41.347]                 {
[16:04:41.347]                   {
[16:04:41.347]                     base::local({
[16:04:41.347]                       has_future <- base::requireNamespace("future", 
[16:04:41.347]                         quietly = TRUE)
[16:04:41.347]                       if (has_future) {
[16:04:41.347]                         ns <- base::getNamespace("future")
[16:04:41.347]                         version <- ns[[".package"]][["version"]]
[16:04:41.347]                         if (is.null(version)) 
[16:04:41.347]                           version <- utils::packageVersion("future")
[16:04:41.347]                       }
[16:04:41.347]                       else {
[16:04:41.347]                         version <- NULL
[16:04:41.347]                       }
[16:04:41.347]                       if (!has_future || version < "1.8.0") {
[16:04:41.347]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.347]                           "", base::R.version$version.string), 
[16:04:41.347]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.347]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.347]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.347]                             "release", "version")], collapse = " "), 
[16:04:41.347]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.347]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.347]                           info)
[16:04:41.347]                         info <- base::paste(info, collapse = "; ")
[16:04:41.347]                         if (!has_future) {
[16:04:41.347]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.347]                             info)
[16:04:41.347]                         }
[16:04:41.347]                         else {
[16:04:41.347]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.347]                             info, version)
[16:04:41.347]                         }
[16:04:41.347]                         base::stop(msg)
[16:04:41.347]                       }
[16:04:41.347]                     })
[16:04:41.347]                   }
[16:04:41.347]                   options(future.plan = NULL)
[16:04:41.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.347]                 }
[16:04:41.347]                 ...future.workdir <- getwd()
[16:04:41.347]             }
[16:04:41.347]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.347]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.347]         }
[16:04:41.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.347]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.347]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.347]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.347]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.347]             base::names(...future.oldOptions))
[16:04:41.347]     }
[16:04:41.347]     if (FALSE) {
[16:04:41.347]     }
[16:04:41.347]     else {
[16:04:41.347]         if (TRUE) {
[16:04:41.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.347]                 open = "w")
[16:04:41.347]         }
[16:04:41.347]         else {
[16:04:41.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.347]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.347]         }
[16:04:41.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.347]             base::sink(type = "output", split = FALSE)
[16:04:41.347]             base::close(...future.stdout)
[16:04:41.347]         }, add = TRUE)
[16:04:41.347]     }
[16:04:41.347]     ...future.frame <- base::sys.nframe()
[16:04:41.347]     ...future.conditions <- base::list()
[16:04:41.347]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.347]     if (FALSE) {
[16:04:41.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.347]     }
[16:04:41.347]     ...future.result <- base::tryCatch({
[16:04:41.347]         base::withCallingHandlers({
[16:04:41.347]             ...future.value <- base::withVisible(base::local(2))
[16:04:41.347]             future::FutureResult(value = ...future.value$value, 
[16:04:41.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.347]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.347]                     ...future.globalenv.names))
[16:04:41.347]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.347]         }, condition = base::local({
[16:04:41.347]             c <- base::c
[16:04:41.347]             inherits <- base::inherits
[16:04:41.347]             invokeRestart <- base::invokeRestart
[16:04:41.347]             length <- base::length
[16:04:41.347]             list <- base::list
[16:04:41.347]             seq.int <- base::seq.int
[16:04:41.347]             signalCondition <- base::signalCondition
[16:04:41.347]             sys.calls <- base::sys.calls
[16:04:41.347]             `[[` <- base::`[[`
[16:04:41.347]             `+` <- base::`+`
[16:04:41.347]             `<<-` <- base::`<<-`
[16:04:41.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.347]                   3L)]
[16:04:41.347]             }
[16:04:41.347]             function(cond) {
[16:04:41.347]                 is_error <- inherits(cond, "error")
[16:04:41.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.347]                   NULL)
[16:04:41.347]                 if (is_error) {
[16:04:41.347]                   sessionInformation <- function() {
[16:04:41.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.347]                       search = base::search(), system = base::Sys.info())
[16:04:41.347]                   }
[16:04:41.347]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.347]                     cond$call), session = sessionInformation(), 
[16:04:41.347]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.347]                   signalCondition(cond)
[16:04:41.347]                 }
[16:04:41.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.347]                 "immediateCondition"))) {
[16:04:41.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.347]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.347]                   if (TRUE && !signal) {
[16:04:41.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.347]                     {
[16:04:41.347]                       inherits <- base::inherits
[16:04:41.347]                       invokeRestart <- base::invokeRestart
[16:04:41.347]                       is.null <- base::is.null
[16:04:41.347]                       muffled <- FALSE
[16:04:41.347]                       if (inherits(cond, "message")) {
[16:04:41.347]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.347]                         if (muffled) 
[16:04:41.347]                           invokeRestart("muffleMessage")
[16:04:41.347]                       }
[16:04:41.347]                       else if (inherits(cond, "warning")) {
[16:04:41.347]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.347]                         if (muffled) 
[16:04:41.347]                           invokeRestart("muffleWarning")
[16:04:41.347]                       }
[16:04:41.347]                       else if (inherits(cond, "condition")) {
[16:04:41.347]                         if (!is.null(pattern)) {
[16:04:41.347]                           computeRestarts <- base::computeRestarts
[16:04:41.347]                           grepl <- base::grepl
[16:04:41.347]                           restarts <- computeRestarts(cond)
[16:04:41.347]                           for (restart in restarts) {
[16:04:41.347]                             name <- restart$name
[16:04:41.347]                             if (is.null(name)) 
[16:04:41.347]                               next
[16:04:41.347]                             if (!grepl(pattern, name)) 
[16:04:41.347]                               next
[16:04:41.347]                             invokeRestart(restart)
[16:04:41.347]                             muffled <- TRUE
[16:04:41.347]                             break
[16:04:41.347]                           }
[16:04:41.347]                         }
[16:04:41.347]                       }
[16:04:41.347]                       invisible(muffled)
[16:04:41.347]                     }
[16:04:41.347]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.347]                   }
[16:04:41.347]                 }
[16:04:41.347]                 else {
[16:04:41.347]                   if (TRUE) {
[16:04:41.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.347]                     {
[16:04:41.347]                       inherits <- base::inherits
[16:04:41.347]                       invokeRestart <- base::invokeRestart
[16:04:41.347]                       is.null <- base::is.null
[16:04:41.347]                       muffled <- FALSE
[16:04:41.347]                       if (inherits(cond, "message")) {
[16:04:41.347]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.347]                         if (muffled) 
[16:04:41.347]                           invokeRestart("muffleMessage")
[16:04:41.347]                       }
[16:04:41.347]                       else if (inherits(cond, "warning")) {
[16:04:41.347]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.347]                         if (muffled) 
[16:04:41.347]                           invokeRestart("muffleWarning")
[16:04:41.347]                       }
[16:04:41.347]                       else if (inherits(cond, "condition")) {
[16:04:41.347]                         if (!is.null(pattern)) {
[16:04:41.347]                           computeRestarts <- base::computeRestarts
[16:04:41.347]                           grepl <- base::grepl
[16:04:41.347]                           restarts <- computeRestarts(cond)
[16:04:41.347]                           for (restart in restarts) {
[16:04:41.347]                             name <- restart$name
[16:04:41.347]                             if (is.null(name)) 
[16:04:41.347]                               next
[16:04:41.347]                             if (!grepl(pattern, name)) 
[16:04:41.347]                               next
[16:04:41.347]                             invokeRestart(restart)
[16:04:41.347]                             muffled <- TRUE
[16:04:41.347]                             break
[16:04:41.347]                           }
[16:04:41.347]                         }
[16:04:41.347]                       }
[16:04:41.347]                       invisible(muffled)
[16:04:41.347]                     }
[16:04:41.347]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.347]                   }
[16:04:41.347]                 }
[16:04:41.347]             }
[16:04:41.347]         }))
[16:04:41.347]     }, error = function(ex) {
[16:04:41.347]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.347]                 ...future.rng), started = ...future.startTime, 
[16:04:41.347]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.347]             version = "1.8"), class = "FutureResult")
[16:04:41.347]     }, finally = {
[16:04:41.347]         if (!identical(...future.workdir, getwd())) 
[16:04:41.347]             setwd(...future.workdir)
[16:04:41.347]         {
[16:04:41.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.347]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.347]             }
[16:04:41.347]             base::options(...future.oldOptions)
[16:04:41.347]             if (.Platform$OS.type == "windows") {
[16:04:41.347]                 old_names <- names(...future.oldEnvVars)
[16:04:41.347]                 envs <- base::Sys.getenv()
[16:04:41.347]                 names <- names(envs)
[16:04:41.347]                 common <- intersect(names, old_names)
[16:04:41.347]                 added <- setdiff(names, old_names)
[16:04:41.347]                 removed <- setdiff(old_names, names)
[16:04:41.347]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.347]                   envs[common]]
[16:04:41.347]                 NAMES <- toupper(changed)
[16:04:41.347]                 args <- list()
[16:04:41.347]                 for (kk in seq_along(NAMES)) {
[16:04:41.347]                   name <- changed[[kk]]
[16:04:41.347]                   NAME <- NAMES[[kk]]
[16:04:41.347]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.347]                     next
[16:04:41.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.347]                 }
[16:04:41.347]                 NAMES <- toupper(added)
[16:04:41.347]                 for (kk in seq_along(NAMES)) {
[16:04:41.347]                   name <- added[[kk]]
[16:04:41.347]                   NAME <- NAMES[[kk]]
[16:04:41.347]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.347]                     next
[16:04:41.347]                   args[[name]] <- ""
[16:04:41.347]                 }
[16:04:41.347]                 NAMES <- toupper(removed)
[16:04:41.347]                 for (kk in seq_along(NAMES)) {
[16:04:41.347]                   name <- removed[[kk]]
[16:04:41.347]                   NAME <- NAMES[[kk]]
[16:04:41.347]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.347]                     next
[16:04:41.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.347]                 }
[16:04:41.347]                 if (length(args) > 0) 
[16:04:41.347]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.347]             }
[16:04:41.347]             else {
[16:04:41.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.347]             }
[16:04:41.347]             {
[16:04:41.347]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.347]                   0L) {
[16:04:41.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.347]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.347]                   base::options(opts)
[16:04:41.347]                 }
[16:04:41.347]                 {
[16:04:41.347]                   {
[16:04:41.347]                     NULL
[16:04:41.347]                     RNGkind("Mersenne-Twister")
[16:04:41.347]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.347]                       inherits = FALSE)
[16:04:41.347]                   }
[16:04:41.347]                   options(future.plan = NULL)
[16:04:41.347]                   if (is.na(NA_character_)) 
[16:04:41.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.347]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.347]                   {
[16:04:41.347]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.347]                     if (!future$lazy) 
[16:04:41.347]                       future <- run(future)
[16:04:41.347]                     invisible(future)
[16:04:41.347]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.347]                 }
[16:04:41.347]             }
[16:04:41.347]         }
[16:04:41.347]     })
[16:04:41.347]     if (TRUE) {
[16:04:41.347]         base::sink(type = "output", split = FALSE)
[16:04:41.347]         if (TRUE) {
[16:04:41.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.347]         }
[16:04:41.347]         else {
[16:04:41.347]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.347]         }
[16:04:41.347]         base::close(...future.stdout)
[16:04:41.347]         ...future.stdout <- NULL
[16:04:41.347]     }
[16:04:41.347]     ...future.result$conditions <- ...future.conditions
[16:04:41.347]     ...future.result$finished <- base::Sys.time()
[16:04:41.347]     ...future.result
[16:04:41.347] }
[16:04:41.348] plan(): Setting new future strategy stack:
[16:04:41.349] List of future strategies:
[16:04:41.349] 1. sequential:
[16:04:41.349]    - args: function (..., envir = parent.frame())
[16:04:41.349]    - tweaked: FALSE
[16:04:41.349]    - call: NULL
[16:04:41.349] plan(): nbrOfWorkers() = 1
[16:04:41.350] plan(): Setting new future strategy stack:
[16:04:41.350] List of future strategies:
[16:04:41.350] 1. sequential:
[16:04:41.350]    - args: function (..., envir = parent.frame())
[16:04:41.350]    - tweaked: FALSE
[16:04:41.350]    - call: plan(strategy)
[16:04:41.350] plan(): nbrOfWorkers() = 1
[16:04:41.350] SequentialFuture started (and completed)
[16:04:41.350] - Launch lazy future ... done
[16:04:41.350] run() for ‘SequentialFuture’ ... done
[16:04:41.351] getGlobalsAndPackages() ...
[16:04:41.351] Searching for globals...
[16:04:41.351] 
[16:04:41.351] Searching for globals ... DONE
[16:04:41.351] - globals: [0] <none>
[16:04:41.351] getGlobalsAndPackages() ... DONE
[16:04:41.351] run() for ‘Future’ ...
[16:04:41.351] - state: ‘created’
[16:04:41.352] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.352] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.352] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.352]   - Field: ‘label’
[16:04:41.352]   - Field: ‘local’
[16:04:41.352]   - Field: ‘owner’
[16:04:41.352]   - Field: ‘envir’
[16:04:41.352]   - Field: ‘packages’
[16:04:41.353]   - Field: ‘gc’
[16:04:41.353]   - Field: ‘conditions’
[16:04:41.353]   - Field: ‘expr’
[16:04:41.353]   - Field: ‘uuid’
[16:04:41.353]   - Field: ‘seed’
[16:04:41.353]   - Field: ‘version’
[16:04:41.353]   - Field: ‘result’
[16:04:41.353]   - Field: ‘asynchronous’
[16:04:41.353]   - Field: ‘calls’
[16:04:41.353]   - Field: ‘globals’
[16:04:41.353]   - Field: ‘stdout’
[16:04:41.354]   - Field: ‘earlySignal’
[16:04:41.354]   - Field: ‘lazy’
[16:04:41.354]   - Field: ‘state’
[16:04:41.354] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.354] - Launch lazy future ...
[16:04:41.354] Packages needed by the future expression (n = 0): <none>
[16:04:41.354] Packages needed by future strategies (n = 0): <none>
[16:04:41.355] {
[16:04:41.355]     {
[16:04:41.355]         {
[16:04:41.355]             ...future.startTime <- base::Sys.time()
[16:04:41.355]             {
[16:04:41.355]                 {
[16:04:41.355]                   {
[16:04:41.355]                     base::local({
[16:04:41.355]                       has_future <- base::requireNamespace("future", 
[16:04:41.355]                         quietly = TRUE)
[16:04:41.355]                       if (has_future) {
[16:04:41.355]                         ns <- base::getNamespace("future")
[16:04:41.355]                         version <- ns[[".package"]][["version"]]
[16:04:41.355]                         if (is.null(version)) 
[16:04:41.355]                           version <- utils::packageVersion("future")
[16:04:41.355]                       }
[16:04:41.355]                       else {
[16:04:41.355]                         version <- NULL
[16:04:41.355]                       }
[16:04:41.355]                       if (!has_future || version < "1.8.0") {
[16:04:41.355]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.355]                           "", base::R.version$version.string), 
[16:04:41.355]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.355]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.355]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.355]                             "release", "version")], collapse = " "), 
[16:04:41.355]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.355]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.355]                           info)
[16:04:41.355]                         info <- base::paste(info, collapse = "; ")
[16:04:41.355]                         if (!has_future) {
[16:04:41.355]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.355]                             info)
[16:04:41.355]                         }
[16:04:41.355]                         else {
[16:04:41.355]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.355]                             info, version)
[16:04:41.355]                         }
[16:04:41.355]                         base::stop(msg)
[16:04:41.355]                       }
[16:04:41.355]                     })
[16:04:41.355]                   }
[16:04:41.355]                   options(future.plan = NULL)
[16:04:41.355]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.355]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.355]                 }
[16:04:41.355]                 ...future.workdir <- getwd()
[16:04:41.355]             }
[16:04:41.355]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.355]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.355]         }
[16:04:41.355]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.355]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.355]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.355]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.355]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.355]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.355]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.355]             base::names(...future.oldOptions))
[16:04:41.355]     }
[16:04:41.355]     if (FALSE) {
[16:04:41.355]     }
[16:04:41.355]     else {
[16:04:41.355]         if (TRUE) {
[16:04:41.355]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.355]                 open = "w")
[16:04:41.355]         }
[16:04:41.355]         else {
[16:04:41.355]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.355]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.355]         }
[16:04:41.355]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.355]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.355]             base::sink(type = "output", split = FALSE)
[16:04:41.355]             base::close(...future.stdout)
[16:04:41.355]         }, add = TRUE)
[16:04:41.355]     }
[16:04:41.355]     ...future.frame <- base::sys.nframe()
[16:04:41.355]     ...future.conditions <- base::list()
[16:04:41.355]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.355]     if (FALSE) {
[16:04:41.355]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.355]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.355]     }
[16:04:41.355]     ...future.result <- base::tryCatch({
[16:04:41.355]         base::withCallingHandlers({
[16:04:41.355]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:41.355]             future::FutureResult(value = ...future.value$value, 
[16:04:41.355]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.355]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.355]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.355]                     ...future.globalenv.names))
[16:04:41.355]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.355]         }, condition = base::local({
[16:04:41.355]             c <- base::c
[16:04:41.355]             inherits <- base::inherits
[16:04:41.355]             invokeRestart <- base::invokeRestart
[16:04:41.355]             length <- base::length
[16:04:41.355]             list <- base::list
[16:04:41.355]             seq.int <- base::seq.int
[16:04:41.355]             signalCondition <- base::signalCondition
[16:04:41.355]             sys.calls <- base::sys.calls
[16:04:41.355]             `[[` <- base::`[[`
[16:04:41.355]             `+` <- base::`+`
[16:04:41.355]             `<<-` <- base::`<<-`
[16:04:41.355]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.355]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.355]                   3L)]
[16:04:41.355]             }
[16:04:41.355]             function(cond) {
[16:04:41.355]                 is_error <- inherits(cond, "error")
[16:04:41.355]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.355]                   NULL)
[16:04:41.355]                 if (is_error) {
[16:04:41.355]                   sessionInformation <- function() {
[16:04:41.355]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.355]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.355]                       search = base::search(), system = base::Sys.info())
[16:04:41.355]                   }
[16:04:41.355]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.355]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.355]                     cond$call), session = sessionInformation(), 
[16:04:41.355]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.355]                   signalCondition(cond)
[16:04:41.355]                 }
[16:04:41.355]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.355]                 "immediateCondition"))) {
[16:04:41.355]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.355]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.355]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.355]                   if (TRUE && !signal) {
[16:04:41.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.355]                     {
[16:04:41.355]                       inherits <- base::inherits
[16:04:41.355]                       invokeRestart <- base::invokeRestart
[16:04:41.355]                       is.null <- base::is.null
[16:04:41.355]                       muffled <- FALSE
[16:04:41.355]                       if (inherits(cond, "message")) {
[16:04:41.355]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.355]                         if (muffled) 
[16:04:41.355]                           invokeRestart("muffleMessage")
[16:04:41.355]                       }
[16:04:41.355]                       else if (inherits(cond, "warning")) {
[16:04:41.355]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.355]                         if (muffled) 
[16:04:41.355]                           invokeRestart("muffleWarning")
[16:04:41.355]                       }
[16:04:41.355]                       else if (inherits(cond, "condition")) {
[16:04:41.355]                         if (!is.null(pattern)) {
[16:04:41.355]                           computeRestarts <- base::computeRestarts
[16:04:41.355]                           grepl <- base::grepl
[16:04:41.355]                           restarts <- computeRestarts(cond)
[16:04:41.355]                           for (restart in restarts) {
[16:04:41.355]                             name <- restart$name
[16:04:41.355]                             if (is.null(name)) 
[16:04:41.355]                               next
[16:04:41.355]                             if (!grepl(pattern, name)) 
[16:04:41.355]                               next
[16:04:41.355]                             invokeRestart(restart)
[16:04:41.355]                             muffled <- TRUE
[16:04:41.355]                             break
[16:04:41.355]                           }
[16:04:41.355]                         }
[16:04:41.355]                       }
[16:04:41.355]                       invisible(muffled)
[16:04:41.355]                     }
[16:04:41.355]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.355]                   }
[16:04:41.355]                 }
[16:04:41.355]                 else {
[16:04:41.355]                   if (TRUE) {
[16:04:41.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.355]                     {
[16:04:41.355]                       inherits <- base::inherits
[16:04:41.355]                       invokeRestart <- base::invokeRestart
[16:04:41.355]                       is.null <- base::is.null
[16:04:41.355]                       muffled <- FALSE
[16:04:41.355]                       if (inherits(cond, "message")) {
[16:04:41.355]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.355]                         if (muffled) 
[16:04:41.355]                           invokeRestart("muffleMessage")
[16:04:41.355]                       }
[16:04:41.355]                       else if (inherits(cond, "warning")) {
[16:04:41.355]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.355]                         if (muffled) 
[16:04:41.355]                           invokeRestart("muffleWarning")
[16:04:41.355]                       }
[16:04:41.355]                       else if (inherits(cond, "condition")) {
[16:04:41.355]                         if (!is.null(pattern)) {
[16:04:41.355]                           computeRestarts <- base::computeRestarts
[16:04:41.355]                           grepl <- base::grepl
[16:04:41.355]                           restarts <- computeRestarts(cond)
[16:04:41.355]                           for (restart in restarts) {
[16:04:41.355]                             name <- restart$name
[16:04:41.355]                             if (is.null(name)) 
[16:04:41.355]                               next
[16:04:41.355]                             if (!grepl(pattern, name)) 
[16:04:41.355]                               next
[16:04:41.355]                             invokeRestart(restart)
[16:04:41.355]                             muffled <- TRUE
[16:04:41.355]                             break
[16:04:41.355]                           }
[16:04:41.355]                         }
[16:04:41.355]                       }
[16:04:41.355]                       invisible(muffled)
[16:04:41.355]                     }
[16:04:41.355]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.355]                   }
[16:04:41.355]                 }
[16:04:41.355]             }
[16:04:41.355]         }))
[16:04:41.355]     }, error = function(ex) {
[16:04:41.355]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.355]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.355]                 ...future.rng), started = ...future.startTime, 
[16:04:41.355]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.355]             version = "1.8"), class = "FutureResult")
[16:04:41.355]     }, finally = {
[16:04:41.355]         if (!identical(...future.workdir, getwd())) 
[16:04:41.355]             setwd(...future.workdir)
[16:04:41.355]         {
[16:04:41.355]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.355]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.355]             }
[16:04:41.355]             base::options(...future.oldOptions)
[16:04:41.355]             if (.Platform$OS.type == "windows") {
[16:04:41.355]                 old_names <- names(...future.oldEnvVars)
[16:04:41.355]                 envs <- base::Sys.getenv()
[16:04:41.355]                 names <- names(envs)
[16:04:41.355]                 common <- intersect(names, old_names)
[16:04:41.355]                 added <- setdiff(names, old_names)
[16:04:41.355]                 removed <- setdiff(old_names, names)
[16:04:41.355]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.355]                   envs[common]]
[16:04:41.355]                 NAMES <- toupper(changed)
[16:04:41.355]                 args <- list()
[16:04:41.355]                 for (kk in seq_along(NAMES)) {
[16:04:41.355]                   name <- changed[[kk]]
[16:04:41.355]                   NAME <- NAMES[[kk]]
[16:04:41.355]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.355]                     next
[16:04:41.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.355]                 }
[16:04:41.355]                 NAMES <- toupper(added)
[16:04:41.355]                 for (kk in seq_along(NAMES)) {
[16:04:41.355]                   name <- added[[kk]]
[16:04:41.355]                   NAME <- NAMES[[kk]]
[16:04:41.355]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.355]                     next
[16:04:41.355]                   args[[name]] <- ""
[16:04:41.355]                 }
[16:04:41.355]                 NAMES <- toupper(removed)
[16:04:41.355]                 for (kk in seq_along(NAMES)) {
[16:04:41.355]                   name <- removed[[kk]]
[16:04:41.355]                   NAME <- NAMES[[kk]]
[16:04:41.355]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.355]                     next
[16:04:41.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.355]                 }
[16:04:41.355]                 if (length(args) > 0) 
[16:04:41.355]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.355]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.355]             }
[16:04:41.355]             else {
[16:04:41.355]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.355]             }
[16:04:41.355]             {
[16:04:41.355]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.355]                   0L) {
[16:04:41.355]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.355]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.355]                   base::options(opts)
[16:04:41.355]                 }
[16:04:41.355]                 {
[16:04:41.355]                   {
[16:04:41.355]                     NULL
[16:04:41.355]                     RNGkind("Mersenne-Twister")
[16:04:41.355]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.355]                       inherits = FALSE)
[16:04:41.355]                   }
[16:04:41.355]                   options(future.plan = NULL)
[16:04:41.355]                   if (is.na(NA_character_)) 
[16:04:41.355]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.355]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.355]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.355]                   {
[16:04:41.355]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.355]                     if (!future$lazy) 
[16:04:41.355]                       future <- run(future)
[16:04:41.355]                     invisible(future)
[16:04:41.355]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.355]                 }
[16:04:41.355]             }
[16:04:41.355]         }
[16:04:41.355]     })
[16:04:41.355]     if (TRUE) {
[16:04:41.355]         base::sink(type = "output", split = FALSE)
[16:04:41.355]         if (TRUE) {
[16:04:41.355]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.355]         }
[16:04:41.355]         else {
[16:04:41.355]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.355]         }
[16:04:41.355]         base::close(...future.stdout)
[16:04:41.355]         ...future.stdout <- NULL
[16:04:41.355]     }
[16:04:41.355]     ...future.result$conditions <- ...future.conditions
[16:04:41.355]     ...future.result$finished <- base::Sys.time()
[16:04:41.355]     ...future.result
[16:04:41.355] }
[16:04:41.356] plan(): Setting new future strategy stack:
[16:04:41.356] List of future strategies:
[16:04:41.356] 1. sequential:
[16:04:41.356]    - args: function (..., envir = parent.frame())
[16:04:41.356]    - tweaked: FALSE
[16:04:41.356]    - call: NULL
[16:04:41.357] plan(): nbrOfWorkers() = 1
[16:04:41.357] plan(): Setting new future strategy stack:
[16:04:41.358] List of future strategies:
[16:04:41.358] 1. sequential:
[16:04:41.358]    - args: function (..., envir = parent.frame())
[16:04:41.358]    - tweaked: FALSE
[16:04:41.358]    - call: plan(strategy)
[16:04:41.358] plan(): nbrOfWorkers() = 1
[16:04:41.358] SequentialFuture started (and completed)
[16:04:41.358] - Launch lazy future ... done
[16:04:41.358] run() for ‘SequentialFuture’ ... done
[16:04:41.359] getGlobalsAndPackages() ...
[16:04:41.359] Searching for globals...
[16:04:41.359] - globals found: [1] ‘{’
[16:04:41.359] Searching for globals ... DONE
[16:04:41.359] Resolving globals: FALSE
[16:04:41.360] 
[16:04:41.360] 
[16:04:41.360] getGlobalsAndPackages() ... DONE
[16:04:41.360] run() for ‘Future’ ...
[16:04:41.360] - state: ‘created’
[16:04:41.360] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.361] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.361] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.361]   - Field: ‘label’
[16:04:41.361]   - Field: ‘local’
[16:04:41.361]   - Field: ‘owner’
[16:04:41.361]   - Field: ‘envir’
[16:04:41.361]   - Field: ‘packages’
[16:04:41.361]   - Field: ‘gc’
[16:04:41.361]   - Field: ‘conditions’
[16:04:41.361]   - Field: ‘expr’
[16:04:41.361]   - Field: ‘uuid’
[16:04:41.362]   - Field: ‘seed’
[16:04:41.362]   - Field: ‘version’
[16:04:41.362]   - Field: ‘result’
[16:04:41.362]   - Field: ‘asynchronous’
[16:04:41.362]   - Field: ‘calls’
[16:04:41.362]   - Field: ‘globals’
[16:04:41.362]   - Field: ‘stdout’
[16:04:41.362]   - Field: ‘earlySignal’
[16:04:41.362]   - Field: ‘lazy’
[16:04:41.362]   - Field: ‘state’
[16:04:41.362] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.363] - Launch lazy future ...
[16:04:41.363] Packages needed by the future expression (n = 0): <none>
[16:04:41.363] Packages needed by future strategies (n = 0): <none>
[16:04:41.363] {
[16:04:41.363]     {
[16:04:41.363]         {
[16:04:41.363]             ...future.startTime <- base::Sys.time()
[16:04:41.363]             {
[16:04:41.363]                 {
[16:04:41.363]                   {
[16:04:41.363]                     base::local({
[16:04:41.363]                       has_future <- base::requireNamespace("future", 
[16:04:41.363]                         quietly = TRUE)
[16:04:41.363]                       if (has_future) {
[16:04:41.363]                         ns <- base::getNamespace("future")
[16:04:41.363]                         version <- ns[[".package"]][["version"]]
[16:04:41.363]                         if (is.null(version)) 
[16:04:41.363]                           version <- utils::packageVersion("future")
[16:04:41.363]                       }
[16:04:41.363]                       else {
[16:04:41.363]                         version <- NULL
[16:04:41.363]                       }
[16:04:41.363]                       if (!has_future || version < "1.8.0") {
[16:04:41.363]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.363]                           "", base::R.version$version.string), 
[16:04:41.363]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.363]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.363]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.363]                             "release", "version")], collapse = " "), 
[16:04:41.363]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.363]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.363]                           info)
[16:04:41.363]                         info <- base::paste(info, collapse = "; ")
[16:04:41.363]                         if (!has_future) {
[16:04:41.363]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.363]                             info)
[16:04:41.363]                         }
[16:04:41.363]                         else {
[16:04:41.363]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.363]                             info, version)
[16:04:41.363]                         }
[16:04:41.363]                         base::stop(msg)
[16:04:41.363]                       }
[16:04:41.363]                     })
[16:04:41.363]                   }
[16:04:41.363]                   options(future.plan = NULL)
[16:04:41.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.363]                 }
[16:04:41.363]                 ...future.workdir <- getwd()
[16:04:41.363]             }
[16:04:41.363]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.363]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.363]         }
[16:04:41.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.363]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.363]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.363]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.363]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.363]             base::names(...future.oldOptions))
[16:04:41.363]     }
[16:04:41.363]     if (FALSE) {
[16:04:41.363]     }
[16:04:41.363]     else {
[16:04:41.363]         if (TRUE) {
[16:04:41.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.363]                 open = "w")
[16:04:41.363]         }
[16:04:41.363]         else {
[16:04:41.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.363]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.363]         }
[16:04:41.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.363]             base::sink(type = "output", split = FALSE)
[16:04:41.363]             base::close(...future.stdout)
[16:04:41.363]         }, add = TRUE)
[16:04:41.363]     }
[16:04:41.363]     ...future.frame <- base::sys.nframe()
[16:04:41.363]     ...future.conditions <- base::list()
[16:04:41.363]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.363]     if (FALSE) {
[16:04:41.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.363]     }
[16:04:41.363]     ...future.result <- base::tryCatch({
[16:04:41.363]         base::withCallingHandlers({
[16:04:41.363]             ...future.value <- base::withVisible(base::local({
[16:04:41.363]                 4
[16:04:41.363]             }))
[16:04:41.363]             future::FutureResult(value = ...future.value$value, 
[16:04:41.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.363]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.363]                     ...future.globalenv.names))
[16:04:41.363]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.363]         }, condition = base::local({
[16:04:41.363]             c <- base::c
[16:04:41.363]             inherits <- base::inherits
[16:04:41.363]             invokeRestart <- base::invokeRestart
[16:04:41.363]             length <- base::length
[16:04:41.363]             list <- base::list
[16:04:41.363]             seq.int <- base::seq.int
[16:04:41.363]             signalCondition <- base::signalCondition
[16:04:41.363]             sys.calls <- base::sys.calls
[16:04:41.363]             `[[` <- base::`[[`
[16:04:41.363]             `+` <- base::`+`
[16:04:41.363]             `<<-` <- base::`<<-`
[16:04:41.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.363]                   3L)]
[16:04:41.363]             }
[16:04:41.363]             function(cond) {
[16:04:41.363]                 is_error <- inherits(cond, "error")
[16:04:41.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.363]                   NULL)
[16:04:41.363]                 if (is_error) {
[16:04:41.363]                   sessionInformation <- function() {
[16:04:41.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.363]                       search = base::search(), system = base::Sys.info())
[16:04:41.363]                   }
[16:04:41.363]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.363]                     cond$call), session = sessionInformation(), 
[16:04:41.363]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.363]                   signalCondition(cond)
[16:04:41.363]                 }
[16:04:41.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.363]                 "immediateCondition"))) {
[16:04:41.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.363]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.363]                   if (TRUE && !signal) {
[16:04:41.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.363]                     {
[16:04:41.363]                       inherits <- base::inherits
[16:04:41.363]                       invokeRestart <- base::invokeRestart
[16:04:41.363]                       is.null <- base::is.null
[16:04:41.363]                       muffled <- FALSE
[16:04:41.363]                       if (inherits(cond, "message")) {
[16:04:41.363]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.363]                         if (muffled) 
[16:04:41.363]                           invokeRestart("muffleMessage")
[16:04:41.363]                       }
[16:04:41.363]                       else if (inherits(cond, "warning")) {
[16:04:41.363]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.363]                         if (muffled) 
[16:04:41.363]                           invokeRestart("muffleWarning")
[16:04:41.363]                       }
[16:04:41.363]                       else if (inherits(cond, "condition")) {
[16:04:41.363]                         if (!is.null(pattern)) {
[16:04:41.363]                           computeRestarts <- base::computeRestarts
[16:04:41.363]                           grepl <- base::grepl
[16:04:41.363]                           restarts <- computeRestarts(cond)
[16:04:41.363]                           for (restart in restarts) {
[16:04:41.363]                             name <- restart$name
[16:04:41.363]                             if (is.null(name)) 
[16:04:41.363]                               next
[16:04:41.363]                             if (!grepl(pattern, name)) 
[16:04:41.363]                               next
[16:04:41.363]                             invokeRestart(restart)
[16:04:41.363]                             muffled <- TRUE
[16:04:41.363]                             break
[16:04:41.363]                           }
[16:04:41.363]                         }
[16:04:41.363]                       }
[16:04:41.363]                       invisible(muffled)
[16:04:41.363]                     }
[16:04:41.363]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.363]                   }
[16:04:41.363]                 }
[16:04:41.363]                 else {
[16:04:41.363]                   if (TRUE) {
[16:04:41.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.363]                     {
[16:04:41.363]                       inherits <- base::inherits
[16:04:41.363]                       invokeRestart <- base::invokeRestart
[16:04:41.363]                       is.null <- base::is.null
[16:04:41.363]                       muffled <- FALSE
[16:04:41.363]                       if (inherits(cond, "message")) {
[16:04:41.363]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.363]                         if (muffled) 
[16:04:41.363]                           invokeRestart("muffleMessage")
[16:04:41.363]                       }
[16:04:41.363]                       else if (inherits(cond, "warning")) {
[16:04:41.363]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.363]                         if (muffled) 
[16:04:41.363]                           invokeRestart("muffleWarning")
[16:04:41.363]                       }
[16:04:41.363]                       else if (inherits(cond, "condition")) {
[16:04:41.363]                         if (!is.null(pattern)) {
[16:04:41.363]                           computeRestarts <- base::computeRestarts
[16:04:41.363]                           grepl <- base::grepl
[16:04:41.363]                           restarts <- computeRestarts(cond)
[16:04:41.363]                           for (restart in restarts) {
[16:04:41.363]                             name <- restart$name
[16:04:41.363]                             if (is.null(name)) 
[16:04:41.363]                               next
[16:04:41.363]                             if (!grepl(pattern, name)) 
[16:04:41.363]                               next
[16:04:41.363]                             invokeRestart(restart)
[16:04:41.363]                             muffled <- TRUE
[16:04:41.363]                             break
[16:04:41.363]                           }
[16:04:41.363]                         }
[16:04:41.363]                       }
[16:04:41.363]                       invisible(muffled)
[16:04:41.363]                     }
[16:04:41.363]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.363]                   }
[16:04:41.363]                 }
[16:04:41.363]             }
[16:04:41.363]         }))
[16:04:41.363]     }, error = function(ex) {
[16:04:41.363]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.363]                 ...future.rng), started = ...future.startTime, 
[16:04:41.363]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.363]             version = "1.8"), class = "FutureResult")
[16:04:41.363]     }, finally = {
[16:04:41.363]         if (!identical(...future.workdir, getwd())) 
[16:04:41.363]             setwd(...future.workdir)
[16:04:41.363]         {
[16:04:41.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.363]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.363]             }
[16:04:41.363]             base::options(...future.oldOptions)
[16:04:41.363]             if (.Platform$OS.type == "windows") {
[16:04:41.363]                 old_names <- names(...future.oldEnvVars)
[16:04:41.363]                 envs <- base::Sys.getenv()
[16:04:41.363]                 names <- names(envs)
[16:04:41.363]                 common <- intersect(names, old_names)
[16:04:41.363]                 added <- setdiff(names, old_names)
[16:04:41.363]                 removed <- setdiff(old_names, names)
[16:04:41.363]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.363]                   envs[common]]
[16:04:41.363]                 NAMES <- toupper(changed)
[16:04:41.363]                 args <- list()
[16:04:41.363]                 for (kk in seq_along(NAMES)) {
[16:04:41.363]                   name <- changed[[kk]]
[16:04:41.363]                   NAME <- NAMES[[kk]]
[16:04:41.363]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.363]                     next
[16:04:41.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.363]                 }
[16:04:41.363]                 NAMES <- toupper(added)
[16:04:41.363]                 for (kk in seq_along(NAMES)) {
[16:04:41.363]                   name <- added[[kk]]
[16:04:41.363]                   NAME <- NAMES[[kk]]
[16:04:41.363]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.363]                     next
[16:04:41.363]                   args[[name]] <- ""
[16:04:41.363]                 }
[16:04:41.363]                 NAMES <- toupper(removed)
[16:04:41.363]                 for (kk in seq_along(NAMES)) {
[16:04:41.363]                   name <- removed[[kk]]
[16:04:41.363]                   NAME <- NAMES[[kk]]
[16:04:41.363]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.363]                     next
[16:04:41.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.363]                 }
[16:04:41.363]                 if (length(args) > 0) 
[16:04:41.363]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.363]             }
[16:04:41.363]             else {
[16:04:41.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.363]             }
[16:04:41.363]             {
[16:04:41.363]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.363]                   0L) {
[16:04:41.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.363]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.363]                   base::options(opts)
[16:04:41.363]                 }
[16:04:41.363]                 {
[16:04:41.363]                   {
[16:04:41.363]                     NULL
[16:04:41.363]                     RNGkind("Mersenne-Twister")
[16:04:41.363]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.363]                       inherits = FALSE)
[16:04:41.363]                   }
[16:04:41.363]                   options(future.plan = NULL)
[16:04:41.363]                   if (is.na(NA_character_)) 
[16:04:41.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.363]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.363]                   {
[16:04:41.363]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.363]                     if (!future$lazy) 
[16:04:41.363]                       future <- run(future)
[16:04:41.363]                     invisible(future)
[16:04:41.363]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.363]                 }
[16:04:41.363]             }
[16:04:41.363]         }
[16:04:41.363]     })
[16:04:41.363]     if (TRUE) {
[16:04:41.363]         base::sink(type = "output", split = FALSE)
[16:04:41.363]         if (TRUE) {
[16:04:41.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.363]         }
[16:04:41.363]         else {
[16:04:41.363]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.363]         }
[16:04:41.363]         base::close(...future.stdout)
[16:04:41.363]         ...future.stdout <- NULL
[16:04:41.363]     }
[16:04:41.363]     ...future.result$conditions <- ...future.conditions
[16:04:41.363]     ...future.result$finished <- base::Sys.time()
[16:04:41.363]     ...future.result
[16:04:41.363] }
[16:04:41.366] plan(): Setting new future strategy stack:
[16:04:41.366] List of future strategies:
[16:04:41.366] 1. sequential:
[16:04:41.366]    - args: function (..., envir = parent.frame())
[16:04:41.366]    - tweaked: FALSE
[16:04:41.366]    - call: NULL
[16:04:41.367] plan(): nbrOfWorkers() = 1
[16:04:41.367] plan(): Setting new future strategy stack:
[16:04:41.367] List of future strategies:
[16:04:41.367] 1. sequential:
[16:04:41.367]    - args: function (..., envir = parent.frame())
[16:04:41.367]    - tweaked: FALSE
[16:04:41.367]    - call: plan(strategy)
[16:04:41.368] plan(): nbrOfWorkers() = 1
[16:04:41.368] SequentialFuture started (and completed)
[16:04:41.368] - Launch lazy future ... done
[16:04:41.368] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55874d02ef00> 
Classes 'listenv', 'environment' <environment: 0x55874c7cf490> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:04:41.372] resolved() for ‘SequentialFuture’ ...
[16:04:41.372] - state: ‘finished’
[16:04:41.372] - run: TRUE
[16:04:41.372] - result: ‘FutureResult’
[16:04:41.372] resolved() for ‘SequentialFuture’ ... done
[16:04:41.372] resolved() for ‘SequentialFuture’ ...
[16:04:41.372] - state: ‘finished’
[16:04:41.372] - run: TRUE
[16:04:41.372] - result: ‘FutureResult’
[16:04:41.373] resolved() for ‘SequentialFuture’ ... done
[16:04:41.373] resolved() for ‘SequentialFuture’ ...
[16:04:41.373] - state: ‘finished’
[16:04:41.373] - run: TRUE
[16:04:41.373] - result: ‘FutureResult’
[16:04:41.373] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:41.375] resolve() on list environment ...
[16:04:41.375]  recursive: 0
[16:04:41.376]  length: 6
[16:04:41.376]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:41.376] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.376] - nx: 6
[16:04:41.377] - relay: TRUE
[16:04:41.377] - stdout: TRUE
[16:04:41.377] - signal: TRUE
[16:04:41.377] - resignal: FALSE
[16:04:41.377] - force: TRUE
[16:04:41.377] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.377] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.377]  - until=2
[16:04:41.377]  - relaying element #2
[16:04:41.377] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.377] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.377] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.378]  length: 5 (resolved future 1)
[16:04:41.378] resolved() for ‘SequentialFuture’ ...
[16:04:41.378] - state: ‘finished’
[16:04:41.378] - run: TRUE
[16:04:41.378] - result: ‘FutureResult’
[16:04:41.378] resolved() for ‘SequentialFuture’ ... done
[16:04:41.378] Future #2
[16:04:41.378] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:41.378] - nx: 6
[16:04:41.378] - relay: TRUE
[16:04:41.378] - stdout: TRUE
[16:04:41.379] - signal: TRUE
[16:04:41.379] - resignal: FALSE
[16:04:41.379] - force: TRUE
[16:04:41.379] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.379] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.379]  - until=2
[16:04:41.379]  - relaying element #2
[16:04:41.379] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.379] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.379] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:41.380]  length: 4 (resolved future 2)
[16:04:41.380] resolved() for ‘SequentialFuture’ ...
[16:04:41.380] - state: ‘finished’
[16:04:41.380] - run: TRUE
[16:04:41.380] - result: ‘FutureResult’
[16:04:41.380] resolved() for ‘SequentialFuture’ ... done
[16:04:41.380] Future #3
[16:04:41.380] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:41.380] - nx: 6
[16:04:41.380] - relay: TRUE
[16:04:41.380] - stdout: TRUE
[16:04:41.381] - signal: TRUE
[16:04:41.381] - resignal: FALSE
[16:04:41.381] - force: TRUE
[16:04:41.381] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.381] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.381]  - until=3
[16:04:41.381]  - relaying element #3
[16:04:41.381] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.381] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.381] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:41.382]  length: 3 (resolved future 3)
[16:04:41.382] resolved() for ‘SequentialFuture’ ...
[16:04:41.382] - state: ‘finished’
[16:04:41.382] - run: TRUE
[16:04:41.382] - result: ‘FutureResult’
[16:04:41.382] resolved() for ‘SequentialFuture’ ... done
[16:04:41.382] Future #4
[16:04:41.382] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:04:41.382] - nx: 6
[16:04:41.382] - relay: TRUE
[16:04:41.382] - stdout: TRUE
[16:04:41.383] - signal: TRUE
[16:04:41.383] - resignal: FALSE
[16:04:41.383] - force: TRUE
[16:04:41.383] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.383] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.383]  - until=4
[16:04:41.383]  - relaying element #4
[16:04:41.383] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.383] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.383] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:04:41.384]  length: 2 (resolved future 4)
[16:04:41.384] signalConditionsASAP(NULL, pos=5) ...
[16:04:41.384] - nx: 6
[16:04:41.384] - relay: TRUE
[16:04:41.384] - stdout: TRUE
[16:04:41.384] - signal: TRUE
[16:04:41.384] - resignal: FALSE
[16:04:41.384] - force: TRUE
[16:04:41.384] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.384] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.384]  - until=6
[16:04:41.384]  - relaying element #6
[16:04:41.384] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.385] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.385] signalConditionsASAP(NULL, pos=5) ... done
[16:04:41.385]  length: 1 (resolved future 5)
[16:04:41.385] signalConditionsASAP(numeric, pos=6) ...
[16:04:41.385] - nx: 6
[16:04:41.385] - relay: TRUE
[16:04:41.385] - stdout: TRUE
[16:04:41.385] - signal: TRUE
[16:04:41.385] - resignal: FALSE
[16:04:41.385] - force: TRUE
[16:04:41.385] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.385] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.386]  - until=6
[16:04:41.386] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.386] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.386] signalConditionsASAP(numeric, pos=6) ... done
[16:04:41.386]  length: 0 (resolved future 6)
[16:04:41.386] Relaying remaining futures
[16:04:41.386] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.386] - nx: 6
[16:04:41.386] - relay: TRUE
[16:04:41.386] - stdout: TRUE
[16:04:41.386] - signal: TRUE
[16:04:41.386] - resignal: FALSE
[16:04:41.387] - force: TRUE
[16:04:41.387] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.387] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:41.387] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.387] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.387] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.387] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55874d609a08> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:04:41.390] getGlobalsAndPackages() ...
[16:04:41.390] Searching for globals...
[16:04:41.390] 
[16:04:41.390] Searching for globals ... DONE
[16:04:41.391] - globals: [0] <none>
[16:04:41.391] getGlobalsAndPackages() ... DONE
[16:04:41.391] run() for ‘Future’ ...
[16:04:41.391] - state: ‘created’
[16:04:41.391] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.391] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.392]   - Field: ‘label’
[16:04:41.392]   - Field: ‘local’
[16:04:41.392]   - Field: ‘owner’
[16:04:41.392]   - Field: ‘envir’
[16:04:41.392]   - Field: ‘packages’
[16:04:41.392]   - Field: ‘gc’
[16:04:41.392]   - Field: ‘conditions’
[16:04:41.392]   - Field: ‘expr’
[16:04:41.392]   - Field: ‘uuid’
[16:04:41.392]   - Field: ‘seed’
[16:04:41.392]   - Field: ‘version’
[16:04:41.393]   - Field: ‘result’
[16:04:41.393]   - Field: ‘asynchronous’
[16:04:41.393]   - Field: ‘calls’
[16:04:41.393]   - Field: ‘globals’
[16:04:41.393]   - Field: ‘stdout’
[16:04:41.393]   - Field: ‘earlySignal’
[16:04:41.393]   - Field: ‘lazy’
[16:04:41.393]   - Field: ‘state’
[16:04:41.393] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.393] - Launch lazy future ...
[16:04:41.394] Packages needed by the future expression (n = 0): <none>
[16:04:41.394] Packages needed by future strategies (n = 0): <none>
[16:04:41.394] {
[16:04:41.394]     {
[16:04:41.394]         {
[16:04:41.394]             ...future.startTime <- base::Sys.time()
[16:04:41.394]             {
[16:04:41.394]                 {
[16:04:41.394]                   {
[16:04:41.394]                     base::local({
[16:04:41.394]                       has_future <- base::requireNamespace("future", 
[16:04:41.394]                         quietly = TRUE)
[16:04:41.394]                       if (has_future) {
[16:04:41.394]                         ns <- base::getNamespace("future")
[16:04:41.394]                         version <- ns[[".package"]][["version"]]
[16:04:41.394]                         if (is.null(version)) 
[16:04:41.394]                           version <- utils::packageVersion("future")
[16:04:41.394]                       }
[16:04:41.394]                       else {
[16:04:41.394]                         version <- NULL
[16:04:41.394]                       }
[16:04:41.394]                       if (!has_future || version < "1.8.0") {
[16:04:41.394]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.394]                           "", base::R.version$version.string), 
[16:04:41.394]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.394]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.394]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.394]                             "release", "version")], collapse = " "), 
[16:04:41.394]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.394]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.394]                           info)
[16:04:41.394]                         info <- base::paste(info, collapse = "; ")
[16:04:41.394]                         if (!has_future) {
[16:04:41.394]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.394]                             info)
[16:04:41.394]                         }
[16:04:41.394]                         else {
[16:04:41.394]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.394]                             info, version)
[16:04:41.394]                         }
[16:04:41.394]                         base::stop(msg)
[16:04:41.394]                       }
[16:04:41.394]                     })
[16:04:41.394]                   }
[16:04:41.394]                   options(future.plan = NULL)
[16:04:41.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.394]                 }
[16:04:41.394]                 ...future.workdir <- getwd()
[16:04:41.394]             }
[16:04:41.394]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.394]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.394]         }
[16:04:41.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.394]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.394]             base::names(...future.oldOptions))
[16:04:41.394]     }
[16:04:41.394]     if (FALSE) {
[16:04:41.394]     }
[16:04:41.394]     else {
[16:04:41.394]         if (TRUE) {
[16:04:41.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.394]                 open = "w")
[16:04:41.394]         }
[16:04:41.394]         else {
[16:04:41.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.394]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.394]         }
[16:04:41.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.394]             base::sink(type = "output", split = FALSE)
[16:04:41.394]             base::close(...future.stdout)
[16:04:41.394]         }, add = TRUE)
[16:04:41.394]     }
[16:04:41.394]     ...future.frame <- base::sys.nframe()
[16:04:41.394]     ...future.conditions <- base::list()
[16:04:41.394]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.394]     if (FALSE) {
[16:04:41.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.394]     }
[16:04:41.394]     ...future.result <- base::tryCatch({
[16:04:41.394]         base::withCallingHandlers({
[16:04:41.394]             ...future.value <- base::withVisible(base::local(2))
[16:04:41.394]             future::FutureResult(value = ...future.value$value, 
[16:04:41.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.394]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.394]                     ...future.globalenv.names))
[16:04:41.394]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.394]         }, condition = base::local({
[16:04:41.394]             c <- base::c
[16:04:41.394]             inherits <- base::inherits
[16:04:41.394]             invokeRestart <- base::invokeRestart
[16:04:41.394]             length <- base::length
[16:04:41.394]             list <- base::list
[16:04:41.394]             seq.int <- base::seq.int
[16:04:41.394]             signalCondition <- base::signalCondition
[16:04:41.394]             sys.calls <- base::sys.calls
[16:04:41.394]             `[[` <- base::`[[`
[16:04:41.394]             `+` <- base::`+`
[16:04:41.394]             `<<-` <- base::`<<-`
[16:04:41.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.394]                   3L)]
[16:04:41.394]             }
[16:04:41.394]             function(cond) {
[16:04:41.394]                 is_error <- inherits(cond, "error")
[16:04:41.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.394]                   NULL)
[16:04:41.394]                 if (is_error) {
[16:04:41.394]                   sessionInformation <- function() {
[16:04:41.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.394]                       search = base::search(), system = base::Sys.info())
[16:04:41.394]                   }
[16:04:41.394]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.394]                     cond$call), session = sessionInformation(), 
[16:04:41.394]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.394]                   signalCondition(cond)
[16:04:41.394]                 }
[16:04:41.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.394]                 "immediateCondition"))) {
[16:04:41.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.394]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.394]                   if (TRUE && !signal) {
[16:04:41.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.394]                     {
[16:04:41.394]                       inherits <- base::inherits
[16:04:41.394]                       invokeRestart <- base::invokeRestart
[16:04:41.394]                       is.null <- base::is.null
[16:04:41.394]                       muffled <- FALSE
[16:04:41.394]                       if (inherits(cond, "message")) {
[16:04:41.394]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.394]                         if (muffled) 
[16:04:41.394]                           invokeRestart("muffleMessage")
[16:04:41.394]                       }
[16:04:41.394]                       else if (inherits(cond, "warning")) {
[16:04:41.394]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.394]                         if (muffled) 
[16:04:41.394]                           invokeRestart("muffleWarning")
[16:04:41.394]                       }
[16:04:41.394]                       else if (inherits(cond, "condition")) {
[16:04:41.394]                         if (!is.null(pattern)) {
[16:04:41.394]                           computeRestarts <- base::computeRestarts
[16:04:41.394]                           grepl <- base::grepl
[16:04:41.394]                           restarts <- computeRestarts(cond)
[16:04:41.394]                           for (restart in restarts) {
[16:04:41.394]                             name <- restart$name
[16:04:41.394]                             if (is.null(name)) 
[16:04:41.394]                               next
[16:04:41.394]                             if (!grepl(pattern, name)) 
[16:04:41.394]                               next
[16:04:41.394]                             invokeRestart(restart)
[16:04:41.394]                             muffled <- TRUE
[16:04:41.394]                             break
[16:04:41.394]                           }
[16:04:41.394]                         }
[16:04:41.394]                       }
[16:04:41.394]                       invisible(muffled)
[16:04:41.394]                     }
[16:04:41.394]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.394]                   }
[16:04:41.394]                 }
[16:04:41.394]                 else {
[16:04:41.394]                   if (TRUE) {
[16:04:41.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.394]                     {
[16:04:41.394]                       inherits <- base::inherits
[16:04:41.394]                       invokeRestart <- base::invokeRestart
[16:04:41.394]                       is.null <- base::is.null
[16:04:41.394]                       muffled <- FALSE
[16:04:41.394]                       if (inherits(cond, "message")) {
[16:04:41.394]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.394]                         if (muffled) 
[16:04:41.394]                           invokeRestart("muffleMessage")
[16:04:41.394]                       }
[16:04:41.394]                       else if (inherits(cond, "warning")) {
[16:04:41.394]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.394]                         if (muffled) 
[16:04:41.394]                           invokeRestart("muffleWarning")
[16:04:41.394]                       }
[16:04:41.394]                       else if (inherits(cond, "condition")) {
[16:04:41.394]                         if (!is.null(pattern)) {
[16:04:41.394]                           computeRestarts <- base::computeRestarts
[16:04:41.394]                           grepl <- base::grepl
[16:04:41.394]                           restarts <- computeRestarts(cond)
[16:04:41.394]                           for (restart in restarts) {
[16:04:41.394]                             name <- restart$name
[16:04:41.394]                             if (is.null(name)) 
[16:04:41.394]                               next
[16:04:41.394]                             if (!grepl(pattern, name)) 
[16:04:41.394]                               next
[16:04:41.394]                             invokeRestart(restart)
[16:04:41.394]                             muffled <- TRUE
[16:04:41.394]                             break
[16:04:41.394]                           }
[16:04:41.394]                         }
[16:04:41.394]                       }
[16:04:41.394]                       invisible(muffled)
[16:04:41.394]                     }
[16:04:41.394]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.394]                   }
[16:04:41.394]                 }
[16:04:41.394]             }
[16:04:41.394]         }))
[16:04:41.394]     }, error = function(ex) {
[16:04:41.394]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.394]                 ...future.rng), started = ...future.startTime, 
[16:04:41.394]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.394]             version = "1.8"), class = "FutureResult")
[16:04:41.394]     }, finally = {
[16:04:41.394]         if (!identical(...future.workdir, getwd())) 
[16:04:41.394]             setwd(...future.workdir)
[16:04:41.394]         {
[16:04:41.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.394]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.394]             }
[16:04:41.394]             base::options(...future.oldOptions)
[16:04:41.394]             if (.Platform$OS.type == "windows") {
[16:04:41.394]                 old_names <- names(...future.oldEnvVars)
[16:04:41.394]                 envs <- base::Sys.getenv()
[16:04:41.394]                 names <- names(envs)
[16:04:41.394]                 common <- intersect(names, old_names)
[16:04:41.394]                 added <- setdiff(names, old_names)
[16:04:41.394]                 removed <- setdiff(old_names, names)
[16:04:41.394]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.394]                   envs[common]]
[16:04:41.394]                 NAMES <- toupper(changed)
[16:04:41.394]                 args <- list()
[16:04:41.394]                 for (kk in seq_along(NAMES)) {
[16:04:41.394]                   name <- changed[[kk]]
[16:04:41.394]                   NAME <- NAMES[[kk]]
[16:04:41.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.394]                     next
[16:04:41.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.394]                 }
[16:04:41.394]                 NAMES <- toupper(added)
[16:04:41.394]                 for (kk in seq_along(NAMES)) {
[16:04:41.394]                   name <- added[[kk]]
[16:04:41.394]                   NAME <- NAMES[[kk]]
[16:04:41.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.394]                     next
[16:04:41.394]                   args[[name]] <- ""
[16:04:41.394]                 }
[16:04:41.394]                 NAMES <- toupper(removed)
[16:04:41.394]                 for (kk in seq_along(NAMES)) {
[16:04:41.394]                   name <- removed[[kk]]
[16:04:41.394]                   NAME <- NAMES[[kk]]
[16:04:41.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.394]                     next
[16:04:41.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.394]                 }
[16:04:41.394]                 if (length(args) > 0) 
[16:04:41.394]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.394]             }
[16:04:41.394]             else {
[16:04:41.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.394]             }
[16:04:41.394]             {
[16:04:41.394]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.394]                   0L) {
[16:04:41.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.394]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.394]                   base::options(opts)
[16:04:41.394]                 }
[16:04:41.394]                 {
[16:04:41.394]                   {
[16:04:41.394]                     NULL
[16:04:41.394]                     RNGkind("Mersenne-Twister")
[16:04:41.394]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.394]                       inherits = FALSE)
[16:04:41.394]                   }
[16:04:41.394]                   options(future.plan = NULL)
[16:04:41.394]                   if (is.na(NA_character_)) 
[16:04:41.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.394]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.394]                   {
[16:04:41.394]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.394]                     if (!future$lazy) 
[16:04:41.394]                       future <- run(future)
[16:04:41.394]                     invisible(future)
[16:04:41.394]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.394]                 }
[16:04:41.394]             }
[16:04:41.394]         }
[16:04:41.394]     })
[16:04:41.394]     if (TRUE) {
[16:04:41.394]         base::sink(type = "output", split = FALSE)
[16:04:41.394]         if (TRUE) {
[16:04:41.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.394]         }
[16:04:41.394]         else {
[16:04:41.394]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.394]         }
[16:04:41.394]         base::close(...future.stdout)
[16:04:41.394]         ...future.stdout <- NULL
[16:04:41.394]     }
[16:04:41.394]     ...future.result$conditions <- ...future.conditions
[16:04:41.394]     ...future.result$finished <- base::Sys.time()
[16:04:41.394]     ...future.result
[16:04:41.394] }
[16:04:41.396] plan(): Setting new future strategy stack:
[16:04:41.396] List of future strategies:
[16:04:41.396] 1. sequential:
[16:04:41.396]    - args: function (..., envir = parent.frame())
[16:04:41.396]    - tweaked: FALSE
[16:04:41.396]    - call: NULL
[16:04:41.396] plan(): nbrOfWorkers() = 1
[16:04:41.397] plan(): Setting new future strategy stack:
[16:04:41.397] List of future strategies:
[16:04:41.397] 1. sequential:
[16:04:41.397]    - args: function (..., envir = parent.frame())
[16:04:41.397]    - tweaked: FALSE
[16:04:41.397]    - call: plan(strategy)
[16:04:41.397] plan(): nbrOfWorkers() = 1
[16:04:41.397] SequentialFuture started (and completed)
[16:04:41.398] - Launch lazy future ... done
[16:04:41.398] run() for ‘SequentialFuture’ ... done
[16:04:41.398] getGlobalsAndPackages() ...
[16:04:41.398] Searching for globals...
[16:04:41.398] 
[16:04:41.398] Searching for globals ... DONE
[16:04:41.398] - globals: [0] <none>
[16:04:41.398] getGlobalsAndPackages() ... DONE
[16:04:41.399] run() for ‘Future’ ...
[16:04:41.399] - state: ‘created’
[16:04:41.399] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.399] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.399] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.399]   - Field: ‘label’
[16:04:41.399]   - Field: ‘local’
[16:04:41.399]   - Field: ‘owner’
[16:04:41.400]   - Field: ‘envir’
[16:04:41.400]   - Field: ‘packages’
[16:04:41.400]   - Field: ‘gc’
[16:04:41.400]   - Field: ‘conditions’
[16:04:41.400]   - Field: ‘expr’
[16:04:41.400]   - Field: ‘uuid’
[16:04:41.400]   - Field: ‘seed’
[16:04:41.400]   - Field: ‘version’
[16:04:41.400]   - Field: ‘result’
[16:04:41.400]   - Field: ‘asynchronous’
[16:04:41.400]   - Field: ‘calls’
[16:04:41.401]   - Field: ‘globals’
[16:04:41.401]   - Field: ‘stdout’
[16:04:41.401]   - Field: ‘earlySignal’
[16:04:41.401]   - Field: ‘lazy’
[16:04:41.401]   - Field: ‘state’
[16:04:41.401] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.401] - Launch lazy future ...
[16:04:41.401] Packages needed by the future expression (n = 0): <none>
[16:04:41.401] Packages needed by future strategies (n = 0): <none>
[16:04:41.402] {
[16:04:41.402]     {
[16:04:41.402]         {
[16:04:41.402]             ...future.startTime <- base::Sys.time()
[16:04:41.402]             {
[16:04:41.402]                 {
[16:04:41.402]                   {
[16:04:41.402]                     base::local({
[16:04:41.402]                       has_future <- base::requireNamespace("future", 
[16:04:41.402]                         quietly = TRUE)
[16:04:41.402]                       if (has_future) {
[16:04:41.402]                         ns <- base::getNamespace("future")
[16:04:41.402]                         version <- ns[[".package"]][["version"]]
[16:04:41.402]                         if (is.null(version)) 
[16:04:41.402]                           version <- utils::packageVersion("future")
[16:04:41.402]                       }
[16:04:41.402]                       else {
[16:04:41.402]                         version <- NULL
[16:04:41.402]                       }
[16:04:41.402]                       if (!has_future || version < "1.8.0") {
[16:04:41.402]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.402]                           "", base::R.version$version.string), 
[16:04:41.402]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.402]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.402]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.402]                             "release", "version")], collapse = " "), 
[16:04:41.402]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.402]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.402]                           info)
[16:04:41.402]                         info <- base::paste(info, collapse = "; ")
[16:04:41.402]                         if (!has_future) {
[16:04:41.402]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.402]                             info)
[16:04:41.402]                         }
[16:04:41.402]                         else {
[16:04:41.402]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.402]                             info, version)
[16:04:41.402]                         }
[16:04:41.402]                         base::stop(msg)
[16:04:41.402]                       }
[16:04:41.402]                     })
[16:04:41.402]                   }
[16:04:41.402]                   options(future.plan = NULL)
[16:04:41.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.402]                 }
[16:04:41.402]                 ...future.workdir <- getwd()
[16:04:41.402]             }
[16:04:41.402]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.402]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.402]         }
[16:04:41.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.402]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.402]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.402]             base::names(...future.oldOptions))
[16:04:41.402]     }
[16:04:41.402]     if (FALSE) {
[16:04:41.402]     }
[16:04:41.402]     else {
[16:04:41.402]         if (TRUE) {
[16:04:41.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.402]                 open = "w")
[16:04:41.402]         }
[16:04:41.402]         else {
[16:04:41.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.402]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.402]         }
[16:04:41.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.402]             base::sink(type = "output", split = FALSE)
[16:04:41.402]             base::close(...future.stdout)
[16:04:41.402]         }, add = TRUE)
[16:04:41.402]     }
[16:04:41.402]     ...future.frame <- base::sys.nframe()
[16:04:41.402]     ...future.conditions <- base::list()
[16:04:41.402]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.402]     if (FALSE) {
[16:04:41.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.402]     }
[16:04:41.402]     ...future.result <- base::tryCatch({
[16:04:41.402]         base::withCallingHandlers({
[16:04:41.402]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:41.402]             future::FutureResult(value = ...future.value$value, 
[16:04:41.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.402]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.402]                     ...future.globalenv.names))
[16:04:41.402]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.402]         }, condition = base::local({
[16:04:41.402]             c <- base::c
[16:04:41.402]             inherits <- base::inherits
[16:04:41.402]             invokeRestart <- base::invokeRestart
[16:04:41.402]             length <- base::length
[16:04:41.402]             list <- base::list
[16:04:41.402]             seq.int <- base::seq.int
[16:04:41.402]             signalCondition <- base::signalCondition
[16:04:41.402]             sys.calls <- base::sys.calls
[16:04:41.402]             `[[` <- base::`[[`
[16:04:41.402]             `+` <- base::`+`
[16:04:41.402]             `<<-` <- base::`<<-`
[16:04:41.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.402]                   3L)]
[16:04:41.402]             }
[16:04:41.402]             function(cond) {
[16:04:41.402]                 is_error <- inherits(cond, "error")
[16:04:41.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.402]                   NULL)
[16:04:41.402]                 if (is_error) {
[16:04:41.402]                   sessionInformation <- function() {
[16:04:41.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.402]                       search = base::search(), system = base::Sys.info())
[16:04:41.402]                   }
[16:04:41.402]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.402]                     cond$call), session = sessionInformation(), 
[16:04:41.402]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.402]                   signalCondition(cond)
[16:04:41.402]                 }
[16:04:41.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.402]                 "immediateCondition"))) {
[16:04:41.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.402]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.402]                   if (TRUE && !signal) {
[16:04:41.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.402]                     {
[16:04:41.402]                       inherits <- base::inherits
[16:04:41.402]                       invokeRestart <- base::invokeRestart
[16:04:41.402]                       is.null <- base::is.null
[16:04:41.402]                       muffled <- FALSE
[16:04:41.402]                       if (inherits(cond, "message")) {
[16:04:41.402]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.402]                         if (muffled) 
[16:04:41.402]                           invokeRestart("muffleMessage")
[16:04:41.402]                       }
[16:04:41.402]                       else if (inherits(cond, "warning")) {
[16:04:41.402]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.402]                         if (muffled) 
[16:04:41.402]                           invokeRestart("muffleWarning")
[16:04:41.402]                       }
[16:04:41.402]                       else if (inherits(cond, "condition")) {
[16:04:41.402]                         if (!is.null(pattern)) {
[16:04:41.402]                           computeRestarts <- base::computeRestarts
[16:04:41.402]                           grepl <- base::grepl
[16:04:41.402]                           restarts <- computeRestarts(cond)
[16:04:41.402]                           for (restart in restarts) {
[16:04:41.402]                             name <- restart$name
[16:04:41.402]                             if (is.null(name)) 
[16:04:41.402]                               next
[16:04:41.402]                             if (!grepl(pattern, name)) 
[16:04:41.402]                               next
[16:04:41.402]                             invokeRestart(restart)
[16:04:41.402]                             muffled <- TRUE
[16:04:41.402]                             break
[16:04:41.402]                           }
[16:04:41.402]                         }
[16:04:41.402]                       }
[16:04:41.402]                       invisible(muffled)
[16:04:41.402]                     }
[16:04:41.402]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.402]                   }
[16:04:41.402]                 }
[16:04:41.402]                 else {
[16:04:41.402]                   if (TRUE) {
[16:04:41.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.402]                     {
[16:04:41.402]                       inherits <- base::inherits
[16:04:41.402]                       invokeRestart <- base::invokeRestart
[16:04:41.402]                       is.null <- base::is.null
[16:04:41.402]                       muffled <- FALSE
[16:04:41.402]                       if (inherits(cond, "message")) {
[16:04:41.402]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.402]                         if (muffled) 
[16:04:41.402]                           invokeRestart("muffleMessage")
[16:04:41.402]                       }
[16:04:41.402]                       else if (inherits(cond, "warning")) {
[16:04:41.402]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.402]                         if (muffled) 
[16:04:41.402]                           invokeRestart("muffleWarning")
[16:04:41.402]                       }
[16:04:41.402]                       else if (inherits(cond, "condition")) {
[16:04:41.402]                         if (!is.null(pattern)) {
[16:04:41.402]                           computeRestarts <- base::computeRestarts
[16:04:41.402]                           grepl <- base::grepl
[16:04:41.402]                           restarts <- computeRestarts(cond)
[16:04:41.402]                           for (restart in restarts) {
[16:04:41.402]                             name <- restart$name
[16:04:41.402]                             if (is.null(name)) 
[16:04:41.402]                               next
[16:04:41.402]                             if (!grepl(pattern, name)) 
[16:04:41.402]                               next
[16:04:41.402]                             invokeRestart(restart)
[16:04:41.402]                             muffled <- TRUE
[16:04:41.402]                             break
[16:04:41.402]                           }
[16:04:41.402]                         }
[16:04:41.402]                       }
[16:04:41.402]                       invisible(muffled)
[16:04:41.402]                     }
[16:04:41.402]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.402]                   }
[16:04:41.402]                 }
[16:04:41.402]             }
[16:04:41.402]         }))
[16:04:41.402]     }, error = function(ex) {
[16:04:41.402]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.402]                 ...future.rng), started = ...future.startTime, 
[16:04:41.402]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.402]             version = "1.8"), class = "FutureResult")
[16:04:41.402]     }, finally = {
[16:04:41.402]         if (!identical(...future.workdir, getwd())) 
[16:04:41.402]             setwd(...future.workdir)
[16:04:41.402]         {
[16:04:41.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.402]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.402]             }
[16:04:41.402]             base::options(...future.oldOptions)
[16:04:41.402]             if (.Platform$OS.type == "windows") {
[16:04:41.402]                 old_names <- names(...future.oldEnvVars)
[16:04:41.402]                 envs <- base::Sys.getenv()
[16:04:41.402]                 names <- names(envs)
[16:04:41.402]                 common <- intersect(names, old_names)
[16:04:41.402]                 added <- setdiff(names, old_names)
[16:04:41.402]                 removed <- setdiff(old_names, names)
[16:04:41.402]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.402]                   envs[common]]
[16:04:41.402]                 NAMES <- toupper(changed)
[16:04:41.402]                 args <- list()
[16:04:41.402]                 for (kk in seq_along(NAMES)) {
[16:04:41.402]                   name <- changed[[kk]]
[16:04:41.402]                   NAME <- NAMES[[kk]]
[16:04:41.402]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.402]                     next
[16:04:41.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.402]                 }
[16:04:41.402]                 NAMES <- toupper(added)
[16:04:41.402]                 for (kk in seq_along(NAMES)) {
[16:04:41.402]                   name <- added[[kk]]
[16:04:41.402]                   NAME <- NAMES[[kk]]
[16:04:41.402]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.402]                     next
[16:04:41.402]                   args[[name]] <- ""
[16:04:41.402]                 }
[16:04:41.402]                 NAMES <- toupper(removed)
[16:04:41.402]                 for (kk in seq_along(NAMES)) {
[16:04:41.402]                   name <- removed[[kk]]
[16:04:41.402]                   NAME <- NAMES[[kk]]
[16:04:41.402]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.402]                     next
[16:04:41.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.402]                 }
[16:04:41.402]                 if (length(args) > 0) 
[16:04:41.402]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.402]             }
[16:04:41.402]             else {
[16:04:41.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.402]             }
[16:04:41.402]             {
[16:04:41.402]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.402]                   0L) {
[16:04:41.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.402]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.402]                   base::options(opts)
[16:04:41.402]                 }
[16:04:41.402]                 {
[16:04:41.402]                   {
[16:04:41.402]                     NULL
[16:04:41.402]                     RNGkind("Mersenne-Twister")
[16:04:41.402]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.402]                       inherits = FALSE)
[16:04:41.402]                   }
[16:04:41.402]                   options(future.plan = NULL)
[16:04:41.402]                   if (is.na(NA_character_)) 
[16:04:41.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.402]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.402]                   {
[16:04:41.402]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.402]                     if (!future$lazy) 
[16:04:41.402]                       future <- run(future)
[16:04:41.402]                     invisible(future)
[16:04:41.402]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.402]                 }
[16:04:41.402]             }
[16:04:41.402]         }
[16:04:41.402]     })
[16:04:41.402]     if (TRUE) {
[16:04:41.402]         base::sink(type = "output", split = FALSE)
[16:04:41.402]         if (TRUE) {
[16:04:41.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.402]         }
[16:04:41.402]         else {
[16:04:41.402]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.402]         }
[16:04:41.402]         base::close(...future.stdout)
[16:04:41.402]         ...future.stdout <- NULL
[16:04:41.402]     }
[16:04:41.402]     ...future.result$conditions <- ...future.conditions
[16:04:41.402]     ...future.result$finished <- base::Sys.time()
[16:04:41.402]     ...future.result
[16:04:41.402] }
[16:04:41.403] plan(): Setting new future strategy stack:
[16:04:41.404] List of future strategies:
[16:04:41.404] 1. sequential:
[16:04:41.404]    - args: function (..., envir = parent.frame())
[16:04:41.404]    - tweaked: FALSE
[16:04:41.404]    - call: NULL
[16:04:41.404] plan(): nbrOfWorkers() = 1
[16:04:41.405] plan(): Setting new future strategy stack:
[16:04:41.405] List of future strategies:
[16:04:41.405] 1. sequential:
[16:04:41.405]    - args: function (..., envir = parent.frame())
[16:04:41.405]    - tweaked: FALSE
[16:04:41.405]    - call: plan(strategy)
[16:04:41.405] plan(): nbrOfWorkers() = 1
[16:04:41.405] SequentialFuture started (and completed)
[16:04:41.405] - Launch lazy future ... done
[16:04:41.405] run() for ‘SequentialFuture’ ... done
[16:04:41.406] getGlobalsAndPackages() ...
[16:04:41.406] Searching for globals...
[16:04:41.406] - globals found: [1] ‘{’
[16:04:41.406] Searching for globals ... DONE
[16:04:41.406] Resolving globals: FALSE
[16:04:41.407] 
[16:04:41.407] 
[16:04:41.407] getGlobalsAndPackages() ... DONE
[16:04:41.407] run() for ‘Future’ ...
[16:04:41.407] - state: ‘created’
[16:04:41.407] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.408] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.408]   - Field: ‘label’
[16:04:41.408]   - Field: ‘local’
[16:04:41.408]   - Field: ‘owner’
[16:04:41.408]   - Field: ‘envir’
[16:04:41.408]   - Field: ‘packages’
[16:04:41.408]   - Field: ‘gc’
[16:04:41.408]   - Field: ‘conditions’
[16:04:41.408]   - Field: ‘expr’
[16:04:41.408]   - Field: ‘uuid’
[16:04:41.409]   - Field: ‘seed’
[16:04:41.409]   - Field: ‘version’
[16:04:41.409]   - Field: ‘result’
[16:04:41.409]   - Field: ‘asynchronous’
[16:04:41.409]   - Field: ‘calls’
[16:04:41.409]   - Field: ‘globals’
[16:04:41.409]   - Field: ‘stdout’
[16:04:41.409]   - Field: ‘earlySignal’
[16:04:41.409]   - Field: ‘lazy’
[16:04:41.409]   - Field: ‘state’
[16:04:41.409] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.410] - Launch lazy future ...
[16:04:41.410] Packages needed by the future expression (n = 0): <none>
[16:04:41.410] Packages needed by future strategies (n = 0): <none>
[16:04:41.410] {
[16:04:41.410]     {
[16:04:41.410]         {
[16:04:41.410]             ...future.startTime <- base::Sys.time()
[16:04:41.410]             {
[16:04:41.410]                 {
[16:04:41.410]                   {
[16:04:41.410]                     base::local({
[16:04:41.410]                       has_future <- base::requireNamespace("future", 
[16:04:41.410]                         quietly = TRUE)
[16:04:41.410]                       if (has_future) {
[16:04:41.410]                         ns <- base::getNamespace("future")
[16:04:41.410]                         version <- ns[[".package"]][["version"]]
[16:04:41.410]                         if (is.null(version)) 
[16:04:41.410]                           version <- utils::packageVersion("future")
[16:04:41.410]                       }
[16:04:41.410]                       else {
[16:04:41.410]                         version <- NULL
[16:04:41.410]                       }
[16:04:41.410]                       if (!has_future || version < "1.8.0") {
[16:04:41.410]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.410]                           "", base::R.version$version.string), 
[16:04:41.410]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.410]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.410]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.410]                             "release", "version")], collapse = " "), 
[16:04:41.410]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.410]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.410]                           info)
[16:04:41.410]                         info <- base::paste(info, collapse = "; ")
[16:04:41.410]                         if (!has_future) {
[16:04:41.410]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.410]                             info)
[16:04:41.410]                         }
[16:04:41.410]                         else {
[16:04:41.410]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.410]                             info, version)
[16:04:41.410]                         }
[16:04:41.410]                         base::stop(msg)
[16:04:41.410]                       }
[16:04:41.410]                     })
[16:04:41.410]                   }
[16:04:41.410]                   options(future.plan = NULL)
[16:04:41.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.410]                 }
[16:04:41.410]                 ...future.workdir <- getwd()
[16:04:41.410]             }
[16:04:41.410]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.410]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.410]         }
[16:04:41.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.410]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.410]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.410]             base::names(...future.oldOptions))
[16:04:41.410]     }
[16:04:41.410]     if (FALSE) {
[16:04:41.410]     }
[16:04:41.410]     else {
[16:04:41.410]         if (TRUE) {
[16:04:41.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.410]                 open = "w")
[16:04:41.410]         }
[16:04:41.410]         else {
[16:04:41.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.410]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.410]         }
[16:04:41.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.410]             base::sink(type = "output", split = FALSE)
[16:04:41.410]             base::close(...future.stdout)
[16:04:41.410]         }, add = TRUE)
[16:04:41.410]     }
[16:04:41.410]     ...future.frame <- base::sys.nframe()
[16:04:41.410]     ...future.conditions <- base::list()
[16:04:41.410]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.410]     if (FALSE) {
[16:04:41.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.410]     }
[16:04:41.410]     ...future.result <- base::tryCatch({
[16:04:41.410]         base::withCallingHandlers({
[16:04:41.410]             ...future.value <- base::withVisible(base::local({
[16:04:41.410]                 4
[16:04:41.410]             }))
[16:04:41.410]             future::FutureResult(value = ...future.value$value, 
[16:04:41.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.410]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.410]                     ...future.globalenv.names))
[16:04:41.410]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.410]         }, condition = base::local({
[16:04:41.410]             c <- base::c
[16:04:41.410]             inherits <- base::inherits
[16:04:41.410]             invokeRestart <- base::invokeRestart
[16:04:41.410]             length <- base::length
[16:04:41.410]             list <- base::list
[16:04:41.410]             seq.int <- base::seq.int
[16:04:41.410]             signalCondition <- base::signalCondition
[16:04:41.410]             sys.calls <- base::sys.calls
[16:04:41.410]             `[[` <- base::`[[`
[16:04:41.410]             `+` <- base::`+`
[16:04:41.410]             `<<-` <- base::`<<-`
[16:04:41.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.410]                   3L)]
[16:04:41.410]             }
[16:04:41.410]             function(cond) {
[16:04:41.410]                 is_error <- inherits(cond, "error")
[16:04:41.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.410]                   NULL)
[16:04:41.410]                 if (is_error) {
[16:04:41.410]                   sessionInformation <- function() {
[16:04:41.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.410]                       search = base::search(), system = base::Sys.info())
[16:04:41.410]                   }
[16:04:41.410]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.410]                     cond$call), session = sessionInformation(), 
[16:04:41.410]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.410]                   signalCondition(cond)
[16:04:41.410]                 }
[16:04:41.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.410]                 "immediateCondition"))) {
[16:04:41.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.410]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.410]                   if (TRUE && !signal) {
[16:04:41.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.410]                     {
[16:04:41.410]                       inherits <- base::inherits
[16:04:41.410]                       invokeRestart <- base::invokeRestart
[16:04:41.410]                       is.null <- base::is.null
[16:04:41.410]                       muffled <- FALSE
[16:04:41.410]                       if (inherits(cond, "message")) {
[16:04:41.410]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.410]                         if (muffled) 
[16:04:41.410]                           invokeRestart("muffleMessage")
[16:04:41.410]                       }
[16:04:41.410]                       else if (inherits(cond, "warning")) {
[16:04:41.410]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.410]                         if (muffled) 
[16:04:41.410]                           invokeRestart("muffleWarning")
[16:04:41.410]                       }
[16:04:41.410]                       else if (inherits(cond, "condition")) {
[16:04:41.410]                         if (!is.null(pattern)) {
[16:04:41.410]                           computeRestarts <- base::computeRestarts
[16:04:41.410]                           grepl <- base::grepl
[16:04:41.410]                           restarts <- computeRestarts(cond)
[16:04:41.410]                           for (restart in restarts) {
[16:04:41.410]                             name <- restart$name
[16:04:41.410]                             if (is.null(name)) 
[16:04:41.410]                               next
[16:04:41.410]                             if (!grepl(pattern, name)) 
[16:04:41.410]                               next
[16:04:41.410]                             invokeRestart(restart)
[16:04:41.410]                             muffled <- TRUE
[16:04:41.410]                             break
[16:04:41.410]                           }
[16:04:41.410]                         }
[16:04:41.410]                       }
[16:04:41.410]                       invisible(muffled)
[16:04:41.410]                     }
[16:04:41.410]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.410]                   }
[16:04:41.410]                 }
[16:04:41.410]                 else {
[16:04:41.410]                   if (TRUE) {
[16:04:41.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.410]                     {
[16:04:41.410]                       inherits <- base::inherits
[16:04:41.410]                       invokeRestart <- base::invokeRestart
[16:04:41.410]                       is.null <- base::is.null
[16:04:41.410]                       muffled <- FALSE
[16:04:41.410]                       if (inherits(cond, "message")) {
[16:04:41.410]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.410]                         if (muffled) 
[16:04:41.410]                           invokeRestart("muffleMessage")
[16:04:41.410]                       }
[16:04:41.410]                       else if (inherits(cond, "warning")) {
[16:04:41.410]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.410]                         if (muffled) 
[16:04:41.410]                           invokeRestart("muffleWarning")
[16:04:41.410]                       }
[16:04:41.410]                       else if (inherits(cond, "condition")) {
[16:04:41.410]                         if (!is.null(pattern)) {
[16:04:41.410]                           computeRestarts <- base::computeRestarts
[16:04:41.410]                           grepl <- base::grepl
[16:04:41.410]                           restarts <- computeRestarts(cond)
[16:04:41.410]                           for (restart in restarts) {
[16:04:41.410]                             name <- restart$name
[16:04:41.410]                             if (is.null(name)) 
[16:04:41.410]                               next
[16:04:41.410]                             if (!grepl(pattern, name)) 
[16:04:41.410]                               next
[16:04:41.410]                             invokeRestart(restart)
[16:04:41.410]                             muffled <- TRUE
[16:04:41.410]                             break
[16:04:41.410]                           }
[16:04:41.410]                         }
[16:04:41.410]                       }
[16:04:41.410]                       invisible(muffled)
[16:04:41.410]                     }
[16:04:41.410]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.410]                   }
[16:04:41.410]                 }
[16:04:41.410]             }
[16:04:41.410]         }))
[16:04:41.410]     }, error = function(ex) {
[16:04:41.410]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.410]                 ...future.rng), started = ...future.startTime, 
[16:04:41.410]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.410]             version = "1.8"), class = "FutureResult")
[16:04:41.410]     }, finally = {
[16:04:41.410]         if (!identical(...future.workdir, getwd())) 
[16:04:41.410]             setwd(...future.workdir)
[16:04:41.410]         {
[16:04:41.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.410]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.410]             }
[16:04:41.410]             base::options(...future.oldOptions)
[16:04:41.410]             if (.Platform$OS.type == "windows") {
[16:04:41.410]                 old_names <- names(...future.oldEnvVars)
[16:04:41.410]                 envs <- base::Sys.getenv()
[16:04:41.410]                 names <- names(envs)
[16:04:41.410]                 common <- intersect(names, old_names)
[16:04:41.410]                 added <- setdiff(names, old_names)
[16:04:41.410]                 removed <- setdiff(old_names, names)
[16:04:41.410]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.410]                   envs[common]]
[16:04:41.410]                 NAMES <- toupper(changed)
[16:04:41.410]                 args <- list()
[16:04:41.410]                 for (kk in seq_along(NAMES)) {
[16:04:41.410]                   name <- changed[[kk]]
[16:04:41.410]                   NAME <- NAMES[[kk]]
[16:04:41.410]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.410]                     next
[16:04:41.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.410]                 }
[16:04:41.410]                 NAMES <- toupper(added)
[16:04:41.410]                 for (kk in seq_along(NAMES)) {
[16:04:41.410]                   name <- added[[kk]]
[16:04:41.410]                   NAME <- NAMES[[kk]]
[16:04:41.410]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.410]                     next
[16:04:41.410]                   args[[name]] <- ""
[16:04:41.410]                 }
[16:04:41.410]                 NAMES <- toupper(removed)
[16:04:41.410]                 for (kk in seq_along(NAMES)) {
[16:04:41.410]                   name <- removed[[kk]]
[16:04:41.410]                   NAME <- NAMES[[kk]]
[16:04:41.410]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.410]                     next
[16:04:41.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.410]                 }
[16:04:41.410]                 if (length(args) > 0) 
[16:04:41.410]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.410]             }
[16:04:41.410]             else {
[16:04:41.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.410]             }
[16:04:41.410]             {
[16:04:41.410]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.410]                   0L) {
[16:04:41.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.410]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.410]                   base::options(opts)
[16:04:41.410]                 }
[16:04:41.410]                 {
[16:04:41.410]                   {
[16:04:41.410]                     NULL
[16:04:41.410]                     RNGkind("Mersenne-Twister")
[16:04:41.410]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.410]                       inherits = FALSE)
[16:04:41.410]                   }
[16:04:41.410]                   options(future.plan = NULL)
[16:04:41.410]                   if (is.na(NA_character_)) 
[16:04:41.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.410]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.410]                   {
[16:04:41.410]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.410]                     if (!future$lazy) 
[16:04:41.410]                       future <- run(future)
[16:04:41.410]                     invisible(future)
[16:04:41.410]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.410]                 }
[16:04:41.410]             }
[16:04:41.410]         }
[16:04:41.410]     })
[16:04:41.410]     if (TRUE) {
[16:04:41.410]         base::sink(type = "output", split = FALSE)
[16:04:41.410]         if (TRUE) {
[16:04:41.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.410]         }
[16:04:41.410]         else {
[16:04:41.410]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.410]         }
[16:04:41.410]         base::close(...future.stdout)
[16:04:41.410]         ...future.stdout <- NULL
[16:04:41.410]     }
[16:04:41.410]     ...future.result$conditions <- ...future.conditions
[16:04:41.410]     ...future.result$finished <- base::Sys.time()
[16:04:41.410]     ...future.result
[16:04:41.410] }
[16:04:41.412] plan(): Setting new future strategy stack:
[16:04:41.412] List of future strategies:
[16:04:41.412] 1. sequential:
[16:04:41.412]    - args: function (..., envir = parent.frame())
[16:04:41.412]    - tweaked: FALSE
[16:04:41.412]    - call: NULL
[16:04:41.412] plan(): nbrOfWorkers() = 1
[16:04:41.413] plan(): Setting new future strategy stack:
[16:04:41.413] List of future strategies:
[16:04:41.413] 1. sequential:
[16:04:41.413]    - args: function (..., envir = parent.frame())
[16:04:41.413]    - tweaked: FALSE
[16:04:41.413]    - call: plan(strategy)
[16:04:41.413] plan(): nbrOfWorkers() = 1
[16:04:41.414] SequentialFuture started (and completed)
[16:04:41.414] - Launch lazy future ... done
[16:04:41.414] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55874c7c8268> 
Classes 'listenv', 'environment' <environment: 0x55874dfb2288> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:04:41.418] resolved() for ‘SequentialFuture’ ...
[16:04:41.418] - state: ‘finished’
[16:04:41.419] - run: TRUE
[16:04:41.419] - result: ‘FutureResult’
[16:04:41.419] resolved() for ‘SequentialFuture’ ... done
[16:04:41.419] resolved() for ‘SequentialFuture’ ...
[16:04:41.419] - state: ‘finished’
[16:04:41.419] - run: TRUE
[16:04:41.419] - result: ‘FutureResult’
[16:04:41.419] resolved() for ‘SequentialFuture’ ... done
[16:04:41.419] resolved() for ‘SequentialFuture’ ...
[16:04:41.419] - state: ‘finished’
[16:04:41.420] - run: TRUE
[16:04:41.420] - result: ‘FutureResult’
[16:04:41.420] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:41.422] resolve() on list environment ...
[16:04:41.422]  recursive: 0
[16:04:41.423]  length: 6
[16:04:41.423]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:41.423] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.424] - nx: 6
[16:04:41.424] - relay: TRUE
[16:04:41.424] - stdout: TRUE
[16:04:41.424] - signal: TRUE
[16:04:41.424] - resignal: FALSE
[16:04:41.424] - force: TRUE
[16:04:41.424] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.424] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.424]  - until=2
[16:04:41.424]  - relaying element #2
[16:04:41.424] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.424] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.425] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.425]  length: 5 (resolved future 1)
[16:04:41.425] resolved() for ‘SequentialFuture’ ...
[16:04:41.425] - state: ‘finished’
[16:04:41.425] - run: TRUE
[16:04:41.425] - result: ‘FutureResult’
[16:04:41.425] resolved() for ‘SequentialFuture’ ... done
[16:04:41.425] Future #2
[16:04:41.425] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:41.425] - nx: 6
[16:04:41.425] - relay: TRUE
[16:04:41.426] - stdout: TRUE
[16:04:41.426] - signal: TRUE
[16:04:41.426] - resignal: FALSE
[16:04:41.426] - force: TRUE
[16:04:41.426] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.426] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.426]  - until=2
[16:04:41.426]  - relaying element #2
[16:04:41.426] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.426] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.426] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:41.427]  length: 4 (resolved future 2)
[16:04:41.427] resolved() for ‘SequentialFuture’ ...
[16:04:41.427] - state: ‘finished’
[16:04:41.427] - run: TRUE
[16:04:41.427] - result: ‘FutureResult’
[16:04:41.427] resolved() for ‘SequentialFuture’ ... done
[16:04:41.427] Future #3
[16:04:41.427] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:41.427] - nx: 6
[16:04:41.427] - relay: TRUE
[16:04:41.428] - stdout: TRUE
[16:04:41.428] - signal: TRUE
[16:04:41.428] - resignal: FALSE
[16:04:41.428] - force: TRUE
[16:04:41.428] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.428] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.428]  - until=3
[16:04:41.428]  - relaying element #3
[16:04:41.428] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.428] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.428] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:41.429]  length: 3 (resolved future 3)
[16:04:41.429] resolved() for ‘SequentialFuture’ ...
[16:04:41.429] - state: ‘finished’
[16:04:41.429] - run: TRUE
[16:04:41.429] - result: ‘FutureResult’
[16:04:41.429] resolved() for ‘SequentialFuture’ ... done
[16:04:41.429] Future #4
[16:04:41.429] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:04:41.429] - nx: 6
[16:04:41.429] - relay: TRUE
[16:04:41.429] - stdout: TRUE
[16:04:41.429] - signal: TRUE
[16:04:41.430] - resignal: FALSE
[16:04:41.430] - force: TRUE
[16:04:41.430] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.430] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.430]  - until=4
[16:04:41.430]  - relaying element #4
[16:04:41.430] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.430] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.430] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:04:41.430]  length: 2 (resolved future 4)
[16:04:41.431] signalConditionsASAP(NULL, pos=5) ...
[16:04:41.431] - nx: 6
[16:04:41.431] - relay: TRUE
[16:04:41.431] - stdout: TRUE
[16:04:41.431] - signal: TRUE
[16:04:41.431] - resignal: FALSE
[16:04:41.431] - force: TRUE
[16:04:41.431] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.431] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.431]  - until=6
[16:04:41.431]  - relaying element #6
[16:04:41.431] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.431] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.432] signalConditionsASAP(NULL, pos=5) ... done
[16:04:41.432]  length: 1 (resolved future 5)
[16:04:41.432] signalConditionsASAP(numeric, pos=6) ...
[16:04:41.432] - nx: 6
[16:04:41.432] - relay: TRUE
[16:04:41.432] - stdout: TRUE
[16:04:41.432] - signal: TRUE
[16:04:41.432] - resignal: FALSE
[16:04:41.432] - force: TRUE
[16:04:41.432] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.432] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.432]  - until=6
[16:04:41.433] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.433] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.433] signalConditionsASAP(numeric, pos=6) ... done
[16:04:41.433]  length: 0 (resolved future 6)
[16:04:41.433] Relaying remaining futures
[16:04:41.433] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.433] - nx: 6
[16:04:41.433] - relay: TRUE
[16:04:41.433] - stdout: TRUE
[16:04:41.433] - signal: TRUE
[16:04:41.433] - resignal: FALSE
[16:04:41.433] - force: TRUE
[16:04:41.433] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.434] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:41.434] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.434] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.434] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.434] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55874c3e5738> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:04:41.436] getGlobalsAndPackages() ...
[16:04:41.436] Searching for globals...
[16:04:41.436] 
[16:04:41.436] Searching for globals ... DONE
[16:04:41.437] - globals: [0] <none>
[16:04:41.437] getGlobalsAndPackages() ... DONE
[16:04:41.437] run() for ‘Future’ ...
[16:04:41.437] - state: ‘created’
[16:04:41.437] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.437] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.437] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.438]   - Field: ‘label’
[16:04:41.438]   - Field: ‘local’
[16:04:41.438]   - Field: ‘owner’
[16:04:41.438]   - Field: ‘envir’
[16:04:41.438]   - Field: ‘packages’
[16:04:41.438]   - Field: ‘gc’
[16:04:41.438]   - Field: ‘conditions’
[16:04:41.438]   - Field: ‘expr’
[16:04:41.438]   - Field: ‘uuid’
[16:04:41.438]   - Field: ‘seed’
[16:04:41.438]   - Field: ‘version’
[16:04:41.439]   - Field: ‘result’
[16:04:41.439]   - Field: ‘asynchronous’
[16:04:41.439]   - Field: ‘calls’
[16:04:41.439]   - Field: ‘globals’
[16:04:41.439]   - Field: ‘stdout’
[16:04:41.439]   - Field: ‘earlySignal’
[16:04:41.439]   - Field: ‘lazy’
[16:04:41.439]   - Field: ‘state’
[16:04:41.439] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.439] - Launch lazy future ...
[16:04:41.439] Packages needed by the future expression (n = 0): <none>
[16:04:41.440] Packages needed by future strategies (n = 0): <none>
[16:04:41.440] {
[16:04:41.440]     {
[16:04:41.440]         {
[16:04:41.440]             ...future.startTime <- base::Sys.time()
[16:04:41.440]             {
[16:04:41.440]                 {
[16:04:41.440]                   {
[16:04:41.440]                     base::local({
[16:04:41.440]                       has_future <- base::requireNamespace("future", 
[16:04:41.440]                         quietly = TRUE)
[16:04:41.440]                       if (has_future) {
[16:04:41.440]                         ns <- base::getNamespace("future")
[16:04:41.440]                         version <- ns[[".package"]][["version"]]
[16:04:41.440]                         if (is.null(version)) 
[16:04:41.440]                           version <- utils::packageVersion("future")
[16:04:41.440]                       }
[16:04:41.440]                       else {
[16:04:41.440]                         version <- NULL
[16:04:41.440]                       }
[16:04:41.440]                       if (!has_future || version < "1.8.0") {
[16:04:41.440]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.440]                           "", base::R.version$version.string), 
[16:04:41.440]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.440]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.440]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.440]                             "release", "version")], collapse = " "), 
[16:04:41.440]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.440]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.440]                           info)
[16:04:41.440]                         info <- base::paste(info, collapse = "; ")
[16:04:41.440]                         if (!has_future) {
[16:04:41.440]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.440]                             info)
[16:04:41.440]                         }
[16:04:41.440]                         else {
[16:04:41.440]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.440]                             info, version)
[16:04:41.440]                         }
[16:04:41.440]                         base::stop(msg)
[16:04:41.440]                       }
[16:04:41.440]                     })
[16:04:41.440]                   }
[16:04:41.440]                   options(future.plan = NULL)
[16:04:41.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.440]                 }
[16:04:41.440]                 ...future.workdir <- getwd()
[16:04:41.440]             }
[16:04:41.440]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.440]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.440]         }
[16:04:41.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.440]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.440]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.440]             base::names(...future.oldOptions))
[16:04:41.440]     }
[16:04:41.440]     if (FALSE) {
[16:04:41.440]     }
[16:04:41.440]     else {
[16:04:41.440]         if (TRUE) {
[16:04:41.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.440]                 open = "w")
[16:04:41.440]         }
[16:04:41.440]         else {
[16:04:41.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.440]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.440]         }
[16:04:41.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.440]             base::sink(type = "output", split = FALSE)
[16:04:41.440]             base::close(...future.stdout)
[16:04:41.440]         }, add = TRUE)
[16:04:41.440]     }
[16:04:41.440]     ...future.frame <- base::sys.nframe()
[16:04:41.440]     ...future.conditions <- base::list()
[16:04:41.440]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.440]     if (FALSE) {
[16:04:41.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.440]     }
[16:04:41.440]     ...future.result <- base::tryCatch({
[16:04:41.440]         base::withCallingHandlers({
[16:04:41.440]             ...future.value <- base::withVisible(base::local(2))
[16:04:41.440]             future::FutureResult(value = ...future.value$value, 
[16:04:41.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.440]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.440]                     ...future.globalenv.names))
[16:04:41.440]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.440]         }, condition = base::local({
[16:04:41.440]             c <- base::c
[16:04:41.440]             inherits <- base::inherits
[16:04:41.440]             invokeRestart <- base::invokeRestart
[16:04:41.440]             length <- base::length
[16:04:41.440]             list <- base::list
[16:04:41.440]             seq.int <- base::seq.int
[16:04:41.440]             signalCondition <- base::signalCondition
[16:04:41.440]             sys.calls <- base::sys.calls
[16:04:41.440]             `[[` <- base::`[[`
[16:04:41.440]             `+` <- base::`+`
[16:04:41.440]             `<<-` <- base::`<<-`
[16:04:41.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.440]                   3L)]
[16:04:41.440]             }
[16:04:41.440]             function(cond) {
[16:04:41.440]                 is_error <- inherits(cond, "error")
[16:04:41.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.440]                   NULL)
[16:04:41.440]                 if (is_error) {
[16:04:41.440]                   sessionInformation <- function() {
[16:04:41.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.440]                       search = base::search(), system = base::Sys.info())
[16:04:41.440]                   }
[16:04:41.440]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.440]                     cond$call), session = sessionInformation(), 
[16:04:41.440]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.440]                   signalCondition(cond)
[16:04:41.440]                 }
[16:04:41.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.440]                 "immediateCondition"))) {
[16:04:41.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.440]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.440]                   if (TRUE && !signal) {
[16:04:41.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.440]                     {
[16:04:41.440]                       inherits <- base::inherits
[16:04:41.440]                       invokeRestart <- base::invokeRestart
[16:04:41.440]                       is.null <- base::is.null
[16:04:41.440]                       muffled <- FALSE
[16:04:41.440]                       if (inherits(cond, "message")) {
[16:04:41.440]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.440]                         if (muffled) 
[16:04:41.440]                           invokeRestart("muffleMessage")
[16:04:41.440]                       }
[16:04:41.440]                       else if (inherits(cond, "warning")) {
[16:04:41.440]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.440]                         if (muffled) 
[16:04:41.440]                           invokeRestart("muffleWarning")
[16:04:41.440]                       }
[16:04:41.440]                       else if (inherits(cond, "condition")) {
[16:04:41.440]                         if (!is.null(pattern)) {
[16:04:41.440]                           computeRestarts <- base::computeRestarts
[16:04:41.440]                           grepl <- base::grepl
[16:04:41.440]                           restarts <- computeRestarts(cond)
[16:04:41.440]                           for (restart in restarts) {
[16:04:41.440]                             name <- restart$name
[16:04:41.440]                             if (is.null(name)) 
[16:04:41.440]                               next
[16:04:41.440]                             if (!grepl(pattern, name)) 
[16:04:41.440]                               next
[16:04:41.440]                             invokeRestart(restart)
[16:04:41.440]                             muffled <- TRUE
[16:04:41.440]                             break
[16:04:41.440]                           }
[16:04:41.440]                         }
[16:04:41.440]                       }
[16:04:41.440]                       invisible(muffled)
[16:04:41.440]                     }
[16:04:41.440]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.440]                   }
[16:04:41.440]                 }
[16:04:41.440]                 else {
[16:04:41.440]                   if (TRUE) {
[16:04:41.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.440]                     {
[16:04:41.440]                       inherits <- base::inherits
[16:04:41.440]                       invokeRestart <- base::invokeRestart
[16:04:41.440]                       is.null <- base::is.null
[16:04:41.440]                       muffled <- FALSE
[16:04:41.440]                       if (inherits(cond, "message")) {
[16:04:41.440]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.440]                         if (muffled) 
[16:04:41.440]                           invokeRestart("muffleMessage")
[16:04:41.440]                       }
[16:04:41.440]                       else if (inherits(cond, "warning")) {
[16:04:41.440]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.440]                         if (muffled) 
[16:04:41.440]                           invokeRestart("muffleWarning")
[16:04:41.440]                       }
[16:04:41.440]                       else if (inherits(cond, "condition")) {
[16:04:41.440]                         if (!is.null(pattern)) {
[16:04:41.440]                           computeRestarts <- base::computeRestarts
[16:04:41.440]                           grepl <- base::grepl
[16:04:41.440]                           restarts <- computeRestarts(cond)
[16:04:41.440]                           for (restart in restarts) {
[16:04:41.440]                             name <- restart$name
[16:04:41.440]                             if (is.null(name)) 
[16:04:41.440]                               next
[16:04:41.440]                             if (!grepl(pattern, name)) 
[16:04:41.440]                               next
[16:04:41.440]                             invokeRestart(restart)
[16:04:41.440]                             muffled <- TRUE
[16:04:41.440]                             break
[16:04:41.440]                           }
[16:04:41.440]                         }
[16:04:41.440]                       }
[16:04:41.440]                       invisible(muffled)
[16:04:41.440]                     }
[16:04:41.440]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.440]                   }
[16:04:41.440]                 }
[16:04:41.440]             }
[16:04:41.440]         }))
[16:04:41.440]     }, error = function(ex) {
[16:04:41.440]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.440]                 ...future.rng), started = ...future.startTime, 
[16:04:41.440]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.440]             version = "1.8"), class = "FutureResult")
[16:04:41.440]     }, finally = {
[16:04:41.440]         if (!identical(...future.workdir, getwd())) 
[16:04:41.440]             setwd(...future.workdir)
[16:04:41.440]         {
[16:04:41.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.440]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.440]             }
[16:04:41.440]             base::options(...future.oldOptions)
[16:04:41.440]             if (.Platform$OS.type == "windows") {
[16:04:41.440]                 old_names <- names(...future.oldEnvVars)
[16:04:41.440]                 envs <- base::Sys.getenv()
[16:04:41.440]                 names <- names(envs)
[16:04:41.440]                 common <- intersect(names, old_names)
[16:04:41.440]                 added <- setdiff(names, old_names)
[16:04:41.440]                 removed <- setdiff(old_names, names)
[16:04:41.440]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.440]                   envs[common]]
[16:04:41.440]                 NAMES <- toupper(changed)
[16:04:41.440]                 args <- list()
[16:04:41.440]                 for (kk in seq_along(NAMES)) {
[16:04:41.440]                   name <- changed[[kk]]
[16:04:41.440]                   NAME <- NAMES[[kk]]
[16:04:41.440]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.440]                     next
[16:04:41.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.440]                 }
[16:04:41.440]                 NAMES <- toupper(added)
[16:04:41.440]                 for (kk in seq_along(NAMES)) {
[16:04:41.440]                   name <- added[[kk]]
[16:04:41.440]                   NAME <- NAMES[[kk]]
[16:04:41.440]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.440]                     next
[16:04:41.440]                   args[[name]] <- ""
[16:04:41.440]                 }
[16:04:41.440]                 NAMES <- toupper(removed)
[16:04:41.440]                 for (kk in seq_along(NAMES)) {
[16:04:41.440]                   name <- removed[[kk]]
[16:04:41.440]                   NAME <- NAMES[[kk]]
[16:04:41.440]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.440]                     next
[16:04:41.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.440]                 }
[16:04:41.440]                 if (length(args) > 0) 
[16:04:41.440]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.440]             }
[16:04:41.440]             else {
[16:04:41.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.440]             }
[16:04:41.440]             {
[16:04:41.440]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.440]                   0L) {
[16:04:41.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.440]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.440]                   base::options(opts)
[16:04:41.440]                 }
[16:04:41.440]                 {
[16:04:41.440]                   {
[16:04:41.440]                     NULL
[16:04:41.440]                     RNGkind("Mersenne-Twister")
[16:04:41.440]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.440]                       inherits = FALSE)
[16:04:41.440]                   }
[16:04:41.440]                   options(future.plan = NULL)
[16:04:41.440]                   if (is.na(NA_character_)) 
[16:04:41.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.440]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.440]                   {
[16:04:41.440]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.440]                     if (!future$lazy) 
[16:04:41.440]                       future <- run(future)
[16:04:41.440]                     invisible(future)
[16:04:41.440]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.440]                 }
[16:04:41.440]             }
[16:04:41.440]         }
[16:04:41.440]     })
[16:04:41.440]     if (TRUE) {
[16:04:41.440]         base::sink(type = "output", split = FALSE)
[16:04:41.440]         if (TRUE) {
[16:04:41.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.440]         }
[16:04:41.440]         else {
[16:04:41.440]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.440]         }
[16:04:41.440]         base::close(...future.stdout)
[16:04:41.440]         ...future.stdout <- NULL
[16:04:41.440]     }
[16:04:41.440]     ...future.result$conditions <- ...future.conditions
[16:04:41.440]     ...future.result$finished <- base::Sys.time()
[16:04:41.440]     ...future.result
[16:04:41.440] }
[16:04:41.443] plan(): Setting new future strategy stack:
[16:04:41.443] List of future strategies:
[16:04:41.443] 1. sequential:
[16:04:41.443]    - args: function (..., envir = parent.frame())
[16:04:41.443]    - tweaked: FALSE
[16:04:41.443]    - call: NULL
[16:04:41.443] plan(): nbrOfWorkers() = 1
[16:04:41.444] plan(): Setting new future strategy stack:
[16:04:41.444] List of future strategies:
[16:04:41.444] 1. sequential:
[16:04:41.444]    - args: function (..., envir = parent.frame())
[16:04:41.444]    - tweaked: FALSE
[16:04:41.444]    - call: plan(strategy)
[16:04:41.444] plan(): nbrOfWorkers() = 1
[16:04:41.444] SequentialFuture started (and completed)
[16:04:41.444] - Launch lazy future ... done
[16:04:41.445] run() for ‘SequentialFuture’ ... done
[16:04:41.445] getGlobalsAndPackages() ...
[16:04:41.445] Searching for globals...
[16:04:41.445] 
[16:04:41.445] Searching for globals ... DONE
[16:04:41.445] - globals: [0] <none>
[16:04:41.445] getGlobalsAndPackages() ... DONE
[16:04:41.446] run() for ‘Future’ ...
[16:04:41.446] - state: ‘created’
[16:04:41.446] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.446] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.446] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.446]   - Field: ‘label’
[16:04:41.446]   - Field: ‘local’
[16:04:41.446]   - Field: ‘owner’
[16:04:41.446]   - Field: ‘envir’
[16:04:41.447]   - Field: ‘packages’
[16:04:41.447]   - Field: ‘gc’
[16:04:41.447]   - Field: ‘conditions’
[16:04:41.447]   - Field: ‘expr’
[16:04:41.447]   - Field: ‘uuid’
[16:04:41.447]   - Field: ‘seed’
[16:04:41.447]   - Field: ‘version’
[16:04:41.447]   - Field: ‘result’
[16:04:41.447]   - Field: ‘asynchronous’
[16:04:41.447]   - Field: ‘calls’
[16:04:41.447]   - Field: ‘globals’
[16:04:41.448]   - Field: ‘stdout’
[16:04:41.448]   - Field: ‘earlySignal’
[16:04:41.448]   - Field: ‘lazy’
[16:04:41.448]   - Field: ‘state’
[16:04:41.448] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.448] - Launch lazy future ...
[16:04:41.448] Packages needed by the future expression (n = 0): <none>
[16:04:41.448] Packages needed by future strategies (n = 0): <none>
[16:04:41.449] {
[16:04:41.449]     {
[16:04:41.449]         {
[16:04:41.449]             ...future.startTime <- base::Sys.time()
[16:04:41.449]             {
[16:04:41.449]                 {
[16:04:41.449]                   {
[16:04:41.449]                     base::local({
[16:04:41.449]                       has_future <- base::requireNamespace("future", 
[16:04:41.449]                         quietly = TRUE)
[16:04:41.449]                       if (has_future) {
[16:04:41.449]                         ns <- base::getNamespace("future")
[16:04:41.449]                         version <- ns[[".package"]][["version"]]
[16:04:41.449]                         if (is.null(version)) 
[16:04:41.449]                           version <- utils::packageVersion("future")
[16:04:41.449]                       }
[16:04:41.449]                       else {
[16:04:41.449]                         version <- NULL
[16:04:41.449]                       }
[16:04:41.449]                       if (!has_future || version < "1.8.0") {
[16:04:41.449]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.449]                           "", base::R.version$version.string), 
[16:04:41.449]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.449]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.449]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.449]                             "release", "version")], collapse = " "), 
[16:04:41.449]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.449]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.449]                           info)
[16:04:41.449]                         info <- base::paste(info, collapse = "; ")
[16:04:41.449]                         if (!has_future) {
[16:04:41.449]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.449]                             info)
[16:04:41.449]                         }
[16:04:41.449]                         else {
[16:04:41.449]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.449]                             info, version)
[16:04:41.449]                         }
[16:04:41.449]                         base::stop(msg)
[16:04:41.449]                       }
[16:04:41.449]                     })
[16:04:41.449]                   }
[16:04:41.449]                   options(future.plan = NULL)
[16:04:41.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.449]                 }
[16:04:41.449]                 ...future.workdir <- getwd()
[16:04:41.449]             }
[16:04:41.449]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.449]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.449]         }
[16:04:41.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.449]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.449]             base::names(...future.oldOptions))
[16:04:41.449]     }
[16:04:41.449]     if (FALSE) {
[16:04:41.449]     }
[16:04:41.449]     else {
[16:04:41.449]         if (TRUE) {
[16:04:41.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.449]                 open = "w")
[16:04:41.449]         }
[16:04:41.449]         else {
[16:04:41.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.449]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.449]         }
[16:04:41.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.449]             base::sink(type = "output", split = FALSE)
[16:04:41.449]             base::close(...future.stdout)
[16:04:41.449]         }, add = TRUE)
[16:04:41.449]     }
[16:04:41.449]     ...future.frame <- base::sys.nframe()
[16:04:41.449]     ...future.conditions <- base::list()
[16:04:41.449]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.449]     if (FALSE) {
[16:04:41.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.449]     }
[16:04:41.449]     ...future.result <- base::tryCatch({
[16:04:41.449]         base::withCallingHandlers({
[16:04:41.449]             ...future.value <- base::withVisible(base::local(NULL))
[16:04:41.449]             future::FutureResult(value = ...future.value$value, 
[16:04:41.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.449]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.449]                     ...future.globalenv.names))
[16:04:41.449]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.449]         }, condition = base::local({
[16:04:41.449]             c <- base::c
[16:04:41.449]             inherits <- base::inherits
[16:04:41.449]             invokeRestart <- base::invokeRestart
[16:04:41.449]             length <- base::length
[16:04:41.449]             list <- base::list
[16:04:41.449]             seq.int <- base::seq.int
[16:04:41.449]             signalCondition <- base::signalCondition
[16:04:41.449]             sys.calls <- base::sys.calls
[16:04:41.449]             `[[` <- base::`[[`
[16:04:41.449]             `+` <- base::`+`
[16:04:41.449]             `<<-` <- base::`<<-`
[16:04:41.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.449]                   3L)]
[16:04:41.449]             }
[16:04:41.449]             function(cond) {
[16:04:41.449]                 is_error <- inherits(cond, "error")
[16:04:41.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.449]                   NULL)
[16:04:41.449]                 if (is_error) {
[16:04:41.449]                   sessionInformation <- function() {
[16:04:41.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.449]                       search = base::search(), system = base::Sys.info())
[16:04:41.449]                   }
[16:04:41.449]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.449]                     cond$call), session = sessionInformation(), 
[16:04:41.449]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.449]                   signalCondition(cond)
[16:04:41.449]                 }
[16:04:41.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.449]                 "immediateCondition"))) {
[16:04:41.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.449]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.449]                   if (TRUE && !signal) {
[16:04:41.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.449]                     {
[16:04:41.449]                       inherits <- base::inherits
[16:04:41.449]                       invokeRestart <- base::invokeRestart
[16:04:41.449]                       is.null <- base::is.null
[16:04:41.449]                       muffled <- FALSE
[16:04:41.449]                       if (inherits(cond, "message")) {
[16:04:41.449]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.449]                         if (muffled) 
[16:04:41.449]                           invokeRestart("muffleMessage")
[16:04:41.449]                       }
[16:04:41.449]                       else if (inherits(cond, "warning")) {
[16:04:41.449]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.449]                         if (muffled) 
[16:04:41.449]                           invokeRestart("muffleWarning")
[16:04:41.449]                       }
[16:04:41.449]                       else if (inherits(cond, "condition")) {
[16:04:41.449]                         if (!is.null(pattern)) {
[16:04:41.449]                           computeRestarts <- base::computeRestarts
[16:04:41.449]                           grepl <- base::grepl
[16:04:41.449]                           restarts <- computeRestarts(cond)
[16:04:41.449]                           for (restart in restarts) {
[16:04:41.449]                             name <- restart$name
[16:04:41.449]                             if (is.null(name)) 
[16:04:41.449]                               next
[16:04:41.449]                             if (!grepl(pattern, name)) 
[16:04:41.449]                               next
[16:04:41.449]                             invokeRestart(restart)
[16:04:41.449]                             muffled <- TRUE
[16:04:41.449]                             break
[16:04:41.449]                           }
[16:04:41.449]                         }
[16:04:41.449]                       }
[16:04:41.449]                       invisible(muffled)
[16:04:41.449]                     }
[16:04:41.449]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.449]                   }
[16:04:41.449]                 }
[16:04:41.449]                 else {
[16:04:41.449]                   if (TRUE) {
[16:04:41.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.449]                     {
[16:04:41.449]                       inherits <- base::inherits
[16:04:41.449]                       invokeRestart <- base::invokeRestart
[16:04:41.449]                       is.null <- base::is.null
[16:04:41.449]                       muffled <- FALSE
[16:04:41.449]                       if (inherits(cond, "message")) {
[16:04:41.449]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.449]                         if (muffled) 
[16:04:41.449]                           invokeRestart("muffleMessage")
[16:04:41.449]                       }
[16:04:41.449]                       else if (inherits(cond, "warning")) {
[16:04:41.449]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.449]                         if (muffled) 
[16:04:41.449]                           invokeRestart("muffleWarning")
[16:04:41.449]                       }
[16:04:41.449]                       else if (inherits(cond, "condition")) {
[16:04:41.449]                         if (!is.null(pattern)) {
[16:04:41.449]                           computeRestarts <- base::computeRestarts
[16:04:41.449]                           grepl <- base::grepl
[16:04:41.449]                           restarts <- computeRestarts(cond)
[16:04:41.449]                           for (restart in restarts) {
[16:04:41.449]                             name <- restart$name
[16:04:41.449]                             if (is.null(name)) 
[16:04:41.449]                               next
[16:04:41.449]                             if (!grepl(pattern, name)) 
[16:04:41.449]                               next
[16:04:41.449]                             invokeRestart(restart)
[16:04:41.449]                             muffled <- TRUE
[16:04:41.449]                             break
[16:04:41.449]                           }
[16:04:41.449]                         }
[16:04:41.449]                       }
[16:04:41.449]                       invisible(muffled)
[16:04:41.449]                     }
[16:04:41.449]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.449]                   }
[16:04:41.449]                 }
[16:04:41.449]             }
[16:04:41.449]         }))
[16:04:41.449]     }, error = function(ex) {
[16:04:41.449]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.449]                 ...future.rng), started = ...future.startTime, 
[16:04:41.449]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.449]             version = "1.8"), class = "FutureResult")
[16:04:41.449]     }, finally = {
[16:04:41.449]         if (!identical(...future.workdir, getwd())) 
[16:04:41.449]             setwd(...future.workdir)
[16:04:41.449]         {
[16:04:41.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.449]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.449]             }
[16:04:41.449]             base::options(...future.oldOptions)
[16:04:41.449]             if (.Platform$OS.type == "windows") {
[16:04:41.449]                 old_names <- names(...future.oldEnvVars)
[16:04:41.449]                 envs <- base::Sys.getenv()
[16:04:41.449]                 names <- names(envs)
[16:04:41.449]                 common <- intersect(names, old_names)
[16:04:41.449]                 added <- setdiff(names, old_names)
[16:04:41.449]                 removed <- setdiff(old_names, names)
[16:04:41.449]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.449]                   envs[common]]
[16:04:41.449]                 NAMES <- toupper(changed)
[16:04:41.449]                 args <- list()
[16:04:41.449]                 for (kk in seq_along(NAMES)) {
[16:04:41.449]                   name <- changed[[kk]]
[16:04:41.449]                   NAME <- NAMES[[kk]]
[16:04:41.449]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.449]                     next
[16:04:41.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.449]                 }
[16:04:41.449]                 NAMES <- toupper(added)
[16:04:41.449]                 for (kk in seq_along(NAMES)) {
[16:04:41.449]                   name <- added[[kk]]
[16:04:41.449]                   NAME <- NAMES[[kk]]
[16:04:41.449]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.449]                     next
[16:04:41.449]                   args[[name]] <- ""
[16:04:41.449]                 }
[16:04:41.449]                 NAMES <- toupper(removed)
[16:04:41.449]                 for (kk in seq_along(NAMES)) {
[16:04:41.449]                   name <- removed[[kk]]
[16:04:41.449]                   NAME <- NAMES[[kk]]
[16:04:41.449]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.449]                     next
[16:04:41.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.449]                 }
[16:04:41.449]                 if (length(args) > 0) 
[16:04:41.449]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.449]             }
[16:04:41.449]             else {
[16:04:41.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.449]             }
[16:04:41.449]             {
[16:04:41.449]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.449]                   0L) {
[16:04:41.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.449]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.449]                   base::options(opts)
[16:04:41.449]                 }
[16:04:41.449]                 {
[16:04:41.449]                   {
[16:04:41.449]                     NULL
[16:04:41.449]                     RNGkind("Mersenne-Twister")
[16:04:41.449]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.449]                       inherits = FALSE)
[16:04:41.449]                   }
[16:04:41.449]                   options(future.plan = NULL)
[16:04:41.449]                   if (is.na(NA_character_)) 
[16:04:41.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.449]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.449]                   {
[16:04:41.449]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.449]                     if (!future$lazy) 
[16:04:41.449]                       future <- run(future)
[16:04:41.449]                     invisible(future)
[16:04:41.449]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.449]                 }
[16:04:41.449]             }
[16:04:41.449]         }
[16:04:41.449]     })
[16:04:41.449]     if (TRUE) {
[16:04:41.449]         base::sink(type = "output", split = FALSE)
[16:04:41.449]         if (TRUE) {
[16:04:41.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.449]         }
[16:04:41.449]         else {
[16:04:41.449]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.449]         }
[16:04:41.449]         base::close(...future.stdout)
[16:04:41.449]         ...future.stdout <- NULL
[16:04:41.449]     }
[16:04:41.449]     ...future.result$conditions <- ...future.conditions
[16:04:41.449]     ...future.result$finished <- base::Sys.time()
[16:04:41.449]     ...future.result
[16:04:41.449] }
[16:04:41.450] plan(): Setting new future strategy stack:
[16:04:41.450] List of future strategies:
[16:04:41.450] 1. sequential:
[16:04:41.450]    - args: function (..., envir = parent.frame())
[16:04:41.450]    - tweaked: FALSE
[16:04:41.450]    - call: NULL
[16:04:41.451] plan(): nbrOfWorkers() = 1
[16:04:41.451] plan(): Setting new future strategy stack:
[16:04:41.452] List of future strategies:
[16:04:41.452] 1. sequential:
[16:04:41.452]    - args: function (..., envir = parent.frame())
[16:04:41.452]    - tweaked: FALSE
[16:04:41.452]    - call: plan(strategy)
[16:04:41.452] plan(): nbrOfWorkers() = 1
[16:04:41.452] SequentialFuture started (and completed)
[16:04:41.452] - Launch lazy future ... done
[16:04:41.452] run() for ‘SequentialFuture’ ... done
[16:04:41.453] getGlobalsAndPackages() ...
[16:04:41.453] Searching for globals...
[16:04:41.453] - globals found: [1] ‘{’
[16:04:41.453] Searching for globals ... DONE
[16:04:41.453] Resolving globals: FALSE
[16:04:41.454] 
[16:04:41.454] 
[16:04:41.454] getGlobalsAndPackages() ... DONE
[16:04:41.454] run() for ‘Future’ ...
[16:04:41.454] - state: ‘created’
[16:04:41.454] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:41.454] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:41.455] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:41.455]   - Field: ‘label’
[16:04:41.455]   - Field: ‘local’
[16:04:41.455]   - Field: ‘owner’
[16:04:41.455]   - Field: ‘envir’
[16:04:41.455]   - Field: ‘packages’
[16:04:41.455]   - Field: ‘gc’
[16:04:41.455]   - Field: ‘conditions’
[16:04:41.455]   - Field: ‘expr’
[16:04:41.455]   - Field: ‘uuid’
[16:04:41.455]   - Field: ‘seed’
[16:04:41.456]   - Field: ‘version’
[16:04:41.456]   - Field: ‘result’
[16:04:41.456]   - Field: ‘asynchronous’
[16:04:41.456]   - Field: ‘calls’
[16:04:41.456]   - Field: ‘globals’
[16:04:41.456]   - Field: ‘stdout’
[16:04:41.456]   - Field: ‘earlySignal’
[16:04:41.456]   - Field: ‘lazy’
[16:04:41.456]   - Field: ‘state’
[16:04:41.456] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:41.456] - Launch lazy future ...
[16:04:41.457] Packages needed by the future expression (n = 0): <none>
[16:04:41.457] Packages needed by future strategies (n = 0): <none>
[16:04:41.457] {
[16:04:41.457]     {
[16:04:41.457]         {
[16:04:41.457]             ...future.startTime <- base::Sys.time()
[16:04:41.457]             {
[16:04:41.457]                 {
[16:04:41.457]                   {
[16:04:41.457]                     base::local({
[16:04:41.457]                       has_future <- base::requireNamespace("future", 
[16:04:41.457]                         quietly = TRUE)
[16:04:41.457]                       if (has_future) {
[16:04:41.457]                         ns <- base::getNamespace("future")
[16:04:41.457]                         version <- ns[[".package"]][["version"]]
[16:04:41.457]                         if (is.null(version)) 
[16:04:41.457]                           version <- utils::packageVersion("future")
[16:04:41.457]                       }
[16:04:41.457]                       else {
[16:04:41.457]                         version <- NULL
[16:04:41.457]                       }
[16:04:41.457]                       if (!has_future || version < "1.8.0") {
[16:04:41.457]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.457]                           "", base::R.version$version.string), 
[16:04:41.457]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:41.457]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.457]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.457]                             "release", "version")], collapse = " "), 
[16:04:41.457]                           hostname = base::Sys.info()[["nodename"]])
[16:04:41.457]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.457]                           info)
[16:04:41.457]                         info <- base::paste(info, collapse = "; ")
[16:04:41.457]                         if (!has_future) {
[16:04:41.457]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.457]                             info)
[16:04:41.457]                         }
[16:04:41.457]                         else {
[16:04:41.457]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.457]                             info, version)
[16:04:41.457]                         }
[16:04:41.457]                         base::stop(msg)
[16:04:41.457]                       }
[16:04:41.457]                     })
[16:04:41.457]                   }
[16:04:41.457]                   options(future.plan = NULL)
[16:04:41.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.457]                 }
[16:04:41.457]                 ...future.workdir <- getwd()
[16:04:41.457]             }
[16:04:41.457]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.457]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.457]         }
[16:04:41.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.457]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.457]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.457]             base::names(...future.oldOptions))
[16:04:41.457]     }
[16:04:41.457]     if (FALSE) {
[16:04:41.457]     }
[16:04:41.457]     else {
[16:04:41.457]         if (TRUE) {
[16:04:41.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.457]                 open = "w")
[16:04:41.457]         }
[16:04:41.457]         else {
[16:04:41.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.457]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.457]         }
[16:04:41.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.457]             base::sink(type = "output", split = FALSE)
[16:04:41.457]             base::close(...future.stdout)
[16:04:41.457]         }, add = TRUE)
[16:04:41.457]     }
[16:04:41.457]     ...future.frame <- base::sys.nframe()
[16:04:41.457]     ...future.conditions <- base::list()
[16:04:41.457]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.457]     if (FALSE) {
[16:04:41.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.457]     }
[16:04:41.457]     ...future.result <- base::tryCatch({
[16:04:41.457]         base::withCallingHandlers({
[16:04:41.457]             ...future.value <- base::withVisible(base::local({
[16:04:41.457]                 4
[16:04:41.457]             }))
[16:04:41.457]             future::FutureResult(value = ...future.value$value, 
[16:04:41.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.457]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.457]                     ...future.globalenv.names))
[16:04:41.457]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.457]         }, condition = base::local({
[16:04:41.457]             c <- base::c
[16:04:41.457]             inherits <- base::inherits
[16:04:41.457]             invokeRestart <- base::invokeRestart
[16:04:41.457]             length <- base::length
[16:04:41.457]             list <- base::list
[16:04:41.457]             seq.int <- base::seq.int
[16:04:41.457]             signalCondition <- base::signalCondition
[16:04:41.457]             sys.calls <- base::sys.calls
[16:04:41.457]             `[[` <- base::`[[`
[16:04:41.457]             `+` <- base::`+`
[16:04:41.457]             `<<-` <- base::`<<-`
[16:04:41.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.457]                   3L)]
[16:04:41.457]             }
[16:04:41.457]             function(cond) {
[16:04:41.457]                 is_error <- inherits(cond, "error")
[16:04:41.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.457]                   NULL)
[16:04:41.457]                 if (is_error) {
[16:04:41.457]                   sessionInformation <- function() {
[16:04:41.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.457]                       search = base::search(), system = base::Sys.info())
[16:04:41.457]                   }
[16:04:41.457]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.457]                     cond$call), session = sessionInformation(), 
[16:04:41.457]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.457]                   signalCondition(cond)
[16:04:41.457]                 }
[16:04:41.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.457]                 "immediateCondition"))) {
[16:04:41.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.457]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.457]                   if (TRUE && !signal) {
[16:04:41.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.457]                     {
[16:04:41.457]                       inherits <- base::inherits
[16:04:41.457]                       invokeRestart <- base::invokeRestart
[16:04:41.457]                       is.null <- base::is.null
[16:04:41.457]                       muffled <- FALSE
[16:04:41.457]                       if (inherits(cond, "message")) {
[16:04:41.457]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.457]                         if (muffled) 
[16:04:41.457]                           invokeRestart("muffleMessage")
[16:04:41.457]                       }
[16:04:41.457]                       else if (inherits(cond, "warning")) {
[16:04:41.457]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.457]                         if (muffled) 
[16:04:41.457]                           invokeRestart("muffleWarning")
[16:04:41.457]                       }
[16:04:41.457]                       else if (inherits(cond, "condition")) {
[16:04:41.457]                         if (!is.null(pattern)) {
[16:04:41.457]                           computeRestarts <- base::computeRestarts
[16:04:41.457]                           grepl <- base::grepl
[16:04:41.457]                           restarts <- computeRestarts(cond)
[16:04:41.457]                           for (restart in restarts) {
[16:04:41.457]                             name <- restart$name
[16:04:41.457]                             if (is.null(name)) 
[16:04:41.457]                               next
[16:04:41.457]                             if (!grepl(pattern, name)) 
[16:04:41.457]                               next
[16:04:41.457]                             invokeRestart(restart)
[16:04:41.457]                             muffled <- TRUE
[16:04:41.457]                             break
[16:04:41.457]                           }
[16:04:41.457]                         }
[16:04:41.457]                       }
[16:04:41.457]                       invisible(muffled)
[16:04:41.457]                     }
[16:04:41.457]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.457]                   }
[16:04:41.457]                 }
[16:04:41.457]                 else {
[16:04:41.457]                   if (TRUE) {
[16:04:41.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.457]                     {
[16:04:41.457]                       inherits <- base::inherits
[16:04:41.457]                       invokeRestart <- base::invokeRestart
[16:04:41.457]                       is.null <- base::is.null
[16:04:41.457]                       muffled <- FALSE
[16:04:41.457]                       if (inherits(cond, "message")) {
[16:04:41.457]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.457]                         if (muffled) 
[16:04:41.457]                           invokeRestart("muffleMessage")
[16:04:41.457]                       }
[16:04:41.457]                       else if (inherits(cond, "warning")) {
[16:04:41.457]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.457]                         if (muffled) 
[16:04:41.457]                           invokeRestart("muffleWarning")
[16:04:41.457]                       }
[16:04:41.457]                       else if (inherits(cond, "condition")) {
[16:04:41.457]                         if (!is.null(pattern)) {
[16:04:41.457]                           computeRestarts <- base::computeRestarts
[16:04:41.457]                           grepl <- base::grepl
[16:04:41.457]                           restarts <- computeRestarts(cond)
[16:04:41.457]                           for (restart in restarts) {
[16:04:41.457]                             name <- restart$name
[16:04:41.457]                             if (is.null(name)) 
[16:04:41.457]                               next
[16:04:41.457]                             if (!grepl(pattern, name)) 
[16:04:41.457]                               next
[16:04:41.457]                             invokeRestart(restart)
[16:04:41.457]                             muffled <- TRUE
[16:04:41.457]                             break
[16:04:41.457]                           }
[16:04:41.457]                         }
[16:04:41.457]                       }
[16:04:41.457]                       invisible(muffled)
[16:04:41.457]                     }
[16:04:41.457]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.457]                   }
[16:04:41.457]                 }
[16:04:41.457]             }
[16:04:41.457]         }))
[16:04:41.457]     }, error = function(ex) {
[16:04:41.457]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.457]                 ...future.rng), started = ...future.startTime, 
[16:04:41.457]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.457]             version = "1.8"), class = "FutureResult")
[16:04:41.457]     }, finally = {
[16:04:41.457]         if (!identical(...future.workdir, getwd())) 
[16:04:41.457]             setwd(...future.workdir)
[16:04:41.457]         {
[16:04:41.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.457]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.457]             }
[16:04:41.457]             base::options(...future.oldOptions)
[16:04:41.457]             if (.Platform$OS.type == "windows") {
[16:04:41.457]                 old_names <- names(...future.oldEnvVars)
[16:04:41.457]                 envs <- base::Sys.getenv()
[16:04:41.457]                 names <- names(envs)
[16:04:41.457]                 common <- intersect(names, old_names)
[16:04:41.457]                 added <- setdiff(names, old_names)
[16:04:41.457]                 removed <- setdiff(old_names, names)
[16:04:41.457]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.457]                   envs[common]]
[16:04:41.457]                 NAMES <- toupper(changed)
[16:04:41.457]                 args <- list()
[16:04:41.457]                 for (kk in seq_along(NAMES)) {
[16:04:41.457]                   name <- changed[[kk]]
[16:04:41.457]                   NAME <- NAMES[[kk]]
[16:04:41.457]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.457]                     next
[16:04:41.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.457]                 }
[16:04:41.457]                 NAMES <- toupper(added)
[16:04:41.457]                 for (kk in seq_along(NAMES)) {
[16:04:41.457]                   name <- added[[kk]]
[16:04:41.457]                   NAME <- NAMES[[kk]]
[16:04:41.457]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.457]                     next
[16:04:41.457]                   args[[name]] <- ""
[16:04:41.457]                 }
[16:04:41.457]                 NAMES <- toupper(removed)
[16:04:41.457]                 for (kk in seq_along(NAMES)) {
[16:04:41.457]                   name <- removed[[kk]]
[16:04:41.457]                   NAME <- NAMES[[kk]]
[16:04:41.457]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.457]                     next
[16:04:41.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.457]                 }
[16:04:41.457]                 if (length(args) > 0) 
[16:04:41.457]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.457]             }
[16:04:41.457]             else {
[16:04:41.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.457]             }
[16:04:41.457]             {
[16:04:41.457]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.457]                   0L) {
[16:04:41.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.457]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.457]                   base::options(opts)
[16:04:41.457]                 }
[16:04:41.457]                 {
[16:04:41.457]                   {
[16:04:41.457]                     NULL
[16:04:41.457]                     RNGkind("Mersenne-Twister")
[16:04:41.457]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:41.457]                       inherits = FALSE)
[16:04:41.457]                   }
[16:04:41.457]                   options(future.plan = NULL)
[16:04:41.457]                   if (is.na(NA_character_)) 
[16:04:41.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.457]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:41.457]                   {
[16:04:41.457]                     future <- SequentialFuture(..., envir = envir)
[16:04:41.457]                     if (!future$lazy) 
[16:04:41.457]                       future <- run(future)
[16:04:41.457]                     invisible(future)
[16:04:41.457]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.457]                 }
[16:04:41.457]             }
[16:04:41.457]         }
[16:04:41.457]     })
[16:04:41.457]     if (TRUE) {
[16:04:41.457]         base::sink(type = "output", split = FALSE)
[16:04:41.457]         if (TRUE) {
[16:04:41.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.457]         }
[16:04:41.457]         else {
[16:04:41.457]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.457]         }
[16:04:41.457]         base::close(...future.stdout)
[16:04:41.457]         ...future.stdout <- NULL
[16:04:41.457]     }
[16:04:41.457]     ...future.result$conditions <- ...future.conditions
[16:04:41.457]     ...future.result$finished <- base::Sys.time()
[16:04:41.457]     ...future.result
[16:04:41.457] }
[16:04:41.459] plan(): Setting new future strategy stack:
[16:04:41.459] List of future strategies:
[16:04:41.459] 1. sequential:
[16:04:41.459]    - args: function (..., envir = parent.frame())
[16:04:41.459]    - tweaked: FALSE
[16:04:41.459]    - call: NULL
[16:04:41.459] plan(): nbrOfWorkers() = 1
[16:04:41.460] plan(): Setting new future strategy stack:
[16:04:41.460] List of future strategies:
[16:04:41.460] 1. sequential:
[16:04:41.460]    - args: function (..., envir = parent.frame())
[16:04:41.460]    - tweaked: FALSE
[16:04:41.460]    - call: plan(strategy)
[16:04:41.460] plan(): nbrOfWorkers() = 1
[16:04:41.460] SequentialFuture started (and completed)
[16:04:41.461] - Launch lazy future ... done
[16:04:41.461] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55874def3090> 
Classes 'listenv', 'environment' <environment: 0x55874dbd7a10> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:04:41.464] resolved() for ‘SequentialFuture’ ...
[16:04:41.465] - state: ‘finished’
[16:04:41.465] - run: TRUE
[16:04:41.465] - result: ‘FutureResult’
[16:04:41.465] resolved() for ‘SequentialFuture’ ... done
[16:04:41.465] resolved() for ‘SequentialFuture’ ...
[16:04:41.465] - state: ‘finished’
[16:04:41.465] - run: TRUE
[16:04:41.465] - result: ‘FutureResult’
[16:04:41.465] resolved() for ‘SequentialFuture’ ... done
[16:04:41.465] resolved() for ‘SequentialFuture’ ...
[16:04:41.465] - state: ‘finished’
[16:04:41.465] - run: TRUE
[16:04:41.466] - result: ‘FutureResult’
[16:04:41.466] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:41.469] resolve() on list environment ...
[16:04:41.470]  recursive: 0
[16:04:41.470]  length: 6
[16:04:41.471]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:41.471] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.471] - nx: 6
[16:04:41.471] - relay: TRUE
[16:04:41.471] - stdout: TRUE
[16:04:41.471] - signal: TRUE
[16:04:41.471] - resignal: FALSE
[16:04:41.471] - force: TRUE
[16:04:41.471] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.471] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.471]  - until=2
[16:04:41.472]  - relaying element #2
[16:04:41.472] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.472] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.472] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.472]  length: 5 (resolved future 1)
[16:04:41.472] resolved() for ‘SequentialFuture’ ...
[16:04:41.472] - state: ‘finished’
[16:04:41.472] - run: TRUE
[16:04:41.472] - result: ‘FutureResult’
[16:04:41.472] resolved() for ‘SequentialFuture’ ... done
[16:04:41.472] Future #2
[16:04:41.473] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:04:41.473] - nx: 6
[16:04:41.473] - relay: TRUE
[16:04:41.473] - stdout: TRUE
[16:04:41.473] - signal: TRUE
[16:04:41.473] - resignal: FALSE
[16:04:41.473] - force: TRUE
[16:04:41.473] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.473] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.473]  - until=2
[16:04:41.473]  - relaying element #2
[16:04:41.474] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.474] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.474] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:04:41.474]  length: 4 (resolved future 2)
[16:04:41.474] resolved() for ‘SequentialFuture’ ...
[16:04:41.474] - state: ‘finished’
[16:04:41.474] - run: TRUE
[16:04:41.474] - result: ‘FutureResult’
[16:04:41.474] resolved() for ‘SequentialFuture’ ... done
[16:04:41.474] Future #3
[16:04:41.474] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:04:41.475] - nx: 6
[16:04:41.475] - relay: TRUE
[16:04:41.475] - stdout: TRUE
[16:04:41.475] - signal: TRUE
[16:04:41.475] - resignal: FALSE
[16:04:41.475] - force: TRUE
[16:04:41.475] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.475] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.475]  - until=3
[16:04:41.475]  - relaying element #3
[16:04:41.476] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.476] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.476] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:04:41.476]  length: 3 (resolved future 3)
[16:04:41.476] resolved() for ‘SequentialFuture’ ...
[16:04:41.476] - state: ‘finished’
[16:04:41.476] - run: TRUE
[16:04:41.476] - result: ‘FutureResult’
[16:04:41.476] resolved() for ‘SequentialFuture’ ... done
[16:04:41.476] Future #4
[16:04:41.476] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:04:41.477] - nx: 6
[16:04:41.477] - relay: TRUE
[16:04:41.477] - stdout: TRUE
[16:04:41.477] - signal: TRUE
[16:04:41.477] - resignal: FALSE
[16:04:41.477] - force: TRUE
[16:04:41.477] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.477] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.477]  - until=4
[16:04:41.477]  - relaying element #4
[16:04:41.477] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.478] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.478] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:04:41.478]  length: 2 (resolved future 4)
[16:04:41.478] signalConditionsASAP(NULL, pos=5) ...
[16:04:41.478] - nx: 6
[16:04:41.478] - relay: TRUE
[16:04:41.478] - stdout: TRUE
[16:04:41.478] - signal: TRUE
[16:04:41.478] - resignal: FALSE
[16:04:41.478] - force: TRUE
[16:04:41.478] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.478] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.478]  - until=6
[16:04:41.479]  - relaying element #6
[16:04:41.479] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.479] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.479] signalConditionsASAP(NULL, pos=5) ... done
[16:04:41.479]  length: 1 (resolved future 5)
[16:04:41.479] signalConditionsASAP(numeric, pos=6) ...
[16:04:41.479] - nx: 6
[16:04:41.479] - relay: TRUE
[16:04:41.479] - stdout: TRUE
[16:04:41.479] - signal: TRUE
[16:04:41.479] - resignal: FALSE
[16:04:41.479] - force: TRUE
[16:04:41.480] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.480] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.480]  - until=6
[16:04:41.480] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.480] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.480] signalConditionsASAP(numeric, pos=6) ... done
[16:04:41.480]  length: 0 (resolved future 6)
[16:04:41.480] Relaying remaining futures
[16:04:41.480] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.480] - nx: 6
[16:04:41.480] - relay: TRUE
[16:04:41.480] - stdout: TRUE
[16:04:41.481] - signal: TRUE
[16:04:41.481] - resignal: FALSE
[16:04:41.481] - force: TRUE
[16:04:41.481] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.481] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:41.481] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.481] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.481] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.481] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55874e42b3f0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[16:04:41.484] plan(): Setting new future strategy stack:
[16:04:41.484] List of future strategies:
[16:04:41.484] 1. multicore:
[16:04:41.484]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:41.484]    - tweaked: FALSE
[16:04:41.484]    - call: plan(strategy)
[16:04:41.488] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:04:41.488] getGlobalsAndPackages() ...
[16:04:41.488] Searching for globals...
[16:04:41.489] 
[16:04:41.489] Searching for globals ... DONE
[16:04:41.489] - globals: [0] <none>
[16:04:41.489] getGlobalsAndPackages() ... DONE
[16:04:41.489] run() for ‘Future’ ...
[16:04:41.489] - state: ‘created’
[16:04:41.489] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:41.493] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:41.493] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:41.493]   - Field: ‘label’
[16:04:41.493]   - Field: ‘local’
[16:04:41.493]   - Field: ‘owner’
[16:04:41.493]   - Field: ‘envir’
[16:04:41.493]   - Field: ‘workers’
[16:04:41.493]   - Field: ‘packages’
[16:04:41.493]   - Field: ‘gc’
[16:04:41.494]   - Field: ‘job’
[16:04:41.494]   - Field: ‘conditions’
[16:04:41.494]   - Field: ‘expr’
[16:04:41.494]   - Field: ‘uuid’
[16:04:41.494]   - Field: ‘seed’
[16:04:41.494]   - Field: ‘version’
[16:04:41.494]   - Field: ‘result’
[16:04:41.494]   - Field: ‘asynchronous’
[16:04:41.494]   - Field: ‘calls’
[16:04:41.494]   - Field: ‘globals’
[16:04:41.494]   - Field: ‘stdout’
[16:04:41.495]   - Field: ‘earlySignal’
[16:04:41.495]   - Field: ‘lazy’
[16:04:41.495]   - Field: ‘state’
[16:04:41.495] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:41.495] - Launch lazy future ...
[16:04:41.496] Packages needed by the future expression (n = 0): <none>
[16:04:41.496] Packages needed by future strategies (n = 0): <none>
[16:04:41.498] {
[16:04:41.498]     {
[16:04:41.498]         {
[16:04:41.498]             ...future.startTime <- base::Sys.time()
[16:04:41.498]             {
[16:04:41.498]                 {
[16:04:41.498]                   {
[16:04:41.498]                     {
[16:04:41.498]                       base::local({
[16:04:41.498]                         has_future <- base::requireNamespace("future", 
[16:04:41.498]                           quietly = TRUE)
[16:04:41.498]                         if (has_future) {
[16:04:41.498]                           ns <- base::getNamespace("future")
[16:04:41.498]                           version <- ns[[".package"]][["version"]]
[16:04:41.498]                           if (is.null(version)) 
[16:04:41.498]                             version <- utils::packageVersion("future")
[16:04:41.498]                         }
[16:04:41.498]                         else {
[16:04:41.498]                           version <- NULL
[16:04:41.498]                         }
[16:04:41.498]                         if (!has_future || version < "1.8.0") {
[16:04:41.498]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.498]                             "", base::R.version$version.string), 
[16:04:41.498]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:41.498]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.498]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.498]                               "release", "version")], collapse = " "), 
[16:04:41.498]                             hostname = base::Sys.info()[["nodename"]])
[16:04:41.498]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.498]                             info)
[16:04:41.498]                           info <- base::paste(info, collapse = "; ")
[16:04:41.498]                           if (!has_future) {
[16:04:41.498]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.498]                               info)
[16:04:41.498]                           }
[16:04:41.498]                           else {
[16:04:41.498]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.498]                               info, version)
[16:04:41.498]                           }
[16:04:41.498]                           base::stop(msg)
[16:04:41.498]                         }
[16:04:41.498]                       })
[16:04:41.498]                     }
[16:04:41.498]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:41.498]                     base::options(mc.cores = 1L)
[16:04:41.498]                   }
[16:04:41.498]                   options(future.plan = NULL)
[16:04:41.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.498]                 }
[16:04:41.498]                 ...future.workdir <- getwd()
[16:04:41.498]             }
[16:04:41.498]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.498]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.498]         }
[16:04:41.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.498]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.498]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.498]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.498]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.498]             base::names(...future.oldOptions))
[16:04:41.498]     }
[16:04:41.498]     if (FALSE) {
[16:04:41.498]     }
[16:04:41.498]     else {
[16:04:41.498]         if (TRUE) {
[16:04:41.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.498]                 open = "w")
[16:04:41.498]         }
[16:04:41.498]         else {
[16:04:41.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.498]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.498]         }
[16:04:41.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.498]             base::sink(type = "output", split = FALSE)
[16:04:41.498]             base::close(...future.stdout)
[16:04:41.498]         }, add = TRUE)
[16:04:41.498]     }
[16:04:41.498]     ...future.frame <- base::sys.nframe()
[16:04:41.498]     ...future.conditions <- base::list()
[16:04:41.498]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.498]     if (FALSE) {
[16:04:41.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.498]     }
[16:04:41.498]     ...future.result <- base::tryCatch({
[16:04:41.498]         base::withCallingHandlers({
[16:04:41.498]             ...future.value <- base::withVisible(base::local({
[16:04:41.498]                 withCallingHandlers({
[16:04:41.498]                   2
[16:04:41.498]                 }, immediateCondition = function(cond) {
[16:04:41.498]                   save_rds <- function (object, pathname, ...) 
[16:04:41.498]                   {
[16:04:41.498]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:41.498]                     if (file_test("-f", pathname_tmp)) {
[16:04:41.498]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.498]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:41.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.498]                         fi_tmp[["mtime"]])
[16:04:41.498]                     }
[16:04:41.498]                     tryCatch({
[16:04:41.498]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:41.498]                     }, error = function(ex) {
[16:04:41.498]                       msg <- conditionMessage(ex)
[16:04:41.498]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.498]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:41.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.498]                         fi_tmp[["mtime"]], msg)
[16:04:41.498]                       ex$message <- msg
[16:04:41.498]                       stop(ex)
[16:04:41.498]                     })
[16:04:41.498]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:41.498]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:41.498]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:41.498]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.498]                       fi <- file.info(pathname)
[16:04:41.498]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:41.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.498]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:41.498]                         fi[["size"]], fi[["mtime"]])
[16:04:41.498]                       stop(msg)
[16:04:41.498]                     }
[16:04:41.498]                     invisible(pathname)
[16:04:41.498]                   }
[16:04:41.498]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:41.498]                     rootPath = tempdir()) 
[16:04:41.498]                   {
[16:04:41.498]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:41.498]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:41.498]                       tmpdir = path, fileext = ".rds")
[16:04:41.498]                     save_rds(obj, file)
[16:04:41.498]                   }
[16:04:41.498]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:41.498]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.498]                   {
[16:04:41.498]                     inherits <- base::inherits
[16:04:41.498]                     invokeRestart <- base::invokeRestart
[16:04:41.498]                     is.null <- base::is.null
[16:04:41.498]                     muffled <- FALSE
[16:04:41.498]                     if (inherits(cond, "message")) {
[16:04:41.498]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:41.498]                       if (muffled) 
[16:04:41.498]                         invokeRestart("muffleMessage")
[16:04:41.498]                     }
[16:04:41.498]                     else if (inherits(cond, "warning")) {
[16:04:41.498]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:41.498]                       if (muffled) 
[16:04:41.498]                         invokeRestart("muffleWarning")
[16:04:41.498]                     }
[16:04:41.498]                     else if (inherits(cond, "condition")) {
[16:04:41.498]                       if (!is.null(pattern)) {
[16:04:41.498]                         computeRestarts <- base::computeRestarts
[16:04:41.498]                         grepl <- base::grepl
[16:04:41.498]                         restarts <- computeRestarts(cond)
[16:04:41.498]                         for (restart in restarts) {
[16:04:41.498]                           name <- restart$name
[16:04:41.498]                           if (is.null(name)) 
[16:04:41.498]                             next
[16:04:41.498]                           if (!grepl(pattern, name)) 
[16:04:41.498]                             next
[16:04:41.498]                           invokeRestart(restart)
[16:04:41.498]                           muffled <- TRUE
[16:04:41.498]                           break
[16:04:41.498]                         }
[16:04:41.498]                       }
[16:04:41.498]                     }
[16:04:41.498]                     invisible(muffled)
[16:04:41.498]                   }
[16:04:41.498]                   muffleCondition(cond)
[16:04:41.498]                 })
[16:04:41.498]             }))
[16:04:41.498]             future::FutureResult(value = ...future.value$value, 
[16:04:41.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.498]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.498]                     ...future.globalenv.names))
[16:04:41.498]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.498]         }, condition = base::local({
[16:04:41.498]             c <- base::c
[16:04:41.498]             inherits <- base::inherits
[16:04:41.498]             invokeRestart <- base::invokeRestart
[16:04:41.498]             length <- base::length
[16:04:41.498]             list <- base::list
[16:04:41.498]             seq.int <- base::seq.int
[16:04:41.498]             signalCondition <- base::signalCondition
[16:04:41.498]             sys.calls <- base::sys.calls
[16:04:41.498]             `[[` <- base::`[[`
[16:04:41.498]             `+` <- base::`+`
[16:04:41.498]             `<<-` <- base::`<<-`
[16:04:41.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.498]                   3L)]
[16:04:41.498]             }
[16:04:41.498]             function(cond) {
[16:04:41.498]                 is_error <- inherits(cond, "error")
[16:04:41.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.498]                   NULL)
[16:04:41.498]                 if (is_error) {
[16:04:41.498]                   sessionInformation <- function() {
[16:04:41.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.498]                       search = base::search(), system = base::Sys.info())
[16:04:41.498]                   }
[16:04:41.498]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.498]                     cond$call), session = sessionInformation(), 
[16:04:41.498]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.498]                   signalCondition(cond)
[16:04:41.498]                 }
[16:04:41.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.498]                 "immediateCondition"))) {
[16:04:41.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.498]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.498]                   if (TRUE && !signal) {
[16:04:41.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.498]                     {
[16:04:41.498]                       inherits <- base::inherits
[16:04:41.498]                       invokeRestart <- base::invokeRestart
[16:04:41.498]                       is.null <- base::is.null
[16:04:41.498]                       muffled <- FALSE
[16:04:41.498]                       if (inherits(cond, "message")) {
[16:04:41.498]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.498]                         if (muffled) 
[16:04:41.498]                           invokeRestart("muffleMessage")
[16:04:41.498]                       }
[16:04:41.498]                       else if (inherits(cond, "warning")) {
[16:04:41.498]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.498]                         if (muffled) 
[16:04:41.498]                           invokeRestart("muffleWarning")
[16:04:41.498]                       }
[16:04:41.498]                       else if (inherits(cond, "condition")) {
[16:04:41.498]                         if (!is.null(pattern)) {
[16:04:41.498]                           computeRestarts <- base::computeRestarts
[16:04:41.498]                           grepl <- base::grepl
[16:04:41.498]                           restarts <- computeRestarts(cond)
[16:04:41.498]                           for (restart in restarts) {
[16:04:41.498]                             name <- restart$name
[16:04:41.498]                             if (is.null(name)) 
[16:04:41.498]                               next
[16:04:41.498]                             if (!grepl(pattern, name)) 
[16:04:41.498]                               next
[16:04:41.498]                             invokeRestart(restart)
[16:04:41.498]                             muffled <- TRUE
[16:04:41.498]                             break
[16:04:41.498]                           }
[16:04:41.498]                         }
[16:04:41.498]                       }
[16:04:41.498]                       invisible(muffled)
[16:04:41.498]                     }
[16:04:41.498]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.498]                   }
[16:04:41.498]                 }
[16:04:41.498]                 else {
[16:04:41.498]                   if (TRUE) {
[16:04:41.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.498]                     {
[16:04:41.498]                       inherits <- base::inherits
[16:04:41.498]                       invokeRestart <- base::invokeRestart
[16:04:41.498]                       is.null <- base::is.null
[16:04:41.498]                       muffled <- FALSE
[16:04:41.498]                       if (inherits(cond, "message")) {
[16:04:41.498]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.498]                         if (muffled) 
[16:04:41.498]                           invokeRestart("muffleMessage")
[16:04:41.498]                       }
[16:04:41.498]                       else if (inherits(cond, "warning")) {
[16:04:41.498]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.498]                         if (muffled) 
[16:04:41.498]                           invokeRestart("muffleWarning")
[16:04:41.498]                       }
[16:04:41.498]                       else if (inherits(cond, "condition")) {
[16:04:41.498]                         if (!is.null(pattern)) {
[16:04:41.498]                           computeRestarts <- base::computeRestarts
[16:04:41.498]                           grepl <- base::grepl
[16:04:41.498]                           restarts <- computeRestarts(cond)
[16:04:41.498]                           for (restart in restarts) {
[16:04:41.498]                             name <- restart$name
[16:04:41.498]                             if (is.null(name)) 
[16:04:41.498]                               next
[16:04:41.498]                             if (!grepl(pattern, name)) 
[16:04:41.498]                               next
[16:04:41.498]                             invokeRestart(restart)
[16:04:41.498]                             muffled <- TRUE
[16:04:41.498]                             break
[16:04:41.498]                           }
[16:04:41.498]                         }
[16:04:41.498]                       }
[16:04:41.498]                       invisible(muffled)
[16:04:41.498]                     }
[16:04:41.498]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.498]                   }
[16:04:41.498]                 }
[16:04:41.498]             }
[16:04:41.498]         }))
[16:04:41.498]     }, error = function(ex) {
[16:04:41.498]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.498]                 ...future.rng), started = ...future.startTime, 
[16:04:41.498]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.498]             version = "1.8"), class = "FutureResult")
[16:04:41.498]     }, finally = {
[16:04:41.498]         if (!identical(...future.workdir, getwd())) 
[16:04:41.498]             setwd(...future.workdir)
[16:04:41.498]         {
[16:04:41.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.498]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.498]             }
[16:04:41.498]             base::options(...future.oldOptions)
[16:04:41.498]             if (.Platform$OS.type == "windows") {
[16:04:41.498]                 old_names <- names(...future.oldEnvVars)
[16:04:41.498]                 envs <- base::Sys.getenv()
[16:04:41.498]                 names <- names(envs)
[16:04:41.498]                 common <- intersect(names, old_names)
[16:04:41.498]                 added <- setdiff(names, old_names)
[16:04:41.498]                 removed <- setdiff(old_names, names)
[16:04:41.498]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.498]                   envs[common]]
[16:04:41.498]                 NAMES <- toupper(changed)
[16:04:41.498]                 args <- list()
[16:04:41.498]                 for (kk in seq_along(NAMES)) {
[16:04:41.498]                   name <- changed[[kk]]
[16:04:41.498]                   NAME <- NAMES[[kk]]
[16:04:41.498]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.498]                     next
[16:04:41.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.498]                 }
[16:04:41.498]                 NAMES <- toupper(added)
[16:04:41.498]                 for (kk in seq_along(NAMES)) {
[16:04:41.498]                   name <- added[[kk]]
[16:04:41.498]                   NAME <- NAMES[[kk]]
[16:04:41.498]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.498]                     next
[16:04:41.498]                   args[[name]] <- ""
[16:04:41.498]                 }
[16:04:41.498]                 NAMES <- toupper(removed)
[16:04:41.498]                 for (kk in seq_along(NAMES)) {
[16:04:41.498]                   name <- removed[[kk]]
[16:04:41.498]                   NAME <- NAMES[[kk]]
[16:04:41.498]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.498]                     next
[16:04:41.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.498]                 }
[16:04:41.498]                 if (length(args) > 0) 
[16:04:41.498]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.498]             }
[16:04:41.498]             else {
[16:04:41.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.498]             }
[16:04:41.498]             {
[16:04:41.498]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.498]                   0L) {
[16:04:41.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.498]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.498]                   base::options(opts)
[16:04:41.498]                 }
[16:04:41.498]                 {
[16:04:41.498]                   {
[16:04:41.498]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:41.498]                     NULL
[16:04:41.498]                   }
[16:04:41.498]                   options(future.plan = NULL)
[16:04:41.498]                   if (is.na(NA_character_)) 
[16:04:41.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.498]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:41.498]                     envir = parent.frame()) 
[16:04:41.498]                   {
[16:04:41.498]                     default_workers <- missing(workers)
[16:04:41.498]                     if (is.function(workers)) 
[16:04:41.498]                       workers <- workers()
[16:04:41.498]                     workers <- structure(as.integer(workers), 
[16:04:41.498]                       class = class(workers))
[16:04:41.498]                     stop_if_not(is.finite(workers), workers >= 
[16:04:41.498]                       1L)
[16:04:41.498]                     if ((workers == 1L && !inherits(workers, 
[16:04:41.498]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:41.498]                       if (default_workers) 
[16:04:41.498]                         supportsMulticore(warn = TRUE)
[16:04:41.498]                       return(sequential(..., envir = envir))
[16:04:41.498]                     }
[16:04:41.498]                     oopts <- options(mc.cores = workers)
[16:04:41.498]                     on.exit(options(oopts))
[16:04:41.498]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:41.498]                       envir = envir)
[16:04:41.498]                     if (!future$lazy) 
[16:04:41.498]                       future <- run(future)
[16:04:41.498]                     invisible(future)
[16:04:41.498]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.498]                 }
[16:04:41.498]             }
[16:04:41.498]         }
[16:04:41.498]     })
[16:04:41.498]     if (TRUE) {
[16:04:41.498]         base::sink(type = "output", split = FALSE)
[16:04:41.498]         if (TRUE) {
[16:04:41.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.498]         }
[16:04:41.498]         else {
[16:04:41.498]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.498]         }
[16:04:41.498]         base::close(...future.stdout)
[16:04:41.498]         ...future.stdout <- NULL
[16:04:41.498]     }
[16:04:41.498]     ...future.result$conditions <- ...future.conditions
[16:04:41.498]     ...future.result$finished <- base::Sys.time()
[16:04:41.498]     ...future.result
[16:04:41.498] }
[16:04:41.500] requestCore(): workers = 2
[16:04:41.503] MulticoreFuture started
[16:04:41.504] - Launch lazy future ... done
[16:04:41.504] plan(): Setting new future strategy stack:
[16:04:41.504] run() for ‘MulticoreFuture’ ... done
[16:04:41.505] getGlobalsAndPackages() ...
[16:04:41.505] List of future strategies:
[16:04:41.505] 1. sequential:
[16:04:41.505]    - args: function (..., envir = parent.frame())
[16:04:41.505]    - tweaked: FALSE
[16:04:41.505]    - call: NULL
[16:04:41.506] Searching for globals...
[16:04:41.506] plan(): nbrOfWorkers() = 1
[16:04:41.507] 
[16:04:41.508] Searching for globals ... DONE
[16:04:41.508] - globals: [0] <none>
[16:04:41.508] getGlobalsAndPackages() ... DONE
[16:04:41.509] plan(): Setting new future strategy stack:
[16:04:41.509] run() for ‘Future’ ...
[16:04:41.509] - state: ‘created’
[16:04:41.509] List of future strategies:
[16:04:41.509] 1. multicore:
[16:04:41.509]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:41.509]    - tweaked: FALSE
[16:04:41.509]    - call: plan(strategy)
[16:04:41.509] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:41.514] plan(): nbrOfWorkers() = 2
[16:04:41.514] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:41.515] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:41.515]   - Field: ‘label’
[16:04:41.515]   - Field: ‘local’
[16:04:41.516]   - Field: ‘owner’
[16:04:41.516]   - Field: ‘envir’
[16:04:41.516]   - Field: ‘workers’
[16:04:41.516]   - Field: ‘packages’
[16:04:41.516]   - Field: ‘gc’
[16:04:41.516]   - Field: ‘job’
[16:04:41.517]   - Field: ‘conditions’
[16:04:41.517]   - Field: ‘expr’
[16:04:41.517]   - Field: ‘uuid’
[16:04:41.517]   - Field: ‘seed’
[16:04:41.517]   - Field: ‘version’
[16:04:41.517]   - Field: ‘result’
[16:04:41.518]   - Field: ‘asynchronous’
[16:04:41.518]   - Field: ‘calls’
[16:04:41.518]   - Field: ‘globals’
[16:04:41.518]   - Field: ‘stdout’
[16:04:41.518]   - Field: ‘earlySignal’
[16:04:41.518]   - Field: ‘lazy’
[16:04:41.519]   - Field: ‘state’
[16:04:41.519] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:41.519] - Launch lazy future ...
[16:04:41.519] Packages needed by the future expression (n = 0): <none>
[16:04:41.519] Packages needed by future strategies (n = 0): <none>
[16:04:41.520] {
[16:04:41.520]     {
[16:04:41.520]         {
[16:04:41.520]             ...future.startTime <- base::Sys.time()
[16:04:41.520]             {
[16:04:41.520]                 {
[16:04:41.520]                   {
[16:04:41.520]                     {
[16:04:41.520]                       base::local({
[16:04:41.520]                         has_future <- base::requireNamespace("future", 
[16:04:41.520]                           quietly = TRUE)
[16:04:41.520]                         if (has_future) {
[16:04:41.520]                           ns <- base::getNamespace("future")
[16:04:41.520]                           version <- ns[[".package"]][["version"]]
[16:04:41.520]                           if (is.null(version)) 
[16:04:41.520]                             version <- utils::packageVersion("future")
[16:04:41.520]                         }
[16:04:41.520]                         else {
[16:04:41.520]                           version <- NULL
[16:04:41.520]                         }
[16:04:41.520]                         if (!has_future || version < "1.8.0") {
[16:04:41.520]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.520]                             "", base::R.version$version.string), 
[16:04:41.520]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:41.520]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.520]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.520]                               "release", "version")], collapse = " "), 
[16:04:41.520]                             hostname = base::Sys.info()[["nodename"]])
[16:04:41.520]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.520]                             info)
[16:04:41.520]                           info <- base::paste(info, collapse = "; ")
[16:04:41.520]                           if (!has_future) {
[16:04:41.520]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.520]                               info)
[16:04:41.520]                           }
[16:04:41.520]                           else {
[16:04:41.520]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.520]                               info, version)
[16:04:41.520]                           }
[16:04:41.520]                           base::stop(msg)
[16:04:41.520]                         }
[16:04:41.520]                       })
[16:04:41.520]                     }
[16:04:41.520]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:41.520]                     base::options(mc.cores = 1L)
[16:04:41.520]                   }
[16:04:41.520]                   options(future.plan = NULL)
[16:04:41.520]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.520]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.520]                 }
[16:04:41.520]                 ...future.workdir <- getwd()
[16:04:41.520]             }
[16:04:41.520]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.520]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.520]         }
[16:04:41.520]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.520]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.520]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.520]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.520]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.520]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.520]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.520]             base::names(...future.oldOptions))
[16:04:41.520]     }
[16:04:41.520]     if (FALSE) {
[16:04:41.520]     }
[16:04:41.520]     else {
[16:04:41.520]         if (TRUE) {
[16:04:41.520]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.520]                 open = "w")
[16:04:41.520]         }
[16:04:41.520]         else {
[16:04:41.520]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.520]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.520]         }
[16:04:41.520]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.520]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.520]             base::sink(type = "output", split = FALSE)
[16:04:41.520]             base::close(...future.stdout)
[16:04:41.520]         }, add = TRUE)
[16:04:41.520]     }
[16:04:41.520]     ...future.frame <- base::sys.nframe()
[16:04:41.520]     ...future.conditions <- base::list()
[16:04:41.520]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.520]     if (FALSE) {
[16:04:41.520]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.520]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.520]     }
[16:04:41.520]     ...future.result <- base::tryCatch({
[16:04:41.520]         base::withCallingHandlers({
[16:04:41.520]             ...future.value <- base::withVisible(base::local({
[16:04:41.520]                 withCallingHandlers({
[16:04:41.520]                   NULL
[16:04:41.520]                 }, immediateCondition = function(cond) {
[16:04:41.520]                   save_rds <- function (object, pathname, ...) 
[16:04:41.520]                   {
[16:04:41.520]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:41.520]                     if (file_test("-f", pathname_tmp)) {
[16:04:41.520]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.520]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:41.520]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.520]                         fi_tmp[["mtime"]])
[16:04:41.520]                     }
[16:04:41.520]                     tryCatch({
[16:04:41.520]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:41.520]                     }, error = function(ex) {
[16:04:41.520]                       msg <- conditionMessage(ex)
[16:04:41.520]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.520]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:41.520]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.520]                         fi_tmp[["mtime"]], msg)
[16:04:41.520]                       ex$message <- msg
[16:04:41.520]                       stop(ex)
[16:04:41.520]                     })
[16:04:41.520]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:41.520]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:41.520]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:41.520]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.520]                       fi <- file.info(pathname)
[16:04:41.520]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:41.520]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.520]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:41.520]                         fi[["size"]], fi[["mtime"]])
[16:04:41.520]                       stop(msg)
[16:04:41.520]                     }
[16:04:41.520]                     invisible(pathname)
[16:04:41.520]                   }
[16:04:41.520]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:41.520]                     rootPath = tempdir()) 
[16:04:41.520]                   {
[16:04:41.520]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:41.520]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:41.520]                       tmpdir = path, fileext = ".rds")
[16:04:41.520]                     save_rds(obj, file)
[16:04:41.520]                   }
[16:04:41.520]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:41.520]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.520]                   {
[16:04:41.520]                     inherits <- base::inherits
[16:04:41.520]                     invokeRestart <- base::invokeRestart
[16:04:41.520]                     is.null <- base::is.null
[16:04:41.520]                     muffled <- FALSE
[16:04:41.520]                     if (inherits(cond, "message")) {
[16:04:41.520]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:41.520]                       if (muffled) 
[16:04:41.520]                         invokeRestart("muffleMessage")
[16:04:41.520]                     }
[16:04:41.520]                     else if (inherits(cond, "warning")) {
[16:04:41.520]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:41.520]                       if (muffled) 
[16:04:41.520]                         invokeRestart("muffleWarning")
[16:04:41.520]                     }
[16:04:41.520]                     else if (inherits(cond, "condition")) {
[16:04:41.520]                       if (!is.null(pattern)) {
[16:04:41.520]                         computeRestarts <- base::computeRestarts
[16:04:41.520]                         grepl <- base::grepl
[16:04:41.520]                         restarts <- computeRestarts(cond)
[16:04:41.520]                         for (restart in restarts) {
[16:04:41.520]                           name <- restart$name
[16:04:41.520]                           if (is.null(name)) 
[16:04:41.520]                             next
[16:04:41.520]                           if (!grepl(pattern, name)) 
[16:04:41.520]                             next
[16:04:41.520]                           invokeRestart(restart)
[16:04:41.520]                           muffled <- TRUE
[16:04:41.520]                           break
[16:04:41.520]                         }
[16:04:41.520]                       }
[16:04:41.520]                     }
[16:04:41.520]                     invisible(muffled)
[16:04:41.520]                   }
[16:04:41.520]                   muffleCondition(cond)
[16:04:41.520]                 })
[16:04:41.520]             }))
[16:04:41.520]             future::FutureResult(value = ...future.value$value, 
[16:04:41.520]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.520]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.520]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.520]                     ...future.globalenv.names))
[16:04:41.520]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.520]         }, condition = base::local({
[16:04:41.520]             c <- base::c
[16:04:41.520]             inherits <- base::inherits
[16:04:41.520]             invokeRestart <- base::invokeRestart
[16:04:41.520]             length <- base::length
[16:04:41.520]             list <- base::list
[16:04:41.520]             seq.int <- base::seq.int
[16:04:41.520]             signalCondition <- base::signalCondition
[16:04:41.520]             sys.calls <- base::sys.calls
[16:04:41.520]             `[[` <- base::`[[`
[16:04:41.520]             `+` <- base::`+`
[16:04:41.520]             `<<-` <- base::`<<-`
[16:04:41.520]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.520]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.520]                   3L)]
[16:04:41.520]             }
[16:04:41.520]             function(cond) {
[16:04:41.520]                 is_error <- inherits(cond, "error")
[16:04:41.520]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.520]                   NULL)
[16:04:41.520]                 if (is_error) {
[16:04:41.520]                   sessionInformation <- function() {
[16:04:41.520]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.520]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.520]                       search = base::search(), system = base::Sys.info())
[16:04:41.520]                   }
[16:04:41.520]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.520]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.520]                     cond$call), session = sessionInformation(), 
[16:04:41.520]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.520]                   signalCondition(cond)
[16:04:41.520]                 }
[16:04:41.520]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.520]                 "immediateCondition"))) {
[16:04:41.520]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.520]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.520]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.520]                   if (TRUE && !signal) {
[16:04:41.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.520]                     {
[16:04:41.520]                       inherits <- base::inherits
[16:04:41.520]                       invokeRestart <- base::invokeRestart
[16:04:41.520]                       is.null <- base::is.null
[16:04:41.520]                       muffled <- FALSE
[16:04:41.520]                       if (inherits(cond, "message")) {
[16:04:41.520]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.520]                         if (muffled) 
[16:04:41.520]                           invokeRestart("muffleMessage")
[16:04:41.520]                       }
[16:04:41.520]                       else if (inherits(cond, "warning")) {
[16:04:41.520]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.520]                         if (muffled) 
[16:04:41.520]                           invokeRestart("muffleWarning")
[16:04:41.520]                       }
[16:04:41.520]                       else if (inherits(cond, "condition")) {
[16:04:41.520]                         if (!is.null(pattern)) {
[16:04:41.520]                           computeRestarts <- base::computeRestarts
[16:04:41.520]                           grepl <- base::grepl
[16:04:41.520]                           restarts <- computeRestarts(cond)
[16:04:41.520]                           for (restart in restarts) {
[16:04:41.520]                             name <- restart$name
[16:04:41.520]                             if (is.null(name)) 
[16:04:41.520]                               next
[16:04:41.520]                             if (!grepl(pattern, name)) 
[16:04:41.520]                               next
[16:04:41.520]                             invokeRestart(restart)
[16:04:41.520]                             muffled <- TRUE
[16:04:41.520]                             break
[16:04:41.520]                           }
[16:04:41.520]                         }
[16:04:41.520]                       }
[16:04:41.520]                       invisible(muffled)
[16:04:41.520]                     }
[16:04:41.520]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.520]                   }
[16:04:41.520]                 }
[16:04:41.520]                 else {
[16:04:41.520]                   if (TRUE) {
[16:04:41.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.520]                     {
[16:04:41.520]                       inherits <- base::inherits
[16:04:41.520]                       invokeRestart <- base::invokeRestart
[16:04:41.520]                       is.null <- base::is.null
[16:04:41.520]                       muffled <- FALSE
[16:04:41.520]                       if (inherits(cond, "message")) {
[16:04:41.520]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.520]                         if (muffled) 
[16:04:41.520]                           invokeRestart("muffleMessage")
[16:04:41.520]                       }
[16:04:41.520]                       else if (inherits(cond, "warning")) {
[16:04:41.520]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.520]                         if (muffled) 
[16:04:41.520]                           invokeRestart("muffleWarning")
[16:04:41.520]                       }
[16:04:41.520]                       else if (inherits(cond, "condition")) {
[16:04:41.520]                         if (!is.null(pattern)) {
[16:04:41.520]                           computeRestarts <- base::computeRestarts
[16:04:41.520]                           grepl <- base::grepl
[16:04:41.520]                           restarts <- computeRestarts(cond)
[16:04:41.520]                           for (restart in restarts) {
[16:04:41.520]                             name <- restart$name
[16:04:41.520]                             if (is.null(name)) 
[16:04:41.520]                               next
[16:04:41.520]                             if (!grepl(pattern, name)) 
[16:04:41.520]                               next
[16:04:41.520]                             invokeRestart(restart)
[16:04:41.520]                             muffled <- TRUE
[16:04:41.520]                             break
[16:04:41.520]                           }
[16:04:41.520]                         }
[16:04:41.520]                       }
[16:04:41.520]                       invisible(muffled)
[16:04:41.520]                     }
[16:04:41.520]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.520]                   }
[16:04:41.520]                 }
[16:04:41.520]             }
[16:04:41.520]         }))
[16:04:41.520]     }, error = function(ex) {
[16:04:41.520]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.520]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.520]                 ...future.rng), started = ...future.startTime, 
[16:04:41.520]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.520]             version = "1.8"), class = "FutureResult")
[16:04:41.520]     }, finally = {
[16:04:41.520]         if (!identical(...future.workdir, getwd())) 
[16:04:41.520]             setwd(...future.workdir)
[16:04:41.520]         {
[16:04:41.520]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.520]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.520]             }
[16:04:41.520]             base::options(...future.oldOptions)
[16:04:41.520]             if (.Platform$OS.type == "windows") {
[16:04:41.520]                 old_names <- names(...future.oldEnvVars)
[16:04:41.520]                 envs <- base::Sys.getenv()
[16:04:41.520]                 names <- names(envs)
[16:04:41.520]                 common <- intersect(names, old_names)
[16:04:41.520]                 added <- setdiff(names, old_names)
[16:04:41.520]                 removed <- setdiff(old_names, names)
[16:04:41.520]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.520]                   envs[common]]
[16:04:41.520]                 NAMES <- toupper(changed)
[16:04:41.520]                 args <- list()
[16:04:41.520]                 for (kk in seq_along(NAMES)) {
[16:04:41.520]                   name <- changed[[kk]]
[16:04:41.520]                   NAME <- NAMES[[kk]]
[16:04:41.520]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.520]                     next
[16:04:41.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.520]                 }
[16:04:41.520]                 NAMES <- toupper(added)
[16:04:41.520]                 for (kk in seq_along(NAMES)) {
[16:04:41.520]                   name <- added[[kk]]
[16:04:41.520]                   NAME <- NAMES[[kk]]
[16:04:41.520]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.520]                     next
[16:04:41.520]                   args[[name]] <- ""
[16:04:41.520]                 }
[16:04:41.520]                 NAMES <- toupper(removed)
[16:04:41.520]                 for (kk in seq_along(NAMES)) {
[16:04:41.520]                   name <- removed[[kk]]
[16:04:41.520]                   NAME <- NAMES[[kk]]
[16:04:41.520]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.520]                     next
[16:04:41.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.520]                 }
[16:04:41.520]                 if (length(args) > 0) 
[16:04:41.520]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.520]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.520]             }
[16:04:41.520]             else {
[16:04:41.520]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.520]             }
[16:04:41.520]             {
[16:04:41.520]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.520]                   0L) {
[16:04:41.520]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.520]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.520]                   base::options(opts)
[16:04:41.520]                 }
[16:04:41.520]                 {
[16:04:41.520]                   {
[16:04:41.520]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:41.520]                     NULL
[16:04:41.520]                   }
[16:04:41.520]                   options(future.plan = NULL)
[16:04:41.520]                   if (is.na(NA_character_)) 
[16:04:41.520]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.520]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.520]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:41.520]                     envir = parent.frame()) 
[16:04:41.520]                   {
[16:04:41.520]                     default_workers <- missing(workers)
[16:04:41.520]                     if (is.function(workers)) 
[16:04:41.520]                       workers <- workers()
[16:04:41.520]                     workers <- structure(as.integer(workers), 
[16:04:41.520]                       class = class(workers))
[16:04:41.520]                     stop_if_not(is.finite(workers), workers >= 
[16:04:41.520]                       1L)
[16:04:41.520]                     if ((workers == 1L && !inherits(workers, 
[16:04:41.520]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:41.520]                       if (default_workers) 
[16:04:41.520]                         supportsMulticore(warn = TRUE)
[16:04:41.520]                       return(sequential(..., envir = envir))
[16:04:41.520]                     }
[16:04:41.520]                     oopts <- options(mc.cores = workers)
[16:04:41.520]                     on.exit(options(oopts))
[16:04:41.520]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:41.520]                       envir = envir)
[16:04:41.520]                     if (!future$lazy) 
[16:04:41.520]                       future <- run(future)
[16:04:41.520]                     invisible(future)
[16:04:41.520]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.520]                 }
[16:04:41.520]             }
[16:04:41.520]         }
[16:04:41.520]     })
[16:04:41.520]     if (TRUE) {
[16:04:41.520]         base::sink(type = "output", split = FALSE)
[16:04:41.520]         if (TRUE) {
[16:04:41.520]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.520]         }
[16:04:41.520]         else {
[16:04:41.520]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.520]         }
[16:04:41.520]         base::close(...future.stdout)
[16:04:41.520]         ...future.stdout <- NULL
[16:04:41.520]     }
[16:04:41.520]     ...future.result$conditions <- ...future.conditions
[16:04:41.520]     ...future.result$finished <- base::Sys.time()
[16:04:41.520]     ...future.result
[16:04:41.520] }
[16:04:41.524] requestCore(): workers = 2
[16:04:41.530] MulticoreFuture started
[16:04:41.530] - Launch lazy future ... done
[16:04:41.530] run() for ‘MulticoreFuture’ ... done
List of 6
[16:04:41.531] plan(): Setting new future strategy stack:
 $ a:[16:04:41.531] List of future strategies:
[16:04:41.531] 1. sequential:
[16:04:41.531]    - args: function (..., envir = parent.frame())
[16:04:41.531]    - tweaked: FALSE
[16:04:41.531]    - call: NULL
 num 1
 $ b:[16:04:41.532] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874de02cc8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874d181fa0> 
 $  : NULL
 $  : NULL
 $  :[16:04:41.534] plan(): Setting new future strategy stack:
 num 6
List of 6
[16:04:41.534] List of future strategies:
[16:04:41.534] 1. multicore:
[16:04:41.534]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:41.534]    - tweaked: FALSE
[16:04:41.534]    - call: plan(strategy)
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874de02cc8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874d181fa0> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:04:41.540] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:41.541] resolve() on list ...
[16:04:41.541]  recursive: 0
[16:04:41.541]  length: 6
[16:04:41.542]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:41.542] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.542] - nx: 6
[16:04:41.542] - relay: TRUE
[16:04:41.542] - stdout: TRUE
[16:04:41.542] - signal: TRUE
[16:04:41.542] - resignal: FALSE
[16:04:41.542] - force: TRUE
[16:04:41.543] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.543] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.543]  - until=2
[16:04:41.543]  - relaying element #2
[16:04:41.543] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.543] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.543] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.544]  length: 5 (resolved future 1)
[16:04:41.544] Future #2
[16:04:41.545] result() for MulticoreFuture ...
[16:04:41.546] result() for MulticoreFuture ...
[16:04:41.546] result() for MulticoreFuture ... done
[16:04:41.546] result() for MulticoreFuture ... done
[16:04:41.547] result() for MulticoreFuture ...
[16:04:41.547] result() for MulticoreFuture ... done
[16:04:41.547] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:41.547] - nx: 6
[16:04:41.547] - relay: TRUE
[16:04:41.547] - stdout: TRUE
[16:04:41.547] - signal: TRUE
[16:04:41.547] - resignal: FALSE
[16:04:41.548] - force: TRUE
[16:04:41.548] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.548] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.548]  - until=2
[16:04:41.548]  - relaying element #2
[16:04:41.548] result() for MulticoreFuture ...
[16:04:41.548] result() for MulticoreFuture ... done
[16:04:41.549] result() for MulticoreFuture ...
[16:04:41.549] result() for MulticoreFuture ... done
[16:04:41.549] result() for MulticoreFuture ...
[16:04:41.549] result() for MulticoreFuture ... done
[16:04:41.549] result() for MulticoreFuture ...
[16:04:41.549] result() for MulticoreFuture ... done
[16:04:41.549] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.550] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.550] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:41.550]  length: 4 (resolved future 2)
[16:04:41.550] Future #3
[16:04:41.550] result() for MulticoreFuture ...
[16:04:41.551] result() for MulticoreFuture ...
[16:04:41.551] result() for MulticoreFuture ... done
[16:04:41.551] result() for MulticoreFuture ... done
[16:04:41.552] result() for MulticoreFuture ...
[16:04:41.552] result() for MulticoreFuture ... done
[16:04:41.552] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:41.552] - nx: 6
[16:04:41.552] - relay: TRUE
[16:04:41.553] - stdout: TRUE
[16:04:41.553] - signal: TRUE
[16:04:41.553] - resignal: FALSE
[16:04:41.553] - force: TRUE
[16:04:41.553] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.553] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.554]  - until=3
[16:04:41.554]  - relaying element #3
[16:04:41.554] result() for MulticoreFuture ...
[16:04:41.554] result() for MulticoreFuture ... done
[16:04:41.554] result() for MulticoreFuture ...
[16:04:41.554] result() for MulticoreFuture ... done
[16:04:41.554] result() for MulticoreFuture ...
[16:04:41.554] result() for MulticoreFuture ... done
[16:04:41.555] result() for MulticoreFuture ...
[16:04:41.555] result() for MulticoreFuture ... done
[16:04:41.555] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.555] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.555] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:41.555]  length: 3 (resolved future 3)
[16:04:41.558] signalConditionsASAP(NULL, pos=4) ...
[16:04:41.558] - nx: 6
[16:04:41.558] - relay: TRUE
[16:04:41.558] - stdout: TRUE
[16:04:41.558] - signal: TRUE
[16:04:41.559] - resignal: FALSE
[16:04:41.559] - force: TRUE
[16:04:41.559] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.559] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.559]  - until=5
[16:04:41.559]  - relaying element #5
[16:04:41.560] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.560] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.560] signalConditionsASAP(NULL, pos=4) ... done
[16:04:41.560]  length: 2 (resolved future 4)
[16:04:41.560] signalConditionsASAP(NULL, pos=5) ...
[16:04:41.560] - nx: 6
[16:04:41.560] - relay: TRUE
[16:04:41.560] - stdout: TRUE
[16:04:41.560] - signal: TRUE
[16:04:41.561] - resignal: FALSE
[16:04:41.561] - force: TRUE
[16:04:41.561] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.561] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.561]  - until=6
[16:04:41.561]  - relaying element #6
[16:04:41.561] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.561] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.561] signalConditionsASAP(NULL, pos=5) ... done
[16:04:41.562]  length: 1 (resolved future 5)
[16:04:41.562] signalConditionsASAP(numeric, pos=6) ...
[16:04:41.562] - nx: 6
[16:04:41.562] - relay: TRUE
[16:04:41.562] - stdout: TRUE
[16:04:41.562] - signal: TRUE
[16:04:41.562] - resignal: FALSE
[16:04:41.562] - force: TRUE
[16:04:41.562] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.563] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.563]  - until=6
[16:04:41.563] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.563] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.563] signalConditionsASAP(numeric, pos=6) ... done
[16:04:41.563]  length: 0 (resolved future 6)
[16:04:41.563] Relaying remaining futures
[16:04:41.563] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.564] - nx: 6
[16:04:41.564] - relay: TRUE
[16:04:41.564] - stdout: TRUE
[16:04:41.564] - signal: TRUE
[16:04:41.564] - resignal: FALSE
[16:04:41.564] - force: TRUE
[16:04:41.564] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.564] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:41.564] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.565] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.565] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.565] resolve() on list ... DONE
[16:04:41.565] result() for MulticoreFuture ...
[16:04:41.565] result() for MulticoreFuture ... done
[16:04:41.565] result() for MulticoreFuture ...
[16:04:41.565] result() for MulticoreFuture ... done
[16:04:41.565] result() for MulticoreFuture ...
[16:04:41.565] result() for MulticoreFuture ... done
[16:04:41.566] result() for MulticoreFuture ...
[16:04:41.566] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[16:04:41.568] getGlobalsAndPackages() ...
[16:04:41.568] Searching for globals...
[16:04:41.569] 
[16:04:41.569] Searching for globals ... DONE
[16:04:41.569] - globals: [0] <none>
[16:04:41.569] getGlobalsAndPackages() ... DONE
[16:04:41.569] run() for ‘Future’ ...
[16:04:41.569] - state: ‘created’
[16:04:41.569] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:41.574] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:41.574] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:41.574]   - Field: ‘label’
[16:04:41.574]   - Field: ‘local’
[16:04:41.574]   - Field: ‘owner’
[16:04:41.574]   - Field: ‘envir’
[16:04:41.574]   - Field: ‘workers’
[16:04:41.574]   - Field: ‘packages’
[16:04:41.574]   - Field: ‘gc’
[16:04:41.575]   - Field: ‘job’
[16:04:41.575]   - Field: ‘conditions’
[16:04:41.575]   - Field: ‘expr’
[16:04:41.575]   - Field: ‘uuid’
[16:04:41.575]   - Field: ‘seed’
[16:04:41.575]   - Field: ‘version’
[16:04:41.575]   - Field: ‘result’
[16:04:41.575]   - Field: ‘asynchronous’
[16:04:41.575]   - Field: ‘calls’
[16:04:41.575]   - Field: ‘globals’
[16:04:41.576]   - Field: ‘stdout’
[16:04:41.576]   - Field: ‘earlySignal’
[16:04:41.576]   - Field: ‘lazy’
[16:04:41.576]   - Field: ‘state’
[16:04:41.576] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:41.576] - Launch lazy future ...
[16:04:41.576] Packages needed by the future expression (n = 0): <none>
[16:04:41.576] Packages needed by future strategies (n = 0): <none>
[16:04:41.577] {
[16:04:41.577]     {
[16:04:41.577]         {
[16:04:41.577]             ...future.startTime <- base::Sys.time()
[16:04:41.577]             {
[16:04:41.577]                 {
[16:04:41.577]                   {
[16:04:41.577]                     {
[16:04:41.577]                       base::local({
[16:04:41.577]                         has_future <- base::requireNamespace("future", 
[16:04:41.577]                           quietly = TRUE)
[16:04:41.577]                         if (has_future) {
[16:04:41.577]                           ns <- base::getNamespace("future")
[16:04:41.577]                           version <- ns[[".package"]][["version"]]
[16:04:41.577]                           if (is.null(version)) 
[16:04:41.577]                             version <- utils::packageVersion("future")
[16:04:41.577]                         }
[16:04:41.577]                         else {
[16:04:41.577]                           version <- NULL
[16:04:41.577]                         }
[16:04:41.577]                         if (!has_future || version < "1.8.0") {
[16:04:41.577]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.577]                             "", base::R.version$version.string), 
[16:04:41.577]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:41.577]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.577]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.577]                               "release", "version")], collapse = " "), 
[16:04:41.577]                             hostname = base::Sys.info()[["nodename"]])
[16:04:41.577]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.577]                             info)
[16:04:41.577]                           info <- base::paste(info, collapse = "; ")
[16:04:41.577]                           if (!has_future) {
[16:04:41.577]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.577]                               info)
[16:04:41.577]                           }
[16:04:41.577]                           else {
[16:04:41.577]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.577]                               info, version)
[16:04:41.577]                           }
[16:04:41.577]                           base::stop(msg)
[16:04:41.577]                         }
[16:04:41.577]                       })
[16:04:41.577]                     }
[16:04:41.577]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:41.577]                     base::options(mc.cores = 1L)
[16:04:41.577]                   }
[16:04:41.577]                   options(future.plan = NULL)
[16:04:41.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.577]                 }
[16:04:41.577]                 ...future.workdir <- getwd()
[16:04:41.577]             }
[16:04:41.577]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.577]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.577]         }
[16:04:41.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.577]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.577]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.577]             base::names(...future.oldOptions))
[16:04:41.577]     }
[16:04:41.577]     if (FALSE) {
[16:04:41.577]     }
[16:04:41.577]     else {
[16:04:41.577]         if (TRUE) {
[16:04:41.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.577]                 open = "w")
[16:04:41.577]         }
[16:04:41.577]         else {
[16:04:41.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.577]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.577]         }
[16:04:41.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.577]             base::sink(type = "output", split = FALSE)
[16:04:41.577]             base::close(...future.stdout)
[16:04:41.577]         }, add = TRUE)
[16:04:41.577]     }
[16:04:41.577]     ...future.frame <- base::sys.nframe()
[16:04:41.577]     ...future.conditions <- base::list()
[16:04:41.577]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.577]     if (FALSE) {
[16:04:41.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.577]     }
[16:04:41.577]     ...future.result <- base::tryCatch({
[16:04:41.577]         base::withCallingHandlers({
[16:04:41.577]             ...future.value <- base::withVisible(base::local({
[16:04:41.577]                 withCallingHandlers({
[16:04:41.577]                   2
[16:04:41.577]                 }, immediateCondition = function(cond) {
[16:04:41.577]                   save_rds <- function (object, pathname, ...) 
[16:04:41.577]                   {
[16:04:41.577]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:41.577]                     if (file_test("-f", pathname_tmp)) {
[16:04:41.577]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.577]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:41.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.577]                         fi_tmp[["mtime"]])
[16:04:41.577]                     }
[16:04:41.577]                     tryCatch({
[16:04:41.577]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:41.577]                     }, error = function(ex) {
[16:04:41.577]                       msg <- conditionMessage(ex)
[16:04:41.577]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.577]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:41.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.577]                         fi_tmp[["mtime"]], msg)
[16:04:41.577]                       ex$message <- msg
[16:04:41.577]                       stop(ex)
[16:04:41.577]                     })
[16:04:41.577]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:41.577]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:41.577]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:41.577]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.577]                       fi <- file.info(pathname)
[16:04:41.577]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:41.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.577]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:41.577]                         fi[["size"]], fi[["mtime"]])
[16:04:41.577]                       stop(msg)
[16:04:41.577]                     }
[16:04:41.577]                     invisible(pathname)
[16:04:41.577]                   }
[16:04:41.577]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:41.577]                     rootPath = tempdir()) 
[16:04:41.577]                   {
[16:04:41.577]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:41.577]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:41.577]                       tmpdir = path, fileext = ".rds")
[16:04:41.577]                     save_rds(obj, file)
[16:04:41.577]                   }
[16:04:41.577]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:41.577]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.577]                   {
[16:04:41.577]                     inherits <- base::inherits
[16:04:41.577]                     invokeRestart <- base::invokeRestart
[16:04:41.577]                     is.null <- base::is.null
[16:04:41.577]                     muffled <- FALSE
[16:04:41.577]                     if (inherits(cond, "message")) {
[16:04:41.577]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:41.577]                       if (muffled) 
[16:04:41.577]                         invokeRestart("muffleMessage")
[16:04:41.577]                     }
[16:04:41.577]                     else if (inherits(cond, "warning")) {
[16:04:41.577]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:41.577]                       if (muffled) 
[16:04:41.577]                         invokeRestart("muffleWarning")
[16:04:41.577]                     }
[16:04:41.577]                     else if (inherits(cond, "condition")) {
[16:04:41.577]                       if (!is.null(pattern)) {
[16:04:41.577]                         computeRestarts <- base::computeRestarts
[16:04:41.577]                         grepl <- base::grepl
[16:04:41.577]                         restarts <- computeRestarts(cond)
[16:04:41.577]                         for (restart in restarts) {
[16:04:41.577]                           name <- restart$name
[16:04:41.577]                           if (is.null(name)) 
[16:04:41.577]                             next
[16:04:41.577]                           if (!grepl(pattern, name)) 
[16:04:41.577]                             next
[16:04:41.577]                           invokeRestart(restart)
[16:04:41.577]                           muffled <- TRUE
[16:04:41.577]                           break
[16:04:41.577]                         }
[16:04:41.577]                       }
[16:04:41.577]                     }
[16:04:41.577]                     invisible(muffled)
[16:04:41.577]                   }
[16:04:41.577]                   muffleCondition(cond)
[16:04:41.577]                 })
[16:04:41.577]             }))
[16:04:41.577]             future::FutureResult(value = ...future.value$value, 
[16:04:41.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.577]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.577]                     ...future.globalenv.names))
[16:04:41.577]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.577]         }, condition = base::local({
[16:04:41.577]             c <- base::c
[16:04:41.577]             inherits <- base::inherits
[16:04:41.577]             invokeRestart <- base::invokeRestart
[16:04:41.577]             length <- base::length
[16:04:41.577]             list <- base::list
[16:04:41.577]             seq.int <- base::seq.int
[16:04:41.577]             signalCondition <- base::signalCondition
[16:04:41.577]             sys.calls <- base::sys.calls
[16:04:41.577]             `[[` <- base::`[[`
[16:04:41.577]             `+` <- base::`+`
[16:04:41.577]             `<<-` <- base::`<<-`
[16:04:41.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.577]                   3L)]
[16:04:41.577]             }
[16:04:41.577]             function(cond) {
[16:04:41.577]                 is_error <- inherits(cond, "error")
[16:04:41.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.577]                   NULL)
[16:04:41.577]                 if (is_error) {
[16:04:41.577]                   sessionInformation <- function() {
[16:04:41.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.577]                       search = base::search(), system = base::Sys.info())
[16:04:41.577]                   }
[16:04:41.577]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.577]                     cond$call), session = sessionInformation(), 
[16:04:41.577]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.577]                   signalCondition(cond)
[16:04:41.577]                 }
[16:04:41.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.577]                 "immediateCondition"))) {
[16:04:41.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.577]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.577]                   if (TRUE && !signal) {
[16:04:41.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.577]                     {
[16:04:41.577]                       inherits <- base::inherits
[16:04:41.577]                       invokeRestart <- base::invokeRestart
[16:04:41.577]                       is.null <- base::is.null
[16:04:41.577]                       muffled <- FALSE
[16:04:41.577]                       if (inherits(cond, "message")) {
[16:04:41.577]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.577]                         if (muffled) 
[16:04:41.577]                           invokeRestart("muffleMessage")
[16:04:41.577]                       }
[16:04:41.577]                       else if (inherits(cond, "warning")) {
[16:04:41.577]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.577]                         if (muffled) 
[16:04:41.577]                           invokeRestart("muffleWarning")
[16:04:41.577]                       }
[16:04:41.577]                       else if (inherits(cond, "condition")) {
[16:04:41.577]                         if (!is.null(pattern)) {
[16:04:41.577]                           computeRestarts <- base::computeRestarts
[16:04:41.577]                           grepl <- base::grepl
[16:04:41.577]                           restarts <- computeRestarts(cond)
[16:04:41.577]                           for (restart in restarts) {
[16:04:41.577]                             name <- restart$name
[16:04:41.577]                             if (is.null(name)) 
[16:04:41.577]                               next
[16:04:41.577]                             if (!grepl(pattern, name)) 
[16:04:41.577]                               next
[16:04:41.577]                             invokeRestart(restart)
[16:04:41.577]                             muffled <- TRUE
[16:04:41.577]                             break
[16:04:41.577]                           }
[16:04:41.577]                         }
[16:04:41.577]                       }
[16:04:41.577]                       invisible(muffled)
[16:04:41.577]                     }
[16:04:41.577]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.577]                   }
[16:04:41.577]                 }
[16:04:41.577]                 else {
[16:04:41.577]                   if (TRUE) {
[16:04:41.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.577]                     {
[16:04:41.577]                       inherits <- base::inherits
[16:04:41.577]                       invokeRestart <- base::invokeRestart
[16:04:41.577]                       is.null <- base::is.null
[16:04:41.577]                       muffled <- FALSE
[16:04:41.577]                       if (inherits(cond, "message")) {
[16:04:41.577]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.577]                         if (muffled) 
[16:04:41.577]                           invokeRestart("muffleMessage")
[16:04:41.577]                       }
[16:04:41.577]                       else if (inherits(cond, "warning")) {
[16:04:41.577]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.577]                         if (muffled) 
[16:04:41.577]                           invokeRestart("muffleWarning")
[16:04:41.577]                       }
[16:04:41.577]                       else if (inherits(cond, "condition")) {
[16:04:41.577]                         if (!is.null(pattern)) {
[16:04:41.577]                           computeRestarts <- base::computeRestarts
[16:04:41.577]                           grepl <- base::grepl
[16:04:41.577]                           restarts <- computeRestarts(cond)
[16:04:41.577]                           for (restart in restarts) {
[16:04:41.577]                             name <- restart$name
[16:04:41.577]                             if (is.null(name)) 
[16:04:41.577]                               next
[16:04:41.577]                             if (!grepl(pattern, name)) 
[16:04:41.577]                               next
[16:04:41.577]                             invokeRestart(restart)
[16:04:41.577]                             muffled <- TRUE
[16:04:41.577]                             break
[16:04:41.577]                           }
[16:04:41.577]                         }
[16:04:41.577]                       }
[16:04:41.577]                       invisible(muffled)
[16:04:41.577]                     }
[16:04:41.577]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.577]                   }
[16:04:41.577]                 }
[16:04:41.577]             }
[16:04:41.577]         }))
[16:04:41.577]     }, error = function(ex) {
[16:04:41.577]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.577]                 ...future.rng), started = ...future.startTime, 
[16:04:41.577]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.577]             version = "1.8"), class = "FutureResult")
[16:04:41.577]     }, finally = {
[16:04:41.577]         if (!identical(...future.workdir, getwd())) 
[16:04:41.577]             setwd(...future.workdir)
[16:04:41.577]         {
[16:04:41.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.577]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.577]             }
[16:04:41.577]             base::options(...future.oldOptions)
[16:04:41.577]             if (.Platform$OS.type == "windows") {
[16:04:41.577]                 old_names <- names(...future.oldEnvVars)
[16:04:41.577]                 envs <- base::Sys.getenv()
[16:04:41.577]                 names <- names(envs)
[16:04:41.577]                 common <- intersect(names, old_names)
[16:04:41.577]                 added <- setdiff(names, old_names)
[16:04:41.577]                 removed <- setdiff(old_names, names)
[16:04:41.577]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.577]                   envs[common]]
[16:04:41.577]                 NAMES <- toupper(changed)
[16:04:41.577]                 args <- list()
[16:04:41.577]                 for (kk in seq_along(NAMES)) {
[16:04:41.577]                   name <- changed[[kk]]
[16:04:41.577]                   NAME <- NAMES[[kk]]
[16:04:41.577]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.577]                     next
[16:04:41.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.577]                 }
[16:04:41.577]                 NAMES <- toupper(added)
[16:04:41.577]                 for (kk in seq_along(NAMES)) {
[16:04:41.577]                   name <- added[[kk]]
[16:04:41.577]                   NAME <- NAMES[[kk]]
[16:04:41.577]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.577]                     next
[16:04:41.577]                   args[[name]] <- ""
[16:04:41.577]                 }
[16:04:41.577]                 NAMES <- toupper(removed)
[16:04:41.577]                 for (kk in seq_along(NAMES)) {
[16:04:41.577]                   name <- removed[[kk]]
[16:04:41.577]                   NAME <- NAMES[[kk]]
[16:04:41.577]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.577]                     next
[16:04:41.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.577]                 }
[16:04:41.577]                 if (length(args) > 0) 
[16:04:41.577]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.577]             }
[16:04:41.577]             else {
[16:04:41.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.577]             }
[16:04:41.577]             {
[16:04:41.577]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.577]                   0L) {
[16:04:41.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.577]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.577]                   base::options(opts)
[16:04:41.577]                 }
[16:04:41.577]                 {
[16:04:41.577]                   {
[16:04:41.577]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:41.577]                     NULL
[16:04:41.577]                   }
[16:04:41.577]                   options(future.plan = NULL)
[16:04:41.577]                   if (is.na(NA_character_)) 
[16:04:41.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.577]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:41.577]                     envir = parent.frame()) 
[16:04:41.577]                   {
[16:04:41.577]                     default_workers <- missing(workers)
[16:04:41.577]                     if (is.function(workers)) 
[16:04:41.577]                       workers <- workers()
[16:04:41.577]                     workers <- structure(as.integer(workers), 
[16:04:41.577]                       class = class(workers))
[16:04:41.577]                     stop_if_not(is.finite(workers), workers >= 
[16:04:41.577]                       1L)
[16:04:41.577]                     if ((workers == 1L && !inherits(workers, 
[16:04:41.577]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:41.577]                       if (default_workers) 
[16:04:41.577]                         supportsMulticore(warn = TRUE)
[16:04:41.577]                       return(sequential(..., envir = envir))
[16:04:41.577]                     }
[16:04:41.577]                     oopts <- options(mc.cores = workers)
[16:04:41.577]                     on.exit(options(oopts))
[16:04:41.577]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:41.577]                       envir = envir)
[16:04:41.577]                     if (!future$lazy) 
[16:04:41.577]                       future <- run(future)
[16:04:41.577]                     invisible(future)
[16:04:41.577]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.577]                 }
[16:04:41.577]             }
[16:04:41.577]         }
[16:04:41.577]     })
[16:04:41.577]     if (TRUE) {
[16:04:41.577]         base::sink(type = "output", split = FALSE)
[16:04:41.577]         if (TRUE) {
[16:04:41.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.577]         }
[16:04:41.577]         else {
[16:04:41.577]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.577]         }
[16:04:41.577]         base::close(...future.stdout)
[16:04:41.577]         ...future.stdout <- NULL
[16:04:41.577]     }
[16:04:41.577]     ...future.result$conditions <- ...future.conditions
[16:04:41.577]     ...future.result$finished <- base::Sys.time()
[16:04:41.577]     ...future.result
[16:04:41.577] }
[16:04:41.579] requestCore(): workers = 2
[16:04:41.581] MulticoreFuture started
[16:04:41.581] - Launch lazy future ... done
[16:04:41.582] run() for ‘MulticoreFuture’ ... done
[16:04:41.582] getGlobalsAndPackages() ...
[16:04:41.582] Searching for globals...
[16:04:41.582] plan(): Setting new future strategy stack:
[16:04:41.583] 
[16:04:41.582] List of future strategies:
[16:04:41.582] 1. sequential:
[16:04:41.582]    - args: function (..., envir = parent.frame())
[16:04:41.582]    - tweaked: FALSE
[16:04:41.582]    - call: NULL
[16:04:41.583] Searching for globals ... DONE
[16:04:41.583] plan(): nbrOfWorkers() = 1
[16:04:41.583] - globals: [0] <none>
[16:04:41.583] getGlobalsAndPackages() ... DONE
[16:04:41.584] run() for ‘Future’ ...
[16:04:41.584] - state: ‘created’
[16:04:41.584] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:41.585] plan(): Setting new future strategy stack:
[16:04:41.585] List of future strategies:
[16:04:41.585] 1. multicore:
[16:04:41.585]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:41.585]    - tweaked: FALSE
[16:04:41.585]    - call: plan(strategy)
[16:04:41.589] plan(): nbrOfWorkers() = 2
[16:04:41.590] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:41.590] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:41.590]   - Field: ‘label’
[16:04:41.590]   - Field: ‘local’
[16:04:41.591]   - Field: ‘owner’
[16:04:41.591]   - Field: ‘envir’
[16:04:41.591]   - Field: ‘workers’
[16:04:41.591]   - Field: ‘packages’
[16:04:41.591]   - Field: ‘gc’
[16:04:41.592]   - Field: ‘job’
[16:04:41.592]   - Field: ‘conditions’
[16:04:41.592]   - Field: ‘expr’
[16:04:41.592]   - Field: ‘uuid’
[16:04:41.592]   - Field: ‘seed’
[16:04:41.592]   - Field: ‘version’
[16:04:41.592]   - Field: ‘result’
[16:04:41.593]   - Field: ‘asynchronous’
[16:04:41.593]   - Field: ‘calls’
[16:04:41.593]   - Field: ‘globals’
[16:04:41.593]   - Field: ‘stdout’
[16:04:41.593]   - Field: ‘earlySignal’
[16:04:41.593]   - Field: ‘lazy’
[16:04:41.593]   - Field: ‘state’
[16:04:41.594] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:41.594] - Launch lazy future ...
[16:04:41.594] Packages needed by the future expression (n = 0): <none>
[16:04:41.595] Packages needed by future strategies (n = 0): <none>
[16:04:41.595] {
[16:04:41.595]     {
[16:04:41.595]         {
[16:04:41.595]             ...future.startTime <- base::Sys.time()
[16:04:41.595]             {
[16:04:41.595]                 {
[16:04:41.595]                   {
[16:04:41.595]                     {
[16:04:41.595]                       base::local({
[16:04:41.595]                         has_future <- base::requireNamespace("future", 
[16:04:41.595]                           quietly = TRUE)
[16:04:41.595]                         if (has_future) {
[16:04:41.595]                           ns <- base::getNamespace("future")
[16:04:41.595]                           version <- ns[[".package"]][["version"]]
[16:04:41.595]                           if (is.null(version)) 
[16:04:41.595]                             version <- utils::packageVersion("future")
[16:04:41.595]                         }
[16:04:41.595]                         else {
[16:04:41.595]                           version <- NULL
[16:04:41.595]                         }
[16:04:41.595]                         if (!has_future || version < "1.8.0") {
[16:04:41.595]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.595]                             "", base::R.version$version.string), 
[16:04:41.595]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:41.595]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.595]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.595]                               "release", "version")], collapse = " "), 
[16:04:41.595]                             hostname = base::Sys.info()[["nodename"]])
[16:04:41.595]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.595]                             info)
[16:04:41.595]                           info <- base::paste(info, collapse = "; ")
[16:04:41.595]                           if (!has_future) {
[16:04:41.595]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.595]                               info)
[16:04:41.595]                           }
[16:04:41.595]                           else {
[16:04:41.595]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.595]                               info, version)
[16:04:41.595]                           }
[16:04:41.595]                           base::stop(msg)
[16:04:41.595]                         }
[16:04:41.595]                       })
[16:04:41.595]                     }
[16:04:41.595]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:41.595]                     base::options(mc.cores = 1L)
[16:04:41.595]                   }
[16:04:41.595]                   options(future.plan = NULL)
[16:04:41.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.595]                 }
[16:04:41.595]                 ...future.workdir <- getwd()
[16:04:41.595]             }
[16:04:41.595]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.595]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.595]         }
[16:04:41.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.595]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.595]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.595]             base::names(...future.oldOptions))
[16:04:41.595]     }
[16:04:41.595]     if (FALSE) {
[16:04:41.595]     }
[16:04:41.595]     else {
[16:04:41.595]         if (TRUE) {
[16:04:41.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.595]                 open = "w")
[16:04:41.595]         }
[16:04:41.595]         else {
[16:04:41.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.595]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.595]         }
[16:04:41.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.595]             base::sink(type = "output", split = FALSE)
[16:04:41.595]             base::close(...future.stdout)
[16:04:41.595]         }, add = TRUE)
[16:04:41.595]     }
[16:04:41.595]     ...future.frame <- base::sys.nframe()
[16:04:41.595]     ...future.conditions <- base::list()
[16:04:41.595]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.595]     if (FALSE) {
[16:04:41.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.595]     }
[16:04:41.595]     ...future.result <- base::tryCatch({
[16:04:41.595]         base::withCallingHandlers({
[16:04:41.595]             ...future.value <- base::withVisible(base::local({
[16:04:41.595]                 withCallingHandlers({
[16:04:41.595]                   NULL
[16:04:41.595]                 }, immediateCondition = function(cond) {
[16:04:41.595]                   save_rds <- function (object, pathname, ...) 
[16:04:41.595]                   {
[16:04:41.595]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:41.595]                     if (file_test("-f", pathname_tmp)) {
[16:04:41.595]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.595]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:41.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.595]                         fi_tmp[["mtime"]])
[16:04:41.595]                     }
[16:04:41.595]                     tryCatch({
[16:04:41.595]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:41.595]                     }, error = function(ex) {
[16:04:41.595]                       msg <- conditionMessage(ex)
[16:04:41.595]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.595]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:41.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.595]                         fi_tmp[["mtime"]], msg)
[16:04:41.595]                       ex$message <- msg
[16:04:41.595]                       stop(ex)
[16:04:41.595]                     })
[16:04:41.595]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:41.595]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:41.595]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:41.595]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.595]                       fi <- file.info(pathname)
[16:04:41.595]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:41.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.595]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:41.595]                         fi[["size"]], fi[["mtime"]])
[16:04:41.595]                       stop(msg)
[16:04:41.595]                     }
[16:04:41.595]                     invisible(pathname)
[16:04:41.595]                   }
[16:04:41.595]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:41.595]                     rootPath = tempdir()) 
[16:04:41.595]                   {
[16:04:41.595]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:41.595]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:41.595]                       tmpdir = path, fileext = ".rds")
[16:04:41.595]                     save_rds(obj, file)
[16:04:41.595]                   }
[16:04:41.595]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:41.595]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.595]                   {
[16:04:41.595]                     inherits <- base::inherits
[16:04:41.595]                     invokeRestart <- base::invokeRestart
[16:04:41.595]                     is.null <- base::is.null
[16:04:41.595]                     muffled <- FALSE
[16:04:41.595]                     if (inherits(cond, "message")) {
[16:04:41.595]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:41.595]                       if (muffled) 
[16:04:41.595]                         invokeRestart("muffleMessage")
[16:04:41.595]                     }
[16:04:41.595]                     else if (inherits(cond, "warning")) {
[16:04:41.595]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:41.595]                       if (muffled) 
[16:04:41.595]                         invokeRestart("muffleWarning")
[16:04:41.595]                     }
[16:04:41.595]                     else if (inherits(cond, "condition")) {
[16:04:41.595]                       if (!is.null(pattern)) {
[16:04:41.595]                         computeRestarts <- base::computeRestarts
[16:04:41.595]                         grepl <- base::grepl
[16:04:41.595]                         restarts <- computeRestarts(cond)
[16:04:41.595]                         for (restart in restarts) {
[16:04:41.595]                           name <- restart$name
[16:04:41.595]                           if (is.null(name)) 
[16:04:41.595]                             next
[16:04:41.595]                           if (!grepl(pattern, name)) 
[16:04:41.595]                             next
[16:04:41.595]                           invokeRestart(restart)
[16:04:41.595]                           muffled <- TRUE
[16:04:41.595]                           break
[16:04:41.595]                         }
[16:04:41.595]                       }
[16:04:41.595]                     }
[16:04:41.595]                     invisible(muffled)
[16:04:41.595]                   }
[16:04:41.595]                   muffleCondition(cond)
[16:04:41.595]                 })
[16:04:41.595]             }))
[16:04:41.595]             future::FutureResult(value = ...future.value$value, 
[16:04:41.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.595]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.595]                     ...future.globalenv.names))
[16:04:41.595]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.595]         }, condition = base::local({
[16:04:41.595]             c <- base::c
[16:04:41.595]             inherits <- base::inherits
[16:04:41.595]             invokeRestart <- base::invokeRestart
[16:04:41.595]             length <- base::length
[16:04:41.595]             list <- base::list
[16:04:41.595]             seq.int <- base::seq.int
[16:04:41.595]             signalCondition <- base::signalCondition
[16:04:41.595]             sys.calls <- base::sys.calls
[16:04:41.595]             `[[` <- base::`[[`
[16:04:41.595]             `+` <- base::`+`
[16:04:41.595]             `<<-` <- base::`<<-`
[16:04:41.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.595]                   3L)]
[16:04:41.595]             }
[16:04:41.595]             function(cond) {
[16:04:41.595]                 is_error <- inherits(cond, "error")
[16:04:41.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.595]                   NULL)
[16:04:41.595]                 if (is_error) {
[16:04:41.595]                   sessionInformation <- function() {
[16:04:41.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.595]                       search = base::search(), system = base::Sys.info())
[16:04:41.595]                   }
[16:04:41.595]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.595]                     cond$call), session = sessionInformation(), 
[16:04:41.595]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.595]                   signalCondition(cond)
[16:04:41.595]                 }
[16:04:41.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.595]                 "immediateCondition"))) {
[16:04:41.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.595]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.595]                   if (TRUE && !signal) {
[16:04:41.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.595]                     {
[16:04:41.595]                       inherits <- base::inherits
[16:04:41.595]                       invokeRestart <- base::invokeRestart
[16:04:41.595]                       is.null <- base::is.null
[16:04:41.595]                       muffled <- FALSE
[16:04:41.595]                       if (inherits(cond, "message")) {
[16:04:41.595]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.595]                         if (muffled) 
[16:04:41.595]                           invokeRestart("muffleMessage")
[16:04:41.595]                       }
[16:04:41.595]                       else if (inherits(cond, "warning")) {
[16:04:41.595]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.595]                         if (muffled) 
[16:04:41.595]                           invokeRestart("muffleWarning")
[16:04:41.595]                       }
[16:04:41.595]                       else if (inherits(cond, "condition")) {
[16:04:41.595]                         if (!is.null(pattern)) {
[16:04:41.595]                           computeRestarts <- base::computeRestarts
[16:04:41.595]                           grepl <- base::grepl
[16:04:41.595]                           restarts <- computeRestarts(cond)
[16:04:41.595]                           for (restart in restarts) {
[16:04:41.595]                             name <- restart$name
[16:04:41.595]                             if (is.null(name)) 
[16:04:41.595]                               next
[16:04:41.595]                             if (!grepl(pattern, name)) 
[16:04:41.595]                               next
[16:04:41.595]                             invokeRestart(restart)
[16:04:41.595]                             muffled <- TRUE
[16:04:41.595]                             break
[16:04:41.595]                           }
[16:04:41.595]                         }
[16:04:41.595]                       }
[16:04:41.595]                       invisible(muffled)
[16:04:41.595]                     }
[16:04:41.595]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.595]                   }
[16:04:41.595]                 }
[16:04:41.595]                 else {
[16:04:41.595]                   if (TRUE) {
[16:04:41.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.595]                     {
[16:04:41.595]                       inherits <- base::inherits
[16:04:41.595]                       invokeRestart <- base::invokeRestart
[16:04:41.595]                       is.null <- base::is.null
[16:04:41.595]                       muffled <- FALSE
[16:04:41.595]                       if (inherits(cond, "message")) {
[16:04:41.595]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.595]                         if (muffled) 
[16:04:41.595]                           invokeRestart("muffleMessage")
[16:04:41.595]                       }
[16:04:41.595]                       else if (inherits(cond, "warning")) {
[16:04:41.595]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.595]                         if (muffled) 
[16:04:41.595]                           invokeRestart("muffleWarning")
[16:04:41.595]                       }
[16:04:41.595]                       else if (inherits(cond, "condition")) {
[16:04:41.595]                         if (!is.null(pattern)) {
[16:04:41.595]                           computeRestarts <- base::computeRestarts
[16:04:41.595]                           grepl <- base::grepl
[16:04:41.595]                           restarts <- computeRestarts(cond)
[16:04:41.595]                           for (restart in restarts) {
[16:04:41.595]                             name <- restart$name
[16:04:41.595]                             if (is.null(name)) 
[16:04:41.595]                               next
[16:04:41.595]                             if (!grepl(pattern, name)) 
[16:04:41.595]                               next
[16:04:41.595]                             invokeRestart(restart)
[16:04:41.595]                             muffled <- TRUE
[16:04:41.595]                             break
[16:04:41.595]                           }
[16:04:41.595]                         }
[16:04:41.595]                       }
[16:04:41.595]                       invisible(muffled)
[16:04:41.595]                     }
[16:04:41.595]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.595]                   }
[16:04:41.595]                 }
[16:04:41.595]             }
[16:04:41.595]         }))
[16:04:41.595]     }, error = function(ex) {
[16:04:41.595]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.595]                 ...future.rng), started = ...future.startTime, 
[16:04:41.595]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.595]             version = "1.8"), class = "FutureResult")
[16:04:41.595]     }, finally = {
[16:04:41.595]         if (!identical(...future.workdir, getwd())) 
[16:04:41.595]             setwd(...future.workdir)
[16:04:41.595]         {
[16:04:41.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.595]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.595]             }
[16:04:41.595]             base::options(...future.oldOptions)
[16:04:41.595]             if (.Platform$OS.type == "windows") {
[16:04:41.595]                 old_names <- names(...future.oldEnvVars)
[16:04:41.595]                 envs <- base::Sys.getenv()
[16:04:41.595]                 names <- names(envs)
[16:04:41.595]                 common <- intersect(names, old_names)
[16:04:41.595]                 added <- setdiff(names, old_names)
[16:04:41.595]                 removed <- setdiff(old_names, names)
[16:04:41.595]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.595]                   envs[common]]
[16:04:41.595]                 NAMES <- toupper(changed)
[16:04:41.595]                 args <- list()
[16:04:41.595]                 for (kk in seq_along(NAMES)) {
[16:04:41.595]                   name <- changed[[kk]]
[16:04:41.595]                   NAME <- NAMES[[kk]]
[16:04:41.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.595]                     next
[16:04:41.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.595]                 }
[16:04:41.595]                 NAMES <- toupper(added)
[16:04:41.595]                 for (kk in seq_along(NAMES)) {
[16:04:41.595]                   name <- added[[kk]]
[16:04:41.595]                   NAME <- NAMES[[kk]]
[16:04:41.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.595]                     next
[16:04:41.595]                   args[[name]] <- ""
[16:04:41.595]                 }
[16:04:41.595]                 NAMES <- toupper(removed)
[16:04:41.595]                 for (kk in seq_along(NAMES)) {
[16:04:41.595]                   name <- removed[[kk]]
[16:04:41.595]                   NAME <- NAMES[[kk]]
[16:04:41.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.595]                     next
[16:04:41.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.595]                 }
[16:04:41.595]                 if (length(args) > 0) 
[16:04:41.595]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.595]             }
[16:04:41.595]             else {
[16:04:41.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.595]             }
[16:04:41.595]             {
[16:04:41.595]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.595]                   0L) {
[16:04:41.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.595]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.595]                   base::options(opts)
[16:04:41.595]                 }
[16:04:41.595]                 {
[16:04:41.595]                   {
[16:04:41.595]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:41.595]                     NULL
[16:04:41.595]                   }
[16:04:41.595]                   options(future.plan = NULL)
[16:04:41.595]                   if (is.na(NA_character_)) 
[16:04:41.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.595]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:41.595]                     envir = parent.frame()) 
[16:04:41.595]                   {
[16:04:41.595]                     default_workers <- missing(workers)
[16:04:41.595]                     if (is.function(workers)) 
[16:04:41.595]                       workers <- workers()
[16:04:41.595]                     workers <- structure(as.integer(workers), 
[16:04:41.595]                       class = class(workers))
[16:04:41.595]                     stop_if_not(is.finite(workers), workers >= 
[16:04:41.595]                       1L)
[16:04:41.595]                     if ((workers == 1L && !inherits(workers, 
[16:04:41.595]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:41.595]                       if (default_workers) 
[16:04:41.595]                         supportsMulticore(warn = TRUE)
[16:04:41.595]                       return(sequential(..., envir = envir))
[16:04:41.595]                     }
[16:04:41.595]                     oopts <- options(mc.cores = workers)
[16:04:41.595]                     on.exit(options(oopts))
[16:04:41.595]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:41.595]                       envir = envir)
[16:04:41.595]                     if (!future$lazy) 
[16:04:41.595]                       future <- run(future)
[16:04:41.595]                     invisible(future)
[16:04:41.595]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.595]                 }
[16:04:41.595]             }
[16:04:41.595]         }
[16:04:41.595]     })
[16:04:41.595]     if (TRUE) {
[16:04:41.595]         base::sink(type = "output", split = FALSE)
[16:04:41.595]         if (TRUE) {
[16:04:41.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.595]         }
[16:04:41.595]         else {
[16:04:41.595]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.595]         }
[16:04:41.595]         base::close(...future.stdout)
[16:04:41.595]         ...future.stdout <- NULL
[16:04:41.595]     }
[16:04:41.595]     ...future.result$conditions <- ...future.conditions
[16:04:41.595]     ...future.result$finished <- base::Sys.time()
[16:04:41.595]     ...future.result
[16:04:41.595] }
[16:04:41.599] requestCore(): workers = 2
[16:04:41.601] MulticoreFuture started
[16:04:41.601] - Launch lazy future ... done
[16:04:41.601] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[16:04:41.602] plan(): Setting new future strategy stack:
[16:04:41.602] List of future strategies:
[16:04:41.602] 1. sequential:
[16:04:41.602]    - args: function (..., envir = parent.frame())
[16:04:41.602]    - tweaked: FALSE
[16:04:41.602]    - call: NULL
 num 1
 $ b:[16:04:41.603] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874d609b58> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874db27ac8> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:04:41.605] plan(): Setting new future strategy stack:
[16:04:41.605] List of future strategies:
[16:04:41.605] 1. multicore:
[16:04:41.605]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:41.605]    - tweaked: FALSE
[16:04:41.605]    - call: plan(strategy)
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874d609b58> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874db27ac8> 
 $  : NULL
 $  :[16:04:41.613] plan(): nbrOfWorkers() = 2
 NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:41.619] resolve() on list ...
[16:04:41.620]  recursive: 0
[16:04:41.620]  length: 6
[16:04:41.620]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:41.620] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.621] - nx: 6
[16:04:41.621] - relay: TRUE
[16:04:41.621] - stdout: TRUE
[16:04:41.621] - signal: TRUE
[16:04:41.621] - resignal: FALSE
[16:04:41.621] - force: TRUE
[16:04:41.621] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.622] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.622]  - until=2
[16:04:41.622]  - relaying element #2
[16:04:41.622] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.622] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.622] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.622]  length: 5 (resolved future 1)
[16:04:41.623] Future #2
[16:04:41.623] result() for MulticoreFuture ...
[16:04:41.624] result() for MulticoreFuture ...
[16:04:41.624] result() for MulticoreFuture ... done
[16:04:41.624] result() for MulticoreFuture ... done
[16:04:41.624] result() for MulticoreFuture ...
[16:04:41.624] result() for MulticoreFuture ... done
[16:04:41.624] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:41.625] - nx: 6
[16:04:41.625] - relay: TRUE
[16:04:41.625] - stdout: TRUE
[16:04:41.625] - signal: TRUE
[16:04:41.625] - resignal: FALSE
[16:04:41.625] - force: TRUE
[16:04:41.625] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.625] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.626]  - until=2
[16:04:41.626]  - relaying element #2
[16:04:41.626] result() for MulticoreFuture ...
[16:04:41.626] result() for MulticoreFuture ... done
[16:04:41.626] result() for MulticoreFuture ...
[16:04:41.626] result() for MulticoreFuture ... done
[16:04:41.626] result() for MulticoreFuture ...
[16:04:41.627] result() for MulticoreFuture ... done
[16:04:41.627] result() for MulticoreFuture ...
[16:04:41.627] result() for MulticoreFuture ... done
[16:04:41.627] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.627] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.627] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:41.627]  length: 4 (resolved future 2)
[16:04:41.628] Future #3
[16:04:41.628] result() for MulticoreFuture ...
[16:04:41.628] result() for MulticoreFuture ...
[16:04:41.629] result() for MulticoreFuture ... done
[16:04:41.629] result() for MulticoreFuture ... done
[16:04:41.629] result() for MulticoreFuture ...
[16:04:41.629] result() for MulticoreFuture ... done
[16:04:41.629] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:41.629] - nx: 6
[16:04:41.629] - relay: TRUE
[16:04:41.629] - stdout: TRUE
[16:04:41.629] - signal: TRUE
[16:04:41.630] - resignal: FALSE
[16:04:41.630] - force: TRUE
[16:04:41.630] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.630] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.630]  - until=3
[16:04:41.630]  - relaying element #3
[16:04:41.630] result() for MulticoreFuture ...
[16:04:41.630] result() for MulticoreFuture ... done
[16:04:41.630] result() for MulticoreFuture ...
[16:04:41.631] result() for MulticoreFuture ... done
[16:04:41.631] result() for MulticoreFuture ...
[16:04:41.631] result() for MulticoreFuture ... done
[16:04:41.631] result() for MulticoreFuture ...
[16:04:41.631] result() for MulticoreFuture ... done
[16:04:41.631] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.631] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.631] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:41.631]  length: 3 (resolved future 3)
[16:04:41.632] signalConditionsASAP(NULL, pos=4) ...
[16:04:41.632] - nx: 6
[16:04:41.632] - relay: TRUE
[16:04:41.632] - stdout: TRUE
[16:04:41.632] - signal: TRUE
[16:04:41.632] - resignal: FALSE
[16:04:41.632] - force: TRUE
[16:04:41.632] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.632] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.632]  - until=5
[16:04:41.633]  - relaying element #5
[16:04:41.633] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.633] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.633] signalConditionsASAP(NULL, pos=4) ... done
[16:04:41.633]  length: 2 (resolved future 4)
[16:04:41.633] signalConditionsASAP(NULL, pos=5) ...
[16:04:41.633] - nx: 6
[16:04:41.633] - relay: TRUE
[16:04:41.633] - stdout: TRUE
[16:04:41.633] - signal: TRUE
[16:04:41.633] - resignal: FALSE
[16:04:41.634] - force: TRUE
[16:04:41.634] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.634] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.634]  - until=6
[16:04:41.634]  - relaying element #6
[16:04:41.634] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.634] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.634] signalConditionsASAP(NULL, pos=5) ... done
[16:04:41.634]  length: 1 (resolved future 5)
[16:04:41.634] signalConditionsASAP(numeric, pos=6) ...
[16:04:41.635] - nx: 6
[16:04:41.635] - relay: TRUE
[16:04:41.635] - stdout: TRUE
[16:04:41.635] - signal: TRUE
[16:04:41.635] - resignal: FALSE
[16:04:41.635] - force: TRUE
[16:04:41.635] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.635] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.635]  - until=6
[16:04:41.635] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.636] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.636] signalConditionsASAP(numeric, pos=6) ... done
[16:04:41.636]  length: 0 (resolved future 6)
[16:04:41.636] Relaying remaining futures
[16:04:41.636] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.636] - nx: 6
[16:04:41.636] - relay: TRUE
[16:04:41.636] - stdout: TRUE
[16:04:41.636] - signal: TRUE
[16:04:41.636] - resignal: FALSE
[16:04:41.636] - force: TRUE
[16:04:41.637] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.637] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:41.637] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.637] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.637] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.637] resolve() on list ... DONE
[16:04:41.637] result() for MulticoreFuture ...
[16:04:41.637] result() for MulticoreFuture ... done
[16:04:41.637] result() for MulticoreFuture ...
[16:04:41.637] result() for MulticoreFuture ... done
[16:04:41.638] result() for MulticoreFuture ...
[16:04:41.638] result() for MulticoreFuture ... done
[16:04:41.638] result() for MulticoreFuture ...
[16:04:41.638] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:04:41.641] getGlobalsAndPackages() ...
[16:04:41.641] Searching for globals...
[16:04:41.642] 
[16:04:41.642] Searching for globals ... DONE
[16:04:41.642] - globals: [0] <none>
[16:04:41.643] getGlobalsAndPackages() ... DONE
[16:04:41.644] run() for ‘Future’ ...
[16:04:41.644] - state: ‘created’
[16:04:41.644] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:41.648] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:41.648] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:41.648]   - Field: ‘label’
[16:04:41.648]   - Field: ‘local’
[16:04:41.648]   - Field: ‘owner’
[16:04:41.648]   - Field: ‘envir’
[16:04:41.649]   - Field: ‘workers’
[16:04:41.649]   - Field: ‘packages’
[16:04:41.649]   - Field: ‘gc’
[16:04:41.649]   - Field: ‘job’
[16:04:41.649]   - Field: ‘conditions’
[16:04:41.649]   - Field: ‘expr’
[16:04:41.649]   - Field: ‘uuid’
[16:04:41.649]   - Field: ‘seed’
[16:04:41.649]   - Field: ‘version’
[16:04:41.649]   - Field: ‘result’
[16:04:41.650]   - Field: ‘asynchronous’
[16:04:41.650]   - Field: ‘calls’
[16:04:41.650]   - Field: ‘globals’
[16:04:41.650]   - Field: ‘stdout’
[16:04:41.650]   - Field: ‘earlySignal’
[16:04:41.650]   - Field: ‘lazy’
[16:04:41.650]   - Field: ‘state’
[16:04:41.650] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:41.650] - Launch lazy future ...
[16:04:41.651] Packages needed by the future expression (n = 0): <none>
[16:04:41.651] Packages needed by future strategies (n = 0): <none>
[16:04:41.651] {
[16:04:41.651]     {
[16:04:41.651]         {
[16:04:41.651]             ...future.startTime <- base::Sys.time()
[16:04:41.651]             {
[16:04:41.651]                 {
[16:04:41.651]                   {
[16:04:41.651]                     {
[16:04:41.651]                       base::local({
[16:04:41.651]                         has_future <- base::requireNamespace("future", 
[16:04:41.651]                           quietly = TRUE)
[16:04:41.651]                         if (has_future) {
[16:04:41.651]                           ns <- base::getNamespace("future")
[16:04:41.651]                           version <- ns[[".package"]][["version"]]
[16:04:41.651]                           if (is.null(version)) 
[16:04:41.651]                             version <- utils::packageVersion("future")
[16:04:41.651]                         }
[16:04:41.651]                         else {
[16:04:41.651]                           version <- NULL
[16:04:41.651]                         }
[16:04:41.651]                         if (!has_future || version < "1.8.0") {
[16:04:41.651]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.651]                             "", base::R.version$version.string), 
[16:04:41.651]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:41.651]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.651]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.651]                               "release", "version")], collapse = " "), 
[16:04:41.651]                             hostname = base::Sys.info()[["nodename"]])
[16:04:41.651]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.651]                             info)
[16:04:41.651]                           info <- base::paste(info, collapse = "; ")
[16:04:41.651]                           if (!has_future) {
[16:04:41.651]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.651]                               info)
[16:04:41.651]                           }
[16:04:41.651]                           else {
[16:04:41.651]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.651]                               info, version)
[16:04:41.651]                           }
[16:04:41.651]                           base::stop(msg)
[16:04:41.651]                         }
[16:04:41.651]                       })
[16:04:41.651]                     }
[16:04:41.651]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:41.651]                     base::options(mc.cores = 1L)
[16:04:41.651]                   }
[16:04:41.651]                   options(future.plan = NULL)
[16:04:41.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.651]                 }
[16:04:41.651]                 ...future.workdir <- getwd()
[16:04:41.651]             }
[16:04:41.651]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.651]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.651]         }
[16:04:41.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.651]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.651]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.651]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.651]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.651]             base::names(...future.oldOptions))
[16:04:41.651]     }
[16:04:41.651]     if (FALSE) {
[16:04:41.651]     }
[16:04:41.651]     else {
[16:04:41.651]         if (TRUE) {
[16:04:41.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.651]                 open = "w")
[16:04:41.651]         }
[16:04:41.651]         else {
[16:04:41.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.651]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.651]         }
[16:04:41.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.651]             base::sink(type = "output", split = FALSE)
[16:04:41.651]             base::close(...future.stdout)
[16:04:41.651]         }, add = TRUE)
[16:04:41.651]     }
[16:04:41.651]     ...future.frame <- base::sys.nframe()
[16:04:41.651]     ...future.conditions <- base::list()
[16:04:41.651]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.651]     if (FALSE) {
[16:04:41.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.651]     }
[16:04:41.651]     ...future.result <- base::tryCatch({
[16:04:41.651]         base::withCallingHandlers({
[16:04:41.651]             ...future.value <- base::withVisible(base::local({
[16:04:41.651]                 withCallingHandlers({
[16:04:41.651]                   2
[16:04:41.651]                 }, immediateCondition = function(cond) {
[16:04:41.651]                   save_rds <- function (object, pathname, ...) 
[16:04:41.651]                   {
[16:04:41.651]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:41.651]                     if (file_test("-f", pathname_tmp)) {
[16:04:41.651]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.651]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:41.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.651]                         fi_tmp[["mtime"]])
[16:04:41.651]                     }
[16:04:41.651]                     tryCatch({
[16:04:41.651]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:41.651]                     }, error = function(ex) {
[16:04:41.651]                       msg <- conditionMessage(ex)
[16:04:41.651]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.651]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:41.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.651]                         fi_tmp[["mtime"]], msg)
[16:04:41.651]                       ex$message <- msg
[16:04:41.651]                       stop(ex)
[16:04:41.651]                     })
[16:04:41.651]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:41.651]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:41.651]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:41.651]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.651]                       fi <- file.info(pathname)
[16:04:41.651]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:41.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.651]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:41.651]                         fi[["size"]], fi[["mtime"]])
[16:04:41.651]                       stop(msg)
[16:04:41.651]                     }
[16:04:41.651]                     invisible(pathname)
[16:04:41.651]                   }
[16:04:41.651]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:41.651]                     rootPath = tempdir()) 
[16:04:41.651]                   {
[16:04:41.651]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:41.651]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:41.651]                       tmpdir = path, fileext = ".rds")
[16:04:41.651]                     save_rds(obj, file)
[16:04:41.651]                   }
[16:04:41.651]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:41.651]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.651]                   {
[16:04:41.651]                     inherits <- base::inherits
[16:04:41.651]                     invokeRestart <- base::invokeRestart
[16:04:41.651]                     is.null <- base::is.null
[16:04:41.651]                     muffled <- FALSE
[16:04:41.651]                     if (inherits(cond, "message")) {
[16:04:41.651]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:41.651]                       if (muffled) 
[16:04:41.651]                         invokeRestart("muffleMessage")
[16:04:41.651]                     }
[16:04:41.651]                     else if (inherits(cond, "warning")) {
[16:04:41.651]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:41.651]                       if (muffled) 
[16:04:41.651]                         invokeRestart("muffleWarning")
[16:04:41.651]                     }
[16:04:41.651]                     else if (inherits(cond, "condition")) {
[16:04:41.651]                       if (!is.null(pattern)) {
[16:04:41.651]                         computeRestarts <- base::computeRestarts
[16:04:41.651]                         grepl <- base::grepl
[16:04:41.651]                         restarts <- computeRestarts(cond)
[16:04:41.651]                         for (restart in restarts) {
[16:04:41.651]                           name <- restart$name
[16:04:41.651]                           if (is.null(name)) 
[16:04:41.651]                             next
[16:04:41.651]                           if (!grepl(pattern, name)) 
[16:04:41.651]                             next
[16:04:41.651]                           invokeRestart(restart)
[16:04:41.651]                           muffled <- TRUE
[16:04:41.651]                           break
[16:04:41.651]                         }
[16:04:41.651]                       }
[16:04:41.651]                     }
[16:04:41.651]                     invisible(muffled)
[16:04:41.651]                   }
[16:04:41.651]                   muffleCondition(cond)
[16:04:41.651]                 })
[16:04:41.651]             }))
[16:04:41.651]             future::FutureResult(value = ...future.value$value, 
[16:04:41.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.651]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.651]                     ...future.globalenv.names))
[16:04:41.651]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.651]         }, condition = base::local({
[16:04:41.651]             c <- base::c
[16:04:41.651]             inherits <- base::inherits
[16:04:41.651]             invokeRestart <- base::invokeRestart
[16:04:41.651]             length <- base::length
[16:04:41.651]             list <- base::list
[16:04:41.651]             seq.int <- base::seq.int
[16:04:41.651]             signalCondition <- base::signalCondition
[16:04:41.651]             sys.calls <- base::sys.calls
[16:04:41.651]             `[[` <- base::`[[`
[16:04:41.651]             `+` <- base::`+`
[16:04:41.651]             `<<-` <- base::`<<-`
[16:04:41.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.651]                   3L)]
[16:04:41.651]             }
[16:04:41.651]             function(cond) {
[16:04:41.651]                 is_error <- inherits(cond, "error")
[16:04:41.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.651]                   NULL)
[16:04:41.651]                 if (is_error) {
[16:04:41.651]                   sessionInformation <- function() {
[16:04:41.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.651]                       search = base::search(), system = base::Sys.info())
[16:04:41.651]                   }
[16:04:41.651]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.651]                     cond$call), session = sessionInformation(), 
[16:04:41.651]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.651]                   signalCondition(cond)
[16:04:41.651]                 }
[16:04:41.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.651]                 "immediateCondition"))) {
[16:04:41.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.651]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.651]                   if (TRUE && !signal) {
[16:04:41.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.651]                     {
[16:04:41.651]                       inherits <- base::inherits
[16:04:41.651]                       invokeRestart <- base::invokeRestart
[16:04:41.651]                       is.null <- base::is.null
[16:04:41.651]                       muffled <- FALSE
[16:04:41.651]                       if (inherits(cond, "message")) {
[16:04:41.651]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.651]                         if (muffled) 
[16:04:41.651]                           invokeRestart("muffleMessage")
[16:04:41.651]                       }
[16:04:41.651]                       else if (inherits(cond, "warning")) {
[16:04:41.651]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.651]                         if (muffled) 
[16:04:41.651]                           invokeRestart("muffleWarning")
[16:04:41.651]                       }
[16:04:41.651]                       else if (inherits(cond, "condition")) {
[16:04:41.651]                         if (!is.null(pattern)) {
[16:04:41.651]                           computeRestarts <- base::computeRestarts
[16:04:41.651]                           grepl <- base::grepl
[16:04:41.651]                           restarts <- computeRestarts(cond)
[16:04:41.651]                           for (restart in restarts) {
[16:04:41.651]                             name <- restart$name
[16:04:41.651]                             if (is.null(name)) 
[16:04:41.651]                               next
[16:04:41.651]                             if (!grepl(pattern, name)) 
[16:04:41.651]                               next
[16:04:41.651]                             invokeRestart(restart)
[16:04:41.651]                             muffled <- TRUE
[16:04:41.651]                             break
[16:04:41.651]                           }
[16:04:41.651]                         }
[16:04:41.651]                       }
[16:04:41.651]                       invisible(muffled)
[16:04:41.651]                     }
[16:04:41.651]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.651]                   }
[16:04:41.651]                 }
[16:04:41.651]                 else {
[16:04:41.651]                   if (TRUE) {
[16:04:41.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.651]                     {
[16:04:41.651]                       inherits <- base::inherits
[16:04:41.651]                       invokeRestart <- base::invokeRestart
[16:04:41.651]                       is.null <- base::is.null
[16:04:41.651]                       muffled <- FALSE
[16:04:41.651]                       if (inherits(cond, "message")) {
[16:04:41.651]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.651]                         if (muffled) 
[16:04:41.651]                           invokeRestart("muffleMessage")
[16:04:41.651]                       }
[16:04:41.651]                       else if (inherits(cond, "warning")) {
[16:04:41.651]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.651]                         if (muffled) 
[16:04:41.651]                           invokeRestart("muffleWarning")
[16:04:41.651]                       }
[16:04:41.651]                       else if (inherits(cond, "condition")) {
[16:04:41.651]                         if (!is.null(pattern)) {
[16:04:41.651]                           computeRestarts <- base::computeRestarts
[16:04:41.651]                           grepl <- base::grepl
[16:04:41.651]                           restarts <- computeRestarts(cond)
[16:04:41.651]                           for (restart in restarts) {
[16:04:41.651]                             name <- restart$name
[16:04:41.651]                             if (is.null(name)) 
[16:04:41.651]                               next
[16:04:41.651]                             if (!grepl(pattern, name)) 
[16:04:41.651]                               next
[16:04:41.651]                             invokeRestart(restart)
[16:04:41.651]                             muffled <- TRUE
[16:04:41.651]                             break
[16:04:41.651]                           }
[16:04:41.651]                         }
[16:04:41.651]                       }
[16:04:41.651]                       invisible(muffled)
[16:04:41.651]                     }
[16:04:41.651]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.651]                   }
[16:04:41.651]                 }
[16:04:41.651]             }
[16:04:41.651]         }))
[16:04:41.651]     }, error = function(ex) {
[16:04:41.651]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.651]                 ...future.rng), started = ...future.startTime, 
[16:04:41.651]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.651]             version = "1.8"), class = "FutureResult")
[16:04:41.651]     }, finally = {
[16:04:41.651]         if (!identical(...future.workdir, getwd())) 
[16:04:41.651]             setwd(...future.workdir)
[16:04:41.651]         {
[16:04:41.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.651]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.651]             }
[16:04:41.651]             base::options(...future.oldOptions)
[16:04:41.651]             if (.Platform$OS.type == "windows") {
[16:04:41.651]                 old_names <- names(...future.oldEnvVars)
[16:04:41.651]                 envs <- base::Sys.getenv()
[16:04:41.651]                 names <- names(envs)
[16:04:41.651]                 common <- intersect(names, old_names)
[16:04:41.651]                 added <- setdiff(names, old_names)
[16:04:41.651]                 removed <- setdiff(old_names, names)
[16:04:41.651]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.651]                   envs[common]]
[16:04:41.651]                 NAMES <- toupper(changed)
[16:04:41.651]                 args <- list()
[16:04:41.651]                 for (kk in seq_along(NAMES)) {
[16:04:41.651]                   name <- changed[[kk]]
[16:04:41.651]                   NAME <- NAMES[[kk]]
[16:04:41.651]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.651]                     next
[16:04:41.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.651]                 }
[16:04:41.651]                 NAMES <- toupper(added)
[16:04:41.651]                 for (kk in seq_along(NAMES)) {
[16:04:41.651]                   name <- added[[kk]]
[16:04:41.651]                   NAME <- NAMES[[kk]]
[16:04:41.651]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.651]                     next
[16:04:41.651]                   args[[name]] <- ""
[16:04:41.651]                 }
[16:04:41.651]                 NAMES <- toupper(removed)
[16:04:41.651]                 for (kk in seq_along(NAMES)) {
[16:04:41.651]                   name <- removed[[kk]]
[16:04:41.651]                   NAME <- NAMES[[kk]]
[16:04:41.651]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.651]                     next
[16:04:41.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.651]                 }
[16:04:41.651]                 if (length(args) > 0) 
[16:04:41.651]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.651]             }
[16:04:41.651]             else {
[16:04:41.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.651]             }
[16:04:41.651]             {
[16:04:41.651]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.651]                   0L) {
[16:04:41.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.651]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.651]                   base::options(opts)
[16:04:41.651]                 }
[16:04:41.651]                 {
[16:04:41.651]                   {
[16:04:41.651]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:41.651]                     NULL
[16:04:41.651]                   }
[16:04:41.651]                   options(future.plan = NULL)
[16:04:41.651]                   if (is.na(NA_character_)) 
[16:04:41.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.651]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:41.651]                     envir = parent.frame()) 
[16:04:41.651]                   {
[16:04:41.651]                     default_workers <- missing(workers)
[16:04:41.651]                     if (is.function(workers)) 
[16:04:41.651]                       workers <- workers()
[16:04:41.651]                     workers <- structure(as.integer(workers), 
[16:04:41.651]                       class = class(workers))
[16:04:41.651]                     stop_if_not(is.finite(workers), workers >= 
[16:04:41.651]                       1L)
[16:04:41.651]                     if ((workers == 1L && !inherits(workers, 
[16:04:41.651]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:41.651]                       if (default_workers) 
[16:04:41.651]                         supportsMulticore(warn = TRUE)
[16:04:41.651]                       return(sequential(..., envir = envir))
[16:04:41.651]                     }
[16:04:41.651]                     oopts <- options(mc.cores = workers)
[16:04:41.651]                     on.exit(options(oopts))
[16:04:41.651]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:41.651]                       envir = envir)
[16:04:41.651]                     if (!future$lazy) 
[16:04:41.651]                       future <- run(future)
[16:04:41.651]                     invisible(future)
[16:04:41.651]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.651]                 }
[16:04:41.651]             }
[16:04:41.651]         }
[16:04:41.651]     })
[16:04:41.651]     if (TRUE) {
[16:04:41.651]         base::sink(type = "output", split = FALSE)
[16:04:41.651]         if (TRUE) {
[16:04:41.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.651]         }
[16:04:41.651]         else {
[16:04:41.651]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.651]         }
[16:04:41.651]         base::close(...future.stdout)
[16:04:41.651]         ...future.stdout <- NULL
[16:04:41.651]     }
[16:04:41.651]     ...future.result$conditions <- ...future.conditions
[16:04:41.651]     ...future.result$finished <- base::Sys.time()
[16:04:41.651]     ...future.result
[16:04:41.651] }
[16:04:41.653] requestCore(): workers = 2
[16:04:41.655] MulticoreFuture started
[16:04:41.656] - Launch lazy future ... done
[16:04:41.656] run() for ‘MulticoreFuture’ ... done
[16:04:41.656] getGlobalsAndPackages() ...
[16:04:41.656] plan(): Setting new future strategy stack:
[16:04:41.656] Searching for globals...
[16:04:41.657] List of future strategies:
[16:04:41.657] 1. sequential:
[16:04:41.657]    - args: function (..., envir = parent.frame())
[16:04:41.657]    - tweaked: FALSE
[16:04:41.657]    - call: NULL
[16:04:41.657] 
[16:04:41.657] Searching for globals ... DONE
[16:04:41.658] plan(): nbrOfWorkers() = 1
[16:04:41.658] - globals: [0] <none>
[16:04:41.658] getGlobalsAndPackages() ... DONE
[16:04:41.658] run() for ‘Future’ ...
[16:04:41.659] - state: ‘created’
[16:04:41.659] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:41.659] plan(): Setting new future strategy stack:
[16:04:41.659] List of future strategies:
[16:04:41.659] 1. multicore:
[16:04:41.659]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:41.659]    - tweaked: FALSE
[16:04:41.659]    - call: plan(strategy)
[16:04:41.664] plan(): nbrOfWorkers() = 2
[16:04:41.665] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:41.665] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:41.665]   - Field: ‘label’
[16:04:41.665]   - Field: ‘local’
[16:04:41.665]   - Field: ‘owner’
[16:04:41.665]   - Field: ‘envir’
[16:04:41.666]   - Field: ‘workers’
[16:04:41.666]   - Field: ‘packages’
[16:04:41.666]   - Field: ‘gc’
[16:04:41.666]   - Field: ‘job’
[16:04:41.666]   - Field: ‘conditions’
[16:04:41.666]   - Field: ‘expr’
[16:04:41.667]   - Field: ‘uuid’
[16:04:41.667]   - Field: ‘seed’
[16:04:41.667]   - Field: ‘version’
[16:04:41.667]   - Field: ‘result’
[16:04:41.667]   - Field: ‘asynchronous’
[16:04:41.667]   - Field: ‘calls’
[16:04:41.668]   - Field: ‘globals’
[16:04:41.668]   - Field: ‘stdout’
[16:04:41.668]   - Field: ‘earlySignal’
[16:04:41.668]   - Field: ‘lazy’
[16:04:41.668]   - Field: ‘state’
[16:04:41.668] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:41.669] - Launch lazy future ...
[16:04:41.669] Packages needed by the future expression (n = 0): <none>
[16:04:41.669] Packages needed by future strategies (n = 0): <none>
[16:04:41.670] {
[16:04:41.670]     {
[16:04:41.670]         {
[16:04:41.670]             ...future.startTime <- base::Sys.time()
[16:04:41.670]             {
[16:04:41.670]                 {
[16:04:41.670]                   {
[16:04:41.670]                     {
[16:04:41.670]                       base::local({
[16:04:41.670]                         has_future <- base::requireNamespace("future", 
[16:04:41.670]                           quietly = TRUE)
[16:04:41.670]                         if (has_future) {
[16:04:41.670]                           ns <- base::getNamespace("future")
[16:04:41.670]                           version <- ns[[".package"]][["version"]]
[16:04:41.670]                           if (is.null(version)) 
[16:04:41.670]                             version <- utils::packageVersion("future")
[16:04:41.670]                         }
[16:04:41.670]                         else {
[16:04:41.670]                           version <- NULL
[16:04:41.670]                         }
[16:04:41.670]                         if (!has_future || version < "1.8.0") {
[16:04:41.670]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.670]                             "", base::R.version$version.string), 
[16:04:41.670]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:41.670]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.670]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.670]                               "release", "version")], collapse = " "), 
[16:04:41.670]                             hostname = base::Sys.info()[["nodename"]])
[16:04:41.670]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.670]                             info)
[16:04:41.670]                           info <- base::paste(info, collapse = "; ")
[16:04:41.670]                           if (!has_future) {
[16:04:41.670]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.670]                               info)
[16:04:41.670]                           }
[16:04:41.670]                           else {
[16:04:41.670]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.670]                               info, version)
[16:04:41.670]                           }
[16:04:41.670]                           base::stop(msg)
[16:04:41.670]                         }
[16:04:41.670]                       })
[16:04:41.670]                     }
[16:04:41.670]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:41.670]                     base::options(mc.cores = 1L)
[16:04:41.670]                   }
[16:04:41.670]                   options(future.plan = NULL)
[16:04:41.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.670]                 }
[16:04:41.670]                 ...future.workdir <- getwd()
[16:04:41.670]             }
[16:04:41.670]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.670]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.670]         }
[16:04:41.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.670]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.670]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.670]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.670]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.670]             base::names(...future.oldOptions))
[16:04:41.670]     }
[16:04:41.670]     if (FALSE) {
[16:04:41.670]     }
[16:04:41.670]     else {
[16:04:41.670]         if (TRUE) {
[16:04:41.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.670]                 open = "w")
[16:04:41.670]         }
[16:04:41.670]         else {
[16:04:41.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.670]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.670]         }
[16:04:41.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.670]             base::sink(type = "output", split = FALSE)
[16:04:41.670]             base::close(...future.stdout)
[16:04:41.670]         }, add = TRUE)
[16:04:41.670]     }
[16:04:41.670]     ...future.frame <- base::sys.nframe()
[16:04:41.670]     ...future.conditions <- base::list()
[16:04:41.670]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.670]     if (FALSE) {
[16:04:41.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.670]     }
[16:04:41.670]     ...future.result <- base::tryCatch({
[16:04:41.670]         base::withCallingHandlers({
[16:04:41.670]             ...future.value <- base::withVisible(base::local({
[16:04:41.670]                 withCallingHandlers({
[16:04:41.670]                   NULL
[16:04:41.670]                 }, immediateCondition = function(cond) {
[16:04:41.670]                   save_rds <- function (object, pathname, ...) 
[16:04:41.670]                   {
[16:04:41.670]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:41.670]                     if (file_test("-f", pathname_tmp)) {
[16:04:41.670]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.670]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:41.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.670]                         fi_tmp[["mtime"]])
[16:04:41.670]                     }
[16:04:41.670]                     tryCatch({
[16:04:41.670]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:41.670]                     }, error = function(ex) {
[16:04:41.670]                       msg <- conditionMessage(ex)
[16:04:41.670]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.670]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:41.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.670]                         fi_tmp[["mtime"]], msg)
[16:04:41.670]                       ex$message <- msg
[16:04:41.670]                       stop(ex)
[16:04:41.670]                     })
[16:04:41.670]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:41.670]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:41.670]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:41.670]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.670]                       fi <- file.info(pathname)
[16:04:41.670]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:41.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.670]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:41.670]                         fi[["size"]], fi[["mtime"]])
[16:04:41.670]                       stop(msg)
[16:04:41.670]                     }
[16:04:41.670]                     invisible(pathname)
[16:04:41.670]                   }
[16:04:41.670]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:41.670]                     rootPath = tempdir()) 
[16:04:41.670]                   {
[16:04:41.670]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:41.670]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:41.670]                       tmpdir = path, fileext = ".rds")
[16:04:41.670]                     save_rds(obj, file)
[16:04:41.670]                   }
[16:04:41.670]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:41.670]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.670]                   {
[16:04:41.670]                     inherits <- base::inherits
[16:04:41.670]                     invokeRestart <- base::invokeRestart
[16:04:41.670]                     is.null <- base::is.null
[16:04:41.670]                     muffled <- FALSE
[16:04:41.670]                     if (inherits(cond, "message")) {
[16:04:41.670]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:41.670]                       if (muffled) 
[16:04:41.670]                         invokeRestart("muffleMessage")
[16:04:41.670]                     }
[16:04:41.670]                     else if (inherits(cond, "warning")) {
[16:04:41.670]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:41.670]                       if (muffled) 
[16:04:41.670]                         invokeRestart("muffleWarning")
[16:04:41.670]                     }
[16:04:41.670]                     else if (inherits(cond, "condition")) {
[16:04:41.670]                       if (!is.null(pattern)) {
[16:04:41.670]                         computeRestarts <- base::computeRestarts
[16:04:41.670]                         grepl <- base::grepl
[16:04:41.670]                         restarts <- computeRestarts(cond)
[16:04:41.670]                         for (restart in restarts) {
[16:04:41.670]                           name <- restart$name
[16:04:41.670]                           if (is.null(name)) 
[16:04:41.670]                             next
[16:04:41.670]                           if (!grepl(pattern, name)) 
[16:04:41.670]                             next
[16:04:41.670]                           invokeRestart(restart)
[16:04:41.670]                           muffled <- TRUE
[16:04:41.670]                           break
[16:04:41.670]                         }
[16:04:41.670]                       }
[16:04:41.670]                     }
[16:04:41.670]                     invisible(muffled)
[16:04:41.670]                   }
[16:04:41.670]                   muffleCondition(cond)
[16:04:41.670]                 })
[16:04:41.670]             }))
[16:04:41.670]             future::FutureResult(value = ...future.value$value, 
[16:04:41.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.670]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.670]                     ...future.globalenv.names))
[16:04:41.670]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.670]         }, condition = base::local({
[16:04:41.670]             c <- base::c
[16:04:41.670]             inherits <- base::inherits
[16:04:41.670]             invokeRestart <- base::invokeRestart
[16:04:41.670]             length <- base::length
[16:04:41.670]             list <- base::list
[16:04:41.670]             seq.int <- base::seq.int
[16:04:41.670]             signalCondition <- base::signalCondition
[16:04:41.670]             sys.calls <- base::sys.calls
[16:04:41.670]             `[[` <- base::`[[`
[16:04:41.670]             `+` <- base::`+`
[16:04:41.670]             `<<-` <- base::`<<-`
[16:04:41.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.670]                   3L)]
[16:04:41.670]             }
[16:04:41.670]             function(cond) {
[16:04:41.670]                 is_error <- inherits(cond, "error")
[16:04:41.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.670]                   NULL)
[16:04:41.670]                 if (is_error) {
[16:04:41.670]                   sessionInformation <- function() {
[16:04:41.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.670]                       search = base::search(), system = base::Sys.info())
[16:04:41.670]                   }
[16:04:41.670]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.670]                     cond$call), session = sessionInformation(), 
[16:04:41.670]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.670]                   signalCondition(cond)
[16:04:41.670]                 }
[16:04:41.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.670]                 "immediateCondition"))) {
[16:04:41.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.670]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.670]                   if (TRUE && !signal) {
[16:04:41.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.670]                     {
[16:04:41.670]                       inherits <- base::inherits
[16:04:41.670]                       invokeRestart <- base::invokeRestart
[16:04:41.670]                       is.null <- base::is.null
[16:04:41.670]                       muffled <- FALSE
[16:04:41.670]                       if (inherits(cond, "message")) {
[16:04:41.670]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.670]                         if (muffled) 
[16:04:41.670]                           invokeRestart("muffleMessage")
[16:04:41.670]                       }
[16:04:41.670]                       else if (inherits(cond, "warning")) {
[16:04:41.670]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.670]                         if (muffled) 
[16:04:41.670]                           invokeRestart("muffleWarning")
[16:04:41.670]                       }
[16:04:41.670]                       else if (inherits(cond, "condition")) {
[16:04:41.670]                         if (!is.null(pattern)) {
[16:04:41.670]                           computeRestarts <- base::computeRestarts
[16:04:41.670]                           grepl <- base::grepl
[16:04:41.670]                           restarts <- computeRestarts(cond)
[16:04:41.670]                           for (restart in restarts) {
[16:04:41.670]                             name <- restart$name
[16:04:41.670]                             if (is.null(name)) 
[16:04:41.670]                               next
[16:04:41.670]                             if (!grepl(pattern, name)) 
[16:04:41.670]                               next
[16:04:41.670]                             invokeRestart(restart)
[16:04:41.670]                             muffled <- TRUE
[16:04:41.670]                             break
[16:04:41.670]                           }
[16:04:41.670]                         }
[16:04:41.670]                       }
[16:04:41.670]                       invisible(muffled)
[16:04:41.670]                     }
[16:04:41.670]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.670]                   }
[16:04:41.670]                 }
[16:04:41.670]                 else {
[16:04:41.670]                   if (TRUE) {
[16:04:41.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.670]                     {
[16:04:41.670]                       inherits <- base::inherits
[16:04:41.670]                       invokeRestart <- base::invokeRestart
[16:04:41.670]                       is.null <- base::is.null
[16:04:41.670]                       muffled <- FALSE
[16:04:41.670]                       if (inherits(cond, "message")) {
[16:04:41.670]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.670]                         if (muffled) 
[16:04:41.670]                           invokeRestart("muffleMessage")
[16:04:41.670]                       }
[16:04:41.670]                       else if (inherits(cond, "warning")) {
[16:04:41.670]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.670]                         if (muffled) 
[16:04:41.670]                           invokeRestart("muffleWarning")
[16:04:41.670]                       }
[16:04:41.670]                       else if (inherits(cond, "condition")) {
[16:04:41.670]                         if (!is.null(pattern)) {
[16:04:41.670]                           computeRestarts <- base::computeRestarts
[16:04:41.670]                           grepl <- base::grepl
[16:04:41.670]                           restarts <- computeRestarts(cond)
[16:04:41.670]                           for (restart in restarts) {
[16:04:41.670]                             name <- restart$name
[16:04:41.670]                             if (is.null(name)) 
[16:04:41.670]                               next
[16:04:41.670]                             if (!grepl(pattern, name)) 
[16:04:41.670]                               next
[16:04:41.670]                             invokeRestart(restart)
[16:04:41.670]                             muffled <- TRUE
[16:04:41.670]                             break
[16:04:41.670]                           }
[16:04:41.670]                         }
[16:04:41.670]                       }
[16:04:41.670]                       invisible(muffled)
[16:04:41.670]                     }
[16:04:41.670]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.670]                   }
[16:04:41.670]                 }
[16:04:41.670]             }
[16:04:41.670]         }))
[16:04:41.670]     }, error = function(ex) {
[16:04:41.670]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.670]                 ...future.rng), started = ...future.startTime, 
[16:04:41.670]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.670]             version = "1.8"), class = "FutureResult")
[16:04:41.670]     }, finally = {
[16:04:41.670]         if (!identical(...future.workdir, getwd())) 
[16:04:41.670]             setwd(...future.workdir)
[16:04:41.670]         {
[16:04:41.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.670]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.670]             }
[16:04:41.670]             base::options(...future.oldOptions)
[16:04:41.670]             if (.Platform$OS.type == "windows") {
[16:04:41.670]                 old_names <- names(...future.oldEnvVars)
[16:04:41.670]                 envs <- base::Sys.getenv()
[16:04:41.670]                 names <- names(envs)
[16:04:41.670]                 common <- intersect(names, old_names)
[16:04:41.670]                 added <- setdiff(names, old_names)
[16:04:41.670]                 removed <- setdiff(old_names, names)
[16:04:41.670]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.670]                   envs[common]]
[16:04:41.670]                 NAMES <- toupper(changed)
[16:04:41.670]                 args <- list()
[16:04:41.670]                 for (kk in seq_along(NAMES)) {
[16:04:41.670]                   name <- changed[[kk]]
[16:04:41.670]                   NAME <- NAMES[[kk]]
[16:04:41.670]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.670]                     next
[16:04:41.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.670]                 }
[16:04:41.670]                 NAMES <- toupper(added)
[16:04:41.670]                 for (kk in seq_along(NAMES)) {
[16:04:41.670]                   name <- added[[kk]]
[16:04:41.670]                   NAME <- NAMES[[kk]]
[16:04:41.670]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.670]                     next
[16:04:41.670]                   args[[name]] <- ""
[16:04:41.670]                 }
[16:04:41.670]                 NAMES <- toupper(removed)
[16:04:41.670]                 for (kk in seq_along(NAMES)) {
[16:04:41.670]                   name <- removed[[kk]]
[16:04:41.670]                   NAME <- NAMES[[kk]]
[16:04:41.670]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.670]                     next
[16:04:41.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.670]                 }
[16:04:41.670]                 if (length(args) > 0) 
[16:04:41.670]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.670]             }
[16:04:41.670]             else {
[16:04:41.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.670]             }
[16:04:41.670]             {
[16:04:41.670]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.670]                   0L) {
[16:04:41.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.670]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.670]                   base::options(opts)
[16:04:41.670]                 }
[16:04:41.670]                 {
[16:04:41.670]                   {
[16:04:41.670]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:41.670]                     NULL
[16:04:41.670]                   }
[16:04:41.670]                   options(future.plan = NULL)
[16:04:41.670]                   if (is.na(NA_character_)) 
[16:04:41.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.670]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:41.670]                     envir = parent.frame()) 
[16:04:41.670]                   {
[16:04:41.670]                     default_workers <- missing(workers)
[16:04:41.670]                     if (is.function(workers)) 
[16:04:41.670]                       workers <- workers()
[16:04:41.670]                     workers <- structure(as.integer(workers), 
[16:04:41.670]                       class = class(workers))
[16:04:41.670]                     stop_if_not(is.finite(workers), workers >= 
[16:04:41.670]                       1L)
[16:04:41.670]                     if ((workers == 1L && !inherits(workers, 
[16:04:41.670]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:41.670]                       if (default_workers) 
[16:04:41.670]                         supportsMulticore(warn = TRUE)
[16:04:41.670]                       return(sequential(..., envir = envir))
[16:04:41.670]                     }
[16:04:41.670]                     oopts <- options(mc.cores = workers)
[16:04:41.670]                     on.exit(options(oopts))
[16:04:41.670]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:41.670]                       envir = envir)
[16:04:41.670]                     if (!future$lazy) 
[16:04:41.670]                       future <- run(future)
[16:04:41.670]                     invisible(future)
[16:04:41.670]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.670]                 }
[16:04:41.670]             }
[16:04:41.670]         }
[16:04:41.670]     })
[16:04:41.670]     if (TRUE) {
[16:04:41.670]         base::sink(type = "output", split = FALSE)
[16:04:41.670]         if (TRUE) {
[16:04:41.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.670]         }
[16:04:41.670]         else {
[16:04:41.670]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.670]         }
[16:04:41.670]         base::close(...future.stdout)
[16:04:41.670]         ...future.stdout <- NULL
[16:04:41.670]     }
[16:04:41.670]     ...future.result$conditions <- ...future.conditions
[16:04:41.670]     ...future.result$finished <- base::Sys.time()
[16:04:41.670]     ...future.result
[16:04:41.670] }
[16:04:41.674] requestCore(): workers = 2
[16:04:41.676] MulticoreFuture started
[16:04:41.676] - Launch lazy future ... done
[16:04:41.676] run() for ‘MulticoreFuture’ ... done
List of 6
[16:04:41.677] plan(): Setting new future strategy stack:
 $ a:[16:04:41.677] List of future strategies:
[16:04:41.677] 1. sequential:
[16:04:41.677]    - args: function (..., envir = parent.frame())
[16:04:41.677]    - tweaked: FALSE
[16:04:41.677]    - call: NULL
 num 1
 $ b:[16:04:41.678] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874e3498a8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874d02fc90> 
 $  : NULL
 $  : NULL
 $  :[16:04:41.680] plan(): Setting new future strategy stack:
 num 6
[16:04:41.680] List of future strategies:
[16:04:41.680] 1. multicore:
[16:04:41.680]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:41.680]    - tweaked: FALSE
[16:04:41.680]    - call: plan(strategy)
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874e3498a8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874d02fc90> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ :[16:04:41.685] plan(): nbrOfWorkers() = 2
 chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:41.688] resolve() on list ...
[16:04:41.688]  recursive: 0
[16:04:41.688]  length: 6
[16:04:41.688]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:41.689] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.689] - nx: 6
[16:04:41.689] - relay: TRUE
[16:04:41.689] - stdout: TRUE
[16:04:41.689] - signal: TRUE
[16:04:41.689] - resignal: FALSE
[16:04:41.689] - force: TRUE
[16:04:41.689] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.690] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.690]  - until=2
[16:04:41.690]  - relaying element #2
[16:04:41.690] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.690] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.690] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.690]  length: 5 (resolved future 1)
[16:04:41.691] Future #2
[16:04:41.691] result() for MulticoreFuture ...
[16:04:41.692] result() for MulticoreFuture ...
[16:04:41.692] result() for MulticoreFuture ... done
[16:04:41.692] result() for MulticoreFuture ... done
[16:04:41.692] result() for MulticoreFuture ...
[16:04:41.693] result() for MulticoreFuture ... done
[16:04:41.693] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:41.693] - nx: 6
[16:04:41.693] - relay: TRUE
[16:04:41.693] - stdout: TRUE
[16:04:41.694] - signal: TRUE
[16:04:41.694] - resignal: FALSE
[16:04:41.694] - force: TRUE
[16:04:41.694] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.694] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.694]  - until=2
[16:04:41.695]  - relaying element #2
[16:04:41.695] result() for MulticoreFuture ...
[16:04:41.695] result() for MulticoreFuture ... done
[16:04:41.695] result() for MulticoreFuture ...
[16:04:41.695] result() for MulticoreFuture ... done
[16:04:41.699] result() for MulticoreFuture ...
[16:04:41.699] result() for MulticoreFuture ... done
[16:04:41.700] result() for MulticoreFuture ...
[16:04:41.700] result() for MulticoreFuture ... done
[16:04:41.700] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.700] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.701] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:41.701]  length: 4 (resolved future 2)
[16:04:41.701] Future #3
[16:04:41.702] result() for MulticoreFuture ...
[16:04:41.703] result() for MulticoreFuture ...
[16:04:41.703] result() for MulticoreFuture ... done
[16:04:41.703] result() for MulticoreFuture ... done
[16:04:41.703] result() for MulticoreFuture ...
[16:04:41.703] result() for MulticoreFuture ... done
[16:04:41.704] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:41.704] - nx: 6
[16:04:41.704] - relay: TRUE
[16:04:41.704] - stdout: TRUE
[16:04:41.704] - signal: TRUE
[16:04:41.704] - resignal: FALSE
[16:04:41.704] - force: TRUE
[16:04:41.704] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.704] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.705]  - until=3
[16:04:41.705]  - relaying element #3
[16:04:41.705] result() for MulticoreFuture ...
[16:04:41.705] result() for MulticoreFuture ... done
[16:04:41.705] result() for MulticoreFuture ...
[16:04:41.705] result() for MulticoreFuture ... done
[16:04:41.705] result() for MulticoreFuture ...
[16:04:41.705] result() for MulticoreFuture ... done
[16:04:41.706] result() for MulticoreFuture ...
[16:04:41.706] result() for MulticoreFuture ... done
[16:04:41.706] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.706] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.706] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:41.706]  length: 3 (resolved future 3)
[16:04:41.706] signalConditionsASAP(NULL, pos=4) ...
[16:04:41.707] - nx: 6
[16:04:41.707] - relay: TRUE
[16:04:41.707] - stdout: TRUE
[16:04:41.707] - signal: TRUE
[16:04:41.707] - resignal: FALSE
[16:04:41.707] - force: TRUE
[16:04:41.707] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.707] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.707]  - until=5
[16:04:41.708]  - relaying element #5
[16:04:41.708] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.708] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.708] signalConditionsASAP(NULL, pos=4) ... done
[16:04:41.708]  length: 2 (resolved future 4)
[16:04:41.708] signalConditionsASAP(NULL, pos=5) ...
[16:04:41.708] - nx: 6
[16:04:41.708] - relay: TRUE
[16:04:41.708] - stdout: TRUE
[16:04:41.709] - signal: TRUE
[16:04:41.709] - resignal: FALSE
[16:04:41.709] - force: TRUE
[16:04:41.709] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.709] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.709]  - until=6
[16:04:41.709]  - relaying element #6
[16:04:41.709] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.709] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.709] signalConditionsASAP(NULL, pos=5) ... done
[16:04:41.709]  length: 1 (resolved future 5)
[16:04:41.710] signalConditionsASAP(numeric, pos=6) ...
[16:04:41.710] - nx: 6
[16:04:41.710] - relay: TRUE
[16:04:41.710] - stdout: TRUE
[16:04:41.710] - signal: TRUE
[16:04:41.710] - resignal: FALSE
[16:04:41.710] - force: TRUE
[16:04:41.710] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.710] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.710]  - until=6
[16:04:41.711] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.711] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.711] signalConditionsASAP(numeric, pos=6) ... done
[16:04:41.711]  length: 0 (resolved future 6)
[16:04:41.711] Relaying remaining futures
[16:04:41.711] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.711] - nx: 6
[16:04:41.711] - relay: TRUE
[16:04:41.711] - stdout: TRUE
[16:04:41.711] - signal: TRUE
[16:04:41.712] - resignal: FALSE
[16:04:41.712] - force: TRUE
[16:04:41.712] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.712] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:41.712] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.712] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.712] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.712] resolve() on list ... DONE
[16:04:41.712] result() for MulticoreFuture ...
[16:04:41.713] result() for MulticoreFuture ... done
[16:04:41.713] result() for MulticoreFuture ...
[16:04:41.713] result() for MulticoreFuture ... done
[16:04:41.713] result() for MulticoreFuture ...
[16:04:41.713] result() for MulticoreFuture ... done
[16:04:41.713] result() for MulticoreFuture ...
[16:04:41.713] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:04:41.716] getGlobalsAndPackages() ...
[16:04:41.717] Searching for globals...
[16:04:41.717] 
[16:04:41.717] Searching for globals ... DONE
[16:04:41.717] - globals: [0] <none>
[16:04:41.717] getGlobalsAndPackages() ... DONE
[16:04:41.717] run() for ‘Future’ ...
[16:04:41.718] - state: ‘created’
[16:04:41.718] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:41.721] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:41.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:41.722]   - Field: ‘label’
[16:04:41.722]   - Field: ‘local’
[16:04:41.722]   - Field: ‘owner’
[16:04:41.722]   - Field: ‘envir’
[16:04:41.722]   - Field: ‘workers’
[16:04:41.722]   - Field: ‘packages’
[16:04:41.722]   - Field: ‘gc’
[16:04:41.722]   - Field: ‘job’
[16:04:41.722]   - Field: ‘conditions’
[16:04:41.723]   - Field: ‘expr’
[16:04:41.723]   - Field: ‘uuid’
[16:04:41.723]   - Field: ‘seed’
[16:04:41.723]   - Field: ‘version’
[16:04:41.723]   - Field: ‘result’
[16:04:41.723]   - Field: ‘asynchronous’
[16:04:41.723]   - Field: ‘calls’
[16:04:41.723]   - Field: ‘globals’
[16:04:41.723]   - Field: ‘stdout’
[16:04:41.723]   - Field: ‘earlySignal’
[16:04:41.724]   - Field: ‘lazy’
[16:04:41.724]   - Field: ‘state’
[16:04:41.724] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:41.724] - Launch lazy future ...
[16:04:41.724] Packages needed by the future expression (n = 0): <none>
[16:04:41.724] Packages needed by future strategies (n = 0): <none>
[16:04:41.725] {
[16:04:41.725]     {
[16:04:41.725]         {
[16:04:41.725]             ...future.startTime <- base::Sys.time()
[16:04:41.725]             {
[16:04:41.725]                 {
[16:04:41.725]                   {
[16:04:41.725]                     {
[16:04:41.725]                       base::local({
[16:04:41.725]                         has_future <- base::requireNamespace("future", 
[16:04:41.725]                           quietly = TRUE)
[16:04:41.725]                         if (has_future) {
[16:04:41.725]                           ns <- base::getNamespace("future")
[16:04:41.725]                           version <- ns[[".package"]][["version"]]
[16:04:41.725]                           if (is.null(version)) 
[16:04:41.725]                             version <- utils::packageVersion("future")
[16:04:41.725]                         }
[16:04:41.725]                         else {
[16:04:41.725]                           version <- NULL
[16:04:41.725]                         }
[16:04:41.725]                         if (!has_future || version < "1.8.0") {
[16:04:41.725]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.725]                             "", base::R.version$version.string), 
[16:04:41.725]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:41.725]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.725]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.725]                               "release", "version")], collapse = " "), 
[16:04:41.725]                             hostname = base::Sys.info()[["nodename"]])
[16:04:41.725]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.725]                             info)
[16:04:41.725]                           info <- base::paste(info, collapse = "; ")
[16:04:41.725]                           if (!has_future) {
[16:04:41.725]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.725]                               info)
[16:04:41.725]                           }
[16:04:41.725]                           else {
[16:04:41.725]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.725]                               info, version)
[16:04:41.725]                           }
[16:04:41.725]                           base::stop(msg)
[16:04:41.725]                         }
[16:04:41.725]                       })
[16:04:41.725]                     }
[16:04:41.725]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:41.725]                     base::options(mc.cores = 1L)
[16:04:41.725]                   }
[16:04:41.725]                   options(future.plan = NULL)
[16:04:41.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.725]                 }
[16:04:41.725]                 ...future.workdir <- getwd()
[16:04:41.725]             }
[16:04:41.725]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.725]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.725]         }
[16:04:41.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.725]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.725]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.725]             base::names(...future.oldOptions))
[16:04:41.725]     }
[16:04:41.725]     if (FALSE) {
[16:04:41.725]     }
[16:04:41.725]     else {
[16:04:41.725]         if (TRUE) {
[16:04:41.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.725]                 open = "w")
[16:04:41.725]         }
[16:04:41.725]         else {
[16:04:41.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.725]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.725]         }
[16:04:41.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.725]             base::sink(type = "output", split = FALSE)
[16:04:41.725]             base::close(...future.stdout)
[16:04:41.725]         }, add = TRUE)
[16:04:41.725]     }
[16:04:41.725]     ...future.frame <- base::sys.nframe()
[16:04:41.725]     ...future.conditions <- base::list()
[16:04:41.725]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.725]     if (FALSE) {
[16:04:41.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.725]     }
[16:04:41.725]     ...future.result <- base::tryCatch({
[16:04:41.725]         base::withCallingHandlers({
[16:04:41.725]             ...future.value <- base::withVisible(base::local({
[16:04:41.725]                 withCallingHandlers({
[16:04:41.725]                   2
[16:04:41.725]                 }, immediateCondition = function(cond) {
[16:04:41.725]                   save_rds <- function (object, pathname, ...) 
[16:04:41.725]                   {
[16:04:41.725]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:41.725]                     if (file_test("-f", pathname_tmp)) {
[16:04:41.725]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.725]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:41.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.725]                         fi_tmp[["mtime"]])
[16:04:41.725]                     }
[16:04:41.725]                     tryCatch({
[16:04:41.725]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:41.725]                     }, error = function(ex) {
[16:04:41.725]                       msg <- conditionMessage(ex)
[16:04:41.725]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.725]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:41.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.725]                         fi_tmp[["mtime"]], msg)
[16:04:41.725]                       ex$message <- msg
[16:04:41.725]                       stop(ex)
[16:04:41.725]                     })
[16:04:41.725]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:41.725]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:41.725]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:41.725]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.725]                       fi <- file.info(pathname)
[16:04:41.725]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:41.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.725]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:41.725]                         fi[["size"]], fi[["mtime"]])
[16:04:41.725]                       stop(msg)
[16:04:41.725]                     }
[16:04:41.725]                     invisible(pathname)
[16:04:41.725]                   }
[16:04:41.725]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:41.725]                     rootPath = tempdir()) 
[16:04:41.725]                   {
[16:04:41.725]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:41.725]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:41.725]                       tmpdir = path, fileext = ".rds")
[16:04:41.725]                     save_rds(obj, file)
[16:04:41.725]                   }
[16:04:41.725]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:41.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.725]                   {
[16:04:41.725]                     inherits <- base::inherits
[16:04:41.725]                     invokeRestart <- base::invokeRestart
[16:04:41.725]                     is.null <- base::is.null
[16:04:41.725]                     muffled <- FALSE
[16:04:41.725]                     if (inherits(cond, "message")) {
[16:04:41.725]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:41.725]                       if (muffled) 
[16:04:41.725]                         invokeRestart("muffleMessage")
[16:04:41.725]                     }
[16:04:41.725]                     else if (inherits(cond, "warning")) {
[16:04:41.725]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:41.725]                       if (muffled) 
[16:04:41.725]                         invokeRestart("muffleWarning")
[16:04:41.725]                     }
[16:04:41.725]                     else if (inherits(cond, "condition")) {
[16:04:41.725]                       if (!is.null(pattern)) {
[16:04:41.725]                         computeRestarts <- base::computeRestarts
[16:04:41.725]                         grepl <- base::grepl
[16:04:41.725]                         restarts <- computeRestarts(cond)
[16:04:41.725]                         for (restart in restarts) {
[16:04:41.725]                           name <- restart$name
[16:04:41.725]                           if (is.null(name)) 
[16:04:41.725]                             next
[16:04:41.725]                           if (!grepl(pattern, name)) 
[16:04:41.725]                             next
[16:04:41.725]                           invokeRestart(restart)
[16:04:41.725]                           muffled <- TRUE
[16:04:41.725]                           break
[16:04:41.725]                         }
[16:04:41.725]                       }
[16:04:41.725]                     }
[16:04:41.725]                     invisible(muffled)
[16:04:41.725]                   }
[16:04:41.725]                   muffleCondition(cond)
[16:04:41.725]                 })
[16:04:41.725]             }))
[16:04:41.725]             future::FutureResult(value = ...future.value$value, 
[16:04:41.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.725]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.725]                     ...future.globalenv.names))
[16:04:41.725]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.725]         }, condition = base::local({
[16:04:41.725]             c <- base::c
[16:04:41.725]             inherits <- base::inherits
[16:04:41.725]             invokeRestart <- base::invokeRestart
[16:04:41.725]             length <- base::length
[16:04:41.725]             list <- base::list
[16:04:41.725]             seq.int <- base::seq.int
[16:04:41.725]             signalCondition <- base::signalCondition
[16:04:41.725]             sys.calls <- base::sys.calls
[16:04:41.725]             `[[` <- base::`[[`
[16:04:41.725]             `+` <- base::`+`
[16:04:41.725]             `<<-` <- base::`<<-`
[16:04:41.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.725]                   3L)]
[16:04:41.725]             }
[16:04:41.725]             function(cond) {
[16:04:41.725]                 is_error <- inherits(cond, "error")
[16:04:41.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.725]                   NULL)
[16:04:41.725]                 if (is_error) {
[16:04:41.725]                   sessionInformation <- function() {
[16:04:41.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.725]                       search = base::search(), system = base::Sys.info())
[16:04:41.725]                   }
[16:04:41.725]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.725]                     cond$call), session = sessionInformation(), 
[16:04:41.725]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.725]                   signalCondition(cond)
[16:04:41.725]                 }
[16:04:41.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.725]                 "immediateCondition"))) {
[16:04:41.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.725]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.725]                   if (TRUE && !signal) {
[16:04:41.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.725]                     {
[16:04:41.725]                       inherits <- base::inherits
[16:04:41.725]                       invokeRestart <- base::invokeRestart
[16:04:41.725]                       is.null <- base::is.null
[16:04:41.725]                       muffled <- FALSE
[16:04:41.725]                       if (inherits(cond, "message")) {
[16:04:41.725]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.725]                         if (muffled) 
[16:04:41.725]                           invokeRestart("muffleMessage")
[16:04:41.725]                       }
[16:04:41.725]                       else if (inherits(cond, "warning")) {
[16:04:41.725]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.725]                         if (muffled) 
[16:04:41.725]                           invokeRestart("muffleWarning")
[16:04:41.725]                       }
[16:04:41.725]                       else if (inherits(cond, "condition")) {
[16:04:41.725]                         if (!is.null(pattern)) {
[16:04:41.725]                           computeRestarts <- base::computeRestarts
[16:04:41.725]                           grepl <- base::grepl
[16:04:41.725]                           restarts <- computeRestarts(cond)
[16:04:41.725]                           for (restart in restarts) {
[16:04:41.725]                             name <- restart$name
[16:04:41.725]                             if (is.null(name)) 
[16:04:41.725]                               next
[16:04:41.725]                             if (!grepl(pattern, name)) 
[16:04:41.725]                               next
[16:04:41.725]                             invokeRestart(restart)
[16:04:41.725]                             muffled <- TRUE
[16:04:41.725]                             break
[16:04:41.725]                           }
[16:04:41.725]                         }
[16:04:41.725]                       }
[16:04:41.725]                       invisible(muffled)
[16:04:41.725]                     }
[16:04:41.725]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.725]                   }
[16:04:41.725]                 }
[16:04:41.725]                 else {
[16:04:41.725]                   if (TRUE) {
[16:04:41.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.725]                     {
[16:04:41.725]                       inherits <- base::inherits
[16:04:41.725]                       invokeRestart <- base::invokeRestart
[16:04:41.725]                       is.null <- base::is.null
[16:04:41.725]                       muffled <- FALSE
[16:04:41.725]                       if (inherits(cond, "message")) {
[16:04:41.725]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.725]                         if (muffled) 
[16:04:41.725]                           invokeRestart("muffleMessage")
[16:04:41.725]                       }
[16:04:41.725]                       else if (inherits(cond, "warning")) {
[16:04:41.725]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.725]                         if (muffled) 
[16:04:41.725]                           invokeRestart("muffleWarning")
[16:04:41.725]                       }
[16:04:41.725]                       else if (inherits(cond, "condition")) {
[16:04:41.725]                         if (!is.null(pattern)) {
[16:04:41.725]                           computeRestarts <- base::computeRestarts
[16:04:41.725]                           grepl <- base::grepl
[16:04:41.725]                           restarts <- computeRestarts(cond)
[16:04:41.725]                           for (restart in restarts) {
[16:04:41.725]                             name <- restart$name
[16:04:41.725]                             if (is.null(name)) 
[16:04:41.725]                               next
[16:04:41.725]                             if (!grepl(pattern, name)) 
[16:04:41.725]                               next
[16:04:41.725]                             invokeRestart(restart)
[16:04:41.725]                             muffled <- TRUE
[16:04:41.725]                             break
[16:04:41.725]                           }
[16:04:41.725]                         }
[16:04:41.725]                       }
[16:04:41.725]                       invisible(muffled)
[16:04:41.725]                     }
[16:04:41.725]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.725]                   }
[16:04:41.725]                 }
[16:04:41.725]             }
[16:04:41.725]         }))
[16:04:41.725]     }, error = function(ex) {
[16:04:41.725]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.725]                 ...future.rng), started = ...future.startTime, 
[16:04:41.725]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.725]             version = "1.8"), class = "FutureResult")
[16:04:41.725]     }, finally = {
[16:04:41.725]         if (!identical(...future.workdir, getwd())) 
[16:04:41.725]             setwd(...future.workdir)
[16:04:41.725]         {
[16:04:41.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.725]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.725]             }
[16:04:41.725]             base::options(...future.oldOptions)
[16:04:41.725]             if (.Platform$OS.type == "windows") {
[16:04:41.725]                 old_names <- names(...future.oldEnvVars)
[16:04:41.725]                 envs <- base::Sys.getenv()
[16:04:41.725]                 names <- names(envs)
[16:04:41.725]                 common <- intersect(names, old_names)
[16:04:41.725]                 added <- setdiff(names, old_names)
[16:04:41.725]                 removed <- setdiff(old_names, names)
[16:04:41.725]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.725]                   envs[common]]
[16:04:41.725]                 NAMES <- toupper(changed)
[16:04:41.725]                 args <- list()
[16:04:41.725]                 for (kk in seq_along(NAMES)) {
[16:04:41.725]                   name <- changed[[kk]]
[16:04:41.725]                   NAME <- NAMES[[kk]]
[16:04:41.725]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.725]                     next
[16:04:41.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.725]                 }
[16:04:41.725]                 NAMES <- toupper(added)
[16:04:41.725]                 for (kk in seq_along(NAMES)) {
[16:04:41.725]                   name <- added[[kk]]
[16:04:41.725]                   NAME <- NAMES[[kk]]
[16:04:41.725]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.725]                     next
[16:04:41.725]                   args[[name]] <- ""
[16:04:41.725]                 }
[16:04:41.725]                 NAMES <- toupper(removed)
[16:04:41.725]                 for (kk in seq_along(NAMES)) {
[16:04:41.725]                   name <- removed[[kk]]
[16:04:41.725]                   NAME <- NAMES[[kk]]
[16:04:41.725]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.725]                     next
[16:04:41.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.725]                 }
[16:04:41.725]                 if (length(args) > 0) 
[16:04:41.725]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.725]             }
[16:04:41.725]             else {
[16:04:41.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.725]             }
[16:04:41.725]             {
[16:04:41.725]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.725]                   0L) {
[16:04:41.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.725]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.725]                   base::options(opts)
[16:04:41.725]                 }
[16:04:41.725]                 {
[16:04:41.725]                   {
[16:04:41.725]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:41.725]                     NULL
[16:04:41.725]                   }
[16:04:41.725]                   options(future.plan = NULL)
[16:04:41.725]                   if (is.na(NA_character_)) 
[16:04:41.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.725]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:41.725]                     envir = parent.frame()) 
[16:04:41.725]                   {
[16:04:41.725]                     default_workers <- missing(workers)
[16:04:41.725]                     if (is.function(workers)) 
[16:04:41.725]                       workers <- workers()
[16:04:41.725]                     workers <- structure(as.integer(workers), 
[16:04:41.725]                       class = class(workers))
[16:04:41.725]                     stop_if_not(is.finite(workers), workers >= 
[16:04:41.725]                       1L)
[16:04:41.725]                     if ((workers == 1L && !inherits(workers, 
[16:04:41.725]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:41.725]                       if (default_workers) 
[16:04:41.725]                         supportsMulticore(warn = TRUE)
[16:04:41.725]                       return(sequential(..., envir = envir))
[16:04:41.725]                     }
[16:04:41.725]                     oopts <- options(mc.cores = workers)
[16:04:41.725]                     on.exit(options(oopts))
[16:04:41.725]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:41.725]                       envir = envir)
[16:04:41.725]                     if (!future$lazy) 
[16:04:41.725]                       future <- run(future)
[16:04:41.725]                     invisible(future)
[16:04:41.725]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.725]                 }
[16:04:41.725]             }
[16:04:41.725]         }
[16:04:41.725]     })
[16:04:41.725]     if (TRUE) {
[16:04:41.725]         base::sink(type = "output", split = FALSE)
[16:04:41.725]         if (TRUE) {
[16:04:41.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.725]         }
[16:04:41.725]         else {
[16:04:41.725]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.725]         }
[16:04:41.725]         base::close(...future.stdout)
[16:04:41.725]         ...future.stdout <- NULL
[16:04:41.725]     }
[16:04:41.725]     ...future.result$conditions <- ...future.conditions
[16:04:41.725]     ...future.result$finished <- base::Sys.time()
[16:04:41.725]     ...future.result
[16:04:41.725] }
[16:04:41.727] requestCore(): workers = 2
[16:04:41.729] MulticoreFuture started
[16:04:41.729] - Launch lazy future ... done
[16:04:41.729] run() for ‘MulticoreFuture’ ... done
[16:04:41.730] getGlobalsAndPackages() ...
[16:04:41.730] Searching for globals...
[16:04:41.730] plan(): Setting new future strategy stack:
[16:04:41.731] 
[16:04:41.730] List of future strategies:
[16:04:41.730] 1. sequential:
[16:04:41.730]    - args: function (..., envir = parent.frame())
[16:04:41.730]    - tweaked: FALSE
[16:04:41.730]    - call: NULL
[16:04:41.731] Searching for globals ... DONE
[16:04:41.731] - globals: [0] <none>
[16:04:41.731] plan(): nbrOfWorkers() = 1
[16:04:41.731] getGlobalsAndPackages() ... DONE
[16:04:41.732] run() for ‘Future’ ...
[16:04:41.732] - state: ‘created’
[16:04:41.732] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:41.733] plan(): Setting new future strategy stack:
[16:04:41.733] List of future strategies:
[16:04:41.733] 1. multicore:
[16:04:41.733]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:41.733]    - tweaked: FALSE
[16:04:41.733]    - call: plan(strategy)
[16:04:41.737] plan(): nbrOfWorkers() = 2
[16:04:41.737] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:41.738] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:41.738]   - Field: ‘label’
[16:04:41.738]   - Field: ‘local’
[16:04:41.742]   - Field: ‘owner’
[16:04:41.742]   - Field: ‘envir’
[16:04:41.742]   - Field: ‘workers’
[16:04:41.743]   - Field: ‘packages’
[16:04:41.743]   - Field: ‘gc’
[16:04:41.743]   - Field: ‘job’
[16:04:41.744]   - Field: ‘conditions’
[16:04:41.744]   - Field: ‘expr’
[16:04:41.744]   - Field: ‘uuid’
[16:04:41.745]   - Field: ‘seed’
[16:04:41.745]   - Field: ‘version’
[16:04:41.745]   - Field: ‘result’
[16:04:41.746]   - Field: ‘asynchronous’
[16:04:41.746]   - Field: ‘calls’
[16:04:41.746]   - Field: ‘globals’
[16:04:41.746]   - Field: ‘stdout’
[16:04:41.747]   - Field: ‘earlySignal’
[16:04:41.747]   - Field: ‘lazy’
[16:04:41.747]   - Field: ‘state’
[16:04:41.747] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:41.747] - Launch lazy future ...
[16:04:41.748] Packages needed by the future expression (n = 0): <none>
[16:04:41.748] Packages needed by future strategies (n = 0): <none>
[16:04:41.749] {
[16:04:41.749]     {
[16:04:41.749]         {
[16:04:41.749]             ...future.startTime <- base::Sys.time()
[16:04:41.749]             {
[16:04:41.749]                 {
[16:04:41.749]                   {
[16:04:41.749]                     {
[16:04:41.749]                       base::local({
[16:04:41.749]                         has_future <- base::requireNamespace("future", 
[16:04:41.749]                           quietly = TRUE)
[16:04:41.749]                         if (has_future) {
[16:04:41.749]                           ns <- base::getNamespace("future")
[16:04:41.749]                           version <- ns[[".package"]][["version"]]
[16:04:41.749]                           if (is.null(version)) 
[16:04:41.749]                             version <- utils::packageVersion("future")
[16:04:41.749]                         }
[16:04:41.749]                         else {
[16:04:41.749]                           version <- NULL
[16:04:41.749]                         }
[16:04:41.749]                         if (!has_future || version < "1.8.0") {
[16:04:41.749]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.749]                             "", base::R.version$version.string), 
[16:04:41.749]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:41.749]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.749]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.749]                               "release", "version")], collapse = " "), 
[16:04:41.749]                             hostname = base::Sys.info()[["nodename"]])
[16:04:41.749]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.749]                             info)
[16:04:41.749]                           info <- base::paste(info, collapse = "; ")
[16:04:41.749]                           if (!has_future) {
[16:04:41.749]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.749]                               info)
[16:04:41.749]                           }
[16:04:41.749]                           else {
[16:04:41.749]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.749]                               info, version)
[16:04:41.749]                           }
[16:04:41.749]                           base::stop(msg)
[16:04:41.749]                         }
[16:04:41.749]                       })
[16:04:41.749]                     }
[16:04:41.749]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:41.749]                     base::options(mc.cores = 1L)
[16:04:41.749]                   }
[16:04:41.749]                   options(future.plan = NULL)
[16:04:41.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.749]                 }
[16:04:41.749]                 ...future.workdir <- getwd()
[16:04:41.749]             }
[16:04:41.749]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.749]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.749]         }
[16:04:41.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.749]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.749]             base::names(...future.oldOptions))
[16:04:41.749]     }
[16:04:41.749]     if (FALSE) {
[16:04:41.749]     }
[16:04:41.749]     else {
[16:04:41.749]         if (TRUE) {
[16:04:41.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.749]                 open = "w")
[16:04:41.749]         }
[16:04:41.749]         else {
[16:04:41.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.749]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.749]         }
[16:04:41.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.749]             base::sink(type = "output", split = FALSE)
[16:04:41.749]             base::close(...future.stdout)
[16:04:41.749]         }, add = TRUE)
[16:04:41.749]     }
[16:04:41.749]     ...future.frame <- base::sys.nframe()
[16:04:41.749]     ...future.conditions <- base::list()
[16:04:41.749]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.749]     if (FALSE) {
[16:04:41.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.749]     }
[16:04:41.749]     ...future.result <- base::tryCatch({
[16:04:41.749]         base::withCallingHandlers({
[16:04:41.749]             ...future.value <- base::withVisible(base::local({
[16:04:41.749]                 withCallingHandlers({
[16:04:41.749]                   NULL
[16:04:41.749]                 }, immediateCondition = function(cond) {
[16:04:41.749]                   save_rds <- function (object, pathname, ...) 
[16:04:41.749]                   {
[16:04:41.749]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:41.749]                     if (file_test("-f", pathname_tmp)) {
[16:04:41.749]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.749]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:41.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.749]                         fi_tmp[["mtime"]])
[16:04:41.749]                     }
[16:04:41.749]                     tryCatch({
[16:04:41.749]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:41.749]                     }, error = function(ex) {
[16:04:41.749]                       msg <- conditionMessage(ex)
[16:04:41.749]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.749]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:41.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.749]                         fi_tmp[["mtime"]], msg)
[16:04:41.749]                       ex$message <- msg
[16:04:41.749]                       stop(ex)
[16:04:41.749]                     })
[16:04:41.749]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:41.749]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:41.749]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:41.749]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.749]                       fi <- file.info(pathname)
[16:04:41.749]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:41.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.749]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:41.749]                         fi[["size"]], fi[["mtime"]])
[16:04:41.749]                       stop(msg)
[16:04:41.749]                     }
[16:04:41.749]                     invisible(pathname)
[16:04:41.749]                   }
[16:04:41.749]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:41.749]                     rootPath = tempdir()) 
[16:04:41.749]                   {
[16:04:41.749]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:41.749]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:41.749]                       tmpdir = path, fileext = ".rds")
[16:04:41.749]                     save_rds(obj, file)
[16:04:41.749]                   }
[16:04:41.749]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:41.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.749]                   {
[16:04:41.749]                     inherits <- base::inherits
[16:04:41.749]                     invokeRestart <- base::invokeRestart
[16:04:41.749]                     is.null <- base::is.null
[16:04:41.749]                     muffled <- FALSE
[16:04:41.749]                     if (inherits(cond, "message")) {
[16:04:41.749]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:41.749]                       if (muffled) 
[16:04:41.749]                         invokeRestart("muffleMessage")
[16:04:41.749]                     }
[16:04:41.749]                     else if (inherits(cond, "warning")) {
[16:04:41.749]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:41.749]                       if (muffled) 
[16:04:41.749]                         invokeRestart("muffleWarning")
[16:04:41.749]                     }
[16:04:41.749]                     else if (inherits(cond, "condition")) {
[16:04:41.749]                       if (!is.null(pattern)) {
[16:04:41.749]                         computeRestarts <- base::computeRestarts
[16:04:41.749]                         grepl <- base::grepl
[16:04:41.749]                         restarts <- computeRestarts(cond)
[16:04:41.749]                         for (restart in restarts) {
[16:04:41.749]                           name <- restart$name
[16:04:41.749]                           if (is.null(name)) 
[16:04:41.749]                             next
[16:04:41.749]                           if (!grepl(pattern, name)) 
[16:04:41.749]                             next
[16:04:41.749]                           invokeRestart(restart)
[16:04:41.749]                           muffled <- TRUE
[16:04:41.749]                           break
[16:04:41.749]                         }
[16:04:41.749]                       }
[16:04:41.749]                     }
[16:04:41.749]                     invisible(muffled)
[16:04:41.749]                   }
[16:04:41.749]                   muffleCondition(cond)
[16:04:41.749]                 })
[16:04:41.749]             }))
[16:04:41.749]             future::FutureResult(value = ...future.value$value, 
[16:04:41.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.749]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.749]                     ...future.globalenv.names))
[16:04:41.749]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.749]         }, condition = base::local({
[16:04:41.749]             c <- base::c
[16:04:41.749]             inherits <- base::inherits
[16:04:41.749]             invokeRestart <- base::invokeRestart
[16:04:41.749]             length <- base::length
[16:04:41.749]             list <- base::list
[16:04:41.749]             seq.int <- base::seq.int
[16:04:41.749]             signalCondition <- base::signalCondition
[16:04:41.749]             sys.calls <- base::sys.calls
[16:04:41.749]             `[[` <- base::`[[`
[16:04:41.749]             `+` <- base::`+`
[16:04:41.749]             `<<-` <- base::`<<-`
[16:04:41.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.749]                   3L)]
[16:04:41.749]             }
[16:04:41.749]             function(cond) {
[16:04:41.749]                 is_error <- inherits(cond, "error")
[16:04:41.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.749]                   NULL)
[16:04:41.749]                 if (is_error) {
[16:04:41.749]                   sessionInformation <- function() {
[16:04:41.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.749]                       search = base::search(), system = base::Sys.info())
[16:04:41.749]                   }
[16:04:41.749]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.749]                     cond$call), session = sessionInformation(), 
[16:04:41.749]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.749]                   signalCondition(cond)
[16:04:41.749]                 }
[16:04:41.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.749]                 "immediateCondition"))) {
[16:04:41.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.749]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.749]                   if (TRUE && !signal) {
[16:04:41.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.749]                     {
[16:04:41.749]                       inherits <- base::inherits
[16:04:41.749]                       invokeRestart <- base::invokeRestart
[16:04:41.749]                       is.null <- base::is.null
[16:04:41.749]                       muffled <- FALSE
[16:04:41.749]                       if (inherits(cond, "message")) {
[16:04:41.749]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.749]                         if (muffled) 
[16:04:41.749]                           invokeRestart("muffleMessage")
[16:04:41.749]                       }
[16:04:41.749]                       else if (inherits(cond, "warning")) {
[16:04:41.749]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.749]                         if (muffled) 
[16:04:41.749]                           invokeRestart("muffleWarning")
[16:04:41.749]                       }
[16:04:41.749]                       else if (inherits(cond, "condition")) {
[16:04:41.749]                         if (!is.null(pattern)) {
[16:04:41.749]                           computeRestarts <- base::computeRestarts
[16:04:41.749]                           grepl <- base::grepl
[16:04:41.749]                           restarts <- computeRestarts(cond)
[16:04:41.749]                           for (restart in restarts) {
[16:04:41.749]                             name <- restart$name
[16:04:41.749]                             if (is.null(name)) 
[16:04:41.749]                               next
[16:04:41.749]                             if (!grepl(pattern, name)) 
[16:04:41.749]                               next
[16:04:41.749]                             invokeRestart(restart)
[16:04:41.749]                             muffled <- TRUE
[16:04:41.749]                             break
[16:04:41.749]                           }
[16:04:41.749]                         }
[16:04:41.749]                       }
[16:04:41.749]                       invisible(muffled)
[16:04:41.749]                     }
[16:04:41.749]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.749]                   }
[16:04:41.749]                 }
[16:04:41.749]                 else {
[16:04:41.749]                   if (TRUE) {
[16:04:41.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.749]                     {
[16:04:41.749]                       inherits <- base::inherits
[16:04:41.749]                       invokeRestart <- base::invokeRestart
[16:04:41.749]                       is.null <- base::is.null
[16:04:41.749]                       muffled <- FALSE
[16:04:41.749]                       if (inherits(cond, "message")) {
[16:04:41.749]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.749]                         if (muffled) 
[16:04:41.749]                           invokeRestart("muffleMessage")
[16:04:41.749]                       }
[16:04:41.749]                       else if (inherits(cond, "warning")) {
[16:04:41.749]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.749]                         if (muffled) 
[16:04:41.749]                           invokeRestart("muffleWarning")
[16:04:41.749]                       }
[16:04:41.749]                       else if (inherits(cond, "condition")) {
[16:04:41.749]                         if (!is.null(pattern)) {
[16:04:41.749]                           computeRestarts <- base::computeRestarts
[16:04:41.749]                           grepl <- base::grepl
[16:04:41.749]                           restarts <- computeRestarts(cond)
[16:04:41.749]                           for (restart in restarts) {
[16:04:41.749]                             name <- restart$name
[16:04:41.749]                             if (is.null(name)) 
[16:04:41.749]                               next
[16:04:41.749]                             if (!grepl(pattern, name)) 
[16:04:41.749]                               next
[16:04:41.749]                             invokeRestart(restart)
[16:04:41.749]                             muffled <- TRUE
[16:04:41.749]                             break
[16:04:41.749]                           }
[16:04:41.749]                         }
[16:04:41.749]                       }
[16:04:41.749]                       invisible(muffled)
[16:04:41.749]                     }
[16:04:41.749]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.749]                   }
[16:04:41.749]                 }
[16:04:41.749]             }
[16:04:41.749]         }))
[16:04:41.749]     }, error = function(ex) {
[16:04:41.749]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.749]                 ...future.rng), started = ...future.startTime, 
[16:04:41.749]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.749]             version = "1.8"), class = "FutureResult")
[16:04:41.749]     }, finally = {
[16:04:41.749]         if (!identical(...future.workdir, getwd())) 
[16:04:41.749]             setwd(...future.workdir)
[16:04:41.749]         {
[16:04:41.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.749]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.749]             }
[16:04:41.749]             base::options(...future.oldOptions)
[16:04:41.749]             if (.Platform$OS.type == "windows") {
[16:04:41.749]                 old_names <- names(...future.oldEnvVars)
[16:04:41.749]                 envs <- base::Sys.getenv()
[16:04:41.749]                 names <- names(envs)
[16:04:41.749]                 common <- intersect(names, old_names)
[16:04:41.749]                 added <- setdiff(names, old_names)
[16:04:41.749]                 removed <- setdiff(old_names, names)
[16:04:41.749]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.749]                   envs[common]]
[16:04:41.749]                 NAMES <- toupper(changed)
[16:04:41.749]                 args <- list()
[16:04:41.749]                 for (kk in seq_along(NAMES)) {
[16:04:41.749]                   name <- changed[[kk]]
[16:04:41.749]                   NAME <- NAMES[[kk]]
[16:04:41.749]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.749]                     next
[16:04:41.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.749]                 }
[16:04:41.749]                 NAMES <- toupper(added)
[16:04:41.749]                 for (kk in seq_along(NAMES)) {
[16:04:41.749]                   name <- added[[kk]]
[16:04:41.749]                   NAME <- NAMES[[kk]]
[16:04:41.749]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.749]                     next
[16:04:41.749]                   args[[name]] <- ""
[16:04:41.749]                 }
[16:04:41.749]                 NAMES <- toupper(removed)
[16:04:41.749]                 for (kk in seq_along(NAMES)) {
[16:04:41.749]                   name <- removed[[kk]]
[16:04:41.749]                   NAME <- NAMES[[kk]]
[16:04:41.749]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.749]                     next
[16:04:41.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.749]                 }
[16:04:41.749]                 if (length(args) > 0) 
[16:04:41.749]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.749]             }
[16:04:41.749]             else {
[16:04:41.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.749]             }
[16:04:41.749]             {
[16:04:41.749]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.749]                   0L) {
[16:04:41.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.749]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.749]                   base::options(opts)
[16:04:41.749]                 }
[16:04:41.749]                 {
[16:04:41.749]                   {
[16:04:41.749]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:41.749]                     NULL
[16:04:41.749]                   }
[16:04:41.749]                   options(future.plan = NULL)
[16:04:41.749]                   if (is.na(NA_character_)) 
[16:04:41.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.749]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:41.749]                     envir = parent.frame()) 
[16:04:41.749]                   {
[16:04:41.749]                     default_workers <- missing(workers)
[16:04:41.749]                     if (is.function(workers)) 
[16:04:41.749]                       workers <- workers()
[16:04:41.749]                     workers <- structure(as.integer(workers), 
[16:04:41.749]                       class = class(workers))
[16:04:41.749]                     stop_if_not(is.finite(workers), workers >= 
[16:04:41.749]                       1L)
[16:04:41.749]                     if ((workers == 1L && !inherits(workers, 
[16:04:41.749]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:41.749]                       if (default_workers) 
[16:04:41.749]                         supportsMulticore(warn = TRUE)
[16:04:41.749]                       return(sequential(..., envir = envir))
[16:04:41.749]                     }
[16:04:41.749]                     oopts <- options(mc.cores = workers)
[16:04:41.749]                     on.exit(options(oopts))
[16:04:41.749]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:41.749]                       envir = envir)
[16:04:41.749]                     if (!future$lazy) 
[16:04:41.749]                       future <- run(future)
[16:04:41.749]                     invisible(future)
[16:04:41.749]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.749]                 }
[16:04:41.749]             }
[16:04:41.749]         }
[16:04:41.749]     })
[16:04:41.749]     if (TRUE) {
[16:04:41.749]         base::sink(type = "output", split = FALSE)
[16:04:41.749]         if (TRUE) {
[16:04:41.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.749]         }
[16:04:41.749]         else {
[16:04:41.749]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.749]         }
[16:04:41.749]         base::close(...future.stdout)
[16:04:41.749]         ...future.stdout <- NULL
[16:04:41.749]     }
[16:04:41.749]     ...future.result$conditions <- ...future.conditions
[16:04:41.749]     ...future.result$finished <- base::Sys.time()
[16:04:41.749]     ...future.result
[16:04:41.749] }
[16:04:41.752] requestCore(): workers = 2
[16:04:41.754] MulticoreFuture started
[16:04:41.754] - Launch lazy future ... done
[16:04:41.755] run() for ‘MulticoreFuture’ ... done
[16:04:41.755] plan(): Setting new future strategy stack:
List of 6
 $ a:[16:04:41.756] List of future strategies:
[16:04:41.756] 1. sequential:
[16:04:41.756]    - args: function (..., envir = parent.frame())
[16:04:41.756]    - tweaked: FALSE
[16:04:41.756]    - call: NULL
 num 1
[16:04:41.757] plan(): nbrOfWorkers() = 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874daa9bd0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874dfd35a0> 
 $  : NULL
 $  :[16:04:41.759] plan(): Setting new future strategy stack:
 NULL
 $  :[16:04:41.759] List of future strategies:
[16:04:41.759] 1. multicore:
[16:04:41.759]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:41.759]    - tweaked: FALSE
[16:04:41.759]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874daa9bd0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874dfd35a0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ :[16:04:41.765] plan(): nbrOfWorkers() = 2
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:41.770] resolve() on list ...
[16:04:41.770]  recursive: 0
[16:04:41.770]  length: 6
[16:04:41.770]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:41.770] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.770] - nx: 6
[16:04:41.771] - relay: TRUE
[16:04:41.771] - stdout: TRUE
[16:04:41.771] - signal: TRUE
[16:04:41.771] - resignal: FALSE
[16:04:41.771] - force: TRUE
[16:04:41.771] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.771] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.772]  - until=2
[16:04:41.772]  - relaying element #2
[16:04:41.772] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.772] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.772] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.772]  length: 5 (resolved future 1)
[16:04:41.773] Future #2
[16:04:41.773] result() for MulticoreFuture ...
[16:04:41.774] result() for MulticoreFuture ...
[16:04:41.774] result() for MulticoreFuture ... done
[16:04:41.774] result() for MulticoreFuture ... done
[16:04:41.774] result() for MulticoreFuture ...
[16:04:41.774] result() for MulticoreFuture ... done
[16:04:41.774] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:41.774] - nx: 6
[16:04:41.775] - relay: TRUE
[16:04:41.775] - stdout: TRUE
[16:04:41.775] - signal: TRUE
[16:04:41.775] - resignal: FALSE
[16:04:41.775] - force: TRUE
[16:04:41.775] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.775] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.776]  - until=2
[16:04:41.776]  - relaying element #2
[16:04:41.776] result() for MulticoreFuture ...
[16:04:41.776] result() for MulticoreFuture ... done
[16:04:41.776] result() for MulticoreFuture ...
[16:04:41.776] result() for MulticoreFuture ... done
[16:04:41.776] result() for MulticoreFuture ...
[16:04:41.777] result() for MulticoreFuture ... done
[16:04:41.777] result() for MulticoreFuture ...
[16:04:41.777] result() for MulticoreFuture ... done
[16:04:41.777] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.777] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.777] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:41.777]  length: 4 (resolved future 2)
[16:04:41.778] Future #3
[16:04:41.778] result() for MulticoreFuture ...
[16:04:41.778] result() for MulticoreFuture ...
[16:04:41.779] result() for MulticoreFuture ... done
[16:04:41.779] result() for MulticoreFuture ... done
[16:04:41.779] result() for MulticoreFuture ...
[16:04:41.779] result() for MulticoreFuture ... done
[16:04:41.779] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:41.780] - nx: 6
[16:04:41.780] - relay: TRUE
[16:04:41.780] - stdout: TRUE
[16:04:41.780] - signal: TRUE
[16:04:41.780] - resignal: FALSE
[16:04:41.780] - force: TRUE
[16:04:41.781] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.781] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.781]  - until=3
[16:04:41.781]  - relaying element #3
[16:04:41.781] result() for MulticoreFuture ...
[16:04:41.781] result() for MulticoreFuture ... done
[16:04:41.781] result() for MulticoreFuture ...
[16:04:41.782] result() for MulticoreFuture ... done
[16:04:41.782] result() for MulticoreFuture ...
[16:04:41.782] result() for MulticoreFuture ... done
[16:04:41.782] result() for MulticoreFuture ...
[16:04:41.782] result() for MulticoreFuture ... done
[16:04:41.782] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.782] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.782] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:41.783]  length: 3 (resolved future 3)
[16:04:41.783] signalConditionsASAP(NULL, pos=4) ...
[16:04:41.783] - nx: 6
[16:04:41.783] - relay: TRUE
[16:04:41.783] - stdout: TRUE
[16:04:41.783] - signal: TRUE
[16:04:41.783] - resignal: FALSE
[16:04:41.783] - force: TRUE
[16:04:41.783] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.783] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.784]  - until=5
[16:04:41.784]  - relaying element #5
[16:04:41.784] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.784] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.784] signalConditionsASAP(NULL, pos=4) ... done
[16:04:41.784]  length: 2 (resolved future 4)
[16:04:41.784] signalConditionsASAP(NULL, pos=5) ...
[16:04:41.784] - nx: 6
[16:04:41.784] - relay: TRUE
[16:04:41.785] - stdout: TRUE
[16:04:41.785] - signal: TRUE
[16:04:41.785] - resignal: FALSE
[16:04:41.785] - force: TRUE
[16:04:41.785] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.785] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.785]  - until=6
[16:04:41.785]  - relaying element #6
[16:04:41.785] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.785] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.786] signalConditionsASAP(NULL, pos=5) ... done
[16:04:41.786]  length: 1 (resolved future 5)
[16:04:41.786] signalConditionsASAP(numeric, pos=6) ...
[16:04:41.786] - nx: 6
[16:04:41.786] - relay: TRUE
[16:04:41.786] - stdout: TRUE
[16:04:41.786] - signal: TRUE
[16:04:41.786] - resignal: FALSE
[16:04:41.786] - force: TRUE
[16:04:41.786] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.787] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.789]  - until=6
[16:04:41.789] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.789] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.789] signalConditionsASAP(numeric, pos=6) ... done
[16:04:41.789]  length: 0 (resolved future 6)
[16:04:41.790] Relaying remaining futures
[16:04:41.790] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.790] - nx: 6
[16:04:41.790] - relay: TRUE
[16:04:41.790] - stdout: TRUE
[16:04:41.790] - signal: TRUE
[16:04:41.790] - resignal: FALSE
[16:04:41.790] - force: TRUE
[16:04:41.791] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.791] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:41.791] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.791] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.791] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.791] resolve() on list ... DONE
[16:04:41.791] result() for MulticoreFuture ...
[16:04:41.791] result() for MulticoreFuture ... done
[16:04:41.792] result() for MulticoreFuture ...
[16:04:41.792] result() for MulticoreFuture ... done
[16:04:41.792] result() for MulticoreFuture ...
[16:04:41.792] result() for MulticoreFuture ... done
[16:04:41.792] result() for MulticoreFuture ...
[16:04:41.792] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:04:41.796] getGlobalsAndPackages() ...
[16:04:41.796] Searching for globals...
[16:04:41.796] 
[16:04:41.796] Searching for globals ... DONE
[16:04:41.797] - globals: [0] <none>
[16:04:41.797] getGlobalsAndPackages() ... DONE
[16:04:41.797] run() for ‘Future’ ...
[16:04:41.797] - state: ‘created’
[16:04:41.797] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:41.801] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:41.801] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:41.802]   - Field: ‘label’
[16:04:41.802]   - Field: ‘local’
[16:04:41.802]   - Field: ‘owner’
[16:04:41.802]   - Field: ‘envir’
[16:04:41.802]   - Field: ‘workers’
[16:04:41.802]   - Field: ‘packages’
[16:04:41.802]   - Field: ‘gc’
[16:04:41.802]   - Field: ‘job’
[16:04:41.802]   - Field: ‘conditions’
[16:04:41.802]   - Field: ‘expr’
[16:04:41.802]   - Field: ‘uuid’
[16:04:41.803]   - Field: ‘seed’
[16:04:41.803]   - Field: ‘version’
[16:04:41.803]   - Field: ‘result’
[16:04:41.803]   - Field: ‘asynchronous’
[16:04:41.803]   - Field: ‘calls’
[16:04:41.803]   - Field: ‘globals’
[16:04:41.803]   - Field: ‘stdout’
[16:04:41.803]   - Field: ‘earlySignal’
[16:04:41.803]   - Field: ‘lazy’
[16:04:41.803]   - Field: ‘state’
[16:04:41.804] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:41.804] - Launch lazy future ...
[16:04:41.804] Packages needed by the future expression (n = 0): <none>
[16:04:41.804] Packages needed by future strategies (n = 0): <none>
[16:04:41.804] {
[16:04:41.804]     {
[16:04:41.804]         {
[16:04:41.804]             ...future.startTime <- base::Sys.time()
[16:04:41.804]             {
[16:04:41.804]                 {
[16:04:41.804]                   {
[16:04:41.804]                     {
[16:04:41.804]                       base::local({
[16:04:41.804]                         has_future <- base::requireNamespace("future", 
[16:04:41.804]                           quietly = TRUE)
[16:04:41.804]                         if (has_future) {
[16:04:41.804]                           ns <- base::getNamespace("future")
[16:04:41.804]                           version <- ns[[".package"]][["version"]]
[16:04:41.804]                           if (is.null(version)) 
[16:04:41.804]                             version <- utils::packageVersion("future")
[16:04:41.804]                         }
[16:04:41.804]                         else {
[16:04:41.804]                           version <- NULL
[16:04:41.804]                         }
[16:04:41.804]                         if (!has_future || version < "1.8.0") {
[16:04:41.804]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.804]                             "", base::R.version$version.string), 
[16:04:41.804]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:41.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.804]                               "release", "version")], collapse = " "), 
[16:04:41.804]                             hostname = base::Sys.info()[["nodename"]])
[16:04:41.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.804]                             info)
[16:04:41.804]                           info <- base::paste(info, collapse = "; ")
[16:04:41.804]                           if (!has_future) {
[16:04:41.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.804]                               info)
[16:04:41.804]                           }
[16:04:41.804]                           else {
[16:04:41.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.804]                               info, version)
[16:04:41.804]                           }
[16:04:41.804]                           base::stop(msg)
[16:04:41.804]                         }
[16:04:41.804]                       })
[16:04:41.804]                     }
[16:04:41.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:41.804]                     base::options(mc.cores = 1L)
[16:04:41.804]                   }
[16:04:41.804]                   options(future.plan = NULL)
[16:04:41.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.804]                 }
[16:04:41.804]                 ...future.workdir <- getwd()
[16:04:41.804]             }
[16:04:41.804]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.804]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.804]         }
[16:04:41.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.804]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.804]             base::names(...future.oldOptions))
[16:04:41.804]     }
[16:04:41.804]     if (FALSE) {
[16:04:41.804]     }
[16:04:41.804]     else {
[16:04:41.804]         if (TRUE) {
[16:04:41.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.804]                 open = "w")
[16:04:41.804]         }
[16:04:41.804]         else {
[16:04:41.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.804]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.804]         }
[16:04:41.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.804]             base::sink(type = "output", split = FALSE)
[16:04:41.804]             base::close(...future.stdout)
[16:04:41.804]         }, add = TRUE)
[16:04:41.804]     }
[16:04:41.804]     ...future.frame <- base::sys.nframe()
[16:04:41.804]     ...future.conditions <- base::list()
[16:04:41.804]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.804]     if (FALSE) {
[16:04:41.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.804]     }
[16:04:41.804]     ...future.result <- base::tryCatch({
[16:04:41.804]         base::withCallingHandlers({
[16:04:41.804]             ...future.value <- base::withVisible(base::local({
[16:04:41.804]                 withCallingHandlers({
[16:04:41.804]                   2
[16:04:41.804]                 }, immediateCondition = function(cond) {
[16:04:41.804]                   save_rds <- function (object, pathname, ...) 
[16:04:41.804]                   {
[16:04:41.804]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:41.804]                     if (file_test("-f", pathname_tmp)) {
[16:04:41.804]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.804]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:41.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.804]                         fi_tmp[["mtime"]])
[16:04:41.804]                     }
[16:04:41.804]                     tryCatch({
[16:04:41.804]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:41.804]                     }, error = function(ex) {
[16:04:41.804]                       msg <- conditionMessage(ex)
[16:04:41.804]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.804]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:41.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.804]                         fi_tmp[["mtime"]], msg)
[16:04:41.804]                       ex$message <- msg
[16:04:41.804]                       stop(ex)
[16:04:41.804]                     })
[16:04:41.804]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:41.804]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:41.804]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:41.804]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.804]                       fi <- file.info(pathname)
[16:04:41.804]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:41.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.804]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:41.804]                         fi[["size"]], fi[["mtime"]])
[16:04:41.804]                       stop(msg)
[16:04:41.804]                     }
[16:04:41.804]                     invisible(pathname)
[16:04:41.804]                   }
[16:04:41.804]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:41.804]                     rootPath = tempdir()) 
[16:04:41.804]                   {
[16:04:41.804]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:41.804]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:41.804]                       tmpdir = path, fileext = ".rds")
[16:04:41.804]                     save_rds(obj, file)
[16:04:41.804]                   }
[16:04:41.804]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:41.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.804]                   {
[16:04:41.804]                     inherits <- base::inherits
[16:04:41.804]                     invokeRestart <- base::invokeRestart
[16:04:41.804]                     is.null <- base::is.null
[16:04:41.804]                     muffled <- FALSE
[16:04:41.804]                     if (inherits(cond, "message")) {
[16:04:41.804]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:41.804]                       if (muffled) 
[16:04:41.804]                         invokeRestart("muffleMessage")
[16:04:41.804]                     }
[16:04:41.804]                     else if (inherits(cond, "warning")) {
[16:04:41.804]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:41.804]                       if (muffled) 
[16:04:41.804]                         invokeRestart("muffleWarning")
[16:04:41.804]                     }
[16:04:41.804]                     else if (inherits(cond, "condition")) {
[16:04:41.804]                       if (!is.null(pattern)) {
[16:04:41.804]                         computeRestarts <- base::computeRestarts
[16:04:41.804]                         grepl <- base::grepl
[16:04:41.804]                         restarts <- computeRestarts(cond)
[16:04:41.804]                         for (restart in restarts) {
[16:04:41.804]                           name <- restart$name
[16:04:41.804]                           if (is.null(name)) 
[16:04:41.804]                             next
[16:04:41.804]                           if (!grepl(pattern, name)) 
[16:04:41.804]                             next
[16:04:41.804]                           invokeRestart(restart)
[16:04:41.804]                           muffled <- TRUE
[16:04:41.804]                           break
[16:04:41.804]                         }
[16:04:41.804]                       }
[16:04:41.804]                     }
[16:04:41.804]                     invisible(muffled)
[16:04:41.804]                   }
[16:04:41.804]                   muffleCondition(cond)
[16:04:41.804]                 })
[16:04:41.804]             }))
[16:04:41.804]             future::FutureResult(value = ...future.value$value, 
[16:04:41.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.804]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.804]                     ...future.globalenv.names))
[16:04:41.804]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.804]         }, condition = base::local({
[16:04:41.804]             c <- base::c
[16:04:41.804]             inherits <- base::inherits
[16:04:41.804]             invokeRestart <- base::invokeRestart
[16:04:41.804]             length <- base::length
[16:04:41.804]             list <- base::list
[16:04:41.804]             seq.int <- base::seq.int
[16:04:41.804]             signalCondition <- base::signalCondition
[16:04:41.804]             sys.calls <- base::sys.calls
[16:04:41.804]             `[[` <- base::`[[`
[16:04:41.804]             `+` <- base::`+`
[16:04:41.804]             `<<-` <- base::`<<-`
[16:04:41.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.804]                   3L)]
[16:04:41.804]             }
[16:04:41.804]             function(cond) {
[16:04:41.804]                 is_error <- inherits(cond, "error")
[16:04:41.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.804]                   NULL)
[16:04:41.804]                 if (is_error) {
[16:04:41.804]                   sessionInformation <- function() {
[16:04:41.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.804]                       search = base::search(), system = base::Sys.info())
[16:04:41.804]                   }
[16:04:41.804]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.804]                     cond$call), session = sessionInformation(), 
[16:04:41.804]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.804]                   signalCondition(cond)
[16:04:41.804]                 }
[16:04:41.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.804]                 "immediateCondition"))) {
[16:04:41.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.804]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.804]                   if (TRUE && !signal) {
[16:04:41.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.804]                     {
[16:04:41.804]                       inherits <- base::inherits
[16:04:41.804]                       invokeRestart <- base::invokeRestart
[16:04:41.804]                       is.null <- base::is.null
[16:04:41.804]                       muffled <- FALSE
[16:04:41.804]                       if (inherits(cond, "message")) {
[16:04:41.804]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.804]                         if (muffled) 
[16:04:41.804]                           invokeRestart("muffleMessage")
[16:04:41.804]                       }
[16:04:41.804]                       else if (inherits(cond, "warning")) {
[16:04:41.804]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.804]                         if (muffled) 
[16:04:41.804]                           invokeRestart("muffleWarning")
[16:04:41.804]                       }
[16:04:41.804]                       else if (inherits(cond, "condition")) {
[16:04:41.804]                         if (!is.null(pattern)) {
[16:04:41.804]                           computeRestarts <- base::computeRestarts
[16:04:41.804]                           grepl <- base::grepl
[16:04:41.804]                           restarts <- computeRestarts(cond)
[16:04:41.804]                           for (restart in restarts) {
[16:04:41.804]                             name <- restart$name
[16:04:41.804]                             if (is.null(name)) 
[16:04:41.804]                               next
[16:04:41.804]                             if (!grepl(pattern, name)) 
[16:04:41.804]                               next
[16:04:41.804]                             invokeRestart(restart)
[16:04:41.804]                             muffled <- TRUE
[16:04:41.804]                             break
[16:04:41.804]                           }
[16:04:41.804]                         }
[16:04:41.804]                       }
[16:04:41.804]                       invisible(muffled)
[16:04:41.804]                     }
[16:04:41.804]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.804]                   }
[16:04:41.804]                 }
[16:04:41.804]                 else {
[16:04:41.804]                   if (TRUE) {
[16:04:41.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.804]                     {
[16:04:41.804]                       inherits <- base::inherits
[16:04:41.804]                       invokeRestart <- base::invokeRestart
[16:04:41.804]                       is.null <- base::is.null
[16:04:41.804]                       muffled <- FALSE
[16:04:41.804]                       if (inherits(cond, "message")) {
[16:04:41.804]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.804]                         if (muffled) 
[16:04:41.804]                           invokeRestart("muffleMessage")
[16:04:41.804]                       }
[16:04:41.804]                       else if (inherits(cond, "warning")) {
[16:04:41.804]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.804]                         if (muffled) 
[16:04:41.804]                           invokeRestart("muffleWarning")
[16:04:41.804]                       }
[16:04:41.804]                       else if (inherits(cond, "condition")) {
[16:04:41.804]                         if (!is.null(pattern)) {
[16:04:41.804]                           computeRestarts <- base::computeRestarts
[16:04:41.804]                           grepl <- base::grepl
[16:04:41.804]                           restarts <- computeRestarts(cond)
[16:04:41.804]                           for (restart in restarts) {
[16:04:41.804]                             name <- restart$name
[16:04:41.804]                             if (is.null(name)) 
[16:04:41.804]                               next
[16:04:41.804]                             if (!grepl(pattern, name)) 
[16:04:41.804]                               next
[16:04:41.804]                             invokeRestart(restart)
[16:04:41.804]                             muffled <- TRUE
[16:04:41.804]                             break
[16:04:41.804]                           }
[16:04:41.804]                         }
[16:04:41.804]                       }
[16:04:41.804]                       invisible(muffled)
[16:04:41.804]                     }
[16:04:41.804]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.804]                   }
[16:04:41.804]                 }
[16:04:41.804]             }
[16:04:41.804]         }))
[16:04:41.804]     }, error = function(ex) {
[16:04:41.804]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.804]                 ...future.rng), started = ...future.startTime, 
[16:04:41.804]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.804]             version = "1.8"), class = "FutureResult")
[16:04:41.804]     }, finally = {
[16:04:41.804]         if (!identical(...future.workdir, getwd())) 
[16:04:41.804]             setwd(...future.workdir)
[16:04:41.804]         {
[16:04:41.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.804]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.804]             }
[16:04:41.804]             base::options(...future.oldOptions)
[16:04:41.804]             if (.Platform$OS.type == "windows") {
[16:04:41.804]                 old_names <- names(...future.oldEnvVars)
[16:04:41.804]                 envs <- base::Sys.getenv()
[16:04:41.804]                 names <- names(envs)
[16:04:41.804]                 common <- intersect(names, old_names)
[16:04:41.804]                 added <- setdiff(names, old_names)
[16:04:41.804]                 removed <- setdiff(old_names, names)
[16:04:41.804]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.804]                   envs[common]]
[16:04:41.804]                 NAMES <- toupper(changed)
[16:04:41.804]                 args <- list()
[16:04:41.804]                 for (kk in seq_along(NAMES)) {
[16:04:41.804]                   name <- changed[[kk]]
[16:04:41.804]                   NAME <- NAMES[[kk]]
[16:04:41.804]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.804]                     next
[16:04:41.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.804]                 }
[16:04:41.804]                 NAMES <- toupper(added)
[16:04:41.804]                 for (kk in seq_along(NAMES)) {
[16:04:41.804]                   name <- added[[kk]]
[16:04:41.804]                   NAME <- NAMES[[kk]]
[16:04:41.804]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.804]                     next
[16:04:41.804]                   args[[name]] <- ""
[16:04:41.804]                 }
[16:04:41.804]                 NAMES <- toupper(removed)
[16:04:41.804]                 for (kk in seq_along(NAMES)) {
[16:04:41.804]                   name <- removed[[kk]]
[16:04:41.804]                   NAME <- NAMES[[kk]]
[16:04:41.804]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.804]                     next
[16:04:41.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.804]                 }
[16:04:41.804]                 if (length(args) > 0) 
[16:04:41.804]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.804]             }
[16:04:41.804]             else {
[16:04:41.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.804]             }
[16:04:41.804]             {
[16:04:41.804]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.804]                   0L) {
[16:04:41.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.804]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.804]                   base::options(opts)
[16:04:41.804]                 }
[16:04:41.804]                 {
[16:04:41.804]                   {
[16:04:41.804]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:41.804]                     NULL
[16:04:41.804]                   }
[16:04:41.804]                   options(future.plan = NULL)
[16:04:41.804]                   if (is.na(NA_character_)) 
[16:04:41.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.804]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:41.804]                     envir = parent.frame()) 
[16:04:41.804]                   {
[16:04:41.804]                     default_workers <- missing(workers)
[16:04:41.804]                     if (is.function(workers)) 
[16:04:41.804]                       workers <- workers()
[16:04:41.804]                     workers <- structure(as.integer(workers), 
[16:04:41.804]                       class = class(workers))
[16:04:41.804]                     stop_if_not(is.finite(workers), workers >= 
[16:04:41.804]                       1L)
[16:04:41.804]                     if ((workers == 1L && !inherits(workers, 
[16:04:41.804]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:41.804]                       if (default_workers) 
[16:04:41.804]                         supportsMulticore(warn = TRUE)
[16:04:41.804]                       return(sequential(..., envir = envir))
[16:04:41.804]                     }
[16:04:41.804]                     oopts <- options(mc.cores = workers)
[16:04:41.804]                     on.exit(options(oopts))
[16:04:41.804]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:41.804]                       envir = envir)
[16:04:41.804]                     if (!future$lazy) 
[16:04:41.804]                       future <- run(future)
[16:04:41.804]                     invisible(future)
[16:04:41.804]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.804]                 }
[16:04:41.804]             }
[16:04:41.804]         }
[16:04:41.804]     })
[16:04:41.804]     if (TRUE) {
[16:04:41.804]         base::sink(type = "output", split = FALSE)
[16:04:41.804]         if (TRUE) {
[16:04:41.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.804]         }
[16:04:41.804]         else {
[16:04:41.804]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.804]         }
[16:04:41.804]         base::close(...future.stdout)
[16:04:41.804]         ...future.stdout <- NULL
[16:04:41.804]     }
[16:04:41.804]     ...future.result$conditions <- ...future.conditions
[16:04:41.804]     ...future.result$finished <- base::Sys.time()
[16:04:41.804]     ...future.result
[16:04:41.804] }
[16:04:41.807] requestCore(): workers = 2
[16:04:41.809] MulticoreFuture started
[16:04:41.809] - Launch lazy future ... done
[16:04:41.809] run() for ‘MulticoreFuture’ ... done
[16:04:41.810] getGlobalsAndPackages() ...
[16:04:41.810] Searching for globals...
[16:04:41.810] plan(): Setting new future strategy stack:
[16:04:41.810] List of future strategies:
[16:04:41.810] 1. sequential:
[16:04:41.810]    - args: function (..., envir = parent.frame())
[16:04:41.810]    - tweaked: FALSE
[16:04:41.810]    - call: NULL
[16:04:41.811] 
[16:04:41.811] Searching for globals ... DONE
[16:04:41.811] plan(): nbrOfWorkers() = 1
[16:04:41.811] - globals: [0] <none>
[16:04:41.811] getGlobalsAndPackages() ... DONE
[16:04:41.812] run() for ‘Future’ ...
[16:04:41.812] - state: ‘created’
[16:04:41.812] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:41.813] plan(): Setting new future strategy stack:
[16:04:41.813] List of future strategies:
[16:04:41.813] 1. multicore:
[16:04:41.813]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:41.813]    - tweaked: FALSE
[16:04:41.813]    - call: plan(strategy)
[16:04:41.817] plan(): nbrOfWorkers() = 2
[16:04:41.817] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:41.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:41.817]   - Field: ‘label’
[16:04:41.818]   - Field: ‘local’
[16:04:41.818]   - Field: ‘owner’
[16:04:41.818]   - Field: ‘envir’
[16:04:41.818]   - Field: ‘workers’
[16:04:41.818]   - Field: ‘packages’
[16:04:41.818]   - Field: ‘gc’
[16:04:41.819]   - Field: ‘job’
[16:04:41.819]   - Field: ‘conditions’
[16:04:41.819]   - Field: ‘expr’
[16:04:41.819]   - Field: ‘uuid’
[16:04:41.819]   - Field: ‘seed’
[16:04:41.819]   - Field: ‘version’
[16:04:41.819]   - Field: ‘result’
[16:04:41.820]   - Field: ‘asynchronous’
[16:04:41.820]   - Field: ‘calls’
[16:04:41.820]   - Field: ‘globals’
[16:04:41.820]   - Field: ‘stdout’
[16:04:41.820]   - Field: ‘earlySignal’
[16:04:41.820]   - Field: ‘lazy’
[16:04:41.821]   - Field: ‘state’
[16:04:41.821] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:41.821] - Launch lazy future ...
[16:04:41.821] Packages needed by the future expression (n = 0): <none>
[16:04:41.822] Packages needed by future strategies (n = 0): <none>
[16:04:41.822] {
[16:04:41.822]     {
[16:04:41.822]         {
[16:04:41.822]             ...future.startTime <- base::Sys.time()
[16:04:41.822]             {
[16:04:41.822]                 {
[16:04:41.822]                   {
[16:04:41.822]                     {
[16:04:41.822]                       base::local({
[16:04:41.822]                         has_future <- base::requireNamespace("future", 
[16:04:41.822]                           quietly = TRUE)
[16:04:41.822]                         if (has_future) {
[16:04:41.822]                           ns <- base::getNamespace("future")
[16:04:41.822]                           version <- ns[[".package"]][["version"]]
[16:04:41.822]                           if (is.null(version)) 
[16:04:41.822]                             version <- utils::packageVersion("future")
[16:04:41.822]                         }
[16:04:41.822]                         else {
[16:04:41.822]                           version <- NULL
[16:04:41.822]                         }
[16:04:41.822]                         if (!has_future || version < "1.8.0") {
[16:04:41.822]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:41.822]                             "", base::R.version$version.string), 
[16:04:41.822]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:41.822]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:41.822]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:41.822]                               "release", "version")], collapse = " "), 
[16:04:41.822]                             hostname = base::Sys.info()[["nodename"]])
[16:04:41.822]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:41.822]                             info)
[16:04:41.822]                           info <- base::paste(info, collapse = "; ")
[16:04:41.822]                           if (!has_future) {
[16:04:41.822]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:41.822]                               info)
[16:04:41.822]                           }
[16:04:41.822]                           else {
[16:04:41.822]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:41.822]                               info, version)
[16:04:41.822]                           }
[16:04:41.822]                           base::stop(msg)
[16:04:41.822]                         }
[16:04:41.822]                       })
[16:04:41.822]                     }
[16:04:41.822]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:41.822]                     base::options(mc.cores = 1L)
[16:04:41.822]                   }
[16:04:41.822]                   options(future.plan = NULL)
[16:04:41.822]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.822]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:41.822]                 }
[16:04:41.822]                 ...future.workdir <- getwd()
[16:04:41.822]             }
[16:04:41.822]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:41.822]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:41.822]         }
[16:04:41.822]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:41.822]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:41.822]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:41.822]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:41.822]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:41.822]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:41.822]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:41.822]             base::names(...future.oldOptions))
[16:04:41.822]     }
[16:04:41.822]     if (FALSE) {
[16:04:41.822]     }
[16:04:41.822]     else {
[16:04:41.822]         if (TRUE) {
[16:04:41.822]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:41.822]                 open = "w")
[16:04:41.822]         }
[16:04:41.822]         else {
[16:04:41.822]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:41.822]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:41.822]         }
[16:04:41.822]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:41.822]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:41.822]             base::sink(type = "output", split = FALSE)
[16:04:41.822]             base::close(...future.stdout)
[16:04:41.822]         }, add = TRUE)
[16:04:41.822]     }
[16:04:41.822]     ...future.frame <- base::sys.nframe()
[16:04:41.822]     ...future.conditions <- base::list()
[16:04:41.822]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:41.822]     if (FALSE) {
[16:04:41.822]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:41.822]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:41.822]     }
[16:04:41.822]     ...future.result <- base::tryCatch({
[16:04:41.822]         base::withCallingHandlers({
[16:04:41.822]             ...future.value <- base::withVisible(base::local({
[16:04:41.822]                 withCallingHandlers({
[16:04:41.822]                   NULL
[16:04:41.822]                 }, immediateCondition = function(cond) {
[16:04:41.822]                   save_rds <- function (object, pathname, ...) 
[16:04:41.822]                   {
[16:04:41.822]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:41.822]                     if (file_test("-f", pathname_tmp)) {
[16:04:41.822]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.822]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:41.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.822]                         fi_tmp[["mtime"]])
[16:04:41.822]                     }
[16:04:41.822]                     tryCatch({
[16:04:41.822]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:41.822]                     }, error = function(ex) {
[16:04:41.822]                       msg <- conditionMessage(ex)
[16:04:41.822]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.822]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:41.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.822]                         fi_tmp[["mtime"]], msg)
[16:04:41.822]                       ex$message <- msg
[16:04:41.822]                       stop(ex)
[16:04:41.822]                     })
[16:04:41.822]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:41.822]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:41.822]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:41.822]                       fi_tmp <- file.info(pathname_tmp)
[16:04:41.822]                       fi <- file.info(pathname)
[16:04:41.822]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:41.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:41.822]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:41.822]                         fi[["size"]], fi[["mtime"]])
[16:04:41.822]                       stop(msg)
[16:04:41.822]                     }
[16:04:41.822]                     invisible(pathname)
[16:04:41.822]                   }
[16:04:41.822]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:41.822]                     rootPath = tempdir()) 
[16:04:41.822]                   {
[16:04:41.822]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:41.822]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:41.822]                       tmpdir = path, fileext = ".rds")
[16:04:41.822]                     save_rds(obj, file)
[16:04:41.822]                   }
[16:04:41.822]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:41.822]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.822]                   {
[16:04:41.822]                     inherits <- base::inherits
[16:04:41.822]                     invokeRestart <- base::invokeRestart
[16:04:41.822]                     is.null <- base::is.null
[16:04:41.822]                     muffled <- FALSE
[16:04:41.822]                     if (inherits(cond, "message")) {
[16:04:41.822]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:41.822]                       if (muffled) 
[16:04:41.822]                         invokeRestart("muffleMessage")
[16:04:41.822]                     }
[16:04:41.822]                     else if (inherits(cond, "warning")) {
[16:04:41.822]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:41.822]                       if (muffled) 
[16:04:41.822]                         invokeRestart("muffleWarning")
[16:04:41.822]                     }
[16:04:41.822]                     else if (inherits(cond, "condition")) {
[16:04:41.822]                       if (!is.null(pattern)) {
[16:04:41.822]                         computeRestarts <- base::computeRestarts
[16:04:41.822]                         grepl <- base::grepl
[16:04:41.822]                         restarts <- computeRestarts(cond)
[16:04:41.822]                         for (restart in restarts) {
[16:04:41.822]                           name <- restart$name
[16:04:41.822]                           if (is.null(name)) 
[16:04:41.822]                             next
[16:04:41.822]                           if (!grepl(pattern, name)) 
[16:04:41.822]                             next
[16:04:41.822]                           invokeRestart(restart)
[16:04:41.822]                           muffled <- TRUE
[16:04:41.822]                           break
[16:04:41.822]                         }
[16:04:41.822]                       }
[16:04:41.822]                     }
[16:04:41.822]                     invisible(muffled)
[16:04:41.822]                   }
[16:04:41.822]                   muffleCondition(cond)
[16:04:41.822]                 })
[16:04:41.822]             }))
[16:04:41.822]             future::FutureResult(value = ...future.value$value, 
[16:04:41.822]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.822]                   ...future.rng), globalenv = if (FALSE) 
[16:04:41.822]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:41.822]                     ...future.globalenv.names))
[16:04:41.822]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:41.822]         }, condition = base::local({
[16:04:41.822]             c <- base::c
[16:04:41.822]             inherits <- base::inherits
[16:04:41.822]             invokeRestart <- base::invokeRestart
[16:04:41.822]             length <- base::length
[16:04:41.822]             list <- base::list
[16:04:41.822]             seq.int <- base::seq.int
[16:04:41.822]             signalCondition <- base::signalCondition
[16:04:41.822]             sys.calls <- base::sys.calls
[16:04:41.822]             `[[` <- base::`[[`
[16:04:41.822]             `+` <- base::`+`
[16:04:41.822]             `<<-` <- base::`<<-`
[16:04:41.822]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:41.822]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:41.822]                   3L)]
[16:04:41.822]             }
[16:04:41.822]             function(cond) {
[16:04:41.822]                 is_error <- inherits(cond, "error")
[16:04:41.822]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:41.822]                   NULL)
[16:04:41.822]                 if (is_error) {
[16:04:41.822]                   sessionInformation <- function() {
[16:04:41.822]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:41.822]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:41.822]                       search = base::search(), system = base::Sys.info())
[16:04:41.822]                   }
[16:04:41.822]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.822]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:41.822]                     cond$call), session = sessionInformation(), 
[16:04:41.822]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:41.822]                   signalCondition(cond)
[16:04:41.822]                 }
[16:04:41.822]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:41.822]                 "immediateCondition"))) {
[16:04:41.822]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:41.822]                   ...future.conditions[[length(...future.conditions) + 
[16:04:41.822]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:41.822]                   if (TRUE && !signal) {
[16:04:41.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.822]                     {
[16:04:41.822]                       inherits <- base::inherits
[16:04:41.822]                       invokeRestart <- base::invokeRestart
[16:04:41.822]                       is.null <- base::is.null
[16:04:41.822]                       muffled <- FALSE
[16:04:41.822]                       if (inherits(cond, "message")) {
[16:04:41.822]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.822]                         if (muffled) 
[16:04:41.822]                           invokeRestart("muffleMessage")
[16:04:41.822]                       }
[16:04:41.822]                       else if (inherits(cond, "warning")) {
[16:04:41.822]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.822]                         if (muffled) 
[16:04:41.822]                           invokeRestart("muffleWarning")
[16:04:41.822]                       }
[16:04:41.822]                       else if (inherits(cond, "condition")) {
[16:04:41.822]                         if (!is.null(pattern)) {
[16:04:41.822]                           computeRestarts <- base::computeRestarts
[16:04:41.822]                           grepl <- base::grepl
[16:04:41.822]                           restarts <- computeRestarts(cond)
[16:04:41.822]                           for (restart in restarts) {
[16:04:41.822]                             name <- restart$name
[16:04:41.822]                             if (is.null(name)) 
[16:04:41.822]                               next
[16:04:41.822]                             if (!grepl(pattern, name)) 
[16:04:41.822]                               next
[16:04:41.822]                             invokeRestart(restart)
[16:04:41.822]                             muffled <- TRUE
[16:04:41.822]                             break
[16:04:41.822]                           }
[16:04:41.822]                         }
[16:04:41.822]                       }
[16:04:41.822]                       invisible(muffled)
[16:04:41.822]                     }
[16:04:41.822]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.822]                   }
[16:04:41.822]                 }
[16:04:41.822]                 else {
[16:04:41.822]                   if (TRUE) {
[16:04:41.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:41.822]                     {
[16:04:41.822]                       inherits <- base::inherits
[16:04:41.822]                       invokeRestart <- base::invokeRestart
[16:04:41.822]                       is.null <- base::is.null
[16:04:41.822]                       muffled <- FALSE
[16:04:41.822]                       if (inherits(cond, "message")) {
[16:04:41.822]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:41.822]                         if (muffled) 
[16:04:41.822]                           invokeRestart("muffleMessage")
[16:04:41.822]                       }
[16:04:41.822]                       else if (inherits(cond, "warning")) {
[16:04:41.822]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:41.822]                         if (muffled) 
[16:04:41.822]                           invokeRestart("muffleWarning")
[16:04:41.822]                       }
[16:04:41.822]                       else if (inherits(cond, "condition")) {
[16:04:41.822]                         if (!is.null(pattern)) {
[16:04:41.822]                           computeRestarts <- base::computeRestarts
[16:04:41.822]                           grepl <- base::grepl
[16:04:41.822]                           restarts <- computeRestarts(cond)
[16:04:41.822]                           for (restart in restarts) {
[16:04:41.822]                             name <- restart$name
[16:04:41.822]                             if (is.null(name)) 
[16:04:41.822]                               next
[16:04:41.822]                             if (!grepl(pattern, name)) 
[16:04:41.822]                               next
[16:04:41.822]                             invokeRestart(restart)
[16:04:41.822]                             muffled <- TRUE
[16:04:41.822]                             break
[16:04:41.822]                           }
[16:04:41.822]                         }
[16:04:41.822]                       }
[16:04:41.822]                       invisible(muffled)
[16:04:41.822]                     }
[16:04:41.822]                     muffleCondition(cond, pattern = "^muffle")
[16:04:41.822]                   }
[16:04:41.822]                 }
[16:04:41.822]             }
[16:04:41.822]         }))
[16:04:41.822]     }, error = function(ex) {
[16:04:41.822]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:41.822]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:41.822]                 ...future.rng), started = ...future.startTime, 
[16:04:41.822]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:41.822]             version = "1.8"), class = "FutureResult")
[16:04:41.822]     }, finally = {
[16:04:41.822]         if (!identical(...future.workdir, getwd())) 
[16:04:41.822]             setwd(...future.workdir)
[16:04:41.822]         {
[16:04:41.822]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:41.822]                 ...future.oldOptions$nwarnings <- NULL
[16:04:41.822]             }
[16:04:41.822]             base::options(...future.oldOptions)
[16:04:41.822]             if (.Platform$OS.type == "windows") {
[16:04:41.822]                 old_names <- names(...future.oldEnvVars)
[16:04:41.822]                 envs <- base::Sys.getenv()
[16:04:41.822]                 names <- names(envs)
[16:04:41.822]                 common <- intersect(names, old_names)
[16:04:41.822]                 added <- setdiff(names, old_names)
[16:04:41.822]                 removed <- setdiff(old_names, names)
[16:04:41.822]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:41.822]                   envs[common]]
[16:04:41.822]                 NAMES <- toupper(changed)
[16:04:41.822]                 args <- list()
[16:04:41.822]                 for (kk in seq_along(NAMES)) {
[16:04:41.822]                   name <- changed[[kk]]
[16:04:41.822]                   NAME <- NAMES[[kk]]
[16:04:41.822]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.822]                     next
[16:04:41.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.822]                 }
[16:04:41.822]                 NAMES <- toupper(added)
[16:04:41.822]                 for (kk in seq_along(NAMES)) {
[16:04:41.822]                   name <- added[[kk]]
[16:04:41.822]                   NAME <- NAMES[[kk]]
[16:04:41.822]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.822]                     next
[16:04:41.822]                   args[[name]] <- ""
[16:04:41.822]                 }
[16:04:41.822]                 NAMES <- toupper(removed)
[16:04:41.822]                 for (kk in seq_along(NAMES)) {
[16:04:41.822]                   name <- removed[[kk]]
[16:04:41.822]                   NAME <- NAMES[[kk]]
[16:04:41.822]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:41.822]                     next
[16:04:41.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:41.822]                 }
[16:04:41.822]                 if (length(args) > 0) 
[16:04:41.822]                   base::do.call(base::Sys.setenv, args = args)
[16:04:41.822]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:41.822]             }
[16:04:41.822]             else {
[16:04:41.822]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:41.822]             }
[16:04:41.822]             {
[16:04:41.822]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:41.822]                   0L) {
[16:04:41.822]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:41.822]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:41.822]                   base::options(opts)
[16:04:41.822]                 }
[16:04:41.822]                 {
[16:04:41.822]                   {
[16:04:41.822]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:41.822]                     NULL
[16:04:41.822]                   }
[16:04:41.822]                   options(future.plan = NULL)
[16:04:41.822]                   if (is.na(NA_character_)) 
[16:04:41.822]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:41.822]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:41.822]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:41.822]                     envir = parent.frame()) 
[16:04:41.822]                   {
[16:04:41.822]                     default_workers <- missing(workers)
[16:04:41.822]                     if (is.function(workers)) 
[16:04:41.822]                       workers <- workers()
[16:04:41.822]                     workers <- structure(as.integer(workers), 
[16:04:41.822]                       class = class(workers))
[16:04:41.822]                     stop_if_not(is.finite(workers), workers >= 
[16:04:41.822]                       1L)
[16:04:41.822]                     if ((workers == 1L && !inherits(workers, 
[16:04:41.822]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:41.822]                       if (default_workers) 
[16:04:41.822]                         supportsMulticore(warn = TRUE)
[16:04:41.822]                       return(sequential(..., envir = envir))
[16:04:41.822]                     }
[16:04:41.822]                     oopts <- options(mc.cores = workers)
[16:04:41.822]                     on.exit(options(oopts))
[16:04:41.822]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:41.822]                       envir = envir)
[16:04:41.822]                     if (!future$lazy) 
[16:04:41.822]                       future <- run(future)
[16:04:41.822]                     invisible(future)
[16:04:41.822]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:41.822]                 }
[16:04:41.822]             }
[16:04:41.822]         }
[16:04:41.822]     })
[16:04:41.822]     if (TRUE) {
[16:04:41.822]         base::sink(type = "output", split = FALSE)
[16:04:41.822]         if (TRUE) {
[16:04:41.822]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:41.822]         }
[16:04:41.822]         else {
[16:04:41.822]             ...future.result["stdout"] <- base::list(NULL)
[16:04:41.822]         }
[16:04:41.822]         base::close(...future.stdout)
[16:04:41.822]         ...future.stdout <- NULL
[16:04:41.822]     }
[16:04:41.822]     ...future.result$conditions <- ...future.conditions
[16:04:41.822]     ...future.result$finished <- base::Sys.time()
[16:04:41.822]     ...future.result
[16:04:41.822] }
[16:04:41.826] requestCore(): workers = 2
[16:04:41.828] MulticoreFuture started
[16:04:41.828] - Launch lazy future ... done
[16:04:41.829] run() for ‘MulticoreFuture’ ... done
List of 6
[16:04:41.829] plan(): Setting new future strategy stack:
 $ a:[16:04:41.829] List of future strategies:
[16:04:41.829] 1. sequential:
[16:04:41.829]    - args: function (..., envir = parent.frame())
[16:04:41.829]    - tweaked: FALSE
[16:04:41.829]    - call: NULL
 num 1
 $ b:[16:04:41.830] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874bb5bc88> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874d9d2f60> 
 $  : NULL
 $  : NULL
 $  :[16:04:41.832] plan(): Setting new future strategy stack:
 num 6
List of 6
 $ [16:04:41.832] List of future strategies:
[16:04:41.832] 1. multicore:
[16:04:41.832]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:41.832]    - tweaked: FALSE
[16:04:41.832]    - call: plan(strategy)
a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874bb5bc88> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874d9d2f60> 
 $  : NULL
 $  : NULL
 $  :[16:04:41.838] plan(): nbrOfWorkers() = 2
 num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:41.849] resolve() on list ...
[16:04:41.850]  recursive: 0
[16:04:41.850]  length: 6
[16:04:41.850]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:41.850] signalConditionsASAP(numeric, pos=1) ...
[16:04:41.850] - nx: 6
[16:04:41.851] - relay: TRUE
[16:04:41.851] - stdout: TRUE
[16:04:41.851] - signal: TRUE
[16:04:41.851] - resignal: FALSE
[16:04:41.851] - force: TRUE
[16:04:41.852] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.852] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.852]  - until=2
[16:04:41.852]  - relaying element #2
[16:04:41.852] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.852] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.852] signalConditionsASAP(NULL, pos=1) ... done
[16:04:41.853]  length: 5 (resolved future 1)
[16:04:41.853] Future #2
[16:04:41.853] result() for MulticoreFuture ...
[16:04:41.854] result() for MulticoreFuture ...
[16:04:41.854] result() for MulticoreFuture ... done
[16:04:41.854] result() for MulticoreFuture ... done
[16:04:41.854] result() for MulticoreFuture ...
[16:04:41.854] result() for MulticoreFuture ... done
[16:04:41.855] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:41.855] - nx: 6
[16:04:41.855] - relay: TRUE
[16:04:41.855] - stdout: TRUE
[16:04:41.855] - signal: TRUE
[16:04:41.855] - resignal: FALSE
[16:04:41.855] - force: TRUE
[16:04:41.855] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.856] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:41.856]  - until=2
[16:04:41.856]  - relaying element #2
[16:04:41.856] result() for MulticoreFuture ...
[16:04:41.856] result() for MulticoreFuture ... done
[16:04:41.856] result() for MulticoreFuture ...
[16:04:41.856] result() for MulticoreFuture ... done
[16:04:41.857] result() for MulticoreFuture ...
[16:04:41.857] result() for MulticoreFuture ... done
[16:04:41.857] result() for MulticoreFuture ...
[16:04:41.857] result() for MulticoreFuture ... done
[16:04:41.857] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.857] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.857] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:41.857]  length: 4 (resolved future 2)
[16:04:41.858] Future #3
[16:04:41.858] result() for MulticoreFuture ...
[16:04:41.859] result() for MulticoreFuture ...
[16:04:41.859] result() for MulticoreFuture ... done
[16:04:41.859] result() for MulticoreFuture ... done
[16:04:41.859] result() for MulticoreFuture ...
[16:04:41.859] result() for MulticoreFuture ... done
[16:04:41.860] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:41.860] - nx: 6
[16:04:41.860] - relay: TRUE
[16:04:41.860] - stdout: TRUE
[16:04:41.860] - signal: TRUE
[16:04:41.860] - resignal: FALSE
[16:04:41.860] - force: TRUE
[16:04:41.861] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.861] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:41.861]  - until=3
[16:04:41.861]  - relaying element #3
[16:04:41.861] result() for MulticoreFuture ...
[16:04:41.861] result() for MulticoreFuture ... done
[16:04:41.861] result() for MulticoreFuture ...
[16:04:41.862] result() for MulticoreFuture ... done
[16:04:41.862] result() for MulticoreFuture ...
[16:04:41.862] result() for MulticoreFuture ... done
[16:04:41.862] result() for MulticoreFuture ...
[16:04:41.862] result() for MulticoreFuture ... done
[16:04:41.862] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.862] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.862] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:41.863]  length: 3 (resolved future 3)
[16:04:41.863] signalConditionsASAP(NULL, pos=4) ...
[16:04:41.863] - nx: 6
[16:04:41.863] - relay: TRUE
[16:04:41.863] - stdout: TRUE
[16:04:41.863] - signal: TRUE
[16:04:41.863] - resignal: FALSE
[16:04:41.863] - force: TRUE
[16:04:41.863] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.863] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.864]  - until=5
[16:04:41.864]  - relaying element #5
[16:04:41.864] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.864] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.864] signalConditionsASAP(NULL, pos=4) ... done
[16:04:41.864]  length: 2 (resolved future 4)
[16:04:41.864] signalConditionsASAP(NULL, pos=5) ...
[16:04:41.864] - nx: 6
[16:04:41.864] - relay: TRUE
[16:04:41.864] - stdout: TRUE
[16:04:41.865] - signal: TRUE
[16:04:41.865] - resignal: FALSE
[16:04:41.865] - force: TRUE
[16:04:41.865] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:41.865] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.865]  - until=6
[16:04:41.865]  - relaying element #6
[16:04:41.865] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.865] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.865] signalConditionsASAP(NULL, pos=5) ... done
[16:04:41.865]  length: 1 (resolved future 5)
[16:04:41.866] signalConditionsASAP(numeric, pos=6) ...
[16:04:41.866] - nx: 6
[16:04:41.866] - relay: TRUE
[16:04:41.866] - stdout: TRUE
[16:04:41.866] - signal: TRUE
[16:04:41.866] - resignal: FALSE
[16:04:41.866] - force: TRUE
[16:04:41.866] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:41.866] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.866]  - until=6
[16:04:41.866] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.867] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.867] signalConditionsASAP(numeric, pos=6) ... done
[16:04:41.867]  length: 0 (resolved future 6)
[16:04:41.867] Relaying remaining futures
[16:04:41.867] signalConditionsASAP(NULL, pos=0) ...
[16:04:41.867] - nx: 6
[16:04:41.867] - relay: TRUE
[16:04:41.867] - stdout: TRUE
[16:04:41.867] - signal: TRUE
[16:04:41.867] - resignal: FALSE
[16:04:41.868] - force: TRUE
[16:04:41.868] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.868] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:41.868] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:41.868] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:41.868] signalConditionsASAP(NULL, pos=0) ... done
[16:04:41.868] resolve() on list ... DONE
[16:04:41.868] result() for MulticoreFuture ...
[16:04:41.868] result() for MulticoreFuture ... done
[16:04:41.868] result() for MulticoreFuture ...
[16:04:41.869] result() for MulticoreFuture ... done
[16:04:41.869] result() for MulticoreFuture ...
[16:04:41.869] result() for MulticoreFuture ... done
[16:04:41.869] result() for MulticoreFuture ...
[16:04:41.869] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[16:04:41.874] plan(): Setting new future strategy stack:
[16:04:41.875] List of future strategies:
[16:04:41.875] 1. multisession:
[16:04:41.875]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:41.875]    - tweaked: FALSE
[16:04:41.875]    - call: plan(strategy)
[16:04:41.875] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:04:41.875] multisession:
[16:04:41.875] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:41.875] - tweaked: FALSE
[16:04:41.875] - call: plan(strategy)
[16:04:41.881] getGlobalsAndPackages() ...
[16:04:41.881] Not searching for globals
[16:04:41.882] - globals: [0] <none>
[16:04:41.882] getGlobalsAndPackages() ... DONE
[16:04:41.882] [local output] makeClusterPSOCK() ...
[16:04:41.922] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:04:41.924] [local output] Base port: 11100
[16:04:41.924] [local output] Getting setup options for 2 cluster nodes ...
[16:04:41.924] [local output]  - Node 1 of 2 ...
[16:04:41.924] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:41.925] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpKP9SHZ/worker.rank=1.parallelly.parent=83263.1453f720a6df6.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpKP9SHZ/worker.rank=1.parallelly.parent=83263.1453f720a6df6.pid")'’
[16:04:42.113] - Possible to infer worker's PID: TRUE
[16:04:42.113] [local output] Rscript port: 11100

[16:04:42.114] [local output]  - Node 2 of 2 ...
[16:04:42.114] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:42.115] [local output] Rscript port: 11100

[16:04:42.115] [local output] Getting setup options for 2 cluster nodes ... done
[16:04:42.115] [local output]  - Parallel setup requested for some PSOCK nodes
[16:04:42.116] [local output] Setting up PSOCK nodes in parallel
[16:04:42.116] List of 36
[16:04:42.116]  $ worker          : chr "localhost"
[16:04:42.116]   ..- attr(*, "localhost")= logi TRUE
[16:04:42.116]  $ master          : chr "localhost"
[16:04:42.116]  $ port            : int 11100
[16:04:42.116]  $ connectTimeout  : num 120
[16:04:42.116]  $ timeout         : num 2592000
[16:04:42.116]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:04:42.116]  $ homogeneous     : logi TRUE
[16:04:42.116]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:04:42.116]  $ rscript_envs    : NULL
[16:04:42.116]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:42.116]  $ rscript_startup : NULL
[16:04:42.116]  $ rscript_sh      : chr "sh"
[16:04:42.116]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:42.116]  $ methods         : logi TRUE
[16:04:42.116]  $ socketOptions   : chr "no-delay"
[16:04:42.116]  $ useXDR          : logi FALSE
[16:04:42.116]  $ outfile         : chr "/dev/null"
[16:04:42.116]  $ renice          : int NA
[16:04:42.116]  $ rshcmd          : NULL
[16:04:42.116]  $ user            : chr(0) 
[16:04:42.116]  $ revtunnel       : logi FALSE
[16:04:42.116]  $ rshlogfile      : NULL
[16:04:42.116]  $ rshopts         : chr(0) 
[16:04:42.116]  $ rank            : int 1
[16:04:42.116]  $ manual          : logi FALSE
[16:04:42.116]  $ dryrun          : logi FALSE
[16:04:42.116]  $ quiet           : logi FALSE
[16:04:42.116]  $ setup_strategy  : chr "parallel"
[16:04:42.116]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:42.116]  $ pidfile         : chr "/tmp/RtmpKP9SHZ/worker.rank=1.parallelly.parent=83263.1453f720a6df6.pid"
[16:04:42.116]  $ rshcmd_label    : NULL
[16:04:42.116]  $ rsh_call        : NULL
[16:04:42.116]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:42.116]  $ localMachine    : logi TRUE
[16:04:42.116]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:04:42.116]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:04:42.116]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:04:42.116]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:04:42.116]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:04:42.116]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:04:42.116]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:04:42.116]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:04:42.116]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:04:42.116]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:04:42.116]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:04:42.116]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:04:42.116]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:04:42.116]  $ arguments       :List of 28
[16:04:42.116]   ..$ worker          : chr "localhost"
[16:04:42.116]   ..$ master          : NULL
[16:04:42.116]   ..$ port            : int 11100
[16:04:42.116]   ..$ connectTimeout  : num 120
[16:04:42.116]   ..$ timeout         : num 2592000
[16:04:42.116]   ..$ rscript         : NULL
[16:04:42.116]   ..$ homogeneous     : NULL
[16:04:42.116]   ..$ rscript_args    : NULL
[16:04:42.116]   ..$ rscript_envs    : NULL
[16:04:42.116]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:42.116]   ..$ rscript_startup : NULL
[16:04:42.116]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:04:42.116]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:42.116]   ..$ methods         : logi TRUE
[16:04:42.116]   ..$ socketOptions   : chr "no-delay"
[16:04:42.116]   ..$ useXDR          : logi FALSE
[16:04:42.116]   ..$ outfile         : chr "/dev/null"
[16:04:42.116]   ..$ renice          : int NA
[16:04:42.116]   ..$ rshcmd          : NULL
[16:04:42.116]   ..$ user            : NULL
[16:04:42.116]   ..$ revtunnel       : logi NA
[16:04:42.116]   ..$ rshlogfile      : NULL
[16:04:42.116]   ..$ rshopts         : NULL
[16:04:42.116]   ..$ rank            : int 1
[16:04:42.116]   ..$ manual          : logi FALSE
[16:04:42.116]   ..$ dryrun          : logi FALSE
[16:04:42.116]   ..$ quiet           : logi FALSE
[16:04:42.116]   ..$ setup_strategy  : chr "parallel"
[16:04:42.116]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:04:42.132] [local output] System call to launch all workers:
[16:04:42.132] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpKP9SHZ/worker.rank=1.parallelly.parent=83263.1453f720a6df6.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11100 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:04:42.132] [local output] Starting PSOCK main server
[16:04:42.138] [local output] Workers launched
[16:04:42.138] [local output] Waiting for workers to connect back
[16:04:42.138]  - [local output] 0 workers out of 2 ready
[16:04:42.397]  - [local output] 0 workers out of 2 ready
[16:04:42.397]  - [local output] 1 workers out of 2 ready
[16:04:42.406]  - [local output] 1 workers out of 2 ready
[16:04:42.406]  - [local output] 2 workers out of 2 ready
[16:04:42.406] [local output] Launching of workers completed
[16:04:42.406] [local output] Collecting session information from workers
[16:04:42.407] [local output]  - Worker #1 of 2
[16:04:42.408] [local output]  - Worker #2 of 2
[16:04:42.408] [local output] makeClusterPSOCK() ... done
[16:04:42.419] Packages needed by the future expression (n = 0): <none>
[16:04:42.419] Packages needed by future strategies (n = 0): <none>
[16:04:42.420] {
[16:04:42.420]     {
[16:04:42.420]         {
[16:04:42.420]             ...future.startTime <- base::Sys.time()
[16:04:42.420]             {
[16:04:42.420]                 {
[16:04:42.420]                   {
[16:04:42.420]                     {
[16:04:42.420]                       base::local({
[16:04:42.420]                         has_future <- base::requireNamespace("future", 
[16:04:42.420]                           quietly = TRUE)
[16:04:42.420]                         if (has_future) {
[16:04:42.420]                           ns <- base::getNamespace("future")
[16:04:42.420]                           version <- ns[[".package"]][["version"]]
[16:04:42.420]                           if (is.null(version)) 
[16:04:42.420]                             version <- utils::packageVersion("future")
[16:04:42.420]                         }
[16:04:42.420]                         else {
[16:04:42.420]                           version <- NULL
[16:04:42.420]                         }
[16:04:42.420]                         if (!has_future || version < "1.8.0") {
[16:04:42.420]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:42.420]                             "", base::R.version$version.string), 
[16:04:42.420]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:42.420]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:42.420]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:42.420]                               "release", "version")], collapse = " "), 
[16:04:42.420]                             hostname = base::Sys.info()[["nodename"]])
[16:04:42.420]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:42.420]                             info)
[16:04:42.420]                           info <- base::paste(info, collapse = "; ")
[16:04:42.420]                           if (!has_future) {
[16:04:42.420]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:42.420]                               info)
[16:04:42.420]                           }
[16:04:42.420]                           else {
[16:04:42.420]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:42.420]                               info, version)
[16:04:42.420]                           }
[16:04:42.420]                           base::stop(msg)
[16:04:42.420]                         }
[16:04:42.420]                       })
[16:04:42.420]                     }
[16:04:42.420]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:42.420]                     base::options(mc.cores = 1L)
[16:04:42.420]                   }
[16:04:42.420]                   options(future.plan = NULL)
[16:04:42.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:42.420]                 }
[16:04:42.420]                 ...future.workdir <- getwd()
[16:04:42.420]             }
[16:04:42.420]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:42.420]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:42.420]         }
[16:04:42.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:42.420]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:42.420]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:42.420]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:42.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:42.420]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:42.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:42.420]             base::names(...future.oldOptions))
[16:04:42.420]     }
[16:04:42.420]     if (FALSE) {
[16:04:42.420]     }
[16:04:42.420]     else {
[16:04:42.420]         if (TRUE) {
[16:04:42.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:42.420]                 open = "w")
[16:04:42.420]         }
[16:04:42.420]         else {
[16:04:42.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:42.420]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:42.420]         }
[16:04:42.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:42.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:42.420]             base::sink(type = "output", split = FALSE)
[16:04:42.420]             base::close(...future.stdout)
[16:04:42.420]         }, add = TRUE)
[16:04:42.420]     }
[16:04:42.420]     ...future.frame <- base::sys.nframe()
[16:04:42.420]     ...future.conditions <- base::list()
[16:04:42.420]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:42.420]     if (FALSE) {
[16:04:42.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:42.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:42.420]     }
[16:04:42.420]     ...future.result <- base::tryCatch({
[16:04:42.420]         base::withCallingHandlers({
[16:04:42.420]             ...future.value <- base::withVisible(base::local({
[16:04:42.420]                 ...future.makeSendCondition <- base::local({
[16:04:42.420]                   sendCondition <- NULL
[16:04:42.420]                   function(frame = 1L) {
[16:04:42.420]                     if (is.function(sendCondition)) 
[16:04:42.420]                       return(sendCondition)
[16:04:42.420]                     ns <- getNamespace("parallel")
[16:04:42.420]                     if (exists("sendData", mode = "function", 
[16:04:42.420]                       envir = ns)) {
[16:04:42.420]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:42.420]                         envir = ns)
[16:04:42.420]                       envir <- sys.frame(frame)
[16:04:42.420]                       master <- NULL
[16:04:42.420]                       while (!identical(envir, .GlobalEnv) && 
[16:04:42.420]                         !identical(envir, emptyenv())) {
[16:04:42.420]                         if (exists("master", mode = "list", envir = envir, 
[16:04:42.420]                           inherits = FALSE)) {
[16:04:42.420]                           master <- get("master", mode = "list", 
[16:04:42.420]                             envir = envir, inherits = FALSE)
[16:04:42.420]                           if (inherits(master, c("SOCKnode", 
[16:04:42.420]                             "SOCK0node"))) {
[16:04:42.420]                             sendCondition <<- function(cond) {
[16:04:42.420]                               data <- list(type = "VALUE", value = cond, 
[16:04:42.420]                                 success = TRUE)
[16:04:42.420]                               parallel_sendData(master, data)
[16:04:42.420]                             }
[16:04:42.420]                             return(sendCondition)
[16:04:42.420]                           }
[16:04:42.420]                         }
[16:04:42.420]                         frame <- frame + 1L
[16:04:42.420]                         envir <- sys.frame(frame)
[16:04:42.420]                       }
[16:04:42.420]                     }
[16:04:42.420]                     sendCondition <<- function(cond) NULL
[16:04:42.420]                   }
[16:04:42.420]                 })
[16:04:42.420]                 withCallingHandlers({
[16:04:42.420]                   NA
[16:04:42.420]                 }, immediateCondition = function(cond) {
[16:04:42.420]                   sendCondition <- ...future.makeSendCondition()
[16:04:42.420]                   sendCondition(cond)
[16:04:42.420]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.420]                   {
[16:04:42.420]                     inherits <- base::inherits
[16:04:42.420]                     invokeRestart <- base::invokeRestart
[16:04:42.420]                     is.null <- base::is.null
[16:04:42.420]                     muffled <- FALSE
[16:04:42.420]                     if (inherits(cond, "message")) {
[16:04:42.420]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:42.420]                       if (muffled) 
[16:04:42.420]                         invokeRestart("muffleMessage")
[16:04:42.420]                     }
[16:04:42.420]                     else if (inherits(cond, "warning")) {
[16:04:42.420]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:42.420]                       if (muffled) 
[16:04:42.420]                         invokeRestart("muffleWarning")
[16:04:42.420]                     }
[16:04:42.420]                     else if (inherits(cond, "condition")) {
[16:04:42.420]                       if (!is.null(pattern)) {
[16:04:42.420]                         computeRestarts <- base::computeRestarts
[16:04:42.420]                         grepl <- base::grepl
[16:04:42.420]                         restarts <- computeRestarts(cond)
[16:04:42.420]                         for (restart in restarts) {
[16:04:42.420]                           name <- restart$name
[16:04:42.420]                           if (is.null(name)) 
[16:04:42.420]                             next
[16:04:42.420]                           if (!grepl(pattern, name)) 
[16:04:42.420]                             next
[16:04:42.420]                           invokeRestart(restart)
[16:04:42.420]                           muffled <- TRUE
[16:04:42.420]                           break
[16:04:42.420]                         }
[16:04:42.420]                       }
[16:04:42.420]                     }
[16:04:42.420]                     invisible(muffled)
[16:04:42.420]                   }
[16:04:42.420]                   muffleCondition(cond)
[16:04:42.420]                 })
[16:04:42.420]             }))
[16:04:42.420]             future::FutureResult(value = ...future.value$value, 
[16:04:42.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.420]                   ...future.rng), globalenv = if (FALSE) 
[16:04:42.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:42.420]                     ...future.globalenv.names))
[16:04:42.420]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:42.420]         }, condition = base::local({
[16:04:42.420]             c <- base::c
[16:04:42.420]             inherits <- base::inherits
[16:04:42.420]             invokeRestart <- base::invokeRestart
[16:04:42.420]             length <- base::length
[16:04:42.420]             list <- base::list
[16:04:42.420]             seq.int <- base::seq.int
[16:04:42.420]             signalCondition <- base::signalCondition
[16:04:42.420]             sys.calls <- base::sys.calls
[16:04:42.420]             `[[` <- base::`[[`
[16:04:42.420]             `+` <- base::`+`
[16:04:42.420]             `<<-` <- base::`<<-`
[16:04:42.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:42.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:42.420]                   3L)]
[16:04:42.420]             }
[16:04:42.420]             function(cond) {
[16:04:42.420]                 is_error <- inherits(cond, "error")
[16:04:42.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:42.420]                   NULL)
[16:04:42.420]                 if (is_error) {
[16:04:42.420]                   sessionInformation <- function() {
[16:04:42.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:42.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:42.420]                       search = base::search(), system = base::Sys.info())
[16:04:42.420]                   }
[16:04:42.420]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:42.420]                     cond$call), session = sessionInformation(), 
[16:04:42.420]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:42.420]                   signalCondition(cond)
[16:04:42.420]                 }
[16:04:42.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:42.420]                 "immediateCondition"))) {
[16:04:42.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:42.420]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:42.420]                   if (TRUE && !signal) {
[16:04:42.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.420]                     {
[16:04:42.420]                       inherits <- base::inherits
[16:04:42.420]                       invokeRestart <- base::invokeRestart
[16:04:42.420]                       is.null <- base::is.null
[16:04:42.420]                       muffled <- FALSE
[16:04:42.420]                       if (inherits(cond, "message")) {
[16:04:42.420]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.420]                         if (muffled) 
[16:04:42.420]                           invokeRestart("muffleMessage")
[16:04:42.420]                       }
[16:04:42.420]                       else if (inherits(cond, "warning")) {
[16:04:42.420]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.420]                         if (muffled) 
[16:04:42.420]                           invokeRestart("muffleWarning")
[16:04:42.420]                       }
[16:04:42.420]                       else if (inherits(cond, "condition")) {
[16:04:42.420]                         if (!is.null(pattern)) {
[16:04:42.420]                           computeRestarts <- base::computeRestarts
[16:04:42.420]                           grepl <- base::grepl
[16:04:42.420]                           restarts <- computeRestarts(cond)
[16:04:42.420]                           for (restart in restarts) {
[16:04:42.420]                             name <- restart$name
[16:04:42.420]                             if (is.null(name)) 
[16:04:42.420]                               next
[16:04:42.420]                             if (!grepl(pattern, name)) 
[16:04:42.420]                               next
[16:04:42.420]                             invokeRestart(restart)
[16:04:42.420]                             muffled <- TRUE
[16:04:42.420]                             break
[16:04:42.420]                           }
[16:04:42.420]                         }
[16:04:42.420]                       }
[16:04:42.420]                       invisible(muffled)
[16:04:42.420]                     }
[16:04:42.420]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.420]                   }
[16:04:42.420]                 }
[16:04:42.420]                 else {
[16:04:42.420]                   if (TRUE) {
[16:04:42.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.420]                     {
[16:04:42.420]                       inherits <- base::inherits
[16:04:42.420]                       invokeRestart <- base::invokeRestart
[16:04:42.420]                       is.null <- base::is.null
[16:04:42.420]                       muffled <- FALSE
[16:04:42.420]                       if (inherits(cond, "message")) {
[16:04:42.420]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.420]                         if (muffled) 
[16:04:42.420]                           invokeRestart("muffleMessage")
[16:04:42.420]                       }
[16:04:42.420]                       else if (inherits(cond, "warning")) {
[16:04:42.420]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.420]                         if (muffled) 
[16:04:42.420]                           invokeRestart("muffleWarning")
[16:04:42.420]                       }
[16:04:42.420]                       else if (inherits(cond, "condition")) {
[16:04:42.420]                         if (!is.null(pattern)) {
[16:04:42.420]                           computeRestarts <- base::computeRestarts
[16:04:42.420]                           grepl <- base::grepl
[16:04:42.420]                           restarts <- computeRestarts(cond)
[16:04:42.420]                           for (restart in restarts) {
[16:04:42.420]                             name <- restart$name
[16:04:42.420]                             if (is.null(name)) 
[16:04:42.420]                               next
[16:04:42.420]                             if (!grepl(pattern, name)) 
[16:04:42.420]                               next
[16:04:42.420]                             invokeRestart(restart)
[16:04:42.420]                             muffled <- TRUE
[16:04:42.420]                             break
[16:04:42.420]                           }
[16:04:42.420]                         }
[16:04:42.420]                       }
[16:04:42.420]                       invisible(muffled)
[16:04:42.420]                     }
[16:04:42.420]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.420]                   }
[16:04:42.420]                 }
[16:04:42.420]             }
[16:04:42.420]         }))
[16:04:42.420]     }, error = function(ex) {
[16:04:42.420]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:42.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.420]                 ...future.rng), started = ...future.startTime, 
[16:04:42.420]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:42.420]             version = "1.8"), class = "FutureResult")
[16:04:42.420]     }, finally = {
[16:04:42.420]         if (!identical(...future.workdir, getwd())) 
[16:04:42.420]             setwd(...future.workdir)
[16:04:42.420]         {
[16:04:42.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:42.420]                 ...future.oldOptions$nwarnings <- NULL
[16:04:42.420]             }
[16:04:42.420]             base::options(...future.oldOptions)
[16:04:42.420]             if (.Platform$OS.type == "windows") {
[16:04:42.420]                 old_names <- names(...future.oldEnvVars)
[16:04:42.420]                 envs <- base::Sys.getenv()
[16:04:42.420]                 names <- names(envs)
[16:04:42.420]                 common <- intersect(names, old_names)
[16:04:42.420]                 added <- setdiff(names, old_names)
[16:04:42.420]                 removed <- setdiff(old_names, names)
[16:04:42.420]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:42.420]                   envs[common]]
[16:04:42.420]                 NAMES <- toupper(changed)
[16:04:42.420]                 args <- list()
[16:04:42.420]                 for (kk in seq_along(NAMES)) {
[16:04:42.420]                   name <- changed[[kk]]
[16:04:42.420]                   NAME <- NAMES[[kk]]
[16:04:42.420]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.420]                     next
[16:04:42.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.420]                 }
[16:04:42.420]                 NAMES <- toupper(added)
[16:04:42.420]                 for (kk in seq_along(NAMES)) {
[16:04:42.420]                   name <- added[[kk]]
[16:04:42.420]                   NAME <- NAMES[[kk]]
[16:04:42.420]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.420]                     next
[16:04:42.420]                   args[[name]] <- ""
[16:04:42.420]                 }
[16:04:42.420]                 NAMES <- toupper(removed)
[16:04:42.420]                 for (kk in seq_along(NAMES)) {
[16:04:42.420]                   name <- removed[[kk]]
[16:04:42.420]                   NAME <- NAMES[[kk]]
[16:04:42.420]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.420]                     next
[16:04:42.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.420]                 }
[16:04:42.420]                 if (length(args) > 0) 
[16:04:42.420]                   base::do.call(base::Sys.setenv, args = args)
[16:04:42.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:42.420]             }
[16:04:42.420]             else {
[16:04:42.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:42.420]             }
[16:04:42.420]             {
[16:04:42.420]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:42.420]                   0L) {
[16:04:42.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:42.420]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:42.420]                   base::options(opts)
[16:04:42.420]                 }
[16:04:42.420]                 {
[16:04:42.420]                   {
[16:04:42.420]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:42.420]                     NULL
[16:04:42.420]                   }
[16:04:42.420]                   options(future.plan = NULL)
[16:04:42.420]                   if (is.na(NA_character_)) 
[16:04:42.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:42.420]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:42.420]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:42.420]                     envir = parent.frame()) 
[16:04:42.420]                   {
[16:04:42.420]                     if (is.function(workers)) 
[16:04:42.420]                       workers <- workers()
[16:04:42.420]                     workers <- structure(as.integer(workers), 
[16:04:42.420]                       class = class(workers))
[16:04:42.420]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:42.420]                       workers >= 1)
[16:04:42.420]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:42.420]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:42.420]                     }
[16:04:42.420]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:42.420]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:42.420]                       envir = envir)
[16:04:42.420]                     if (!future$lazy) 
[16:04:42.420]                       future <- run(future)
[16:04:42.420]                     invisible(future)
[16:04:42.420]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:42.420]                 }
[16:04:42.420]             }
[16:04:42.420]         }
[16:04:42.420]     })
[16:04:42.420]     if (TRUE) {
[16:04:42.420]         base::sink(type = "output", split = FALSE)
[16:04:42.420]         if (TRUE) {
[16:04:42.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:42.420]         }
[16:04:42.420]         else {
[16:04:42.420]             ...future.result["stdout"] <- base::list(NULL)
[16:04:42.420]         }
[16:04:42.420]         base::close(...future.stdout)
[16:04:42.420]         ...future.stdout <- NULL
[16:04:42.420]     }
[16:04:42.420]     ...future.result$conditions <- ...future.conditions
[16:04:42.420]     ...future.result$finished <- base::Sys.time()
[16:04:42.420]     ...future.result
[16:04:42.420] }
[16:04:42.472] MultisessionFuture started
[16:04:42.473] result() for ClusterFuture ...
[16:04:42.473] receiveMessageFromWorker() for ClusterFuture ...
[16:04:42.473] - Validating connection of MultisessionFuture
[16:04:42.516] - received message: FutureResult
[16:04:42.516] - Received FutureResult
[16:04:42.516] - Erased future from FutureRegistry
[16:04:42.516] result() for ClusterFuture ...
[16:04:42.516] - result already collected: FutureResult
[16:04:42.517] result() for ClusterFuture ... done
[16:04:42.517] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:42.517] result() for ClusterFuture ... done
[16:04:42.517] result() for ClusterFuture ...
[16:04:42.517] - result already collected: FutureResult
[16:04:42.517] result() for ClusterFuture ... done
[16:04:42.517] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:04:42.521] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:04:42.521] getGlobalsAndPackages() ...
[16:04:42.521] Searching for globals...
[16:04:42.522] 
[16:04:42.522] Searching for globals ... DONE
[16:04:42.522] - globals: [0] <none>
[16:04:42.522] getGlobalsAndPackages() ... DONE
[16:04:42.522] run() for ‘Future’ ...
[16:04:42.523] - state: ‘created’
[16:04:42.523] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:42.537] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:42.537] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:42.537]   - Field: ‘node’
[16:04:42.537]   - Field: ‘label’
[16:04:42.537]   - Field: ‘local’
[16:04:42.538]   - Field: ‘owner’
[16:04:42.538]   - Field: ‘envir’
[16:04:42.538]   - Field: ‘workers’
[16:04:42.538]   - Field: ‘packages’
[16:04:42.538]   - Field: ‘gc’
[16:04:42.538]   - Field: ‘conditions’
[16:04:42.538]   - Field: ‘persistent’
[16:04:42.538]   - Field: ‘expr’
[16:04:42.538]   - Field: ‘uuid’
[16:04:42.539]   - Field: ‘seed’
[16:04:42.539]   - Field: ‘version’
[16:04:42.539]   - Field: ‘result’
[16:04:42.539]   - Field: ‘asynchronous’
[16:04:42.539]   - Field: ‘calls’
[16:04:42.539]   - Field: ‘globals’
[16:04:42.539]   - Field: ‘stdout’
[16:04:42.539]   - Field: ‘earlySignal’
[16:04:42.540]   - Field: ‘lazy’
[16:04:42.540]   - Field: ‘state’
[16:04:42.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:42.540] - Launch lazy future ...
[16:04:42.540] Packages needed by the future expression (n = 0): <none>
[16:04:42.540] Packages needed by future strategies (n = 0): <none>
[16:04:42.541] {
[16:04:42.541]     {
[16:04:42.541]         {
[16:04:42.541]             ...future.startTime <- base::Sys.time()
[16:04:42.541]             {
[16:04:42.541]                 {
[16:04:42.541]                   {
[16:04:42.541]                     {
[16:04:42.541]                       base::local({
[16:04:42.541]                         has_future <- base::requireNamespace("future", 
[16:04:42.541]                           quietly = TRUE)
[16:04:42.541]                         if (has_future) {
[16:04:42.541]                           ns <- base::getNamespace("future")
[16:04:42.541]                           version <- ns[[".package"]][["version"]]
[16:04:42.541]                           if (is.null(version)) 
[16:04:42.541]                             version <- utils::packageVersion("future")
[16:04:42.541]                         }
[16:04:42.541]                         else {
[16:04:42.541]                           version <- NULL
[16:04:42.541]                         }
[16:04:42.541]                         if (!has_future || version < "1.8.0") {
[16:04:42.541]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:42.541]                             "", base::R.version$version.string), 
[16:04:42.541]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:42.541]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:42.541]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:42.541]                               "release", "version")], collapse = " "), 
[16:04:42.541]                             hostname = base::Sys.info()[["nodename"]])
[16:04:42.541]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:42.541]                             info)
[16:04:42.541]                           info <- base::paste(info, collapse = "; ")
[16:04:42.541]                           if (!has_future) {
[16:04:42.541]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:42.541]                               info)
[16:04:42.541]                           }
[16:04:42.541]                           else {
[16:04:42.541]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:42.541]                               info, version)
[16:04:42.541]                           }
[16:04:42.541]                           base::stop(msg)
[16:04:42.541]                         }
[16:04:42.541]                       })
[16:04:42.541]                     }
[16:04:42.541]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:42.541]                     base::options(mc.cores = 1L)
[16:04:42.541]                   }
[16:04:42.541]                   options(future.plan = NULL)
[16:04:42.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:42.541]                 }
[16:04:42.541]                 ...future.workdir <- getwd()
[16:04:42.541]             }
[16:04:42.541]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:42.541]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:42.541]         }
[16:04:42.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:42.541]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:42.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:42.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:42.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:42.541]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:42.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:42.541]             base::names(...future.oldOptions))
[16:04:42.541]     }
[16:04:42.541]     if (FALSE) {
[16:04:42.541]     }
[16:04:42.541]     else {
[16:04:42.541]         if (TRUE) {
[16:04:42.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:42.541]                 open = "w")
[16:04:42.541]         }
[16:04:42.541]         else {
[16:04:42.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:42.541]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:42.541]         }
[16:04:42.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:42.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:42.541]             base::sink(type = "output", split = FALSE)
[16:04:42.541]             base::close(...future.stdout)
[16:04:42.541]         }, add = TRUE)
[16:04:42.541]     }
[16:04:42.541]     ...future.frame <- base::sys.nframe()
[16:04:42.541]     ...future.conditions <- base::list()
[16:04:42.541]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:42.541]     if (FALSE) {
[16:04:42.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:42.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:42.541]     }
[16:04:42.541]     ...future.result <- base::tryCatch({
[16:04:42.541]         base::withCallingHandlers({
[16:04:42.541]             ...future.value <- base::withVisible(base::local({
[16:04:42.541]                 ...future.makeSendCondition <- base::local({
[16:04:42.541]                   sendCondition <- NULL
[16:04:42.541]                   function(frame = 1L) {
[16:04:42.541]                     if (is.function(sendCondition)) 
[16:04:42.541]                       return(sendCondition)
[16:04:42.541]                     ns <- getNamespace("parallel")
[16:04:42.541]                     if (exists("sendData", mode = "function", 
[16:04:42.541]                       envir = ns)) {
[16:04:42.541]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:42.541]                         envir = ns)
[16:04:42.541]                       envir <- sys.frame(frame)
[16:04:42.541]                       master <- NULL
[16:04:42.541]                       while (!identical(envir, .GlobalEnv) && 
[16:04:42.541]                         !identical(envir, emptyenv())) {
[16:04:42.541]                         if (exists("master", mode = "list", envir = envir, 
[16:04:42.541]                           inherits = FALSE)) {
[16:04:42.541]                           master <- get("master", mode = "list", 
[16:04:42.541]                             envir = envir, inherits = FALSE)
[16:04:42.541]                           if (inherits(master, c("SOCKnode", 
[16:04:42.541]                             "SOCK0node"))) {
[16:04:42.541]                             sendCondition <<- function(cond) {
[16:04:42.541]                               data <- list(type = "VALUE", value = cond, 
[16:04:42.541]                                 success = TRUE)
[16:04:42.541]                               parallel_sendData(master, data)
[16:04:42.541]                             }
[16:04:42.541]                             return(sendCondition)
[16:04:42.541]                           }
[16:04:42.541]                         }
[16:04:42.541]                         frame <- frame + 1L
[16:04:42.541]                         envir <- sys.frame(frame)
[16:04:42.541]                       }
[16:04:42.541]                     }
[16:04:42.541]                     sendCondition <<- function(cond) NULL
[16:04:42.541]                   }
[16:04:42.541]                 })
[16:04:42.541]                 withCallingHandlers({
[16:04:42.541]                   2
[16:04:42.541]                 }, immediateCondition = function(cond) {
[16:04:42.541]                   sendCondition <- ...future.makeSendCondition()
[16:04:42.541]                   sendCondition(cond)
[16:04:42.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.541]                   {
[16:04:42.541]                     inherits <- base::inherits
[16:04:42.541]                     invokeRestart <- base::invokeRestart
[16:04:42.541]                     is.null <- base::is.null
[16:04:42.541]                     muffled <- FALSE
[16:04:42.541]                     if (inherits(cond, "message")) {
[16:04:42.541]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:42.541]                       if (muffled) 
[16:04:42.541]                         invokeRestart("muffleMessage")
[16:04:42.541]                     }
[16:04:42.541]                     else if (inherits(cond, "warning")) {
[16:04:42.541]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:42.541]                       if (muffled) 
[16:04:42.541]                         invokeRestart("muffleWarning")
[16:04:42.541]                     }
[16:04:42.541]                     else if (inherits(cond, "condition")) {
[16:04:42.541]                       if (!is.null(pattern)) {
[16:04:42.541]                         computeRestarts <- base::computeRestarts
[16:04:42.541]                         grepl <- base::grepl
[16:04:42.541]                         restarts <- computeRestarts(cond)
[16:04:42.541]                         for (restart in restarts) {
[16:04:42.541]                           name <- restart$name
[16:04:42.541]                           if (is.null(name)) 
[16:04:42.541]                             next
[16:04:42.541]                           if (!grepl(pattern, name)) 
[16:04:42.541]                             next
[16:04:42.541]                           invokeRestart(restart)
[16:04:42.541]                           muffled <- TRUE
[16:04:42.541]                           break
[16:04:42.541]                         }
[16:04:42.541]                       }
[16:04:42.541]                     }
[16:04:42.541]                     invisible(muffled)
[16:04:42.541]                   }
[16:04:42.541]                   muffleCondition(cond)
[16:04:42.541]                 })
[16:04:42.541]             }))
[16:04:42.541]             future::FutureResult(value = ...future.value$value, 
[16:04:42.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.541]                   ...future.rng), globalenv = if (FALSE) 
[16:04:42.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:42.541]                     ...future.globalenv.names))
[16:04:42.541]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:42.541]         }, condition = base::local({
[16:04:42.541]             c <- base::c
[16:04:42.541]             inherits <- base::inherits
[16:04:42.541]             invokeRestart <- base::invokeRestart
[16:04:42.541]             length <- base::length
[16:04:42.541]             list <- base::list
[16:04:42.541]             seq.int <- base::seq.int
[16:04:42.541]             signalCondition <- base::signalCondition
[16:04:42.541]             sys.calls <- base::sys.calls
[16:04:42.541]             `[[` <- base::`[[`
[16:04:42.541]             `+` <- base::`+`
[16:04:42.541]             `<<-` <- base::`<<-`
[16:04:42.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:42.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:42.541]                   3L)]
[16:04:42.541]             }
[16:04:42.541]             function(cond) {
[16:04:42.541]                 is_error <- inherits(cond, "error")
[16:04:42.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:42.541]                   NULL)
[16:04:42.541]                 if (is_error) {
[16:04:42.541]                   sessionInformation <- function() {
[16:04:42.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:42.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:42.541]                       search = base::search(), system = base::Sys.info())
[16:04:42.541]                   }
[16:04:42.541]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:42.541]                     cond$call), session = sessionInformation(), 
[16:04:42.541]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:42.541]                   signalCondition(cond)
[16:04:42.541]                 }
[16:04:42.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:42.541]                 "immediateCondition"))) {
[16:04:42.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:42.541]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:42.541]                   if (TRUE && !signal) {
[16:04:42.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.541]                     {
[16:04:42.541]                       inherits <- base::inherits
[16:04:42.541]                       invokeRestart <- base::invokeRestart
[16:04:42.541]                       is.null <- base::is.null
[16:04:42.541]                       muffled <- FALSE
[16:04:42.541]                       if (inherits(cond, "message")) {
[16:04:42.541]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.541]                         if (muffled) 
[16:04:42.541]                           invokeRestart("muffleMessage")
[16:04:42.541]                       }
[16:04:42.541]                       else if (inherits(cond, "warning")) {
[16:04:42.541]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.541]                         if (muffled) 
[16:04:42.541]                           invokeRestart("muffleWarning")
[16:04:42.541]                       }
[16:04:42.541]                       else if (inherits(cond, "condition")) {
[16:04:42.541]                         if (!is.null(pattern)) {
[16:04:42.541]                           computeRestarts <- base::computeRestarts
[16:04:42.541]                           grepl <- base::grepl
[16:04:42.541]                           restarts <- computeRestarts(cond)
[16:04:42.541]                           for (restart in restarts) {
[16:04:42.541]                             name <- restart$name
[16:04:42.541]                             if (is.null(name)) 
[16:04:42.541]                               next
[16:04:42.541]                             if (!grepl(pattern, name)) 
[16:04:42.541]                               next
[16:04:42.541]                             invokeRestart(restart)
[16:04:42.541]                             muffled <- TRUE
[16:04:42.541]                             break
[16:04:42.541]                           }
[16:04:42.541]                         }
[16:04:42.541]                       }
[16:04:42.541]                       invisible(muffled)
[16:04:42.541]                     }
[16:04:42.541]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.541]                   }
[16:04:42.541]                 }
[16:04:42.541]                 else {
[16:04:42.541]                   if (TRUE) {
[16:04:42.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.541]                     {
[16:04:42.541]                       inherits <- base::inherits
[16:04:42.541]                       invokeRestart <- base::invokeRestart
[16:04:42.541]                       is.null <- base::is.null
[16:04:42.541]                       muffled <- FALSE
[16:04:42.541]                       if (inherits(cond, "message")) {
[16:04:42.541]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.541]                         if (muffled) 
[16:04:42.541]                           invokeRestart("muffleMessage")
[16:04:42.541]                       }
[16:04:42.541]                       else if (inherits(cond, "warning")) {
[16:04:42.541]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.541]                         if (muffled) 
[16:04:42.541]                           invokeRestart("muffleWarning")
[16:04:42.541]                       }
[16:04:42.541]                       else if (inherits(cond, "condition")) {
[16:04:42.541]                         if (!is.null(pattern)) {
[16:04:42.541]                           computeRestarts <- base::computeRestarts
[16:04:42.541]                           grepl <- base::grepl
[16:04:42.541]                           restarts <- computeRestarts(cond)
[16:04:42.541]                           for (restart in restarts) {
[16:04:42.541]                             name <- restart$name
[16:04:42.541]                             if (is.null(name)) 
[16:04:42.541]                               next
[16:04:42.541]                             if (!grepl(pattern, name)) 
[16:04:42.541]                               next
[16:04:42.541]                             invokeRestart(restart)
[16:04:42.541]                             muffled <- TRUE
[16:04:42.541]                             break
[16:04:42.541]                           }
[16:04:42.541]                         }
[16:04:42.541]                       }
[16:04:42.541]                       invisible(muffled)
[16:04:42.541]                     }
[16:04:42.541]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.541]                   }
[16:04:42.541]                 }
[16:04:42.541]             }
[16:04:42.541]         }))
[16:04:42.541]     }, error = function(ex) {
[16:04:42.541]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:42.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.541]                 ...future.rng), started = ...future.startTime, 
[16:04:42.541]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:42.541]             version = "1.8"), class = "FutureResult")
[16:04:42.541]     }, finally = {
[16:04:42.541]         if (!identical(...future.workdir, getwd())) 
[16:04:42.541]             setwd(...future.workdir)
[16:04:42.541]         {
[16:04:42.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:42.541]                 ...future.oldOptions$nwarnings <- NULL
[16:04:42.541]             }
[16:04:42.541]             base::options(...future.oldOptions)
[16:04:42.541]             if (.Platform$OS.type == "windows") {
[16:04:42.541]                 old_names <- names(...future.oldEnvVars)
[16:04:42.541]                 envs <- base::Sys.getenv()
[16:04:42.541]                 names <- names(envs)
[16:04:42.541]                 common <- intersect(names, old_names)
[16:04:42.541]                 added <- setdiff(names, old_names)
[16:04:42.541]                 removed <- setdiff(old_names, names)
[16:04:42.541]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:42.541]                   envs[common]]
[16:04:42.541]                 NAMES <- toupper(changed)
[16:04:42.541]                 args <- list()
[16:04:42.541]                 for (kk in seq_along(NAMES)) {
[16:04:42.541]                   name <- changed[[kk]]
[16:04:42.541]                   NAME <- NAMES[[kk]]
[16:04:42.541]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.541]                     next
[16:04:42.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.541]                 }
[16:04:42.541]                 NAMES <- toupper(added)
[16:04:42.541]                 for (kk in seq_along(NAMES)) {
[16:04:42.541]                   name <- added[[kk]]
[16:04:42.541]                   NAME <- NAMES[[kk]]
[16:04:42.541]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.541]                     next
[16:04:42.541]                   args[[name]] <- ""
[16:04:42.541]                 }
[16:04:42.541]                 NAMES <- toupper(removed)
[16:04:42.541]                 for (kk in seq_along(NAMES)) {
[16:04:42.541]                   name <- removed[[kk]]
[16:04:42.541]                   NAME <- NAMES[[kk]]
[16:04:42.541]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.541]                     next
[16:04:42.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.541]                 }
[16:04:42.541]                 if (length(args) > 0) 
[16:04:42.541]                   base::do.call(base::Sys.setenv, args = args)
[16:04:42.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:42.541]             }
[16:04:42.541]             else {
[16:04:42.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:42.541]             }
[16:04:42.541]             {
[16:04:42.541]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:42.541]                   0L) {
[16:04:42.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:42.541]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:42.541]                   base::options(opts)
[16:04:42.541]                 }
[16:04:42.541]                 {
[16:04:42.541]                   {
[16:04:42.541]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:42.541]                     NULL
[16:04:42.541]                   }
[16:04:42.541]                   options(future.plan = NULL)
[16:04:42.541]                   if (is.na(NA_character_)) 
[16:04:42.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:42.541]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:42.541]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:42.541]                     envir = parent.frame()) 
[16:04:42.541]                   {
[16:04:42.541]                     if (is.function(workers)) 
[16:04:42.541]                       workers <- workers()
[16:04:42.541]                     workers <- structure(as.integer(workers), 
[16:04:42.541]                       class = class(workers))
[16:04:42.541]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:42.541]                       workers >= 1)
[16:04:42.541]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:42.541]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:42.541]                     }
[16:04:42.541]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:42.541]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:42.541]                       envir = envir)
[16:04:42.541]                     if (!future$lazy) 
[16:04:42.541]                       future <- run(future)
[16:04:42.541]                     invisible(future)
[16:04:42.541]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:42.541]                 }
[16:04:42.541]             }
[16:04:42.541]         }
[16:04:42.541]     })
[16:04:42.541]     if (TRUE) {
[16:04:42.541]         base::sink(type = "output", split = FALSE)
[16:04:42.541]         if (TRUE) {
[16:04:42.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:42.541]         }
[16:04:42.541]         else {
[16:04:42.541]             ...future.result["stdout"] <- base::list(NULL)
[16:04:42.541]         }
[16:04:42.541]         base::close(...future.stdout)
[16:04:42.541]         ...future.stdout <- NULL
[16:04:42.541]     }
[16:04:42.541]     ...future.result$conditions <- ...future.conditions
[16:04:42.541]     ...future.result$finished <- base::Sys.time()
[16:04:42.541]     ...future.result
[16:04:42.541] }
[16:04:42.544] MultisessionFuture started
[16:04:42.545] - Launch lazy future ... done
[16:04:42.545] run() for ‘MultisessionFuture’ ... done
[16:04:42.545] getGlobalsAndPackages() ...
[16:04:42.545] Searching for globals...
[16:04:42.546] 
[16:04:42.546] Searching for globals ... DONE
[16:04:42.546] - globals: [0] <none>
[16:04:42.546] getGlobalsAndPackages() ... DONE
[16:04:42.546] run() for ‘Future’ ...
[16:04:42.546] - state: ‘created’
[16:04:42.546] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:42.560] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:42.561] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:42.561]   - Field: ‘node’
[16:04:42.561]   - Field: ‘label’
[16:04:42.561]   - Field: ‘local’
[16:04:42.561]   - Field: ‘owner’
[16:04:42.561]   - Field: ‘envir’
[16:04:42.561]   - Field: ‘workers’
[16:04:42.561]   - Field: ‘packages’
[16:04:42.561]   - Field: ‘gc’
[16:04:42.562]   - Field: ‘conditions’
[16:04:42.562]   - Field: ‘persistent’
[16:04:42.562]   - Field: ‘expr’
[16:04:42.562]   - Field: ‘uuid’
[16:04:42.562]   - Field: ‘seed’
[16:04:42.562]   - Field: ‘version’
[16:04:42.562]   - Field: ‘result’
[16:04:42.562]   - Field: ‘asynchronous’
[16:04:42.562]   - Field: ‘calls’
[16:04:42.563]   - Field: ‘globals’
[16:04:42.563]   - Field: ‘stdout’
[16:04:42.563]   - Field: ‘earlySignal’
[16:04:42.563]   - Field: ‘lazy’
[16:04:42.563]   - Field: ‘state’
[16:04:42.563] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:42.563] - Launch lazy future ...
[16:04:42.564] Packages needed by the future expression (n = 0): <none>
[16:04:42.564] Packages needed by future strategies (n = 0): <none>
[16:04:42.564] {
[16:04:42.564]     {
[16:04:42.564]         {
[16:04:42.564]             ...future.startTime <- base::Sys.time()
[16:04:42.564]             {
[16:04:42.564]                 {
[16:04:42.564]                   {
[16:04:42.564]                     {
[16:04:42.564]                       base::local({
[16:04:42.564]                         has_future <- base::requireNamespace("future", 
[16:04:42.564]                           quietly = TRUE)
[16:04:42.564]                         if (has_future) {
[16:04:42.564]                           ns <- base::getNamespace("future")
[16:04:42.564]                           version <- ns[[".package"]][["version"]]
[16:04:42.564]                           if (is.null(version)) 
[16:04:42.564]                             version <- utils::packageVersion("future")
[16:04:42.564]                         }
[16:04:42.564]                         else {
[16:04:42.564]                           version <- NULL
[16:04:42.564]                         }
[16:04:42.564]                         if (!has_future || version < "1.8.0") {
[16:04:42.564]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:42.564]                             "", base::R.version$version.string), 
[16:04:42.564]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:42.564]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:42.564]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:42.564]                               "release", "version")], collapse = " "), 
[16:04:42.564]                             hostname = base::Sys.info()[["nodename"]])
[16:04:42.564]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:42.564]                             info)
[16:04:42.564]                           info <- base::paste(info, collapse = "; ")
[16:04:42.564]                           if (!has_future) {
[16:04:42.564]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:42.564]                               info)
[16:04:42.564]                           }
[16:04:42.564]                           else {
[16:04:42.564]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:42.564]                               info, version)
[16:04:42.564]                           }
[16:04:42.564]                           base::stop(msg)
[16:04:42.564]                         }
[16:04:42.564]                       })
[16:04:42.564]                     }
[16:04:42.564]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:42.564]                     base::options(mc.cores = 1L)
[16:04:42.564]                   }
[16:04:42.564]                   options(future.plan = NULL)
[16:04:42.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:42.564]                 }
[16:04:42.564]                 ...future.workdir <- getwd()
[16:04:42.564]             }
[16:04:42.564]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:42.564]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:42.564]         }
[16:04:42.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:42.564]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:42.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:42.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:42.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:42.564]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:42.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:42.564]             base::names(...future.oldOptions))
[16:04:42.564]     }
[16:04:42.564]     if (FALSE) {
[16:04:42.564]     }
[16:04:42.564]     else {
[16:04:42.564]         if (TRUE) {
[16:04:42.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:42.564]                 open = "w")
[16:04:42.564]         }
[16:04:42.564]         else {
[16:04:42.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:42.564]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:42.564]         }
[16:04:42.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:42.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:42.564]             base::sink(type = "output", split = FALSE)
[16:04:42.564]             base::close(...future.stdout)
[16:04:42.564]         }, add = TRUE)
[16:04:42.564]     }
[16:04:42.564]     ...future.frame <- base::sys.nframe()
[16:04:42.564]     ...future.conditions <- base::list()
[16:04:42.564]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:42.564]     if (FALSE) {
[16:04:42.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:42.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:42.564]     }
[16:04:42.564]     ...future.result <- base::tryCatch({
[16:04:42.564]         base::withCallingHandlers({
[16:04:42.564]             ...future.value <- base::withVisible(base::local({
[16:04:42.564]                 ...future.makeSendCondition <- base::local({
[16:04:42.564]                   sendCondition <- NULL
[16:04:42.564]                   function(frame = 1L) {
[16:04:42.564]                     if (is.function(sendCondition)) 
[16:04:42.564]                       return(sendCondition)
[16:04:42.564]                     ns <- getNamespace("parallel")
[16:04:42.564]                     if (exists("sendData", mode = "function", 
[16:04:42.564]                       envir = ns)) {
[16:04:42.564]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:42.564]                         envir = ns)
[16:04:42.564]                       envir <- sys.frame(frame)
[16:04:42.564]                       master <- NULL
[16:04:42.564]                       while (!identical(envir, .GlobalEnv) && 
[16:04:42.564]                         !identical(envir, emptyenv())) {
[16:04:42.564]                         if (exists("master", mode = "list", envir = envir, 
[16:04:42.564]                           inherits = FALSE)) {
[16:04:42.564]                           master <- get("master", mode = "list", 
[16:04:42.564]                             envir = envir, inherits = FALSE)
[16:04:42.564]                           if (inherits(master, c("SOCKnode", 
[16:04:42.564]                             "SOCK0node"))) {
[16:04:42.564]                             sendCondition <<- function(cond) {
[16:04:42.564]                               data <- list(type = "VALUE", value = cond, 
[16:04:42.564]                                 success = TRUE)
[16:04:42.564]                               parallel_sendData(master, data)
[16:04:42.564]                             }
[16:04:42.564]                             return(sendCondition)
[16:04:42.564]                           }
[16:04:42.564]                         }
[16:04:42.564]                         frame <- frame + 1L
[16:04:42.564]                         envir <- sys.frame(frame)
[16:04:42.564]                       }
[16:04:42.564]                     }
[16:04:42.564]                     sendCondition <<- function(cond) NULL
[16:04:42.564]                   }
[16:04:42.564]                 })
[16:04:42.564]                 withCallingHandlers({
[16:04:42.564]                   NULL
[16:04:42.564]                 }, immediateCondition = function(cond) {
[16:04:42.564]                   sendCondition <- ...future.makeSendCondition()
[16:04:42.564]                   sendCondition(cond)
[16:04:42.564]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.564]                   {
[16:04:42.564]                     inherits <- base::inherits
[16:04:42.564]                     invokeRestart <- base::invokeRestart
[16:04:42.564]                     is.null <- base::is.null
[16:04:42.564]                     muffled <- FALSE
[16:04:42.564]                     if (inherits(cond, "message")) {
[16:04:42.564]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:42.564]                       if (muffled) 
[16:04:42.564]                         invokeRestart("muffleMessage")
[16:04:42.564]                     }
[16:04:42.564]                     else if (inherits(cond, "warning")) {
[16:04:42.564]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:42.564]                       if (muffled) 
[16:04:42.564]                         invokeRestart("muffleWarning")
[16:04:42.564]                     }
[16:04:42.564]                     else if (inherits(cond, "condition")) {
[16:04:42.564]                       if (!is.null(pattern)) {
[16:04:42.564]                         computeRestarts <- base::computeRestarts
[16:04:42.564]                         grepl <- base::grepl
[16:04:42.564]                         restarts <- computeRestarts(cond)
[16:04:42.564]                         for (restart in restarts) {
[16:04:42.564]                           name <- restart$name
[16:04:42.564]                           if (is.null(name)) 
[16:04:42.564]                             next
[16:04:42.564]                           if (!grepl(pattern, name)) 
[16:04:42.564]                             next
[16:04:42.564]                           invokeRestart(restart)
[16:04:42.564]                           muffled <- TRUE
[16:04:42.564]                           break
[16:04:42.564]                         }
[16:04:42.564]                       }
[16:04:42.564]                     }
[16:04:42.564]                     invisible(muffled)
[16:04:42.564]                   }
[16:04:42.564]                   muffleCondition(cond)
[16:04:42.564]                 })
[16:04:42.564]             }))
[16:04:42.564]             future::FutureResult(value = ...future.value$value, 
[16:04:42.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.564]                   ...future.rng), globalenv = if (FALSE) 
[16:04:42.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:42.564]                     ...future.globalenv.names))
[16:04:42.564]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:42.564]         }, condition = base::local({
[16:04:42.564]             c <- base::c
[16:04:42.564]             inherits <- base::inherits
[16:04:42.564]             invokeRestart <- base::invokeRestart
[16:04:42.564]             length <- base::length
[16:04:42.564]             list <- base::list
[16:04:42.564]             seq.int <- base::seq.int
[16:04:42.564]             signalCondition <- base::signalCondition
[16:04:42.564]             sys.calls <- base::sys.calls
[16:04:42.564]             `[[` <- base::`[[`
[16:04:42.564]             `+` <- base::`+`
[16:04:42.564]             `<<-` <- base::`<<-`
[16:04:42.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:42.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:42.564]                   3L)]
[16:04:42.564]             }
[16:04:42.564]             function(cond) {
[16:04:42.564]                 is_error <- inherits(cond, "error")
[16:04:42.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:42.564]                   NULL)
[16:04:42.564]                 if (is_error) {
[16:04:42.564]                   sessionInformation <- function() {
[16:04:42.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:42.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:42.564]                       search = base::search(), system = base::Sys.info())
[16:04:42.564]                   }
[16:04:42.564]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:42.564]                     cond$call), session = sessionInformation(), 
[16:04:42.564]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:42.564]                   signalCondition(cond)
[16:04:42.564]                 }
[16:04:42.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:42.564]                 "immediateCondition"))) {
[16:04:42.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:42.564]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:42.564]                   if (TRUE && !signal) {
[16:04:42.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.564]                     {
[16:04:42.564]                       inherits <- base::inherits
[16:04:42.564]                       invokeRestart <- base::invokeRestart
[16:04:42.564]                       is.null <- base::is.null
[16:04:42.564]                       muffled <- FALSE
[16:04:42.564]                       if (inherits(cond, "message")) {
[16:04:42.564]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.564]                         if (muffled) 
[16:04:42.564]                           invokeRestart("muffleMessage")
[16:04:42.564]                       }
[16:04:42.564]                       else if (inherits(cond, "warning")) {
[16:04:42.564]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.564]                         if (muffled) 
[16:04:42.564]                           invokeRestart("muffleWarning")
[16:04:42.564]                       }
[16:04:42.564]                       else if (inherits(cond, "condition")) {
[16:04:42.564]                         if (!is.null(pattern)) {
[16:04:42.564]                           computeRestarts <- base::computeRestarts
[16:04:42.564]                           grepl <- base::grepl
[16:04:42.564]                           restarts <- computeRestarts(cond)
[16:04:42.564]                           for (restart in restarts) {
[16:04:42.564]                             name <- restart$name
[16:04:42.564]                             if (is.null(name)) 
[16:04:42.564]                               next
[16:04:42.564]                             if (!grepl(pattern, name)) 
[16:04:42.564]                               next
[16:04:42.564]                             invokeRestart(restart)
[16:04:42.564]                             muffled <- TRUE
[16:04:42.564]                             break
[16:04:42.564]                           }
[16:04:42.564]                         }
[16:04:42.564]                       }
[16:04:42.564]                       invisible(muffled)
[16:04:42.564]                     }
[16:04:42.564]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.564]                   }
[16:04:42.564]                 }
[16:04:42.564]                 else {
[16:04:42.564]                   if (TRUE) {
[16:04:42.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.564]                     {
[16:04:42.564]                       inherits <- base::inherits
[16:04:42.564]                       invokeRestart <- base::invokeRestart
[16:04:42.564]                       is.null <- base::is.null
[16:04:42.564]                       muffled <- FALSE
[16:04:42.564]                       if (inherits(cond, "message")) {
[16:04:42.564]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.564]                         if (muffled) 
[16:04:42.564]                           invokeRestart("muffleMessage")
[16:04:42.564]                       }
[16:04:42.564]                       else if (inherits(cond, "warning")) {
[16:04:42.564]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.564]                         if (muffled) 
[16:04:42.564]                           invokeRestart("muffleWarning")
[16:04:42.564]                       }
[16:04:42.564]                       else if (inherits(cond, "condition")) {
[16:04:42.564]                         if (!is.null(pattern)) {
[16:04:42.564]                           computeRestarts <- base::computeRestarts
[16:04:42.564]                           grepl <- base::grepl
[16:04:42.564]                           restarts <- computeRestarts(cond)
[16:04:42.564]                           for (restart in restarts) {
[16:04:42.564]                             name <- restart$name
[16:04:42.564]                             if (is.null(name)) 
[16:04:42.564]                               next
[16:04:42.564]                             if (!grepl(pattern, name)) 
[16:04:42.564]                               next
[16:04:42.564]                             invokeRestart(restart)
[16:04:42.564]                             muffled <- TRUE
[16:04:42.564]                             break
[16:04:42.564]                           }
[16:04:42.564]                         }
[16:04:42.564]                       }
[16:04:42.564]                       invisible(muffled)
[16:04:42.564]                     }
[16:04:42.564]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.564]                   }
[16:04:42.564]                 }
[16:04:42.564]             }
[16:04:42.564]         }))
[16:04:42.564]     }, error = function(ex) {
[16:04:42.564]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:42.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.564]                 ...future.rng), started = ...future.startTime, 
[16:04:42.564]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:42.564]             version = "1.8"), class = "FutureResult")
[16:04:42.564]     }, finally = {
[16:04:42.564]         if (!identical(...future.workdir, getwd())) 
[16:04:42.564]             setwd(...future.workdir)
[16:04:42.564]         {
[16:04:42.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:42.564]                 ...future.oldOptions$nwarnings <- NULL
[16:04:42.564]             }
[16:04:42.564]             base::options(...future.oldOptions)
[16:04:42.564]             if (.Platform$OS.type == "windows") {
[16:04:42.564]                 old_names <- names(...future.oldEnvVars)
[16:04:42.564]                 envs <- base::Sys.getenv()
[16:04:42.564]                 names <- names(envs)
[16:04:42.564]                 common <- intersect(names, old_names)
[16:04:42.564]                 added <- setdiff(names, old_names)
[16:04:42.564]                 removed <- setdiff(old_names, names)
[16:04:42.564]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:42.564]                   envs[common]]
[16:04:42.564]                 NAMES <- toupper(changed)
[16:04:42.564]                 args <- list()
[16:04:42.564]                 for (kk in seq_along(NAMES)) {
[16:04:42.564]                   name <- changed[[kk]]
[16:04:42.564]                   NAME <- NAMES[[kk]]
[16:04:42.564]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.564]                     next
[16:04:42.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.564]                 }
[16:04:42.564]                 NAMES <- toupper(added)
[16:04:42.564]                 for (kk in seq_along(NAMES)) {
[16:04:42.564]                   name <- added[[kk]]
[16:04:42.564]                   NAME <- NAMES[[kk]]
[16:04:42.564]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.564]                     next
[16:04:42.564]                   args[[name]] <- ""
[16:04:42.564]                 }
[16:04:42.564]                 NAMES <- toupper(removed)
[16:04:42.564]                 for (kk in seq_along(NAMES)) {
[16:04:42.564]                   name <- removed[[kk]]
[16:04:42.564]                   NAME <- NAMES[[kk]]
[16:04:42.564]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.564]                     next
[16:04:42.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.564]                 }
[16:04:42.564]                 if (length(args) > 0) 
[16:04:42.564]                   base::do.call(base::Sys.setenv, args = args)
[16:04:42.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:42.564]             }
[16:04:42.564]             else {
[16:04:42.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:42.564]             }
[16:04:42.564]             {
[16:04:42.564]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:42.564]                   0L) {
[16:04:42.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:42.564]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:42.564]                   base::options(opts)
[16:04:42.564]                 }
[16:04:42.564]                 {
[16:04:42.564]                   {
[16:04:42.564]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:42.564]                     NULL
[16:04:42.564]                   }
[16:04:42.564]                   options(future.plan = NULL)
[16:04:42.564]                   if (is.na(NA_character_)) 
[16:04:42.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:42.564]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:42.564]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:42.564]                     envir = parent.frame()) 
[16:04:42.564]                   {
[16:04:42.564]                     if (is.function(workers)) 
[16:04:42.564]                       workers <- workers()
[16:04:42.564]                     workers <- structure(as.integer(workers), 
[16:04:42.564]                       class = class(workers))
[16:04:42.564]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:42.564]                       workers >= 1)
[16:04:42.564]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:42.564]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:42.564]                     }
[16:04:42.564]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:42.564]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:42.564]                       envir = envir)
[16:04:42.564]                     if (!future$lazy) 
[16:04:42.564]                       future <- run(future)
[16:04:42.564]                     invisible(future)
[16:04:42.564]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:42.564]                 }
[16:04:42.564]             }
[16:04:42.564]         }
[16:04:42.564]     })
[16:04:42.564]     if (TRUE) {
[16:04:42.564]         base::sink(type = "output", split = FALSE)
[16:04:42.564]         if (TRUE) {
[16:04:42.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:42.564]         }
[16:04:42.564]         else {
[16:04:42.564]             ...future.result["stdout"] <- base::list(NULL)
[16:04:42.564]         }
[16:04:42.564]         base::close(...future.stdout)
[16:04:42.564]         ...future.stdout <- NULL
[16:04:42.564]     }
[16:04:42.564]     ...future.result$conditions <- ...future.conditions
[16:04:42.564]     ...future.result$finished <- base::Sys.time()
[16:04:42.564]     ...future.result
[16:04:42.564] }
[16:04:42.618] MultisessionFuture started
[16:04:42.619] - Launch lazy future ... done
[16:04:42.619] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874eca2a68> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874f10ea58> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874eca2a68> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874f10ea58> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:04:42.627] receiveMessageFromWorker() for ClusterFuture ...
[16:04:42.628] - Validating connection of MultisessionFuture
[16:04:42.628] - received message: FutureResult
[16:04:42.628] - Received FutureResult
[16:04:42.628] - Erased future from FutureRegistry
[16:04:42.629] result() for ClusterFuture ...
[16:04:42.629] - result already collected: FutureResult
[16:04:42.629] result() for ClusterFuture ... done
[16:04:42.629] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:42.641] resolve() on list ...
[16:04:42.641]  recursive: 0
[16:04:42.641]  length: 6
[16:04:42.641]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:42.641] signalConditionsASAP(numeric, pos=1) ...
[16:04:42.641] - nx: 6
[16:04:42.641] - relay: TRUE
[16:04:42.641] - stdout: TRUE
[16:04:42.642] - signal: TRUE
[16:04:42.642] - resignal: FALSE
[16:04:42.642] - force: TRUE
[16:04:42.642] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.642] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.642]  - until=2
[16:04:42.642]  - relaying element #2
[16:04:42.642] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.642] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.643] signalConditionsASAP(NULL, pos=1) ... done
[16:04:42.643]  length: 5 (resolved future 1)
[16:04:42.643] Future #2
[16:04:42.643] result() for ClusterFuture ...
[16:04:42.643] - result already collected: FutureResult
[16:04:42.643] result() for ClusterFuture ... done
[16:04:42.643] result() for ClusterFuture ...
[16:04:42.643] - result already collected: FutureResult
[16:04:42.644] result() for ClusterFuture ... done
[16:04:42.644] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:42.644] - nx: 6
[16:04:42.644] - relay: TRUE
[16:04:42.644] - stdout: TRUE
[16:04:42.644] - signal: TRUE
[16:04:42.644] - resignal: FALSE
[16:04:42.644] - force: TRUE
[16:04:42.644] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.645] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.645]  - until=2
[16:04:42.645]  - relaying element #2
[16:04:42.645] result() for ClusterFuture ...
[16:04:42.645] - result already collected: FutureResult
[16:04:42.645] result() for ClusterFuture ... done
[16:04:42.645] result() for ClusterFuture ...
[16:04:42.645] - result already collected: FutureResult
[16:04:42.645] result() for ClusterFuture ... done
[16:04:42.646] result() for ClusterFuture ...
[16:04:42.646] - result already collected: FutureResult
[16:04:42.646] result() for ClusterFuture ... done
[16:04:42.646] result() for ClusterFuture ...
[16:04:42.646] - result already collected: FutureResult
[16:04:42.646] result() for ClusterFuture ... done
[16:04:42.646] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.646] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.646] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:42.647]  length: 4 (resolved future 2)
[16:04:42.657] signalConditionsASAP(NULL, pos=4) ...
[16:04:42.657] - nx: 6
[16:04:42.658] - relay: TRUE
[16:04:42.658] - stdout: TRUE
[16:04:42.658] - signal: TRUE
[16:04:42.658] - resignal: FALSE
[16:04:42.658] - force: TRUE
[16:04:42.658] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.659] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.659]  - until=5
[16:04:42.659]  - relaying element #3
[16:04:42.659]  - relaying element #5
[16:04:42.659] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:04:42.659] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.659] signalConditionsASAP(NULL, pos=4) ... done
[16:04:42.659]  length: 3 (resolved future 4)
[16:04:42.660] signalConditionsASAP(NULL, pos=5) ...
[16:04:42.660] - nx: 6
[16:04:42.660] - relay: TRUE
[16:04:42.660] - stdout: TRUE
[16:04:42.660] - signal: TRUE
[16:04:42.660] - resignal: FALSE
[16:04:42.660] - force: TRUE
[16:04:42.660] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:04:42.661] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.661]  - until=6
[16:04:42.661]  - relaying element #3
[16:04:42.661]  - relaying element #6
[16:04:42.661] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:04:42.661] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.661] signalConditionsASAP(NULL, pos=5) ... done
[16:04:42.661]  length: 2 (resolved future 5)
[16:04:42.661] signalConditionsASAP(numeric, pos=6) ...
[16:04:42.662] - nx: 6
[16:04:42.662] - relay: TRUE
[16:04:42.662] - stdout: TRUE
[16:04:42.662] - signal: TRUE
[16:04:42.662] - resignal: FALSE
[16:04:42.662] - force: TRUE
[16:04:42.662] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:04:42.662] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.662]  - until=6
[16:04:42.662]  - relaying element #3
[16:04:42.663] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:04:42.663] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.663] signalConditionsASAP(NULL, pos=6) ... done
[16:04:42.663]  length: 1 (resolved future 6)
[16:04:42.674] receiveMessageFromWorker() for ClusterFuture ...
[16:04:42.674] - Validating connection of MultisessionFuture
[16:04:42.674] - received message: FutureResult
[16:04:42.674] - Received FutureResult
[16:04:42.674] - Erased future from FutureRegistry
[16:04:42.675] result() for ClusterFuture ...
[16:04:42.675] - result already collected: FutureResult
[16:04:42.675] result() for ClusterFuture ... done
[16:04:42.675] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:42.675] Future #3
[16:04:42.675] result() for ClusterFuture ...
[16:04:42.675] - result already collected: FutureResult
[16:04:42.675] result() for ClusterFuture ... done
[16:04:42.676] result() for ClusterFuture ...
[16:04:42.676] - result already collected: FutureResult
[16:04:42.676] result() for ClusterFuture ... done
[16:04:42.676] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:42.676] - nx: 6
[16:04:42.676] - relay: TRUE
[16:04:42.676] - stdout: TRUE
[16:04:42.676] - signal: TRUE
[16:04:42.676] - resignal: FALSE
[16:04:42.676] - force: TRUE
[16:04:42.677] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:04:42.677] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.677]  - until=6
[16:04:42.677]  - relaying element #3
[16:04:42.677] result() for ClusterFuture ...
[16:04:42.677] - result already collected: FutureResult
[16:04:42.677] result() for ClusterFuture ... done
[16:04:42.677] result() for ClusterFuture ...
[16:04:42.677] - result already collected: FutureResult
[16:04:42.678] result() for ClusterFuture ... done
[16:04:42.678] result() for ClusterFuture ...
[16:04:42.678] - result already collected: FutureResult
[16:04:42.678] result() for ClusterFuture ... done
[16:04:42.678] result() for ClusterFuture ...
[16:04:42.678] - result already collected: FutureResult
[16:04:42.678] result() for ClusterFuture ... done
[16:04:42.678] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:42.678] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.679] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:42.679]  length: 0 (resolved future 3)
[16:04:42.681] Relaying remaining futures
[16:04:42.681] signalConditionsASAP(NULL, pos=0) ...
[16:04:42.681] - nx: 6
[16:04:42.681] - relay: TRUE
[16:04:42.681] - stdout: TRUE
[16:04:42.681] - signal: TRUE
[16:04:42.681] - resignal: FALSE
[16:04:42.682] - force: TRUE
[16:04:42.682] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:42.682] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:42.682] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:42.682] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.682] signalConditionsASAP(NULL, pos=0) ... done
[16:04:42.682] resolve() on list ... DONE
[16:04:42.682] result() for ClusterFuture ...
[16:04:42.682] - result already collected: FutureResult
[16:04:42.682] result() for ClusterFuture ... done
[16:04:42.682] result() for ClusterFuture ...
[16:04:42.683] - result already collected: FutureResult
[16:04:42.683] result() for ClusterFuture ... done
[16:04:42.683] result() for ClusterFuture ...
[16:04:42.683] - result already collected: FutureResult
[16:04:42.683] result() for ClusterFuture ... done
[16:04:42.683] result() for ClusterFuture ...
[16:04:42.683] - result already collected: FutureResult
[16:04:42.683] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[16:04:42.685] getGlobalsAndPackages() ...
[16:04:42.685] Searching for globals...
[16:04:42.686] 
[16:04:42.686] Searching for globals ... DONE
[16:04:42.686] - globals: [0] <none>
[16:04:42.686] getGlobalsAndPackages() ... DONE
[16:04:42.686] run() for ‘Future’ ...
[16:04:42.686] - state: ‘created’
[16:04:42.686] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:42.700] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:42.700] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:42.700]   - Field: ‘node’
[16:04:42.700]   - Field: ‘label’
[16:04:42.700]   - Field: ‘local’
[16:04:42.700]   - Field: ‘owner’
[16:04:42.700]   - Field: ‘envir’
[16:04:42.701]   - Field: ‘workers’
[16:04:42.701]   - Field: ‘packages’
[16:04:42.701]   - Field: ‘gc’
[16:04:42.701]   - Field: ‘conditions’
[16:04:42.701]   - Field: ‘persistent’
[16:04:42.701]   - Field: ‘expr’
[16:04:42.701]   - Field: ‘uuid’
[16:04:42.701]   - Field: ‘seed’
[16:04:42.701]   - Field: ‘version’
[16:04:42.701]   - Field: ‘result’
[16:04:42.701]   - Field: ‘asynchronous’
[16:04:42.702]   - Field: ‘calls’
[16:04:42.702]   - Field: ‘globals’
[16:04:42.702]   - Field: ‘stdout’
[16:04:42.702]   - Field: ‘earlySignal’
[16:04:42.702]   - Field: ‘lazy’
[16:04:42.702]   - Field: ‘state’
[16:04:42.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:42.702] - Launch lazy future ...
[16:04:42.702] Packages needed by the future expression (n = 0): <none>
[16:04:42.703] Packages needed by future strategies (n = 0): <none>
[16:04:42.703] {
[16:04:42.703]     {
[16:04:42.703]         {
[16:04:42.703]             ...future.startTime <- base::Sys.time()
[16:04:42.703]             {
[16:04:42.703]                 {
[16:04:42.703]                   {
[16:04:42.703]                     {
[16:04:42.703]                       base::local({
[16:04:42.703]                         has_future <- base::requireNamespace("future", 
[16:04:42.703]                           quietly = TRUE)
[16:04:42.703]                         if (has_future) {
[16:04:42.703]                           ns <- base::getNamespace("future")
[16:04:42.703]                           version <- ns[[".package"]][["version"]]
[16:04:42.703]                           if (is.null(version)) 
[16:04:42.703]                             version <- utils::packageVersion("future")
[16:04:42.703]                         }
[16:04:42.703]                         else {
[16:04:42.703]                           version <- NULL
[16:04:42.703]                         }
[16:04:42.703]                         if (!has_future || version < "1.8.0") {
[16:04:42.703]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:42.703]                             "", base::R.version$version.string), 
[16:04:42.703]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:42.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:42.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:42.703]                               "release", "version")], collapse = " "), 
[16:04:42.703]                             hostname = base::Sys.info()[["nodename"]])
[16:04:42.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:42.703]                             info)
[16:04:42.703]                           info <- base::paste(info, collapse = "; ")
[16:04:42.703]                           if (!has_future) {
[16:04:42.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:42.703]                               info)
[16:04:42.703]                           }
[16:04:42.703]                           else {
[16:04:42.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:42.703]                               info, version)
[16:04:42.703]                           }
[16:04:42.703]                           base::stop(msg)
[16:04:42.703]                         }
[16:04:42.703]                       })
[16:04:42.703]                     }
[16:04:42.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:42.703]                     base::options(mc.cores = 1L)
[16:04:42.703]                   }
[16:04:42.703]                   options(future.plan = NULL)
[16:04:42.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:42.703]                 }
[16:04:42.703]                 ...future.workdir <- getwd()
[16:04:42.703]             }
[16:04:42.703]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:42.703]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:42.703]         }
[16:04:42.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:42.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:42.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:42.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:42.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:42.703]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:42.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:42.703]             base::names(...future.oldOptions))
[16:04:42.703]     }
[16:04:42.703]     if (FALSE) {
[16:04:42.703]     }
[16:04:42.703]     else {
[16:04:42.703]         if (TRUE) {
[16:04:42.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:42.703]                 open = "w")
[16:04:42.703]         }
[16:04:42.703]         else {
[16:04:42.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:42.703]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:42.703]         }
[16:04:42.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:42.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:42.703]             base::sink(type = "output", split = FALSE)
[16:04:42.703]             base::close(...future.stdout)
[16:04:42.703]         }, add = TRUE)
[16:04:42.703]     }
[16:04:42.703]     ...future.frame <- base::sys.nframe()
[16:04:42.703]     ...future.conditions <- base::list()
[16:04:42.703]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:42.703]     if (FALSE) {
[16:04:42.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:42.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:42.703]     }
[16:04:42.703]     ...future.result <- base::tryCatch({
[16:04:42.703]         base::withCallingHandlers({
[16:04:42.703]             ...future.value <- base::withVisible(base::local({
[16:04:42.703]                 ...future.makeSendCondition <- base::local({
[16:04:42.703]                   sendCondition <- NULL
[16:04:42.703]                   function(frame = 1L) {
[16:04:42.703]                     if (is.function(sendCondition)) 
[16:04:42.703]                       return(sendCondition)
[16:04:42.703]                     ns <- getNamespace("parallel")
[16:04:42.703]                     if (exists("sendData", mode = "function", 
[16:04:42.703]                       envir = ns)) {
[16:04:42.703]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:42.703]                         envir = ns)
[16:04:42.703]                       envir <- sys.frame(frame)
[16:04:42.703]                       master <- NULL
[16:04:42.703]                       while (!identical(envir, .GlobalEnv) && 
[16:04:42.703]                         !identical(envir, emptyenv())) {
[16:04:42.703]                         if (exists("master", mode = "list", envir = envir, 
[16:04:42.703]                           inherits = FALSE)) {
[16:04:42.703]                           master <- get("master", mode = "list", 
[16:04:42.703]                             envir = envir, inherits = FALSE)
[16:04:42.703]                           if (inherits(master, c("SOCKnode", 
[16:04:42.703]                             "SOCK0node"))) {
[16:04:42.703]                             sendCondition <<- function(cond) {
[16:04:42.703]                               data <- list(type = "VALUE", value = cond, 
[16:04:42.703]                                 success = TRUE)
[16:04:42.703]                               parallel_sendData(master, data)
[16:04:42.703]                             }
[16:04:42.703]                             return(sendCondition)
[16:04:42.703]                           }
[16:04:42.703]                         }
[16:04:42.703]                         frame <- frame + 1L
[16:04:42.703]                         envir <- sys.frame(frame)
[16:04:42.703]                       }
[16:04:42.703]                     }
[16:04:42.703]                     sendCondition <<- function(cond) NULL
[16:04:42.703]                   }
[16:04:42.703]                 })
[16:04:42.703]                 withCallingHandlers({
[16:04:42.703]                   2
[16:04:42.703]                 }, immediateCondition = function(cond) {
[16:04:42.703]                   sendCondition <- ...future.makeSendCondition()
[16:04:42.703]                   sendCondition(cond)
[16:04:42.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.703]                   {
[16:04:42.703]                     inherits <- base::inherits
[16:04:42.703]                     invokeRestart <- base::invokeRestart
[16:04:42.703]                     is.null <- base::is.null
[16:04:42.703]                     muffled <- FALSE
[16:04:42.703]                     if (inherits(cond, "message")) {
[16:04:42.703]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:42.703]                       if (muffled) 
[16:04:42.703]                         invokeRestart("muffleMessage")
[16:04:42.703]                     }
[16:04:42.703]                     else if (inherits(cond, "warning")) {
[16:04:42.703]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:42.703]                       if (muffled) 
[16:04:42.703]                         invokeRestart("muffleWarning")
[16:04:42.703]                     }
[16:04:42.703]                     else if (inherits(cond, "condition")) {
[16:04:42.703]                       if (!is.null(pattern)) {
[16:04:42.703]                         computeRestarts <- base::computeRestarts
[16:04:42.703]                         grepl <- base::grepl
[16:04:42.703]                         restarts <- computeRestarts(cond)
[16:04:42.703]                         for (restart in restarts) {
[16:04:42.703]                           name <- restart$name
[16:04:42.703]                           if (is.null(name)) 
[16:04:42.703]                             next
[16:04:42.703]                           if (!grepl(pattern, name)) 
[16:04:42.703]                             next
[16:04:42.703]                           invokeRestart(restart)
[16:04:42.703]                           muffled <- TRUE
[16:04:42.703]                           break
[16:04:42.703]                         }
[16:04:42.703]                       }
[16:04:42.703]                     }
[16:04:42.703]                     invisible(muffled)
[16:04:42.703]                   }
[16:04:42.703]                   muffleCondition(cond)
[16:04:42.703]                 })
[16:04:42.703]             }))
[16:04:42.703]             future::FutureResult(value = ...future.value$value, 
[16:04:42.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.703]                   ...future.rng), globalenv = if (FALSE) 
[16:04:42.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:42.703]                     ...future.globalenv.names))
[16:04:42.703]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:42.703]         }, condition = base::local({
[16:04:42.703]             c <- base::c
[16:04:42.703]             inherits <- base::inherits
[16:04:42.703]             invokeRestart <- base::invokeRestart
[16:04:42.703]             length <- base::length
[16:04:42.703]             list <- base::list
[16:04:42.703]             seq.int <- base::seq.int
[16:04:42.703]             signalCondition <- base::signalCondition
[16:04:42.703]             sys.calls <- base::sys.calls
[16:04:42.703]             `[[` <- base::`[[`
[16:04:42.703]             `+` <- base::`+`
[16:04:42.703]             `<<-` <- base::`<<-`
[16:04:42.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:42.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:42.703]                   3L)]
[16:04:42.703]             }
[16:04:42.703]             function(cond) {
[16:04:42.703]                 is_error <- inherits(cond, "error")
[16:04:42.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:42.703]                   NULL)
[16:04:42.703]                 if (is_error) {
[16:04:42.703]                   sessionInformation <- function() {
[16:04:42.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:42.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:42.703]                       search = base::search(), system = base::Sys.info())
[16:04:42.703]                   }
[16:04:42.703]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:42.703]                     cond$call), session = sessionInformation(), 
[16:04:42.703]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:42.703]                   signalCondition(cond)
[16:04:42.703]                 }
[16:04:42.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:42.703]                 "immediateCondition"))) {
[16:04:42.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:42.703]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:42.703]                   if (TRUE && !signal) {
[16:04:42.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.703]                     {
[16:04:42.703]                       inherits <- base::inherits
[16:04:42.703]                       invokeRestart <- base::invokeRestart
[16:04:42.703]                       is.null <- base::is.null
[16:04:42.703]                       muffled <- FALSE
[16:04:42.703]                       if (inherits(cond, "message")) {
[16:04:42.703]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.703]                         if (muffled) 
[16:04:42.703]                           invokeRestart("muffleMessage")
[16:04:42.703]                       }
[16:04:42.703]                       else if (inherits(cond, "warning")) {
[16:04:42.703]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.703]                         if (muffled) 
[16:04:42.703]                           invokeRestart("muffleWarning")
[16:04:42.703]                       }
[16:04:42.703]                       else if (inherits(cond, "condition")) {
[16:04:42.703]                         if (!is.null(pattern)) {
[16:04:42.703]                           computeRestarts <- base::computeRestarts
[16:04:42.703]                           grepl <- base::grepl
[16:04:42.703]                           restarts <- computeRestarts(cond)
[16:04:42.703]                           for (restart in restarts) {
[16:04:42.703]                             name <- restart$name
[16:04:42.703]                             if (is.null(name)) 
[16:04:42.703]                               next
[16:04:42.703]                             if (!grepl(pattern, name)) 
[16:04:42.703]                               next
[16:04:42.703]                             invokeRestart(restart)
[16:04:42.703]                             muffled <- TRUE
[16:04:42.703]                             break
[16:04:42.703]                           }
[16:04:42.703]                         }
[16:04:42.703]                       }
[16:04:42.703]                       invisible(muffled)
[16:04:42.703]                     }
[16:04:42.703]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.703]                   }
[16:04:42.703]                 }
[16:04:42.703]                 else {
[16:04:42.703]                   if (TRUE) {
[16:04:42.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.703]                     {
[16:04:42.703]                       inherits <- base::inherits
[16:04:42.703]                       invokeRestart <- base::invokeRestart
[16:04:42.703]                       is.null <- base::is.null
[16:04:42.703]                       muffled <- FALSE
[16:04:42.703]                       if (inherits(cond, "message")) {
[16:04:42.703]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.703]                         if (muffled) 
[16:04:42.703]                           invokeRestart("muffleMessage")
[16:04:42.703]                       }
[16:04:42.703]                       else if (inherits(cond, "warning")) {
[16:04:42.703]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.703]                         if (muffled) 
[16:04:42.703]                           invokeRestart("muffleWarning")
[16:04:42.703]                       }
[16:04:42.703]                       else if (inherits(cond, "condition")) {
[16:04:42.703]                         if (!is.null(pattern)) {
[16:04:42.703]                           computeRestarts <- base::computeRestarts
[16:04:42.703]                           grepl <- base::grepl
[16:04:42.703]                           restarts <- computeRestarts(cond)
[16:04:42.703]                           for (restart in restarts) {
[16:04:42.703]                             name <- restart$name
[16:04:42.703]                             if (is.null(name)) 
[16:04:42.703]                               next
[16:04:42.703]                             if (!grepl(pattern, name)) 
[16:04:42.703]                               next
[16:04:42.703]                             invokeRestart(restart)
[16:04:42.703]                             muffled <- TRUE
[16:04:42.703]                             break
[16:04:42.703]                           }
[16:04:42.703]                         }
[16:04:42.703]                       }
[16:04:42.703]                       invisible(muffled)
[16:04:42.703]                     }
[16:04:42.703]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.703]                   }
[16:04:42.703]                 }
[16:04:42.703]             }
[16:04:42.703]         }))
[16:04:42.703]     }, error = function(ex) {
[16:04:42.703]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:42.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.703]                 ...future.rng), started = ...future.startTime, 
[16:04:42.703]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:42.703]             version = "1.8"), class = "FutureResult")
[16:04:42.703]     }, finally = {
[16:04:42.703]         if (!identical(...future.workdir, getwd())) 
[16:04:42.703]             setwd(...future.workdir)
[16:04:42.703]         {
[16:04:42.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:42.703]                 ...future.oldOptions$nwarnings <- NULL
[16:04:42.703]             }
[16:04:42.703]             base::options(...future.oldOptions)
[16:04:42.703]             if (.Platform$OS.type == "windows") {
[16:04:42.703]                 old_names <- names(...future.oldEnvVars)
[16:04:42.703]                 envs <- base::Sys.getenv()
[16:04:42.703]                 names <- names(envs)
[16:04:42.703]                 common <- intersect(names, old_names)
[16:04:42.703]                 added <- setdiff(names, old_names)
[16:04:42.703]                 removed <- setdiff(old_names, names)
[16:04:42.703]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:42.703]                   envs[common]]
[16:04:42.703]                 NAMES <- toupper(changed)
[16:04:42.703]                 args <- list()
[16:04:42.703]                 for (kk in seq_along(NAMES)) {
[16:04:42.703]                   name <- changed[[kk]]
[16:04:42.703]                   NAME <- NAMES[[kk]]
[16:04:42.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.703]                     next
[16:04:42.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.703]                 }
[16:04:42.703]                 NAMES <- toupper(added)
[16:04:42.703]                 for (kk in seq_along(NAMES)) {
[16:04:42.703]                   name <- added[[kk]]
[16:04:42.703]                   NAME <- NAMES[[kk]]
[16:04:42.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.703]                     next
[16:04:42.703]                   args[[name]] <- ""
[16:04:42.703]                 }
[16:04:42.703]                 NAMES <- toupper(removed)
[16:04:42.703]                 for (kk in seq_along(NAMES)) {
[16:04:42.703]                   name <- removed[[kk]]
[16:04:42.703]                   NAME <- NAMES[[kk]]
[16:04:42.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.703]                     next
[16:04:42.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.703]                 }
[16:04:42.703]                 if (length(args) > 0) 
[16:04:42.703]                   base::do.call(base::Sys.setenv, args = args)
[16:04:42.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:42.703]             }
[16:04:42.703]             else {
[16:04:42.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:42.703]             }
[16:04:42.703]             {
[16:04:42.703]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:42.703]                   0L) {
[16:04:42.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:42.703]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:42.703]                   base::options(opts)
[16:04:42.703]                 }
[16:04:42.703]                 {
[16:04:42.703]                   {
[16:04:42.703]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:42.703]                     NULL
[16:04:42.703]                   }
[16:04:42.703]                   options(future.plan = NULL)
[16:04:42.703]                   if (is.na(NA_character_)) 
[16:04:42.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:42.703]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:42.703]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:42.703]                     envir = parent.frame()) 
[16:04:42.703]                   {
[16:04:42.703]                     if (is.function(workers)) 
[16:04:42.703]                       workers <- workers()
[16:04:42.703]                     workers <- structure(as.integer(workers), 
[16:04:42.703]                       class = class(workers))
[16:04:42.703]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:42.703]                       workers >= 1)
[16:04:42.703]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:42.703]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:42.703]                     }
[16:04:42.703]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:42.703]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:42.703]                       envir = envir)
[16:04:42.703]                     if (!future$lazy) 
[16:04:42.703]                       future <- run(future)
[16:04:42.703]                     invisible(future)
[16:04:42.703]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:42.703]                 }
[16:04:42.703]             }
[16:04:42.703]         }
[16:04:42.703]     })
[16:04:42.703]     if (TRUE) {
[16:04:42.703]         base::sink(type = "output", split = FALSE)
[16:04:42.703]         if (TRUE) {
[16:04:42.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:42.703]         }
[16:04:42.703]         else {
[16:04:42.703]             ...future.result["stdout"] <- base::list(NULL)
[16:04:42.703]         }
[16:04:42.703]         base::close(...future.stdout)
[16:04:42.703]         ...future.stdout <- NULL
[16:04:42.703]     }
[16:04:42.703]     ...future.result$conditions <- ...future.conditions
[16:04:42.703]     ...future.result$finished <- base::Sys.time()
[16:04:42.703]     ...future.result
[16:04:42.703] }
[16:04:42.706] MultisessionFuture started
[16:04:42.706] - Launch lazy future ... done
[16:04:42.706] run() for ‘MultisessionFuture’ ... done
[16:04:42.707] getGlobalsAndPackages() ...
[16:04:42.707] Searching for globals...
[16:04:42.707] 
[16:04:42.707] Searching for globals ... DONE
[16:04:42.707] - globals: [0] <none>
[16:04:42.707] getGlobalsAndPackages() ... DONE
[16:04:42.708] run() for ‘Future’ ...
[16:04:42.708] - state: ‘created’
[16:04:42.708] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:42.721] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:42.721] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:42.721]   - Field: ‘node’
[16:04:42.721]   - Field: ‘label’
[16:04:42.722]   - Field: ‘local’
[16:04:42.722]   - Field: ‘owner’
[16:04:42.722]   - Field: ‘envir’
[16:04:42.722]   - Field: ‘workers’
[16:04:42.722]   - Field: ‘packages’
[16:04:42.722]   - Field: ‘gc’
[16:04:42.722]   - Field: ‘conditions’
[16:04:42.722]   - Field: ‘persistent’
[16:04:42.722]   - Field: ‘expr’
[16:04:42.722]   - Field: ‘uuid’
[16:04:42.722]   - Field: ‘seed’
[16:04:42.723]   - Field: ‘version’
[16:04:42.723]   - Field: ‘result’
[16:04:42.723]   - Field: ‘asynchronous’
[16:04:42.723]   - Field: ‘calls’
[16:04:42.723]   - Field: ‘globals’
[16:04:42.723]   - Field: ‘stdout’
[16:04:42.723]   - Field: ‘earlySignal’
[16:04:42.723]   - Field: ‘lazy’
[16:04:42.723]   - Field: ‘state’
[16:04:42.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:42.724] - Launch lazy future ...
[16:04:42.724] Packages needed by the future expression (n = 0): <none>
[16:04:42.724] Packages needed by future strategies (n = 0): <none>
[16:04:42.724] {
[16:04:42.724]     {
[16:04:42.724]         {
[16:04:42.724]             ...future.startTime <- base::Sys.time()
[16:04:42.724]             {
[16:04:42.724]                 {
[16:04:42.724]                   {
[16:04:42.724]                     {
[16:04:42.724]                       base::local({
[16:04:42.724]                         has_future <- base::requireNamespace("future", 
[16:04:42.724]                           quietly = TRUE)
[16:04:42.724]                         if (has_future) {
[16:04:42.724]                           ns <- base::getNamespace("future")
[16:04:42.724]                           version <- ns[[".package"]][["version"]]
[16:04:42.724]                           if (is.null(version)) 
[16:04:42.724]                             version <- utils::packageVersion("future")
[16:04:42.724]                         }
[16:04:42.724]                         else {
[16:04:42.724]                           version <- NULL
[16:04:42.724]                         }
[16:04:42.724]                         if (!has_future || version < "1.8.0") {
[16:04:42.724]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:42.724]                             "", base::R.version$version.string), 
[16:04:42.724]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:42.724]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:42.724]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:42.724]                               "release", "version")], collapse = " "), 
[16:04:42.724]                             hostname = base::Sys.info()[["nodename"]])
[16:04:42.724]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:42.724]                             info)
[16:04:42.724]                           info <- base::paste(info, collapse = "; ")
[16:04:42.724]                           if (!has_future) {
[16:04:42.724]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:42.724]                               info)
[16:04:42.724]                           }
[16:04:42.724]                           else {
[16:04:42.724]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:42.724]                               info, version)
[16:04:42.724]                           }
[16:04:42.724]                           base::stop(msg)
[16:04:42.724]                         }
[16:04:42.724]                       })
[16:04:42.724]                     }
[16:04:42.724]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:42.724]                     base::options(mc.cores = 1L)
[16:04:42.724]                   }
[16:04:42.724]                   options(future.plan = NULL)
[16:04:42.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:42.724]                 }
[16:04:42.724]                 ...future.workdir <- getwd()
[16:04:42.724]             }
[16:04:42.724]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:42.724]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:42.724]         }
[16:04:42.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:42.724]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:42.724]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:42.724]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:42.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:42.724]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:42.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:42.724]             base::names(...future.oldOptions))
[16:04:42.724]     }
[16:04:42.724]     if (FALSE) {
[16:04:42.724]     }
[16:04:42.724]     else {
[16:04:42.724]         if (TRUE) {
[16:04:42.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:42.724]                 open = "w")
[16:04:42.724]         }
[16:04:42.724]         else {
[16:04:42.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:42.724]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:42.724]         }
[16:04:42.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:42.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:42.724]             base::sink(type = "output", split = FALSE)
[16:04:42.724]             base::close(...future.stdout)
[16:04:42.724]         }, add = TRUE)
[16:04:42.724]     }
[16:04:42.724]     ...future.frame <- base::sys.nframe()
[16:04:42.724]     ...future.conditions <- base::list()
[16:04:42.724]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:42.724]     if (FALSE) {
[16:04:42.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:42.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:42.724]     }
[16:04:42.724]     ...future.result <- base::tryCatch({
[16:04:42.724]         base::withCallingHandlers({
[16:04:42.724]             ...future.value <- base::withVisible(base::local({
[16:04:42.724]                 ...future.makeSendCondition <- base::local({
[16:04:42.724]                   sendCondition <- NULL
[16:04:42.724]                   function(frame = 1L) {
[16:04:42.724]                     if (is.function(sendCondition)) 
[16:04:42.724]                       return(sendCondition)
[16:04:42.724]                     ns <- getNamespace("parallel")
[16:04:42.724]                     if (exists("sendData", mode = "function", 
[16:04:42.724]                       envir = ns)) {
[16:04:42.724]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:42.724]                         envir = ns)
[16:04:42.724]                       envir <- sys.frame(frame)
[16:04:42.724]                       master <- NULL
[16:04:42.724]                       while (!identical(envir, .GlobalEnv) && 
[16:04:42.724]                         !identical(envir, emptyenv())) {
[16:04:42.724]                         if (exists("master", mode = "list", envir = envir, 
[16:04:42.724]                           inherits = FALSE)) {
[16:04:42.724]                           master <- get("master", mode = "list", 
[16:04:42.724]                             envir = envir, inherits = FALSE)
[16:04:42.724]                           if (inherits(master, c("SOCKnode", 
[16:04:42.724]                             "SOCK0node"))) {
[16:04:42.724]                             sendCondition <<- function(cond) {
[16:04:42.724]                               data <- list(type = "VALUE", value = cond, 
[16:04:42.724]                                 success = TRUE)
[16:04:42.724]                               parallel_sendData(master, data)
[16:04:42.724]                             }
[16:04:42.724]                             return(sendCondition)
[16:04:42.724]                           }
[16:04:42.724]                         }
[16:04:42.724]                         frame <- frame + 1L
[16:04:42.724]                         envir <- sys.frame(frame)
[16:04:42.724]                       }
[16:04:42.724]                     }
[16:04:42.724]                     sendCondition <<- function(cond) NULL
[16:04:42.724]                   }
[16:04:42.724]                 })
[16:04:42.724]                 withCallingHandlers({
[16:04:42.724]                   NULL
[16:04:42.724]                 }, immediateCondition = function(cond) {
[16:04:42.724]                   sendCondition <- ...future.makeSendCondition()
[16:04:42.724]                   sendCondition(cond)
[16:04:42.724]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.724]                   {
[16:04:42.724]                     inherits <- base::inherits
[16:04:42.724]                     invokeRestart <- base::invokeRestart
[16:04:42.724]                     is.null <- base::is.null
[16:04:42.724]                     muffled <- FALSE
[16:04:42.724]                     if (inherits(cond, "message")) {
[16:04:42.724]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:42.724]                       if (muffled) 
[16:04:42.724]                         invokeRestart("muffleMessage")
[16:04:42.724]                     }
[16:04:42.724]                     else if (inherits(cond, "warning")) {
[16:04:42.724]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:42.724]                       if (muffled) 
[16:04:42.724]                         invokeRestart("muffleWarning")
[16:04:42.724]                     }
[16:04:42.724]                     else if (inherits(cond, "condition")) {
[16:04:42.724]                       if (!is.null(pattern)) {
[16:04:42.724]                         computeRestarts <- base::computeRestarts
[16:04:42.724]                         grepl <- base::grepl
[16:04:42.724]                         restarts <- computeRestarts(cond)
[16:04:42.724]                         for (restart in restarts) {
[16:04:42.724]                           name <- restart$name
[16:04:42.724]                           if (is.null(name)) 
[16:04:42.724]                             next
[16:04:42.724]                           if (!grepl(pattern, name)) 
[16:04:42.724]                             next
[16:04:42.724]                           invokeRestart(restart)
[16:04:42.724]                           muffled <- TRUE
[16:04:42.724]                           break
[16:04:42.724]                         }
[16:04:42.724]                       }
[16:04:42.724]                     }
[16:04:42.724]                     invisible(muffled)
[16:04:42.724]                   }
[16:04:42.724]                   muffleCondition(cond)
[16:04:42.724]                 })
[16:04:42.724]             }))
[16:04:42.724]             future::FutureResult(value = ...future.value$value, 
[16:04:42.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.724]                   ...future.rng), globalenv = if (FALSE) 
[16:04:42.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:42.724]                     ...future.globalenv.names))
[16:04:42.724]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:42.724]         }, condition = base::local({
[16:04:42.724]             c <- base::c
[16:04:42.724]             inherits <- base::inherits
[16:04:42.724]             invokeRestart <- base::invokeRestart
[16:04:42.724]             length <- base::length
[16:04:42.724]             list <- base::list
[16:04:42.724]             seq.int <- base::seq.int
[16:04:42.724]             signalCondition <- base::signalCondition
[16:04:42.724]             sys.calls <- base::sys.calls
[16:04:42.724]             `[[` <- base::`[[`
[16:04:42.724]             `+` <- base::`+`
[16:04:42.724]             `<<-` <- base::`<<-`
[16:04:42.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:42.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:42.724]                   3L)]
[16:04:42.724]             }
[16:04:42.724]             function(cond) {
[16:04:42.724]                 is_error <- inherits(cond, "error")
[16:04:42.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:42.724]                   NULL)
[16:04:42.724]                 if (is_error) {
[16:04:42.724]                   sessionInformation <- function() {
[16:04:42.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:42.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:42.724]                       search = base::search(), system = base::Sys.info())
[16:04:42.724]                   }
[16:04:42.724]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:42.724]                     cond$call), session = sessionInformation(), 
[16:04:42.724]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:42.724]                   signalCondition(cond)
[16:04:42.724]                 }
[16:04:42.724]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:42.724]                 "immediateCondition"))) {
[16:04:42.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:42.724]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:42.724]                   if (TRUE && !signal) {
[16:04:42.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.724]                     {
[16:04:42.724]                       inherits <- base::inherits
[16:04:42.724]                       invokeRestart <- base::invokeRestart
[16:04:42.724]                       is.null <- base::is.null
[16:04:42.724]                       muffled <- FALSE
[16:04:42.724]                       if (inherits(cond, "message")) {
[16:04:42.724]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.724]                         if (muffled) 
[16:04:42.724]                           invokeRestart("muffleMessage")
[16:04:42.724]                       }
[16:04:42.724]                       else if (inherits(cond, "warning")) {
[16:04:42.724]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.724]                         if (muffled) 
[16:04:42.724]                           invokeRestart("muffleWarning")
[16:04:42.724]                       }
[16:04:42.724]                       else if (inherits(cond, "condition")) {
[16:04:42.724]                         if (!is.null(pattern)) {
[16:04:42.724]                           computeRestarts <- base::computeRestarts
[16:04:42.724]                           grepl <- base::grepl
[16:04:42.724]                           restarts <- computeRestarts(cond)
[16:04:42.724]                           for (restart in restarts) {
[16:04:42.724]                             name <- restart$name
[16:04:42.724]                             if (is.null(name)) 
[16:04:42.724]                               next
[16:04:42.724]                             if (!grepl(pattern, name)) 
[16:04:42.724]                               next
[16:04:42.724]                             invokeRestart(restart)
[16:04:42.724]                             muffled <- TRUE
[16:04:42.724]                             break
[16:04:42.724]                           }
[16:04:42.724]                         }
[16:04:42.724]                       }
[16:04:42.724]                       invisible(muffled)
[16:04:42.724]                     }
[16:04:42.724]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.724]                   }
[16:04:42.724]                 }
[16:04:42.724]                 else {
[16:04:42.724]                   if (TRUE) {
[16:04:42.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.724]                     {
[16:04:42.724]                       inherits <- base::inherits
[16:04:42.724]                       invokeRestart <- base::invokeRestart
[16:04:42.724]                       is.null <- base::is.null
[16:04:42.724]                       muffled <- FALSE
[16:04:42.724]                       if (inherits(cond, "message")) {
[16:04:42.724]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.724]                         if (muffled) 
[16:04:42.724]                           invokeRestart("muffleMessage")
[16:04:42.724]                       }
[16:04:42.724]                       else if (inherits(cond, "warning")) {
[16:04:42.724]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.724]                         if (muffled) 
[16:04:42.724]                           invokeRestart("muffleWarning")
[16:04:42.724]                       }
[16:04:42.724]                       else if (inherits(cond, "condition")) {
[16:04:42.724]                         if (!is.null(pattern)) {
[16:04:42.724]                           computeRestarts <- base::computeRestarts
[16:04:42.724]                           grepl <- base::grepl
[16:04:42.724]                           restarts <- computeRestarts(cond)
[16:04:42.724]                           for (restart in restarts) {
[16:04:42.724]                             name <- restart$name
[16:04:42.724]                             if (is.null(name)) 
[16:04:42.724]                               next
[16:04:42.724]                             if (!grepl(pattern, name)) 
[16:04:42.724]                               next
[16:04:42.724]                             invokeRestart(restart)
[16:04:42.724]                             muffled <- TRUE
[16:04:42.724]                             break
[16:04:42.724]                           }
[16:04:42.724]                         }
[16:04:42.724]                       }
[16:04:42.724]                       invisible(muffled)
[16:04:42.724]                     }
[16:04:42.724]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.724]                   }
[16:04:42.724]                 }
[16:04:42.724]             }
[16:04:42.724]         }))
[16:04:42.724]     }, error = function(ex) {
[16:04:42.724]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:42.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.724]                 ...future.rng), started = ...future.startTime, 
[16:04:42.724]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:42.724]             version = "1.8"), class = "FutureResult")
[16:04:42.724]     }, finally = {
[16:04:42.724]         if (!identical(...future.workdir, getwd())) 
[16:04:42.724]             setwd(...future.workdir)
[16:04:42.724]         {
[16:04:42.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:42.724]                 ...future.oldOptions$nwarnings <- NULL
[16:04:42.724]             }
[16:04:42.724]             base::options(...future.oldOptions)
[16:04:42.724]             if (.Platform$OS.type == "windows") {
[16:04:42.724]                 old_names <- names(...future.oldEnvVars)
[16:04:42.724]                 envs <- base::Sys.getenv()
[16:04:42.724]                 names <- names(envs)
[16:04:42.724]                 common <- intersect(names, old_names)
[16:04:42.724]                 added <- setdiff(names, old_names)
[16:04:42.724]                 removed <- setdiff(old_names, names)
[16:04:42.724]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:42.724]                   envs[common]]
[16:04:42.724]                 NAMES <- toupper(changed)
[16:04:42.724]                 args <- list()
[16:04:42.724]                 for (kk in seq_along(NAMES)) {
[16:04:42.724]                   name <- changed[[kk]]
[16:04:42.724]                   NAME <- NAMES[[kk]]
[16:04:42.724]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.724]                     next
[16:04:42.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.724]                 }
[16:04:42.724]                 NAMES <- toupper(added)
[16:04:42.724]                 for (kk in seq_along(NAMES)) {
[16:04:42.724]                   name <- added[[kk]]
[16:04:42.724]                   NAME <- NAMES[[kk]]
[16:04:42.724]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.724]                     next
[16:04:42.724]                   args[[name]] <- ""
[16:04:42.724]                 }
[16:04:42.724]                 NAMES <- toupper(removed)
[16:04:42.724]                 for (kk in seq_along(NAMES)) {
[16:04:42.724]                   name <- removed[[kk]]
[16:04:42.724]                   NAME <- NAMES[[kk]]
[16:04:42.724]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.724]                     next
[16:04:42.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.724]                 }
[16:04:42.724]                 if (length(args) > 0) 
[16:04:42.724]                   base::do.call(base::Sys.setenv, args = args)
[16:04:42.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:42.724]             }
[16:04:42.724]             else {
[16:04:42.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:42.724]             }
[16:04:42.724]             {
[16:04:42.724]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:42.724]                   0L) {
[16:04:42.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:42.724]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:42.724]                   base::options(opts)
[16:04:42.724]                 }
[16:04:42.724]                 {
[16:04:42.724]                   {
[16:04:42.724]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:42.724]                     NULL
[16:04:42.724]                   }
[16:04:42.724]                   options(future.plan = NULL)
[16:04:42.724]                   if (is.na(NA_character_)) 
[16:04:42.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:42.724]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:42.724]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:42.724]                     envir = parent.frame()) 
[16:04:42.724]                   {
[16:04:42.724]                     if (is.function(workers)) 
[16:04:42.724]                       workers <- workers()
[16:04:42.724]                     workers <- structure(as.integer(workers), 
[16:04:42.724]                       class = class(workers))
[16:04:42.724]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:42.724]                       workers >= 1)
[16:04:42.724]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:42.724]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:42.724]                     }
[16:04:42.724]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:42.724]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:42.724]                       envir = envir)
[16:04:42.724]                     if (!future$lazy) 
[16:04:42.724]                       future <- run(future)
[16:04:42.724]                     invisible(future)
[16:04:42.724]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:42.724]                 }
[16:04:42.724]             }
[16:04:42.724]         }
[16:04:42.724]     })
[16:04:42.724]     if (TRUE) {
[16:04:42.724]         base::sink(type = "output", split = FALSE)
[16:04:42.724]         if (TRUE) {
[16:04:42.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:42.724]         }
[16:04:42.724]         else {
[16:04:42.724]             ...future.result["stdout"] <- base::list(NULL)
[16:04:42.724]         }
[16:04:42.724]         base::close(...future.stdout)
[16:04:42.724]         ...future.stdout <- NULL
[16:04:42.724]     }
[16:04:42.724]     ...future.result$conditions <- ...future.conditions
[16:04:42.724]     ...future.result$finished <- base::Sys.time()
[16:04:42.724]     ...future.result
[16:04:42.724] }
[16:04:42.727] MultisessionFuture started
[16:04:42.727] - Launch lazy future ... done
[16:04:42.727] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874dfd7aa8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874d9df5e0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874dfd7aa8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874d9df5e0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:42.755] resolve() on list ...
[16:04:42.755]  recursive: 0
[16:04:42.755]  length: 6
[16:04:42.755]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:42.755] signalConditionsASAP(numeric, pos=1) ...
[16:04:42.755] - nx: 6
[16:04:42.755] - relay: TRUE
[16:04:42.756] - stdout: TRUE
[16:04:42.756] - signal: TRUE
[16:04:42.756] - resignal: FALSE
[16:04:42.756] - force: TRUE
[16:04:42.756] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.756] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.756]  - until=2
[16:04:42.756]  - relaying element #2
[16:04:42.756] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.756] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.756] signalConditionsASAP(NULL, pos=1) ... done
[16:04:42.757]  length: 5 (resolved future 1)
[16:04:42.757] receiveMessageFromWorker() for ClusterFuture ...
[16:04:42.757] - Validating connection of MultisessionFuture
[16:04:42.757] - received message: FutureResult
[16:04:42.757] - Received FutureResult
[16:04:42.757] - Erased future from FutureRegistry
[16:04:42.758] result() for ClusterFuture ...
[16:04:42.758] - result already collected: FutureResult
[16:04:42.758] result() for ClusterFuture ... done
[16:04:42.758] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:42.758] Future #2
[16:04:42.758] result() for ClusterFuture ...
[16:04:42.758] - result already collected: FutureResult
[16:04:42.758] result() for ClusterFuture ... done
[16:04:42.758] result() for ClusterFuture ...
[16:04:42.758] - result already collected: FutureResult
[16:04:42.758] result() for ClusterFuture ... done
[16:04:42.759] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:42.759] - nx: 6
[16:04:42.759] - relay: TRUE
[16:04:42.759] - stdout: TRUE
[16:04:42.759] - signal: TRUE
[16:04:42.759] - resignal: FALSE
[16:04:42.759] - force: TRUE
[16:04:42.759] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.759] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.759]  - until=2
[16:04:42.759]  - relaying element #2
[16:04:42.760] result() for ClusterFuture ...
[16:04:42.760] - result already collected: FutureResult
[16:04:42.760] result() for ClusterFuture ... done
[16:04:42.760] result() for ClusterFuture ...
[16:04:42.760] - result already collected: FutureResult
[16:04:42.760] result() for ClusterFuture ... done
[16:04:42.760] result() for ClusterFuture ...
[16:04:42.760] - result already collected: FutureResult
[16:04:42.760] result() for ClusterFuture ... done
[16:04:42.760] result() for ClusterFuture ...
[16:04:42.760] - result already collected: FutureResult
[16:04:42.761] result() for ClusterFuture ... done
[16:04:42.761] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.761] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.761] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:42.761]  length: 4 (resolved future 2)
[16:04:42.771] signalConditionsASAP(NULL, pos=4) ...
[16:04:42.772] - nx: 6
[16:04:42.772] - relay: TRUE
[16:04:42.772] - stdout: TRUE
[16:04:42.772] - signal: TRUE
[16:04:42.772] - resignal: FALSE
[16:04:42.772] - force: TRUE
[16:04:42.772] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.772] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.772]  - until=5
[16:04:42.772]  - relaying element #3
[16:04:42.772]  - relaying element #5
[16:04:42.772] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:04:42.773] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.773] signalConditionsASAP(NULL, pos=4) ... done
[16:04:42.773]  length: 3 (resolved future 4)
[16:04:42.773] signalConditionsASAP(NULL, pos=5) ...
[16:04:42.773] - nx: 6
[16:04:42.773] - relay: TRUE
[16:04:42.773] - stdout: TRUE
[16:04:42.773] - signal: TRUE
[16:04:42.773] - resignal: FALSE
[16:04:42.773] - force: TRUE
[16:04:42.773] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:04:42.773] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.774]  - until=6
[16:04:42.774]  - relaying element #3
[16:04:42.774]  - relaying element #6
[16:04:42.774] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:04:42.774] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.774] signalConditionsASAP(NULL, pos=5) ... done
[16:04:42.774]  length: 2 (resolved future 5)
[16:04:42.774] signalConditionsASAP(numeric, pos=6) ...
[16:04:42.774] - nx: 6
[16:04:42.774] - relay: TRUE
[16:04:42.774] - stdout: TRUE
[16:04:42.775] - signal: TRUE
[16:04:42.775] - resignal: FALSE
[16:04:42.775] - force: TRUE
[16:04:42.775] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:04:42.775] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.775]  - until=6
[16:04:42.775]  - relaying element #3
[16:04:42.775] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:04:42.775] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.775] signalConditionsASAP(NULL, pos=6) ... done
[16:04:42.775]  length: 1 (resolved future 6)
[16:04:42.786] receiveMessageFromWorker() for ClusterFuture ...
[16:04:42.786] - Validating connection of MultisessionFuture
[16:04:42.786] - received message: FutureResult
[16:04:42.786] - Received FutureResult
[16:04:42.787] - Erased future from FutureRegistry
[16:04:42.787] result() for ClusterFuture ...
[16:04:42.787] - result already collected: FutureResult
[16:04:42.787] result() for ClusterFuture ... done
[16:04:42.787] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:42.787] Future #3
[16:04:42.787] result() for ClusterFuture ...
[16:04:42.787] - result already collected: FutureResult
[16:04:42.787] result() for ClusterFuture ... done
[16:04:42.787] result() for ClusterFuture ...
[16:04:42.788] - result already collected: FutureResult
[16:04:42.788] result() for ClusterFuture ... done
[16:04:42.788] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:42.788] - nx: 6
[16:04:42.788] - relay: TRUE
[16:04:42.788] - stdout: TRUE
[16:04:42.788] - signal: TRUE
[16:04:42.788] - resignal: FALSE
[16:04:42.788] - force: TRUE
[16:04:42.788] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:04:42.788] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.788]  - until=6
[16:04:42.789]  - relaying element #3
[16:04:42.789] result() for ClusterFuture ...
[16:04:42.789] - result already collected: FutureResult
[16:04:42.789] result() for ClusterFuture ... done
[16:04:42.789] result() for ClusterFuture ...
[16:04:42.789] - result already collected: FutureResult
[16:04:42.789] result() for ClusterFuture ... done
[16:04:42.789] result() for ClusterFuture ...
[16:04:42.789] - result already collected: FutureResult
[16:04:42.789] result() for ClusterFuture ... done
[16:04:42.789] result() for ClusterFuture ...
[16:04:42.789] - result already collected: FutureResult
[16:04:42.790] result() for ClusterFuture ... done
[16:04:42.790] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:42.790] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.790] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:42.790]  length: 0 (resolved future 3)
[16:04:42.790] Relaying remaining futures
[16:04:42.790] signalConditionsASAP(NULL, pos=0) ...
[16:04:42.790] - nx: 6
[16:04:42.790] - relay: TRUE
[16:04:42.790] - stdout: TRUE
[16:04:42.790] - signal: TRUE
[16:04:42.790] - resignal: FALSE
[16:04:42.791] - force: TRUE
[16:04:42.791] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:42.791] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:42.791] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:42.791] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.791] signalConditionsASAP(NULL, pos=0) ... done
[16:04:42.791] resolve() on list ... DONE
[16:04:42.791] result() for ClusterFuture ...
[16:04:42.791] - result already collected: FutureResult
[16:04:42.791] result() for ClusterFuture ... done
[16:04:42.792] result() for ClusterFuture ...
[16:04:42.792] - result already collected: FutureResult
[16:04:42.792] result() for ClusterFuture ... done
[16:04:42.792] result() for ClusterFuture ...
[16:04:42.792] - result already collected: FutureResult
[16:04:42.792] result() for ClusterFuture ... done
[16:04:42.792] result() for ClusterFuture ...
[16:04:42.792] - result already collected: FutureResult
[16:04:42.792] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:04:42.795] getGlobalsAndPackages() ...
[16:04:42.796] Searching for globals...
[16:04:42.796] 
[16:04:42.796] Searching for globals ... DONE
[16:04:42.796] - globals: [0] <none>
[16:04:42.796] getGlobalsAndPackages() ... DONE
[16:04:42.796] run() for ‘Future’ ...
[16:04:42.796] - state: ‘created’
[16:04:42.797] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:42.810] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:42.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:42.810]   - Field: ‘node’
[16:04:42.811]   - Field: ‘label’
[16:04:42.811]   - Field: ‘local’
[16:04:42.811]   - Field: ‘owner’
[16:04:42.811]   - Field: ‘envir’
[16:04:42.811]   - Field: ‘workers’
[16:04:42.811]   - Field: ‘packages’
[16:04:42.811]   - Field: ‘gc’
[16:04:42.811]   - Field: ‘conditions’
[16:04:42.811]   - Field: ‘persistent’
[16:04:42.811]   - Field: ‘expr’
[16:04:42.812]   - Field: ‘uuid’
[16:04:42.812]   - Field: ‘seed’
[16:04:42.812]   - Field: ‘version’
[16:04:42.812]   - Field: ‘result’
[16:04:42.812]   - Field: ‘asynchronous’
[16:04:42.812]   - Field: ‘calls’
[16:04:42.812]   - Field: ‘globals’
[16:04:42.812]   - Field: ‘stdout’
[16:04:42.812]   - Field: ‘earlySignal’
[16:04:42.812]   - Field: ‘lazy’
[16:04:42.812]   - Field: ‘state’
[16:04:42.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:42.813] - Launch lazy future ...
[16:04:42.813] Packages needed by the future expression (n = 0): <none>
[16:04:42.813] Packages needed by future strategies (n = 0): <none>
[16:04:42.813] {
[16:04:42.813]     {
[16:04:42.813]         {
[16:04:42.813]             ...future.startTime <- base::Sys.time()
[16:04:42.813]             {
[16:04:42.813]                 {
[16:04:42.813]                   {
[16:04:42.813]                     {
[16:04:42.813]                       base::local({
[16:04:42.813]                         has_future <- base::requireNamespace("future", 
[16:04:42.813]                           quietly = TRUE)
[16:04:42.813]                         if (has_future) {
[16:04:42.813]                           ns <- base::getNamespace("future")
[16:04:42.813]                           version <- ns[[".package"]][["version"]]
[16:04:42.813]                           if (is.null(version)) 
[16:04:42.813]                             version <- utils::packageVersion("future")
[16:04:42.813]                         }
[16:04:42.813]                         else {
[16:04:42.813]                           version <- NULL
[16:04:42.813]                         }
[16:04:42.813]                         if (!has_future || version < "1.8.0") {
[16:04:42.813]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:42.813]                             "", base::R.version$version.string), 
[16:04:42.813]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:42.813]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:42.813]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:42.813]                               "release", "version")], collapse = " "), 
[16:04:42.813]                             hostname = base::Sys.info()[["nodename"]])
[16:04:42.813]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:42.813]                             info)
[16:04:42.813]                           info <- base::paste(info, collapse = "; ")
[16:04:42.813]                           if (!has_future) {
[16:04:42.813]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:42.813]                               info)
[16:04:42.813]                           }
[16:04:42.813]                           else {
[16:04:42.813]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:42.813]                               info, version)
[16:04:42.813]                           }
[16:04:42.813]                           base::stop(msg)
[16:04:42.813]                         }
[16:04:42.813]                       })
[16:04:42.813]                     }
[16:04:42.813]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:42.813]                     base::options(mc.cores = 1L)
[16:04:42.813]                   }
[16:04:42.813]                   options(future.plan = NULL)
[16:04:42.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:42.813]                 }
[16:04:42.813]                 ...future.workdir <- getwd()
[16:04:42.813]             }
[16:04:42.813]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:42.813]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:42.813]         }
[16:04:42.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:42.813]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:42.813]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:42.813]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:42.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:42.813]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:42.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:42.813]             base::names(...future.oldOptions))
[16:04:42.813]     }
[16:04:42.813]     if (FALSE) {
[16:04:42.813]     }
[16:04:42.813]     else {
[16:04:42.813]         if (TRUE) {
[16:04:42.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:42.813]                 open = "w")
[16:04:42.813]         }
[16:04:42.813]         else {
[16:04:42.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:42.813]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:42.813]         }
[16:04:42.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:42.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:42.813]             base::sink(type = "output", split = FALSE)
[16:04:42.813]             base::close(...future.stdout)
[16:04:42.813]         }, add = TRUE)
[16:04:42.813]     }
[16:04:42.813]     ...future.frame <- base::sys.nframe()
[16:04:42.813]     ...future.conditions <- base::list()
[16:04:42.813]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:42.813]     if (FALSE) {
[16:04:42.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:42.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:42.813]     }
[16:04:42.813]     ...future.result <- base::tryCatch({
[16:04:42.813]         base::withCallingHandlers({
[16:04:42.813]             ...future.value <- base::withVisible(base::local({
[16:04:42.813]                 ...future.makeSendCondition <- base::local({
[16:04:42.813]                   sendCondition <- NULL
[16:04:42.813]                   function(frame = 1L) {
[16:04:42.813]                     if (is.function(sendCondition)) 
[16:04:42.813]                       return(sendCondition)
[16:04:42.813]                     ns <- getNamespace("parallel")
[16:04:42.813]                     if (exists("sendData", mode = "function", 
[16:04:42.813]                       envir = ns)) {
[16:04:42.813]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:42.813]                         envir = ns)
[16:04:42.813]                       envir <- sys.frame(frame)
[16:04:42.813]                       master <- NULL
[16:04:42.813]                       while (!identical(envir, .GlobalEnv) && 
[16:04:42.813]                         !identical(envir, emptyenv())) {
[16:04:42.813]                         if (exists("master", mode = "list", envir = envir, 
[16:04:42.813]                           inherits = FALSE)) {
[16:04:42.813]                           master <- get("master", mode = "list", 
[16:04:42.813]                             envir = envir, inherits = FALSE)
[16:04:42.813]                           if (inherits(master, c("SOCKnode", 
[16:04:42.813]                             "SOCK0node"))) {
[16:04:42.813]                             sendCondition <<- function(cond) {
[16:04:42.813]                               data <- list(type = "VALUE", value = cond, 
[16:04:42.813]                                 success = TRUE)
[16:04:42.813]                               parallel_sendData(master, data)
[16:04:42.813]                             }
[16:04:42.813]                             return(sendCondition)
[16:04:42.813]                           }
[16:04:42.813]                         }
[16:04:42.813]                         frame <- frame + 1L
[16:04:42.813]                         envir <- sys.frame(frame)
[16:04:42.813]                       }
[16:04:42.813]                     }
[16:04:42.813]                     sendCondition <<- function(cond) NULL
[16:04:42.813]                   }
[16:04:42.813]                 })
[16:04:42.813]                 withCallingHandlers({
[16:04:42.813]                   2
[16:04:42.813]                 }, immediateCondition = function(cond) {
[16:04:42.813]                   sendCondition <- ...future.makeSendCondition()
[16:04:42.813]                   sendCondition(cond)
[16:04:42.813]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.813]                   {
[16:04:42.813]                     inherits <- base::inherits
[16:04:42.813]                     invokeRestart <- base::invokeRestart
[16:04:42.813]                     is.null <- base::is.null
[16:04:42.813]                     muffled <- FALSE
[16:04:42.813]                     if (inherits(cond, "message")) {
[16:04:42.813]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:42.813]                       if (muffled) 
[16:04:42.813]                         invokeRestart("muffleMessage")
[16:04:42.813]                     }
[16:04:42.813]                     else if (inherits(cond, "warning")) {
[16:04:42.813]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:42.813]                       if (muffled) 
[16:04:42.813]                         invokeRestart("muffleWarning")
[16:04:42.813]                     }
[16:04:42.813]                     else if (inherits(cond, "condition")) {
[16:04:42.813]                       if (!is.null(pattern)) {
[16:04:42.813]                         computeRestarts <- base::computeRestarts
[16:04:42.813]                         grepl <- base::grepl
[16:04:42.813]                         restarts <- computeRestarts(cond)
[16:04:42.813]                         for (restart in restarts) {
[16:04:42.813]                           name <- restart$name
[16:04:42.813]                           if (is.null(name)) 
[16:04:42.813]                             next
[16:04:42.813]                           if (!grepl(pattern, name)) 
[16:04:42.813]                             next
[16:04:42.813]                           invokeRestart(restart)
[16:04:42.813]                           muffled <- TRUE
[16:04:42.813]                           break
[16:04:42.813]                         }
[16:04:42.813]                       }
[16:04:42.813]                     }
[16:04:42.813]                     invisible(muffled)
[16:04:42.813]                   }
[16:04:42.813]                   muffleCondition(cond)
[16:04:42.813]                 })
[16:04:42.813]             }))
[16:04:42.813]             future::FutureResult(value = ...future.value$value, 
[16:04:42.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.813]                   ...future.rng), globalenv = if (FALSE) 
[16:04:42.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:42.813]                     ...future.globalenv.names))
[16:04:42.813]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:42.813]         }, condition = base::local({
[16:04:42.813]             c <- base::c
[16:04:42.813]             inherits <- base::inherits
[16:04:42.813]             invokeRestart <- base::invokeRestart
[16:04:42.813]             length <- base::length
[16:04:42.813]             list <- base::list
[16:04:42.813]             seq.int <- base::seq.int
[16:04:42.813]             signalCondition <- base::signalCondition
[16:04:42.813]             sys.calls <- base::sys.calls
[16:04:42.813]             `[[` <- base::`[[`
[16:04:42.813]             `+` <- base::`+`
[16:04:42.813]             `<<-` <- base::`<<-`
[16:04:42.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:42.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:42.813]                   3L)]
[16:04:42.813]             }
[16:04:42.813]             function(cond) {
[16:04:42.813]                 is_error <- inherits(cond, "error")
[16:04:42.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:42.813]                   NULL)
[16:04:42.813]                 if (is_error) {
[16:04:42.813]                   sessionInformation <- function() {
[16:04:42.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:42.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:42.813]                       search = base::search(), system = base::Sys.info())
[16:04:42.813]                   }
[16:04:42.813]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:42.813]                     cond$call), session = sessionInformation(), 
[16:04:42.813]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:42.813]                   signalCondition(cond)
[16:04:42.813]                 }
[16:04:42.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:42.813]                 "immediateCondition"))) {
[16:04:42.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:42.813]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:42.813]                   if (TRUE && !signal) {
[16:04:42.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.813]                     {
[16:04:42.813]                       inherits <- base::inherits
[16:04:42.813]                       invokeRestart <- base::invokeRestart
[16:04:42.813]                       is.null <- base::is.null
[16:04:42.813]                       muffled <- FALSE
[16:04:42.813]                       if (inherits(cond, "message")) {
[16:04:42.813]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.813]                         if (muffled) 
[16:04:42.813]                           invokeRestart("muffleMessage")
[16:04:42.813]                       }
[16:04:42.813]                       else if (inherits(cond, "warning")) {
[16:04:42.813]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.813]                         if (muffled) 
[16:04:42.813]                           invokeRestart("muffleWarning")
[16:04:42.813]                       }
[16:04:42.813]                       else if (inherits(cond, "condition")) {
[16:04:42.813]                         if (!is.null(pattern)) {
[16:04:42.813]                           computeRestarts <- base::computeRestarts
[16:04:42.813]                           grepl <- base::grepl
[16:04:42.813]                           restarts <- computeRestarts(cond)
[16:04:42.813]                           for (restart in restarts) {
[16:04:42.813]                             name <- restart$name
[16:04:42.813]                             if (is.null(name)) 
[16:04:42.813]                               next
[16:04:42.813]                             if (!grepl(pattern, name)) 
[16:04:42.813]                               next
[16:04:42.813]                             invokeRestart(restart)
[16:04:42.813]                             muffled <- TRUE
[16:04:42.813]                             break
[16:04:42.813]                           }
[16:04:42.813]                         }
[16:04:42.813]                       }
[16:04:42.813]                       invisible(muffled)
[16:04:42.813]                     }
[16:04:42.813]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.813]                   }
[16:04:42.813]                 }
[16:04:42.813]                 else {
[16:04:42.813]                   if (TRUE) {
[16:04:42.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.813]                     {
[16:04:42.813]                       inherits <- base::inherits
[16:04:42.813]                       invokeRestart <- base::invokeRestart
[16:04:42.813]                       is.null <- base::is.null
[16:04:42.813]                       muffled <- FALSE
[16:04:42.813]                       if (inherits(cond, "message")) {
[16:04:42.813]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.813]                         if (muffled) 
[16:04:42.813]                           invokeRestart("muffleMessage")
[16:04:42.813]                       }
[16:04:42.813]                       else if (inherits(cond, "warning")) {
[16:04:42.813]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.813]                         if (muffled) 
[16:04:42.813]                           invokeRestart("muffleWarning")
[16:04:42.813]                       }
[16:04:42.813]                       else if (inherits(cond, "condition")) {
[16:04:42.813]                         if (!is.null(pattern)) {
[16:04:42.813]                           computeRestarts <- base::computeRestarts
[16:04:42.813]                           grepl <- base::grepl
[16:04:42.813]                           restarts <- computeRestarts(cond)
[16:04:42.813]                           for (restart in restarts) {
[16:04:42.813]                             name <- restart$name
[16:04:42.813]                             if (is.null(name)) 
[16:04:42.813]                               next
[16:04:42.813]                             if (!grepl(pattern, name)) 
[16:04:42.813]                               next
[16:04:42.813]                             invokeRestart(restart)
[16:04:42.813]                             muffled <- TRUE
[16:04:42.813]                             break
[16:04:42.813]                           }
[16:04:42.813]                         }
[16:04:42.813]                       }
[16:04:42.813]                       invisible(muffled)
[16:04:42.813]                     }
[16:04:42.813]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.813]                   }
[16:04:42.813]                 }
[16:04:42.813]             }
[16:04:42.813]         }))
[16:04:42.813]     }, error = function(ex) {
[16:04:42.813]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:42.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.813]                 ...future.rng), started = ...future.startTime, 
[16:04:42.813]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:42.813]             version = "1.8"), class = "FutureResult")
[16:04:42.813]     }, finally = {
[16:04:42.813]         if (!identical(...future.workdir, getwd())) 
[16:04:42.813]             setwd(...future.workdir)
[16:04:42.813]         {
[16:04:42.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:42.813]                 ...future.oldOptions$nwarnings <- NULL
[16:04:42.813]             }
[16:04:42.813]             base::options(...future.oldOptions)
[16:04:42.813]             if (.Platform$OS.type == "windows") {
[16:04:42.813]                 old_names <- names(...future.oldEnvVars)
[16:04:42.813]                 envs <- base::Sys.getenv()
[16:04:42.813]                 names <- names(envs)
[16:04:42.813]                 common <- intersect(names, old_names)
[16:04:42.813]                 added <- setdiff(names, old_names)
[16:04:42.813]                 removed <- setdiff(old_names, names)
[16:04:42.813]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:42.813]                   envs[common]]
[16:04:42.813]                 NAMES <- toupper(changed)
[16:04:42.813]                 args <- list()
[16:04:42.813]                 for (kk in seq_along(NAMES)) {
[16:04:42.813]                   name <- changed[[kk]]
[16:04:42.813]                   NAME <- NAMES[[kk]]
[16:04:42.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.813]                     next
[16:04:42.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.813]                 }
[16:04:42.813]                 NAMES <- toupper(added)
[16:04:42.813]                 for (kk in seq_along(NAMES)) {
[16:04:42.813]                   name <- added[[kk]]
[16:04:42.813]                   NAME <- NAMES[[kk]]
[16:04:42.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.813]                     next
[16:04:42.813]                   args[[name]] <- ""
[16:04:42.813]                 }
[16:04:42.813]                 NAMES <- toupper(removed)
[16:04:42.813]                 for (kk in seq_along(NAMES)) {
[16:04:42.813]                   name <- removed[[kk]]
[16:04:42.813]                   NAME <- NAMES[[kk]]
[16:04:42.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.813]                     next
[16:04:42.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.813]                 }
[16:04:42.813]                 if (length(args) > 0) 
[16:04:42.813]                   base::do.call(base::Sys.setenv, args = args)
[16:04:42.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:42.813]             }
[16:04:42.813]             else {
[16:04:42.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:42.813]             }
[16:04:42.813]             {
[16:04:42.813]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:42.813]                   0L) {
[16:04:42.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:42.813]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:42.813]                   base::options(opts)
[16:04:42.813]                 }
[16:04:42.813]                 {
[16:04:42.813]                   {
[16:04:42.813]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:42.813]                     NULL
[16:04:42.813]                   }
[16:04:42.813]                   options(future.plan = NULL)
[16:04:42.813]                   if (is.na(NA_character_)) 
[16:04:42.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:42.813]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:42.813]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:42.813]                     envir = parent.frame()) 
[16:04:42.813]                   {
[16:04:42.813]                     if (is.function(workers)) 
[16:04:42.813]                       workers <- workers()
[16:04:42.813]                     workers <- structure(as.integer(workers), 
[16:04:42.813]                       class = class(workers))
[16:04:42.813]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:42.813]                       workers >= 1)
[16:04:42.813]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:42.813]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:42.813]                     }
[16:04:42.813]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:42.813]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:42.813]                       envir = envir)
[16:04:42.813]                     if (!future$lazy) 
[16:04:42.813]                       future <- run(future)
[16:04:42.813]                     invisible(future)
[16:04:42.813]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:42.813]                 }
[16:04:42.813]             }
[16:04:42.813]         }
[16:04:42.813]     })
[16:04:42.813]     if (TRUE) {
[16:04:42.813]         base::sink(type = "output", split = FALSE)
[16:04:42.813]         if (TRUE) {
[16:04:42.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:42.813]         }
[16:04:42.813]         else {
[16:04:42.813]             ...future.result["stdout"] <- base::list(NULL)
[16:04:42.813]         }
[16:04:42.813]         base::close(...future.stdout)
[16:04:42.813]         ...future.stdout <- NULL
[16:04:42.813]     }
[16:04:42.813]     ...future.result$conditions <- ...future.conditions
[16:04:42.813]     ...future.result$finished <- base::Sys.time()
[16:04:42.813]     ...future.result
[16:04:42.813] }
[16:04:42.817] MultisessionFuture started
[16:04:42.817] - Launch lazy future ... done
[16:04:42.817] run() for ‘MultisessionFuture’ ... done
[16:04:42.817] getGlobalsAndPackages() ...
[16:04:42.817] Searching for globals...
[16:04:42.818] 
[16:04:42.818] Searching for globals ... DONE
[16:04:42.818] - globals: [0] <none>
[16:04:42.818] getGlobalsAndPackages() ... DONE
[16:04:42.818] run() for ‘Future’ ...
[16:04:42.818] - state: ‘created’
[16:04:42.818] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:42.832] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:42.832] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:42.832]   - Field: ‘node’
[16:04:42.832]   - Field: ‘label’
[16:04:42.832]   - Field: ‘local’
[16:04:42.832]   - Field: ‘owner’
[16:04:42.832]   - Field: ‘envir’
[16:04:42.832]   - Field: ‘workers’
[16:04:42.833]   - Field: ‘packages’
[16:04:42.833]   - Field: ‘gc’
[16:04:42.833]   - Field: ‘conditions’
[16:04:42.833]   - Field: ‘persistent’
[16:04:42.833]   - Field: ‘expr’
[16:04:42.833]   - Field: ‘uuid’
[16:04:42.833]   - Field: ‘seed’
[16:04:42.833]   - Field: ‘version’
[16:04:42.833]   - Field: ‘result’
[16:04:42.833]   - Field: ‘asynchronous’
[16:04:42.833]   - Field: ‘calls’
[16:04:42.834]   - Field: ‘globals’
[16:04:42.834]   - Field: ‘stdout’
[16:04:42.834]   - Field: ‘earlySignal’
[16:04:42.834]   - Field: ‘lazy’
[16:04:42.834]   - Field: ‘state’
[16:04:42.834] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:42.834] - Launch lazy future ...
[16:04:42.834] Packages needed by the future expression (n = 0): <none>
[16:04:42.834] Packages needed by future strategies (n = 0): <none>
[16:04:42.835] {
[16:04:42.835]     {
[16:04:42.835]         {
[16:04:42.835]             ...future.startTime <- base::Sys.time()
[16:04:42.835]             {
[16:04:42.835]                 {
[16:04:42.835]                   {
[16:04:42.835]                     {
[16:04:42.835]                       base::local({
[16:04:42.835]                         has_future <- base::requireNamespace("future", 
[16:04:42.835]                           quietly = TRUE)
[16:04:42.835]                         if (has_future) {
[16:04:42.835]                           ns <- base::getNamespace("future")
[16:04:42.835]                           version <- ns[[".package"]][["version"]]
[16:04:42.835]                           if (is.null(version)) 
[16:04:42.835]                             version <- utils::packageVersion("future")
[16:04:42.835]                         }
[16:04:42.835]                         else {
[16:04:42.835]                           version <- NULL
[16:04:42.835]                         }
[16:04:42.835]                         if (!has_future || version < "1.8.0") {
[16:04:42.835]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:42.835]                             "", base::R.version$version.string), 
[16:04:42.835]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:42.835]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:42.835]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:42.835]                               "release", "version")], collapse = " "), 
[16:04:42.835]                             hostname = base::Sys.info()[["nodename"]])
[16:04:42.835]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:42.835]                             info)
[16:04:42.835]                           info <- base::paste(info, collapse = "; ")
[16:04:42.835]                           if (!has_future) {
[16:04:42.835]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:42.835]                               info)
[16:04:42.835]                           }
[16:04:42.835]                           else {
[16:04:42.835]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:42.835]                               info, version)
[16:04:42.835]                           }
[16:04:42.835]                           base::stop(msg)
[16:04:42.835]                         }
[16:04:42.835]                       })
[16:04:42.835]                     }
[16:04:42.835]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:42.835]                     base::options(mc.cores = 1L)
[16:04:42.835]                   }
[16:04:42.835]                   options(future.plan = NULL)
[16:04:42.835]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.835]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:42.835]                 }
[16:04:42.835]                 ...future.workdir <- getwd()
[16:04:42.835]             }
[16:04:42.835]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:42.835]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:42.835]         }
[16:04:42.835]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:42.835]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:42.835]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:42.835]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:42.835]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:42.835]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:42.835]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:42.835]             base::names(...future.oldOptions))
[16:04:42.835]     }
[16:04:42.835]     if (FALSE) {
[16:04:42.835]     }
[16:04:42.835]     else {
[16:04:42.835]         if (TRUE) {
[16:04:42.835]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:42.835]                 open = "w")
[16:04:42.835]         }
[16:04:42.835]         else {
[16:04:42.835]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:42.835]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:42.835]         }
[16:04:42.835]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:42.835]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:42.835]             base::sink(type = "output", split = FALSE)
[16:04:42.835]             base::close(...future.stdout)
[16:04:42.835]         }, add = TRUE)
[16:04:42.835]     }
[16:04:42.835]     ...future.frame <- base::sys.nframe()
[16:04:42.835]     ...future.conditions <- base::list()
[16:04:42.835]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:42.835]     if (FALSE) {
[16:04:42.835]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:42.835]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:42.835]     }
[16:04:42.835]     ...future.result <- base::tryCatch({
[16:04:42.835]         base::withCallingHandlers({
[16:04:42.835]             ...future.value <- base::withVisible(base::local({
[16:04:42.835]                 ...future.makeSendCondition <- base::local({
[16:04:42.835]                   sendCondition <- NULL
[16:04:42.835]                   function(frame = 1L) {
[16:04:42.835]                     if (is.function(sendCondition)) 
[16:04:42.835]                       return(sendCondition)
[16:04:42.835]                     ns <- getNamespace("parallel")
[16:04:42.835]                     if (exists("sendData", mode = "function", 
[16:04:42.835]                       envir = ns)) {
[16:04:42.835]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:42.835]                         envir = ns)
[16:04:42.835]                       envir <- sys.frame(frame)
[16:04:42.835]                       master <- NULL
[16:04:42.835]                       while (!identical(envir, .GlobalEnv) && 
[16:04:42.835]                         !identical(envir, emptyenv())) {
[16:04:42.835]                         if (exists("master", mode = "list", envir = envir, 
[16:04:42.835]                           inherits = FALSE)) {
[16:04:42.835]                           master <- get("master", mode = "list", 
[16:04:42.835]                             envir = envir, inherits = FALSE)
[16:04:42.835]                           if (inherits(master, c("SOCKnode", 
[16:04:42.835]                             "SOCK0node"))) {
[16:04:42.835]                             sendCondition <<- function(cond) {
[16:04:42.835]                               data <- list(type = "VALUE", value = cond, 
[16:04:42.835]                                 success = TRUE)
[16:04:42.835]                               parallel_sendData(master, data)
[16:04:42.835]                             }
[16:04:42.835]                             return(sendCondition)
[16:04:42.835]                           }
[16:04:42.835]                         }
[16:04:42.835]                         frame <- frame + 1L
[16:04:42.835]                         envir <- sys.frame(frame)
[16:04:42.835]                       }
[16:04:42.835]                     }
[16:04:42.835]                     sendCondition <<- function(cond) NULL
[16:04:42.835]                   }
[16:04:42.835]                 })
[16:04:42.835]                 withCallingHandlers({
[16:04:42.835]                   NULL
[16:04:42.835]                 }, immediateCondition = function(cond) {
[16:04:42.835]                   sendCondition <- ...future.makeSendCondition()
[16:04:42.835]                   sendCondition(cond)
[16:04:42.835]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.835]                   {
[16:04:42.835]                     inherits <- base::inherits
[16:04:42.835]                     invokeRestart <- base::invokeRestart
[16:04:42.835]                     is.null <- base::is.null
[16:04:42.835]                     muffled <- FALSE
[16:04:42.835]                     if (inherits(cond, "message")) {
[16:04:42.835]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:42.835]                       if (muffled) 
[16:04:42.835]                         invokeRestart("muffleMessage")
[16:04:42.835]                     }
[16:04:42.835]                     else if (inherits(cond, "warning")) {
[16:04:42.835]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:42.835]                       if (muffled) 
[16:04:42.835]                         invokeRestart("muffleWarning")
[16:04:42.835]                     }
[16:04:42.835]                     else if (inherits(cond, "condition")) {
[16:04:42.835]                       if (!is.null(pattern)) {
[16:04:42.835]                         computeRestarts <- base::computeRestarts
[16:04:42.835]                         grepl <- base::grepl
[16:04:42.835]                         restarts <- computeRestarts(cond)
[16:04:42.835]                         for (restart in restarts) {
[16:04:42.835]                           name <- restart$name
[16:04:42.835]                           if (is.null(name)) 
[16:04:42.835]                             next
[16:04:42.835]                           if (!grepl(pattern, name)) 
[16:04:42.835]                             next
[16:04:42.835]                           invokeRestart(restart)
[16:04:42.835]                           muffled <- TRUE
[16:04:42.835]                           break
[16:04:42.835]                         }
[16:04:42.835]                       }
[16:04:42.835]                     }
[16:04:42.835]                     invisible(muffled)
[16:04:42.835]                   }
[16:04:42.835]                   muffleCondition(cond)
[16:04:42.835]                 })
[16:04:42.835]             }))
[16:04:42.835]             future::FutureResult(value = ...future.value$value, 
[16:04:42.835]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.835]                   ...future.rng), globalenv = if (FALSE) 
[16:04:42.835]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:42.835]                     ...future.globalenv.names))
[16:04:42.835]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:42.835]         }, condition = base::local({
[16:04:42.835]             c <- base::c
[16:04:42.835]             inherits <- base::inherits
[16:04:42.835]             invokeRestart <- base::invokeRestart
[16:04:42.835]             length <- base::length
[16:04:42.835]             list <- base::list
[16:04:42.835]             seq.int <- base::seq.int
[16:04:42.835]             signalCondition <- base::signalCondition
[16:04:42.835]             sys.calls <- base::sys.calls
[16:04:42.835]             `[[` <- base::`[[`
[16:04:42.835]             `+` <- base::`+`
[16:04:42.835]             `<<-` <- base::`<<-`
[16:04:42.835]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:42.835]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:42.835]                   3L)]
[16:04:42.835]             }
[16:04:42.835]             function(cond) {
[16:04:42.835]                 is_error <- inherits(cond, "error")
[16:04:42.835]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:42.835]                   NULL)
[16:04:42.835]                 if (is_error) {
[16:04:42.835]                   sessionInformation <- function() {
[16:04:42.835]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:42.835]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:42.835]                       search = base::search(), system = base::Sys.info())
[16:04:42.835]                   }
[16:04:42.835]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.835]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:42.835]                     cond$call), session = sessionInformation(), 
[16:04:42.835]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:42.835]                   signalCondition(cond)
[16:04:42.835]                 }
[16:04:42.835]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:42.835]                 "immediateCondition"))) {
[16:04:42.835]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:42.835]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.835]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:42.835]                   if (TRUE && !signal) {
[16:04:42.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.835]                     {
[16:04:42.835]                       inherits <- base::inherits
[16:04:42.835]                       invokeRestart <- base::invokeRestart
[16:04:42.835]                       is.null <- base::is.null
[16:04:42.835]                       muffled <- FALSE
[16:04:42.835]                       if (inherits(cond, "message")) {
[16:04:42.835]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.835]                         if (muffled) 
[16:04:42.835]                           invokeRestart("muffleMessage")
[16:04:42.835]                       }
[16:04:42.835]                       else if (inherits(cond, "warning")) {
[16:04:42.835]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.835]                         if (muffled) 
[16:04:42.835]                           invokeRestart("muffleWarning")
[16:04:42.835]                       }
[16:04:42.835]                       else if (inherits(cond, "condition")) {
[16:04:42.835]                         if (!is.null(pattern)) {
[16:04:42.835]                           computeRestarts <- base::computeRestarts
[16:04:42.835]                           grepl <- base::grepl
[16:04:42.835]                           restarts <- computeRestarts(cond)
[16:04:42.835]                           for (restart in restarts) {
[16:04:42.835]                             name <- restart$name
[16:04:42.835]                             if (is.null(name)) 
[16:04:42.835]                               next
[16:04:42.835]                             if (!grepl(pattern, name)) 
[16:04:42.835]                               next
[16:04:42.835]                             invokeRestart(restart)
[16:04:42.835]                             muffled <- TRUE
[16:04:42.835]                             break
[16:04:42.835]                           }
[16:04:42.835]                         }
[16:04:42.835]                       }
[16:04:42.835]                       invisible(muffled)
[16:04:42.835]                     }
[16:04:42.835]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.835]                   }
[16:04:42.835]                 }
[16:04:42.835]                 else {
[16:04:42.835]                   if (TRUE) {
[16:04:42.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.835]                     {
[16:04:42.835]                       inherits <- base::inherits
[16:04:42.835]                       invokeRestart <- base::invokeRestart
[16:04:42.835]                       is.null <- base::is.null
[16:04:42.835]                       muffled <- FALSE
[16:04:42.835]                       if (inherits(cond, "message")) {
[16:04:42.835]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.835]                         if (muffled) 
[16:04:42.835]                           invokeRestart("muffleMessage")
[16:04:42.835]                       }
[16:04:42.835]                       else if (inherits(cond, "warning")) {
[16:04:42.835]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.835]                         if (muffled) 
[16:04:42.835]                           invokeRestart("muffleWarning")
[16:04:42.835]                       }
[16:04:42.835]                       else if (inherits(cond, "condition")) {
[16:04:42.835]                         if (!is.null(pattern)) {
[16:04:42.835]                           computeRestarts <- base::computeRestarts
[16:04:42.835]                           grepl <- base::grepl
[16:04:42.835]                           restarts <- computeRestarts(cond)
[16:04:42.835]                           for (restart in restarts) {
[16:04:42.835]                             name <- restart$name
[16:04:42.835]                             if (is.null(name)) 
[16:04:42.835]                               next
[16:04:42.835]                             if (!grepl(pattern, name)) 
[16:04:42.835]                               next
[16:04:42.835]                             invokeRestart(restart)
[16:04:42.835]                             muffled <- TRUE
[16:04:42.835]                             break
[16:04:42.835]                           }
[16:04:42.835]                         }
[16:04:42.835]                       }
[16:04:42.835]                       invisible(muffled)
[16:04:42.835]                     }
[16:04:42.835]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.835]                   }
[16:04:42.835]                 }
[16:04:42.835]             }
[16:04:42.835]         }))
[16:04:42.835]     }, error = function(ex) {
[16:04:42.835]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:42.835]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.835]                 ...future.rng), started = ...future.startTime, 
[16:04:42.835]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:42.835]             version = "1.8"), class = "FutureResult")
[16:04:42.835]     }, finally = {
[16:04:42.835]         if (!identical(...future.workdir, getwd())) 
[16:04:42.835]             setwd(...future.workdir)
[16:04:42.835]         {
[16:04:42.835]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:42.835]                 ...future.oldOptions$nwarnings <- NULL
[16:04:42.835]             }
[16:04:42.835]             base::options(...future.oldOptions)
[16:04:42.835]             if (.Platform$OS.type == "windows") {
[16:04:42.835]                 old_names <- names(...future.oldEnvVars)
[16:04:42.835]                 envs <- base::Sys.getenv()
[16:04:42.835]                 names <- names(envs)
[16:04:42.835]                 common <- intersect(names, old_names)
[16:04:42.835]                 added <- setdiff(names, old_names)
[16:04:42.835]                 removed <- setdiff(old_names, names)
[16:04:42.835]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:42.835]                   envs[common]]
[16:04:42.835]                 NAMES <- toupper(changed)
[16:04:42.835]                 args <- list()
[16:04:42.835]                 for (kk in seq_along(NAMES)) {
[16:04:42.835]                   name <- changed[[kk]]
[16:04:42.835]                   NAME <- NAMES[[kk]]
[16:04:42.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.835]                     next
[16:04:42.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.835]                 }
[16:04:42.835]                 NAMES <- toupper(added)
[16:04:42.835]                 for (kk in seq_along(NAMES)) {
[16:04:42.835]                   name <- added[[kk]]
[16:04:42.835]                   NAME <- NAMES[[kk]]
[16:04:42.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.835]                     next
[16:04:42.835]                   args[[name]] <- ""
[16:04:42.835]                 }
[16:04:42.835]                 NAMES <- toupper(removed)
[16:04:42.835]                 for (kk in seq_along(NAMES)) {
[16:04:42.835]                   name <- removed[[kk]]
[16:04:42.835]                   NAME <- NAMES[[kk]]
[16:04:42.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.835]                     next
[16:04:42.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.835]                 }
[16:04:42.835]                 if (length(args) > 0) 
[16:04:42.835]                   base::do.call(base::Sys.setenv, args = args)
[16:04:42.835]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:42.835]             }
[16:04:42.835]             else {
[16:04:42.835]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:42.835]             }
[16:04:42.835]             {
[16:04:42.835]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:42.835]                   0L) {
[16:04:42.835]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:42.835]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:42.835]                   base::options(opts)
[16:04:42.835]                 }
[16:04:42.835]                 {
[16:04:42.835]                   {
[16:04:42.835]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:42.835]                     NULL
[16:04:42.835]                   }
[16:04:42.835]                   options(future.plan = NULL)
[16:04:42.835]                   if (is.na(NA_character_)) 
[16:04:42.835]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.835]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:42.835]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:42.835]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:42.835]                     envir = parent.frame()) 
[16:04:42.835]                   {
[16:04:42.835]                     if (is.function(workers)) 
[16:04:42.835]                       workers <- workers()
[16:04:42.835]                     workers <- structure(as.integer(workers), 
[16:04:42.835]                       class = class(workers))
[16:04:42.835]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:42.835]                       workers >= 1)
[16:04:42.835]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:42.835]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:42.835]                     }
[16:04:42.835]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:42.835]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:42.835]                       envir = envir)
[16:04:42.835]                     if (!future$lazy) 
[16:04:42.835]                       future <- run(future)
[16:04:42.835]                     invisible(future)
[16:04:42.835]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:42.835]                 }
[16:04:42.835]             }
[16:04:42.835]         }
[16:04:42.835]     })
[16:04:42.835]     if (TRUE) {
[16:04:42.835]         base::sink(type = "output", split = FALSE)
[16:04:42.835]         if (TRUE) {
[16:04:42.835]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:42.835]         }
[16:04:42.835]         else {
[16:04:42.835]             ...future.result["stdout"] <- base::list(NULL)
[16:04:42.835]         }
[16:04:42.835]         base::close(...future.stdout)
[16:04:42.835]         ...future.stdout <- NULL
[16:04:42.835]     }
[16:04:42.835]     ...future.result$conditions <- ...future.conditions
[16:04:42.835]     ...future.result$finished <- base::Sys.time()
[16:04:42.835]     ...future.result
[16:04:42.835] }
[16:04:42.838] MultisessionFuture started
[16:04:42.838] - Launch lazy future ... done
[16:04:42.838] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874f56b780> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874f8c0590> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874f56b780> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874f8c0590> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:42.868] resolve() on list ...
[16:04:42.868]  recursive: 0
[16:04:42.868]  length: 6
[16:04:42.868]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:42.868] signalConditionsASAP(numeric, pos=1) ...
[16:04:42.868] - nx: 6
[16:04:42.868] - relay: TRUE
[16:04:42.868] - stdout: TRUE
[16:04:42.868] - signal: TRUE
[16:04:42.868] - resignal: FALSE
[16:04:42.868] - force: TRUE
[16:04:42.869] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.869] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.869]  - until=2
[16:04:42.869]  - relaying element #2
[16:04:42.869] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.869] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.869] signalConditionsASAP(NULL, pos=1) ... done
[16:04:42.869]  length: 5 (resolved future 1)
[16:04:42.870] receiveMessageFromWorker() for ClusterFuture ...
[16:04:42.870] - Validating connection of MultisessionFuture
[16:04:42.870] - received message: FutureResult
[16:04:42.870] - Received FutureResult
[16:04:42.870] - Erased future from FutureRegistry
[16:04:42.870] result() for ClusterFuture ...
[16:04:42.870] - result already collected: FutureResult
[16:04:42.870] result() for ClusterFuture ... done
[16:04:42.871] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:42.871] Future #2
[16:04:42.871] result() for ClusterFuture ...
[16:04:42.871] - result already collected: FutureResult
[16:04:42.871] result() for ClusterFuture ... done
[16:04:42.871] result() for ClusterFuture ...
[16:04:42.871] - result already collected: FutureResult
[16:04:42.871] result() for ClusterFuture ... done
[16:04:42.871] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:42.871] - nx: 6
[16:04:42.871] - relay: TRUE
[16:04:42.872] - stdout: TRUE
[16:04:42.872] - signal: TRUE
[16:04:42.872] - resignal: FALSE
[16:04:42.872] - force: TRUE
[16:04:42.872] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.872] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.872]  - until=2
[16:04:42.872]  - relaying element #2
[16:04:42.872] result() for ClusterFuture ...
[16:04:42.872] - result already collected: FutureResult
[16:04:42.872] result() for ClusterFuture ... done
[16:04:42.872] result() for ClusterFuture ...
[16:04:42.873] - result already collected: FutureResult
[16:04:42.873] result() for ClusterFuture ... done
[16:04:42.873] result() for ClusterFuture ...
[16:04:42.873] - result already collected: FutureResult
[16:04:42.873] result() for ClusterFuture ... done
[16:04:42.873] result() for ClusterFuture ...
[16:04:42.873] - result already collected: FutureResult
[16:04:42.873] result() for ClusterFuture ... done
[16:04:42.873] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.873] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.873] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:42.873]  length: 4 (resolved future 2)
[16:04:42.884] receiveMessageFromWorker() for ClusterFuture ...
[16:04:42.884] - Validating connection of MultisessionFuture
[16:04:42.884] - received message: FutureResult
[16:04:42.884] - Received FutureResult
[16:04:42.884] - Erased future from FutureRegistry
[16:04:42.884] result() for ClusterFuture ...
[16:04:42.884] - result already collected: FutureResult
[16:04:42.884] result() for ClusterFuture ... done
[16:04:42.884] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:42.885] Future #3
[16:04:42.885] result() for ClusterFuture ...
[16:04:42.885] - result already collected: FutureResult
[16:04:42.885] result() for ClusterFuture ... done
[16:04:42.885] result() for ClusterFuture ...
[16:04:42.885] - result already collected: FutureResult
[16:04:42.885] result() for ClusterFuture ... done
[16:04:42.885] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:42.885] - nx: 6
[16:04:42.885] - relay: TRUE
[16:04:42.885] - stdout: TRUE
[16:04:42.886] - signal: TRUE
[16:04:42.886] - resignal: FALSE
[16:04:42.886] - force: TRUE
[16:04:42.886] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.886] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.886]  - until=3
[16:04:42.886]  - relaying element #3
[16:04:42.886] result() for ClusterFuture ...
[16:04:42.886] - result already collected: FutureResult
[16:04:42.886] result() for ClusterFuture ... done
[16:04:42.886] result() for ClusterFuture ...
[16:04:42.886] - result already collected: FutureResult
[16:04:42.887] result() for ClusterFuture ... done
[16:04:42.887] result() for ClusterFuture ...
[16:04:42.887] - result already collected: FutureResult
[16:04:42.887] result() for ClusterFuture ... done
[16:04:42.887] result() for ClusterFuture ...
[16:04:42.887] - result already collected: FutureResult
[16:04:42.887] result() for ClusterFuture ... done
[16:04:42.887] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.887] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.887] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:42.887]  length: 3 (resolved future 3)
[16:04:42.888] signalConditionsASAP(NULL, pos=4) ...
[16:04:42.888] - nx: 6
[16:04:42.888] - relay: TRUE
[16:04:42.888] - stdout: TRUE
[16:04:42.888] - signal: TRUE
[16:04:42.888] - resignal: FALSE
[16:04:42.888] - force: TRUE
[16:04:42.888] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.888] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.888]  - until=5
[16:04:42.888]  - relaying element #5
[16:04:42.888] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:42.889] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.889] signalConditionsASAP(NULL, pos=4) ... done
[16:04:42.889]  length: 2 (resolved future 4)
[16:04:42.889] signalConditionsASAP(NULL, pos=5) ...
[16:04:42.889] - nx: 6
[16:04:42.889] - relay: TRUE
[16:04:42.889] - stdout: TRUE
[16:04:42.889] - signal: TRUE
[16:04:42.889] - resignal: FALSE
[16:04:42.889] - force: TRUE
[16:04:42.889] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:42.889] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.890]  - until=6
[16:04:42.890]  - relaying element #6
[16:04:42.890] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:42.890] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.890] signalConditionsASAP(NULL, pos=5) ... done
[16:04:42.890]  length: 1 (resolved future 5)
[16:04:42.890] signalConditionsASAP(numeric, pos=6) ...
[16:04:42.890] - nx: 6
[16:04:42.890] - relay: TRUE
[16:04:42.890] - stdout: TRUE
[16:04:42.890] - signal: TRUE
[16:04:42.890] - resignal: FALSE
[16:04:42.890] - force: TRUE
[16:04:42.891] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:42.891] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.891]  - until=6
[16:04:42.891] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:42.891] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.891] signalConditionsASAP(numeric, pos=6) ... done
[16:04:42.891]  length: 0 (resolved future 6)
[16:04:42.891] Relaying remaining futures
[16:04:42.891] signalConditionsASAP(NULL, pos=0) ...
[16:04:42.891] - nx: 6
[16:04:42.891] - relay: TRUE
[16:04:42.892] - stdout: TRUE
[16:04:42.892] - signal: TRUE
[16:04:42.892] - resignal: FALSE
[16:04:42.892] - force: TRUE
[16:04:42.892] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:42.892] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:42.892] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:42.892] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:42.892] signalConditionsASAP(NULL, pos=0) ... done
[16:04:42.892] resolve() on list ... DONE
[16:04:42.892] result() for ClusterFuture ...
[16:04:42.893] - result already collected: FutureResult
[16:04:42.893] result() for ClusterFuture ... done
[16:04:42.893] result() for ClusterFuture ...
[16:04:42.893] - result already collected: FutureResult
[16:04:42.893] result() for ClusterFuture ... done
[16:04:42.893] result() for ClusterFuture ...
[16:04:42.893] - result already collected: FutureResult
[16:04:42.893] result() for ClusterFuture ... done
[16:04:42.893] result() for ClusterFuture ...
[16:04:42.893] - result already collected: FutureResult
[16:04:42.893] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:04:42.897] getGlobalsAndPackages() ...
[16:04:42.897] Searching for globals...
[16:04:42.897] 
[16:04:42.897] Searching for globals ... DONE
[16:04:42.897] - globals: [0] <none>
[16:04:42.897] getGlobalsAndPackages() ... DONE
[16:04:42.898] run() for ‘Future’ ...
[16:04:42.898] - state: ‘created’
[16:04:42.898] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:42.913] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:42.913] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:42.913]   - Field: ‘node’
[16:04:42.913]   - Field: ‘label’
[16:04:42.913]   - Field: ‘local’
[16:04:42.914]   - Field: ‘owner’
[16:04:42.914]   - Field: ‘envir’
[16:04:42.914]   - Field: ‘workers’
[16:04:42.914]   - Field: ‘packages’
[16:04:42.914]   - Field: ‘gc’
[16:04:42.914]   - Field: ‘conditions’
[16:04:42.914]   - Field: ‘persistent’
[16:04:42.914]   - Field: ‘expr’
[16:04:42.914]   - Field: ‘uuid’
[16:04:42.914]   - Field: ‘seed’
[16:04:42.914]   - Field: ‘version’
[16:04:42.915]   - Field: ‘result’
[16:04:42.915]   - Field: ‘asynchronous’
[16:04:42.915]   - Field: ‘calls’
[16:04:42.915]   - Field: ‘globals’
[16:04:42.915]   - Field: ‘stdout’
[16:04:42.915]   - Field: ‘earlySignal’
[16:04:42.915]   - Field: ‘lazy’
[16:04:42.915]   - Field: ‘state’
[16:04:42.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:42.915] - Launch lazy future ...
[16:04:42.916] Packages needed by the future expression (n = 0): <none>
[16:04:42.916] Packages needed by future strategies (n = 0): <none>
[16:04:42.916] {
[16:04:42.916]     {
[16:04:42.916]         {
[16:04:42.916]             ...future.startTime <- base::Sys.time()
[16:04:42.916]             {
[16:04:42.916]                 {
[16:04:42.916]                   {
[16:04:42.916]                     {
[16:04:42.916]                       base::local({
[16:04:42.916]                         has_future <- base::requireNamespace("future", 
[16:04:42.916]                           quietly = TRUE)
[16:04:42.916]                         if (has_future) {
[16:04:42.916]                           ns <- base::getNamespace("future")
[16:04:42.916]                           version <- ns[[".package"]][["version"]]
[16:04:42.916]                           if (is.null(version)) 
[16:04:42.916]                             version <- utils::packageVersion("future")
[16:04:42.916]                         }
[16:04:42.916]                         else {
[16:04:42.916]                           version <- NULL
[16:04:42.916]                         }
[16:04:42.916]                         if (!has_future || version < "1.8.0") {
[16:04:42.916]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:42.916]                             "", base::R.version$version.string), 
[16:04:42.916]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:42.916]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:42.916]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:42.916]                               "release", "version")], collapse = " "), 
[16:04:42.916]                             hostname = base::Sys.info()[["nodename"]])
[16:04:42.916]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:42.916]                             info)
[16:04:42.916]                           info <- base::paste(info, collapse = "; ")
[16:04:42.916]                           if (!has_future) {
[16:04:42.916]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:42.916]                               info)
[16:04:42.916]                           }
[16:04:42.916]                           else {
[16:04:42.916]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:42.916]                               info, version)
[16:04:42.916]                           }
[16:04:42.916]                           base::stop(msg)
[16:04:42.916]                         }
[16:04:42.916]                       })
[16:04:42.916]                     }
[16:04:42.916]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:42.916]                     base::options(mc.cores = 1L)
[16:04:42.916]                   }
[16:04:42.916]                   options(future.plan = NULL)
[16:04:42.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:42.916]                 }
[16:04:42.916]                 ...future.workdir <- getwd()
[16:04:42.916]             }
[16:04:42.916]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:42.916]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:42.916]         }
[16:04:42.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:42.916]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:42.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:42.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:42.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:42.916]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:42.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:42.916]             base::names(...future.oldOptions))
[16:04:42.916]     }
[16:04:42.916]     if (FALSE) {
[16:04:42.916]     }
[16:04:42.916]     else {
[16:04:42.916]         if (TRUE) {
[16:04:42.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:42.916]                 open = "w")
[16:04:42.916]         }
[16:04:42.916]         else {
[16:04:42.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:42.916]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:42.916]         }
[16:04:42.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:42.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:42.916]             base::sink(type = "output", split = FALSE)
[16:04:42.916]             base::close(...future.stdout)
[16:04:42.916]         }, add = TRUE)
[16:04:42.916]     }
[16:04:42.916]     ...future.frame <- base::sys.nframe()
[16:04:42.916]     ...future.conditions <- base::list()
[16:04:42.916]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:42.916]     if (FALSE) {
[16:04:42.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:42.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:42.916]     }
[16:04:42.916]     ...future.result <- base::tryCatch({
[16:04:42.916]         base::withCallingHandlers({
[16:04:42.916]             ...future.value <- base::withVisible(base::local({
[16:04:42.916]                 ...future.makeSendCondition <- base::local({
[16:04:42.916]                   sendCondition <- NULL
[16:04:42.916]                   function(frame = 1L) {
[16:04:42.916]                     if (is.function(sendCondition)) 
[16:04:42.916]                       return(sendCondition)
[16:04:42.916]                     ns <- getNamespace("parallel")
[16:04:42.916]                     if (exists("sendData", mode = "function", 
[16:04:42.916]                       envir = ns)) {
[16:04:42.916]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:42.916]                         envir = ns)
[16:04:42.916]                       envir <- sys.frame(frame)
[16:04:42.916]                       master <- NULL
[16:04:42.916]                       while (!identical(envir, .GlobalEnv) && 
[16:04:42.916]                         !identical(envir, emptyenv())) {
[16:04:42.916]                         if (exists("master", mode = "list", envir = envir, 
[16:04:42.916]                           inherits = FALSE)) {
[16:04:42.916]                           master <- get("master", mode = "list", 
[16:04:42.916]                             envir = envir, inherits = FALSE)
[16:04:42.916]                           if (inherits(master, c("SOCKnode", 
[16:04:42.916]                             "SOCK0node"))) {
[16:04:42.916]                             sendCondition <<- function(cond) {
[16:04:42.916]                               data <- list(type = "VALUE", value = cond, 
[16:04:42.916]                                 success = TRUE)
[16:04:42.916]                               parallel_sendData(master, data)
[16:04:42.916]                             }
[16:04:42.916]                             return(sendCondition)
[16:04:42.916]                           }
[16:04:42.916]                         }
[16:04:42.916]                         frame <- frame + 1L
[16:04:42.916]                         envir <- sys.frame(frame)
[16:04:42.916]                       }
[16:04:42.916]                     }
[16:04:42.916]                     sendCondition <<- function(cond) NULL
[16:04:42.916]                   }
[16:04:42.916]                 })
[16:04:42.916]                 withCallingHandlers({
[16:04:42.916]                   2
[16:04:42.916]                 }, immediateCondition = function(cond) {
[16:04:42.916]                   sendCondition <- ...future.makeSendCondition()
[16:04:42.916]                   sendCondition(cond)
[16:04:42.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.916]                   {
[16:04:42.916]                     inherits <- base::inherits
[16:04:42.916]                     invokeRestart <- base::invokeRestart
[16:04:42.916]                     is.null <- base::is.null
[16:04:42.916]                     muffled <- FALSE
[16:04:42.916]                     if (inherits(cond, "message")) {
[16:04:42.916]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:42.916]                       if (muffled) 
[16:04:42.916]                         invokeRestart("muffleMessage")
[16:04:42.916]                     }
[16:04:42.916]                     else if (inherits(cond, "warning")) {
[16:04:42.916]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:42.916]                       if (muffled) 
[16:04:42.916]                         invokeRestart("muffleWarning")
[16:04:42.916]                     }
[16:04:42.916]                     else if (inherits(cond, "condition")) {
[16:04:42.916]                       if (!is.null(pattern)) {
[16:04:42.916]                         computeRestarts <- base::computeRestarts
[16:04:42.916]                         grepl <- base::grepl
[16:04:42.916]                         restarts <- computeRestarts(cond)
[16:04:42.916]                         for (restart in restarts) {
[16:04:42.916]                           name <- restart$name
[16:04:42.916]                           if (is.null(name)) 
[16:04:42.916]                             next
[16:04:42.916]                           if (!grepl(pattern, name)) 
[16:04:42.916]                             next
[16:04:42.916]                           invokeRestart(restart)
[16:04:42.916]                           muffled <- TRUE
[16:04:42.916]                           break
[16:04:42.916]                         }
[16:04:42.916]                       }
[16:04:42.916]                     }
[16:04:42.916]                     invisible(muffled)
[16:04:42.916]                   }
[16:04:42.916]                   muffleCondition(cond)
[16:04:42.916]                 })
[16:04:42.916]             }))
[16:04:42.916]             future::FutureResult(value = ...future.value$value, 
[16:04:42.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.916]                   ...future.rng), globalenv = if (FALSE) 
[16:04:42.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:42.916]                     ...future.globalenv.names))
[16:04:42.916]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:42.916]         }, condition = base::local({
[16:04:42.916]             c <- base::c
[16:04:42.916]             inherits <- base::inherits
[16:04:42.916]             invokeRestart <- base::invokeRestart
[16:04:42.916]             length <- base::length
[16:04:42.916]             list <- base::list
[16:04:42.916]             seq.int <- base::seq.int
[16:04:42.916]             signalCondition <- base::signalCondition
[16:04:42.916]             sys.calls <- base::sys.calls
[16:04:42.916]             `[[` <- base::`[[`
[16:04:42.916]             `+` <- base::`+`
[16:04:42.916]             `<<-` <- base::`<<-`
[16:04:42.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:42.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:42.916]                   3L)]
[16:04:42.916]             }
[16:04:42.916]             function(cond) {
[16:04:42.916]                 is_error <- inherits(cond, "error")
[16:04:42.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:42.916]                   NULL)
[16:04:42.916]                 if (is_error) {
[16:04:42.916]                   sessionInformation <- function() {
[16:04:42.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:42.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:42.916]                       search = base::search(), system = base::Sys.info())
[16:04:42.916]                   }
[16:04:42.916]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:42.916]                     cond$call), session = sessionInformation(), 
[16:04:42.916]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:42.916]                   signalCondition(cond)
[16:04:42.916]                 }
[16:04:42.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:42.916]                 "immediateCondition"))) {
[16:04:42.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:42.916]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:42.916]                   if (TRUE && !signal) {
[16:04:42.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.916]                     {
[16:04:42.916]                       inherits <- base::inherits
[16:04:42.916]                       invokeRestart <- base::invokeRestart
[16:04:42.916]                       is.null <- base::is.null
[16:04:42.916]                       muffled <- FALSE
[16:04:42.916]                       if (inherits(cond, "message")) {
[16:04:42.916]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.916]                         if (muffled) 
[16:04:42.916]                           invokeRestart("muffleMessage")
[16:04:42.916]                       }
[16:04:42.916]                       else if (inherits(cond, "warning")) {
[16:04:42.916]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.916]                         if (muffled) 
[16:04:42.916]                           invokeRestart("muffleWarning")
[16:04:42.916]                       }
[16:04:42.916]                       else if (inherits(cond, "condition")) {
[16:04:42.916]                         if (!is.null(pattern)) {
[16:04:42.916]                           computeRestarts <- base::computeRestarts
[16:04:42.916]                           grepl <- base::grepl
[16:04:42.916]                           restarts <- computeRestarts(cond)
[16:04:42.916]                           for (restart in restarts) {
[16:04:42.916]                             name <- restart$name
[16:04:42.916]                             if (is.null(name)) 
[16:04:42.916]                               next
[16:04:42.916]                             if (!grepl(pattern, name)) 
[16:04:42.916]                               next
[16:04:42.916]                             invokeRestart(restart)
[16:04:42.916]                             muffled <- TRUE
[16:04:42.916]                             break
[16:04:42.916]                           }
[16:04:42.916]                         }
[16:04:42.916]                       }
[16:04:42.916]                       invisible(muffled)
[16:04:42.916]                     }
[16:04:42.916]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.916]                   }
[16:04:42.916]                 }
[16:04:42.916]                 else {
[16:04:42.916]                   if (TRUE) {
[16:04:42.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.916]                     {
[16:04:42.916]                       inherits <- base::inherits
[16:04:42.916]                       invokeRestart <- base::invokeRestart
[16:04:42.916]                       is.null <- base::is.null
[16:04:42.916]                       muffled <- FALSE
[16:04:42.916]                       if (inherits(cond, "message")) {
[16:04:42.916]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.916]                         if (muffled) 
[16:04:42.916]                           invokeRestart("muffleMessage")
[16:04:42.916]                       }
[16:04:42.916]                       else if (inherits(cond, "warning")) {
[16:04:42.916]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.916]                         if (muffled) 
[16:04:42.916]                           invokeRestart("muffleWarning")
[16:04:42.916]                       }
[16:04:42.916]                       else if (inherits(cond, "condition")) {
[16:04:42.916]                         if (!is.null(pattern)) {
[16:04:42.916]                           computeRestarts <- base::computeRestarts
[16:04:42.916]                           grepl <- base::grepl
[16:04:42.916]                           restarts <- computeRestarts(cond)
[16:04:42.916]                           for (restart in restarts) {
[16:04:42.916]                             name <- restart$name
[16:04:42.916]                             if (is.null(name)) 
[16:04:42.916]                               next
[16:04:42.916]                             if (!grepl(pattern, name)) 
[16:04:42.916]                               next
[16:04:42.916]                             invokeRestart(restart)
[16:04:42.916]                             muffled <- TRUE
[16:04:42.916]                             break
[16:04:42.916]                           }
[16:04:42.916]                         }
[16:04:42.916]                       }
[16:04:42.916]                       invisible(muffled)
[16:04:42.916]                     }
[16:04:42.916]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.916]                   }
[16:04:42.916]                 }
[16:04:42.916]             }
[16:04:42.916]         }))
[16:04:42.916]     }, error = function(ex) {
[16:04:42.916]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:42.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.916]                 ...future.rng), started = ...future.startTime, 
[16:04:42.916]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:42.916]             version = "1.8"), class = "FutureResult")
[16:04:42.916]     }, finally = {
[16:04:42.916]         if (!identical(...future.workdir, getwd())) 
[16:04:42.916]             setwd(...future.workdir)
[16:04:42.916]         {
[16:04:42.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:42.916]                 ...future.oldOptions$nwarnings <- NULL
[16:04:42.916]             }
[16:04:42.916]             base::options(...future.oldOptions)
[16:04:42.916]             if (.Platform$OS.type == "windows") {
[16:04:42.916]                 old_names <- names(...future.oldEnvVars)
[16:04:42.916]                 envs <- base::Sys.getenv()
[16:04:42.916]                 names <- names(envs)
[16:04:42.916]                 common <- intersect(names, old_names)
[16:04:42.916]                 added <- setdiff(names, old_names)
[16:04:42.916]                 removed <- setdiff(old_names, names)
[16:04:42.916]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:42.916]                   envs[common]]
[16:04:42.916]                 NAMES <- toupper(changed)
[16:04:42.916]                 args <- list()
[16:04:42.916]                 for (kk in seq_along(NAMES)) {
[16:04:42.916]                   name <- changed[[kk]]
[16:04:42.916]                   NAME <- NAMES[[kk]]
[16:04:42.916]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.916]                     next
[16:04:42.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.916]                 }
[16:04:42.916]                 NAMES <- toupper(added)
[16:04:42.916]                 for (kk in seq_along(NAMES)) {
[16:04:42.916]                   name <- added[[kk]]
[16:04:42.916]                   NAME <- NAMES[[kk]]
[16:04:42.916]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.916]                     next
[16:04:42.916]                   args[[name]] <- ""
[16:04:42.916]                 }
[16:04:42.916]                 NAMES <- toupper(removed)
[16:04:42.916]                 for (kk in seq_along(NAMES)) {
[16:04:42.916]                   name <- removed[[kk]]
[16:04:42.916]                   NAME <- NAMES[[kk]]
[16:04:42.916]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.916]                     next
[16:04:42.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.916]                 }
[16:04:42.916]                 if (length(args) > 0) 
[16:04:42.916]                   base::do.call(base::Sys.setenv, args = args)
[16:04:42.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:42.916]             }
[16:04:42.916]             else {
[16:04:42.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:42.916]             }
[16:04:42.916]             {
[16:04:42.916]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:42.916]                   0L) {
[16:04:42.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:42.916]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:42.916]                   base::options(opts)
[16:04:42.916]                 }
[16:04:42.916]                 {
[16:04:42.916]                   {
[16:04:42.916]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:42.916]                     NULL
[16:04:42.916]                   }
[16:04:42.916]                   options(future.plan = NULL)
[16:04:42.916]                   if (is.na(NA_character_)) 
[16:04:42.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:42.916]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:42.916]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:42.916]                     envir = parent.frame()) 
[16:04:42.916]                   {
[16:04:42.916]                     if (is.function(workers)) 
[16:04:42.916]                       workers <- workers()
[16:04:42.916]                     workers <- structure(as.integer(workers), 
[16:04:42.916]                       class = class(workers))
[16:04:42.916]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:42.916]                       workers >= 1)
[16:04:42.916]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:42.916]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:42.916]                     }
[16:04:42.916]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:42.916]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:42.916]                       envir = envir)
[16:04:42.916]                     if (!future$lazy) 
[16:04:42.916]                       future <- run(future)
[16:04:42.916]                     invisible(future)
[16:04:42.916]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:42.916]                 }
[16:04:42.916]             }
[16:04:42.916]         }
[16:04:42.916]     })
[16:04:42.916]     if (TRUE) {
[16:04:42.916]         base::sink(type = "output", split = FALSE)
[16:04:42.916]         if (TRUE) {
[16:04:42.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:42.916]         }
[16:04:42.916]         else {
[16:04:42.916]             ...future.result["stdout"] <- base::list(NULL)
[16:04:42.916]         }
[16:04:42.916]         base::close(...future.stdout)
[16:04:42.916]         ...future.stdout <- NULL
[16:04:42.916]     }
[16:04:42.916]     ...future.result$conditions <- ...future.conditions
[16:04:42.916]     ...future.result$finished <- base::Sys.time()
[16:04:42.916]     ...future.result
[16:04:42.916] }
[16:04:42.919] MultisessionFuture started
[16:04:42.920] - Launch lazy future ... done
[16:04:42.920] run() for ‘MultisessionFuture’ ... done
[16:04:42.920] getGlobalsAndPackages() ...
[16:04:42.920] Searching for globals...
[16:04:42.920] 
[16:04:42.920] Searching for globals ... DONE
[16:04:42.921] - globals: [0] <none>
[16:04:42.921] getGlobalsAndPackages() ... DONE
[16:04:42.921] run() for ‘Future’ ...
[16:04:42.921] - state: ‘created’
[16:04:42.921] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:42.935] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:42.935] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:42.935]   - Field: ‘node’
[16:04:42.935]   - Field: ‘label’
[16:04:42.935]   - Field: ‘local’
[16:04:42.935]   - Field: ‘owner’
[16:04:42.935]   - Field: ‘envir’
[16:04:42.935]   - Field: ‘workers’
[16:04:42.935]   - Field: ‘packages’
[16:04:42.935]   - Field: ‘gc’
[16:04:42.936]   - Field: ‘conditions’
[16:04:42.936]   - Field: ‘persistent’
[16:04:42.936]   - Field: ‘expr’
[16:04:42.936]   - Field: ‘uuid’
[16:04:42.936]   - Field: ‘seed’
[16:04:42.936]   - Field: ‘version’
[16:04:42.936]   - Field: ‘result’
[16:04:42.936]   - Field: ‘asynchronous’
[16:04:42.936]   - Field: ‘calls’
[16:04:42.936]   - Field: ‘globals’
[16:04:42.936]   - Field: ‘stdout’
[16:04:42.937]   - Field: ‘earlySignal’
[16:04:42.937]   - Field: ‘lazy’
[16:04:42.937]   - Field: ‘state’
[16:04:42.937] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:42.937] - Launch lazy future ...
[16:04:42.937] Packages needed by the future expression (n = 0): <none>
[16:04:42.937] Packages needed by future strategies (n = 0): <none>
[16:04:42.938] {
[16:04:42.938]     {
[16:04:42.938]         {
[16:04:42.938]             ...future.startTime <- base::Sys.time()
[16:04:42.938]             {
[16:04:42.938]                 {
[16:04:42.938]                   {
[16:04:42.938]                     {
[16:04:42.938]                       base::local({
[16:04:42.938]                         has_future <- base::requireNamespace("future", 
[16:04:42.938]                           quietly = TRUE)
[16:04:42.938]                         if (has_future) {
[16:04:42.938]                           ns <- base::getNamespace("future")
[16:04:42.938]                           version <- ns[[".package"]][["version"]]
[16:04:42.938]                           if (is.null(version)) 
[16:04:42.938]                             version <- utils::packageVersion("future")
[16:04:42.938]                         }
[16:04:42.938]                         else {
[16:04:42.938]                           version <- NULL
[16:04:42.938]                         }
[16:04:42.938]                         if (!has_future || version < "1.8.0") {
[16:04:42.938]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:42.938]                             "", base::R.version$version.string), 
[16:04:42.938]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:42.938]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:42.938]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:42.938]                               "release", "version")], collapse = " "), 
[16:04:42.938]                             hostname = base::Sys.info()[["nodename"]])
[16:04:42.938]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:42.938]                             info)
[16:04:42.938]                           info <- base::paste(info, collapse = "; ")
[16:04:42.938]                           if (!has_future) {
[16:04:42.938]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:42.938]                               info)
[16:04:42.938]                           }
[16:04:42.938]                           else {
[16:04:42.938]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:42.938]                               info, version)
[16:04:42.938]                           }
[16:04:42.938]                           base::stop(msg)
[16:04:42.938]                         }
[16:04:42.938]                       })
[16:04:42.938]                     }
[16:04:42.938]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:42.938]                     base::options(mc.cores = 1L)
[16:04:42.938]                   }
[16:04:42.938]                   options(future.plan = NULL)
[16:04:42.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:42.938]                 }
[16:04:42.938]                 ...future.workdir <- getwd()
[16:04:42.938]             }
[16:04:42.938]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:42.938]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:42.938]         }
[16:04:42.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:42.938]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:42.938]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:42.938]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:42.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:42.938]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:42.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:42.938]             base::names(...future.oldOptions))
[16:04:42.938]     }
[16:04:42.938]     if (FALSE) {
[16:04:42.938]     }
[16:04:42.938]     else {
[16:04:42.938]         if (TRUE) {
[16:04:42.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:42.938]                 open = "w")
[16:04:42.938]         }
[16:04:42.938]         else {
[16:04:42.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:42.938]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:42.938]         }
[16:04:42.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:42.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:42.938]             base::sink(type = "output", split = FALSE)
[16:04:42.938]             base::close(...future.stdout)
[16:04:42.938]         }, add = TRUE)
[16:04:42.938]     }
[16:04:42.938]     ...future.frame <- base::sys.nframe()
[16:04:42.938]     ...future.conditions <- base::list()
[16:04:42.938]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:42.938]     if (FALSE) {
[16:04:42.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:42.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:42.938]     }
[16:04:42.938]     ...future.result <- base::tryCatch({
[16:04:42.938]         base::withCallingHandlers({
[16:04:42.938]             ...future.value <- base::withVisible(base::local({
[16:04:42.938]                 ...future.makeSendCondition <- base::local({
[16:04:42.938]                   sendCondition <- NULL
[16:04:42.938]                   function(frame = 1L) {
[16:04:42.938]                     if (is.function(sendCondition)) 
[16:04:42.938]                       return(sendCondition)
[16:04:42.938]                     ns <- getNamespace("parallel")
[16:04:42.938]                     if (exists("sendData", mode = "function", 
[16:04:42.938]                       envir = ns)) {
[16:04:42.938]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:42.938]                         envir = ns)
[16:04:42.938]                       envir <- sys.frame(frame)
[16:04:42.938]                       master <- NULL
[16:04:42.938]                       while (!identical(envir, .GlobalEnv) && 
[16:04:42.938]                         !identical(envir, emptyenv())) {
[16:04:42.938]                         if (exists("master", mode = "list", envir = envir, 
[16:04:42.938]                           inherits = FALSE)) {
[16:04:42.938]                           master <- get("master", mode = "list", 
[16:04:42.938]                             envir = envir, inherits = FALSE)
[16:04:42.938]                           if (inherits(master, c("SOCKnode", 
[16:04:42.938]                             "SOCK0node"))) {
[16:04:42.938]                             sendCondition <<- function(cond) {
[16:04:42.938]                               data <- list(type = "VALUE", value = cond, 
[16:04:42.938]                                 success = TRUE)
[16:04:42.938]                               parallel_sendData(master, data)
[16:04:42.938]                             }
[16:04:42.938]                             return(sendCondition)
[16:04:42.938]                           }
[16:04:42.938]                         }
[16:04:42.938]                         frame <- frame + 1L
[16:04:42.938]                         envir <- sys.frame(frame)
[16:04:42.938]                       }
[16:04:42.938]                     }
[16:04:42.938]                     sendCondition <<- function(cond) NULL
[16:04:42.938]                   }
[16:04:42.938]                 })
[16:04:42.938]                 withCallingHandlers({
[16:04:42.938]                   NULL
[16:04:42.938]                 }, immediateCondition = function(cond) {
[16:04:42.938]                   sendCondition <- ...future.makeSendCondition()
[16:04:42.938]                   sendCondition(cond)
[16:04:42.938]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.938]                   {
[16:04:42.938]                     inherits <- base::inherits
[16:04:42.938]                     invokeRestart <- base::invokeRestart
[16:04:42.938]                     is.null <- base::is.null
[16:04:42.938]                     muffled <- FALSE
[16:04:42.938]                     if (inherits(cond, "message")) {
[16:04:42.938]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:42.938]                       if (muffled) 
[16:04:42.938]                         invokeRestart("muffleMessage")
[16:04:42.938]                     }
[16:04:42.938]                     else if (inherits(cond, "warning")) {
[16:04:42.938]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:42.938]                       if (muffled) 
[16:04:42.938]                         invokeRestart("muffleWarning")
[16:04:42.938]                     }
[16:04:42.938]                     else if (inherits(cond, "condition")) {
[16:04:42.938]                       if (!is.null(pattern)) {
[16:04:42.938]                         computeRestarts <- base::computeRestarts
[16:04:42.938]                         grepl <- base::grepl
[16:04:42.938]                         restarts <- computeRestarts(cond)
[16:04:42.938]                         for (restart in restarts) {
[16:04:42.938]                           name <- restart$name
[16:04:42.938]                           if (is.null(name)) 
[16:04:42.938]                             next
[16:04:42.938]                           if (!grepl(pattern, name)) 
[16:04:42.938]                             next
[16:04:42.938]                           invokeRestart(restart)
[16:04:42.938]                           muffled <- TRUE
[16:04:42.938]                           break
[16:04:42.938]                         }
[16:04:42.938]                       }
[16:04:42.938]                     }
[16:04:42.938]                     invisible(muffled)
[16:04:42.938]                   }
[16:04:42.938]                   muffleCondition(cond)
[16:04:42.938]                 })
[16:04:42.938]             }))
[16:04:42.938]             future::FutureResult(value = ...future.value$value, 
[16:04:42.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.938]                   ...future.rng), globalenv = if (FALSE) 
[16:04:42.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:42.938]                     ...future.globalenv.names))
[16:04:42.938]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:42.938]         }, condition = base::local({
[16:04:42.938]             c <- base::c
[16:04:42.938]             inherits <- base::inherits
[16:04:42.938]             invokeRestart <- base::invokeRestart
[16:04:42.938]             length <- base::length
[16:04:42.938]             list <- base::list
[16:04:42.938]             seq.int <- base::seq.int
[16:04:42.938]             signalCondition <- base::signalCondition
[16:04:42.938]             sys.calls <- base::sys.calls
[16:04:42.938]             `[[` <- base::`[[`
[16:04:42.938]             `+` <- base::`+`
[16:04:42.938]             `<<-` <- base::`<<-`
[16:04:42.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:42.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:42.938]                   3L)]
[16:04:42.938]             }
[16:04:42.938]             function(cond) {
[16:04:42.938]                 is_error <- inherits(cond, "error")
[16:04:42.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:42.938]                   NULL)
[16:04:42.938]                 if (is_error) {
[16:04:42.938]                   sessionInformation <- function() {
[16:04:42.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:42.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:42.938]                       search = base::search(), system = base::Sys.info())
[16:04:42.938]                   }
[16:04:42.938]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:42.938]                     cond$call), session = sessionInformation(), 
[16:04:42.938]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:42.938]                   signalCondition(cond)
[16:04:42.938]                 }
[16:04:42.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:42.938]                 "immediateCondition"))) {
[16:04:42.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:42.938]                   ...future.conditions[[length(...future.conditions) + 
[16:04:42.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:42.938]                   if (TRUE && !signal) {
[16:04:42.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.938]                     {
[16:04:42.938]                       inherits <- base::inherits
[16:04:42.938]                       invokeRestart <- base::invokeRestart
[16:04:42.938]                       is.null <- base::is.null
[16:04:42.938]                       muffled <- FALSE
[16:04:42.938]                       if (inherits(cond, "message")) {
[16:04:42.938]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.938]                         if (muffled) 
[16:04:42.938]                           invokeRestart("muffleMessage")
[16:04:42.938]                       }
[16:04:42.938]                       else if (inherits(cond, "warning")) {
[16:04:42.938]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.938]                         if (muffled) 
[16:04:42.938]                           invokeRestart("muffleWarning")
[16:04:42.938]                       }
[16:04:42.938]                       else if (inherits(cond, "condition")) {
[16:04:42.938]                         if (!is.null(pattern)) {
[16:04:42.938]                           computeRestarts <- base::computeRestarts
[16:04:42.938]                           grepl <- base::grepl
[16:04:42.938]                           restarts <- computeRestarts(cond)
[16:04:42.938]                           for (restart in restarts) {
[16:04:42.938]                             name <- restart$name
[16:04:42.938]                             if (is.null(name)) 
[16:04:42.938]                               next
[16:04:42.938]                             if (!grepl(pattern, name)) 
[16:04:42.938]                               next
[16:04:42.938]                             invokeRestart(restart)
[16:04:42.938]                             muffled <- TRUE
[16:04:42.938]                             break
[16:04:42.938]                           }
[16:04:42.938]                         }
[16:04:42.938]                       }
[16:04:42.938]                       invisible(muffled)
[16:04:42.938]                     }
[16:04:42.938]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.938]                   }
[16:04:42.938]                 }
[16:04:42.938]                 else {
[16:04:42.938]                   if (TRUE) {
[16:04:42.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:42.938]                     {
[16:04:42.938]                       inherits <- base::inherits
[16:04:42.938]                       invokeRestart <- base::invokeRestart
[16:04:42.938]                       is.null <- base::is.null
[16:04:42.938]                       muffled <- FALSE
[16:04:42.938]                       if (inherits(cond, "message")) {
[16:04:42.938]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:42.938]                         if (muffled) 
[16:04:42.938]                           invokeRestart("muffleMessage")
[16:04:42.938]                       }
[16:04:42.938]                       else if (inherits(cond, "warning")) {
[16:04:42.938]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:42.938]                         if (muffled) 
[16:04:42.938]                           invokeRestart("muffleWarning")
[16:04:42.938]                       }
[16:04:42.938]                       else if (inherits(cond, "condition")) {
[16:04:42.938]                         if (!is.null(pattern)) {
[16:04:42.938]                           computeRestarts <- base::computeRestarts
[16:04:42.938]                           grepl <- base::grepl
[16:04:42.938]                           restarts <- computeRestarts(cond)
[16:04:42.938]                           for (restart in restarts) {
[16:04:42.938]                             name <- restart$name
[16:04:42.938]                             if (is.null(name)) 
[16:04:42.938]                               next
[16:04:42.938]                             if (!grepl(pattern, name)) 
[16:04:42.938]                               next
[16:04:42.938]                             invokeRestart(restart)
[16:04:42.938]                             muffled <- TRUE
[16:04:42.938]                             break
[16:04:42.938]                           }
[16:04:42.938]                         }
[16:04:42.938]                       }
[16:04:42.938]                       invisible(muffled)
[16:04:42.938]                     }
[16:04:42.938]                     muffleCondition(cond, pattern = "^muffle")
[16:04:42.938]                   }
[16:04:42.938]                 }
[16:04:42.938]             }
[16:04:42.938]         }))
[16:04:42.938]     }, error = function(ex) {
[16:04:42.938]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:42.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:42.938]                 ...future.rng), started = ...future.startTime, 
[16:04:42.938]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:42.938]             version = "1.8"), class = "FutureResult")
[16:04:42.938]     }, finally = {
[16:04:42.938]         if (!identical(...future.workdir, getwd())) 
[16:04:42.938]             setwd(...future.workdir)
[16:04:42.938]         {
[16:04:42.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:42.938]                 ...future.oldOptions$nwarnings <- NULL
[16:04:42.938]             }
[16:04:42.938]             base::options(...future.oldOptions)
[16:04:42.938]             if (.Platform$OS.type == "windows") {
[16:04:42.938]                 old_names <- names(...future.oldEnvVars)
[16:04:42.938]                 envs <- base::Sys.getenv()
[16:04:42.938]                 names <- names(envs)
[16:04:42.938]                 common <- intersect(names, old_names)
[16:04:42.938]                 added <- setdiff(names, old_names)
[16:04:42.938]                 removed <- setdiff(old_names, names)
[16:04:42.938]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:42.938]                   envs[common]]
[16:04:42.938]                 NAMES <- toupper(changed)
[16:04:42.938]                 args <- list()
[16:04:42.938]                 for (kk in seq_along(NAMES)) {
[16:04:42.938]                   name <- changed[[kk]]
[16:04:42.938]                   NAME <- NAMES[[kk]]
[16:04:42.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.938]                     next
[16:04:42.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.938]                 }
[16:04:42.938]                 NAMES <- toupper(added)
[16:04:42.938]                 for (kk in seq_along(NAMES)) {
[16:04:42.938]                   name <- added[[kk]]
[16:04:42.938]                   NAME <- NAMES[[kk]]
[16:04:42.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.938]                     next
[16:04:42.938]                   args[[name]] <- ""
[16:04:42.938]                 }
[16:04:42.938]                 NAMES <- toupper(removed)
[16:04:42.938]                 for (kk in seq_along(NAMES)) {
[16:04:42.938]                   name <- removed[[kk]]
[16:04:42.938]                   NAME <- NAMES[[kk]]
[16:04:42.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:42.938]                     next
[16:04:42.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:42.938]                 }
[16:04:42.938]                 if (length(args) > 0) 
[16:04:42.938]                   base::do.call(base::Sys.setenv, args = args)
[16:04:42.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:42.938]             }
[16:04:42.938]             else {
[16:04:42.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:42.938]             }
[16:04:42.938]             {
[16:04:42.938]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:42.938]                   0L) {
[16:04:42.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:42.938]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:42.938]                   base::options(opts)
[16:04:42.938]                 }
[16:04:42.938]                 {
[16:04:42.938]                   {
[16:04:42.938]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:42.938]                     NULL
[16:04:42.938]                   }
[16:04:42.938]                   options(future.plan = NULL)
[16:04:42.938]                   if (is.na(NA_character_)) 
[16:04:42.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:42.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:42.938]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:42.938]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:42.938]                     envir = parent.frame()) 
[16:04:42.938]                   {
[16:04:42.938]                     if (is.function(workers)) 
[16:04:42.938]                       workers <- workers()
[16:04:42.938]                     workers <- structure(as.integer(workers), 
[16:04:42.938]                       class = class(workers))
[16:04:42.938]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:42.938]                       workers >= 1)
[16:04:42.938]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:42.938]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:42.938]                     }
[16:04:42.938]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:42.938]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:42.938]                       envir = envir)
[16:04:42.938]                     if (!future$lazy) 
[16:04:42.938]                       future <- run(future)
[16:04:42.938]                     invisible(future)
[16:04:42.938]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:42.938]                 }
[16:04:42.938]             }
[16:04:42.938]         }
[16:04:42.938]     })
[16:04:42.938]     if (TRUE) {
[16:04:42.938]         base::sink(type = "output", split = FALSE)
[16:04:42.938]         if (TRUE) {
[16:04:42.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:42.938]         }
[16:04:42.938]         else {
[16:04:42.938]             ...future.result["stdout"] <- base::list(NULL)
[16:04:42.938]         }
[16:04:42.938]         base::close(...future.stdout)
[16:04:42.938]         ...future.stdout <- NULL
[16:04:42.938]     }
[16:04:42.938]     ...future.result$conditions <- ...future.conditions
[16:04:42.938]     ...future.result$finished <- base::Sys.time()
[16:04:42.938]     ...future.result
[16:04:42.938] }
[16:04:42.941] MultisessionFuture started
[16:04:42.941] - Launch lazy future ... done
[16:04:42.941] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874b9f5e40> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874ebc0440> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874b9f5e40> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874ebc0440> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:42.969] resolve() on list ...
[16:04:42.969]  recursive: 0
[16:04:42.969]  length: 6
[16:04:42.969]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:42.969] signalConditionsASAP(numeric, pos=1) ...
[16:04:42.969] - nx: 6
[16:04:42.969] - relay: TRUE
[16:04:42.969] - stdout: TRUE
[16:04:42.969] - signal: TRUE
[16:04:42.969] - resignal: FALSE
[16:04:42.969] - force: TRUE
[16:04:42.970] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.970] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.970]  - until=2
[16:04:42.970]  - relaying element #2
[16:04:42.970] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.970] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.970] signalConditionsASAP(NULL, pos=1) ... done
[16:04:42.970]  length: 5 (resolved future 1)
[16:04:42.971] receiveMessageFromWorker() for ClusterFuture ...
[16:04:42.971] - Validating connection of MultisessionFuture
[16:04:42.971] - received message: FutureResult
[16:04:42.971] - Received FutureResult
[16:04:42.971] - Erased future from FutureRegistry
[16:04:42.971] result() for ClusterFuture ...
[16:04:42.971] - result already collected: FutureResult
[16:04:42.971] result() for ClusterFuture ... done
[16:04:42.972] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:42.972] Future #2
[16:04:42.972] result() for ClusterFuture ...
[16:04:42.972] - result already collected: FutureResult
[16:04:42.972] result() for ClusterFuture ... done
[16:04:42.972] result() for ClusterFuture ...
[16:04:42.972] - result already collected: FutureResult
[16:04:42.972] result() for ClusterFuture ... done
[16:04:42.972] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:42.972] - nx: 6
[16:04:42.972] - relay: TRUE
[16:04:42.973] - stdout: TRUE
[16:04:42.973] - signal: TRUE
[16:04:42.973] - resignal: FALSE
[16:04:42.973] - force: TRUE
[16:04:42.973] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.973] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:42.973]  - until=2
[16:04:42.973]  - relaying element #2
[16:04:42.973] result() for ClusterFuture ...
[16:04:42.973] - result already collected: FutureResult
[16:04:42.973] result() for ClusterFuture ... done
[16:04:42.973] result() for ClusterFuture ...
[16:04:42.974] - result already collected: FutureResult
[16:04:42.974] result() for ClusterFuture ... done
[16:04:42.974] result() for ClusterFuture ...
[16:04:42.974] - result already collected: FutureResult
[16:04:42.974] result() for ClusterFuture ... done
[16:04:42.974] result() for ClusterFuture ...
[16:04:42.974] - result already collected: FutureResult
[16:04:42.974] result() for ClusterFuture ... done
[16:04:42.974] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.974] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.974] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:42.975]  length: 4 (resolved future 2)
[16:04:42.985] signalConditionsASAP(NULL, pos=4) ...
[16:04:42.985] - nx: 6
[16:04:42.985] - relay: TRUE
[16:04:42.985] - stdout: TRUE
[16:04:42.985] - signal: TRUE
[16:04:42.986] - resignal: FALSE
[16:04:42.986] - force: TRUE
[16:04:42.986] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.986] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.986]  - until=5
[16:04:42.986]  - relaying element #3
[16:04:42.986]  - relaying element #5
[16:04:42.986] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:04:42.986] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.986] signalConditionsASAP(NULL, pos=4) ... done
[16:04:42.986]  length: 3 (resolved future 4)
[16:04:42.987] signalConditionsASAP(NULL, pos=5) ...
[16:04:42.987] - nx: 6
[16:04:42.987] - relay: TRUE
[16:04:42.987] - stdout: TRUE
[16:04:42.987] - signal: TRUE
[16:04:42.987] - resignal: FALSE
[16:04:42.987] - force: TRUE
[16:04:42.987] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:04:42.987] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.987]  - until=6
[16:04:42.988]  - relaying element #3
[16:04:42.988]  - relaying element #6
[16:04:42.988] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:04:42.988] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.988] signalConditionsASAP(NULL, pos=5) ... done
[16:04:42.988]  length: 2 (resolved future 5)
[16:04:42.988] signalConditionsASAP(numeric, pos=6) ...
[16:04:42.988] - nx: 6
[16:04:42.988] - relay: TRUE
[16:04:42.988] - stdout: TRUE
[16:04:42.988] - signal: TRUE
[16:04:42.989] - resignal: FALSE
[16:04:42.989] - force: TRUE
[16:04:42.989] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:04:42.989] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.989]  - until=6
[16:04:42.989]  - relaying element #3
[16:04:42.989] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:04:42.989] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:42.989] signalConditionsASAP(NULL, pos=6) ... done
[16:04:42.989]  length: 1 (resolved future 6)
[16:04:43.000] receiveMessageFromWorker() for ClusterFuture ...
[16:04:43.000] - Validating connection of MultisessionFuture
[16:04:43.000] - received message: FutureResult
[16:04:43.000] - Received FutureResult
[16:04:43.000] - Erased future from FutureRegistry
[16:04:43.001] result() for ClusterFuture ...
[16:04:43.001] - result already collected: FutureResult
[16:04:43.001] result() for ClusterFuture ... done
[16:04:43.001] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:43.001] Future #3
[16:04:43.001] result() for ClusterFuture ...
[16:04:43.001] - result already collected: FutureResult
[16:04:43.001] result() for ClusterFuture ... done
[16:04:43.001] result() for ClusterFuture ...
[16:04:43.001] - result already collected: FutureResult
[16:04:43.001] result() for ClusterFuture ... done
[16:04:43.001] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:43.002] - nx: 6
[16:04:43.002] - relay: TRUE
[16:04:43.002] - stdout: TRUE
[16:04:43.002] - signal: TRUE
[16:04:43.002] - resignal: FALSE
[16:04:43.002] - force: TRUE
[16:04:43.002] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:04:43.002] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:43.002]  - until=6
[16:04:43.002]  - relaying element #3
[16:04:43.002] result() for ClusterFuture ...
[16:04:43.002] - result already collected: FutureResult
[16:04:43.003] result() for ClusterFuture ... done
[16:04:43.003] result() for ClusterFuture ...
[16:04:43.003] - result already collected: FutureResult
[16:04:43.003] result() for ClusterFuture ... done
[16:04:43.003] result() for ClusterFuture ...
[16:04:43.003] - result already collected: FutureResult
[16:04:43.003] result() for ClusterFuture ... done
[16:04:43.003] result() for ClusterFuture ...
[16:04:43.003] - result already collected: FutureResult
[16:04:43.003] result() for ClusterFuture ... done
[16:04:43.003] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:43.004] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:43.004] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:43.004]  length: 0 (resolved future 3)
[16:04:43.004] Relaying remaining futures
[16:04:43.004] signalConditionsASAP(NULL, pos=0) ...
[16:04:43.004] - nx: 6
[16:04:43.004] - relay: TRUE
[16:04:43.004] - stdout: TRUE
[16:04:43.004] - signal: TRUE
[16:04:43.004] - resignal: FALSE
[16:04:43.004] - force: TRUE
[16:04:43.004] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:43.005] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:43.005] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:43.005] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:43.005] signalConditionsASAP(NULL, pos=0) ... done
[16:04:43.005] resolve() on list ... DONE
[16:04:43.005] result() for ClusterFuture ...
[16:04:43.005] - result already collected: FutureResult
[16:04:43.005] result() for ClusterFuture ... done
[16:04:43.005] result() for ClusterFuture ...
[16:04:43.005] - result already collected: FutureResult
[16:04:43.005] result() for ClusterFuture ... done
[16:04:43.006] result() for ClusterFuture ...
[16:04:43.006] - result already collected: FutureResult
[16:04:43.006] result() for ClusterFuture ... done
[16:04:43.006] result() for ClusterFuture ...
[16:04:43.006] - result already collected: FutureResult
[16:04:43.006] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:04:43.011] getGlobalsAndPackages() ...
[16:04:43.011] Searching for globals...
[16:04:43.012] 
[16:04:43.012] Searching for globals ... DONE
[16:04:43.012] - globals: [0] <none>
[16:04:43.012] getGlobalsAndPackages() ... DONE
[16:04:43.012] run() for ‘Future’ ...
[16:04:43.012] - state: ‘created’
[16:04:43.012] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.027] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:43.027]   - Field: ‘node’
[16:04:43.027]   - Field: ‘label’
[16:04:43.027]   - Field: ‘local’
[16:04:43.027]   - Field: ‘owner’
[16:04:43.027]   - Field: ‘envir’
[16:04:43.027]   - Field: ‘workers’
[16:04:43.027]   - Field: ‘packages’
[16:04:43.028]   - Field: ‘gc’
[16:04:43.028]   - Field: ‘conditions’
[16:04:43.028]   - Field: ‘persistent’
[16:04:43.028]   - Field: ‘expr’
[16:04:43.028]   - Field: ‘uuid’
[16:04:43.028]   - Field: ‘seed’
[16:04:43.028]   - Field: ‘version’
[16:04:43.028]   - Field: ‘result’
[16:04:43.028]   - Field: ‘asynchronous’
[16:04:43.028]   - Field: ‘calls’
[16:04:43.028]   - Field: ‘globals’
[16:04:43.028]   - Field: ‘stdout’
[16:04:43.029]   - Field: ‘earlySignal’
[16:04:43.029]   - Field: ‘lazy’
[16:04:43.029]   - Field: ‘state’
[16:04:43.029] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:43.029] - Launch lazy future ...
[16:04:43.029] Packages needed by the future expression (n = 0): <none>
[16:04:43.029] Packages needed by future strategies (n = 0): <none>
[16:04:43.030] {
[16:04:43.030]     {
[16:04:43.030]         {
[16:04:43.030]             ...future.startTime <- base::Sys.time()
[16:04:43.030]             {
[16:04:43.030]                 {
[16:04:43.030]                   {
[16:04:43.030]                     {
[16:04:43.030]                       base::local({
[16:04:43.030]                         has_future <- base::requireNamespace("future", 
[16:04:43.030]                           quietly = TRUE)
[16:04:43.030]                         if (has_future) {
[16:04:43.030]                           ns <- base::getNamespace("future")
[16:04:43.030]                           version <- ns[[".package"]][["version"]]
[16:04:43.030]                           if (is.null(version)) 
[16:04:43.030]                             version <- utils::packageVersion("future")
[16:04:43.030]                         }
[16:04:43.030]                         else {
[16:04:43.030]                           version <- NULL
[16:04:43.030]                         }
[16:04:43.030]                         if (!has_future || version < "1.8.0") {
[16:04:43.030]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.030]                             "", base::R.version$version.string), 
[16:04:43.030]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.030]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.030]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.030]                               "release", "version")], collapse = " "), 
[16:04:43.030]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.030]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.030]                             info)
[16:04:43.030]                           info <- base::paste(info, collapse = "; ")
[16:04:43.030]                           if (!has_future) {
[16:04:43.030]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.030]                               info)
[16:04:43.030]                           }
[16:04:43.030]                           else {
[16:04:43.030]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.030]                               info, version)
[16:04:43.030]                           }
[16:04:43.030]                           base::stop(msg)
[16:04:43.030]                         }
[16:04:43.030]                       })
[16:04:43.030]                     }
[16:04:43.030]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.030]                     base::options(mc.cores = 1L)
[16:04:43.030]                   }
[16:04:43.030]                   options(future.plan = NULL)
[16:04:43.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.030]                 }
[16:04:43.030]                 ...future.workdir <- getwd()
[16:04:43.030]             }
[16:04:43.030]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.030]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.030]         }
[16:04:43.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.030]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.030]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.030]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.030]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.030]             base::names(...future.oldOptions))
[16:04:43.030]     }
[16:04:43.030]     if (FALSE) {
[16:04:43.030]     }
[16:04:43.030]     else {
[16:04:43.030]         if (TRUE) {
[16:04:43.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.030]                 open = "w")
[16:04:43.030]         }
[16:04:43.030]         else {
[16:04:43.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.030]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.030]         }
[16:04:43.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.030]             base::sink(type = "output", split = FALSE)
[16:04:43.030]             base::close(...future.stdout)
[16:04:43.030]         }, add = TRUE)
[16:04:43.030]     }
[16:04:43.030]     ...future.frame <- base::sys.nframe()
[16:04:43.030]     ...future.conditions <- base::list()
[16:04:43.030]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.030]     if (FALSE) {
[16:04:43.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.030]     }
[16:04:43.030]     ...future.result <- base::tryCatch({
[16:04:43.030]         base::withCallingHandlers({
[16:04:43.030]             ...future.value <- base::withVisible(base::local({
[16:04:43.030]                 ...future.makeSendCondition <- base::local({
[16:04:43.030]                   sendCondition <- NULL
[16:04:43.030]                   function(frame = 1L) {
[16:04:43.030]                     if (is.function(sendCondition)) 
[16:04:43.030]                       return(sendCondition)
[16:04:43.030]                     ns <- getNamespace("parallel")
[16:04:43.030]                     if (exists("sendData", mode = "function", 
[16:04:43.030]                       envir = ns)) {
[16:04:43.030]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:43.030]                         envir = ns)
[16:04:43.030]                       envir <- sys.frame(frame)
[16:04:43.030]                       master <- NULL
[16:04:43.030]                       while (!identical(envir, .GlobalEnv) && 
[16:04:43.030]                         !identical(envir, emptyenv())) {
[16:04:43.030]                         if (exists("master", mode = "list", envir = envir, 
[16:04:43.030]                           inherits = FALSE)) {
[16:04:43.030]                           master <- get("master", mode = "list", 
[16:04:43.030]                             envir = envir, inherits = FALSE)
[16:04:43.030]                           if (inherits(master, c("SOCKnode", 
[16:04:43.030]                             "SOCK0node"))) {
[16:04:43.030]                             sendCondition <<- function(cond) {
[16:04:43.030]                               data <- list(type = "VALUE", value = cond, 
[16:04:43.030]                                 success = TRUE)
[16:04:43.030]                               parallel_sendData(master, data)
[16:04:43.030]                             }
[16:04:43.030]                             return(sendCondition)
[16:04:43.030]                           }
[16:04:43.030]                         }
[16:04:43.030]                         frame <- frame + 1L
[16:04:43.030]                         envir <- sys.frame(frame)
[16:04:43.030]                       }
[16:04:43.030]                     }
[16:04:43.030]                     sendCondition <<- function(cond) NULL
[16:04:43.030]                   }
[16:04:43.030]                 })
[16:04:43.030]                 withCallingHandlers({
[16:04:43.030]                   2
[16:04:43.030]                 }, immediateCondition = function(cond) {
[16:04:43.030]                   sendCondition <- ...future.makeSendCondition()
[16:04:43.030]                   sendCondition(cond)
[16:04:43.030]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.030]                   {
[16:04:43.030]                     inherits <- base::inherits
[16:04:43.030]                     invokeRestart <- base::invokeRestart
[16:04:43.030]                     is.null <- base::is.null
[16:04:43.030]                     muffled <- FALSE
[16:04:43.030]                     if (inherits(cond, "message")) {
[16:04:43.030]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.030]                       if (muffled) 
[16:04:43.030]                         invokeRestart("muffleMessage")
[16:04:43.030]                     }
[16:04:43.030]                     else if (inherits(cond, "warning")) {
[16:04:43.030]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.030]                       if (muffled) 
[16:04:43.030]                         invokeRestart("muffleWarning")
[16:04:43.030]                     }
[16:04:43.030]                     else if (inherits(cond, "condition")) {
[16:04:43.030]                       if (!is.null(pattern)) {
[16:04:43.030]                         computeRestarts <- base::computeRestarts
[16:04:43.030]                         grepl <- base::grepl
[16:04:43.030]                         restarts <- computeRestarts(cond)
[16:04:43.030]                         for (restart in restarts) {
[16:04:43.030]                           name <- restart$name
[16:04:43.030]                           if (is.null(name)) 
[16:04:43.030]                             next
[16:04:43.030]                           if (!grepl(pattern, name)) 
[16:04:43.030]                             next
[16:04:43.030]                           invokeRestart(restart)
[16:04:43.030]                           muffled <- TRUE
[16:04:43.030]                           break
[16:04:43.030]                         }
[16:04:43.030]                       }
[16:04:43.030]                     }
[16:04:43.030]                     invisible(muffled)
[16:04:43.030]                   }
[16:04:43.030]                   muffleCondition(cond)
[16:04:43.030]                 })
[16:04:43.030]             }))
[16:04:43.030]             future::FutureResult(value = ...future.value$value, 
[16:04:43.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.030]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.030]                     ...future.globalenv.names))
[16:04:43.030]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.030]         }, condition = base::local({
[16:04:43.030]             c <- base::c
[16:04:43.030]             inherits <- base::inherits
[16:04:43.030]             invokeRestart <- base::invokeRestart
[16:04:43.030]             length <- base::length
[16:04:43.030]             list <- base::list
[16:04:43.030]             seq.int <- base::seq.int
[16:04:43.030]             signalCondition <- base::signalCondition
[16:04:43.030]             sys.calls <- base::sys.calls
[16:04:43.030]             `[[` <- base::`[[`
[16:04:43.030]             `+` <- base::`+`
[16:04:43.030]             `<<-` <- base::`<<-`
[16:04:43.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.030]                   3L)]
[16:04:43.030]             }
[16:04:43.030]             function(cond) {
[16:04:43.030]                 is_error <- inherits(cond, "error")
[16:04:43.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.030]                   NULL)
[16:04:43.030]                 if (is_error) {
[16:04:43.030]                   sessionInformation <- function() {
[16:04:43.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.030]                       search = base::search(), system = base::Sys.info())
[16:04:43.030]                   }
[16:04:43.030]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.030]                     cond$call), session = sessionInformation(), 
[16:04:43.030]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.030]                   signalCondition(cond)
[16:04:43.030]                 }
[16:04:43.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.030]                 "immediateCondition"))) {
[16:04:43.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.030]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.030]                   if (TRUE && !signal) {
[16:04:43.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.030]                     {
[16:04:43.030]                       inherits <- base::inherits
[16:04:43.030]                       invokeRestart <- base::invokeRestart
[16:04:43.030]                       is.null <- base::is.null
[16:04:43.030]                       muffled <- FALSE
[16:04:43.030]                       if (inherits(cond, "message")) {
[16:04:43.030]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.030]                         if (muffled) 
[16:04:43.030]                           invokeRestart("muffleMessage")
[16:04:43.030]                       }
[16:04:43.030]                       else if (inherits(cond, "warning")) {
[16:04:43.030]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.030]                         if (muffled) 
[16:04:43.030]                           invokeRestart("muffleWarning")
[16:04:43.030]                       }
[16:04:43.030]                       else if (inherits(cond, "condition")) {
[16:04:43.030]                         if (!is.null(pattern)) {
[16:04:43.030]                           computeRestarts <- base::computeRestarts
[16:04:43.030]                           grepl <- base::grepl
[16:04:43.030]                           restarts <- computeRestarts(cond)
[16:04:43.030]                           for (restart in restarts) {
[16:04:43.030]                             name <- restart$name
[16:04:43.030]                             if (is.null(name)) 
[16:04:43.030]                               next
[16:04:43.030]                             if (!grepl(pattern, name)) 
[16:04:43.030]                               next
[16:04:43.030]                             invokeRestart(restart)
[16:04:43.030]                             muffled <- TRUE
[16:04:43.030]                             break
[16:04:43.030]                           }
[16:04:43.030]                         }
[16:04:43.030]                       }
[16:04:43.030]                       invisible(muffled)
[16:04:43.030]                     }
[16:04:43.030]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.030]                   }
[16:04:43.030]                 }
[16:04:43.030]                 else {
[16:04:43.030]                   if (TRUE) {
[16:04:43.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.030]                     {
[16:04:43.030]                       inherits <- base::inherits
[16:04:43.030]                       invokeRestart <- base::invokeRestart
[16:04:43.030]                       is.null <- base::is.null
[16:04:43.030]                       muffled <- FALSE
[16:04:43.030]                       if (inherits(cond, "message")) {
[16:04:43.030]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.030]                         if (muffled) 
[16:04:43.030]                           invokeRestart("muffleMessage")
[16:04:43.030]                       }
[16:04:43.030]                       else if (inherits(cond, "warning")) {
[16:04:43.030]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.030]                         if (muffled) 
[16:04:43.030]                           invokeRestart("muffleWarning")
[16:04:43.030]                       }
[16:04:43.030]                       else if (inherits(cond, "condition")) {
[16:04:43.030]                         if (!is.null(pattern)) {
[16:04:43.030]                           computeRestarts <- base::computeRestarts
[16:04:43.030]                           grepl <- base::grepl
[16:04:43.030]                           restarts <- computeRestarts(cond)
[16:04:43.030]                           for (restart in restarts) {
[16:04:43.030]                             name <- restart$name
[16:04:43.030]                             if (is.null(name)) 
[16:04:43.030]                               next
[16:04:43.030]                             if (!grepl(pattern, name)) 
[16:04:43.030]                               next
[16:04:43.030]                             invokeRestart(restart)
[16:04:43.030]                             muffled <- TRUE
[16:04:43.030]                             break
[16:04:43.030]                           }
[16:04:43.030]                         }
[16:04:43.030]                       }
[16:04:43.030]                       invisible(muffled)
[16:04:43.030]                     }
[16:04:43.030]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.030]                   }
[16:04:43.030]                 }
[16:04:43.030]             }
[16:04:43.030]         }))
[16:04:43.030]     }, error = function(ex) {
[16:04:43.030]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.030]                 ...future.rng), started = ...future.startTime, 
[16:04:43.030]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.030]             version = "1.8"), class = "FutureResult")
[16:04:43.030]     }, finally = {
[16:04:43.030]         if (!identical(...future.workdir, getwd())) 
[16:04:43.030]             setwd(...future.workdir)
[16:04:43.030]         {
[16:04:43.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.030]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.030]             }
[16:04:43.030]             base::options(...future.oldOptions)
[16:04:43.030]             if (.Platform$OS.type == "windows") {
[16:04:43.030]                 old_names <- names(...future.oldEnvVars)
[16:04:43.030]                 envs <- base::Sys.getenv()
[16:04:43.030]                 names <- names(envs)
[16:04:43.030]                 common <- intersect(names, old_names)
[16:04:43.030]                 added <- setdiff(names, old_names)
[16:04:43.030]                 removed <- setdiff(old_names, names)
[16:04:43.030]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.030]                   envs[common]]
[16:04:43.030]                 NAMES <- toupper(changed)
[16:04:43.030]                 args <- list()
[16:04:43.030]                 for (kk in seq_along(NAMES)) {
[16:04:43.030]                   name <- changed[[kk]]
[16:04:43.030]                   NAME <- NAMES[[kk]]
[16:04:43.030]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.030]                     next
[16:04:43.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.030]                 }
[16:04:43.030]                 NAMES <- toupper(added)
[16:04:43.030]                 for (kk in seq_along(NAMES)) {
[16:04:43.030]                   name <- added[[kk]]
[16:04:43.030]                   NAME <- NAMES[[kk]]
[16:04:43.030]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.030]                     next
[16:04:43.030]                   args[[name]] <- ""
[16:04:43.030]                 }
[16:04:43.030]                 NAMES <- toupper(removed)
[16:04:43.030]                 for (kk in seq_along(NAMES)) {
[16:04:43.030]                   name <- removed[[kk]]
[16:04:43.030]                   NAME <- NAMES[[kk]]
[16:04:43.030]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.030]                     next
[16:04:43.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.030]                 }
[16:04:43.030]                 if (length(args) > 0) 
[16:04:43.030]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.030]             }
[16:04:43.030]             else {
[16:04:43.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.030]             }
[16:04:43.030]             {
[16:04:43.030]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.030]                   0L) {
[16:04:43.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.030]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.030]                   base::options(opts)
[16:04:43.030]                 }
[16:04:43.030]                 {
[16:04:43.030]                   {
[16:04:43.030]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.030]                     NULL
[16:04:43.030]                   }
[16:04:43.030]                   options(future.plan = NULL)
[16:04:43.030]                   if (is.na(NA_character_)) 
[16:04:43.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.030]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:43.030]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:43.030]                     envir = parent.frame()) 
[16:04:43.030]                   {
[16:04:43.030]                     if (is.function(workers)) 
[16:04:43.030]                       workers <- workers()
[16:04:43.030]                     workers <- structure(as.integer(workers), 
[16:04:43.030]                       class = class(workers))
[16:04:43.030]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:43.030]                       workers >= 1)
[16:04:43.030]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:43.030]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:43.030]                     }
[16:04:43.030]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:43.030]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:43.030]                       envir = envir)
[16:04:43.030]                     if (!future$lazy) 
[16:04:43.030]                       future <- run(future)
[16:04:43.030]                     invisible(future)
[16:04:43.030]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.030]                 }
[16:04:43.030]             }
[16:04:43.030]         }
[16:04:43.030]     })
[16:04:43.030]     if (TRUE) {
[16:04:43.030]         base::sink(type = "output", split = FALSE)
[16:04:43.030]         if (TRUE) {
[16:04:43.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.030]         }
[16:04:43.030]         else {
[16:04:43.030]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.030]         }
[16:04:43.030]         base::close(...future.stdout)
[16:04:43.030]         ...future.stdout <- NULL
[16:04:43.030]     }
[16:04:43.030]     ...future.result$conditions <- ...future.conditions
[16:04:43.030]     ...future.result$finished <- base::Sys.time()
[16:04:43.030]     ...future.result
[16:04:43.030] }
[16:04:43.033] MultisessionFuture started
[16:04:43.033] - Launch lazy future ... done
[16:04:43.033] run() for ‘MultisessionFuture’ ... done
[16:04:43.033] getGlobalsAndPackages() ...
[16:04:43.033] Searching for globals...
[16:04:43.034] 
[16:04:43.034] Searching for globals ... DONE
[16:04:43.034] - globals: [0] <none>
[16:04:43.034] getGlobalsAndPackages() ... DONE
[16:04:43.034] run() for ‘Future’ ...
[16:04:43.034] - state: ‘created’
[16:04:43.034] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.048] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.048] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:43.048]   - Field: ‘node’
[16:04:43.048]   - Field: ‘label’
[16:04:43.048]   - Field: ‘local’
[16:04:43.048]   - Field: ‘owner’
[16:04:43.048]   - Field: ‘envir’
[16:04:43.048]   - Field: ‘workers’
[16:04:43.049]   - Field: ‘packages’
[16:04:43.049]   - Field: ‘gc’
[16:04:43.049]   - Field: ‘conditions’
[16:04:43.049]   - Field: ‘persistent’
[16:04:43.049]   - Field: ‘expr’
[16:04:43.049]   - Field: ‘uuid’
[16:04:43.049]   - Field: ‘seed’
[16:04:43.049]   - Field: ‘version’
[16:04:43.049]   - Field: ‘result’
[16:04:43.049]   - Field: ‘asynchronous’
[16:04:43.049]   - Field: ‘calls’
[16:04:43.049]   - Field: ‘globals’
[16:04:43.050]   - Field: ‘stdout’
[16:04:43.050]   - Field: ‘earlySignal’
[16:04:43.050]   - Field: ‘lazy’
[16:04:43.050]   - Field: ‘state’
[16:04:43.050] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:43.050] - Launch lazy future ...
[16:04:43.050] Packages needed by the future expression (n = 0): <none>
[16:04:43.050] Packages needed by future strategies (n = 0): <none>
[16:04:43.051] {
[16:04:43.051]     {
[16:04:43.051]         {
[16:04:43.051]             ...future.startTime <- base::Sys.time()
[16:04:43.051]             {
[16:04:43.051]                 {
[16:04:43.051]                   {
[16:04:43.051]                     {
[16:04:43.051]                       base::local({
[16:04:43.051]                         has_future <- base::requireNamespace("future", 
[16:04:43.051]                           quietly = TRUE)
[16:04:43.051]                         if (has_future) {
[16:04:43.051]                           ns <- base::getNamespace("future")
[16:04:43.051]                           version <- ns[[".package"]][["version"]]
[16:04:43.051]                           if (is.null(version)) 
[16:04:43.051]                             version <- utils::packageVersion("future")
[16:04:43.051]                         }
[16:04:43.051]                         else {
[16:04:43.051]                           version <- NULL
[16:04:43.051]                         }
[16:04:43.051]                         if (!has_future || version < "1.8.0") {
[16:04:43.051]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.051]                             "", base::R.version$version.string), 
[16:04:43.051]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.051]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.051]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.051]                               "release", "version")], collapse = " "), 
[16:04:43.051]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.051]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.051]                             info)
[16:04:43.051]                           info <- base::paste(info, collapse = "; ")
[16:04:43.051]                           if (!has_future) {
[16:04:43.051]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.051]                               info)
[16:04:43.051]                           }
[16:04:43.051]                           else {
[16:04:43.051]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.051]                               info, version)
[16:04:43.051]                           }
[16:04:43.051]                           base::stop(msg)
[16:04:43.051]                         }
[16:04:43.051]                       })
[16:04:43.051]                     }
[16:04:43.051]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.051]                     base::options(mc.cores = 1L)
[16:04:43.051]                   }
[16:04:43.051]                   options(future.plan = NULL)
[16:04:43.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.051]                 }
[16:04:43.051]                 ...future.workdir <- getwd()
[16:04:43.051]             }
[16:04:43.051]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.051]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.051]         }
[16:04:43.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.051]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.051]             base::names(...future.oldOptions))
[16:04:43.051]     }
[16:04:43.051]     if (FALSE) {
[16:04:43.051]     }
[16:04:43.051]     else {
[16:04:43.051]         if (TRUE) {
[16:04:43.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.051]                 open = "w")
[16:04:43.051]         }
[16:04:43.051]         else {
[16:04:43.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.051]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.051]         }
[16:04:43.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.051]             base::sink(type = "output", split = FALSE)
[16:04:43.051]             base::close(...future.stdout)
[16:04:43.051]         }, add = TRUE)
[16:04:43.051]     }
[16:04:43.051]     ...future.frame <- base::sys.nframe()
[16:04:43.051]     ...future.conditions <- base::list()
[16:04:43.051]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.051]     if (FALSE) {
[16:04:43.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.051]     }
[16:04:43.051]     ...future.result <- base::tryCatch({
[16:04:43.051]         base::withCallingHandlers({
[16:04:43.051]             ...future.value <- base::withVisible(base::local({
[16:04:43.051]                 ...future.makeSendCondition <- base::local({
[16:04:43.051]                   sendCondition <- NULL
[16:04:43.051]                   function(frame = 1L) {
[16:04:43.051]                     if (is.function(sendCondition)) 
[16:04:43.051]                       return(sendCondition)
[16:04:43.051]                     ns <- getNamespace("parallel")
[16:04:43.051]                     if (exists("sendData", mode = "function", 
[16:04:43.051]                       envir = ns)) {
[16:04:43.051]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:43.051]                         envir = ns)
[16:04:43.051]                       envir <- sys.frame(frame)
[16:04:43.051]                       master <- NULL
[16:04:43.051]                       while (!identical(envir, .GlobalEnv) && 
[16:04:43.051]                         !identical(envir, emptyenv())) {
[16:04:43.051]                         if (exists("master", mode = "list", envir = envir, 
[16:04:43.051]                           inherits = FALSE)) {
[16:04:43.051]                           master <- get("master", mode = "list", 
[16:04:43.051]                             envir = envir, inherits = FALSE)
[16:04:43.051]                           if (inherits(master, c("SOCKnode", 
[16:04:43.051]                             "SOCK0node"))) {
[16:04:43.051]                             sendCondition <<- function(cond) {
[16:04:43.051]                               data <- list(type = "VALUE", value = cond, 
[16:04:43.051]                                 success = TRUE)
[16:04:43.051]                               parallel_sendData(master, data)
[16:04:43.051]                             }
[16:04:43.051]                             return(sendCondition)
[16:04:43.051]                           }
[16:04:43.051]                         }
[16:04:43.051]                         frame <- frame + 1L
[16:04:43.051]                         envir <- sys.frame(frame)
[16:04:43.051]                       }
[16:04:43.051]                     }
[16:04:43.051]                     sendCondition <<- function(cond) NULL
[16:04:43.051]                   }
[16:04:43.051]                 })
[16:04:43.051]                 withCallingHandlers({
[16:04:43.051]                   NULL
[16:04:43.051]                 }, immediateCondition = function(cond) {
[16:04:43.051]                   sendCondition <- ...future.makeSendCondition()
[16:04:43.051]                   sendCondition(cond)
[16:04:43.051]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.051]                   {
[16:04:43.051]                     inherits <- base::inherits
[16:04:43.051]                     invokeRestart <- base::invokeRestart
[16:04:43.051]                     is.null <- base::is.null
[16:04:43.051]                     muffled <- FALSE
[16:04:43.051]                     if (inherits(cond, "message")) {
[16:04:43.051]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.051]                       if (muffled) 
[16:04:43.051]                         invokeRestart("muffleMessage")
[16:04:43.051]                     }
[16:04:43.051]                     else if (inherits(cond, "warning")) {
[16:04:43.051]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.051]                       if (muffled) 
[16:04:43.051]                         invokeRestart("muffleWarning")
[16:04:43.051]                     }
[16:04:43.051]                     else if (inherits(cond, "condition")) {
[16:04:43.051]                       if (!is.null(pattern)) {
[16:04:43.051]                         computeRestarts <- base::computeRestarts
[16:04:43.051]                         grepl <- base::grepl
[16:04:43.051]                         restarts <- computeRestarts(cond)
[16:04:43.051]                         for (restart in restarts) {
[16:04:43.051]                           name <- restart$name
[16:04:43.051]                           if (is.null(name)) 
[16:04:43.051]                             next
[16:04:43.051]                           if (!grepl(pattern, name)) 
[16:04:43.051]                             next
[16:04:43.051]                           invokeRestart(restart)
[16:04:43.051]                           muffled <- TRUE
[16:04:43.051]                           break
[16:04:43.051]                         }
[16:04:43.051]                       }
[16:04:43.051]                     }
[16:04:43.051]                     invisible(muffled)
[16:04:43.051]                   }
[16:04:43.051]                   muffleCondition(cond)
[16:04:43.051]                 })
[16:04:43.051]             }))
[16:04:43.051]             future::FutureResult(value = ...future.value$value, 
[16:04:43.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.051]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.051]                     ...future.globalenv.names))
[16:04:43.051]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.051]         }, condition = base::local({
[16:04:43.051]             c <- base::c
[16:04:43.051]             inherits <- base::inherits
[16:04:43.051]             invokeRestart <- base::invokeRestart
[16:04:43.051]             length <- base::length
[16:04:43.051]             list <- base::list
[16:04:43.051]             seq.int <- base::seq.int
[16:04:43.051]             signalCondition <- base::signalCondition
[16:04:43.051]             sys.calls <- base::sys.calls
[16:04:43.051]             `[[` <- base::`[[`
[16:04:43.051]             `+` <- base::`+`
[16:04:43.051]             `<<-` <- base::`<<-`
[16:04:43.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.051]                   3L)]
[16:04:43.051]             }
[16:04:43.051]             function(cond) {
[16:04:43.051]                 is_error <- inherits(cond, "error")
[16:04:43.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.051]                   NULL)
[16:04:43.051]                 if (is_error) {
[16:04:43.051]                   sessionInformation <- function() {
[16:04:43.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.051]                       search = base::search(), system = base::Sys.info())
[16:04:43.051]                   }
[16:04:43.051]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.051]                     cond$call), session = sessionInformation(), 
[16:04:43.051]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.051]                   signalCondition(cond)
[16:04:43.051]                 }
[16:04:43.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.051]                 "immediateCondition"))) {
[16:04:43.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.051]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.051]                   if (TRUE && !signal) {
[16:04:43.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.051]                     {
[16:04:43.051]                       inherits <- base::inherits
[16:04:43.051]                       invokeRestart <- base::invokeRestart
[16:04:43.051]                       is.null <- base::is.null
[16:04:43.051]                       muffled <- FALSE
[16:04:43.051]                       if (inherits(cond, "message")) {
[16:04:43.051]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.051]                         if (muffled) 
[16:04:43.051]                           invokeRestart("muffleMessage")
[16:04:43.051]                       }
[16:04:43.051]                       else if (inherits(cond, "warning")) {
[16:04:43.051]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.051]                         if (muffled) 
[16:04:43.051]                           invokeRestart("muffleWarning")
[16:04:43.051]                       }
[16:04:43.051]                       else if (inherits(cond, "condition")) {
[16:04:43.051]                         if (!is.null(pattern)) {
[16:04:43.051]                           computeRestarts <- base::computeRestarts
[16:04:43.051]                           grepl <- base::grepl
[16:04:43.051]                           restarts <- computeRestarts(cond)
[16:04:43.051]                           for (restart in restarts) {
[16:04:43.051]                             name <- restart$name
[16:04:43.051]                             if (is.null(name)) 
[16:04:43.051]                               next
[16:04:43.051]                             if (!grepl(pattern, name)) 
[16:04:43.051]                               next
[16:04:43.051]                             invokeRestart(restart)
[16:04:43.051]                             muffled <- TRUE
[16:04:43.051]                             break
[16:04:43.051]                           }
[16:04:43.051]                         }
[16:04:43.051]                       }
[16:04:43.051]                       invisible(muffled)
[16:04:43.051]                     }
[16:04:43.051]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.051]                   }
[16:04:43.051]                 }
[16:04:43.051]                 else {
[16:04:43.051]                   if (TRUE) {
[16:04:43.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.051]                     {
[16:04:43.051]                       inherits <- base::inherits
[16:04:43.051]                       invokeRestart <- base::invokeRestart
[16:04:43.051]                       is.null <- base::is.null
[16:04:43.051]                       muffled <- FALSE
[16:04:43.051]                       if (inherits(cond, "message")) {
[16:04:43.051]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.051]                         if (muffled) 
[16:04:43.051]                           invokeRestart("muffleMessage")
[16:04:43.051]                       }
[16:04:43.051]                       else if (inherits(cond, "warning")) {
[16:04:43.051]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.051]                         if (muffled) 
[16:04:43.051]                           invokeRestart("muffleWarning")
[16:04:43.051]                       }
[16:04:43.051]                       else if (inherits(cond, "condition")) {
[16:04:43.051]                         if (!is.null(pattern)) {
[16:04:43.051]                           computeRestarts <- base::computeRestarts
[16:04:43.051]                           grepl <- base::grepl
[16:04:43.051]                           restarts <- computeRestarts(cond)
[16:04:43.051]                           for (restart in restarts) {
[16:04:43.051]                             name <- restart$name
[16:04:43.051]                             if (is.null(name)) 
[16:04:43.051]                               next
[16:04:43.051]                             if (!grepl(pattern, name)) 
[16:04:43.051]                               next
[16:04:43.051]                             invokeRestart(restart)
[16:04:43.051]                             muffled <- TRUE
[16:04:43.051]                             break
[16:04:43.051]                           }
[16:04:43.051]                         }
[16:04:43.051]                       }
[16:04:43.051]                       invisible(muffled)
[16:04:43.051]                     }
[16:04:43.051]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.051]                   }
[16:04:43.051]                 }
[16:04:43.051]             }
[16:04:43.051]         }))
[16:04:43.051]     }, error = function(ex) {
[16:04:43.051]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.051]                 ...future.rng), started = ...future.startTime, 
[16:04:43.051]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.051]             version = "1.8"), class = "FutureResult")
[16:04:43.051]     }, finally = {
[16:04:43.051]         if (!identical(...future.workdir, getwd())) 
[16:04:43.051]             setwd(...future.workdir)
[16:04:43.051]         {
[16:04:43.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.051]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.051]             }
[16:04:43.051]             base::options(...future.oldOptions)
[16:04:43.051]             if (.Platform$OS.type == "windows") {
[16:04:43.051]                 old_names <- names(...future.oldEnvVars)
[16:04:43.051]                 envs <- base::Sys.getenv()
[16:04:43.051]                 names <- names(envs)
[16:04:43.051]                 common <- intersect(names, old_names)
[16:04:43.051]                 added <- setdiff(names, old_names)
[16:04:43.051]                 removed <- setdiff(old_names, names)
[16:04:43.051]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.051]                   envs[common]]
[16:04:43.051]                 NAMES <- toupper(changed)
[16:04:43.051]                 args <- list()
[16:04:43.051]                 for (kk in seq_along(NAMES)) {
[16:04:43.051]                   name <- changed[[kk]]
[16:04:43.051]                   NAME <- NAMES[[kk]]
[16:04:43.051]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.051]                     next
[16:04:43.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.051]                 }
[16:04:43.051]                 NAMES <- toupper(added)
[16:04:43.051]                 for (kk in seq_along(NAMES)) {
[16:04:43.051]                   name <- added[[kk]]
[16:04:43.051]                   NAME <- NAMES[[kk]]
[16:04:43.051]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.051]                     next
[16:04:43.051]                   args[[name]] <- ""
[16:04:43.051]                 }
[16:04:43.051]                 NAMES <- toupper(removed)
[16:04:43.051]                 for (kk in seq_along(NAMES)) {
[16:04:43.051]                   name <- removed[[kk]]
[16:04:43.051]                   NAME <- NAMES[[kk]]
[16:04:43.051]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.051]                     next
[16:04:43.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.051]                 }
[16:04:43.051]                 if (length(args) > 0) 
[16:04:43.051]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.051]             }
[16:04:43.051]             else {
[16:04:43.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.051]             }
[16:04:43.051]             {
[16:04:43.051]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.051]                   0L) {
[16:04:43.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.051]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.051]                   base::options(opts)
[16:04:43.051]                 }
[16:04:43.051]                 {
[16:04:43.051]                   {
[16:04:43.051]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.051]                     NULL
[16:04:43.051]                   }
[16:04:43.051]                   options(future.plan = NULL)
[16:04:43.051]                   if (is.na(NA_character_)) 
[16:04:43.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.051]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:43.051]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:43.051]                     envir = parent.frame()) 
[16:04:43.051]                   {
[16:04:43.051]                     if (is.function(workers)) 
[16:04:43.051]                       workers <- workers()
[16:04:43.051]                     workers <- structure(as.integer(workers), 
[16:04:43.051]                       class = class(workers))
[16:04:43.051]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:43.051]                       workers >= 1)
[16:04:43.051]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:43.051]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:43.051]                     }
[16:04:43.051]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:43.051]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:43.051]                       envir = envir)
[16:04:43.051]                     if (!future$lazy) 
[16:04:43.051]                       future <- run(future)
[16:04:43.051]                     invisible(future)
[16:04:43.051]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.051]                 }
[16:04:43.051]             }
[16:04:43.051]         }
[16:04:43.051]     })
[16:04:43.051]     if (TRUE) {
[16:04:43.051]         base::sink(type = "output", split = FALSE)
[16:04:43.051]         if (TRUE) {
[16:04:43.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.051]         }
[16:04:43.051]         else {
[16:04:43.051]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.051]         }
[16:04:43.051]         base::close(...future.stdout)
[16:04:43.051]         ...future.stdout <- NULL
[16:04:43.051]     }
[16:04:43.051]     ...future.result$conditions <- ...future.conditions
[16:04:43.051]     ...future.result$finished <- base::Sys.time()
[16:04:43.051]     ...future.result
[16:04:43.051] }
[16:04:43.054] MultisessionFuture started
[16:04:43.054] - Launch lazy future ... done
[16:04:43.054] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874e413af8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874dd39030> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874e413af8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55874dd39030> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:04:43.082] resolve() on list ...
[16:04:43.082]  recursive: 0
[16:04:43.083]  length: 6
[16:04:43.083]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:04:43.083] signalConditionsASAP(numeric, pos=1) ...
[16:04:43.083] - nx: 6
[16:04:43.083] - relay: TRUE
[16:04:43.083] - stdout: TRUE
[16:04:43.083] - signal: TRUE
[16:04:43.083] - resignal: FALSE
[16:04:43.083] - force: TRUE
[16:04:43.083] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:43.084] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:43.084]  - until=2
[16:04:43.084]  - relaying element #2
[16:04:43.084] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:43.084] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:43.084] signalConditionsASAP(NULL, pos=1) ... done
[16:04:43.084]  length: 5 (resolved future 1)
[16:04:43.084] receiveMessageFromWorker() for ClusterFuture ...
[16:04:43.085] - Validating connection of MultisessionFuture
[16:04:43.085] - received message: FutureResult
[16:04:43.085] - Received FutureResult
[16:04:43.085] - Erased future from FutureRegistry
[16:04:43.085] result() for ClusterFuture ...
[16:04:43.085] - result already collected: FutureResult
[16:04:43.085] result() for ClusterFuture ... done
[16:04:43.085] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:43.085] Future #2
[16:04:43.086] result() for ClusterFuture ...
[16:04:43.086] - result already collected: FutureResult
[16:04:43.086] result() for ClusterFuture ... done
[16:04:43.086] result() for ClusterFuture ...
[16:04:43.086] - result already collected: FutureResult
[16:04:43.086] result() for ClusterFuture ... done
[16:04:43.086] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:43.086] - nx: 6
[16:04:43.086] - relay: TRUE
[16:04:43.086] - stdout: TRUE
[16:04:43.086] - signal: TRUE
[16:04:43.086] - resignal: FALSE
[16:04:43.087] - force: TRUE
[16:04:43.087] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:43.087] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:43.087]  - until=2
[16:04:43.087]  - relaying element #2
[16:04:43.087] result() for ClusterFuture ...
[16:04:43.087] - result already collected: FutureResult
[16:04:43.087] result() for ClusterFuture ... done
[16:04:43.087] result() for ClusterFuture ...
[16:04:43.087] - result already collected: FutureResult
[16:04:43.087] result() for ClusterFuture ... done
[16:04:43.088] result() for ClusterFuture ...
[16:04:43.088] - result already collected: FutureResult
[16:04:43.088] result() for ClusterFuture ... done
[16:04:43.088] result() for ClusterFuture ...
[16:04:43.088] - result already collected: FutureResult
[16:04:43.088] result() for ClusterFuture ... done
[16:04:43.088] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:43.088] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:43.088] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:43.088]  length: 4 (resolved future 2)
[16:04:43.099] signalConditionsASAP(NULL, pos=4) ...
[16:04:43.099] - nx: 6
[16:04:43.099] - relay: TRUE
[16:04:43.099] - stdout: TRUE
[16:04:43.099] - signal: TRUE
[16:04:43.099] - resignal: FALSE
[16:04:43.099] - force: TRUE
[16:04:43.100] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:43.100] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:43.100]  - until=5
[16:04:43.100]  - relaying element #3
[16:04:43.100]  - relaying element #5
[16:04:43.100] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:04:43.100] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:43.100] signalConditionsASAP(NULL, pos=4) ... done
[16:04:43.100]  length: 3 (resolved future 4)
[16:04:43.100] signalConditionsASAP(NULL, pos=5) ...
[16:04:43.100] - nx: 6
[16:04:43.100] - relay: TRUE
[16:04:43.101] - stdout: TRUE
[16:04:43.101] - signal: TRUE
[16:04:43.101] - resignal: FALSE
[16:04:43.101] - force: TRUE
[16:04:43.101] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:04:43.101] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:43.101]  - until=6
[16:04:43.101]  - relaying element #3
[16:04:43.101]  - relaying element #6
[16:04:43.101] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:04:43.101] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:43.101] signalConditionsASAP(NULL, pos=5) ... done
[16:04:43.102]  length: 2 (resolved future 5)
[16:04:43.102] signalConditionsASAP(numeric, pos=6) ...
[16:04:43.102] - nx: 6
[16:04:43.102] - relay: TRUE
[16:04:43.102] - stdout: TRUE
[16:04:43.102] - signal: TRUE
[16:04:43.102] - resignal: FALSE
[16:04:43.102] - force: TRUE
[16:04:43.102] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:04:43.102] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:43.102]  - until=6
[16:04:43.102]  - relaying element #3
[16:04:43.103] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:04:43.103] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:43.103] signalConditionsASAP(NULL, pos=6) ... done
[16:04:43.103]  length: 1 (resolved future 6)
[16:04:43.113] receiveMessageFromWorker() for ClusterFuture ...
[16:04:43.114] - Validating connection of MultisessionFuture
[16:04:43.114] - received message: FutureResult
[16:04:43.114] - Received FutureResult
[16:04:43.114] - Erased future from FutureRegistry
[16:04:43.114] result() for ClusterFuture ...
[16:04:43.114] - result already collected: FutureResult
[16:04:43.114] result() for ClusterFuture ... done
[16:04:43.114] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:43.114] Future #3
[16:04:43.115] result() for ClusterFuture ...
[16:04:43.115] - result already collected: FutureResult
[16:04:43.115] result() for ClusterFuture ... done
[16:04:43.115] result() for ClusterFuture ...
[16:04:43.115] - result already collected: FutureResult
[16:04:43.115] result() for ClusterFuture ... done
[16:04:43.115] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:43.115] - nx: 6
[16:04:43.115] - relay: TRUE
[16:04:43.115] - stdout: TRUE
[16:04:43.115] - signal: TRUE
[16:04:43.116] - resignal: FALSE
[16:04:43.116] - force: TRUE
[16:04:43.116] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:04:43.116] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:43.116]  - until=6
[16:04:43.116]  - relaying element #3
[16:04:43.116] result() for ClusterFuture ...
[16:04:43.116] - result already collected: FutureResult
[16:04:43.116] result() for ClusterFuture ... done
[16:04:43.116] result() for ClusterFuture ...
[16:04:43.116] - result already collected: FutureResult
[16:04:43.116] result() for ClusterFuture ... done
[16:04:43.117] result() for ClusterFuture ...
[16:04:43.117] - result already collected: FutureResult
[16:04:43.117] result() for ClusterFuture ... done
[16:04:43.117] result() for ClusterFuture ...
[16:04:43.117] - result already collected: FutureResult
[16:04:43.117] result() for ClusterFuture ... done
[16:04:43.117] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:43.117] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:43.117] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:43.117]  length: 0 (resolved future 3)
[16:04:43.117] Relaying remaining futures
[16:04:43.118] signalConditionsASAP(NULL, pos=0) ...
[16:04:43.118] - nx: 6
[16:04:43.118] - relay: TRUE
[16:04:43.118] - stdout: TRUE
[16:04:43.118] - signal: TRUE
[16:04:43.118] - resignal: FALSE
[16:04:43.118] - force: TRUE
[16:04:43.118] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:43.118] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:04:43.118] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:43.118] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:43.119] signalConditionsASAP(NULL, pos=0) ... done
[16:04:43.119] resolve() on list ... DONE
[16:04:43.119] result() for ClusterFuture ...
[16:04:43.119] - result already collected: FutureResult
[16:04:43.119] result() for ClusterFuture ... done
[16:04:43.119] result() for ClusterFuture ...
[16:04:43.119] - result already collected: FutureResult
[16:04:43.119] result() for ClusterFuture ... done
[16:04:43.119] result() for ClusterFuture ...
[16:04:43.119] - result already collected: FutureResult
[16:04:43.119] result() for ClusterFuture ... done
[16:04:43.120] result() for ClusterFuture ...
[16:04:43.120] - result already collected: FutureResult
[16:04:43.120] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[16:04:43.124] plan(): Setting new future strategy stack:
[16:04:43.124] List of future strategies:
[16:04:43.124] 1. multicore:
[16:04:43.124]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.124]    - tweaked: FALSE
[16:04:43.124]    - call: plan(strategy)
[16:04:43.128] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:04:43.128] getGlobalsAndPackages() ...
[16:04:43.128] Searching for globals...
[16:04:43.129] 
[16:04:43.129] Searching for globals ... DONE
[16:04:43.129] - globals: [0] <none>
[16:04:43.129] getGlobalsAndPackages() ... DONE
[16:04:43.129] run() for ‘Future’ ...
[16:04:43.129] - state: ‘created’
[16:04:43.130] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.133] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.133] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.133]   - Field: ‘label’
[16:04:43.133]   - Field: ‘local’
[16:04:43.134]   - Field: ‘owner’
[16:04:43.134]   - Field: ‘envir’
[16:04:43.134]   - Field: ‘workers’
[16:04:43.134]   - Field: ‘packages’
[16:04:43.134]   - Field: ‘gc’
[16:04:43.134]   - Field: ‘job’
[16:04:43.134]   - Field: ‘conditions’
[16:04:43.134]   - Field: ‘expr’
[16:04:43.134]   - Field: ‘uuid’
[16:04:43.134]   - Field: ‘seed’
[16:04:43.134]   - Field: ‘version’
[16:04:43.135]   - Field: ‘result’
[16:04:43.135]   - Field: ‘asynchronous’
[16:04:43.135]   - Field: ‘calls’
[16:04:43.135]   - Field: ‘globals’
[16:04:43.135]   - Field: ‘stdout’
[16:04:43.135]   - Field: ‘earlySignal’
[16:04:43.135]   - Field: ‘lazy’
[16:04:43.135]   - Field: ‘state’
[16:04:43.135] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.136] - Launch lazy future ...
[16:04:43.136] Packages needed by the future expression (n = 0): <none>
[16:04:43.136] Packages needed by future strategies (n = 0): <none>
[16:04:43.136] {
[16:04:43.136]     {
[16:04:43.136]         {
[16:04:43.136]             ...future.startTime <- base::Sys.time()
[16:04:43.136]             {
[16:04:43.136]                 {
[16:04:43.136]                   {
[16:04:43.136]                     {
[16:04:43.136]                       base::local({
[16:04:43.136]                         has_future <- base::requireNamespace("future", 
[16:04:43.136]                           quietly = TRUE)
[16:04:43.136]                         if (has_future) {
[16:04:43.136]                           ns <- base::getNamespace("future")
[16:04:43.136]                           version <- ns[[".package"]][["version"]]
[16:04:43.136]                           if (is.null(version)) 
[16:04:43.136]                             version <- utils::packageVersion("future")
[16:04:43.136]                         }
[16:04:43.136]                         else {
[16:04:43.136]                           version <- NULL
[16:04:43.136]                         }
[16:04:43.136]                         if (!has_future || version < "1.8.0") {
[16:04:43.136]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.136]                             "", base::R.version$version.string), 
[16:04:43.136]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.136]                               "release", "version")], collapse = " "), 
[16:04:43.136]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.136]                             info)
[16:04:43.136]                           info <- base::paste(info, collapse = "; ")
[16:04:43.136]                           if (!has_future) {
[16:04:43.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.136]                               info)
[16:04:43.136]                           }
[16:04:43.136]                           else {
[16:04:43.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.136]                               info, version)
[16:04:43.136]                           }
[16:04:43.136]                           base::stop(msg)
[16:04:43.136]                         }
[16:04:43.136]                       })
[16:04:43.136]                     }
[16:04:43.136]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.136]                     base::options(mc.cores = 1L)
[16:04:43.136]                   }
[16:04:43.136]                   options(future.plan = NULL)
[16:04:43.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.136]                 }
[16:04:43.136]                 ...future.workdir <- getwd()
[16:04:43.136]             }
[16:04:43.136]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.136]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.136]         }
[16:04:43.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.136]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.136]             base::names(...future.oldOptions))
[16:04:43.136]     }
[16:04:43.136]     if (FALSE) {
[16:04:43.136]     }
[16:04:43.136]     else {
[16:04:43.136]         if (TRUE) {
[16:04:43.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.136]                 open = "w")
[16:04:43.136]         }
[16:04:43.136]         else {
[16:04:43.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.136]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.136]         }
[16:04:43.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.136]             base::sink(type = "output", split = FALSE)
[16:04:43.136]             base::close(...future.stdout)
[16:04:43.136]         }, add = TRUE)
[16:04:43.136]     }
[16:04:43.136]     ...future.frame <- base::sys.nframe()
[16:04:43.136]     ...future.conditions <- base::list()
[16:04:43.136]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.136]     if (FALSE) {
[16:04:43.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.136]     }
[16:04:43.136]     ...future.result <- base::tryCatch({
[16:04:43.136]         base::withCallingHandlers({
[16:04:43.136]             ...future.value <- base::withVisible(base::local({
[16:04:43.136]                 withCallingHandlers({
[16:04:43.136]                   2
[16:04:43.136]                 }, immediateCondition = function(cond) {
[16:04:43.136]                   save_rds <- function (object, pathname, ...) 
[16:04:43.136]                   {
[16:04:43.136]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.136]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.136]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.136]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.136]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.136]                         fi_tmp[["mtime"]])
[16:04:43.136]                     }
[16:04:43.136]                     tryCatch({
[16:04:43.136]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.136]                     }, error = function(ex) {
[16:04:43.136]                       msg <- conditionMessage(ex)
[16:04:43.136]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.136]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.136]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.136]                         fi_tmp[["mtime"]], msg)
[16:04:43.136]                       ex$message <- msg
[16:04:43.136]                       stop(ex)
[16:04:43.136]                     })
[16:04:43.136]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.136]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.136]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.136]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.136]                       fi <- file.info(pathname)
[16:04:43.136]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.136]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.136]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.136]                         fi[["size"]], fi[["mtime"]])
[16:04:43.136]                       stop(msg)
[16:04:43.136]                     }
[16:04:43.136]                     invisible(pathname)
[16:04:43.136]                   }
[16:04:43.136]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.136]                     rootPath = tempdir()) 
[16:04:43.136]                   {
[16:04:43.136]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.136]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.136]                       tmpdir = path, fileext = ".rds")
[16:04:43.136]                     save_rds(obj, file)
[16:04:43.136]                   }
[16:04:43.136]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.136]                   {
[16:04:43.136]                     inherits <- base::inherits
[16:04:43.136]                     invokeRestart <- base::invokeRestart
[16:04:43.136]                     is.null <- base::is.null
[16:04:43.136]                     muffled <- FALSE
[16:04:43.136]                     if (inherits(cond, "message")) {
[16:04:43.136]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.136]                       if (muffled) 
[16:04:43.136]                         invokeRestart("muffleMessage")
[16:04:43.136]                     }
[16:04:43.136]                     else if (inherits(cond, "warning")) {
[16:04:43.136]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.136]                       if (muffled) 
[16:04:43.136]                         invokeRestart("muffleWarning")
[16:04:43.136]                     }
[16:04:43.136]                     else if (inherits(cond, "condition")) {
[16:04:43.136]                       if (!is.null(pattern)) {
[16:04:43.136]                         computeRestarts <- base::computeRestarts
[16:04:43.136]                         grepl <- base::grepl
[16:04:43.136]                         restarts <- computeRestarts(cond)
[16:04:43.136]                         for (restart in restarts) {
[16:04:43.136]                           name <- restart$name
[16:04:43.136]                           if (is.null(name)) 
[16:04:43.136]                             next
[16:04:43.136]                           if (!grepl(pattern, name)) 
[16:04:43.136]                             next
[16:04:43.136]                           invokeRestart(restart)
[16:04:43.136]                           muffled <- TRUE
[16:04:43.136]                           break
[16:04:43.136]                         }
[16:04:43.136]                       }
[16:04:43.136]                     }
[16:04:43.136]                     invisible(muffled)
[16:04:43.136]                   }
[16:04:43.136]                   muffleCondition(cond)
[16:04:43.136]                 })
[16:04:43.136]             }))
[16:04:43.136]             future::FutureResult(value = ...future.value$value, 
[16:04:43.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.136]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.136]                     ...future.globalenv.names))
[16:04:43.136]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.136]         }, condition = base::local({
[16:04:43.136]             c <- base::c
[16:04:43.136]             inherits <- base::inherits
[16:04:43.136]             invokeRestart <- base::invokeRestart
[16:04:43.136]             length <- base::length
[16:04:43.136]             list <- base::list
[16:04:43.136]             seq.int <- base::seq.int
[16:04:43.136]             signalCondition <- base::signalCondition
[16:04:43.136]             sys.calls <- base::sys.calls
[16:04:43.136]             `[[` <- base::`[[`
[16:04:43.136]             `+` <- base::`+`
[16:04:43.136]             `<<-` <- base::`<<-`
[16:04:43.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.136]                   3L)]
[16:04:43.136]             }
[16:04:43.136]             function(cond) {
[16:04:43.136]                 is_error <- inherits(cond, "error")
[16:04:43.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.136]                   NULL)
[16:04:43.136]                 if (is_error) {
[16:04:43.136]                   sessionInformation <- function() {
[16:04:43.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.136]                       search = base::search(), system = base::Sys.info())
[16:04:43.136]                   }
[16:04:43.136]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.136]                     cond$call), session = sessionInformation(), 
[16:04:43.136]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.136]                   signalCondition(cond)
[16:04:43.136]                 }
[16:04:43.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.136]                 "immediateCondition"))) {
[16:04:43.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.136]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.136]                   if (TRUE && !signal) {
[16:04:43.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.136]                     {
[16:04:43.136]                       inherits <- base::inherits
[16:04:43.136]                       invokeRestart <- base::invokeRestart
[16:04:43.136]                       is.null <- base::is.null
[16:04:43.136]                       muffled <- FALSE
[16:04:43.136]                       if (inherits(cond, "message")) {
[16:04:43.136]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.136]                         if (muffled) 
[16:04:43.136]                           invokeRestart("muffleMessage")
[16:04:43.136]                       }
[16:04:43.136]                       else if (inherits(cond, "warning")) {
[16:04:43.136]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.136]                         if (muffled) 
[16:04:43.136]                           invokeRestart("muffleWarning")
[16:04:43.136]                       }
[16:04:43.136]                       else if (inherits(cond, "condition")) {
[16:04:43.136]                         if (!is.null(pattern)) {
[16:04:43.136]                           computeRestarts <- base::computeRestarts
[16:04:43.136]                           grepl <- base::grepl
[16:04:43.136]                           restarts <- computeRestarts(cond)
[16:04:43.136]                           for (restart in restarts) {
[16:04:43.136]                             name <- restart$name
[16:04:43.136]                             if (is.null(name)) 
[16:04:43.136]                               next
[16:04:43.136]                             if (!grepl(pattern, name)) 
[16:04:43.136]                               next
[16:04:43.136]                             invokeRestart(restart)
[16:04:43.136]                             muffled <- TRUE
[16:04:43.136]                             break
[16:04:43.136]                           }
[16:04:43.136]                         }
[16:04:43.136]                       }
[16:04:43.136]                       invisible(muffled)
[16:04:43.136]                     }
[16:04:43.136]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.136]                   }
[16:04:43.136]                 }
[16:04:43.136]                 else {
[16:04:43.136]                   if (TRUE) {
[16:04:43.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.136]                     {
[16:04:43.136]                       inherits <- base::inherits
[16:04:43.136]                       invokeRestart <- base::invokeRestart
[16:04:43.136]                       is.null <- base::is.null
[16:04:43.136]                       muffled <- FALSE
[16:04:43.136]                       if (inherits(cond, "message")) {
[16:04:43.136]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.136]                         if (muffled) 
[16:04:43.136]                           invokeRestart("muffleMessage")
[16:04:43.136]                       }
[16:04:43.136]                       else if (inherits(cond, "warning")) {
[16:04:43.136]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.136]                         if (muffled) 
[16:04:43.136]                           invokeRestart("muffleWarning")
[16:04:43.136]                       }
[16:04:43.136]                       else if (inherits(cond, "condition")) {
[16:04:43.136]                         if (!is.null(pattern)) {
[16:04:43.136]                           computeRestarts <- base::computeRestarts
[16:04:43.136]                           grepl <- base::grepl
[16:04:43.136]                           restarts <- computeRestarts(cond)
[16:04:43.136]                           for (restart in restarts) {
[16:04:43.136]                             name <- restart$name
[16:04:43.136]                             if (is.null(name)) 
[16:04:43.136]                               next
[16:04:43.136]                             if (!grepl(pattern, name)) 
[16:04:43.136]                               next
[16:04:43.136]                             invokeRestart(restart)
[16:04:43.136]                             muffled <- TRUE
[16:04:43.136]                             break
[16:04:43.136]                           }
[16:04:43.136]                         }
[16:04:43.136]                       }
[16:04:43.136]                       invisible(muffled)
[16:04:43.136]                     }
[16:04:43.136]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.136]                   }
[16:04:43.136]                 }
[16:04:43.136]             }
[16:04:43.136]         }))
[16:04:43.136]     }, error = function(ex) {
[16:04:43.136]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.136]                 ...future.rng), started = ...future.startTime, 
[16:04:43.136]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.136]             version = "1.8"), class = "FutureResult")
[16:04:43.136]     }, finally = {
[16:04:43.136]         if (!identical(...future.workdir, getwd())) 
[16:04:43.136]             setwd(...future.workdir)
[16:04:43.136]         {
[16:04:43.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.136]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.136]             }
[16:04:43.136]             base::options(...future.oldOptions)
[16:04:43.136]             if (.Platform$OS.type == "windows") {
[16:04:43.136]                 old_names <- names(...future.oldEnvVars)
[16:04:43.136]                 envs <- base::Sys.getenv()
[16:04:43.136]                 names <- names(envs)
[16:04:43.136]                 common <- intersect(names, old_names)
[16:04:43.136]                 added <- setdiff(names, old_names)
[16:04:43.136]                 removed <- setdiff(old_names, names)
[16:04:43.136]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.136]                   envs[common]]
[16:04:43.136]                 NAMES <- toupper(changed)
[16:04:43.136]                 args <- list()
[16:04:43.136]                 for (kk in seq_along(NAMES)) {
[16:04:43.136]                   name <- changed[[kk]]
[16:04:43.136]                   NAME <- NAMES[[kk]]
[16:04:43.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.136]                     next
[16:04:43.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.136]                 }
[16:04:43.136]                 NAMES <- toupper(added)
[16:04:43.136]                 for (kk in seq_along(NAMES)) {
[16:04:43.136]                   name <- added[[kk]]
[16:04:43.136]                   NAME <- NAMES[[kk]]
[16:04:43.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.136]                     next
[16:04:43.136]                   args[[name]] <- ""
[16:04:43.136]                 }
[16:04:43.136]                 NAMES <- toupper(removed)
[16:04:43.136]                 for (kk in seq_along(NAMES)) {
[16:04:43.136]                   name <- removed[[kk]]
[16:04:43.136]                   NAME <- NAMES[[kk]]
[16:04:43.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.136]                     next
[16:04:43.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.136]                 }
[16:04:43.136]                 if (length(args) > 0) 
[16:04:43.136]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.136]             }
[16:04:43.136]             else {
[16:04:43.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.136]             }
[16:04:43.136]             {
[16:04:43.136]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.136]                   0L) {
[16:04:43.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.136]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.136]                   base::options(opts)
[16:04:43.136]                 }
[16:04:43.136]                 {
[16:04:43.136]                   {
[16:04:43.136]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.136]                     NULL
[16:04:43.136]                   }
[16:04:43.136]                   options(future.plan = NULL)
[16:04:43.136]                   if (is.na(NA_character_)) 
[16:04:43.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.136]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.136]                     envir = parent.frame()) 
[16:04:43.136]                   {
[16:04:43.136]                     default_workers <- missing(workers)
[16:04:43.136]                     if (is.function(workers)) 
[16:04:43.136]                       workers <- workers()
[16:04:43.136]                     workers <- structure(as.integer(workers), 
[16:04:43.136]                       class = class(workers))
[16:04:43.136]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.136]                       1L)
[16:04:43.136]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.136]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.136]                       if (default_workers) 
[16:04:43.136]                         supportsMulticore(warn = TRUE)
[16:04:43.136]                       return(sequential(..., envir = envir))
[16:04:43.136]                     }
[16:04:43.136]                     oopts <- options(mc.cores = workers)
[16:04:43.136]                     on.exit(options(oopts))
[16:04:43.136]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.136]                       envir = envir)
[16:04:43.136]                     if (!future$lazy) 
[16:04:43.136]                       future <- run(future)
[16:04:43.136]                     invisible(future)
[16:04:43.136]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.136]                 }
[16:04:43.136]             }
[16:04:43.136]         }
[16:04:43.136]     })
[16:04:43.136]     if (TRUE) {
[16:04:43.136]         base::sink(type = "output", split = FALSE)
[16:04:43.136]         if (TRUE) {
[16:04:43.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.136]         }
[16:04:43.136]         else {
[16:04:43.136]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.136]         }
[16:04:43.136]         base::close(...future.stdout)
[16:04:43.136]         ...future.stdout <- NULL
[16:04:43.136]     }
[16:04:43.136]     ...future.result$conditions <- ...future.conditions
[16:04:43.136]     ...future.result$finished <- base::Sys.time()
[16:04:43.136]     ...future.result
[16:04:43.136] }
[16:04:43.139] requestCore(): workers = 2
[16:04:43.141] MulticoreFuture started
[16:04:43.141] - Launch lazy future ... done
[16:04:43.141] run() for ‘MulticoreFuture’ ... done
[16:04:43.142] getGlobalsAndPackages() ...
[16:04:43.142] Searching for globals...
[16:04:43.142] plan(): Setting new future strategy stack:
[16:04:43.143] 
[16:04:43.142] List of future strategies:
[16:04:43.142] 1. sequential:
[16:04:43.142]    - args: function (..., envir = parent.frame())
[16:04:43.142]    - tweaked: FALSE
[16:04:43.142]    - call: NULL
[16:04:43.143] Searching for globals ... DONE
[16:04:43.143] - globals: [0] <none>
[16:04:43.143] plan(): nbrOfWorkers() = 1
[16:04:43.143] getGlobalsAndPackages() ... DONE
[16:04:43.144] run() for ‘Future’ ...
[16:04:43.144] - state: ‘created’
[16:04:43.144] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.145] plan(): Setting new future strategy stack:
[16:04:43.146] List of future strategies:
[16:04:43.146] 1. multicore:
[16:04:43.146]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.146]    - tweaked: FALSE
[16:04:43.146]    - call: plan(strategy)
[16:04:43.149] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.149] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.150]   - Field: ‘label’
[16:04:43.150]   - Field: ‘local’
[16:04:43.150] plan(): nbrOfWorkers() = 2
[16:04:43.150]   - Field: ‘owner’
[16:04:43.150]   - Field: ‘envir’
[16:04:43.150]   - Field: ‘workers’
[16:04:43.150]   - Field: ‘packages’
[16:04:43.150]   - Field: ‘gc’
[16:04:43.151]   - Field: ‘job’
[16:04:43.151]   - Field: ‘conditions’
[16:04:43.151]   - Field: ‘expr’
[16:04:43.151]   - Field: ‘uuid’
[16:04:43.151]   - Field: ‘seed’
[16:04:43.151]   - Field: ‘version’
[16:04:43.152]   - Field: ‘result’
[16:04:43.152]   - Field: ‘asynchronous’
[16:04:43.152]   - Field: ‘calls’
[16:04:43.152]   - Field: ‘globals’
[16:04:43.152]   - Field: ‘stdout’
[16:04:43.152]   - Field: ‘earlySignal’
[16:04:43.153]   - Field: ‘lazy’
[16:04:43.153]   - Field: ‘state’
[16:04:43.153] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.153] - Launch lazy future ...
[16:04:43.154] Packages needed by the future expression (n = 0): <none>
[16:04:43.154] Packages needed by future strategies (n = 0): <none>
[16:04:43.155] {
[16:04:43.155]     {
[16:04:43.155]         {
[16:04:43.155]             ...future.startTime <- base::Sys.time()
[16:04:43.155]             {
[16:04:43.155]                 {
[16:04:43.155]                   {
[16:04:43.155]                     {
[16:04:43.155]                       base::local({
[16:04:43.155]                         has_future <- base::requireNamespace("future", 
[16:04:43.155]                           quietly = TRUE)
[16:04:43.155]                         if (has_future) {
[16:04:43.155]                           ns <- base::getNamespace("future")
[16:04:43.155]                           version <- ns[[".package"]][["version"]]
[16:04:43.155]                           if (is.null(version)) 
[16:04:43.155]                             version <- utils::packageVersion("future")
[16:04:43.155]                         }
[16:04:43.155]                         else {
[16:04:43.155]                           version <- NULL
[16:04:43.155]                         }
[16:04:43.155]                         if (!has_future || version < "1.8.0") {
[16:04:43.155]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.155]                             "", base::R.version$version.string), 
[16:04:43.155]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.155]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.155]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.155]                               "release", "version")], collapse = " "), 
[16:04:43.155]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.155]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.155]                             info)
[16:04:43.155]                           info <- base::paste(info, collapse = "; ")
[16:04:43.155]                           if (!has_future) {
[16:04:43.155]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.155]                               info)
[16:04:43.155]                           }
[16:04:43.155]                           else {
[16:04:43.155]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.155]                               info, version)
[16:04:43.155]                           }
[16:04:43.155]                           base::stop(msg)
[16:04:43.155]                         }
[16:04:43.155]                       })
[16:04:43.155]                     }
[16:04:43.155]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.155]                     base::options(mc.cores = 1L)
[16:04:43.155]                   }
[16:04:43.155]                   options(future.plan = NULL)
[16:04:43.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.155]                 }
[16:04:43.155]                 ...future.workdir <- getwd()
[16:04:43.155]             }
[16:04:43.155]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.155]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.155]         }
[16:04:43.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.155]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.155]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.155]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.155]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.155]             base::names(...future.oldOptions))
[16:04:43.155]     }
[16:04:43.155]     if (FALSE) {
[16:04:43.155]     }
[16:04:43.155]     else {
[16:04:43.155]         if (TRUE) {
[16:04:43.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.155]                 open = "w")
[16:04:43.155]         }
[16:04:43.155]         else {
[16:04:43.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.155]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.155]         }
[16:04:43.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.155]             base::sink(type = "output", split = FALSE)
[16:04:43.155]             base::close(...future.stdout)
[16:04:43.155]         }, add = TRUE)
[16:04:43.155]     }
[16:04:43.155]     ...future.frame <- base::sys.nframe()
[16:04:43.155]     ...future.conditions <- base::list()
[16:04:43.155]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.155]     if (FALSE) {
[16:04:43.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.155]     }
[16:04:43.155]     ...future.result <- base::tryCatch({
[16:04:43.155]         base::withCallingHandlers({
[16:04:43.155]             ...future.value <- base::withVisible(base::local({
[16:04:43.155]                 withCallingHandlers({
[16:04:43.155]                   NULL
[16:04:43.155]                 }, immediateCondition = function(cond) {
[16:04:43.155]                   save_rds <- function (object, pathname, ...) 
[16:04:43.155]                   {
[16:04:43.155]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.155]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.155]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.155]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.155]                         fi_tmp[["mtime"]])
[16:04:43.155]                     }
[16:04:43.155]                     tryCatch({
[16:04:43.155]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.155]                     }, error = function(ex) {
[16:04:43.155]                       msg <- conditionMessage(ex)
[16:04:43.155]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.155]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.155]                         fi_tmp[["mtime"]], msg)
[16:04:43.155]                       ex$message <- msg
[16:04:43.155]                       stop(ex)
[16:04:43.155]                     })
[16:04:43.155]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.155]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.155]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.155]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.155]                       fi <- file.info(pathname)
[16:04:43.155]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.155]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.155]                         fi[["size"]], fi[["mtime"]])
[16:04:43.155]                       stop(msg)
[16:04:43.155]                     }
[16:04:43.155]                     invisible(pathname)
[16:04:43.155]                   }
[16:04:43.155]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.155]                     rootPath = tempdir()) 
[16:04:43.155]                   {
[16:04:43.155]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.155]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.155]                       tmpdir = path, fileext = ".rds")
[16:04:43.155]                     save_rds(obj, file)
[16:04:43.155]                   }
[16:04:43.155]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.155]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.155]                   {
[16:04:43.155]                     inherits <- base::inherits
[16:04:43.155]                     invokeRestart <- base::invokeRestart
[16:04:43.155]                     is.null <- base::is.null
[16:04:43.155]                     muffled <- FALSE
[16:04:43.155]                     if (inherits(cond, "message")) {
[16:04:43.155]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.155]                       if (muffled) 
[16:04:43.155]                         invokeRestart("muffleMessage")
[16:04:43.155]                     }
[16:04:43.155]                     else if (inherits(cond, "warning")) {
[16:04:43.155]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.155]                       if (muffled) 
[16:04:43.155]                         invokeRestart("muffleWarning")
[16:04:43.155]                     }
[16:04:43.155]                     else if (inherits(cond, "condition")) {
[16:04:43.155]                       if (!is.null(pattern)) {
[16:04:43.155]                         computeRestarts <- base::computeRestarts
[16:04:43.155]                         grepl <- base::grepl
[16:04:43.155]                         restarts <- computeRestarts(cond)
[16:04:43.155]                         for (restart in restarts) {
[16:04:43.155]                           name <- restart$name
[16:04:43.155]                           if (is.null(name)) 
[16:04:43.155]                             next
[16:04:43.155]                           if (!grepl(pattern, name)) 
[16:04:43.155]                             next
[16:04:43.155]                           invokeRestart(restart)
[16:04:43.155]                           muffled <- TRUE
[16:04:43.155]                           break
[16:04:43.155]                         }
[16:04:43.155]                       }
[16:04:43.155]                     }
[16:04:43.155]                     invisible(muffled)
[16:04:43.155]                   }
[16:04:43.155]                   muffleCondition(cond)
[16:04:43.155]                 })
[16:04:43.155]             }))
[16:04:43.155]             future::FutureResult(value = ...future.value$value, 
[16:04:43.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.155]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.155]                     ...future.globalenv.names))
[16:04:43.155]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.155]         }, condition = base::local({
[16:04:43.155]             c <- base::c
[16:04:43.155]             inherits <- base::inherits
[16:04:43.155]             invokeRestart <- base::invokeRestart
[16:04:43.155]             length <- base::length
[16:04:43.155]             list <- base::list
[16:04:43.155]             seq.int <- base::seq.int
[16:04:43.155]             signalCondition <- base::signalCondition
[16:04:43.155]             sys.calls <- base::sys.calls
[16:04:43.155]             `[[` <- base::`[[`
[16:04:43.155]             `+` <- base::`+`
[16:04:43.155]             `<<-` <- base::`<<-`
[16:04:43.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.155]                   3L)]
[16:04:43.155]             }
[16:04:43.155]             function(cond) {
[16:04:43.155]                 is_error <- inherits(cond, "error")
[16:04:43.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.155]                   NULL)
[16:04:43.155]                 if (is_error) {
[16:04:43.155]                   sessionInformation <- function() {
[16:04:43.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.155]                       search = base::search(), system = base::Sys.info())
[16:04:43.155]                   }
[16:04:43.155]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.155]                     cond$call), session = sessionInformation(), 
[16:04:43.155]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.155]                   signalCondition(cond)
[16:04:43.155]                 }
[16:04:43.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.155]                 "immediateCondition"))) {
[16:04:43.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.155]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.155]                   if (TRUE && !signal) {
[16:04:43.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.155]                     {
[16:04:43.155]                       inherits <- base::inherits
[16:04:43.155]                       invokeRestart <- base::invokeRestart
[16:04:43.155]                       is.null <- base::is.null
[16:04:43.155]                       muffled <- FALSE
[16:04:43.155]                       if (inherits(cond, "message")) {
[16:04:43.155]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.155]                         if (muffled) 
[16:04:43.155]                           invokeRestart("muffleMessage")
[16:04:43.155]                       }
[16:04:43.155]                       else if (inherits(cond, "warning")) {
[16:04:43.155]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.155]                         if (muffled) 
[16:04:43.155]                           invokeRestart("muffleWarning")
[16:04:43.155]                       }
[16:04:43.155]                       else if (inherits(cond, "condition")) {
[16:04:43.155]                         if (!is.null(pattern)) {
[16:04:43.155]                           computeRestarts <- base::computeRestarts
[16:04:43.155]                           grepl <- base::grepl
[16:04:43.155]                           restarts <- computeRestarts(cond)
[16:04:43.155]                           for (restart in restarts) {
[16:04:43.155]                             name <- restart$name
[16:04:43.155]                             if (is.null(name)) 
[16:04:43.155]                               next
[16:04:43.155]                             if (!grepl(pattern, name)) 
[16:04:43.155]                               next
[16:04:43.155]                             invokeRestart(restart)
[16:04:43.155]                             muffled <- TRUE
[16:04:43.155]                             break
[16:04:43.155]                           }
[16:04:43.155]                         }
[16:04:43.155]                       }
[16:04:43.155]                       invisible(muffled)
[16:04:43.155]                     }
[16:04:43.155]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.155]                   }
[16:04:43.155]                 }
[16:04:43.155]                 else {
[16:04:43.155]                   if (TRUE) {
[16:04:43.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.155]                     {
[16:04:43.155]                       inherits <- base::inherits
[16:04:43.155]                       invokeRestart <- base::invokeRestart
[16:04:43.155]                       is.null <- base::is.null
[16:04:43.155]                       muffled <- FALSE
[16:04:43.155]                       if (inherits(cond, "message")) {
[16:04:43.155]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.155]                         if (muffled) 
[16:04:43.155]                           invokeRestart("muffleMessage")
[16:04:43.155]                       }
[16:04:43.155]                       else if (inherits(cond, "warning")) {
[16:04:43.155]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.155]                         if (muffled) 
[16:04:43.155]                           invokeRestart("muffleWarning")
[16:04:43.155]                       }
[16:04:43.155]                       else if (inherits(cond, "condition")) {
[16:04:43.155]                         if (!is.null(pattern)) {
[16:04:43.155]                           computeRestarts <- base::computeRestarts
[16:04:43.155]                           grepl <- base::grepl
[16:04:43.155]                           restarts <- computeRestarts(cond)
[16:04:43.155]                           for (restart in restarts) {
[16:04:43.155]                             name <- restart$name
[16:04:43.155]                             if (is.null(name)) 
[16:04:43.155]                               next
[16:04:43.155]                             if (!grepl(pattern, name)) 
[16:04:43.155]                               next
[16:04:43.155]                             invokeRestart(restart)
[16:04:43.155]                             muffled <- TRUE
[16:04:43.155]                             break
[16:04:43.155]                           }
[16:04:43.155]                         }
[16:04:43.155]                       }
[16:04:43.155]                       invisible(muffled)
[16:04:43.155]                     }
[16:04:43.155]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.155]                   }
[16:04:43.155]                 }
[16:04:43.155]             }
[16:04:43.155]         }))
[16:04:43.155]     }, error = function(ex) {
[16:04:43.155]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.155]                 ...future.rng), started = ...future.startTime, 
[16:04:43.155]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.155]             version = "1.8"), class = "FutureResult")
[16:04:43.155]     }, finally = {
[16:04:43.155]         if (!identical(...future.workdir, getwd())) 
[16:04:43.155]             setwd(...future.workdir)
[16:04:43.155]         {
[16:04:43.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.155]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.155]             }
[16:04:43.155]             base::options(...future.oldOptions)
[16:04:43.155]             if (.Platform$OS.type == "windows") {
[16:04:43.155]                 old_names <- names(...future.oldEnvVars)
[16:04:43.155]                 envs <- base::Sys.getenv()
[16:04:43.155]                 names <- names(envs)
[16:04:43.155]                 common <- intersect(names, old_names)
[16:04:43.155]                 added <- setdiff(names, old_names)
[16:04:43.155]                 removed <- setdiff(old_names, names)
[16:04:43.155]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.155]                   envs[common]]
[16:04:43.155]                 NAMES <- toupper(changed)
[16:04:43.155]                 args <- list()
[16:04:43.155]                 for (kk in seq_along(NAMES)) {
[16:04:43.155]                   name <- changed[[kk]]
[16:04:43.155]                   NAME <- NAMES[[kk]]
[16:04:43.155]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.155]                     next
[16:04:43.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.155]                 }
[16:04:43.155]                 NAMES <- toupper(added)
[16:04:43.155]                 for (kk in seq_along(NAMES)) {
[16:04:43.155]                   name <- added[[kk]]
[16:04:43.155]                   NAME <- NAMES[[kk]]
[16:04:43.155]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.155]                     next
[16:04:43.155]                   args[[name]] <- ""
[16:04:43.155]                 }
[16:04:43.155]                 NAMES <- toupper(removed)
[16:04:43.155]                 for (kk in seq_along(NAMES)) {
[16:04:43.155]                   name <- removed[[kk]]
[16:04:43.155]                   NAME <- NAMES[[kk]]
[16:04:43.155]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.155]                     next
[16:04:43.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.155]                 }
[16:04:43.155]                 if (length(args) > 0) 
[16:04:43.155]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.155]             }
[16:04:43.155]             else {
[16:04:43.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.155]             }
[16:04:43.155]             {
[16:04:43.155]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.155]                   0L) {
[16:04:43.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.155]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.155]                   base::options(opts)
[16:04:43.155]                 }
[16:04:43.155]                 {
[16:04:43.155]                   {
[16:04:43.155]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.155]                     NULL
[16:04:43.155]                   }
[16:04:43.155]                   options(future.plan = NULL)
[16:04:43.155]                   if (is.na(NA_character_)) 
[16:04:43.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.155]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.155]                     envir = parent.frame()) 
[16:04:43.155]                   {
[16:04:43.155]                     default_workers <- missing(workers)
[16:04:43.155]                     if (is.function(workers)) 
[16:04:43.155]                       workers <- workers()
[16:04:43.155]                     workers <- structure(as.integer(workers), 
[16:04:43.155]                       class = class(workers))
[16:04:43.155]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.155]                       1L)
[16:04:43.155]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.155]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.155]                       if (default_workers) 
[16:04:43.155]                         supportsMulticore(warn = TRUE)
[16:04:43.155]                       return(sequential(..., envir = envir))
[16:04:43.155]                     }
[16:04:43.155]                     oopts <- options(mc.cores = workers)
[16:04:43.155]                     on.exit(options(oopts))
[16:04:43.155]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.155]                       envir = envir)
[16:04:43.155]                     if (!future$lazy) 
[16:04:43.155]                       future <- run(future)
[16:04:43.155]                     invisible(future)
[16:04:43.155]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.155]                 }
[16:04:43.155]             }
[16:04:43.155]         }
[16:04:43.155]     })
[16:04:43.155]     if (TRUE) {
[16:04:43.155]         base::sink(type = "output", split = FALSE)
[16:04:43.155]         if (TRUE) {
[16:04:43.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.155]         }
[16:04:43.155]         else {
[16:04:43.155]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.155]         }
[16:04:43.155]         base::close(...future.stdout)
[16:04:43.155]         ...future.stdout <- NULL
[16:04:43.155]     }
[16:04:43.155]     ...future.result$conditions <- ...future.conditions
[16:04:43.155]     ...future.result$finished <- base::Sys.time()
[16:04:43.155]     ...future.result
[16:04:43.155] }
[16:04:43.159] requestCore(): workers = 2
[16:04:43.162] MulticoreFuture started
[16:04:43.162] - Launch lazy future ... done
[16:04:43.162] run() for ‘MulticoreFuture’ ... done
[16:04:43.163] plan(): Setting new future strategy stack:
[16:04:43.163] getGlobalsAndPackages() ...
[16:04:43.163] List of future strategies:
[16:04:43.163] 1. sequential:
[16:04:43.163]    - args: function (..., envir = parent.frame())
[16:04:43.163]    - tweaked: FALSE
[16:04:43.163]    - call: NULL
[16:04:43.164] Searching for globals...
[16:04:43.164] plan(): nbrOfWorkers() = 1
[16:04:43.165] - globals found: [1] ‘{’
[16:04:43.166] Searching for globals ... DONE
[16:04:43.166] plan(): Setting new future strategy stack:
[16:04:43.166] Resolving globals: FALSE
[16:04:43.166] List of future strategies:
[16:04:43.166] 1. multicore:
[16:04:43.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.166]    - tweaked: FALSE
[16:04:43.166]    - call: plan(strategy)
[16:04:43.166] 
[16:04:43.167] 
[16:04:43.167] getGlobalsAndPackages() ... DONE
[16:04:43.167] run() for ‘Future’ ...
[16:04:43.167] - state: ‘created’
[16:04:43.168] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.171] plan(): nbrOfWorkers() = 2
[16:04:43.172] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.172] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.172]   - Field: ‘label’
[16:04:43.173]   - Field: ‘local’
[16:04:43.173]   - Field: ‘owner’
[16:04:43.173]   - Field: ‘envir’
[16:04:43.173]   - Field: ‘workers’
[16:04:43.173]   - Field: ‘packages’
[16:04:43.173]   - Field: ‘gc’
[16:04:43.173]   - Field: ‘job’
[16:04:43.174]   - Field: ‘conditions’
[16:04:43.174]   - Field: ‘expr’
[16:04:43.174]   - Field: ‘uuid’
[16:04:43.174]   - Field: ‘seed’
[16:04:43.174]   - Field: ‘version’
[16:04:43.174]   - Field: ‘result’
[16:04:43.174]   - Field: ‘asynchronous’
[16:04:43.174]   - Field: ‘calls’
[16:04:43.175]   - Field: ‘globals’
[16:04:43.175]   - Field: ‘stdout’
[16:04:43.175]   - Field: ‘earlySignal’
[16:04:43.175]   - Field: ‘lazy’
[16:04:43.175]   - Field: ‘state’
[16:04:43.175] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.175] - Launch lazy future ...
[16:04:43.176] Packages needed by the future expression (n = 0): <none>
[16:04:43.176] Packages needed by future strategies (n = 0): <none>
[16:04:43.177] {
[16:04:43.177]     {
[16:04:43.177]         {
[16:04:43.177]             ...future.startTime <- base::Sys.time()
[16:04:43.177]             {
[16:04:43.177]                 {
[16:04:43.177]                   {
[16:04:43.177]                     {
[16:04:43.177]                       base::local({
[16:04:43.177]                         has_future <- base::requireNamespace("future", 
[16:04:43.177]                           quietly = TRUE)
[16:04:43.177]                         if (has_future) {
[16:04:43.177]                           ns <- base::getNamespace("future")
[16:04:43.177]                           version <- ns[[".package"]][["version"]]
[16:04:43.177]                           if (is.null(version)) 
[16:04:43.177]                             version <- utils::packageVersion("future")
[16:04:43.177]                         }
[16:04:43.177]                         else {
[16:04:43.177]                           version <- NULL
[16:04:43.177]                         }
[16:04:43.177]                         if (!has_future || version < "1.8.0") {
[16:04:43.177]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.177]                             "", base::R.version$version.string), 
[16:04:43.177]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.177]                               "release", "version")], collapse = " "), 
[16:04:43.177]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.177]                             info)
[16:04:43.177]                           info <- base::paste(info, collapse = "; ")
[16:04:43.177]                           if (!has_future) {
[16:04:43.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.177]                               info)
[16:04:43.177]                           }
[16:04:43.177]                           else {
[16:04:43.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.177]                               info, version)
[16:04:43.177]                           }
[16:04:43.177]                           base::stop(msg)
[16:04:43.177]                         }
[16:04:43.177]                       })
[16:04:43.177]                     }
[16:04:43.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.177]                     base::options(mc.cores = 1L)
[16:04:43.177]                   }
[16:04:43.177]                   options(future.plan = NULL)
[16:04:43.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.177]                 }
[16:04:43.177]                 ...future.workdir <- getwd()
[16:04:43.177]             }
[16:04:43.177]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.177]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.177]         }
[16:04:43.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.177]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.177]             base::names(...future.oldOptions))
[16:04:43.177]     }
[16:04:43.177]     if (FALSE) {
[16:04:43.177]     }
[16:04:43.177]     else {
[16:04:43.177]         if (TRUE) {
[16:04:43.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.177]                 open = "w")
[16:04:43.177]         }
[16:04:43.177]         else {
[16:04:43.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.177]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.177]         }
[16:04:43.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.177]             base::sink(type = "output", split = FALSE)
[16:04:43.177]             base::close(...future.stdout)
[16:04:43.177]         }, add = TRUE)
[16:04:43.177]     }
[16:04:43.177]     ...future.frame <- base::sys.nframe()
[16:04:43.177]     ...future.conditions <- base::list()
[16:04:43.177]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.177]     if (FALSE) {
[16:04:43.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.177]     }
[16:04:43.177]     ...future.result <- base::tryCatch({
[16:04:43.177]         base::withCallingHandlers({
[16:04:43.177]             ...future.value <- base::withVisible(base::local({
[16:04:43.177]                 withCallingHandlers({
[16:04:43.177]                   {
[16:04:43.177]                     4
[16:04:43.177]                   }
[16:04:43.177]                 }, immediateCondition = function(cond) {
[16:04:43.177]                   save_rds <- function (object, pathname, ...) 
[16:04:43.177]                   {
[16:04:43.177]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.177]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.177]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.177]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.177]                         fi_tmp[["mtime"]])
[16:04:43.177]                     }
[16:04:43.177]                     tryCatch({
[16:04:43.177]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.177]                     }, error = function(ex) {
[16:04:43.177]                       msg <- conditionMessage(ex)
[16:04:43.177]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.177]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.177]                         fi_tmp[["mtime"]], msg)
[16:04:43.177]                       ex$message <- msg
[16:04:43.177]                       stop(ex)
[16:04:43.177]                     })
[16:04:43.177]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.177]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.177]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.177]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.177]                       fi <- file.info(pathname)
[16:04:43.177]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.177]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.177]                         fi[["size"]], fi[["mtime"]])
[16:04:43.177]                       stop(msg)
[16:04:43.177]                     }
[16:04:43.177]                     invisible(pathname)
[16:04:43.177]                   }
[16:04:43.177]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.177]                     rootPath = tempdir()) 
[16:04:43.177]                   {
[16:04:43.177]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.177]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.177]                       tmpdir = path, fileext = ".rds")
[16:04:43.177]                     save_rds(obj, file)
[16:04:43.177]                   }
[16:04:43.177]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.177]                   {
[16:04:43.177]                     inherits <- base::inherits
[16:04:43.177]                     invokeRestart <- base::invokeRestart
[16:04:43.177]                     is.null <- base::is.null
[16:04:43.177]                     muffled <- FALSE
[16:04:43.177]                     if (inherits(cond, "message")) {
[16:04:43.177]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.177]                       if (muffled) 
[16:04:43.177]                         invokeRestart("muffleMessage")
[16:04:43.177]                     }
[16:04:43.177]                     else if (inherits(cond, "warning")) {
[16:04:43.177]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.177]                       if (muffled) 
[16:04:43.177]                         invokeRestart("muffleWarning")
[16:04:43.177]                     }
[16:04:43.177]                     else if (inherits(cond, "condition")) {
[16:04:43.177]                       if (!is.null(pattern)) {
[16:04:43.177]                         computeRestarts <- base::computeRestarts
[16:04:43.177]                         grepl <- base::grepl
[16:04:43.177]                         restarts <- computeRestarts(cond)
[16:04:43.177]                         for (restart in restarts) {
[16:04:43.177]                           name <- restart$name
[16:04:43.177]                           if (is.null(name)) 
[16:04:43.177]                             next
[16:04:43.177]                           if (!grepl(pattern, name)) 
[16:04:43.177]                             next
[16:04:43.177]                           invokeRestart(restart)
[16:04:43.177]                           muffled <- TRUE
[16:04:43.177]                           break
[16:04:43.177]                         }
[16:04:43.177]                       }
[16:04:43.177]                     }
[16:04:43.177]                     invisible(muffled)
[16:04:43.177]                   }
[16:04:43.177]                   muffleCondition(cond)
[16:04:43.177]                 })
[16:04:43.177]             }))
[16:04:43.177]             future::FutureResult(value = ...future.value$value, 
[16:04:43.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.177]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.177]                     ...future.globalenv.names))
[16:04:43.177]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.177]         }, condition = base::local({
[16:04:43.177]             c <- base::c
[16:04:43.177]             inherits <- base::inherits
[16:04:43.177]             invokeRestart <- base::invokeRestart
[16:04:43.177]             length <- base::length
[16:04:43.177]             list <- base::list
[16:04:43.177]             seq.int <- base::seq.int
[16:04:43.177]             signalCondition <- base::signalCondition
[16:04:43.177]             sys.calls <- base::sys.calls
[16:04:43.177]             `[[` <- base::`[[`
[16:04:43.177]             `+` <- base::`+`
[16:04:43.177]             `<<-` <- base::`<<-`
[16:04:43.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.177]                   3L)]
[16:04:43.177]             }
[16:04:43.177]             function(cond) {
[16:04:43.177]                 is_error <- inherits(cond, "error")
[16:04:43.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.177]                   NULL)
[16:04:43.177]                 if (is_error) {
[16:04:43.177]                   sessionInformation <- function() {
[16:04:43.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.177]                       search = base::search(), system = base::Sys.info())
[16:04:43.177]                   }
[16:04:43.177]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.177]                     cond$call), session = sessionInformation(), 
[16:04:43.177]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.177]                   signalCondition(cond)
[16:04:43.177]                 }
[16:04:43.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.177]                 "immediateCondition"))) {
[16:04:43.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.177]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.177]                   if (TRUE && !signal) {
[16:04:43.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.177]                     {
[16:04:43.177]                       inherits <- base::inherits
[16:04:43.177]                       invokeRestart <- base::invokeRestart
[16:04:43.177]                       is.null <- base::is.null
[16:04:43.177]                       muffled <- FALSE
[16:04:43.177]                       if (inherits(cond, "message")) {
[16:04:43.177]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.177]                         if (muffled) 
[16:04:43.177]                           invokeRestart("muffleMessage")
[16:04:43.177]                       }
[16:04:43.177]                       else if (inherits(cond, "warning")) {
[16:04:43.177]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.177]                         if (muffled) 
[16:04:43.177]                           invokeRestart("muffleWarning")
[16:04:43.177]                       }
[16:04:43.177]                       else if (inherits(cond, "condition")) {
[16:04:43.177]                         if (!is.null(pattern)) {
[16:04:43.177]                           computeRestarts <- base::computeRestarts
[16:04:43.177]                           grepl <- base::grepl
[16:04:43.177]                           restarts <- computeRestarts(cond)
[16:04:43.177]                           for (restart in restarts) {
[16:04:43.177]                             name <- restart$name
[16:04:43.177]                             if (is.null(name)) 
[16:04:43.177]                               next
[16:04:43.177]                             if (!grepl(pattern, name)) 
[16:04:43.177]                               next
[16:04:43.177]                             invokeRestart(restart)
[16:04:43.177]                             muffled <- TRUE
[16:04:43.177]                             break
[16:04:43.177]                           }
[16:04:43.177]                         }
[16:04:43.177]                       }
[16:04:43.177]                       invisible(muffled)
[16:04:43.177]                     }
[16:04:43.177]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.177]                   }
[16:04:43.177]                 }
[16:04:43.177]                 else {
[16:04:43.177]                   if (TRUE) {
[16:04:43.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.177]                     {
[16:04:43.177]                       inherits <- base::inherits
[16:04:43.177]                       invokeRestart <- base::invokeRestart
[16:04:43.177]                       is.null <- base::is.null
[16:04:43.177]                       muffled <- FALSE
[16:04:43.177]                       if (inherits(cond, "message")) {
[16:04:43.177]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.177]                         if (muffled) 
[16:04:43.177]                           invokeRestart("muffleMessage")
[16:04:43.177]                       }
[16:04:43.177]                       else if (inherits(cond, "warning")) {
[16:04:43.177]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.177]                         if (muffled) 
[16:04:43.177]                           invokeRestart("muffleWarning")
[16:04:43.177]                       }
[16:04:43.177]                       else if (inherits(cond, "condition")) {
[16:04:43.177]                         if (!is.null(pattern)) {
[16:04:43.177]                           computeRestarts <- base::computeRestarts
[16:04:43.177]                           grepl <- base::grepl
[16:04:43.177]                           restarts <- computeRestarts(cond)
[16:04:43.177]                           for (restart in restarts) {
[16:04:43.177]                             name <- restart$name
[16:04:43.177]                             if (is.null(name)) 
[16:04:43.177]                               next
[16:04:43.177]                             if (!grepl(pattern, name)) 
[16:04:43.177]                               next
[16:04:43.177]                             invokeRestart(restart)
[16:04:43.177]                             muffled <- TRUE
[16:04:43.177]                             break
[16:04:43.177]                           }
[16:04:43.177]                         }
[16:04:43.177]                       }
[16:04:43.177]                       invisible(muffled)
[16:04:43.177]                     }
[16:04:43.177]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.177]                   }
[16:04:43.177]                 }
[16:04:43.177]             }
[16:04:43.177]         }))
[16:04:43.177]     }, error = function(ex) {
[16:04:43.177]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.177]                 ...future.rng), started = ...future.startTime, 
[16:04:43.177]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.177]             version = "1.8"), class = "FutureResult")
[16:04:43.177]     }, finally = {
[16:04:43.177]         if (!identical(...future.workdir, getwd())) 
[16:04:43.177]             setwd(...future.workdir)
[16:04:43.177]         {
[16:04:43.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.177]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.177]             }
[16:04:43.177]             base::options(...future.oldOptions)
[16:04:43.177]             if (.Platform$OS.type == "windows") {
[16:04:43.177]                 old_names <- names(...future.oldEnvVars)
[16:04:43.177]                 envs <- base::Sys.getenv()
[16:04:43.177]                 names <- names(envs)
[16:04:43.177]                 common <- intersect(names, old_names)
[16:04:43.177]                 added <- setdiff(names, old_names)
[16:04:43.177]                 removed <- setdiff(old_names, names)
[16:04:43.177]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.177]                   envs[common]]
[16:04:43.177]                 NAMES <- toupper(changed)
[16:04:43.177]                 args <- list()
[16:04:43.177]                 for (kk in seq_along(NAMES)) {
[16:04:43.177]                   name <- changed[[kk]]
[16:04:43.177]                   NAME <- NAMES[[kk]]
[16:04:43.177]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.177]                     next
[16:04:43.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.177]                 }
[16:04:43.177]                 NAMES <- toupper(added)
[16:04:43.177]                 for (kk in seq_along(NAMES)) {
[16:04:43.177]                   name <- added[[kk]]
[16:04:43.177]                   NAME <- NAMES[[kk]]
[16:04:43.177]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.177]                     next
[16:04:43.177]                   args[[name]] <- ""
[16:04:43.177]                 }
[16:04:43.177]                 NAMES <- toupper(removed)
[16:04:43.177]                 for (kk in seq_along(NAMES)) {
[16:04:43.177]                   name <- removed[[kk]]
[16:04:43.177]                   NAME <- NAMES[[kk]]
[16:04:43.177]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.177]                     next
[16:04:43.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.177]                 }
[16:04:43.177]                 if (length(args) > 0) 
[16:04:43.177]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.177]             }
[16:04:43.177]             else {
[16:04:43.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.177]             }
[16:04:43.177]             {
[16:04:43.177]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.177]                   0L) {
[16:04:43.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.177]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.177]                   base::options(opts)
[16:04:43.177]                 }
[16:04:43.177]                 {
[16:04:43.177]                   {
[16:04:43.177]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.177]                     NULL
[16:04:43.177]                   }
[16:04:43.177]                   options(future.plan = NULL)
[16:04:43.177]                   if (is.na(NA_character_)) 
[16:04:43.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.177]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.177]                     envir = parent.frame()) 
[16:04:43.177]                   {
[16:04:43.177]                     default_workers <- missing(workers)
[16:04:43.177]                     if (is.function(workers)) 
[16:04:43.177]                       workers <- workers()
[16:04:43.177]                     workers <- structure(as.integer(workers), 
[16:04:43.177]                       class = class(workers))
[16:04:43.177]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.177]                       1L)
[16:04:43.177]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.177]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.177]                       if (default_workers) 
[16:04:43.177]                         supportsMulticore(warn = TRUE)
[16:04:43.177]                       return(sequential(..., envir = envir))
[16:04:43.177]                     }
[16:04:43.177]                     oopts <- options(mc.cores = workers)
[16:04:43.177]                     on.exit(options(oopts))
[16:04:43.177]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.177]                       envir = envir)
[16:04:43.177]                     if (!future$lazy) 
[16:04:43.177]                       future <- run(future)
[16:04:43.177]                     invisible(future)
[16:04:43.177]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.177]                 }
[16:04:43.177]             }
[16:04:43.177]         }
[16:04:43.177]     })
[16:04:43.177]     if (TRUE) {
[16:04:43.177]         base::sink(type = "output", split = FALSE)
[16:04:43.177]         if (TRUE) {
[16:04:43.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.177]         }
[16:04:43.177]         else {
[16:04:43.177]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.177]         }
[16:04:43.177]         base::close(...future.stdout)
[16:04:43.177]         ...future.stdout <- NULL
[16:04:43.177]     }
[16:04:43.177]     ...future.result$conditions <- ...future.conditions
[16:04:43.177]     ...future.result$finished <- base::Sys.time()
[16:04:43.177]     ...future.result
[16:04:43.177] }
[16:04:43.180] requestCore(): workers = 2
[16:04:43.180] Poll #1 (0): usedCores() = 2, workers = 2
[16:04:43.196] result() for MulticoreFuture ...
[16:04:43.197] result() for MulticoreFuture ...
[16:04:43.197] result() for MulticoreFuture ... done
[16:04:43.197] result() for MulticoreFuture ... done
[16:04:43.197] result() for MulticoreFuture ...
[16:04:43.198] result() for MulticoreFuture ... done
[16:04:43.200] MulticoreFuture started
[16:04:43.201] - Launch lazy future ... done
[16:04:43.201] run() for ‘MulticoreFuture’ ... done
[16:04:43.202] plan(): Setting new future strategy stack:
<environment: 0x55874f406e50> 
[16:04:43.202] List of future strategies:
[16:04:43.202] 1. sequential:
[16:04:43.202]    - args: function (..., envir = parent.frame())
[16:04:43.202]    - tweaked: FALSE
[16:04:43.202]    - call: NULL
[16:04:43.203] plan(): nbrOfWorkers() = 1
<environment: 0x55874e2c55b8> 
[16:04:43.206] plan(): Setting new future strategy stack:
[16:04:43.206] List of future strategies:
[16:04:43.206] 1. multicore:
[16:04:43.206]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.206]    - tweaked: FALSE
[16:04:43.206]    - call: plan(strategy)
[16:04:43.210] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:43.213] resolve() on environment ...
[16:04:43.213]  recursive: 0
[16:04:43.214]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:43.214] signalConditionsASAP(numeric, pos=1) ...
[16:04:43.214] - nx: 4
[16:04:43.214] - relay: TRUE
[16:04:43.214] - stdout: TRUE
[16:04:43.214] - signal: TRUE
[16:04:43.214] - resignal: FALSE
[16:04:43.215] - force: TRUE
[16:04:43.215] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.215] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.215]  - until=2
[16:04:43.215]  - relaying element #2
[16:04:43.215] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:43.215] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.216] signalConditionsASAP(NULL, pos=1) ... done
[16:04:43.216]  length: 3 (resolved future 1)
[16:04:43.216] Future #2
[16:04:43.216] result() for MulticoreFuture ...
[16:04:43.216] result() for MulticoreFuture ... done
[16:04:43.216] result() for MulticoreFuture ...
[16:04:43.216] result() for MulticoreFuture ... done
[16:04:43.217] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:43.217] - nx: 4
[16:04:43.217] - relay: TRUE
[16:04:43.217] - stdout: TRUE
[16:04:43.217] - signal: TRUE
[16:04:43.217] - resignal: FALSE
[16:04:43.217] - force: TRUE
[16:04:43.218] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:43.218] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.218]  - until=2
[16:04:43.218]  - relaying element #2
[16:04:43.218] result() for MulticoreFuture ...
[16:04:43.218] result() for MulticoreFuture ... done
[16:04:43.218] result() for MulticoreFuture ...
[16:04:43.218] result() for MulticoreFuture ... done
[16:04:43.219] result() for MulticoreFuture ...
[16:04:43.219] result() for MulticoreFuture ... done
[16:04:43.219] result() for MulticoreFuture ...
[16:04:43.219] result() for MulticoreFuture ... done
[16:04:43.219] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:43.219] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:43.219] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:43.220]  length: 2 (resolved future 2)
[16:04:43.220] Future #3
[16:04:43.220] result() for MulticoreFuture ...
[16:04:43.221] result() for MulticoreFuture ...
[16:04:43.221] result() for MulticoreFuture ... done
[16:04:43.221] result() for MulticoreFuture ... done
[16:04:43.221] result() for MulticoreFuture ...
[16:04:43.221] result() for MulticoreFuture ... done
[16:04:43.222] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:43.222] - nx: 4
[16:04:43.222] - relay: TRUE
[16:04:43.222] - stdout: TRUE
[16:04:43.222] - signal: TRUE
[16:04:43.222] - resignal: FALSE
[16:04:43.222] - force: TRUE
[16:04:43.222] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:43.223] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:43.223]  - until=3
[16:04:43.223]  - relaying element #3
[16:04:43.223] result() for MulticoreFuture ...
[16:04:43.223] result() for MulticoreFuture ... done
[16:04:43.223] result() for MulticoreFuture ...
[16:04:43.223] result() for MulticoreFuture ... done
[16:04:43.224] result() for MulticoreFuture ...
[16:04:43.224] result() for MulticoreFuture ... done
[16:04:43.224] result() for MulticoreFuture ...
[16:04:43.224] result() for MulticoreFuture ... done
[16:04:43.224] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:43.224] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:43.224] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:43.224]  length: 1 (resolved future 3)
[16:04:43.225] Future #4
[16:04:43.225] result() for MulticoreFuture ...
[16:04:43.226] result() for MulticoreFuture ...
[16:04:43.226] result() for MulticoreFuture ... done
[16:04:43.226] result() for MulticoreFuture ... done
[16:04:43.226] result() for MulticoreFuture ...
[16:04:43.226] result() for MulticoreFuture ... done
[16:04:43.227] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:04:43.227] - nx: 4
[16:04:43.227] - relay: TRUE
[16:04:43.227] - stdout: TRUE
[16:04:43.227] - signal: TRUE
[16:04:43.227] - resignal: FALSE
[16:04:43.227] - force: TRUE
[16:04:43.228] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:43.228] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:43.228]  - until=4
[16:04:43.228]  - relaying element #4
[16:04:43.228] result() for MulticoreFuture ...
[16:04:43.228] result() for MulticoreFuture ... done
[16:04:43.228] result() for MulticoreFuture ...
[16:04:43.229] result() for MulticoreFuture ... done
[16:04:43.229] result() for MulticoreFuture ...
[16:04:43.229] result() for MulticoreFuture ... done
[16:04:43.229] result() for MulticoreFuture ...
[16:04:43.229] result() for MulticoreFuture ... done
[16:04:43.229] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.229] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:43.229] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:04:43.230]  length: 0 (resolved future 4)
[16:04:43.230] Relaying remaining futures
[16:04:43.230] signalConditionsASAP(NULL, pos=0) ...
[16:04:43.230] - nx: 4
[16:04:43.230] - relay: TRUE
[16:04:43.230] - stdout: TRUE
[16:04:43.230] - signal: TRUE
[16:04:43.230] - resignal: FALSE
[16:04:43.230] - force: TRUE
[16:04:43.230] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.231] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:43.231] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.231] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:43.231] signalConditionsASAP(NULL, pos=0) ... done
[16:04:43.231] resolve() on environment ... DONE
[16:04:43.231] result() for MulticoreFuture ...
[16:04:43.231] result() for MulticoreFuture ... done
[16:04:43.231] result() for MulticoreFuture ...
[16:04:43.232] result() for MulticoreFuture ... done
[16:04:43.232] result() for MulticoreFuture ...
[16:04:43.232] result() for MulticoreFuture ... done
[16:04:43.232] result() for MulticoreFuture ...
[16:04:43.232] result() for MulticoreFuture ... done
[16:04:43.232] result() for MulticoreFuture ...
[16:04:43.232] result() for MulticoreFuture ... done
[16:04:43.232] result() for MulticoreFuture ...
[16:04:43.233] result() for MulticoreFuture ... done
<environment: 0x55874e191900> 
Dimensions: c(1, 6)
[16:04:43.233] getGlobalsAndPackages() ...
[16:04:43.233] Searching for globals...
[16:04:43.234] 
[16:04:43.234] Searching for globals ... DONE
[16:04:43.234] - globals: [0] <none>
[16:04:43.234] getGlobalsAndPackages() ... DONE
[16:04:43.234] run() for ‘Future’ ...
[16:04:43.234] - state: ‘created’
[16:04:43.235] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.239] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.239]   - Field: ‘label’
[16:04:43.239]   - Field: ‘local’
[16:04:43.239]   - Field: ‘owner’
[16:04:43.239]   - Field: ‘envir’
[16:04:43.239]   - Field: ‘workers’
[16:04:43.240]   - Field: ‘packages’
[16:04:43.240]   - Field: ‘gc’
[16:04:43.240]   - Field: ‘job’
[16:04:43.240]   - Field: ‘conditions’
[16:04:43.240]   - Field: ‘expr’
[16:04:43.240]   - Field: ‘uuid’
[16:04:43.240]   - Field: ‘seed’
[16:04:43.240]   - Field: ‘version’
[16:04:43.241]   - Field: ‘result’
[16:04:43.241]   - Field: ‘asynchronous’
[16:04:43.241]   - Field: ‘calls’
[16:04:43.241]   - Field: ‘globals’
[16:04:43.241]   - Field: ‘stdout’
[16:04:43.241]   - Field: ‘earlySignal’
[16:04:43.241]   - Field: ‘lazy’
[16:04:43.241]   - Field: ‘state’
[16:04:43.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.242] - Launch lazy future ...
[16:04:43.242] Packages needed by the future expression (n = 0): <none>
[16:04:43.242] Packages needed by future strategies (n = 0): <none>
[16:04:43.243] {
[16:04:43.243]     {
[16:04:43.243]         {
[16:04:43.243]             ...future.startTime <- base::Sys.time()
[16:04:43.243]             {
[16:04:43.243]                 {
[16:04:43.243]                   {
[16:04:43.243]                     {
[16:04:43.243]                       base::local({
[16:04:43.243]                         has_future <- base::requireNamespace("future", 
[16:04:43.243]                           quietly = TRUE)
[16:04:43.243]                         if (has_future) {
[16:04:43.243]                           ns <- base::getNamespace("future")
[16:04:43.243]                           version <- ns[[".package"]][["version"]]
[16:04:43.243]                           if (is.null(version)) 
[16:04:43.243]                             version <- utils::packageVersion("future")
[16:04:43.243]                         }
[16:04:43.243]                         else {
[16:04:43.243]                           version <- NULL
[16:04:43.243]                         }
[16:04:43.243]                         if (!has_future || version < "1.8.0") {
[16:04:43.243]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.243]                             "", base::R.version$version.string), 
[16:04:43.243]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.243]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.243]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.243]                               "release", "version")], collapse = " "), 
[16:04:43.243]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.243]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.243]                             info)
[16:04:43.243]                           info <- base::paste(info, collapse = "; ")
[16:04:43.243]                           if (!has_future) {
[16:04:43.243]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.243]                               info)
[16:04:43.243]                           }
[16:04:43.243]                           else {
[16:04:43.243]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.243]                               info, version)
[16:04:43.243]                           }
[16:04:43.243]                           base::stop(msg)
[16:04:43.243]                         }
[16:04:43.243]                       })
[16:04:43.243]                     }
[16:04:43.243]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.243]                     base::options(mc.cores = 1L)
[16:04:43.243]                   }
[16:04:43.243]                   options(future.plan = NULL)
[16:04:43.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.243]                 }
[16:04:43.243]                 ...future.workdir <- getwd()
[16:04:43.243]             }
[16:04:43.243]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.243]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.243]         }
[16:04:43.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.243]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.243]             base::names(...future.oldOptions))
[16:04:43.243]     }
[16:04:43.243]     if (FALSE) {
[16:04:43.243]     }
[16:04:43.243]     else {
[16:04:43.243]         if (TRUE) {
[16:04:43.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.243]                 open = "w")
[16:04:43.243]         }
[16:04:43.243]         else {
[16:04:43.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.243]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.243]         }
[16:04:43.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.243]             base::sink(type = "output", split = FALSE)
[16:04:43.243]             base::close(...future.stdout)
[16:04:43.243]         }, add = TRUE)
[16:04:43.243]     }
[16:04:43.243]     ...future.frame <- base::sys.nframe()
[16:04:43.243]     ...future.conditions <- base::list()
[16:04:43.243]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.243]     if (FALSE) {
[16:04:43.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.243]     }
[16:04:43.243]     ...future.result <- base::tryCatch({
[16:04:43.243]         base::withCallingHandlers({
[16:04:43.243]             ...future.value <- base::withVisible(base::local({
[16:04:43.243]                 withCallingHandlers({
[16:04:43.243]                   2
[16:04:43.243]                 }, immediateCondition = function(cond) {
[16:04:43.243]                   save_rds <- function (object, pathname, ...) 
[16:04:43.243]                   {
[16:04:43.243]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.243]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.243]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.243]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.243]                         fi_tmp[["mtime"]])
[16:04:43.243]                     }
[16:04:43.243]                     tryCatch({
[16:04:43.243]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.243]                     }, error = function(ex) {
[16:04:43.243]                       msg <- conditionMessage(ex)
[16:04:43.243]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.243]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.243]                         fi_tmp[["mtime"]], msg)
[16:04:43.243]                       ex$message <- msg
[16:04:43.243]                       stop(ex)
[16:04:43.243]                     })
[16:04:43.243]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.243]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.243]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.243]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.243]                       fi <- file.info(pathname)
[16:04:43.243]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.243]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.243]                         fi[["size"]], fi[["mtime"]])
[16:04:43.243]                       stop(msg)
[16:04:43.243]                     }
[16:04:43.243]                     invisible(pathname)
[16:04:43.243]                   }
[16:04:43.243]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.243]                     rootPath = tempdir()) 
[16:04:43.243]                   {
[16:04:43.243]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.243]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.243]                       tmpdir = path, fileext = ".rds")
[16:04:43.243]                     save_rds(obj, file)
[16:04:43.243]                   }
[16:04:43.243]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.243]                   {
[16:04:43.243]                     inherits <- base::inherits
[16:04:43.243]                     invokeRestart <- base::invokeRestart
[16:04:43.243]                     is.null <- base::is.null
[16:04:43.243]                     muffled <- FALSE
[16:04:43.243]                     if (inherits(cond, "message")) {
[16:04:43.243]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.243]                       if (muffled) 
[16:04:43.243]                         invokeRestart("muffleMessage")
[16:04:43.243]                     }
[16:04:43.243]                     else if (inherits(cond, "warning")) {
[16:04:43.243]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.243]                       if (muffled) 
[16:04:43.243]                         invokeRestart("muffleWarning")
[16:04:43.243]                     }
[16:04:43.243]                     else if (inherits(cond, "condition")) {
[16:04:43.243]                       if (!is.null(pattern)) {
[16:04:43.243]                         computeRestarts <- base::computeRestarts
[16:04:43.243]                         grepl <- base::grepl
[16:04:43.243]                         restarts <- computeRestarts(cond)
[16:04:43.243]                         for (restart in restarts) {
[16:04:43.243]                           name <- restart$name
[16:04:43.243]                           if (is.null(name)) 
[16:04:43.243]                             next
[16:04:43.243]                           if (!grepl(pattern, name)) 
[16:04:43.243]                             next
[16:04:43.243]                           invokeRestart(restart)
[16:04:43.243]                           muffled <- TRUE
[16:04:43.243]                           break
[16:04:43.243]                         }
[16:04:43.243]                       }
[16:04:43.243]                     }
[16:04:43.243]                     invisible(muffled)
[16:04:43.243]                   }
[16:04:43.243]                   muffleCondition(cond)
[16:04:43.243]                 })
[16:04:43.243]             }))
[16:04:43.243]             future::FutureResult(value = ...future.value$value, 
[16:04:43.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.243]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.243]                     ...future.globalenv.names))
[16:04:43.243]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.243]         }, condition = base::local({
[16:04:43.243]             c <- base::c
[16:04:43.243]             inherits <- base::inherits
[16:04:43.243]             invokeRestart <- base::invokeRestart
[16:04:43.243]             length <- base::length
[16:04:43.243]             list <- base::list
[16:04:43.243]             seq.int <- base::seq.int
[16:04:43.243]             signalCondition <- base::signalCondition
[16:04:43.243]             sys.calls <- base::sys.calls
[16:04:43.243]             `[[` <- base::`[[`
[16:04:43.243]             `+` <- base::`+`
[16:04:43.243]             `<<-` <- base::`<<-`
[16:04:43.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.243]                   3L)]
[16:04:43.243]             }
[16:04:43.243]             function(cond) {
[16:04:43.243]                 is_error <- inherits(cond, "error")
[16:04:43.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.243]                   NULL)
[16:04:43.243]                 if (is_error) {
[16:04:43.243]                   sessionInformation <- function() {
[16:04:43.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.243]                       search = base::search(), system = base::Sys.info())
[16:04:43.243]                   }
[16:04:43.243]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.243]                     cond$call), session = sessionInformation(), 
[16:04:43.243]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.243]                   signalCondition(cond)
[16:04:43.243]                 }
[16:04:43.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.243]                 "immediateCondition"))) {
[16:04:43.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.243]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.243]                   if (TRUE && !signal) {
[16:04:43.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.243]                     {
[16:04:43.243]                       inherits <- base::inherits
[16:04:43.243]                       invokeRestart <- base::invokeRestart
[16:04:43.243]                       is.null <- base::is.null
[16:04:43.243]                       muffled <- FALSE
[16:04:43.243]                       if (inherits(cond, "message")) {
[16:04:43.243]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.243]                         if (muffled) 
[16:04:43.243]                           invokeRestart("muffleMessage")
[16:04:43.243]                       }
[16:04:43.243]                       else if (inherits(cond, "warning")) {
[16:04:43.243]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.243]                         if (muffled) 
[16:04:43.243]                           invokeRestart("muffleWarning")
[16:04:43.243]                       }
[16:04:43.243]                       else if (inherits(cond, "condition")) {
[16:04:43.243]                         if (!is.null(pattern)) {
[16:04:43.243]                           computeRestarts <- base::computeRestarts
[16:04:43.243]                           grepl <- base::grepl
[16:04:43.243]                           restarts <- computeRestarts(cond)
[16:04:43.243]                           for (restart in restarts) {
[16:04:43.243]                             name <- restart$name
[16:04:43.243]                             if (is.null(name)) 
[16:04:43.243]                               next
[16:04:43.243]                             if (!grepl(pattern, name)) 
[16:04:43.243]                               next
[16:04:43.243]                             invokeRestart(restart)
[16:04:43.243]                             muffled <- TRUE
[16:04:43.243]                             break
[16:04:43.243]                           }
[16:04:43.243]                         }
[16:04:43.243]                       }
[16:04:43.243]                       invisible(muffled)
[16:04:43.243]                     }
[16:04:43.243]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.243]                   }
[16:04:43.243]                 }
[16:04:43.243]                 else {
[16:04:43.243]                   if (TRUE) {
[16:04:43.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.243]                     {
[16:04:43.243]                       inherits <- base::inherits
[16:04:43.243]                       invokeRestart <- base::invokeRestart
[16:04:43.243]                       is.null <- base::is.null
[16:04:43.243]                       muffled <- FALSE
[16:04:43.243]                       if (inherits(cond, "message")) {
[16:04:43.243]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.243]                         if (muffled) 
[16:04:43.243]                           invokeRestart("muffleMessage")
[16:04:43.243]                       }
[16:04:43.243]                       else if (inherits(cond, "warning")) {
[16:04:43.243]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.243]                         if (muffled) 
[16:04:43.243]                           invokeRestart("muffleWarning")
[16:04:43.243]                       }
[16:04:43.243]                       else if (inherits(cond, "condition")) {
[16:04:43.243]                         if (!is.null(pattern)) {
[16:04:43.243]                           computeRestarts <- base::computeRestarts
[16:04:43.243]                           grepl <- base::grepl
[16:04:43.243]                           restarts <- computeRestarts(cond)
[16:04:43.243]                           for (restart in restarts) {
[16:04:43.243]                             name <- restart$name
[16:04:43.243]                             if (is.null(name)) 
[16:04:43.243]                               next
[16:04:43.243]                             if (!grepl(pattern, name)) 
[16:04:43.243]                               next
[16:04:43.243]                             invokeRestart(restart)
[16:04:43.243]                             muffled <- TRUE
[16:04:43.243]                             break
[16:04:43.243]                           }
[16:04:43.243]                         }
[16:04:43.243]                       }
[16:04:43.243]                       invisible(muffled)
[16:04:43.243]                     }
[16:04:43.243]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.243]                   }
[16:04:43.243]                 }
[16:04:43.243]             }
[16:04:43.243]         }))
[16:04:43.243]     }, error = function(ex) {
[16:04:43.243]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.243]                 ...future.rng), started = ...future.startTime, 
[16:04:43.243]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.243]             version = "1.8"), class = "FutureResult")
[16:04:43.243]     }, finally = {
[16:04:43.243]         if (!identical(...future.workdir, getwd())) 
[16:04:43.243]             setwd(...future.workdir)
[16:04:43.243]         {
[16:04:43.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.243]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.243]             }
[16:04:43.243]             base::options(...future.oldOptions)
[16:04:43.243]             if (.Platform$OS.type == "windows") {
[16:04:43.243]                 old_names <- names(...future.oldEnvVars)
[16:04:43.243]                 envs <- base::Sys.getenv()
[16:04:43.243]                 names <- names(envs)
[16:04:43.243]                 common <- intersect(names, old_names)
[16:04:43.243]                 added <- setdiff(names, old_names)
[16:04:43.243]                 removed <- setdiff(old_names, names)
[16:04:43.243]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.243]                   envs[common]]
[16:04:43.243]                 NAMES <- toupper(changed)
[16:04:43.243]                 args <- list()
[16:04:43.243]                 for (kk in seq_along(NAMES)) {
[16:04:43.243]                   name <- changed[[kk]]
[16:04:43.243]                   NAME <- NAMES[[kk]]
[16:04:43.243]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.243]                     next
[16:04:43.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.243]                 }
[16:04:43.243]                 NAMES <- toupper(added)
[16:04:43.243]                 for (kk in seq_along(NAMES)) {
[16:04:43.243]                   name <- added[[kk]]
[16:04:43.243]                   NAME <- NAMES[[kk]]
[16:04:43.243]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.243]                     next
[16:04:43.243]                   args[[name]] <- ""
[16:04:43.243]                 }
[16:04:43.243]                 NAMES <- toupper(removed)
[16:04:43.243]                 for (kk in seq_along(NAMES)) {
[16:04:43.243]                   name <- removed[[kk]]
[16:04:43.243]                   NAME <- NAMES[[kk]]
[16:04:43.243]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.243]                     next
[16:04:43.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.243]                 }
[16:04:43.243]                 if (length(args) > 0) 
[16:04:43.243]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.243]             }
[16:04:43.243]             else {
[16:04:43.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.243]             }
[16:04:43.243]             {
[16:04:43.243]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.243]                   0L) {
[16:04:43.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.243]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.243]                   base::options(opts)
[16:04:43.243]                 }
[16:04:43.243]                 {
[16:04:43.243]                   {
[16:04:43.243]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.243]                     NULL
[16:04:43.243]                   }
[16:04:43.243]                   options(future.plan = NULL)
[16:04:43.243]                   if (is.na(NA_character_)) 
[16:04:43.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.243]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.243]                     envir = parent.frame()) 
[16:04:43.243]                   {
[16:04:43.243]                     default_workers <- missing(workers)
[16:04:43.243]                     if (is.function(workers)) 
[16:04:43.243]                       workers <- workers()
[16:04:43.243]                     workers <- structure(as.integer(workers), 
[16:04:43.243]                       class = class(workers))
[16:04:43.243]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.243]                       1L)
[16:04:43.243]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.243]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.243]                       if (default_workers) 
[16:04:43.243]                         supportsMulticore(warn = TRUE)
[16:04:43.243]                       return(sequential(..., envir = envir))
[16:04:43.243]                     }
[16:04:43.243]                     oopts <- options(mc.cores = workers)
[16:04:43.243]                     on.exit(options(oopts))
[16:04:43.243]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.243]                       envir = envir)
[16:04:43.243]                     if (!future$lazy) 
[16:04:43.243]                       future <- run(future)
[16:04:43.243]                     invisible(future)
[16:04:43.243]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.243]                 }
[16:04:43.243]             }
[16:04:43.243]         }
[16:04:43.243]     })
[16:04:43.243]     if (TRUE) {
[16:04:43.243]         base::sink(type = "output", split = FALSE)
[16:04:43.243]         if (TRUE) {
[16:04:43.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.243]         }
[16:04:43.243]         else {
[16:04:43.243]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.243]         }
[16:04:43.243]         base::close(...future.stdout)
[16:04:43.243]         ...future.stdout <- NULL
[16:04:43.243]     }
[16:04:43.243]     ...future.result$conditions <- ...future.conditions
[16:04:43.243]     ...future.result$finished <- base::Sys.time()
[16:04:43.243]     ...future.result
[16:04:43.243] }
[16:04:43.245] requestCore(): workers = 2
[16:04:43.248] MulticoreFuture started
[16:04:43.248] - Launch lazy future ... done
[16:04:43.248] run() for ‘MulticoreFuture’ ... done
[16:04:43.249] getGlobalsAndPackages() ...
[16:04:43.249] Searching for globals...
[16:04:43.249] plan(): Setting new future strategy stack:
[16:04:43.249] List of future strategies:
[16:04:43.249] 1. sequential:
[16:04:43.249]    - args: function (..., envir = parent.frame())
[16:04:43.249]    - tweaked: FALSE
[16:04:43.249]    - call: NULL
[16:04:43.250] 
[16:04:43.250] Searching for globals ... DONE
[16:04:43.250] plan(): nbrOfWorkers() = 1
[16:04:43.250] - globals: [0] <none>
[16:04:43.250] getGlobalsAndPackages() ... DONE
[16:04:43.251] run() for ‘Future’ ...
[16:04:43.251] - state: ‘created’
[16:04:43.251] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.252] plan(): Setting new future strategy stack:
[16:04:43.252] List of future strategies:
[16:04:43.252] 1. multicore:
[16:04:43.252]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.252]    - tweaked: FALSE
[16:04:43.252]    - call: plan(strategy)
[16:04:43.256] plan(): nbrOfWorkers() = 2
[16:04:43.256] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.256] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.256]   - Field: ‘label’
[16:04:43.257]   - Field: ‘local’
[16:04:43.257]   - Field: ‘owner’
[16:04:43.257]   - Field: ‘envir’
[16:04:43.257]   - Field: ‘workers’
[16:04:43.257]   - Field: ‘packages’
[16:04:43.257]   - Field: ‘gc’
[16:04:43.258]   - Field: ‘job’
[16:04:43.258]   - Field: ‘conditions’
[16:04:43.258]   - Field: ‘expr’
[16:04:43.258]   - Field: ‘uuid’
[16:04:43.258]   - Field: ‘seed’
[16:04:43.258]   - Field: ‘version’
[16:04:43.258]   - Field: ‘result’
[16:04:43.259]   - Field: ‘asynchronous’
[16:04:43.259]   - Field: ‘calls’
[16:04:43.259]   - Field: ‘globals’
[16:04:43.259]   - Field: ‘stdout’
[16:04:43.259]   - Field: ‘earlySignal’
[16:04:43.259]   - Field: ‘lazy’
[16:04:43.259]   - Field: ‘state’
[16:04:43.260] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.260] - Launch lazy future ...
[16:04:43.260] Packages needed by the future expression (n = 0): <none>
[16:04:43.260] Packages needed by future strategies (n = 0): <none>
[16:04:43.261] {
[16:04:43.261]     {
[16:04:43.261]         {
[16:04:43.261]             ...future.startTime <- base::Sys.time()
[16:04:43.261]             {
[16:04:43.261]                 {
[16:04:43.261]                   {
[16:04:43.261]                     {
[16:04:43.261]                       base::local({
[16:04:43.261]                         has_future <- base::requireNamespace("future", 
[16:04:43.261]                           quietly = TRUE)
[16:04:43.261]                         if (has_future) {
[16:04:43.261]                           ns <- base::getNamespace("future")
[16:04:43.261]                           version <- ns[[".package"]][["version"]]
[16:04:43.261]                           if (is.null(version)) 
[16:04:43.261]                             version <- utils::packageVersion("future")
[16:04:43.261]                         }
[16:04:43.261]                         else {
[16:04:43.261]                           version <- NULL
[16:04:43.261]                         }
[16:04:43.261]                         if (!has_future || version < "1.8.0") {
[16:04:43.261]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.261]                             "", base::R.version$version.string), 
[16:04:43.261]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.261]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.261]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.261]                               "release", "version")], collapse = " "), 
[16:04:43.261]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.261]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.261]                             info)
[16:04:43.261]                           info <- base::paste(info, collapse = "; ")
[16:04:43.261]                           if (!has_future) {
[16:04:43.261]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.261]                               info)
[16:04:43.261]                           }
[16:04:43.261]                           else {
[16:04:43.261]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.261]                               info, version)
[16:04:43.261]                           }
[16:04:43.261]                           base::stop(msg)
[16:04:43.261]                         }
[16:04:43.261]                       })
[16:04:43.261]                     }
[16:04:43.261]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.261]                     base::options(mc.cores = 1L)
[16:04:43.261]                   }
[16:04:43.261]                   options(future.plan = NULL)
[16:04:43.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.261]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.261]                 }
[16:04:43.261]                 ...future.workdir <- getwd()
[16:04:43.261]             }
[16:04:43.261]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.261]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.261]         }
[16:04:43.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.261]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.261]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.261]             base::names(...future.oldOptions))
[16:04:43.261]     }
[16:04:43.261]     if (FALSE) {
[16:04:43.261]     }
[16:04:43.261]     else {
[16:04:43.261]         if (TRUE) {
[16:04:43.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.261]                 open = "w")
[16:04:43.261]         }
[16:04:43.261]         else {
[16:04:43.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.261]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.261]         }
[16:04:43.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.261]             base::sink(type = "output", split = FALSE)
[16:04:43.261]             base::close(...future.stdout)
[16:04:43.261]         }, add = TRUE)
[16:04:43.261]     }
[16:04:43.261]     ...future.frame <- base::sys.nframe()
[16:04:43.261]     ...future.conditions <- base::list()
[16:04:43.261]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.261]     if (FALSE) {
[16:04:43.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.261]     }
[16:04:43.261]     ...future.result <- base::tryCatch({
[16:04:43.261]         base::withCallingHandlers({
[16:04:43.261]             ...future.value <- base::withVisible(base::local({
[16:04:43.261]                 withCallingHandlers({
[16:04:43.261]                   NULL
[16:04:43.261]                 }, immediateCondition = function(cond) {
[16:04:43.261]                   save_rds <- function (object, pathname, ...) 
[16:04:43.261]                   {
[16:04:43.261]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.261]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.261]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.261]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.261]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.261]                         fi_tmp[["mtime"]])
[16:04:43.261]                     }
[16:04:43.261]                     tryCatch({
[16:04:43.261]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.261]                     }, error = function(ex) {
[16:04:43.261]                       msg <- conditionMessage(ex)
[16:04:43.261]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.261]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.261]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.261]                         fi_tmp[["mtime"]], msg)
[16:04:43.261]                       ex$message <- msg
[16:04:43.261]                       stop(ex)
[16:04:43.261]                     })
[16:04:43.261]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.261]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.261]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.261]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.261]                       fi <- file.info(pathname)
[16:04:43.261]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.261]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.261]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.261]                         fi[["size"]], fi[["mtime"]])
[16:04:43.261]                       stop(msg)
[16:04:43.261]                     }
[16:04:43.261]                     invisible(pathname)
[16:04:43.261]                   }
[16:04:43.261]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.261]                     rootPath = tempdir()) 
[16:04:43.261]                   {
[16:04:43.261]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.261]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.261]                       tmpdir = path, fileext = ".rds")
[16:04:43.261]                     save_rds(obj, file)
[16:04:43.261]                   }
[16:04:43.261]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.261]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.261]                   {
[16:04:43.261]                     inherits <- base::inherits
[16:04:43.261]                     invokeRestart <- base::invokeRestart
[16:04:43.261]                     is.null <- base::is.null
[16:04:43.261]                     muffled <- FALSE
[16:04:43.261]                     if (inherits(cond, "message")) {
[16:04:43.261]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.261]                       if (muffled) 
[16:04:43.261]                         invokeRestart("muffleMessage")
[16:04:43.261]                     }
[16:04:43.261]                     else if (inherits(cond, "warning")) {
[16:04:43.261]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.261]                       if (muffled) 
[16:04:43.261]                         invokeRestart("muffleWarning")
[16:04:43.261]                     }
[16:04:43.261]                     else if (inherits(cond, "condition")) {
[16:04:43.261]                       if (!is.null(pattern)) {
[16:04:43.261]                         computeRestarts <- base::computeRestarts
[16:04:43.261]                         grepl <- base::grepl
[16:04:43.261]                         restarts <- computeRestarts(cond)
[16:04:43.261]                         for (restart in restarts) {
[16:04:43.261]                           name <- restart$name
[16:04:43.261]                           if (is.null(name)) 
[16:04:43.261]                             next
[16:04:43.261]                           if (!grepl(pattern, name)) 
[16:04:43.261]                             next
[16:04:43.261]                           invokeRestart(restart)
[16:04:43.261]                           muffled <- TRUE
[16:04:43.261]                           break
[16:04:43.261]                         }
[16:04:43.261]                       }
[16:04:43.261]                     }
[16:04:43.261]                     invisible(muffled)
[16:04:43.261]                   }
[16:04:43.261]                   muffleCondition(cond)
[16:04:43.261]                 })
[16:04:43.261]             }))
[16:04:43.261]             future::FutureResult(value = ...future.value$value, 
[16:04:43.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.261]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.261]                     ...future.globalenv.names))
[16:04:43.261]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.261]         }, condition = base::local({
[16:04:43.261]             c <- base::c
[16:04:43.261]             inherits <- base::inherits
[16:04:43.261]             invokeRestart <- base::invokeRestart
[16:04:43.261]             length <- base::length
[16:04:43.261]             list <- base::list
[16:04:43.261]             seq.int <- base::seq.int
[16:04:43.261]             signalCondition <- base::signalCondition
[16:04:43.261]             sys.calls <- base::sys.calls
[16:04:43.261]             `[[` <- base::`[[`
[16:04:43.261]             `+` <- base::`+`
[16:04:43.261]             `<<-` <- base::`<<-`
[16:04:43.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.261]                   3L)]
[16:04:43.261]             }
[16:04:43.261]             function(cond) {
[16:04:43.261]                 is_error <- inherits(cond, "error")
[16:04:43.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.261]                   NULL)
[16:04:43.261]                 if (is_error) {
[16:04:43.261]                   sessionInformation <- function() {
[16:04:43.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.261]                       search = base::search(), system = base::Sys.info())
[16:04:43.261]                   }
[16:04:43.261]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.261]                     cond$call), session = sessionInformation(), 
[16:04:43.261]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.261]                   signalCondition(cond)
[16:04:43.261]                 }
[16:04:43.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.261]                 "immediateCondition"))) {
[16:04:43.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.261]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.261]                   if (TRUE && !signal) {
[16:04:43.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.261]                     {
[16:04:43.261]                       inherits <- base::inherits
[16:04:43.261]                       invokeRestart <- base::invokeRestart
[16:04:43.261]                       is.null <- base::is.null
[16:04:43.261]                       muffled <- FALSE
[16:04:43.261]                       if (inherits(cond, "message")) {
[16:04:43.261]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.261]                         if (muffled) 
[16:04:43.261]                           invokeRestart("muffleMessage")
[16:04:43.261]                       }
[16:04:43.261]                       else if (inherits(cond, "warning")) {
[16:04:43.261]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.261]                         if (muffled) 
[16:04:43.261]                           invokeRestart("muffleWarning")
[16:04:43.261]                       }
[16:04:43.261]                       else if (inherits(cond, "condition")) {
[16:04:43.261]                         if (!is.null(pattern)) {
[16:04:43.261]                           computeRestarts <- base::computeRestarts
[16:04:43.261]                           grepl <- base::grepl
[16:04:43.261]                           restarts <- computeRestarts(cond)
[16:04:43.261]                           for (restart in restarts) {
[16:04:43.261]                             name <- restart$name
[16:04:43.261]                             if (is.null(name)) 
[16:04:43.261]                               next
[16:04:43.261]                             if (!grepl(pattern, name)) 
[16:04:43.261]                               next
[16:04:43.261]                             invokeRestart(restart)
[16:04:43.261]                             muffled <- TRUE
[16:04:43.261]                             break
[16:04:43.261]                           }
[16:04:43.261]                         }
[16:04:43.261]                       }
[16:04:43.261]                       invisible(muffled)
[16:04:43.261]                     }
[16:04:43.261]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.261]                   }
[16:04:43.261]                 }
[16:04:43.261]                 else {
[16:04:43.261]                   if (TRUE) {
[16:04:43.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.261]                     {
[16:04:43.261]                       inherits <- base::inherits
[16:04:43.261]                       invokeRestart <- base::invokeRestart
[16:04:43.261]                       is.null <- base::is.null
[16:04:43.261]                       muffled <- FALSE
[16:04:43.261]                       if (inherits(cond, "message")) {
[16:04:43.261]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.261]                         if (muffled) 
[16:04:43.261]                           invokeRestart("muffleMessage")
[16:04:43.261]                       }
[16:04:43.261]                       else if (inherits(cond, "warning")) {
[16:04:43.261]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.261]                         if (muffled) 
[16:04:43.261]                           invokeRestart("muffleWarning")
[16:04:43.261]                       }
[16:04:43.261]                       else if (inherits(cond, "condition")) {
[16:04:43.261]                         if (!is.null(pattern)) {
[16:04:43.261]                           computeRestarts <- base::computeRestarts
[16:04:43.261]                           grepl <- base::grepl
[16:04:43.261]                           restarts <- computeRestarts(cond)
[16:04:43.261]                           for (restart in restarts) {
[16:04:43.261]                             name <- restart$name
[16:04:43.261]                             if (is.null(name)) 
[16:04:43.261]                               next
[16:04:43.261]                             if (!grepl(pattern, name)) 
[16:04:43.261]                               next
[16:04:43.261]                             invokeRestart(restart)
[16:04:43.261]                             muffled <- TRUE
[16:04:43.261]                             break
[16:04:43.261]                           }
[16:04:43.261]                         }
[16:04:43.261]                       }
[16:04:43.261]                       invisible(muffled)
[16:04:43.261]                     }
[16:04:43.261]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.261]                   }
[16:04:43.261]                 }
[16:04:43.261]             }
[16:04:43.261]         }))
[16:04:43.261]     }, error = function(ex) {
[16:04:43.261]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.261]                 ...future.rng), started = ...future.startTime, 
[16:04:43.261]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.261]             version = "1.8"), class = "FutureResult")
[16:04:43.261]     }, finally = {
[16:04:43.261]         if (!identical(...future.workdir, getwd())) 
[16:04:43.261]             setwd(...future.workdir)
[16:04:43.261]         {
[16:04:43.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.261]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.261]             }
[16:04:43.261]             base::options(...future.oldOptions)
[16:04:43.261]             if (.Platform$OS.type == "windows") {
[16:04:43.261]                 old_names <- names(...future.oldEnvVars)
[16:04:43.261]                 envs <- base::Sys.getenv()
[16:04:43.261]                 names <- names(envs)
[16:04:43.261]                 common <- intersect(names, old_names)
[16:04:43.261]                 added <- setdiff(names, old_names)
[16:04:43.261]                 removed <- setdiff(old_names, names)
[16:04:43.261]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.261]                   envs[common]]
[16:04:43.261]                 NAMES <- toupper(changed)
[16:04:43.261]                 args <- list()
[16:04:43.261]                 for (kk in seq_along(NAMES)) {
[16:04:43.261]                   name <- changed[[kk]]
[16:04:43.261]                   NAME <- NAMES[[kk]]
[16:04:43.261]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.261]                     next
[16:04:43.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.261]                 }
[16:04:43.261]                 NAMES <- toupper(added)
[16:04:43.261]                 for (kk in seq_along(NAMES)) {
[16:04:43.261]                   name <- added[[kk]]
[16:04:43.261]                   NAME <- NAMES[[kk]]
[16:04:43.261]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.261]                     next
[16:04:43.261]                   args[[name]] <- ""
[16:04:43.261]                 }
[16:04:43.261]                 NAMES <- toupper(removed)
[16:04:43.261]                 for (kk in seq_along(NAMES)) {
[16:04:43.261]                   name <- removed[[kk]]
[16:04:43.261]                   NAME <- NAMES[[kk]]
[16:04:43.261]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.261]                     next
[16:04:43.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.261]                 }
[16:04:43.261]                 if (length(args) > 0) 
[16:04:43.261]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.261]             }
[16:04:43.261]             else {
[16:04:43.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.261]             }
[16:04:43.261]             {
[16:04:43.261]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.261]                   0L) {
[16:04:43.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.261]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.261]                   base::options(opts)
[16:04:43.261]                 }
[16:04:43.261]                 {
[16:04:43.261]                   {
[16:04:43.261]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.261]                     NULL
[16:04:43.261]                   }
[16:04:43.261]                   options(future.plan = NULL)
[16:04:43.261]                   if (is.na(NA_character_)) 
[16:04:43.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.261]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.261]                     envir = parent.frame()) 
[16:04:43.261]                   {
[16:04:43.261]                     default_workers <- missing(workers)
[16:04:43.261]                     if (is.function(workers)) 
[16:04:43.261]                       workers <- workers()
[16:04:43.261]                     workers <- structure(as.integer(workers), 
[16:04:43.261]                       class = class(workers))
[16:04:43.261]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.261]                       1L)
[16:04:43.261]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.261]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.261]                       if (default_workers) 
[16:04:43.261]                         supportsMulticore(warn = TRUE)
[16:04:43.261]                       return(sequential(..., envir = envir))
[16:04:43.261]                     }
[16:04:43.261]                     oopts <- options(mc.cores = workers)
[16:04:43.261]                     on.exit(options(oopts))
[16:04:43.261]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.261]                       envir = envir)
[16:04:43.261]                     if (!future$lazy) 
[16:04:43.261]                       future <- run(future)
[16:04:43.261]                     invisible(future)
[16:04:43.261]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.261]                 }
[16:04:43.261]             }
[16:04:43.261]         }
[16:04:43.261]     })
[16:04:43.261]     if (TRUE) {
[16:04:43.261]         base::sink(type = "output", split = FALSE)
[16:04:43.261]         if (TRUE) {
[16:04:43.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.261]         }
[16:04:43.261]         else {
[16:04:43.261]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.261]         }
[16:04:43.261]         base::close(...future.stdout)
[16:04:43.261]         ...future.stdout <- NULL
[16:04:43.261]     }
[16:04:43.261]     ...future.result$conditions <- ...future.conditions
[16:04:43.261]     ...future.result$finished <- base::Sys.time()
[16:04:43.261]     ...future.result
[16:04:43.261] }
[16:04:43.265] requestCore(): workers = 2
[16:04:43.267] MulticoreFuture started
[16:04:43.268] - Launch lazy future ... done
[16:04:43.268] run() for ‘MulticoreFuture’ ... done
[16:04:43.268] plan(): Setting new future strategy stack:
[16:04:43.269] getGlobalsAndPackages() ...
[16:04:43.269] Searching for globals...
[16:04:43.269] List of future strategies:
[16:04:43.269] 1. sequential:
[16:04:43.269]    - args: function (..., envir = parent.frame())
[16:04:43.269]    - tweaked: FALSE
[16:04:43.269]    - call: NULL
[16:04:43.270] plan(): nbrOfWorkers() = 1
[16:04:43.270] - globals found: [1] ‘{’
[16:04:43.270] Searching for globals ... DONE
[16:04:43.270] Resolving globals: FALSE
[16:04:43.271] 
[16:04:43.271] 
[16:04:43.271] getGlobalsAndPackages() ... DONE
[16:04:43.271] plan(): Setting new future strategy stack:
[16:04:43.272] run() for ‘Future’ ...
[16:04:43.272] - state: ‘created’
[16:04:43.272] List of future strategies:
[16:04:43.272] 1. multicore:
[16:04:43.272]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.272]    - tweaked: FALSE
[16:04:43.272]    - call: plan(strategy)
[16:04:43.272] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.277] plan(): nbrOfWorkers() = 2
[16:04:43.277] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.277] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.277]   - Field: ‘label’
[16:04:43.277]   - Field: ‘local’
[16:04:43.277]   - Field: ‘owner’
[16:04:43.277]   - Field: ‘envir’
[16:04:43.278]   - Field: ‘workers’
[16:04:43.278]   - Field: ‘packages’
[16:04:43.278]   - Field: ‘gc’
[16:04:43.278]   - Field: ‘job’
[16:04:43.278]   - Field: ‘conditions’
[16:04:43.278]   - Field: ‘expr’
[16:04:43.278]   - Field: ‘uuid’
[16:04:43.279]   - Field: ‘seed’
[16:04:43.279]   - Field: ‘version’
[16:04:43.279]   - Field: ‘result’
[16:04:43.279]   - Field: ‘asynchronous’
[16:04:43.279]   - Field: ‘calls’
[16:04:43.279]   - Field: ‘globals’
[16:04:43.279]   - Field: ‘stdout’
[16:04:43.280]   - Field: ‘earlySignal’
[16:04:43.280]   - Field: ‘lazy’
[16:04:43.280]   - Field: ‘state’
[16:04:43.280] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.280] - Launch lazy future ...
[16:04:43.281] Packages needed by the future expression (n = 0): <none>
[16:04:43.281] Packages needed by future strategies (n = 0): <none>
[16:04:43.281] {
[16:04:43.281]     {
[16:04:43.281]         {
[16:04:43.281]             ...future.startTime <- base::Sys.time()
[16:04:43.281]             {
[16:04:43.281]                 {
[16:04:43.281]                   {
[16:04:43.281]                     {
[16:04:43.281]                       base::local({
[16:04:43.281]                         has_future <- base::requireNamespace("future", 
[16:04:43.281]                           quietly = TRUE)
[16:04:43.281]                         if (has_future) {
[16:04:43.281]                           ns <- base::getNamespace("future")
[16:04:43.281]                           version <- ns[[".package"]][["version"]]
[16:04:43.281]                           if (is.null(version)) 
[16:04:43.281]                             version <- utils::packageVersion("future")
[16:04:43.281]                         }
[16:04:43.281]                         else {
[16:04:43.281]                           version <- NULL
[16:04:43.281]                         }
[16:04:43.281]                         if (!has_future || version < "1.8.0") {
[16:04:43.281]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.281]                             "", base::R.version$version.string), 
[16:04:43.281]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.281]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.281]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.281]                               "release", "version")], collapse = " "), 
[16:04:43.281]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.281]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.281]                             info)
[16:04:43.281]                           info <- base::paste(info, collapse = "; ")
[16:04:43.281]                           if (!has_future) {
[16:04:43.281]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.281]                               info)
[16:04:43.281]                           }
[16:04:43.281]                           else {
[16:04:43.281]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.281]                               info, version)
[16:04:43.281]                           }
[16:04:43.281]                           base::stop(msg)
[16:04:43.281]                         }
[16:04:43.281]                       })
[16:04:43.281]                     }
[16:04:43.281]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.281]                     base::options(mc.cores = 1L)
[16:04:43.281]                   }
[16:04:43.281]                   options(future.plan = NULL)
[16:04:43.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.281]                 }
[16:04:43.281]                 ...future.workdir <- getwd()
[16:04:43.281]             }
[16:04:43.281]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.281]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.281]         }
[16:04:43.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.281]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.281]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.281]             base::names(...future.oldOptions))
[16:04:43.281]     }
[16:04:43.281]     if (FALSE) {
[16:04:43.281]     }
[16:04:43.281]     else {
[16:04:43.281]         if (TRUE) {
[16:04:43.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.281]                 open = "w")
[16:04:43.281]         }
[16:04:43.281]         else {
[16:04:43.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.281]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.281]         }
[16:04:43.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.281]             base::sink(type = "output", split = FALSE)
[16:04:43.281]             base::close(...future.stdout)
[16:04:43.281]         }, add = TRUE)
[16:04:43.281]     }
[16:04:43.281]     ...future.frame <- base::sys.nframe()
[16:04:43.281]     ...future.conditions <- base::list()
[16:04:43.281]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.281]     if (FALSE) {
[16:04:43.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.281]     }
[16:04:43.281]     ...future.result <- base::tryCatch({
[16:04:43.281]         base::withCallingHandlers({
[16:04:43.281]             ...future.value <- base::withVisible(base::local({
[16:04:43.281]                 withCallingHandlers({
[16:04:43.281]                   {
[16:04:43.281]                     4
[16:04:43.281]                   }
[16:04:43.281]                 }, immediateCondition = function(cond) {
[16:04:43.281]                   save_rds <- function (object, pathname, ...) 
[16:04:43.281]                   {
[16:04:43.281]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.281]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.281]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.281]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.281]                         fi_tmp[["mtime"]])
[16:04:43.281]                     }
[16:04:43.281]                     tryCatch({
[16:04:43.281]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.281]                     }, error = function(ex) {
[16:04:43.281]                       msg <- conditionMessage(ex)
[16:04:43.281]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.281]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.281]                         fi_tmp[["mtime"]], msg)
[16:04:43.281]                       ex$message <- msg
[16:04:43.281]                       stop(ex)
[16:04:43.281]                     })
[16:04:43.281]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.281]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.281]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.281]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.281]                       fi <- file.info(pathname)
[16:04:43.281]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.281]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.281]                         fi[["size"]], fi[["mtime"]])
[16:04:43.281]                       stop(msg)
[16:04:43.281]                     }
[16:04:43.281]                     invisible(pathname)
[16:04:43.281]                   }
[16:04:43.281]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.281]                     rootPath = tempdir()) 
[16:04:43.281]                   {
[16:04:43.281]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.281]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.281]                       tmpdir = path, fileext = ".rds")
[16:04:43.281]                     save_rds(obj, file)
[16:04:43.281]                   }
[16:04:43.281]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.281]                   {
[16:04:43.281]                     inherits <- base::inherits
[16:04:43.281]                     invokeRestart <- base::invokeRestart
[16:04:43.281]                     is.null <- base::is.null
[16:04:43.281]                     muffled <- FALSE
[16:04:43.281]                     if (inherits(cond, "message")) {
[16:04:43.281]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.281]                       if (muffled) 
[16:04:43.281]                         invokeRestart("muffleMessage")
[16:04:43.281]                     }
[16:04:43.281]                     else if (inherits(cond, "warning")) {
[16:04:43.281]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.281]                       if (muffled) 
[16:04:43.281]                         invokeRestart("muffleWarning")
[16:04:43.281]                     }
[16:04:43.281]                     else if (inherits(cond, "condition")) {
[16:04:43.281]                       if (!is.null(pattern)) {
[16:04:43.281]                         computeRestarts <- base::computeRestarts
[16:04:43.281]                         grepl <- base::grepl
[16:04:43.281]                         restarts <- computeRestarts(cond)
[16:04:43.281]                         for (restart in restarts) {
[16:04:43.281]                           name <- restart$name
[16:04:43.281]                           if (is.null(name)) 
[16:04:43.281]                             next
[16:04:43.281]                           if (!grepl(pattern, name)) 
[16:04:43.281]                             next
[16:04:43.281]                           invokeRestart(restart)
[16:04:43.281]                           muffled <- TRUE
[16:04:43.281]                           break
[16:04:43.281]                         }
[16:04:43.281]                       }
[16:04:43.281]                     }
[16:04:43.281]                     invisible(muffled)
[16:04:43.281]                   }
[16:04:43.281]                   muffleCondition(cond)
[16:04:43.281]                 })
[16:04:43.281]             }))
[16:04:43.281]             future::FutureResult(value = ...future.value$value, 
[16:04:43.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.281]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.281]                     ...future.globalenv.names))
[16:04:43.281]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.281]         }, condition = base::local({
[16:04:43.281]             c <- base::c
[16:04:43.281]             inherits <- base::inherits
[16:04:43.281]             invokeRestart <- base::invokeRestart
[16:04:43.281]             length <- base::length
[16:04:43.281]             list <- base::list
[16:04:43.281]             seq.int <- base::seq.int
[16:04:43.281]             signalCondition <- base::signalCondition
[16:04:43.281]             sys.calls <- base::sys.calls
[16:04:43.281]             `[[` <- base::`[[`
[16:04:43.281]             `+` <- base::`+`
[16:04:43.281]             `<<-` <- base::`<<-`
[16:04:43.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.281]                   3L)]
[16:04:43.281]             }
[16:04:43.281]             function(cond) {
[16:04:43.281]                 is_error <- inherits(cond, "error")
[16:04:43.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.281]                   NULL)
[16:04:43.281]                 if (is_error) {
[16:04:43.281]                   sessionInformation <- function() {
[16:04:43.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.281]                       search = base::search(), system = base::Sys.info())
[16:04:43.281]                   }
[16:04:43.281]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.281]                     cond$call), session = sessionInformation(), 
[16:04:43.281]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.281]                   signalCondition(cond)
[16:04:43.281]                 }
[16:04:43.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.281]                 "immediateCondition"))) {
[16:04:43.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.281]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.281]                   if (TRUE && !signal) {
[16:04:43.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.281]                     {
[16:04:43.281]                       inherits <- base::inherits
[16:04:43.281]                       invokeRestart <- base::invokeRestart
[16:04:43.281]                       is.null <- base::is.null
[16:04:43.281]                       muffled <- FALSE
[16:04:43.281]                       if (inherits(cond, "message")) {
[16:04:43.281]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.281]                         if (muffled) 
[16:04:43.281]                           invokeRestart("muffleMessage")
[16:04:43.281]                       }
[16:04:43.281]                       else if (inherits(cond, "warning")) {
[16:04:43.281]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.281]                         if (muffled) 
[16:04:43.281]                           invokeRestart("muffleWarning")
[16:04:43.281]                       }
[16:04:43.281]                       else if (inherits(cond, "condition")) {
[16:04:43.281]                         if (!is.null(pattern)) {
[16:04:43.281]                           computeRestarts <- base::computeRestarts
[16:04:43.281]                           grepl <- base::grepl
[16:04:43.281]                           restarts <- computeRestarts(cond)
[16:04:43.281]                           for (restart in restarts) {
[16:04:43.281]                             name <- restart$name
[16:04:43.281]                             if (is.null(name)) 
[16:04:43.281]                               next
[16:04:43.281]                             if (!grepl(pattern, name)) 
[16:04:43.281]                               next
[16:04:43.281]                             invokeRestart(restart)
[16:04:43.281]                             muffled <- TRUE
[16:04:43.281]                             break
[16:04:43.281]                           }
[16:04:43.281]                         }
[16:04:43.281]                       }
[16:04:43.281]                       invisible(muffled)
[16:04:43.281]                     }
[16:04:43.281]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.281]                   }
[16:04:43.281]                 }
[16:04:43.281]                 else {
[16:04:43.281]                   if (TRUE) {
[16:04:43.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.281]                     {
[16:04:43.281]                       inherits <- base::inherits
[16:04:43.281]                       invokeRestart <- base::invokeRestart
[16:04:43.281]                       is.null <- base::is.null
[16:04:43.281]                       muffled <- FALSE
[16:04:43.281]                       if (inherits(cond, "message")) {
[16:04:43.281]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.281]                         if (muffled) 
[16:04:43.281]                           invokeRestart("muffleMessage")
[16:04:43.281]                       }
[16:04:43.281]                       else if (inherits(cond, "warning")) {
[16:04:43.281]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.281]                         if (muffled) 
[16:04:43.281]                           invokeRestart("muffleWarning")
[16:04:43.281]                       }
[16:04:43.281]                       else if (inherits(cond, "condition")) {
[16:04:43.281]                         if (!is.null(pattern)) {
[16:04:43.281]                           computeRestarts <- base::computeRestarts
[16:04:43.281]                           grepl <- base::grepl
[16:04:43.281]                           restarts <- computeRestarts(cond)
[16:04:43.281]                           for (restart in restarts) {
[16:04:43.281]                             name <- restart$name
[16:04:43.281]                             if (is.null(name)) 
[16:04:43.281]                               next
[16:04:43.281]                             if (!grepl(pattern, name)) 
[16:04:43.281]                               next
[16:04:43.281]                             invokeRestart(restart)
[16:04:43.281]                             muffled <- TRUE
[16:04:43.281]                             break
[16:04:43.281]                           }
[16:04:43.281]                         }
[16:04:43.281]                       }
[16:04:43.281]                       invisible(muffled)
[16:04:43.281]                     }
[16:04:43.281]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.281]                   }
[16:04:43.281]                 }
[16:04:43.281]             }
[16:04:43.281]         }))
[16:04:43.281]     }, error = function(ex) {
[16:04:43.281]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.281]                 ...future.rng), started = ...future.startTime, 
[16:04:43.281]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.281]             version = "1.8"), class = "FutureResult")
[16:04:43.281]     }, finally = {
[16:04:43.281]         if (!identical(...future.workdir, getwd())) 
[16:04:43.281]             setwd(...future.workdir)
[16:04:43.281]         {
[16:04:43.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.281]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.281]             }
[16:04:43.281]             base::options(...future.oldOptions)
[16:04:43.281]             if (.Platform$OS.type == "windows") {
[16:04:43.281]                 old_names <- names(...future.oldEnvVars)
[16:04:43.281]                 envs <- base::Sys.getenv()
[16:04:43.281]                 names <- names(envs)
[16:04:43.281]                 common <- intersect(names, old_names)
[16:04:43.281]                 added <- setdiff(names, old_names)
[16:04:43.281]                 removed <- setdiff(old_names, names)
[16:04:43.281]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.281]                   envs[common]]
[16:04:43.281]                 NAMES <- toupper(changed)
[16:04:43.281]                 args <- list()
[16:04:43.281]                 for (kk in seq_along(NAMES)) {
[16:04:43.281]                   name <- changed[[kk]]
[16:04:43.281]                   NAME <- NAMES[[kk]]
[16:04:43.281]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.281]                     next
[16:04:43.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.281]                 }
[16:04:43.281]                 NAMES <- toupper(added)
[16:04:43.281]                 for (kk in seq_along(NAMES)) {
[16:04:43.281]                   name <- added[[kk]]
[16:04:43.281]                   NAME <- NAMES[[kk]]
[16:04:43.281]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.281]                     next
[16:04:43.281]                   args[[name]] <- ""
[16:04:43.281]                 }
[16:04:43.281]                 NAMES <- toupper(removed)
[16:04:43.281]                 for (kk in seq_along(NAMES)) {
[16:04:43.281]                   name <- removed[[kk]]
[16:04:43.281]                   NAME <- NAMES[[kk]]
[16:04:43.281]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.281]                     next
[16:04:43.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.281]                 }
[16:04:43.281]                 if (length(args) > 0) 
[16:04:43.281]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.281]             }
[16:04:43.281]             else {
[16:04:43.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.281]             }
[16:04:43.281]             {
[16:04:43.281]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.281]                   0L) {
[16:04:43.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.281]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.281]                   base::options(opts)
[16:04:43.281]                 }
[16:04:43.281]                 {
[16:04:43.281]                   {
[16:04:43.281]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.281]                     NULL
[16:04:43.281]                   }
[16:04:43.281]                   options(future.plan = NULL)
[16:04:43.281]                   if (is.na(NA_character_)) 
[16:04:43.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.281]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.281]                     envir = parent.frame()) 
[16:04:43.281]                   {
[16:04:43.281]                     default_workers <- missing(workers)
[16:04:43.281]                     if (is.function(workers)) 
[16:04:43.281]                       workers <- workers()
[16:04:43.281]                     workers <- structure(as.integer(workers), 
[16:04:43.281]                       class = class(workers))
[16:04:43.281]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.281]                       1L)
[16:04:43.281]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.281]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.281]                       if (default_workers) 
[16:04:43.281]                         supportsMulticore(warn = TRUE)
[16:04:43.281]                       return(sequential(..., envir = envir))
[16:04:43.281]                     }
[16:04:43.281]                     oopts <- options(mc.cores = workers)
[16:04:43.281]                     on.exit(options(oopts))
[16:04:43.281]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.281]                       envir = envir)
[16:04:43.281]                     if (!future$lazy) 
[16:04:43.281]                       future <- run(future)
[16:04:43.281]                     invisible(future)
[16:04:43.281]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.281]                 }
[16:04:43.281]             }
[16:04:43.281]         }
[16:04:43.281]     })
[16:04:43.281]     if (TRUE) {
[16:04:43.281]         base::sink(type = "output", split = FALSE)
[16:04:43.281]         if (TRUE) {
[16:04:43.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.281]         }
[16:04:43.281]         else {
[16:04:43.281]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.281]         }
[16:04:43.281]         base::close(...future.stdout)
[16:04:43.281]         ...future.stdout <- NULL
[16:04:43.281]     }
[16:04:43.281]     ...future.result$conditions <- ...future.conditions
[16:04:43.281]     ...future.result$finished <- base::Sys.time()
[16:04:43.281]     ...future.result
[16:04:43.281] }
[16:04:43.285] requestCore(): workers = 2
[16:04:43.285] Poll #1 (0): usedCores() = 2, workers = 2
[16:04:43.308] result() for MulticoreFuture ...
[16:04:43.309] result() for MulticoreFuture ...
[16:04:43.309] result() for MulticoreFuture ... done
[16:04:43.309] result() for MulticoreFuture ... done
[16:04:43.310] result() for MulticoreFuture ...
[16:04:43.310] result() for MulticoreFuture ... done
[16:04:43.312] MulticoreFuture started
[16:04:43.313] - Launch lazy future ... done
[16:04:43.313] run() for ‘MulticoreFuture’ ... done
[16:04:43.314] plan(): Setting new future strategy stack:
<environment: 0x55874bfed1e8> 
[16:04:43.314] List of future strategies:
[16:04:43.314] 1. sequential:
[16:04:43.314]    - args: function (..., envir = parent.frame())
[16:04:43.314]    - tweaked: FALSE
[16:04:43.314]    - call: NULL
[16:04:43.315] plan(): nbrOfWorkers() = 1
<environment: 0x55874f5d7278> 
[16:04:43.318] plan(): Setting new future strategy stack:
[16:04:43.318] List of future strategies:
[16:04:43.318] 1. multicore:
[16:04:43.318]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.318]    - tweaked: FALSE
[16:04:43.318]    - call: plan(strategy)
[16:04:43.322] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:43.325] resolve() on environment ...
[16:04:43.325]  recursive: 0
[16:04:43.326]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:43.326] signalConditionsASAP(numeric, pos=1) ...
[16:04:43.326] - nx: 4
[16:04:43.326] - relay: TRUE
[16:04:43.326] - stdout: TRUE
[16:04:43.326] - signal: TRUE
[16:04:43.326] - resignal: FALSE
[16:04:43.326] - force: TRUE
[16:04:43.327] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.327] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.327]  - until=2
[16:04:43.327]  - relaying element #2
[16:04:43.327] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:43.327] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.327] signalConditionsASAP(NULL, pos=1) ... done
[16:04:43.328]  length: 3 (resolved future 1)
[16:04:43.328] Future #2
[16:04:43.328] result() for MulticoreFuture ...
[16:04:43.328] result() for MulticoreFuture ... done
[16:04:43.328] result() for MulticoreFuture ...
[16:04:43.328] result() for MulticoreFuture ... done
[16:04:43.328] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:43.329] - nx: 4
[16:04:43.329] - relay: TRUE
[16:04:43.329] - stdout: TRUE
[16:04:43.329] - signal: TRUE
[16:04:43.329] - resignal: FALSE
[16:04:43.329] - force: TRUE
[16:04:43.329] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:43.329] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.330]  - until=2
[16:04:43.330]  - relaying element #2
[16:04:43.330] result() for MulticoreFuture ...
[16:04:43.330] result() for MulticoreFuture ... done
[16:04:43.330] result() for MulticoreFuture ...
[16:04:43.330] result() for MulticoreFuture ... done
[16:04:43.330] result() for MulticoreFuture ...
[16:04:43.330] result() for MulticoreFuture ... done
[16:04:43.331] result() for MulticoreFuture ...
[16:04:43.331] result() for MulticoreFuture ... done
[16:04:43.331] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:43.331] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:43.331] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:43.331]  length: 2 (resolved future 2)
[16:04:43.332] Future #3
[16:04:43.332] result() for MulticoreFuture ...
[16:04:43.332] result() for MulticoreFuture ...
[16:04:43.333] result() for MulticoreFuture ... done
[16:04:43.333] result() for MulticoreFuture ... done
[16:04:43.333] result() for MulticoreFuture ...
[16:04:43.333] result() for MulticoreFuture ... done
[16:04:43.333] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:43.333] - nx: 4
[16:04:43.333] - relay: TRUE
[16:04:43.333] - stdout: TRUE
[16:04:43.334] - signal: TRUE
[16:04:43.334] - resignal: FALSE
[16:04:43.334] - force: TRUE
[16:04:43.334] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:43.334] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:43.334]  - until=3
[16:04:43.334]  - relaying element #3
[16:04:43.334] result() for MulticoreFuture ...
[16:04:43.335] result() for MulticoreFuture ... done
[16:04:43.335] result() for MulticoreFuture ...
[16:04:43.335] result() for MulticoreFuture ... done
[16:04:43.335] result() for MulticoreFuture ...
[16:04:43.335] result() for MulticoreFuture ... done
[16:04:43.335] result() for MulticoreFuture ...
[16:04:43.335] result() for MulticoreFuture ... done
[16:04:43.336] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:43.336] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:43.336] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:43.336]  length: 1 (resolved future 3)
[16:04:43.336] Future #4
[16:04:43.336] result() for MulticoreFuture ...
[16:04:43.337] result() for MulticoreFuture ...
[16:04:43.337] result() for MulticoreFuture ... done
[16:04:43.337] result() for MulticoreFuture ... done
[16:04:43.338] result() for MulticoreFuture ...
[16:04:43.338] result() for MulticoreFuture ... done
[16:04:43.338] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:04:43.338] - nx: 4
[16:04:43.338] - relay: TRUE
[16:04:43.338] - stdout: TRUE
[16:04:43.339] - signal: TRUE
[16:04:43.339] - resignal: FALSE
[16:04:43.339] - force: TRUE
[16:04:43.339] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:43.339] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:43.339]  - until=4
[16:04:43.340]  - relaying element #4
[16:04:43.340] result() for MulticoreFuture ...
[16:04:43.340] result() for MulticoreFuture ... done
[16:04:43.340] result() for MulticoreFuture ...
[16:04:43.340] result() for MulticoreFuture ... done
[16:04:43.340] result() for MulticoreFuture ...
[16:04:43.340] result() for MulticoreFuture ... done
[16:04:43.341] result() for MulticoreFuture ...
[16:04:43.341] result() for MulticoreFuture ... done
[16:04:43.341] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.341] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:43.341] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:04:43.341]  length: 0 (resolved future 4)
[16:04:43.341] Relaying remaining futures
[16:04:43.341] signalConditionsASAP(NULL, pos=0) ...
[16:04:43.341] - nx: 4
[16:04:43.341] - relay: TRUE
[16:04:43.342] - stdout: TRUE
[16:04:43.342] - signal: TRUE
[16:04:43.342] - resignal: FALSE
[16:04:43.342] - force: TRUE
[16:04:43.342] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.342] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:43.342] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.342] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:43.342] signalConditionsASAP(NULL, pos=0) ... done
[16:04:43.343] resolve() on environment ... DONE
[16:04:43.343] result() for MulticoreFuture ...
[16:04:43.343] result() for MulticoreFuture ... done
[16:04:43.343] result() for MulticoreFuture ...
[16:04:43.343] result() for MulticoreFuture ... done
[16:04:43.343] result() for MulticoreFuture ...
[16:04:43.343] result() for MulticoreFuture ... done
[16:04:43.343] result() for MulticoreFuture ...
[16:04:43.343] result() for MulticoreFuture ... done
[16:04:43.344] result() for MulticoreFuture ...
[16:04:43.344] result() for MulticoreFuture ... done
[16:04:43.344] result() for MulticoreFuture ...
[16:04:43.344] result() for MulticoreFuture ... done
<environment: 0x55874f680fb8> 
Dimensions: c(2, 3)
[16:04:43.344] getGlobalsAndPackages() ...
[16:04:43.344] Searching for globals...
[16:04:43.345] 
[16:04:43.345] Searching for globals ... DONE
[16:04:43.345] - globals: [0] <none>
[16:04:43.345] getGlobalsAndPackages() ... DONE
[16:04:43.349] run() for ‘Future’ ...
[16:04:43.349] - state: ‘created’
[16:04:43.349] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.353] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.353] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.353]   - Field: ‘label’
[16:04:43.353]   - Field: ‘local’
[16:04:43.354]   - Field: ‘owner’
[16:04:43.354]   - Field: ‘envir’
[16:04:43.354]   - Field: ‘workers’
[16:04:43.354]   - Field: ‘packages’
[16:04:43.354]   - Field: ‘gc’
[16:04:43.354]   - Field: ‘job’
[16:04:43.354]   - Field: ‘conditions’
[16:04:43.354]   - Field: ‘expr’
[16:04:43.354]   - Field: ‘uuid’
[16:04:43.354]   - Field: ‘seed’
[16:04:43.355]   - Field: ‘version’
[16:04:43.355]   - Field: ‘result’
[16:04:43.355]   - Field: ‘asynchronous’
[16:04:43.355]   - Field: ‘calls’
[16:04:43.355]   - Field: ‘globals’
[16:04:43.355]   - Field: ‘stdout’
[16:04:43.355]   - Field: ‘earlySignal’
[16:04:43.355]   - Field: ‘lazy’
[16:04:43.356]   - Field: ‘state’
[16:04:43.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.356] - Launch lazy future ...
[16:04:43.356] Packages needed by the future expression (n = 0): <none>
[16:04:43.356] Packages needed by future strategies (n = 0): <none>
[16:04:43.357] {
[16:04:43.357]     {
[16:04:43.357]         {
[16:04:43.357]             ...future.startTime <- base::Sys.time()
[16:04:43.357]             {
[16:04:43.357]                 {
[16:04:43.357]                   {
[16:04:43.357]                     {
[16:04:43.357]                       base::local({
[16:04:43.357]                         has_future <- base::requireNamespace("future", 
[16:04:43.357]                           quietly = TRUE)
[16:04:43.357]                         if (has_future) {
[16:04:43.357]                           ns <- base::getNamespace("future")
[16:04:43.357]                           version <- ns[[".package"]][["version"]]
[16:04:43.357]                           if (is.null(version)) 
[16:04:43.357]                             version <- utils::packageVersion("future")
[16:04:43.357]                         }
[16:04:43.357]                         else {
[16:04:43.357]                           version <- NULL
[16:04:43.357]                         }
[16:04:43.357]                         if (!has_future || version < "1.8.0") {
[16:04:43.357]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.357]                             "", base::R.version$version.string), 
[16:04:43.357]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.357]                               "release", "version")], collapse = " "), 
[16:04:43.357]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.357]                             info)
[16:04:43.357]                           info <- base::paste(info, collapse = "; ")
[16:04:43.357]                           if (!has_future) {
[16:04:43.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.357]                               info)
[16:04:43.357]                           }
[16:04:43.357]                           else {
[16:04:43.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.357]                               info, version)
[16:04:43.357]                           }
[16:04:43.357]                           base::stop(msg)
[16:04:43.357]                         }
[16:04:43.357]                       })
[16:04:43.357]                     }
[16:04:43.357]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.357]                     base::options(mc.cores = 1L)
[16:04:43.357]                   }
[16:04:43.357]                   options(future.plan = NULL)
[16:04:43.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.357]                 }
[16:04:43.357]                 ...future.workdir <- getwd()
[16:04:43.357]             }
[16:04:43.357]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.357]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.357]         }
[16:04:43.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.357]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.357]             base::names(...future.oldOptions))
[16:04:43.357]     }
[16:04:43.357]     if (FALSE) {
[16:04:43.357]     }
[16:04:43.357]     else {
[16:04:43.357]         if (TRUE) {
[16:04:43.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.357]                 open = "w")
[16:04:43.357]         }
[16:04:43.357]         else {
[16:04:43.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.357]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.357]         }
[16:04:43.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.357]             base::sink(type = "output", split = FALSE)
[16:04:43.357]             base::close(...future.stdout)
[16:04:43.357]         }, add = TRUE)
[16:04:43.357]     }
[16:04:43.357]     ...future.frame <- base::sys.nframe()
[16:04:43.357]     ...future.conditions <- base::list()
[16:04:43.357]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.357]     if (FALSE) {
[16:04:43.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.357]     }
[16:04:43.357]     ...future.result <- base::tryCatch({
[16:04:43.357]         base::withCallingHandlers({
[16:04:43.357]             ...future.value <- base::withVisible(base::local({
[16:04:43.357]                 withCallingHandlers({
[16:04:43.357]                   2
[16:04:43.357]                 }, immediateCondition = function(cond) {
[16:04:43.357]                   save_rds <- function (object, pathname, ...) 
[16:04:43.357]                   {
[16:04:43.357]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.357]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.357]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.357]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.357]                         fi_tmp[["mtime"]])
[16:04:43.357]                     }
[16:04:43.357]                     tryCatch({
[16:04:43.357]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.357]                     }, error = function(ex) {
[16:04:43.357]                       msg <- conditionMessage(ex)
[16:04:43.357]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.357]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.357]                         fi_tmp[["mtime"]], msg)
[16:04:43.357]                       ex$message <- msg
[16:04:43.357]                       stop(ex)
[16:04:43.357]                     })
[16:04:43.357]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.357]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.357]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.357]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.357]                       fi <- file.info(pathname)
[16:04:43.357]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.357]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.357]                         fi[["size"]], fi[["mtime"]])
[16:04:43.357]                       stop(msg)
[16:04:43.357]                     }
[16:04:43.357]                     invisible(pathname)
[16:04:43.357]                   }
[16:04:43.357]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.357]                     rootPath = tempdir()) 
[16:04:43.357]                   {
[16:04:43.357]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.357]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.357]                       tmpdir = path, fileext = ".rds")
[16:04:43.357]                     save_rds(obj, file)
[16:04:43.357]                   }
[16:04:43.357]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.357]                   {
[16:04:43.357]                     inherits <- base::inherits
[16:04:43.357]                     invokeRestart <- base::invokeRestart
[16:04:43.357]                     is.null <- base::is.null
[16:04:43.357]                     muffled <- FALSE
[16:04:43.357]                     if (inherits(cond, "message")) {
[16:04:43.357]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.357]                       if (muffled) 
[16:04:43.357]                         invokeRestart("muffleMessage")
[16:04:43.357]                     }
[16:04:43.357]                     else if (inherits(cond, "warning")) {
[16:04:43.357]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.357]                       if (muffled) 
[16:04:43.357]                         invokeRestart("muffleWarning")
[16:04:43.357]                     }
[16:04:43.357]                     else if (inherits(cond, "condition")) {
[16:04:43.357]                       if (!is.null(pattern)) {
[16:04:43.357]                         computeRestarts <- base::computeRestarts
[16:04:43.357]                         grepl <- base::grepl
[16:04:43.357]                         restarts <- computeRestarts(cond)
[16:04:43.357]                         for (restart in restarts) {
[16:04:43.357]                           name <- restart$name
[16:04:43.357]                           if (is.null(name)) 
[16:04:43.357]                             next
[16:04:43.357]                           if (!grepl(pattern, name)) 
[16:04:43.357]                             next
[16:04:43.357]                           invokeRestart(restart)
[16:04:43.357]                           muffled <- TRUE
[16:04:43.357]                           break
[16:04:43.357]                         }
[16:04:43.357]                       }
[16:04:43.357]                     }
[16:04:43.357]                     invisible(muffled)
[16:04:43.357]                   }
[16:04:43.357]                   muffleCondition(cond)
[16:04:43.357]                 })
[16:04:43.357]             }))
[16:04:43.357]             future::FutureResult(value = ...future.value$value, 
[16:04:43.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.357]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.357]                     ...future.globalenv.names))
[16:04:43.357]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.357]         }, condition = base::local({
[16:04:43.357]             c <- base::c
[16:04:43.357]             inherits <- base::inherits
[16:04:43.357]             invokeRestart <- base::invokeRestart
[16:04:43.357]             length <- base::length
[16:04:43.357]             list <- base::list
[16:04:43.357]             seq.int <- base::seq.int
[16:04:43.357]             signalCondition <- base::signalCondition
[16:04:43.357]             sys.calls <- base::sys.calls
[16:04:43.357]             `[[` <- base::`[[`
[16:04:43.357]             `+` <- base::`+`
[16:04:43.357]             `<<-` <- base::`<<-`
[16:04:43.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.357]                   3L)]
[16:04:43.357]             }
[16:04:43.357]             function(cond) {
[16:04:43.357]                 is_error <- inherits(cond, "error")
[16:04:43.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.357]                   NULL)
[16:04:43.357]                 if (is_error) {
[16:04:43.357]                   sessionInformation <- function() {
[16:04:43.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.357]                       search = base::search(), system = base::Sys.info())
[16:04:43.357]                   }
[16:04:43.357]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.357]                     cond$call), session = sessionInformation(), 
[16:04:43.357]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.357]                   signalCondition(cond)
[16:04:43.357]                 }
[16:04:43.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.357]                 "immediateCondition"))) {
[16:04:43.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.357]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.357]                   if (TRUE && !signal) {
[16:04:43.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.357]                     {
[16:04:43.357]                       inherits <- base::inherits
[16:04:43.357]                       invokeRestart <- base::invokeRestart
[16:04:43.357]                       is.null <- base::is.null
[16:04:43.357]                       muffled <- FALSE
[16:04:43.357]                       if (inherits(cond, "message")) {
[16:04:43.357]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.357]                         if (muffled) 
[16:04:43.357]                           invokeRestart("muffleMessage")
[16:04:43.357]                       }
[16:04:43.357]                       else if (inherits(cond, "warning")) {
[16:04:43.357]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.357]                         if (muffled) 
[16:04:43.357]                           invokeRestart("muffleWarning")
[16:04:43.357]                       }
[16:04:43.357]                       else if (inherits(cond, "condition")) {
[16:04:43.357]                         if (!is.null(pattern)) {
[16:04:43.357]                           computeRestarts <- base::computeRestarts
[16:04:43.357]                           grepl <- base::grepl
[16:04:43.357]                           restarts <- computeRestarts(cond)
[16:04:43.357]                           for (restart in restarts) {
[16:04:43.357]                             name <- restart$name
[16:04:43.357]                             if (is.null(name)) 
[16:04:43.357]                               next
[16:04:43.357]                             if (!grepl(pattern, name)) 
[16:04:43.357]                               next
[16:04:43.357]                             invokeRestart(restart)
[16:04:43.357]                             muffled <- TRUE
[16:04:43.357]                             break
[16:04:43.357]                           }
[16:04:43.357]                         }
[16:04:43.357]                       }
[16:04:43.357]                       invisible(muffled)
[16:04:43.357]                     }
[16:04:43.357]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.357]                   }
[16:04:43.357]                 }
[16:04:43.357]                 else {
[16:04:43.357]                   if (TRUE) {
[16:04:43.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.357]                     {
[16:04:43.357]                       inherits <- base::inherits
[16:04:43.357]                       invokeRestart <- base::invokeRestart
[16:04:43.357]                       is.null <- base::is.null
[16:04:43.357]                       muffled <- FALSE
[16:04:43.357]                       if (inherits(cond, "message")) {
[16:04:43.357]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.357]                         if (muffled) 
[16:04:43.357]                           invokeRestart("muffleMessage")
[16:04:43.357]                       }
[16:04:43.357]                       else if (inherits(cond, "warning")) {
[16:04:43.357]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.357]                         if (muffled) 
[16:04:43.357]                           invokeRestart("muffleWarning")
[16:04:43.357]                       }
[16:04:43.357]                       else if (inherits(cond, "condition")) {
[16:04:43.357]                         if (!is.null(pattern)) {
[16:04:43.357]                           computeRestarts <- base::computeRestarts
[16:04:43.357]                           grepl <- base::grepl
[16:04:43.357]                           restarts <- computeRestarts(cond)
[16:04:43.357]                           for (restart in restarts) {
[16:04:43.357]                             name <- restart$name
[16:04:43.357]                             if (is.null(name)) 
[16:04:43.357]                               next
[16:04:43.357]                             if (!grepl(pattern, name)) 
[16:04:43.357]                               next
[16:04:43.357]                             invokeRestart(restart)
[16:04:43.357]                             muffled <- TRUE
[16:04:43.357]                             break
[16:04:43.357]                           }
[16:04:43.357]                         }
[16:04:43.357]                       }
[16:04:43.357]                       invisible(muffled)
[16:04:43.357]                     }
[16:04:43.357]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.357]                   }
[16:04:43.357]                 }
[16:04:43.357]             }
[16:04:43.357]         }))
[16:04:43.357]     }, error = function(ex) {
[16:04:43.357]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.357]                 ...future.rng), started = ...future.startTime, 
[16:04:43.357]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.357]             version = "1.8"), class = "FutureResult")
[16:04:43.357]     }, finally = {
[16:04:43.357]         if (!identical(...future.workdir, getwd())) 
[16:04:43.357]             setwd(...future.workdir)
[16:04:43.357]         {
[16:04:43.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.357]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.357]             }
[16:04:43.357]             base::options(...future.oldOptions)
[16:04:43.357]             if (.Platform$OS.type == "windows") {
[16:04:43.357]                 old_names <- names(...future.oldEnvVars)
[16:04:43.357]                 envs <- base::Sys.getenv()
[16:04:43.357]                 names <- names(envs)
[16:04:43.357]                 common <- intersect(names, old_names)
[16:04:43.357]                 added <- setdiff(names, old_names)
[16:04:43.357]                 removed <- setdiff(old_names, names)
[16:04:43.357]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.357]                   envs[common]]
[16:04:43.357]                 NAMES <- toupper(changed)
[16:04:43.357]                 args <- list()
[16:04:43.357]                 for (kk in seq_along(NAMES)) {
[16:04:43.357]                   name <- changed[[kk]]
[16:04:43.357]                   NAME <- NAMES[[kk]]
[16:04:43.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.357]                     next
[16:04:43.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.357]                 }
[16:04:43.357]                 NAMES <- toupper(added)
[16:04:43.357]                 for (kk in seq_along(NAMES)) {
[16:04:43.357]                   name <- added[[kk]]
[16:04:43.357]                   NAME <- NAMES[[kk]]
[16:04:43.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.357]                     next
[16:04:43.357]                   args[[name]] <- ""
[16:04:43.357]                 }
[16:04:43.357]                 NAMES <- toupper(removed)
[16:04:43.357]                 for (kk in seq_along(NAMES)) {
[16:04:43.357]                   name <- removed[[kk]]
[16:04:43.357]                   NAME <- NAMES[[kk]]
[16:04:43.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.357]                     next
[16:04:43.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.357]                 }
[16:04:43.357]                 if (length(args) > 0) 
[16:04:43.357]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.357]             }
[16:04:43.357]             else {
[16:04:43.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.357]             }
[16:04:43.357]             {
[16:04:43.357]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.357]                   0L) {
[16:04:43.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.357]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.357]                   base::options(opts)
[16:04:43.357]                 }
[16:04:43.357]                 {
[16:04:43.357]                   {
[16:04:43.357]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.357]                     NULL
[16:04:43.357]                   }
[16:04:43.357]                   options(future.plan = NULL)
[16:04:43.357]                   if (is.na(NA_character_)) 
[16:04:43.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.357]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.357]                     envir = parent.frame()) 
[16:04:43.357]                   {
[16:04:43.357]                     default_workers <- missing(workers)
[16:04:43.357]                     if (is.function(workers)) 
[16:04:43.357]                       workers <- workers()
[16:04:43.357]                     workers <- structure(as.integer(workers), 
[16:04:43.357]                       class = class(workers))
[16:04:43.357]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.357]                       1L)
[16:04:43.357]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.357]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.357]                       if (default_workers) 
[16:04:43.357]                         supportsMulticore(warn = TRUE)
[16:04:43.357]                       return(sequential(..., envir = envir))
[16:04:43.357]                     }
[16:04:43.357]                     oopts <- options(mc.cores = workers)
[16:04:43.357]                     on.exit(options(oopts))
[16:04:43.357]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.357]                       envir = envir)
[16:04:43.357]                     if (!future$lazy) 
[16:04:43.357]                       future <- run(future)
[16:04:43.357]                     invisible(future)
[16:04:43.357]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.357]                 }
[16:04:43.357]             }
[16:04:43.357]         }
[16:04:43.357]     })
[16:04:43.357]     if (TRUE) {
[16:04:43.357]         base::sink(type = "output", split = FALSE)
[16:04:43.357]         if (TRUE) {
[16:04:43.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.357]         }
[16:04:43.357]         else {
[16:04:43.357]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.357]         }
[16:04:43.357]         base::close(...future.stdout)
[16:04:43.357]         ...future.stdout <- NULL
[16:04:43.357]     }
[16:04:43.357]     ...future.result$conditions <- ...future.conditions
[16:04:43.357]     ...future.result$finished <- base::Sys.time()
[16:04:43.357]     ...future.result
[16:04:43.357] }
[16:04:43.359] requestCore(): workers = 2
[16:04:43.361] MulticoreFuture started
[16:04:43.362] - Launch lazy future ... done
[16:04:43.362] run() for ‘MulticoreFuture’ ... done
[16:04:43.362] getGlobalsAndPackages() ...
[16:04:43.362] Searching for globals...
[16:04:43.362] plan(): Setting new future strategy stack:
[16:04:43.363] 
[16:04:43.363] List of future strategies:
[16:04:43.363] 1. sequential:
[16:04:43.363]    - args: function (..., envir = parent.frame())
[16:04:43.363]    - tweaked: FALSE
[16:04:43.363]    - call: NULL
[16:04:43.363] Searching for globals ... DONE
[16:04:43.364] plan(): nbrOfWorkers() = 1
[16:04:43.364] - globals: [0] <none>
[16:04:43.364] getGlobalsAndPackages() ... DONE
[16:04:43.364] run() for ‘Future’ ...
[16:04:43.364] - state: ‘created’
[16:04:43.365] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.365] plan(): Setting new future strategy stack:
[16:04:43.365] List of future strategies:
[16:04:43.365] 1. multicore:
[16:04:43.365]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.365]    - tweaked: FALSE
[16:04:43.365]    - call: plan(strategy)
[16:04:43.370] plan(): nbrOfWorkers() = 2
[16:04:43.370] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.370] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.370]   - Field: ‘label’
[16:04:43.370]   - Field: ‘local’
[16:04:43.370]   - Field: ‘owner’
[16:04:43.371]   - Field: ‘envir’
[16:04:43.371]   - Field: ‘workers’
[16:04:43.371]   - Field: ‘packages’
[16:04:43.371]   - Field: ‘gc’
[16:04:43.371]   - Field: ‘job’
[16:04:43.371]   - Field: ‘conditions’
[16:04:43.371]   - Field: ‘expr’
[16:04:43.372]   - Field: ‘uuid’
[16:04:43.372]   - Field: ‘seed’
[16:04:43.372]   - Field: ‘version’
[16:04:43.372]   - Field: ‘result’
[16:04:43.372]   - Field: ‘asynchronous’
[16:04:43.372]   - Field: ‘calls’
[16:04:43.373]   - Field: ‘globals’
[16:04:43.373]   - Field: ‘stdout’
[16:04:43.373]   - Field: ‘earlySignal’
[16:04:43.373]   - Field: ‘lazy’
[16:04:43.373]   - Field: ‘state’
[16:04:43.373] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.373] - Launch lazy future ...
[16:04:43.374] Packages needed by the future expression (n = 0): <none>
[16:04:43.374] Packages needed by future strategies (n = 0): <none>
[16:04:43.375] {
[16:04:43.375]     {
[16:04:43.375]         {
[16:04:43.375]             ...future.startTime <- base::Sys.time()
[16:04:43.375]             {
[16:04:43.375]                 {
[16:04:43.375]                   {
[16:04:43.375]                     {
[16:04:43.375]                       base::local({
[16:04:43.375]                         has_future <- base::requireNamespace("future", 
[16:04:43.375]                           quietly = TRUE)
[16:04:43.375]                         if (has_future) {
[16:04:43.375]                           ns <- base::getNamespace("future")
[16:04:43.375]                           version <- ns[[".package"]][["version"]]
[16:04:43.375]                           if (is.null(version)) 
[16:04:43.375]                             version <- utils::packageVersion("future")
[16:04:43.375]                         }
[16:04:43.375]                         else {
[16:04:43.375]                           version <- NULL
[16:04:43.375]                         }
[16:04:43.375]                         if (!has_future || version < "1.8.0") {
[16:04:43.375]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.375]                             "", base::R.version$version.string), 
[16:04:43.375]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.375]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.375]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.375]                               "release", "version")], collapse = " "), 
[16:04:43.375]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.375]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.375]                             info)
[16:04:43.375]                           info <- base::paste(info, collapse = "; ")
[16:04:43.375]                           if (!has_future) {
[16:04:43.375]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.375]                               info)
[16:04:43.375]                           }
[16:04:43.375]                           else {
[16:04:43.375]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.375]                               info, version)
[16:04:43.375]                           }
[16:04:43.375]                           base::stop(msg)
[16:04:43.375]                         }
[16:04:43.375]                       })
[16:04:43.375]                     }
[16:04:43.375]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.375]                     base::options(mc.cores = 1L)
[16:04:43.375]                   }
[16:04:43.375]                   options(future.plan = NULL)
[16:04:43.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.375]                 }
[16:04:43.375]                 ...future.workdir <- getwd()
[16:04:43.375]             }
[16:04:43.375]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.375]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.375]         }
[16:04:43.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.375]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.375]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.375]             base::names(...future.oldOptions))
[16:04:43.375]     }
[16:04:43.375]     if (FALSE) {
[16:04:43.375]     }
[16:04:43.375]     else {
[16:04:43.375]         if (TRUE) {
[16:04:43.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.375]                 open = "w")
[16:04:43.375]         }
[16:04:43.375]         else {
[16:04:43.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.375]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.375]         }
[16:04:43.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.375]             base::sink(type = "output", split = FALSE)
[16:04:43.375]             base::close(...future.stdout)
[16:04:43.375]         }, add = TRUE)
[16:04:43.375]     }
[16:04:43.375]     ...future.frame <- base::sys.nframe()
[16:04:43.375]     ...future.conditions <- base::list()
[16:04:43.375]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.375]     if (FALSE) {
[16:04:43.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.375]     }
[16:04:43.375]     ...future.result <- base::tryCatch({
[16:04:43.375]         base::withCallingHandlers({
[16:04:43.375]             ...future.value <- base::withVisible(base::local({
[16:04:43.375]                 withCallingHandlers({
[16:04:43.375]                   NULL
[16:04:43.375]                 }, immediateCondition = function(cond) {
[16:04:43.375]                   save_rds <- function (object, pathname, ...) 
[16:04:43.375]                   {
[16:04:43.375]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.375]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.375]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.375]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.375]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.375]                         fi_tmp[["mtime"]])
[16:04:43.375]                     }
[16:04:43.375]                     tryCatch({
[16:04:43.375]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.375]                     }, error = function(ex) {
[16:04:43.375]                       msg <- conditionMessage(ex)
[16:04:43.375]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.375]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.375]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.375]                         fi_tmp[["mtime"]], msg)
[16:04:43.375]                       ex$message <- msg
[16:04:43.375]                       stop(ex)
[16:04:43.375]                     })
[16:04:43.375]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.375]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.375]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.375]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.375]                       fi <- file.info(pathname)
[16:04:43.375]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.375]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.375]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.375]                         fi[["size"]], fi[["mtime"]])
[16:04:43.375]                       stop(msg)
[16:04:43.375]                     }
[16:04:43.375]                     invisible(pathname)
[16:04:43.375]                   }
[16:04:43.375]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.375]                     rootPath = tempdir()) 
[16:04:43.375]                   {
[16:04:43.375]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.375]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.375]                       tmpdir = path, fileext = ".rds")
[16:04:43.375]                     save_rds(obj, file)
[16:04:43.375]                   }
[16:04:43.375]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.375]                   {
[16:04:43.375]                     inherits <- base::inherits
[16:04:43.375]                     invokeRestart <- base::invokeRestart
[16:04:43.375]                     is.null <- base::is.null
[16:04:43.375]                     muffled <- FALSE
[16:04:43.375]                     if (inherits(cond, "message")) {
[16:04:43.375]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.375]                       if (muffled) 
[16:04:43.375]                         invokeRestart("muffleMessage")
[16:04:43.375]                     }
[16:04:43.375]                     else if (inherits(cond, "warning")) {
[16:04:43.375]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.375]                       if (muffled) 
[16:04:43.375]                         invokeRestart("muffleWarning")
[16:04:43.375]                     }
[16:04:43.375]                     else if (inherits(cond, "condition")) {
[16:04:43.375]                       if (!is.null(pattern)) {
[16:04:43.375]                         computeRestarts <- base::computeRestarts
[16:04:43.375]                         grepl <- base::grepl
[16:04:43.375]                         restarts <- computeRestarts(cond)
[16:04:43.375]                         for (restart in restarts) {
[16:04:43.375]                           name <- restart$name
[16:04:43.375]                           if (is.null(name)) 
[16:04:43.375]                             next
[16:04:43.375]                           if (!grepl(pattern, name)) 
[16:04:43.375]                             next
[16:04:43.375]                           invokeRestart(restart)
[16:04:43.375]                           muffled <- TRUE
[16:04:43.375]                           break
[16:04:43.375]                         }
[16:04:43.375]                       }
[16:04:43.375]                     }
[16:04:43.375]                     invisible(muffled)
[16:04:43.375]                   }
[16:04:43.375]                   muffleCondition(cond)
[16:04:43.375]                 })
[16:04:43.375]             }))
[16:04:43.375]             future::FutureResult(value = ...future.value$value, 
[16:04:43.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.375]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.375]                     ...future.globalenv.names))
[16:04:43.375]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.375]         }, condition = base::local({
[16:04:43.375]             c <- base::c
[16:04:43.375]             inherits <- base::inherits
[16:04:43.375]             invokeRestart <- base::invokeRestart
[16:04:43.375]             length <- base::length
[16:04:43.375]             list <- base::list
[16:04:43.375]             seq.int <- base::seq.int
[16:04:43.375]             signalCondition <- base::signalCondition
[16:04:43.375]             sys.calls <- base::sys.calls
[16:04:43.375]             `[[` <- base::`[[`
[16:04:43.375]             `+` <- base::`+`
[16:04:43.375]             `<<-` <- base::`<<-`
[16:04:43.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.375]                   3L)]
[16:04:43.375]             }
[16:04:43.375]             function(cond) {
[16:04:43.375]                 is_error <- inherits(cond, "error")
[16:04:43.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.375]                   NULL)
[16:04:43.375]                 if (is_error) {
[16:04:43.375]                   sessionInformation <- function() {
[16:04:43.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.375]                       search = base::search(), system = base::Sys.info())
[16:04:43.375]                   }
[16:04:43.375]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.375]                     cond$call), session = sessionInformation(), 
[16:04:43.375]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.375]                   signalCondition(cond)
[16:04:43.375]                 }
[16:04:43.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.375]                 "immediateCondition"))) {
[16:04:43.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.375]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.375]                   if (TRUE && !signal) {
[16:04:43.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.375]                     {
[16:04:43.375]                       inherits <- base::inherits
[16:04:43.375]                       invokeRestart <- base::invokeRestart
[16:04:43.375]                       is.null <- base::is.null
[16:04:43.375]                       muffled <- FALSE
[16:04:43.375]                       if (inherits(cond, "message")) {
[16:04:43.375]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.375]                         if (muffled) 
[16:04:43.375]                           invokeRestart("muffleMessage")
[16:04:43.375]                       }
[16:04:43.375]                       else if (inherits(cond, "warning")) {
[16:04:43.375]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.375]                         if (muffled) 
[16:04:43.375]                           invokeRestart("muffleWarning")
[16:04:43.375]                       }
[16:04:43.375]                       else if (inherits(cond, "condition")) {
[16:04:43.375]                         if (!is.null(pattern)) {
[16:04:43.375]                           computeRestarts <- base::computeRestarts
[16:04:43.375]                           grepl <- base::grepl
[16:04:43.375]                           restarts <- computeRestarts(cond)
[16:04:43.375]                           for (restart in restarts) {
[16:04:43.375]                             name <- restart$name
[16:04:43.375]                             if (is.null(name)) 
[16:04:43.375]                               next
[16:04:43.375]                             if (!grepl(pattern, name)) 
[16:04:43.375]                               next
[16:04:43.375]                             invokeRestart(restart)
[16:04:43.375]                             muffled <- TRUE
[16:04:43.375]                             break
[16:04:43.375]                           }
[16:04:43.375]                         }
[16:04:43.375]                       }
[16:04:43.375]                       invisible(muffled)
[16:04:43.375]                     }
[16:04:43.375]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.375]                   }
[16:04:43.375]                 }
[16:04:43.375]                 else {
[16:04:43.375]                   if (TRUE) {
[16:04:43.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.375]                     {
[16:04:43.375]                       inherits <- base::inherits
[16:04:43.375]                       invokeRestart <- base::invokeRestart
[16:04:43.375]                       is.null <- base::is.null
[16:04:43.375]                       muffled <- FALSE
[16:04:43.375]                       if (inherits(cond, "message")) {
[16:04:43.375]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.375]                         if (muffled) 
[16:04:43.375]                           invokeRestart("muffleMessage")
[16:04:43.375]                       }
[16:04:43.375]                       else if (inherits(cond, "warning")) {
[16:04:43.375]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.375]                         if (muffled) 
[16:04:43.375]                           invokeRestart("muffleWarning")
[16:04:43.375]                       }
[16:04:43.375]                       else if (inherits(cond, "condition")) {
[16:04:43.375]                         if (!is.null(pattern)) {
[16:04:43.375]                           computeRestarts <- base::computeRestarts
[16:04:43.375]                           grepl <- base::grepl
[16:04:43.375]                           restarts <- computeRestarts(cond)
[16:04:43.375]                           for (restart in restarts) {
[16:04:43.375]                             name <- restart$name
[16:04:43.375]                             if (is.null(name)) 
[16:04:43.375]                               next
[16:04:43.375]                             if (!grepl(pattern, name)) 
[16:04:43.375]                               next
[16:04:43.375]                             invokeRestart(restart)
[16:04:43.375]                             muffled <- TRUE
[16:04:43.375]                             break
[16:04:43.375]                           }
[16:04:43.375]                         }
[16:04:43.375]                       }
[16:04:43.375]                       invisible(muffled)
[16:04:43.375]                     }
[16:04:43.375]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.375]                   }
[16:04:43.375]                 }
[16:04:43.375]             }
[16:04:43.375]         }))
[16:04:43.375]     }, error = function(ex) {
[16:04:43.375]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.375]                 ...future.rng), started = ...future.startTime, 
[16:04:43.375]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.375]             version = "1.8"), class = "FutureResult")
[16:04:43.375]     }, finally = {
[16:04:43.375]         if (!identical(...future.workdir, getwd())) 
[16:04:43.375]             setwd(...future.workdir)
[16:04:43.375]         {
[16:04:43.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.375]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.375]             }
[16:04:43.375]             base::options(...future.oldOptions)
[16:04:43.375]             if (.Platform$OS.type == "windows") {
[16:04:43.375]                 old_names <- names(...future.oldEnvVars)
[16:04:43.375]                 envs <- base::Sys.getenv()
[16:04:43.375]                 names <- names(envs)
[16:04:43.375]                 common <- intersect(names, old_names)
[16:04:43.375]                 added <- setdiff(names, old_names)
[16:04:43.375]                 removed <- setdiff(old_names, names)
[16:04:43.375]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.375]                   envs[common]]
[16:04:43.375]                 NAMES <- toupper(changed)
[16:04:43.375]                 args <- list()
[16:04:43.375]                 for (kk in seq_along(NAMES)) {
[16:04:43.375]                   name <- changed[[kk]]
[16:04:43.375]                   NAME <- NAMES[[kk]]
[16:04:43.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.375]                     next
[16:04:43.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.375]                 }
[16:04:43.375]                 NAMES <- toupper(added)
[16:04:43.375]                 for (kk in seq_along(NAMES)) {
[16:04:43.375]                   name <- added[[kk]]
[16:04:43.375]                   NAME <- NAMES[[kk]]
[16:04:43.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.375]                     next
[16:04:43.375]                   args[[name]] <- ""
[16:04:43.375]                 }
[16:04:43.375]                 NAMES <- toupper(removed)
[16:04:43.375]                 for (kk in seq_along(NAMES)) {
[16:04:43.375]                   name <- removed[[kk]]
[16:04:43.375]                   NAME <- NAMES[[kk]]
[16:04:43.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.375]                     next
[16:04:43.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.375]                 }
[16:04:43.375]                 if (length(args) > 0) 
[16:04:43.375]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.375]             }
[16:04:43.375]             else {
[16:04:43.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.375]             }
[16:04:43.375]             {
[16:04:43.375]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.375]                   0L) {
[16:04:43.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.375]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.375]                   base::options(opts)
[16:04:43.375]                 }
[16:04:43.375]                 {
[16:04:43.375]                   {
[16:04:43.375]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.375]                     NULL
[16:04:43.375]                   }
[16:04:43.375]                   options(future.plan = NULL)
[16:04:43.375]                   if (is.na(NA_character_)) 
[16:04:43.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.375]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.375]                     envir = parent.frame()) 
[16:04:43.375]                   {
[16:04:43.375]                     default_workers <- missing(workers)
[16:04:43.375]                     if (is.function(workers)) 
[16:04:43.375]                       workers <- workers()
[16:04:43.375]                     workers <- structure(as.integer(workers), 
[16:04:43.375]                       class = class(workers))
[16:04:43.375]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.375]                       1L)
[16:04:43.375]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.375]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.375]                       if (default_workers) 
[16:04:43.375]                         supportsMulticore(warn = TRUE)
[16:04:43.375]                       return(sequential(..., envir = envir))
[16:04:43.375]                     }
[16:04:43.375]                     oopts <- options(mc.cores = workers)
[16:04:43.375]                     on.exit(options(oopts))
[16:04:43.375]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.375]                       envir = envir)
[16:04:43.375]                     if (!future$lazy) 
[16:04:43.375]                       future <- run(future)
[16:04:43.375]                     invisible(future)
[16:04:43.375]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.375]                 }
[16:04:43.375]             }
[16:04:43.375]         }
[16:04:43.375]     })
[16:04:43.375]     if (TRUE) {
[16:04:43.375]         base::sink(type = "output", split = FALSE)
[16:04:43.375]         if (TRUE) {
[16:04:43.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.375]         }
[16:04:43.375]         else {
[16:04:43.375]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.375]         }
[16:04:43.375]         base::close(...future.stdout)
[16:04:43.375]         ...future.stdout <- NULL
[16:04:43.375]     }
[16:04:43.375]     ...future.result$conditions <- ...future.conditions
[16:04:43.375]     ...future.result$finished <- base::Sys.time()
[16:04:43.375]     ...future.result
[16:04:43.375] }
[16:04:43.378] requestCore(): workers = 2
[16:04:43.381] MulticoreFuture started
[16:04:43.381] - Launch lazy future ... done
[16:04:43.381] run() for ‘MulticoreFuture’ ... done
[16:04:43.382] plan(): Setting new future strategy stack:
[16:04:43.382] getGlobalsAndPackages() ...
[16:04:43.382] Searching for globals...
[16:04:43.382] List of future strategies:
[16:04:43.382] 1. sequential:
[16:04:43.382]    - args: function (..., envir = parent.frame())
[16:04:43.382]    - tweaked: FALSE
[16:04:43.382]    - call: NULL
[16:04:43.383] plan(): nbrOfWorkers() = 1
[16:04:43.384] - globals found: [1] ‘{’
[16:04:43.384] Searching for globals ... DONE
[16:04:43.384] Resolving globals: FALSE
[16:04:43.385] 
[16:04:43.385] 
[16:04:43.385] getGlobalsAndPackages() ... DONE
[16:04:43.385] plan(): Setting new future strategy stack:
[16:04:43.386] run() for ‘Future’ ...
[16:04:43.386] - state: ‘created’
[16:04:43.385] List of future strategies:
[16:04:43.385] 1. multicore:
[16:04:43.385]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.385]    - tweaked: FALSE
[16:04:43.385]    - call: plan(strategy)
[16:04:43.386] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.390] plan(): nbrOfWorkers() = 2
[16:04:43.391] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.391] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.391]   - Field: ‘label’
[16:04:43.391]   - Field: ‘local’
[16:04:43.391]   - Field: ‘owner’
[16:04:43.392]   - Field: ‘envir’
[16:04:43.392]   - Field: ‘workers’
[16:04:43.392]   - Field: ‘packages’
[16:04:43.392]   - Field: ‘gc’
[16:04:43.392]   - Field: ‘job’
[16:04:43.392]   - Field: ‘conditions’
[16:04:43.392]   - Field: ‘expr’
[16:04:43.393]   - Field: ‘uuid’
[16:04:43.393]   - Field: ‘seed’
[16:04:43.393]   - Field: ‘version’
[16:04:43.393]   - Field: ‘result’
[16:04:43.393]   - Field: ‘asynchronous’
[16:04:43.393]   - Field: ‘calls’
[16:04:43.394]   - Field: ‘globals’
[16:04:43.394]   - Field: ‘stdout’
[16:04:43.394]   - Field: ‘earlySignal’
[16:04:43.394]   - Field: ‘lazy’
[16:04:43.394]   - Field: ‘state’
[16:04:43.394] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.394] - Launch lazy future ...
[16:04:43.395] Packages needed by the future expression (n = 0): <none>
[16:04:43.395] Packages needed by future strategies (n = 0): <none>
[16:04:43.396] {
[16:04:43.396]     {
[16:04:43.396]         {
[16:04:43.396]             ...future.startTime <- base::Sys.time()
[16:04:43.396]             {
[16:04:43.396]                 {
[16:04:43.396]                   {
[16:04:43.396]                     {
[16:04:43.396]                       base::local({
[16:04:43.396]                         has_future <- base::requireNamespace("future", 
[16:04:43.396]                           quietly = TRUE)
[16:04:43.396]                         if (has_future) {
[16:04:43.396]                           ns <- base::getNamespace("future")
[16:04:43.396]                           version <- ns[[".package"]][["version"]]
[16:04:43.396]                           if (is.null(version)) 
[16:04:43.396]                             version <- utils::packageVersion("future")
[16:04:43.396]                         }
[16:04:43.396]                         else {
[16:04:43.396]                           version <- NULL
[16:04:43.396]                         }
[16:04:43.396]                         if (!has_future || version < "1.8.0") {
[16:04:43.396]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.396]                             "", base::R.version$version.string), 
[16:04:43.396]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.396]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.396]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.396]                               "release", "version")], collapse = " "), 
[16:04:43.396]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.396]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.396]                             info)
[16:04:43.396]                           info <- base::paste(info, collapse = "; ")
[16:04:43.396]                           if (!has_future) {
[16:04:43.396]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.396]                               info)
[16:04:43.396]                           }
[16:04:43.396]                           else {
[16:04:43.396]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.396]                               info, version)
[16:04:43.396]                           }
[16:04:43.396]                           base::stop(msg)
[16:04:43.396]                         }
[16:04:43.396]                       })
[16:04:43.396]                     }
[16:04:43.396]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.396]                     base::options(mc.cores = 1L)
[16:04:43.396]                   }
[16:04:43.396]                   options(future.plan = NULL)
[16:04:43.396]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.396]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.396]                 }
[16:04:43.396]                 ...future.workdir <- getwd()
[16:04:43.396]             }
[16:04:43.396]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.396]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.396]         }
[16:04:43.396]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.396]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.396]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.396]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.396]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.396]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.396]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.396]             base::names(...future.oldOptions))
[16:04:43.396]     }
[16:04:43.396]     if (FALSE) {
[16:04:43.396]     }
[16:04:43.396]     else {
[16:04:43.396]         if (TRUE) {
[16:04:43.396]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.396]                 open = "w")
[16:04:43.396]         }
[16:04:43.396]         else {
[16:04:43.396]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.396]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.396]         }
[16:04:43.396]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.396]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.396]             base::sink(type = "output", split = FALSE)
[16:04:43.396]             base::close(...future.stdout)
[16:04:43.396]         }, add = TRUE)
[16:04:43.396]     }
[16:04:43.396]     ...future.frame <- base::sys.nframe()
[16:04:43.396]     ...future.conditions <- base::list()
[16:04:43.396]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.396]     if (FALSE) {
[16:04:43.396]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.396]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.396]     }
[16:04:43.396]     ...future.result <- base::tryCatch({
[16:04:43.396]         base::withCallingHandlers({
[16:04:43.396]             ...future.value <- base::withVisible(base::local({
[16:04:43.396]                 withCallingHandlers({
[16:04:43.396]                   {
[16:04:43.396]                     4
[16:04:43.396]                   }
[16:04:43.396]                 }, immediateCondition = function(cond) {
[16:04:43.396]                   save_rds <- function (object, pathname, ...) 
[16:04:43.396]                   {
[16:04:43.396]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.396]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.396]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.396]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.396]                         fi_tmp[["mtime"]])
[16:04:43.396]                     }
[16:04:43.396]                     tryCatch({
[16:04:43.396]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.396]                     }, error = function(ex) {
[16:04:43.396]                       msg <- conditionMessage(ex)
[16:04:43.396]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.396]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.396]                         fi_tmp[["mtime"]], msg)
[16:04:43.396]                       ex$message <- msg
[16:04:43.396]                       stop(ex)
[16:04:43.396]                     })
[16:04:43.396]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.396]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.396]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.396]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.396]                       fi <- file.info(pathname)
[16:04:43.396]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.396]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.396]                         fi[["size"]], fi[["mtime"]])
[16:04:43.396]                       stop(msg)
[16:04:43.396]                     }
[16:04:43.396]                     invisible(pathname)
[16:04:43.396]                   }
[16:04:43.396]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.396]                     rootPath = tempdir()) 
[16:04:43.396]                   {
[16:04:43.396]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.396]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.396]                       tmpdir = path, fileext = ".rds")
[16:04:43.396]                     save_rds(obj, file)
[16:04:43.396]                   }
[16:04:43.396]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.396]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.396]                   {
[16:04:43.396]                     inherits <- base::inherits
[16:04:43.396]                     invokeRestart <- base::invokeRestart
[16:04:43.396]                     is.null <- base::is.null
[16:04:43.396]                     muffled <- FALSE
[16:04:43.396]                     if (inherits(cond, "message")) {
[16:04:43.396]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.396]                       if (muffled) 
[16:04:43.396]                         invokeRestart("muffleMessage")
[16:04:43.396]                     }
[16:04:43.396]                     else if (inherits(cond, "warning")) {
[16:04:43.396]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.396]                       if (muffled) 
[16:04:43.396]                         invokeRestart("muffleWarning")
[16:04:43.396]                     }
[16:04:43.396]                     else if (inherits(cond, "condition")) {
[16:04:43.396]                       if (!is.null(pattern)) {
[16:04:43.396]                         computeRestarts <- base::computeRestarts
[16:04:43.396]                         grepl <- base::grepl
[16:04:43.396]                         restarts <- computeRestarts(cond)
[16:04:43.396]                         for (restart in restarts) {
[16:04:43.396]                           name <- restart$name
[16:04:43.396]                           if (is.null(name)) 
[16:04:43.396]                             next
[16:04:43.396]                           if (!grepl(pattern, name)) 
[16:04:43.396]                             next
[16:04:43.396]                           invokeRestart(restart)
[16:04:43.396]                           muffled <- TRUE
[16:04:43.396]                           break
[16:04:43.396]                         }
[16:04:43.396]                       }
[16:04:43.396]                     }
[16:04:43.396]                     invisible(muffled)
[16:04:43.396]                   }
[16:04:43.396]                   muffleCondition(cond)
[16:04:43.396]                 })
[16:04:43.396]             }))
[16:04:43.396]             future::FutureResult(value = ...future.value$value, 
[16:04:43.396]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.396]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.396]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.396]                     ...future.globalenv.names))
[16:04:43.396]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.396]         }, condition = base::local({
[16:04:43.396]             c <- base::c
[16:04:43.396]             inherits <- base::inherits
[16:04:43.396]             invokeRestart <- base::invokeRestart
[16:04:43.396]             length <- base::length
[16:04:43.396]             list <- base::list
[16:04:43.396]             seq.int <- base::seq.int
[16:04:43.396]             signalCondition <- base::signalCondition
[16:04:43.396]             sys.calls <- base::sys.calls
[16:04:43.396]             `[[` <- base::`[[`
[16:04:43.396]             `+` <- base::`+`
[16:04:43.396]             `<<-` <- base::`<<-`
[16:04:43.396]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.396]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.396]                   3L)]
[16:04:43.396]             }
[16:04:43.396]             function(cond) {
[16:04:43.396]                 is_error <- inherits(cond, "error")
[16:04:43.396]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.396]                   NULL)
[16:04:43.396]                 if (is_error) {
[16:04:43.396]                   sessionInformation <- function() {
[16:04:43.396]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.396]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.396]                       search = base::search(), system = base::Sys.info())
[16:04:43.396]                   }
[16:04:43.396]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.396]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.396]                     cond$call), session = sessionInformation(), 
[16:04:43.396]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.396]                   signalCondition(cond)
[16:04:43.396]                 }
[16:04:43.396]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.396]                 "immediateCondition"))) {
[16:04:43.396]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.396]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.396]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.396]                   if (TRUE && !signal) {
[16:04:43.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.396]                     {
[16:04:43.396]                       inherits <- base::inherits
[16:04:43.396]                       invokeRestart <- base::invokeRestart
[16:04:43.396]                       is.null <- base::is.null
[16:04:43.396]                       muffled <- FALSE
[16:04:43.396]                       if (inherits(cond, "message")) {
[16:04:43.396]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.396]                         if (muffled) 
[16:04:43.396]                           invokeRestart("muffleMessage")
[16:04:43.396]                       }
[16:04:43.396]                       else if (inherits(cond, "warning")) {
[16:04:43.396]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.396]                         if (muffled) 
[16:04:43.396]                           invokeRestart("muffleWarning")
[16:04:43.396]                       }
[16:04:43.396]                       else if (inherits(cond, "condition")) {
[16:04:43.396]                         if (!is.null(pattern)) {
[16:04:43.396]                           computeRestarts <- base::computeRestarts
[16:04:43.396]                           grepl <- base::grepl
[16:04:43.396]                           restarts <- computeRestarts(cond)
[16:04:43.396]                           for (restart in restarts) {
[16:04:43.396]                             name <- restart$name
[16:04:43.396]                             if (is.null(name)) 
[16:04:43.396]                               next
[16:04:43.396]                             if (!grepl(pattern, name)) 
[16:04:43.396]                               next
[16:04:43.396]                             invokeRestart(restart)
[16:04:43.396]                             muffled <- TRUE
[16:04:43.396]                             break
[16:04:43.396]                           }
[16:04:43.396]                         }
[16:04:43.396]                       }
[16:04:43.396]                       invisible(muffled)
[16:04:43.396]                     }
[16:04:43.396]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.396]                   }
[16:04:43.396]                 }
[16:04:43.396]                 else {
[16:04:43.396]                   if (TRUE) {
[16:04:43.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.396]                     {
[16:04:43.396]                       inherits <- base::inherits
[16:04:43.396]                       invokeRestart <- base::invokeRestart
[16:04:43.396]                       is.null <- base::is.null
[16:04:43.396]                       muffled <- FALSE
[16:04:43.396]                       if (inherits(cond, "message")) {
[16:04:43.396]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.396]                         if (muffled) 
[16:04:43.396]                           invokeRestart("muffleMessage")
[16:04:43.396]                       }
[16:04:43.396]                       else if (inherits(cond, "warning")) {
[16:04:43.396]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.396]                         if (muffled) 
[16:04:43.396]                           invokeRestart("muffleWarning")
[16:04:43.396]                       }
[16:04:43.396]                       else if (inherits(cond, "condition")) {
[16:04:43.396]                         if (!is.null(pattern)) {
[16:04:43.396]                           computeRestarts <- base::computeRestarts
[16:04:43.396]                           grepl <- base::grepl
[16:04:43.396]                           restarts <- computeRestarts(cond)
[16:04:43.396]                           for (restart in restarts) {
[16:04:43.396]                             name <- restart$name
[16:04:43.396]                             if (is.null(name)) 
[16:04:43.396]                               next
[16:04:43.396]                             if (!grepl(pattern, name)) 
[16:04:43.396]                               next
[16:04:43.396]                             invokeRestart(restart)
[16:04:43.396]                             muffled <- TRUE
[16:04:43.396]                             break
[16:04:43.396]                           }
[16:04:43.396]                         }
[16:04:43.396]                       }
[16:04:43.396]                       invisible(muffled)
[16:04:43.396]                     }
[16:04:43.396]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.396]                   }
[16:04:43.396]                 }
[16:04:43.396]             }
[16:04:43.396]         }))
[16:04:43.396]     }, error = function(ex) {
[16:04:43.396]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.396]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.396]                 ...future.rng), started = ...future.startTime, 
[16:04:43.396]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.396]             version = "1.8"), class = "FutureResult")
[16:04:43.396]     }, finally = {
[16:04:43.396]         if (!identical(...future.workdir, getwd())) 
[16:04:43.396]             setwd(...future.workdir)
[16:04:43.396]         {
[16:04:43.396]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.396]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.396]             }
[16:04:43.396]             base::options(...future.oldOptions)
[16:04:43.396]             if (.Platform$OS.type == "windows") {
[16:04:43.396]                 old_names <- names(...future.oldEnvVars)
[16:04:43.396]                 envs <- base::Sys.getenv()
[16:04:43.396]                 names <- names(envs)
[16:04:43.396]                 common <- intersect(names, old_names)
[16:04:43.396]                 added <- setdiff(names, old_names)
[16:04:43.396]                 removed <- setdiff(old_names, names)
[16:04:43.396]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.396]                   envs[common]]
[16:04:43.396]                 NAMES <- toupper(changed)
[16:04:43.396]                 args <- list()
[16:04:43.396]                 for (kk in seq_along(NAMES)) {
[16:04:43.396]                   name <- changed[[kk]]
[16:04:43.396]                   NAME <- NAMES[[kk]]
[16:04:43.396]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.396]                     next
[16:04:43.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.396]                 }
[16:04:43.396]                 NAMES <- toupper(added)
[16:04:43.396]                 for (kk in seq_along(NAMES)) {
[16:04:43.396]                   name <- added[[kk]]
[16:04:43.396]                   NAME <- NAMES[[kk]]
[16:04:43.396]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.396]                     next
[16:04:43.396]                   args[[name]] <- ""
[16:04:43.396]                 }
[16:04:43.396]                 NAMES <- toupper(removed)
[16:04:43.396]                 for (kk in seq_along(NAMES)) {
[16:04:43.396]                   name <- removed[[kk]]
[16:04:43.396]                   NAME <- NAMES[[kk]]
[16:04:43.396]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.396]                     next
[16:04:43.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.396]                 }
[16:04:43.396]                 if (length(args) > 0) 
[16:04:43.396]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.396]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.396]             }
[16:04:43.396]             else {
[16:04:43.396]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.396]             }
[16:04:43.396]             {
[16:04:43.396]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.396]                   0L) {
[16:04:43.396]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.396]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.396]                   base::options(opts)
[16:04:43.396]                 }
[16:04:43.396]                 {
[16:04:43.396]                   {
[16:04:43.396]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.396]                     NULL
[16:04:43.396]                   }
[16:04:43.396]                   options(future.plan = NULL)
[16:04:43.396]                   if (is.na(NA_character_)) 
[16:04:43.396]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.396]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.396]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.396]                     envir = parent.frame()) 
[16:04:43.396]                   {
[16:04:43.396]                     default_workers <- missing(workers)
[16:04:43.396]                     if (is.function(workers)) 
[16:04:43.396]                       workers <- workers()
[16:04:43.396]                     workers <- structure(as.integer(workers), 
[16:04:43.396]                       class = class(workers))
[16:04:43.396]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.396]                       1L)
[16:04:43.396]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.396]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.396]                       if (default_workers) 
[16:04:43.396]                         supportsMulticore(warn = TRUE)
[16:04:43.396]                       return(sequential(..., envir = envir))
[16:04:43.396]                     }
[16:04:43.396]                     oopts <- options(mc.cores = workers)
[16:04:43.396]                     on.exit(options(oopts))
[16:04:43.396]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.396]                       envir = envir)
[16:04:43.396]                     if (!future$lazy) 
[16:04:43.396]                       future <- run(future)
[16:04:43.396]                     invisible(future)
[16:04:43.396]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.396]                 }
[16:04:43.396]             }
[16:04:43.396]         }
[16:04:43.396]     })
[16:04:43.396]     if (TRUE) {
[16:04:43.396]         base::sink(type = "output", split = FALSE)
[16:04:43.396]         if (TRUE) {
[16:04:43.396]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.396]         }
[16:04:43.396]         else {
[16:04:43.396]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.396]         }
[16:04:43.396]         base::close(...future.stdout)
[16:04:43.396]         ...future.stdout <- NULL
[16:04:43.396]     }
[16:04:43.396]     ...future.result$conditions <- ...future.conditions
[16:04:43.396]     ...future.result$finished <- base::Sys.time()
[16:04:43.396]     ...future.result
[16:04:43.396] }
[16:04:43.400] requestCore(): workers = 2
[16:04:43.400] Poll #1 (0): usedCores() = 2, workers = 2
[16:04:43.411] result() for MulticoreFuture ...
[16:04:43.412] result() for MulticoreFuture ...
[16:04:43.412] result() for MulticoreFuture ... done
[16:04:43.412] result() for MulticoreFuture ... done
[16:04:43.413] result() for MulticoreFuture ...
[16:04:43.413] result() for MulticoreFuture ... done
[16:04:43.415] MulticoreFuture started
[16:04:43.416] - Launch lazy future ... done
[16:04:43.416] run() for ‘MulticoreFuture’ ... done
[16:04:43.417] plan(): Setting new future strategy stack:
<environment: 0x55874fccd9d8> 
[16:04:43.417] List of future strategies:
[16:04:43.417] 1. sequential:
[16:04:43.417]    - args: function (..., envir = parent.frame())
[16:04:43.417]    - tweaked: FALSE
[16:04:43.417]    - call: NULL
[16:04:43.418] plan(): nbrOfWorkers() = 1
<environment: 0x55874c77ab38> 
[16:04:43.420] plan(): Setting new future strategy stack:
[16:04:43.420] List of future strategies:
[16:04:43.420] 1. multicore:
[16:04:43.420]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.420]    - tweaked: FALSE
[16:04:43.420]    - call: plan(strategy)
[16:04:43.425] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:43.428] resolve() on environment ...
[16:04:43.428]  recursive: 0
[16:04:43.429]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:43.430] signalConditionsASAP(numeric, pos=1) ...
[16:04:43.430] - nx: 4
[16:04:43.430] - relay: TRUE
[16:04:43.430] - stdout: TRUE
[16:04:43.430] - signal: TRUE
[16:04:43.430] - resignal: FALSE
[16:04:43.430] - force: TRUE
[16:04:43.431] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.431] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.431]  - until=2
[16:04:43.431]  - relaying element #2
[16:04:43.431] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:43.431] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.432] signalConditionsASAP(NULL, pos=1) ... done
[16:04:43.432]  length: 3 (resolved future 1)
[16:04:43.432] Future #2
[16:04:43.432] result() for MulticoreFuture ...
[16:04:43.432] result() for MulticoreFuture ... done
[16:04:43.432] result() for MulticoreFuture ...
[16:04:43.433] result() for MulticoreFuture ... done
[16:04:43.433] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:43.433] - nx: 4
[16:04:43.433] - relay: TRUE
[16:04:43.433] - stdout: TRUE
[16:04:43.433] - signal: TRUE
[16:04:43.433] - resignal: FALSE
[16:04:43.433] - force: TRUE
[16:04:43.434] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:43.434] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.434]  - until=2
[16:04:43.434]  - relaying element #2
[16:04:43.434] result() for MulticoreFuture ...
[16:04:43.434] result() for MulticoreFuture ... done
[16:04:43.434] result() for MulticoreFuture ...
[16:04:43.435] result() for MulticoreFuture ... done
[16:04:43.435] result() for MulticoreFuture ...
[16:04:43.435] result() for MulticoreFuture ... done
[16:04:43.435] result() for MulticoreFuture ...
[16:04:43.435] result() for MulticoreFuture ... done
[16:04:43.435] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:43.436] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:43.436] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:43.436]  length: 2 (resolved future 2)
[16:04:43.436] Future #3
[16:04:43.436] result() for MulticoreFuture ...
[16:04:43.437] result() for MulticoreFuture ...
[16:04:43.437] result() for MulticoreFuture ... done
[16:04:43.438] result() for MulticoreFuture ... done
[16:04:43.438] result() for MulticoreFuture ...
[16:04:43.438] result() for MulticoreFuture ... done
[16:04:43.438] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:43.438] - nx: 4
[16:04:43.438] - relay: TRUE
[16:04:43.439] - stdout: TRUE
[16:04:43.439] - signal: TRUE
[16:04:43.439] - resignal: FALSE
[16:04:43.439] - force: TRUE
[16:04:43.439] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:43.439] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:43.439]  - until=3
[16:04:43.440]  - relaying element #3
[16:04:43.440] result() for MulticoreFuture ...
[16:04:43.440] result() for MulticoreFuture ... done
[16:04:43.440] result() for MulticoreFuture ...
[16:04:43.440] result() for MulticoreFuture ... done
[16:04:43.440] result() for MulticoreFuture ...
[16:04:43.440] result() for MulticoreFuture ... done
[16:04:43.441] result() for MulticoreFuture ...
[16:04:43.441] result() for MulticoreFuture ... done
[16:04:43.441] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:43.441] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:43.441] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:43.441]  length: 1 (resolved future 3)
[16:04:43.442] Future #4
[16:04:43.442] result() for MulticoreFuture ...
[16:04:43.442] result() for MulticoreFuture ...
[16:04:43.442] result() for MulticoreFuture ... done
[16:04:43.443] result() for MulticoreFuture ... done
[16:04:43.443] result() for MulticoreFuture ...
[16:04:43.443] result() for MulticoreFuture ... done
[16:04:43.443] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:04:43.443] - nx: 4
[16:04:43.443] - relay: TRUE
[16:04:43.444] - stdout: TRUE
[16:04:43.444] - signal: TRUE
[16:04:43.444] - resignal: FALSE
[16:04:43.444] - force: TRUE
[16:04:43.444] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:43.444] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:43.444]  - until=4
[16:04:43.444]  - relaying element #4
[16:04:43.445] result() for MulticoreFuture ...
[16:04:43.445] result() for MulticoreFuture ... done
[16:04:43.445] result() for MulticoreFuture ...
[16:04:43.445] result() for MulticoreFuture ... done
[16:04:43.445] result() for MulticoreFuture ...
[16:04:43.445] result() for MulticoreFuture ... done
[16:04:43.445] result() for MulticoreFuture ...
[16:04:43.445] result() for MulticoreFuture ... done
[16:04:43.445] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.446] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:43.446] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:04:43.446]  length: 0 (resolved future 4)
[16:04:43.446] Relaying remaining futures
[16:04:43.446] signalConditionsASAP(NULL, pos=0) ...
[16:04:43.446] - nx: 4
[16:04:43.446] - relay: TRUE
[16:04:43.446] - stdout: TRUE
[16:04:43.446] - signal: TRUE
[16:04:43.446] - resignal: FALSE
[16:04:43.447] - force: TRUE
[16:04:43.447] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.447] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:43.447] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.447] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:43.447] signalConditionsASAP(NULL, pos=0) ... done
[16:04:43.447] resolve() on environment ... DONE
[16:04:43.447] result() for MulticoreFuture ...
[16:04:43.447] result() for MulticoreFuture ... done
[16:04:43.448] result() for MulticoreFuture ...
[16:04:43.448] result() for MulticoreFuture ... done
[16:04:43.448] result() for MulticoreFuture ...
[16:04:43.448] result() for MulticoreFuture ... done
[16:04:43.448] result() for MulticoreFuture ...
[16:04:43.448] result() for MulticoreFuture ... done
[16:04:43.448] result() for MulticoreFuture ...
[16:04:43.448] result() for MulticoreFuture ... done
[16:04:43.448] result() for MulticoreFuture ...
[16:04:43.449] result() for MulticoreFuture ... done
<environment: 0x55874c49bfd8> 
Dimensions: c(2, 3, 1)
[16:04:43.449] getGlobalsAndPackages() ...
[16:04:43.449] Searching for globals...
[16:04:43.450] 
[16:04:43.450] Searching for globals ... DONE
[16:04:43.450] - globals: [0] <none>
[16:04:43.450] getGlobalsAndPackages() ... DONE
[16:04:43.450] run() for ‘Future’ ...
[16:04:43.450] - state: ‘created’
[16:04:43.451] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.454] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.455] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.455]   - Field: ‘label’
[16:04:43.455]   - Field: ‘local’
[16:04:43.455]   - Field: ‘owner’
[16:04:43.455]   - Field: ‘envir’
[16:04:43.455]   - Field: ‘workers’
[16:04:43.455]   - Field: ‘packages’
[16:04:43.455]   - Field: ‘gc’
[16:04:43.456]   - Field: ‘job’
[16:04:43.456]   - Field: ‘conditions’
[16:04:43.456]   - Field: ‘expr’
[16:04:43.456]   - Field: ‘uuid’
[16:04:43.456]   - Field: ‘seed’
[16:04:43.456]   - Field: ‘version’
[16:04:43.456]   - Field: ‘result’
[16:04:43.456]   - Field: ‘asynchronous’
[16:04:43.456]   - Field: ‘calls’
[16:04:43.457]   - Field: ‘globals’
[16:04:43.457]   - Field: ‘stdout’
[16:04:43.457]   - Field: ‘earlySignal’
[16:04:43.457]   - Field: ‘lazy’
[16:04:43.457]   - Field: ‘state’
[16:04:43.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.457] - Launch lazy future ...
[16:04:43.458] Packages needed by the future expression (n = 0): <none>
[16:04:43.458] Packages needed by future strategies (n = 0): <none>
[16:04:43.458] {
[16:04:43.458]     {
[16:04:43.458]         {
[16:04:43.458]             ...future.startTime <- base::Sys.time()
[16:04:43.458]             {
[16:04:43.458]                 {
[16:04:43.458]                   {
[16:04:43.458]                     {
[16:04:43.458]                       base::local({
[16:04:43.458]                         has_future <- base::requireNamespace("future", 
[16:04:43.458]                           quietly = TRUE)
[16:04:43.458]                         if (has_future) {
[16:04:43.458]                           ns <- base::getNamespace("future")
[16:04:43.458]                           version <- ns[[".package"]][["version"]]
[16:04:43.458]                           if (is.null(version)) 
[16:04:43.458]                             version <- utils::packageVersion("future")
[16:04:43.458]                         }
[16:04:43.458]                         else {
[16:04:43.458]                           version <- NULL
[16:04:43.458]                         }
[16:04:43.458]                         if (!has_future || version < "1.8.0") {
[16:04:43.458]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.458]                             "", base::R.version$version.string), 
[16:04:43.458]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.458]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.458]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.458]                               "release", "version")], collapse = " "), 
[16:04:43.458]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.458]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.458]                             info)
[16:04:43.458]                           info <- base::paste(info, collapse = "; ")
[16:04:43.458]                           if (!has_future) {
[16:04:43.458]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.458]                               info)
[16:04:43.458]                           }
[16:04:43.458]                           else {
[16:04:43.458]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.458]                               info, version)
[16:04:43.458]                           }
[16:04:43.458]                           base::stop(msg)
[16:04:43.458]                         }
[16:04:43.458]                       })
[16:04:43.458]                     }
[16:04:43.458]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.458]                     base::options(mc.cores = 1L)
[16:04:43.458]                   }
[16:04:43.458]                   options(future.plan = NULL)
[16:04:43.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.458]                 }
[16:04:43.458]                 ...future.workdir <- getwd()
[16:04:43.458]             }
[16:04:43.458]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.458]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.458]         }
[16:04:43.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.458]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.458]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.458]             base::names(...future.oldOptions))
[16:04:43.458]     }
[16:04:43.458]     if (FALSE) {
[16:04:43.458]     }
[16:04:43.458]     else {
[16:04:43.458]         if (TRUE) {
[16:04:43.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.458]                 open = "w")
[16:04:43.458]         }
[16:04:43.458]         else {
[16:04:43.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.458]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.458]         }
[16:04:43.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.458]             base::sink(type = "output", split = FALSE)
[16:04:43.458]             base::close(...future.stdout)
[16:04:43.458]         }, add = TRUE)
[16:04:43.458]     }
[16:04:43.458]     ...future.frame <- base::sys.nframe()
[16:04:43.458]     ...future.conditions <- base::list()
[16:04:43.458]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.458]     if (FALSE) {
[16:04:43.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.458]     }
[16:04:43.458]     ...future.result <- base::tryCatch({
[16:04:43.458]         base::withCallingHandlers({
[16:04:43.458]             ...future.value <- base::withVisible(base::local({
[16:04:43.458]                 withCallingHandlers({
[16:04:43.458]                   2
[16:04:43.458]                 }, immediateCondition = function(cond) {
[16:04:43.458]                   save_rds <- function (object, pathname, ...) 
[16:04:43.458]                   {
[16:04:43.458]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.458]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.458]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.458]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.458]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.458]                         fi_tmp[["mtime"]])
[16:04:43.458]                     }
[16:04:43.458]                     tryCatch({
[16:04:43.458]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.458]                     }, error = function(ex) {
[16:04:43.458]                       msg <- conditionMessage(ex)
[16:04:43.458]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.458]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.458]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.458]                         fi_tmp[["mtime"]], msg)
[16:04:43.458]                       ex$message <- msg
[16:04:43.458]                       stop(ex)
[16:04:43.458]                     })
[16:04:43.458]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.458]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.458]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.458]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.458]                       fi <- file.info(pathname)
[16:04:43.458]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.458]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.458]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.458]                         fi[["size"]], fi[["mtime"]])
[16:04:43.458]                       stop(msg)
[16:04:43.458]                     }
[16:04:43.458]                     invisible(pathname)
[16:04:43.458]                   }
[16:04:43.458]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.458]                     rootPath = tempdir()) 
[16:04:43.458]                   {
[16:04:43.458]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.458]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.458]                       tmpdir = path, fileext = ".rds")
[16:04:43.458]                     save_rds(obj, file)
[16:04:43.458]                   }
[16:04:43.458]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.458]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.458]                   {
[16:04:43.458]                     inherits <- base::inherits
[16:04:43.458]                     invokeRestart <- base::invokeRestart
[16:04:43.458]                     is.null <- base::is.null
[16:04:43.458]                     muffled <- FALSE
[16:04:43.458]                     if (inherits(cond, "message")) {
[16:04:43.458]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.458]                       if (muffled) 
[16:04:43.458]                         invokeRestart("muffleMessage")
[16:04:43.458]                     }
[16:04:43.458]                     else if (inherits(cond, "warning")) {
[16:04:43.458]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.458]                       if (muffled) 
[16:04:43.458]                         invokeRestart("muffleWarning")
[16:04:43.458]                     }
[16:04:43.458]                     else if (inherits(cond, "condition")) {
[16:04:43.458]                       if (!is.null(pattern)) {
[16:04:43.458]                         computeRestarts <- base::computeRestarts
[16:04:43.458]                         grepl <- base::grepl
[16:04:43.458]                         restarts <- computeRestarts(cond)
[16:04:43.458]                         for (restart in restarts) {
[16:04:43.458]                           name <- restart$name
[16:04:43.458]                           if (is.null(name)) 
[16:04:43.458]                             next
[16:04:43.458]                           if (!grepl(pattern, name)) 
[16:04:43.458]                             next
[16:04:43.458]                           invokeRestart(restart)
[16:04:43.458]                           muffled <- TRUE
[16:04:43.458]                           break
[16:04:43.458]                         }
[16:04:43.458]                       }
[16:04:43.458]                     }
[16:04:43.458]                     invisible(muffled)
[16:04:43.458]                   }
[16:04:43.458]                   muffleCondition(cond)
[16:04:43.458]                 })
[16:04:43.458]             }))
[16:04:43.458]             future::FutureResult(value = ...future.value$value, 
[16:04:43.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.458]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.458]                     ...future.globalenv.names))
[16:04:43.458]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.458]         }, condition = base::local({
[16:04:43.458]             c <- base::c
[16:04:43.458]             inherits <- base::inherits
[16:04:43.458]             invokeRestart <- base::invokeRestart
[16:04:43.458]             length <- base::length
[16:04:43.458]             list <- base::list
[16:04:43.458]             seq.int <- base::seq.int
[16:04:43.458]             signalCondition <- base::signalCondition
[16:04:43.458]             sys.calls <- base::sys.calls
[16:04:43.458]             `[[` <- base::`[[`
[16:04:43.458]             `+` <- base::`+`
[16:04:43.458]             `<<-` <- base::`<<-`
[16:04:43.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.458]                   3L)]
[16:04:43.458]             }
[16:04:43.458]             function(cond) {
[16:04:43.458]                 is_error <- inherits(cond, "error")
[16:04:43.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.458]                   NULL)
[16:04:43.458]                 if (is_error) {
[16:04:43.458]                   sessionInformation <- function() {
[16:04:43.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.458]                       search = base::search(), system = base::Sys.info())
[16:04:43.458]                   }
[16:04:43.458]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.458]                     cond$call), session = sessionInformation(), 
[16:04:43.458]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.458]                   signalCondition(cond)
[16:04:43.458]                 }
[16:04:43.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.458]                 "immediateCondition"))) {
[16:04:43.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.458]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.458]                   if (TRUE && !signal) {
[16:04:43.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.458]                     {
[16:04:43.458]                       inherits <- base::inherits
[16:04:43.458]                       invokeRestart <- base::invokeRestart
[16:04:43.458]                       is.null <- base::is.null
[16:04:43.458]                       muffled <- FALSE
[16:04:43.458]                       if (inherits(cond, "message")) {
[16:04:43.458]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.458]                         if (muffled) 
[16:04:43.458]                           invokeRestart("muffleMessage")
[16:04:43.458]                       }
[16:04:43.458]                       else if (inherits(cond, "warning")) {
[16:04:43.458]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.458]                         if (muffled) 
[16:04:43.458]                           invokeRestart("muffleWarning")
[16:04:43.458]                       }
[16:04:43.458]                       else if (inherits(cond, "condition")) {
[16:04:43.458]                         if (!is.null(pattern)) {
[16:04:43.458]                           computeRestarts <- base::computeRestarts
[16:04:43.458]                           grepl <- base::grepl
[16:04:43.458]                           restarts <- computeRestarts(cond)
[16:04:43.458]                           for (restart in restarts) {
[16:04:43.458]                             name <- restart$name
[16:04:43.458]                             if (is.null(name)) 
[16:04:43.458]                               next
[16:04:43.458]                             if (!grepl(pattern, name)) 
[16:04:43.458]                               next
[16:04:43.458]                             invokeRestart(restart)
[16:04:43.458]                             muffled <- TRUE
[16:04:43.458]                             break
[16:04:43.458]                           }
[16:04:43.458]                         }
[16:04:43.458]                       }
[16:04:43.458]                       invisible(muffled)
[16:04:43.458]                     }
[16:04:43.458]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.458]                   }
[16:04:43.458]                 }
[16:04:43.458]                 else {
[16:04:43.458]                   if (TRUE) {
[16:04:43.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.458]                     {
[16:04:43.458]                       inherits <- base::inherits
[16:04:43.458]                       invokeRestart <- base::invokeRestart
[16:04:43.458]                       is.null <- base::is.null
[16:04:43.458]                       muffled <- FALSE
[16:04:43.458]                       if (inherits(cond, "message")) {
[16:04:43.458]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.458]                         if (muffled) 
[16:04:43.458]                           invokeRestart("muffleMessage")
[16:04:43.458]                       }
[16:04:43.458]                       else if (inherits(cond, "warning")) {
[16:04:43.458]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.458]                         if (muffled) 
[16:04:43.458]                           invokeRestart("muffleWarning")
[16:04:43.458]                       }
[16:04:43.458]                       else if (inherits(cond, "condition")) {
[16:04:43.458]                         if (!is.null(pattern)) {
[16:04:43.458]                           computeRestarts <- base::computeRestarts
[16:04:43.458]                           grepl <- base::grepl
[16:04:43.458]                           restarts <- computeRestarts(cond)
[16:04:43.458]                           for (restart in restarts) {
[16:04:43.458]                             name <- restart$name
[16:04:43.458]                             if (is.null(name)) 
[16:04:43.458]                               next
[16:04:43.458]                             if (!grepl(pattern, name)) 
[16:04:43.458]                               next
[16:04:43.458]                             invokeRestart(restart)
[16:04:43.458]                             muffled <- TRUE
[16:04:43.458]                             break
[16:04:43.458]                           }
[16:04:43.458]                         }
[16:04:43.458]                       }
[16:04:43.458]                       invisible(muffled)
[16:04:43.458]                     }
[16:04:43.458]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.458]                   }
[16:04:43.458]                 }
[16:04:43.458]             }
[16:04:43.458]         }))
[16:04:43.458]     }, error = function(ex) {
[16:04:43.458]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.458]                 ...future.rng), started = ...future.startTime, 
[16:04:43.458]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.458]             version = "1.8"), class = "FutureResult")
[16:04:43.458]     }, finally = {
[16:04:43.458]         if (!identical(...future.workdir, getwd())) 
[16:04:43.458]             setwd(...future.workdir)
[16:04:43.458]         {
[16:04:43.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.458]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.458]             }
[16:04:43.458]             base::options(...future.oldOptions)
[16:04:43.458]             if (.Platform$OS.type == "windows") {
[16:04:43.458]                 old_names <- names(...future.oldEnvVars)
[16:04:43.458]                 envs <- base::Sys.getenv()
[16:04:43.458]                 names <- names(envs)
[16:04:43.458]                 common <- intersect(names, old_names)
[16:04:43.458]                 added <- setdiff(names, old_names)
[16:04:43.458]                 removed <- setdiff(old_names, names)
[16:04:43.458]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.458]                   envs[common]]
[16:04:43.458]                 NAMES <- toupper(changed)
[16:04:43.458]                 args <- list()
[16:04:43.458]                 for (kk in seq_along(NAMES)) {
[16:04:43.458]                   name <- changed[[kk]]
[16:04:43.458]                   NAME <- NAMES[[kk]]
[16:04:43.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.458]                     next
[16:04:43.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.458]                 }
[16:04:43.458]                 NAMES <- toupper(added)
[16:04:43.458]                 for (kk in seq_along(NAMES)) {
[16:04:43.458]                   name <- added[[kk]]
[16:04:43.458]                   NAME <- NAMES[[kk]]
[16:04:43.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.458]                     next
[16:04:43.458]                   args[[name]] <- ""
[16:04:43.458]                 }
[16:04:43.458]                 NAMES <- toupper(removed)
[16:04:43.458]                 for (kk in seq_along(NAMES)) {
[16:04:43.458]                   name <- removed[[kk]]
[16:04:43.458]                   NAME <- NAMES[[kk]]
[16:04:43.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.458]                     next
[16:04:43.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.458]                 }
[16:04:43.458]                 if (length(args) > 0) 
[16:04:43.458]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.458]             }
[16:04:43.458]             else {
[16:04:43.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.458]             }
[16:04:43.458]             {
[16:04:43.458]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.458]                   0L) {
[16:04:43.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.458]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.458]                   base::options(opts)
[16:04:43.458]                 }
[16:04:43.458]                 {
[16:04:43.458]                   {
[16:04:43.458]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.458]                     NULL
[16:04:43.458]                   }
[16:04:43.458]                   options(future.plan = NULL)
[16:04:43.458]                   if (is.na(NA_character_)) 
[16:04:43.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.458]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.458]                     envir = parent.frame()) 
[16:04:43.458]                   {
[16:04:43.458]                     default_workers <- missing(workers)
[16:04:43.458]                     if (is.function(workers)) 
[16:04:43.458]                       workers <- workers()
[16:04:43.458]                     workers <- structure(as.integer(workers), 
[16:04:43.458]                       class = class(workers))
[16:04:43.458]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.458]                       1L)
[16:04:43.458]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.458]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.458]                       if (default_workers) 
[16:04:43.458]                         supportsMulticore(warn = TRUE)
[16:04:43.458]                       return(sequential(..., envir = envir))
[16:04:43.458]                     }
[16:04:43.458]                     oopts <- options(mc.cores = workers)
[16:04:43.458]                     on.exit(options(oopts))
[16:04:43.458]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.458]                       envir = envir)
[16:04:43.458]                     if (!future$lazy) 
[16:04:43.458]                       future <- run(future)
[16:04:43.458]                     invisible(future)
[16:04:43.458]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.458]                 }
[16:04:43.458]             }
[16:04:43.458]         }
[16:04:43.458]     })
[16:04:43.458]     if (TRUE) {
[16:04:43.458]         base::sink(type = "output", split = FALSE)
[16:04:43.458]         if (TRUE) {
[16:04:43.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.458]         }
[16:04:43.458]         else {
[16:04:43.458]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.458]         }
[16:04:43.458]         base::close(...future.stdout)
[16:04:43.458]         ...future.stdout <- NULL
[16:04:43.458]     }
[16:04:43.458]     ...future.result$conditions <- ...future.conditions
[16:04:43.458]     ...future.result$finished <- base::Sys.time()
[16:04:43.458]     ...future.result
[16:04:43.458] }
[16:04:43.461] requestCore(): workers = 2
[16:04:43.463] MulticoreFuture started
[16:04:43.463] - Launch lazy future ... done
[16:04:43.464] run() for ‘MulticoreFuture’ ... done
[16:04:43.464] getGlobalsAndPackages() ...
[16:04:43.464] Searching for globals...
[16:04:43.464] plan(): Setting new future strategy stack:
[16:04:43.465] 
[16:04:43.464] List of future strategies:
[16:04:43.464] 1. sequential:
[16:04:43.464]    - args: function (..., envir = parent.frame())
[16:04:43.464]    - tweaked: FALSE
[16:04:43.464]    - call: NULL
[16:04:43.465] Searching for globals ... DONE
[16:04:43.465] plan(): nbrOfWorkers() = 1
[16:04:43.465] - globals: [0] <none>
[16:04:43.465] getGlobalsAndPackages() ... DONE
[16:04:43.466] run() for ‘Future’ ...
[16:04:43.466] - state: ‘created’
[16:04:43.466] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.467] plan(): Setting new future strategy stack:
[16:04:43.467] List of future strategies:
[16:04:43.467] 1. multicore:
[16:04:43.467]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.467]    - tweaked: FALSE
[16:04:43.467]    - call: plan(strategy)
[16:04:43.471] plan(): nbrOfWorkers() = 2
[16:04:43.471] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.472]   - Field: ‘label’
[16:04:43.472]   - Field: ‘local’
[16:04:43.472]   - Field: ‘owner’
[16:04:43.472]   - Field: ‘envir’
[16:04:43.472]   - Field: ‘workers’
[16:04:43.472]   - Field: ‘packages’
[16:04:43.473]   - Field: ‘gc’
[16:04:43.473]   - Field: ‘job’
[16:04:43.473]   - Field: ‘conditions’
[16:04:43.473]   - Field: ‘expr’
[16:04:43.473]   - Field: ‘uuid’
[16:04:43.473]   - Field: ‘seed’
[16:04:43.473]   - Field: ‘version’
[16:04:43.474]   - Field: ‘result’
[16:04:43.474]   - Field: ‘asynchronous’
[16:04:43.474]   - Field: ‘calls’
[16:04:43.474]   - Field: ‘globals’
[16:04:43.474]   - Field: ‘stdout’
[16:04:43.474]   - Field: ‘earlySignal’
[16:04:43.474]   - Field: ‘lazy’
[16:04:43.474]   - Field: ‘state’
[16:04:43.475] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.475] - Launch lazy future ...
[16:04:43.475] Packages needed by the future expression (n = 0): <none>
[16:04:43.475] Packages needed by future strategies (n = 0): <none>
[16:04:43.476] {
[16:04:43.476]     {
[16:04:43.476]         {
[16:04:43.476]             ...future.startTime <- base::Sys.time()
[16:04:43.476]             {
[16:04:43.476]                 {
[16:04:43.476]                   {
[16:04:43.476]                     {
[16:04:43.476]                       base::local({
[16:04:43.476]                         has_future <- base::requireNamespace("future", 
[16:04:43.476]                           quietly = TRUE)
[16:04:43.476]                         if (has_future) {
[16:04:43.476]                           ns <- base::getNamespace("future")
[16:04:43.476]                           version <- ns[[".package"]][["version"]]
[16:04:43.476]                           if (is.null(version)) 
[16:04:43.476]                             version <- utils::packageVersion("future")
[16:04:43.476]                         }
[16:04:43.476]                         else {
[16:04:43.476]                           version <- NULL
[16:04:43.476]                         }
[16:04:43.476]                         if (!has_future || version < "1.8.0") {
[16:04:43.476]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.476]                             "", base::R.version$version.string), 
[16:04:43.476]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.476]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.476]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.476]                               "release", "version")], collapse = " "), 
[16:04:43.476]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.476]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.476]                             info)
[16:04:43.476]                           info <- base::paste(info, collapse = "; ")
[16:04:43.476]                           if (!has_future) {
[16:04:43.476]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.476]                               info)
[16:04:43.476]                           }
[16:04:43.476]                           else {
[16:04:43.476]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.476]                               info, version)
[16:04:43.476]                           }
[16:04:43.476]                           base::stop(msg)
[16:04:43.476]                         }
[16:04:43.476]                       })
[16:04:43.476]                     }
[16:04:43.476]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.476]                     base::options(mc.cores = 1L)
[16:04:43.476]                   }
[16:04:43.476]                   options(future.plan = NULL)
[16:04:43.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.476]                 }
[16:04:43.476]                 ...future.workdir <- getwd()
[16:04:43.476]             }
[16:04:43.476]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.476]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.476]         }
[16:04:43.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.476]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.476]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.476]             base::names(...future.oldOptions))
[16:04:43.476]     }
[16:04:43.476]     if (FALSE) {
[16:04:43.476]     }
[16:04:43.476]     else {
[16:04:43.476]         if (TRUE) {
[16:04:43.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.476]                 open = "w")
[16:04:43.476]         }
[16:04:43.476]         else {
[16:04:43.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.476]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.476]         }
[16:04:43.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.476]             base::sink(type = "output", split = FALSE)
[16:04:43.476]             base::close(...future.stdout)
[16:04:43.476]         }, add = TRUE)
[16:04:43.476]     }
[16:04:43.476]     ...future.frame <- base::sys.nframe()
[16:04:43.476]     ...future.conditions <- base::list()
[16:04:43.476]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.476]     if (FALSE) {
[16:04:43.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.476]     }
[16:04:43.476]     ...future.result <- base::tryCatch({
[16:04:43.476]         base::withCallingHandlers({
[16:04:43.476]             ...future.value <- base::withVisible(base::local({
[16:04:43.476]                 withCallingHandlers({
[16:04:43.476]                   NULL
[16:04:43.476]                 }, immediateCondition = function(cond) {
[16:04:43.476]                   save_rds <- function (object, pathname, ...) 
[16:04:43.476]                   {
[16:04:43.476]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.476]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.476]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.476]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.476]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.476]                         fi_tmp[["mtime"]])
[16:04:43.476]                     }
[16:04:43.476]                     tryCatch({
[16:04:43.476]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.476]                     }, error = function(ex) {
[16:04:43.476]                       msg <- conditionMessage(ex)
[16:04:43.476]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.476]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.476]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.476]                         fi_tmp[["mtime"]], msg)
[16:04:43.476]                       ex$message <- msg
[16:04:43.476]                       stop(ex)
[16:04:43.476]                     })
[16:04:43.476]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.476]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.476]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.476]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.476]                       fi <- file.info(pathname)
[16:04:43.476]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.476]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.476]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.476]                         fi[["size"]], fi[["mtime"]])
[16:04:43.476]                       stop(msg)
[16:04:43.476]                     }
[16:04:43.476]                     invisible(pathname)
[16:04:43.476]                   }
[16:04:43.476]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.476]                     rootPath = tempdir()) 
[16:04:43.476]                   {
[16:04:43.476]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.476]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.476]                       tmpdir = path, fileext = ".rds")
[16:04:43.476]                     save_rds(obj, file)
[16:04:43.476]                   }
[16:04:43.476]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.476]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.476]                   {
[16:04:43.476]                     inherits <- base::inherits
[16:04:43.476]                     invokeRestart <- base::invokeRestart
[16:04:43.476]                     is.null <- base::is.null
[16:04:43.476]                     muffled <- FALSE
[16:04:43.476]                     if (inherits(cond, "message")) {
[16:04:43.476]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.476]                       if (muffled) 
[16:04:43.476]                         invokeRestart("muffleMessage")
[16:04:43.476]                     }
[16:04:43.476]                     else if (inherits(cond, "warning")) {
[16:04:43.476]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.476]                       if (muffled) 
[16:04:43.476]                         invokeRestart("muffleWarning")
[16:04:43.476]                     }
[16:04:43.476]                     else if (inherits(cond, "condition")) {
[16:04:43.476]                       if (!is.null(pattern)) {
[16:04:43.476]                         computeRestarts <- base::computeRestarts
[16:04:43.476]                         grepl <- base::grepl
[16:04:43.476]                         restarts <- computeRestarts(cond)
[16:04:43.476]                         for (restart in restarts) {
[16:04:43.476]                           name <- restart$name
[16:04:43.476]                           if (is.null(name)) 
[16:04:43.476]                             next
[16:04:43.476]                           if (!grepl(pattern, name)) 
[16:04:43.476]                             next
[16:04:43.476]                           invokeRestart(restart)
[16:04:43.476]                           muffled <- TRUE
[16:04:43.476]                           break
[16:04:43.476]                         }
[16:04:43.476]                       }
[16:04:43.476]                     }
[16:04:43.476]                     invisible(muffled)
[16:04:43.476]                   }
[16:04:43.476]                   muffleCondition(cond)
[16:04:43.476]                 })
[16:04:43.476]             }))
[16:04:43.476]             future::FutureResult(value = ...future.value$value, 
[16:04:43.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.476]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.476]                     ...future.globalenv.names))
[16:04:43.476]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.476]         }, condition = base::local({
[16:04:43.476]             c <- base::c
[16:04:43.476]             inherits <- base::inherits
[16:04:43.476]             invokeRestart <- base::invokeRestart
[16:04:43.476]             length <- base::length
[16:04:43.476]             list <- base::list
[16:04:43.476]             seq.int <- base::seq.int
[16:04:43.476]             signalCondition <- base::signalCondition
[16:04:43.476]             sys.calls <- base::sys.calls
[16:04:43.476]             `[[` <- base::`[[`
[16:04:43.476]             `+` <- base::`+`
[16:04:43.476]             `<<-` <- base::`<<-`
[16:04:43.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.476]                   3L)]
[16:04:43.476]             }
[16:04:43.476]             function(cond) {
[16:04:43.476]                 is_error <- inherits(cond, "error")
[16:04:43.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.476]                   NULL)
[16:04:43.476]                 if (is_error) {
[16:04:43.476]                   sessionInformation <- function() {
[16:04:43.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.476]                       search = base::search(), system = base::Sys.info())
[16:04:43.476]                   }
[16:04:43.476]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.476]                     cond$call), session = sessionInformation(), 
[16:04:43.476]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.476]                   signalCondition(cond)
[16:04:43.476]                 }
[16:04:43.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.476]                 "immediateCondition"))) {
[16:04:43.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.476]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.476]                   if (TRUE && !signal) {
[16:04:43.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.476]                     {
[16:04:43.476]                       inherits <- base::inherits
[16:04:43.476]                       invokeRestart <- base::invokeRestart
[16:04:43.476]                       is.null <- base::is.null
[16:04:43.476]                       muffled <- FALSE
[16:04:43.476]                       if (inherits(cond, "message")) {
[16:04:43.476]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.476]                         if (muffled) 
[16:04:43.476]                           invokeRestart("muffleMessage")
[16:04:43.476]                       }
[16:04:43.476]                       else if (inherits(cond, "warning")) {
[16:04:43.476]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.476]                         if (muffled) 
[16:04:43.476]                           invokeRestart("muffleWarning")
[16:04:43.476]                       }
[16:04:43.476]                       else if (inherits(cond, "condition")) {
[16:04:43.476]                         if (!is.null(pattern)) {
[16:04:43.476]                           computeRestarts <- base::computeRestarts
[16:04:43.476]                           grepl <- base::grepl
[16:04:43.476]                           restarts <- computeRestarts(cond)
[16:04:43.476]                           for (restart in restarts) {
[16:04:43.476]                             name <- restart$name
[16:04:43.476]                             if (is.null(name)) 
[16:04:43.476]                               next
[16:04:43.476]                             if (!grepl(pattern, name)) 
[16:04:43.476]                               next
[16:04:43.476]                             invokeRestart(restart)
[16:04:43.476]                             muffled <- TRUE
[16:04:43.476]                             break
[16:04:43.476]                           }
[16:04:43.476]                         }
[16:04:43.476]                       }
[16:04:43.476]                       invisible(muffled)
[16:04:43.476]                     }
[16:04:43.476]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.476]                   }
[16:04:43.476]                 }
[16:04:43.476]                 else {
[16:04:43.476]                   if (TRUE) {
[16:04:43.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.476]                     {
[16:04:43.476]                       inherits <- base::inherits
[16:04:43.476]                       invokeRestart <- base::invokeRestart
[16:04:43.476]                       is.null <- base::is.null
[16:04:43.476]                       muffled <- FALSE
[16:04:43.476]                       if (inherits(cond, "message")) {
[16:04:43.476]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.476]                         if (muffled) 
[16:04:43.476]                           invokeRestart("muffleMessage")
[16:04:43.476]                       }
[16:04:43.476]                       else if (inherits(cond, "warning")) {
[16:04:43.476]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.476]                         if (muffled) 
[16:04:43.476]                           invokeRestart("muffleWarning")
[16:04:43.476]                       }
[16:04:43.476]                       else if (inherits(cond, "condition")) {
[16:04:43.476]                         if (!is.null(pattern)) {
[16:04:43.476]                           computeRestarts <- base::computeRestarts
[16:04:43.476]                           grepl <- base::grepl
[16:04:43.476]                           restarts <- computeRestarts(cond)
[16:04:43.476]                           for (restart in restarts) {
[16:04:43.476]                             name <- restart$name
[16:04:43.476]                             if (is.null(name)) 
[16:04:43.476]                               next
[16:04:43.476]                             if (!grepl(pattern, name)) 
[16:04:43.476]                               next
[16:04:43.476]                             invokeRestart(restart)
[16:04:43.476]                             muffled <- TRUE
[16:04:43.476]                             break
[16:04:43.476]                           }
[16:04:43.476]                         }
[16:04:43.476]                       }
[16:04:43.476]                       invisible(muffled)
[16:04:43.476]                     }
[16:04:43.476]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.476]                   }
[16:04:43.476]                 }
[16:04:43.476]             }
[16:04:43.476]         }))
[16:04:43.476]     }, error = function(ex) {
[16:04:43.476]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.476]                 ...future.rng), started = ...future.startTime, 
[16:04:43.476]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.476]             version = "1.8"), class = "FutureResult")
[16:04:43.476]     }, finally = {
[16:04:43.476]         if (!identical(...future.workdir, getwd())) 
[16:04:43.476]             setwd(...future.workdir)
[16:04:43.476]         {
[16:04:43.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.476]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.476]             }
[16:04:43.476]             base::options(...future.oldOptions)
[16:04:43.476]             if (.Platform$OS.type == "windows") {
[16:04:43.476]                 old_names <- names(...future.oldEnvVars)
[16:04:43.476]                 envs <- base::Sys.getenv()
[16:04:43.476]                 names <- names(envs)
[16:04:43.476]                 common <- intersect(names, old_names)
[16:04:43.476]                 added <- setdiff(names, old_names)
[16:04:43.476]                 removed <- setdiff(old_names, names)
[16:04:43.476]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.476]                   envs[common]]
[16:04:43.476]                 NAMES <- toupper(changed)
[16:04:43.476]                 args <- list()
[16:04:43.476]                 for (kk in seq_along(NAMES)) {
[16:04:43.476]                   name <- changed[[kk]]
[16:04:43.476]                   NAME <- NAMES[[kk]]
[16:04:43.476]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.476]                     next
[16:04:43.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.476]                 }
[16:04:43.476]                 NAMES <- toupper(added)
[16:04:43.476]                 for (kk in seq_along(NAMES)) {
[16:04:43.476]                   name <- added[[kk]]
[16:04:43.476]                   NAME <- NAMES[[kk]]
[16:04:43.476]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.476]                     next
[16:04:43.476]                   args[[name]] <- ""
[16:04:43.476]                 }
[16:04:43.476]                 NAMES <- toupper(removed)
[16:04:43.476]                 for (kk in seq_along(NAMES)) {
[16:04:43.476]                   name <- removed[[kk]]
[16:04:43.476]                   NAME <- NAMES[[kk]]
[16:04:43.476]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.476]                     next
[16:04:43.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.476]                 }
[16:04:43.476]                 if (length(args) > 0) 
[16:04:43.476]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.476]             }
[16:04:43.476]             else {
[16:04:43.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.476]             }
[16:04:43.476]             {
[16:04:43.476]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.476]                   0L) {
[16:04:43.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.476]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.476]                   base::options(opts)
[16:04:43.476]                 }
[16:04:43.476]                 {
[16:04:43.476]                   {
[16:04:43.476]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.476]                     NULL
[16:04:43.476]                   }
[16:04:43.476]                   options(future.plan = NULL)
[16:04:43.476]                   if (is.na(NA_character_)) 
[16:04:43.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.476]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.476]                     envir = parent.frame()) 
[16:04:43.476]                   {
[16:04:43.476]                     default_workers <- missing(workers)
[16:04:43.476]                     if (is.function(workers)) 
[16:04:43.476]                       workers <- workers()
[16:04:43.476]                     workers <- structure(as.integer(workers), 
[16:04:43.476]                       class = class(workers))
[16:04:43.476]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.476]                       1L)
[16:04:43.476]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.476]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.476]                       if (default_workers) 
[16:04:43.476]                         supportsMulticore(warn = TRUE)
[16:04:43.476]                       return(sequential(..., envir = envir))
[16:04:43.476]                     }
[16:04:43.476]                     oopts <- options(mc.cores = workers)
[16:04:43.476]                     on.exit(options(oopts))
[16:04:43.476]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.476]                       envir = envir)
[16:04:43.476]                     if (!future$lazy) 
[16:04:43.476]                       future <- run(future)
[16:04:43.476]                     invisible(future)
[16:04:43.476]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.476]                 }
[16:04:43.476]             }
[16:04:43.476]         }
[16:04:43.476]     })
[16:04:43.476]     if (TRUE) {
[16:04:43.476]         base::sink(type = "output", split = FALSE)
[16:04:43.476]         if (TRUE) {
[16:04:43.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.476]         }
[16:04:43.476]         else {
[16:04:43.476]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.476]         }
[16:04:43.476]         base::close(...future.stdout)
[16:04:43.476]         ...future.stdout <- NULL
[16:04:43.476]     }
[16:04:43.476]     ...future.result$conditions <- ...future.conditions
[16:04:43.476]     ...future.result$finished <- base::Sys.time()
[16:04:43.476]     ...future.result
[16:04:43.476] }
[16:04:43.480] requestCore(): workers = 2
[16:04:43.482] MulticoreFuture started
[16:04:43.482] - Launch lazy future ... done
[16:04:43.482] run() for ‘MulticoreFuture’ ... done
[16:04:43.483] getGlobalsAndPackages() ...
[16:04:43.483] plan(): Setting new future strategy stack:
[16:04:43.483] Searching for globals...
[16:04:43.483] List of future strategies:
[16:04:43.483] 1. sequential:
[16:04:43.483]    - args: function (..., envir = parent.frame())
[16:04:43.483]    - tweaked: FALSE
[16:04:43.483]    - call: NULL
[16:04:43.484] plan(): nbrOfWorkers() = 1
[16:04:43.485] - globals found: [1] ‘{’
[16:04:43.485] Searching for globals ... DONE
[16:04:43.485] Resolving globals: FALSE
[16:04:43.486] 
[16:04:43.486] 
[16:04:43.486] getGlobalsAndPackages() ... DONE
[16:04:43.486] plan(): Setting new future strategy stack:
[16:04:43.486] run() for ‘Future’ ...
[16:04:43.486] List of future strategies:
[16:04:43.486] 1. multicore:
[16:04:43.486]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.486]    - tweaked: FALSE
[16:04:43.486]    - call: plan(strategy)
[16:04:43.487] - state: ‘created’
[16:04:43.487] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.491] plan(): nbrOfWorkers() = 2
[16:04:43.491] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.492] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.492]   - Field: ‘label’
[16:04:43.492]   - Field: ‘local’
[16:04:43.492]   - Field: ‘owner’
[16:04:43.492]   - Field: ‘envir’
[16:04:43.492]   - Field: ‘workers’
[16:04:43.492]   - Field: ‘packages’
[16:04:43.493]   - Field: ‘gc’
[16:04:43.493]   - Field: ‘job’
[16:04:43.493]   - Field: ‘conditions’
[16:04:43.493]   - Field: ‘expr’
[16:04:43.493]   - Field: ‘uuid’
[16:04:43.493]   - Field: ‘seed’
[16:04:43.493]   - Field: ‘version’
[16:04:43.494]   - Field: ‘result’
[16:04:43.494]   - Field: ‘asynchronous’
[16:04:43.494]   - Field: ‘calls’
[16:04:43.494]   - Field: ‘globals’
[16:04:43.494]   - Field: ‘stdout’
[16:04:43.494]   - Field: ‘earlySignal’
[16:04:43.494]   - Field: ‘lazy’
[16:04:43.494]   - Field: ‘state’
[16:04:43.495] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.495] - Launch lazy future ...
[16:04:43.495] Packages needed by the future expression (n = 0): <none>
[16:04:43.495] Packages needed by future strategies (n = 0): <none>
[16:04:43.496] {
[16:04:43.496]     {
[16:04:43.496]         {
[16:04:43.496]             ...future.startTime <- base::Sys.time()
[16:04:43.496]             {
[16:04:43.496]                 {
[16:04:43.496]                   {
[16:04:43.496]                     {
[16:04:43.496]                       base::local({
[16:04:43.496]                         has_future <- base::requireNamespace("future", 
[16:04:43.496]                           quietly = TRUE)
[16:04:43.496]                         if (has_future) {
[16:04:43.496]                           ns <- base::getNamespace("future")
[16:04:43.496]                           version <- ns[[".package"]][["version"]]
[16:04:43.496]                           if (is.null(version)) 
[16:04:43.496]                             version <- utils::packageVersion("future")
[16:04:43.496]                         }
[16:04:43.496]                         else {
[16:04:43.496]                           version <- NULL
[16:04:43.496]                         }
[16:04:43.496]                         if (!has_future || version < "1.8.0") {
[16:04:43.496]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.496]                             "", base::R.version$version.string), 
[16:04:43.496]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.496]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.496]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.496]                               "release", "version")], collapse = " "), 
[16:04:43.496]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.496]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.496]                             info)
[16:04:43.496]                           info <- base::paste(info, collapse = "; ")
[16:04:43.496]                           if (!has_future) {
[16:04:43.496]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.496]                               info)
[16:04:43.496]                           }
[16:04:43.496]                           else {
[16:04:43.496]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.496]                               info, version)
[16:04:43.496]                           }
[16:04:43.496]                           base::stop(msg)
[16:04:43.496]                         }
[16:04:43.496]                       })
[16:04:43.496]                     }
[16:04:43.496]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.496]                     base::options(mc.cores = 1L)
[16:04:43.496]                   }
[16:04:43.496]                   options(future.plan = NULL)
[16:04:43.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.496]                 }
[16:04:43.496]                 ...future.workdir <- getwd()
[16:04:43.496]             }
[16:04:43.496]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.496]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.496]         }
[16:04:43.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.496]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.496]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.496]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.496]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.496]             base::names(...future.oldOptions))
[16:04:43.496]     }
[16:04:43.496]     if (FALSE) {
[16:04:43.496]     }
[16:04:43.496]     else {
[16:04:43.496]         if (TRUE) {
[16:04:43.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.496]                 open = "w")
[16:04:43.496]         }
[16:04:43.496]         else {
[16:04:43.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.496]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.496]         }
[16:04:43.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.496]             base::sink(type = "output", split = FALSE)
[16:04:43.496]             base::close(...future.stdout)
[16:04:43.496]         }, add = TRUE)
[16:04:43.496]     }
[16:04:43.496]     ...future.frame <- base::sys.nframe()
[16:04:43.496]     ...future.conditions <- base::list()
[16:04:43.496]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.496]     if (FALSE) {
[16:04:43.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.496]     }
[16:04:43.496]     ...future.result <- base::tryCatch({
[16:04:43.496]         base::withCallingHandlers({
[16:04:43.496]             ...future.value <- base::withVisible(base::local({
[16:04:43.496]                 withCallingHandlers({
[16:04:43.496]                   {
[16:04:43.496]                     4
[16:04:43.496]                   }
[16:04:43.496]                 }, immediateCondition = function(cond) {
[16:04:43.496]                   save_rds <- function (object, pathname, ...) 
[16:04:43.496]                   {
[16:04:43.496]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.496]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.496]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.496]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.496]                         fi_tmp[["mtime"]])
[16:04:43.496]                     }
[16:04:43.496]                     tryCatch({
[16:04:43.496]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.496]                     }, error = function(ex) {
[16:04:43.496]                       msg <- conditionMessage(ex)
[16:04:43.496]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.496]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.496]                         fi_tmp[["mtime"]], msg)
[16:04:43.496]                       ex$message <- msg
[16:04:43.496]                       stop(ex)
[16:04:43.496]                     })
[16:04:43.496]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.496]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.496]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.496]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.496]                       fi <- file.info(pathname)
[16:04:43.496]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.496]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.496]                         fi[["size"]], fi[["mtime"]])
[16:04:43.496]                       stop(msg)
[16:04:43.496]                     }
[16:04:43.496]                     invisible(pathname)
[16:04:43.496]                   }
[16:04:43.496]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.496]                     rootPath = tempdir()) 
[16:04:43.496]                   {
[16:04:43.496]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.496]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.496]                       tmpdir = path, fileext = ".rds")
[16:04:43.496]                     save_rds(obj, file)
[16:04:43.496]                   }
[16:04:43.496]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.496]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.496]                   {
[16:04:43.496]                     inherits <- base::inherits
[16:04:43.496]                     invokeRestart <- base::invokeRestart
[16:04:43.496]                     is.null <- base::is.null
[16:04:43.496]                     muffled <- FALSE
[16:04:43.496]                     if (inherits(cond, "message")) {
[16:04:43.496]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.496]                       if (muffled) 
[16:04:43.496]                         invokeRestart("muffleMessage")
[16:04:43.496]                     }
[16:04:43.496]                     else if (inherits(cond, "warning")) {
[16:04:43.496]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.496]                       if (muffled) 
[16:04:43.496]                         invokeRestart("muffleWarning")
[16:04:43.496]                     }
[16:04:43.496]                     else if (inherits(cond, "condition")) {
[16:04:43.496]                       if (!is.null(pattern)) {
[16:04:43.496]                         computeRestarts <- base::computeRestarts
[16:04:43.496]                         grepl <- base::grepl
[16:04:43.496]                         restarts <- computeRestarts(cond)
[16:04:43.496]                         for (restart in restarts) {
[16:04:43.496]                           name <- restart$name
[16:04:43.496]                           if (is.null(name)) 
[16:04:43.496]                             next
[16:04:43.496]                           if (!grepl(pattern, name)) 
[16:04:43.496]                             next
[16:04:43.496]                           invokeRestart(restart)
[16:04:43.496]                           muffled <- TRUE
[16:04:43.496]                           break
[16:04:43.496]                         }
[16:04:43.496]                       }
[16:04:43.496]                     }
[16:04:43.496]                     invisible(muffled)
[16:04:43.496]                   }
[16:04:43.496]                   muffleCondition(cond)
[16:04:43.496]                 })
[16:04:43.496]             }))
[16:04:43.496]             future::FutureResult(value = ...future.value$value, 
[16:04:43.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.496]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.496]                     ...future.globalenv.names))
[16:04:43.496]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.496]         }, condition = base::local({
[16:04:43.496]             c <- base::c
[16:04:43.496]             inherits <- base::inherits
[16:04:43.496]             invokeRestart <- base::invokeRestart
[16:04:43.496]             length <- base::length
[16:04:43.496]             list <- base::list
[16:04:43.496]             seq.int <- base::seq.int
[16:04:43.496]             signalCondition <- base::signalCondition
[16:04:43.496]             sys.calls <- base::sys.calls
[16:04:43.496]             `[[` <- base::`[[`
[16:04:43.496]             `+` <- base::`+`
[16:04:43.496]             `<<-` <- base::`<<-`
[16:04:43.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.496]                   3L)]
[16:04:43.496]             }
[16:04:43.496]             function(cond) {
[16:04:43.496]                 is_error <- inherits(cond, "error")
[16:04:43.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.496]                   NULL)
[16:04:43.496]                 if (is_error) {
[16:04:43.496]                   sessionInformation <- function() {
[16:04:43.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.496]                       search = base::search(), system = base::Sys.info())
[16:04:43.496]                   }
[16:04:43.496]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.496]                     cond$call), session = sessionInformation(), 
[16:04:43.496]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.496]                   signalCondition(cond)
[16:04:43.496]                 }
[16:04:43.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.496]                 "immediateCondition"))) {
[16:04:43.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.496]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.496]                   if (TRUE && !signal) {
[16:04:43.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.496]                     {
[16:04:43.496]                       inherits <- base::inherits
[16:04:43.496]                       invokeRestart <- base::invokeRestart
[16:04:43.496]                       is.null <- base::is.null
[16:04:43.496]                       muffled <- FALSE
[16:04:43.496]                       if (inherits(cond, "message")) {
[16:04:43.496]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.496]                         if (muffled) 
[16:04:43.496]                           invokeRestart("muffleMessage")
[16:04:43.496]                       }
[16:04:43.496]                       else if (inherits(cond, "warning")) {
[16:04:43.496]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.496]                         if (muffled) 
[16:04:43.496]                           invokeRestart("muffleWarning")
[16:04:43.496]                       }
[16:04:43.496]                       else if (inherits(cond, "condition")) {
[16:04:43.496]                         if (!is.null(pattern)) {
[16:04:43.496]                           computeRestarts <- base::computeRestarts
[16:04:43.496]                           grepl <- base::grepl
[16:04:43.496]                           restarts <- computeRestarts(cond)
[16:04:43.496]                           for (restart in restarts) {
[16:04:43.496]                             name <- restart$name
[16:04:43.496]                             if (is.null(name)) 
[16:04:43.496]                               next
[16:04:43.496]                             if (!grepl(pattern, name)) 
[16:04:43.496]                               next
[16:04:43.496]                             invokeRestart(restart)
[16:04:43.496]                             muffled <- TRUE
[16:04:43.496]                             break
[16:04:43.496]                           }
[16:04:43.496]                         }
[16:04:43.496]                       }
[16:04:43.496]                       invisible(muffled)
[16:04:43.496]                     }
[16:04:43.496]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.496]                   }
[16:04:43.496]                 }
[16:04:43.496]                 else {
[16:04:43.496]                   if (TRUE) {
[16:04:43.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.496]                     {
[16:04:43.496]                       inherits <- base::inherits
[16:04:43.496]                       invokeRestart <- base::invokeRestart
[16:04:43.496]                       is.null <- base::is.null
[16:04:43.496]                       muffled <- FALSE
[16:04:43.496]                       if (inherits(cond, "message")) {
[16:04:43.496]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.496]                         if (muffled) 
[16:04:43.496]                           invokeRestart("muffleMessage")
[16:04:43.496]                       }
[16:04:43.496]                       else if (inherits(cond, "warning")) {
[16:04:43.496]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.496]                         if (muffled) 
[16:04:43.496]                           invokeRestart("muffleWarning")
[16:04:43.496]                       }
[16:04:43.496]                       else if (inherits(cond, "condition")) {
[16:04:43.496]                         if (!is.null(pattern)) {
[16:04:43.496]                           computeRestarts <- base::computeRestarts
[16:04:43.496]                           grepl <- base::grepl
[16:04:43.496]                           restarts <- computeRestarts(cond)
[16:04:43.496]                           for (restart in restarts) {
[16:04:43.496]                             name <- restart$name
[16:04:43.496]                             if (is.null(name)) 
[16:04:43.496]                               next
[16:04:43.496]                             if (!grepl(pattern, name)) 
[16:04:43.496]                               next
[16:04:43.496]                             invokeRestart(restart)
[16:04:43.496]                             muffled <- TRUE
[16:04:43.496]                             break
[16:04:43.496]                           }
[16:04:43.496]                         }
[16:04:43.496]                       }
[16:04:43.496]                       invisible(muffled)
[16:04:43.496]                     }
[16:04:43.496]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.496]                   }
[16:04:43.496]                 }
[16:04:43.496]             }
[16:04:43.496]         }))
[16:04:43.496]     }, error = function(ex) {
[16:04:43.496]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.496]                 ...future.rng), started = ...future.startTime, 
[16:04:43.496]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.496]             version = "1.8"), class = "FutureResult")
[16:04:43.496]     }, finally = {
[16:04:43.496]         if (!identical(...future.workdir, getwd())) 
[16:04:43.496]             setwd(...future.workdir)
[16:04:43.496]         {
[16:04:43.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.496]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.496]             }
[16:04:43.496]             base::options(...future.oldOptions)
[16:04:43.496]             if (.Platform$OS.type == "windows") {
[16:04:43.496]                 old_names <- names(...future.oldEnvVars)
[16:04:43.496]                 envs <- base::Sys.getenv()
[16:04:43.496]                 names <- names(envs)
[16:04:43.496]                 common <- intersect(names, old_names)
[16:04:43.496]                 added <- setdiff(names, old_names)
[16:04:43.496]                 removed <- setdiff(old_names, names)
[16:04:43.496]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.496]                   envs[common]]
[16:04:43.496]                 NAMES <- toupper(changed)
[16:04:43.496]                 args <- list()
[16:04:43.496]                 for (kk in seq_along(NAMES)) {
[16:04:43.496]                   name <- changed[[kk]]
[16:04:43.496]                   NAME <- NAMES[[kk]]
[16:04:43.496]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.496]                     next
[16:04:43.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.496]                 }
[16:04:43.496]                 NAMES <- toupper(added)
[16:04:43.496]                 for (kk in seq_along(NAMES)) {
[16:04:43.496]                   name <- added[[kk]]
[16:04:43.496]                   NAME <- NAMES[[kk]]
[16:04:43.496]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.496]                     next
[16:04:43.496]                   args[[name]] <- ""
[16:04:43.496]                 }
[16:04:43.496]                 NAMES <- toupper(removed)
[16:04:43.496]                 for (kk in seq_along(NAMES)) {
[16:04:43.496]                   name <- removed[[kk]]
[16:04:43.496]                   NAME <- NAMES[[kk]]
[16:04:43.496]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.496]                     next
[16:04:43.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.496]                 }
[16:04:43.496]                 if (length(args) > 0) 
[16:04:43.496]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.496]             }
[16:04:43.496]             else {
[16:04:43.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.496]             }
[16:04:43.496]             {
[16:04:43.496]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.496]                   0L) {
[16:04:43.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.496]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.496]                   base::options(opts)
[16:04:43.496]                 }
[16:04:43.496]                 {
[16:04:43.496]                   {
[16:04:43.496]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.496]                     NULL
[16:04:43.496]                   }
[16:04:43.496]                   options(future.plan = NULL)
[16:04:43.496]                   if (is.na(NA_character_)) 
[16:04:43.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.496]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.496]                     envir = parent.frame()) 
[16:04:43.496]                   {
[16:04:43.496]                     default_workers <- missing(workers)
[16:04:43.496]                     if (is.function(workers)) 
[16:04:43.496]                       workers <- workers()
[16:04:43.496]                     workers <- structure(as.integer(workers), 
[16:04:43.496]                       class = class(workers))
[16:04:43.496]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.496]                       1L)
[16:04:43.496]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.496]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.496]                       if (default_workers) 
[16:04:43.496]                         supportsMulticore(warn = TRUE)
[16:04:43.496]                       return(sequential(..., envir = envir))
[16:04:43.496]                     }
[16:04:43.496]                     oopts <- options(mc.cores = workers)
[16:04:43.496]                     on.exit(options(oopts))
[16:04:43.496]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.496]                       envir = envir)
[16:04:43.496]                     if (!future$lazy) 
[16:04:43.496]                       future <- run(future)
[16:04:43.496]                     invisible(future)
[16:04:43.496]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.496]                 }
[16:04:43.496]             }
[16:04:43.496]         }
[16:04:43.496]     })
[16:04:43.496]     if (TRUE) {
[16:04:43.496]         base::sink(type = "output", split = FALSE)
[16:04:43.496]         if (TRUE) {
[16:04:43.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.496]         }
[16:04:43.496]         else {
[16:04:43.496]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.496]         }
[16:04:43.496]         base::close(...future.stdout)
[16:04:43.496]         ...future.stdout <- NULL
[16:04:43.496]     }
[16:04:43.496]     ...future.result$conditions <- ...future.conditions
[16:04:43.496]     ...future.result$finished <- base::Sys.time()
[16:04:43.496]     ...future.result
[16:04:43.496] }
[16:04:43.499] requestCore(): workers = 2
[16:04:43.500] Poll #1 (0): usedCores() = 2, workers = 2
[16:04:43.510] result() for MulticoreFuture ...
[16:04:43.511] result() for MulticoreFuture ...
[16:04:43.512] result() for MulticoreFuture ... done
[16:04:43.512] result() for MulticoreFuture ... done
[16:04:43.512] result() for MulticoreFuture ...
[16:04:43.512] result() for MulticoreFuture ... done
[16:04:43.514] MulticoreFuture started
[16:04:43.515] - Launch lazy future ... done
[16:04:43.515] run() for ‘MulticoreFuture’ ... done
[16:04:43.516] plan(): Setting new future strategy stack:
<environment: 0x55874edd7948> 
[16:04:43.516] List of future strategies:
[16:04:43.516] 1. sequential:
[16:04:43.516]    - args: function (..., envir = parent.frame())
[16:04:43.516]    - tweaked: FALSE
[16:04:43.516]    - call: NULL
[16:04:43.517] plan(): nbrOfWorkers() = 1
<environment: 0x55874f98b008> 
[16:04:43.520] plan(): Setting new future strategy stack:
[16:04:43.520] List of future strategies:
[16:04:43.520] 1. multicore:
[16:04:43.520]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.520]    - tweaked: FALSE
[16:04:43.520]    - call: plan(strategy)
[16:04:43.525] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:43.527] resolve() on environment ...
[16:04:43.527]  recursive: 0
[16:04:43.528]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:43.528] signalConditionsASAP(numeric, pos=1) ...
[16:04:43.528] - nx: 4
[16:04:43.528] - relay: TRUE
[16:04:43.528] - stdout: TRUE
[16:04:43.528] - signal: TRUE
[16:04:43.529] - resignal: FALSE
[16:04:43.529] - force: TRUE
[16:04:43.529] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.529] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.529]  - until=2
[16:04:43.529]  - relaying element #2
[16:04:43.529] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:43.529] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.530] signalConditionsASAP(NULL, pos=1) ... done
[16:04:43.530]  length: 3 (resolved future 1)
[16:04:43.530] Future #2
[16:04:43.530] result() for MulticoreFuture ...
[16:04:43.530] result() for MulticoreFuture ... done
[16:04:43.530] result() for MulticoreFuture ...
[16:04:43.531] result() for MulticoreFuture ... done
[16:04:43.531] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:43.531] - nx: 4
[16:04:43.531] - relay: TRUE
[16:04:43.531] - stdout: TRUE
[16:04:43.531] - signal: TRUE
[16:04:43.531] - resignal: FALSE
[16:04:43.531] - force: TRUE
[16:04:43.532] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:43.532] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.532]  - until=2
[16:04:43.532]  - relaying element #2
[16:04:43.532] result() for MulticoreFuture ...
[16:04:43.532] result() for MulticoreFuture ... done
[16:04:43.532] result() for MulticoreFuture ...
[16:04:43.532] result() for MulticoreFuture ... done
[16:04:43.533] result() for MulticoreFuture ...
[16:04:43.533] result() for MulticoreFuture ... done
[16:04:43.533] result() for MulticoreFuture ...
[16:04:43.533] result() for MulticoreFuture ... done
[16:04:43.533] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:43.533] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:43.533] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:43.533]  length: 2 (resolved future 2)
[16:04:43.534] Future #3
[16:04:43.534] result() for MulticoreFuture ...
[16:04:43.535] result() for MulticoreFuture ...
[16:04:43.535] result() for MulticoreFuture ... done
[16:04:43.535] result() for MulticoreFuture ... done
[16:04:43.535] result() for MulticoreFuture ...
[16:04:43.548] result() for MulticoreFuture ... done
[16:04:43.548] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:43.549] - nx: 4
[16:04:43.549] - relay: TRUE
[16:04:43.549] - stdout: TRUE
[16:04:43.549] - signal: TRUE
[16:04:43.549] - resignal: FALSE
[16:04:43.549] - force: TRUE
[16:04:43.549] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:43.549] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:43.550]  - until=3
[16:04:43.550]  - relaying element #3
[16:04:43.550] result() for MulticoreFuture ...
[16:04:43.550] result() for MulticoreFuture ... done
[16:04:43.550] result() for MulticoreFuture ...
[16:04:43.550] result() for MulticoreFuture ... done
[16:04:43.550] result() for MulticoreFuture ...
[16:04:43.550] result() for MulticoreFuture ... done
[16:04:43.551] result() for MulticoreFuture ...
[16:04:43.551] result() for MulticoreFuture ... done
[16:04:43.551] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:43.551] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:43.551] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:43.551]  length: 1 (resolved future 3)
[16:04:43.552] Future #4
[16:04:43.552] result() for MulticoreFuture ...
[16:04:43.552] result() for MulticoreFuture ...
[16:04:43.553] result() for MulticoreFuture ... done
[16:04:43.553] result() for MulticoreFuture ... done
[16:04:43.553] result() for MulticoreFuture ...
[16:04:43.553] result() for MulticoreFuture ... done
[16:04:43.553] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:04:43.553] - nx: 4
[16:04:43.554] - relay: TRUE
[16:04:43.554] - stdout: TRUE
[16:04:43.554] - signal: TRUE
[16:04:43.554] - resignal: FALSE
[16:04:43.554] - force: TRUE
[16:04:43.554] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:43.554] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:43.555]  - until=4
[16:04:43.555]  - relaying element #4
[16:04:43.555] result() for MulticoreFuture ...
[16:04:43.555] result() for MulticoreFuture ... done
[16:04:43.555] result() for MulticoreFuture ...
[16:04:43.555] result() for MulticoreFuture ... done
[16:04:43.556] result() for MulticoreFuture ...
[16:04:43.556] result() for MulticoreFuture ... done
[16:04:43.556] result() for MulticoreFuture ...
[16:04:43.556] result() for MulticoreFuture ... done
[16:04:43.556] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.556] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:43.557] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:04:43.557]  length: 0 (resolved future 4)
[16:04:43.557] Relaying remaining futures
[16:04:43.557] signalConditionsASAP(NULL, pos=0) ...
[16:04:43.557] - nx: 4
[16:04:43.557] - relay: TRUE
[16:04:43.557] - stdout: TRUE
[16:04:43.557] - signal: TRUE
[16:04:43.557] - resignal: FALSE
[16:04:43.558] - force: TRUE
[16:04:43.558] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.558] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:43.558] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.558] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:43.558] signalConditionsASAP(NULL, pos=0) ... done
[16:04:43.558] resolve() on environment ... DONE
[16:04:43.558] result() for MulticoreFuture ...
[16:04:43.558] result() for MulticoreFuture ... done
[16:04:43.559] result() for MulticoreFuture ...
[16:04:43.559] result() for MulticoreFuture ... done
[16:04:43.559] result() for MulticoreFuture ...
[16:04:43.559] result() for MulticoreFuture ... done
[16:04:43.559] result() for MulticoreFuture ...
[16:04:43.559] result() for MulticoreFuture ... done
[16:04:43.559] result() for MulticoreFuture ...
[16:04:43.559] result() for MulticoreFuture ... done
[16:04:43.559] result() for MulticoreFuture ...
[16:04:43.560] result() for MulticoreFuture ... done
<environment: 0x55874fa418a0> 
Dimensions: c(2, 1, 3, 1)
[16:04:43.560] getGlobalsAndPackages() ...
[16:04:43.560] Searching for globals...
[16:04:43.561] 
[16:04:43.561] Searching for globals ... DONE
[16:04:43.561] - globals: [0] <none>
[16:04:43.561] getGlobalsAndPackages() ... DONE
[16:04:43.561] run() for ‘Future’ ...
[16:04:43.561] - state: ‘created’
[16:04:43.561] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.565] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.566] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.566]   - Field: ‘label’
[16:04:43.566]   - Field: ‘local’
[16:04:43.566]   - Field: ‘owner’
[16:04:43.566]   - Field: ‘envir’
[16:04:43.566]   - Field: ‘workers’
[16:04:43.566]   - Field: ‘packages’
[16:04:43.566]   - Field: ‘gc’
[16:04:43.567]   - Field: ‘job’
[16:04:43.567]   - Field: ‘conditions’
[16:04:43.567]   - Field: ‘expr’
[16:04:43.567]   - Field: ‘uuid’
[16:04:43.567]   - Field: ‘seed’
[16:04:43.567]   - Field: ‘version’
[16:04:43.567]   - Field: ‘result’
[16:04:43.567]   - Field: ‘asynchronous’
[16:04:43.567]   - Field: ‘calls’
[16:04:43.568]   - Field: ‘globals’
[16:04:43.568]   - Field: ‘stdout’
[16:04:43.568]   - Field: ‘earlySignal’
[16:04:43.568]   - Field: ‘lazy’
[16:04:43.568]   - Field: ‘state’
[16:04:43.568] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.568] - Launch lazy future ...
[16:04:43.568] Packages needed by the future expression (n = 0): <none>
[16:04:43.569] Packages needed by future strategies (n = 0): <none>
[16:04:43.569] {
[16:04:43.569]     {
[16:04:43.569]         {
[16:04:43.569]             ...future.startTime <- base::Sys.time()
[16:04:43.569]             {
[16:04:43.569]                 {
[16:04:43.569]                   {
[16:04:43.569]                     {
[16:04:43.569]                       base::local({
[16:04:43.569]                         has_future <- base::requireNamespace("future", 
[16:04:43.569]                           quietly = TRUE)
[16:04:43.569]                         if (has_future) {
[16:04:43.569]                           ns <- base::getNamespace("future")
[16:04:43.569]                           version <- ns[[".package"]][["version"]]
[16:04:43.569]                           if (is.null(version)) 
[16:04:43.569]                             version <- utils::packageVersion("future")
[16:04:43.569]                         }
[16:04:43.569]                         else {
[16:04:43.569]                           version <- NULL
[16:04:43.569]                         }
[16:04:43.569]                         if (!has_future || version < "1.8.0") {
[16:04:43.569]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.569]                             "", base::R.version$version.string), 
[16:04:43.569]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.569]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.569]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.569]                               "release", "version")], collapse = " "), 
[16:04:43.569]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.569]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.569]                             info)
[16:04:43.569]                           info <- base::paste(info, collapse = "; ")
[16:04:43.569]                           if (!has_future) {
[16:04:43.569]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.569]                               info)
[16:04:43.569]                           }
[16:04:43.569]                           else {
[16:04:43.569]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.569]                               info, version)
[16:04:43.569]                           }
[16:04:43.569]                           base::stop(msg)
[16:04:43.569]                         }
[16:04:43.569]                       })
[16:04:43.569]                     }
[16:04:43.569]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.569]                     base::options(mc.cores = 1L)
[16:04:43.569]                   }
[16:04:43.569]                   options(future.plan = NULL)
[16:04:43.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.569]                 }
[16:04:43.569]                 ...future.workdir <- getwd()
[16:04:43.569]             }
[16:04:43.569]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.569]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.569]         }
[16:04:43.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.569]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.569]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.569]             base::names(...future.oldOptions))
[16:04:43.569]     }
[16:04:43.569]     if (FALSE) {
[16:04:43.569]     }
[16:04:43.569]     else {
[16:04:43.569]         if (TRUE) {
[16:04:43.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.569]                 open = "w")
[16:04:43.569]         }
[16:04:43.569]         else {
[16:04:43.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.569]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.569]         }
[16:04:43.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.569]             base::sink(type = "output", split = FALSE)
[16:04:43.569]             base::close(...future.stdout)
[16:04:43.569]         }, add = TRUE)
[16:04:43.569]     }
[16:04:43.569]     ...future.frame <- base::sys.nframe()
[16:04:43.569]     ...future.conditions <- base::list()
[16:04:43.569]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.569]     if (FALSE) {
[16:04:43.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.569]     }
[16:04:43.569]     ...future.result <- base::tryCatch({
[16:04:43.569]         base::withCallingHandlers({
[16:04:43.569]             ...future.value <- base::withVisible(base::local({
[16:04:43.569]                 withCallingHandlers({
[16:04:43.569]                   2
[16:04:43.569]                 }, immediateCondition = function(cond) {
[16:04:43.569]                   save_rds <- function (object, pathname, ...) 
[16:04:43.569]                   {
[16:04:43.569]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.569]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.569]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.569]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.569]                         fi_tmp[["mtime"]])
[16:04:43.569]                     }
[16:04:43.569]                     tryCatch({
[16:04:43.569]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.569]                     }, error = function(ex) {
[16:04:43.569]                       msg <- conditionMessage(ex)
[16:04:43.569]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.569]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.569]                         fi_tmp[["mtime"]], msg)
[16:04:43.569]                       ex$message <- msg
[16:04:43.569]                       stop(ex)
[16:04:43.569]                     })
[16:04:43.569]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.569]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.569]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.569]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.569]                       fi <- file.info(pathname)
[16:04:43.569]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.569]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.569]                         fi[["size"]], fi[["mtime"]])
[16:04:43.569]                       stop(msg)
[16:04:43.569]                     }
[16:04:43.569]                     invisible(pathname)
[16:04:43.569]                   }
[16:04:43.569]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.569]                     rootPath = tempdir()) 
[16:04:43.569]                   {
[16:04:43.569]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.569]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.569]                       tmpdir = path, fileext = ".rds")
[16:04:43.569]                     save_rds(obj, file)
[16:04:43.569]                   }
[16:04:43.569]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.569]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.569]                   {
[16:04:43.569]                     inherits <- base::inherits
[16:04:43.569]                     invokeRestart <- base::invokeRestart
[16:04:43.569]                     is.null <- base::is.null
[16:04:43.569]                     muffled <- FALSE
[16:04:43.569]                     if (inherits(cond, "message")) {
[16:04:43.569]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.569]                       if (muffled) 
[16:04:43.569]                         invokeRestart("muffleMessage")
[16:04:43.569]                     }
[16:04:43.569]                     else if (inherits(cond, "warning")) {
[16:04:43.569]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.569]                       if (muffled) 
[16:04:43.569]                         invokeRestart("muffleWarning")
[16:04:43.569]                     }
[16:04:43.569]                     else if (inherits(cond, "condition")) {
[16:04:43.569]                       if (!is.null(pattern)) {
[16:04:43.569]                         computeRestarts <- base::computeRestarts
[16:04:43.569]                         grepl <- base::grepl
[16:04:43.569]                         restarts <- computeRestarts(cond)
[16:04:43.569]                         for (restart in restarts) {
[16:04:43.569]                           name <- restart$name
[16:04:43.569]                           if (is.null(name)) 
[16:04:43.569]                             next
[16:04:43.569]                           if (!grepl(pattern, name)) 
[16:04:43.569]                             next
[16:04:43.569]                           invokeRestart(restart)
[16:04:43.569]                           muffled <- TRUE
[16:04:43.569]                           break
[16:04:43.569]                         }
[16:04:43.569]                       }
[16:04:43.569]                     }
[16:04:43.569]                     invisible(muffled)
[16:04:43.569]                   }
[16:04:43.569]                   muffleCondition(cond)
[16:04:43.569]                 })
[16:04:43.569]             }))
[16:04:43.569]             future::FutureResult(value = ...future.value$value, 
[16:04:43.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.569]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.569]                     ...future.globalenv.names))
[16:04:43.569]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.569]         }, condition = base::local({
[16:04:43.569]             c <- base::c
[16:04:43.569]             inherits <- base::inherits
[16:04:43.569]             invokeRestart <- base::invokeRestart
[16:04:43.569]             length <- base::length
[16:04:43.569]             list <- base::list
[16:04:43.569]             seq.int <- base::seq.int
[16:04:43.569]             signalCondition <- base::signalCondition
[16:04:43.569]             sys.calls <- base::sys.calls
[16:04:43.569]             `[[` <- base::`[[`
[16:04:43.569]             `+` <- base::`+`
[16:04:43.569]             `<<-` <- base::`<<-`
[16:04:43.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.569]                   3L)]
[16:04:43.569]             }
[16:04:43.569]             function(cond) {
[16:04:43.569]                 is_error <- inherits(cond, "error")
[16:04:43.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.569]                   NULL)
[16:04:43.569]                 if (is_error) {
[16:04:43.569]                   sessionInformation <- function() {
[16:04:43.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.569]                       search = base::search(), system = base::Sys.info())
[16:04:43.569]                   }
[16:04:43.569]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.569]                     cond$call), session = sessionInformation(), 
[16:04:43.569]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.569]                   signalCondition(cond)
[16:04:43.569]                 }
[16:04:43.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.569]                 "immediateCondition"))) {
[16:04:43.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.569]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.569]                   if (TRUE && !signal) {
[16:04:43.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.569]                     {
[16:04:43.569]                       inherits <- base::inherits
[16:04:43.569]                       invokeRestart <- base::invokeRestart
[16:04:43.569]                       is.null <- base::is.null
[16:04:43.569]                       muffled <- FALSE
[16:04:43.569]                       if (inherits(cond, "message")) {
[16:04:43.569]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.569]                         if (muffled) 
[16:04:43.569]                           invokeRestart("muffleMessage")
[16:04:43.569]                       }
[16:04:43.569]                       else if (inherits(cond, "warning")) {
[16:04:43.569]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.569]                         if (muffled) 
[16:04:43.569]                           invokeRestart("muffleWarning")
[16:04:43.569]                       }
[16:04:43.569]                       else if (inherits(cond, "condition")) {
[16:04:43.569]                         if (!is.null(pattern)) {
[16:04:43.569]                           computeRestarts <- base::computeRestarts
[16:04:43.569]                           grepl <- base::grepl
[16:04:43.569]                           restarts <- computeRestarts(cond)
[16:04:43.569]                           for (restart in restarts) {
[16:04:43.569]                             name <- restart$name
[16:04:43.569]                             if (is.null(name)) 
[16:04:43.569]                               next
[16:04:43.569]                             if (!grepl(pattern, name)) 
[16:04:43.569]                               next
[16:04:43.569]                             invokeRestart(restart)
[16:04:43.569]                             muffled <- TRUE
[16:04:43.569]                             break
[16:04:43.569]                           }
[16:04:43.569]                         }
[16:04:43.569]                       }
[16:04:43.569]                       invisible(muffled)
[16:04:43.569]                     }
[16:04:43.569]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.569]                   }
[16:04:43.569]                 }
[16:04:43.569]                 else {
[16:04:43.569]                   if (TRUE) {
[16:04:43.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.569]                     {
[16:04:43.569]                       inherits <- base::inherits
[16:04:43.569]                       invokeRestart <- base::invokeRestart
[16:04:43.569]                       is.null <- base::is.null
[16:04:43.569]                       muffled <- FALSE
[16:04:43.569]                       if (inherits(cond, "message")) {
[16:04:43.569]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.569]                         if (muffled) 
[16:04:43.569]                           invokeRestart("muffleMessage")
[16:04:43.569]                       }
[16:04:43.569]                       else if (inherits(cond, "warning")) {
[16:04:43.569]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.569]                         if (muffled) 
[16:04:43.569]                           invokeRestart("muffleWarning")
[16:04:43.569]                       }
[16:04:43.569]                       else if (inherits(cond, "condition")) {
[16:04:43.569]                         if (!is.null(pattern)) {
[16:04:43.569]                           computeRestarts <- base::computeRestarts
[16:04:43.569]                           grepl <- base::grepl
[16:04:43.569]                           restarts <- computeRestarts(cond)
[16:04:43.569]                           for (restart in restarts) {
[16:04:43.569]                             name <- restart$name
[16:04:43.569]                             if (is.null(name)) 
[16:04:43.569]                               next
[16:04:43.569]                             if (!grepl(pattern, name)) 
[16:04:43.569]                               next
[16:04:43.569]                             invokeRestart(restart)
[16:04:43.569]                             muffled <- TRUE
[16:04:43.569]                             break
[16:04:43.569]                           }
[16:04:43.569]                         }
[16:04:43.569]                       }
[16:04:43.569]                       invisible(muffled)
[16:04:43.569]                     }
[16:04:43.569]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.569]                   }
[16:04:43.569]                 }
[16:04:43.569]             }
[16:04:43.569]         }))
[16:04:43.569]     }, error = function(ex) {
[16:04:43.569]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.569]                 ...future.rng), started = ...future.startTime, 
[16:04:43.569]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.569]             version = "1.8"), class = "FutureResult")
[16:04:43.569]     }, finally = {
[16:04:43.569]         if (!identical(...future.workdir, getwd())) 
[16:04:43.569]             setwd(...future.workdir)
[16:04:43.569]         {
[16:04:43.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.569]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.569]             }
[16:04:43.569]             base::options(...future.oldOptions)
[16:04:43.569]             if (.Platform$OS.type == "windows") {
[16:04:43.569]                 old_names <- names(...future.oldEnvVars)
[16:04:43.569]                 envs <- base::Sys.getenv()
[16:04:43.569]                 names <- names(envs)
[16:04:43.569]                 common <- intersect(names, old_names)
[16:04:43.569]                 added <- setdiff(names, old_names)
[16:04:43.569]                 removed <- setdiff(old_names, names)
[16:04:43.569]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.569]                   envs[common]]
[16:04:43.569]                 NAMES <- toupper(changed)
[16:04:43.569]                 args <- list()
[16:04:43.569]                 for (kk in seq_along(NAMES)) {
[16:04:43.569]                   name <- changed[[kk]]
[16:04:43.569]                   NAME <- NAMES[[kk]]
[16:04:43.569]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.569]                     next
[16:04:43.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.569]                 }
[16:04:43.569]                 NAMES <- toupper(added)
[16:04:43.569]                 for (kk in seq_along(NAMES)) {
[16:04:43.569]                   name <- added[[kk]]
[16:04:43.569]                   NAME <- NAMES[[kk]]
[16:04:43.569]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.569]                     next
[16:04:43.569]                   args[[name]] <- ""
[16:04:43.569]                 }
[16:04:43.569]                 NAMES <- toupper(removed)
[16:04:43.569]                 for (kk in seq_along(NAMES)) {
[16:04:43.569]                   name <- removed[[kk]]
[16:04:43.569]                   NAME <- NAMES[[kk]]
[16:04:43.569]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.569]                     next
[16:04:43.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.569]                 }
[16:04:43.569]                 if (length(args) > 0) 
[16:04:43.569]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.569]             }
[16:04:43.569]             else {
[16:04:43.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.569]             }
[16:04:43.569]             {
[16:04:43.569]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.569]                   0L) {
[16:04:43.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.569]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.569]                   base::options(opts)
[16:04:43.569]                 }
[16:04:43.569]                 {
[16:04:43.569]                   {
[16:04:43.569]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.569]                     NULL
[16:04:43.569]                   }
[16:04:43.569]                   options(future.plan = NULL)
[16:04:43.569]                   if (is.na(NA_character_)) 
[16:04:43.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.569]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.569]                     envir = parent.frame()) 
[16:04:43.569]                   {
[16:04:43.569]                     default_workers <- missing(workers)
[16:04:43.569]                     if (is.function(workers)) 
[16:04:43.569]                       workers <- workers()
[16:04:43.569]                     workers <- structure(as.integer(workers), 
[16:04:43.569]                       class = class(workers))
[16:04:43.569]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.569]                       1L)
[16:04:43.569]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.569]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.569]                       if (default_workers) 
[16:04:43.569]                         supportsMulticore(warn = TRUE)
[16:04:43.569]                       return(sequential(..., envir = envir))
[16:04:43.569]                     }
[16:04:43.569]                     oopts <- options(mc.cores = workers)
[16:04:43.569]                     on.exit(options(oopts))
[16:04:43.569]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.569]                       envir = envir)
[16:04:43.569]                     if (!future$lazy) 
[16:04:43.569]                       future <- run(future)
[16:04:43.569]                     invisible(future)
[16:04:43.569]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.569]                 }
[16:04:43.569]             }
[16:04:43.569]         }
[16:04:43.569]     })
[16:04:43.569]     if (TRUE) {
[16:04:43.569]         base::sink(type = "output", split = FALSE)
[16:04:43.569]         if (TRUE) {
[16:04:43.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.569]         }
[16:04:43.569]         else {
[16:04:43.569]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.569]         }
[16:04:43.569]         base::close(...future.stdout)
[16:04:43.569]         ...future.stdout <- NULL
[16:04:43.569]     }
[16:04:43.569]     ...future.result$conditions <- ...future.conditions
[16:04:43.569]     ...future.result$finished <- base::Sys.time()
[16:04:43.569]     ...future.result
[16:04:43.569] }
[16:04:43.572] requestCore(): workers = 2
[16:04:43.574] MulticoreFuture started
[16:04:43.574] - Launch lazy future ... done
[16:04:43.574] run() for ‘MulticoreFuture’ ... done
[16:04:43.575] getGlobalsAndPackages() ...
[16:04:43.575] Searching for globals...
[16:04:43.575] plan(): Setting new future strategy stack:
[16:04:43.575] 
[16:04:43.576] Searching for globals ... DONE
[16:04:43.575] List of future strategies:
[16:04:43.575] 1. sequential:
[16:04:43.575]    - args: function (..., envir = parent.frame())
[16:04:43.575]    - tweaked: FALSE
[16:04:43.575]    - call: NULL
[16:04:43.576] - globals: [0] <none>
[16:04:43.576] plan(): nbrOfWorkers() = 1
[16:04:43.576] getGlobalsAndPackages() ... DONE
[16:04:43.576] run() for ‘Future’ ...
[16:04:43.577] - state: ‘created’
[16:04:43.577] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.578] plan(): Setting new future strategy stack:
[16:04:43.578] List of future strategies:
[16:04:43.578] 1. multicore:
[16:04:43.578]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.578]    - tweaked: FALSE
[16:04:43.578]    - call: plan(strategy)
[16:04:43.582] plan(): nbrOfWorkers() = 2
[16:04:43.582] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.582] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.583]   - Field: ‘label’
[16:04:43.583]   - Field: ‘local’
[16:04:43.583]   - Field: ‘owner’
[16:04:43.583]   - Field: ‘envir’
[16:04:43.583]   - Field: ‘workers’
[16:04:43.583]   - Field: ‘packages’
[16:04:43.584]   - Field: ‘gc’
[16:04:43.584]   - Field: ‘job’
[16:04:43.584]   - Field: ‘conditions’
[16:04:43.584]   - Field: ‘expr’
[16:04:43.584]   - Field: ‘uuid’
[16:04:43.584]   - Field: ‘seed’
[16:04:43.584]   - Field: ‘version’
[16:04:43.585]   - Field: ‘result’
[16:04:43.585]   - Field: ‘asynchronous’
[16:04:43.585]   - Field: ‘calls’
[16:04:43.585]   - Field: ‘globals’
[16:04:43.585]   - Field: ‘stdout’
[16:04:43.585]   - Field: ‘earlySignal’
[16:04:43.585]   - Field: ‘lazy’
[16:04:43.586]   - Field: ‘state’
[16:04:43.586] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.586] - Launch lazy future ...
[16:04:43.586] Packages needed by the future expression (n = 0): <none>
[16:04:43.587] Packages needed by future strategies (n = 0): <none>
[16:04:43.587] {
[16:04:43.587]     {
[16:04:43.587]         {
[16:04:43.587]             ...future.startTime <- base::Sys.time()
[16:04:43.587]             {
[16:04:43.587]                 {
[16:04:43.587]                   {
[16:04:43.587]                     {
[16:04:43.587]                       base::local({
[16:04:43.587]                         has_future <- base::requireNamespace("future", 
[16:04:43.587]                           quietly = TRUE)
[16:04:43.587]                         if (has_future) {
[16:04:43.587]                           ns <- base::getNamespace("future")
[16:04:43.587]                           version <- ns[[".package"]][["version"]]
[16:04:43.587]                           if (is.null(version)) 
[16:04:43.587]                             version <- utils::packageVersion("future")
[16:04:43.587]                         }
[16:04:43.587]                         else {
[16:04:43.587]                           version <- NULL
[16:04:43.587]                         }
[16:04:43.587]                         if (!has_future || version < "1.8.0") {
[16:04:43.587]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.587]                             "", base::R.version$version.string), 
[16:04:43.587]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.587]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.587]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.587]                               "release", "version")], collapse = " "), 
[16:04:43.587]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.587]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.587]                             info)
[16:04:43.587]                           info <- base::paste(info, collapse = "; ")
[16:04:43.587]                           if (!has_future) {
[16:04:43.587]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.587]                               info)
[16:04:43.587]                           }
[16:04:43.587]                           else {
[16:04:43.587]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.587]                               info, version)
[16:04:43.587]                           }
[16:04:43.587]                           base::stop(msg)
[16:04:43.587]                         }
[16:04:43.587]                       })
[16:04:43.587]                     }
[16:04:43.587]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.587]                     base::options(mc.cores = 1L)
[16:04:43.587]                   }
[16:04:43.587]                   options(future.plan = NULL)
[16:04:43.587]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.587]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.587]                 }
[16:04:43.587]                 ...future.workdir <- getwd()
[16:04:43.587]             }
[16:04:43.587]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.587]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.587]         }
[16:04:43.587]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.587]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.587]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.587]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.587]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.587]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.587]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.587]             base::names(...future.oldOptions))
[16:04:43.587]     }
[16:04:43.587]     if (FALSE) {
[16:04:43.587]     }
[16:04:43.587]     else {
[16:04:43.587]         if (TRUE) {
[16:04:43.587]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.587]                 open = "w")
[16:04:43.587]         }
[16:04:43.587]         else {
[16:04:43.587]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.587]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.587]         }
[16:04:43.587]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.587]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.587]             base::sink(type = "output", split = FALSE)
[16:04:43.587]             base::close(...future.stdout)
[16:04:43.587]         }, add = TRUE)
[16:04:43.587]     }
[16:04:43.587]     ...future.frame <- base::sys.nframe()
[16:04:43.587]     ...future.conditions <- base::list()
[16:04:43.587]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.587]     if (FALSE) {
[16:04:43.587]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.587]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.587]     }
[16:04:43.587]     ...future.result <- base::tryCatch({
[16:04:43.587]         base::withCallingHandlers({
[16:04:43.587]             ...future.value <- base::withVisible(base::local({
[16:04:43.587]                 withCallingHandlers({
[16:04:43.587]                   NULL
[16:04:43.587]                 }, immediateCondition = function(cond) {
[16:04:43.587]                   save_rds <- function (object, pathname, ...) 
[16:04:43.587]                   {
[16:04:43.587]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.587]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.587]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.587]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.587]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.587]                         fi_tmp[["mtime"]])
[16:04:43.587]                     }
[16:04:43.587]                     tryCatch({
[16:04:43.587]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.587]                     }, error = function(ex) {
[16:04:43.587]                       msg <- conditionMessage(ex)
[16:04:43.587]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.587]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.587]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.587]                         fi_tmp[["mtime"]], msg)
[16:04:43.587]                       ex$message <- msg
[16:04:43.587]                       stop(ex)
[16:04:43.587]                     })
[16:04:43.587]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.587]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.587]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.587]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.587]                       fi <- file.info(pathname)
[16:04:43.587]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.587]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.587]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.587]                         fi[["size"]], fi[["mtime"]])
[16:04:43.587]                       stop(msg)
[16:04:43.587]                     }
[16:04:43.587]                     invisible(pathname)
[16:04:43.587]                   }
[16:04:43.587]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.587]                     rootPath = tempdir()) 
[16:04:43.587]                   {
[16:04:43.587]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.587]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.587]                       tmpdir = path, fileext = ".rds")
[16:04:43.587]                     save_rds(obj, file)
[16:04:43.587]                   }
[16:04:43.587]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.587]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.587]                   {
[16:04:43.587]                     inherits <- base::inherits
[16:04:43.587]                     invokeRestart <- base::invokeRestart
[16:04:43.587]                     is.null <- base::is.null
[16:04:43.587]                     muffled <- FALSE
[16:04:43.587]                     if (inherits(cond, "message")) {
[16:04:43.587]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.587]                       if (muffled) 
[16:04:43.587]                         invokeRestart("muffleMessage")
[16:04:43.587]                     }
[16:04:43.587]                     else if (inherits(cond, "warning")) {
[16:04:43.587]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.587]                       if (muffled) 
[16:04:43.587]                         invokeRestart("muffleWarning")
[16:04:43.587]                     }
[16:04:43.587]                     else if (inherits(cond, "condition")) {
[16:04:43.587]                       if (!is.null(pattern)) {
[16:04:43.587]                         computeRestarts <- base::computeRestarts
[16:04:43.587]                         grepl <- base::grepl
[16:04:43.587]                         restarts <- computeRestarts(cond)
[16:04:43.587]                         for (restart in restarts) {
[16:04:43.587]                           name <- restart$name
[16:04:43.587]                           if (is.null(name)) 
[16:04:43.587]                             next
[16:04:43.587]                           if (!grepl(pattern, name)) 
[16:04:43.587]                             next
[16:04:43.587]                           invokeRestart(restart)
[16:04:43.587]                           muffled <- TRUE
[16:04:43.587]                           break
[16:04:43.587]                         }
[16:04:43.587]                       }
[16:04:43.587]                     }
[16:04:43.587]                     invisible(muffled)
[16:04:43.587]                   }
[16:04:43.587]                   muffleCondition(cond)
[16:04:43.587]                 })
[16:04:43.587]             }))
[16:04:43.587]             future::FutureResult(value = ...future.value$value, 
[16:04:43.587]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.587]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.587]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.587]                     ...future.globalenv.names))
[16:04:43.587]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.587]         }, condition = base::local({
[16:04:43.587]             c <- base::c
[16:04:43.587]             inherits <- base::inherits
[16:04:43.587]             invokeRestart <- base::invokeRestart
[16:04:43.587]             length <- base::length
[16:04:43.587]             list <- base::list
[16:04:43.587]             seq.int <- base::seq.int
[16:04:43.587]             signalCondition <- base::signalCondition
[16:04:43.587]             sys.calls <- base::sys.calls
[16:04:43.587]             `[[` <- base::`[[`
[16:04:43.587]             `+` <- base::`+`
[16:04:43.587]             `<<-` <- base::`<<-`
[16:04:43.587]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.587]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.587]                   3L)]
[16:04:43.587]             }
[16:04:43.587]             function(cond) {
[16:04:43.587]                 is_error <- inherits(cond, "error")
[16:04:43.587]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.587]                   NULL)
[16:04:43.587]                 if (is_error) {
[16:04:43.587]                   sessionInformation <- function() {
[16:04:43.587]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.587]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.587]                       search = base::search(), system = base::Sys.info())
[16:04:43.587]                   }
[16:04:43.587]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.587]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.587]                     cond$call), session = sessionInformation(), 
[16:04:43.587]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.587]                   signalCondition(cond)
[16:04:43.587]                 }
[16:04:43.587]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.587]                 "immediateCondition"))) {
[16:04:43.587]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.587]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.587]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.587]                   if (TRUE && !signal) {
[16:04:43.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.587]                     {
[16:04:43.587]                       inherits <- base::inherits
[16:04:43.587]                       invokeRestart <- base::invokeRestart
[16:04:43.587]                       is.null <- base::is.null
[16:04:43.587]                       muffled <- FALSE
[16:04:43.587]                       if (inherits(cond, "message")) {
[16:04:43.587]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.587]                         if (muffled) 
[16:04:43.587]                           invokeRestart("muffleMessage")
[16:04:43.587]                       }
[16:04:43.587]                       else if (inherits(cond, "warning")) {
[16:04:43.587]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.587]                         if (muffled) 
[16:04:43.587]                           invokeRestart("muffleWarning")
[16:04:43.587]                       }
[16:04:43.587]                       else if (inherits(cond, "condition")) {
[16:04:43.587]                         if (!is.null(pattern)) {
[16:04:43.587]                           computeRestarts <- base::computeRestarts
[16:04:43.587]                           grepl <- base::grepl
[16:04:43.587]                           restarts <- computeRestarts(cond)
[16:04:43.587]                           for (restart in restarts) {
[16:04:43.587]                             name <- restart$name
[16:04:43.587]                             if (is.null(name)) 
[16:04:43.587]                               next
[16:04:43.587]                             if (!grepl(pattern, name)) 
[16:04:43.587]                               next
[16:04:43.587]                             invokeRestart(restart)
[16:04:43.587]                             muffled <- TRUE
[16:04:43.587]                             break
[16:04:43.587]                           }
[16:04:43.587]                         }
[16:04:43.587]                       }
[16:04:43.587]                       invisible(muffled)
[16:04:43.587]                     }
[16:04:43.587]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.587]                   }
[16:04:43.587]                 }
[16:04:43.587]                 else {
[16:04:43.587]                   if (TRUE) {
[16:04:43.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.587]                     {
[16:04:43.587]                       inherits <- base::inherits
[16:04:43.587]                       invokeRestart <- base::invokeRestart
[16:04:43.587]                       is.null <- base::is.null
[16:04:43.587]                       muffled <- FALSE
[16:04:43.587]                       if (inherits(cond, "message")) {
[16:04:43.587]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.587]                         if (muffled) 
[16:04:43.587]                           invokeRestart("muffleMessage")
[16:04:43.587]                       }
[16:04:43.587]                       else if (inherits(cond, "warning")) {
[16:04:43.587]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.587]                         if (muffled) 
[16:04:43.587]                           invokeRestart("muffleWarning")
[16:04:43.587]                       }
[16:04:43.587]                       else if (inherits(cond, "condition")) {
[16:04:43.587]                         if (!is.null(pattern)) {
[16:04:43.587]                           computeRestarts <- base::computeRestarts
[16:04:43.587]                           grepl <- base::grepl
[16:04:43.587]                           restarts <- computeRestarts(cond)
[16:04:43.587]                           for (restart in restarts) {
[16:04:43.587]                             name <- restart$name
[16:04:43.587]                             if (is.null(name)) 
[16:04:43.587]                               next
[16:04:43.587]                             if (!grepl(pattern, name)) 
[16:04:43.587]                               next
[16:04:43.587]                             invokeRestart(restart)
[16:04:43.587]                             muffled <- TRUE
[16:04:43.587]                             break
[16:04:43.587]                           }
[16:04:43.587]                         }
[16:04:43.587]                       }
[16:04:43.587]                       invisible(muffled)
[16:04:43.587]                     }
[16:04:43.587]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.587]                   }
[16:04:43.587]                 }
[16:04:43.587]             }
[16:04:43.587]         }))
[16:04:43.587]     }, error = function(ex) {
[16:04:43.587]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.587]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.587]                 ...future.rng), started = ...future.startTime, 
[16:04:43.587]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.587]             version = "1.8"), class = "FutureResult")
[16:04:43.587]     }, finally = {
[16:04:43.587]         if (!identical(...future.workdir, getwd())) 
[16:04:43.587]             setwd(...future.workdir)
[16:04:43.587]         {
[16:04:43.587]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.587]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.587]             }
[16:04:43.587]             base::options(...future.oldOptions)
[16:04:43.587]             if (.Platform$OS.type == "windows") {
[16:04:43.587]                 old_names <- names(...future.oldEnvVars)
[16:04:43.587]                 envs <- base::Sys.getenv()
[16:04:43.587]                 names <- names(envs)
[16:04:43.587]                 common <- intersect(names, old_names)
[16:04:43.587]                 added <- setdiff(names, old_names)
[16:04:43.587]                 removed <- setdiff(old_names, names)
[16:04:43.587]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.587]                   envs[common]]
[16:04:43.587]                 NAMES <- toupper(changed)
[16:04:43.587]                 args <- list()
[16:04:43.587]                 for (kk in seq_along(NAMES)) {
[16:04:43.587]                   name <- changed[[kk]]
[16:04:43.587]                   NAME <- NAMES[[kk]]
[16:04:43.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.587]                     next
[16:04:43.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.587]                 }
[16:04:43.587]                 NAMES <- toupper(added)
[16:04:43.587]                 for (kk in seq_along(NAMES)) {
[16:04:43.587]                   name <- added[[kk]]
[16:04:43.587]                   NAME <- NAMES[[kk]]
[16:04:43.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.587]                     next
[16:04:43.587]                   args[[name]] <- ""
[16:04:43.587]                 }
[16:04:43.587]                 NAMES <- toupper(removed)
[16:04:43.587]                 for (kk in seq_along(NAMES)) {
[16:04:43.587]                   name <- removed[[kk]]
[16:04:43.587]                   NAME <- NAMES[[kk]]
[16:04:43.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.587]                     next
[16:04:43.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.587]                 }
[16:04:43.587]                 if (length(args) > 0) 
[16:04:43.587]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.587]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.587]             }
[16:04:43.587]             else {
[16:04:43.587]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.587]             }
[16:04:43.587]             {
[16:04:43.587]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.587]                   0L) {
[16:04:43.587]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.587]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.587]                   base::options(opts)
[16:04:43.587]                 }
[16:04:43.587]                 {
[16:04:43.587]                   {
[16:04:43.587]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.587]                     NULL
[16:04:43.587]                   }
[16:04:43.587]                   options(future.plan = NULL)
[16:04:43.587]                   if (is.na(NA_character_)) 
[16:04:43.587]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.587]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.587]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.587]                     envir = parent.frame()) 
[16:04:43.587]                   {
[16:04:43.587]                     default_workers <- missing(workers)
[16:04:43.587]                     if (is.function(workers)) 
[16:04:43.587]                       workers <- workers()
[16:04:43.587]                     workers <- structure(as.integer(workers), 
[16:04:43.587]                       class = class(workers))
[16:04:43.587]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.587]                       1L)
[16:04:43.587]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.587]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.587]                       if (default_workers) 
[16:04:43.587]                         supportsMulticore(warn = TRUE)
[16:04:43.587]                       return(sequential(..., envir = envir))
[16:04:43.587]                     }
[16:04:43.587]                     oopts <- options(mc.cores = workers)
[16:04:43.587]                     on.exit(options(oopts))
[16:04:43.587]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.587]                       envir = envir)
[16:04:43.587]                     if (!future$lazy) 
[16:04:43.587]                       future <- run(future)
[16:04:43.587]                     invisible(future)
[16:04:43.587]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.587]                 }
[16:04:43.587]             }
[16:04:43.587]         }
[16:04:43.587]     })
[16:04:43.587]     if (TRUE) {
[16:04:43.587]         base::sink(type = "output", split = FALSE)
[16:04:43.587]         if (TRUE) {
[16:04:43.587]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.587]         }
[16:04:43.587]         else {
[16:04:43.587]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.587]         }
[16:04:43.587]         base::close(...future.stdout)
[16:04:43.587]         ...future.stdout <- NULL
[16:04:43.587]     }
[16:04:43.587]     ...future.result$conditions <- ...future.conditions
[16:04:43.587]     ...future.result$finished <- base::Sys.time()
[16:04:43.587]     ...future.result
[16:04:43.587] }
[16:04:43.592] requestCore(): workers = 2
[16:04:43.594] MulticoreFuture started
[16:04:43.595] - Launch lazy future ... done
[16:04:43.595] run() for ‘MulticoreFuture’ ... done
[16:04:43.596] plan(): Setting new future strategy stack:
[16:04:43.596] getGlobalsAndPackages() ...
[16:04:43.596] Searching for globals...
[16:04:43.596] List of future strategies:
[16:04:43.596] 1. sequential:
[16:04:43.596]    - args: function (..., envir = parent.frame())
[16:04:43.596]    - tweaked: FALSE
[16:04:43.596]    - call: NULL
[16:04:43.597] plan(): nbrOfWorkers() = 1
[16:04:43.598] - globals found: [1] ‘{’
[16:04:43.598] Searching for globals ... DONE
[16:04:43.598] Resolving globals: FALSE
[16:04:43.599] 
[16:04:43.599] plan(): Setting new future strategy stack:
[16:04:43.599] 
[16:04:43.599] getGlobalsAndPackages() ... DONE
[16:04:43.599] List of future strategies:
[16:04:43.599] 1. multicore:
[16:04:43.599]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.599]    - tweaked: FALSE
[16:04:43.599]    - call: plan(strategy)
[16:04:43.600] run() for ‘Future’ ...
[16:04:43.600] - state: ‘created’
[16:04:43.600] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:43.604] plan(): nbrOfWorkers() = 2
[16:04:43.605] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:43.605] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:43.606]   - Field: ‘label’
[16:04:43.606]   - Field: ‘local’
[16:04:43.606]   - Field: ‘owner’
[16:04:43.606]   - Field: ‘envir’
[16:04:43.606]   - Field: ‘workers’
[16:04:43.606]   - Field: ‘packages’
[16:04:43.607]   - Field: ‘gc’
[16:04:43.607]   - Field: ‘job’
[16:04:43.607]   - Field: ‘conditions’
[16:04:43.607]   - Field: ‘expr’
[16:04:43.607]   - Field: ‘uuid’
[16:04:43.607]   - Field: ‘seed’
[16:04:43.608]   - Field: ‘version’
[16:04:43.608]   - Field: ‘result’
[16:04:43.608]   - Field: ‘asynchronous’
[16:04:43.608]   - Field: ‘calls’
[16:04:43.608]   - Field: ‘globals’
[16:04:43.608]   - Field: ‘stdout’
[16:04:43.608]   - Field: ‘earlySignal’
[16:04:43.609]   - Field: ‘lazy’
[16:04:43.609]   - Field: ‘state’
[16:04:43.609] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:43.609] - Launch lazy future ...
[16:04:43.609] Packages needed by the future expression (n = 0): <none>
[16:04:43.610] Packages needed by future strategies (n = 0): <none>
[16:04:43.610] {
[16:04:43.610]     {
[16:04:43.610]         {
[16:04:43.610]             ...future.startTime <- base::Sys.time()
[16:04:43.610]             {
[16:04:43.610]                 {
[16:04:43.610]                   {
[16:04:43.610]                     {
[16:04:43.610]                       base::local({
[16:04:43.610]                         has_future <- base::requireNamespace("future", 
[16:04:43.610]                           quietly = TRUE)
[16:04:43.610]                         if (has_future) {
[16:04:43.610]                           ns <- base::getNamespace("future")
[16:04:43.610]                           version <- ns[[".package"]][["version"]]
[16:04:43.610]                           if (is.null(version)) 
[16:04:43.610]                             version <- utils::packageVersion("future")
[16:04:43.610]                         }
[16:04:43.610]                         else {
[16:04:43.610]                           version <- NULL
[16:04:43.610]                         }
[16:04:43.610]                         if (!has_future || version < "1.8.0") {
[16:04:43.610]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.610]                             "", base::R.version$version.string), 
[16:04:43.610]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.610]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.610]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.610]                               "release", "version")], collapse = " "), 
[16:04:43.610]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.610]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.610]                             info)
[16:04:43.610]                           info <- base::paste(info, collapse = "; ")
[16:04:43.610]                           if (!has_future) {
[16:04:43.610]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.610]                               info)
[16:04:43.610]                           }
[16:04:43.610]                           else {
[16:04:43.610]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.610]                               info, version)
[16:04:43.610]                           }
[16:04:43.610]                           base::stop(msg)
[16:04:43.610]                         }
[16:04:43.610]                       })
[16:04:43.610]                     }
[16:04:43.610]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.610]                     base::options(mc.cores = 1L)
[16:04:43.610]                   }
[16:04:43.610]                   options(future.plan = NULL)
[16:04:43.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.610]                 }
[16:04:43.610]                 ...future.workdir <- getwd()
[16:04:43.610]             }
[16:04:43.610]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.610]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.610]         }
[16:04:43.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.610]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.610]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.610]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.610]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.610]             base::names(...future.oldOptions))
[16:04:43.610]     }
[16:04:43.610]     if (FALSE) {
[16:04:43.610]     }
[16:04:43.610]     else {
[16:04:43.610]         if (TRUE) {
[16:04:43.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.610]                 open = "w")
[16:04:43.610]         }
[16:04:43.610]         else {
[16:04:43.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.610]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.610]         }
[16:04:43.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.610]             base::sink(type = "output", split = FALSE)
[16:04:43.610]             base::close(...future.stdout)
[16:04:43.610]         }, add = TRUE)
[16:04:43.610]     }
[16:04:43.610]     ...future.frame <- base::sys.nframe()
[16:04:43.610]     ...future.conditions <- base::list()
[16:04:43.610]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.610]     if (FALSE) {
[16:04:43.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.610]     }
[16:04:43.610]     ...future.result <- base::tryCatch({
[16:04:43.610]         base::withCallingHandlers({
[16:04:43.610]             ...future.value <- base::withVisible(base::local({
[16:04:43.610]                 withCallingHandlers({
[16:04:43.610]                   {
[16:04:43.610]                     4
[16:04:43.610]                   }
[16:04:43.610]                 }, immediateCondition = function(cond) {
[16:04:43.610]                   save_rds <- function (object, pathname, ...) 
[16:04:43.610]                   {
[16:04:43.610]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:43.610]                     if (file_test("-f", pathname_tmp)) {
[16:04:43.610]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.610]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:43.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.610]                         fi_tmp[["mtime"]])
[16:04:43.610]                     }
[16:04:43.610]                     tryCatch({
[16:04:43.610]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:43.610]                     }, error = function(ex) {
[16:04:43.610]                       msg <- conditionMessage(ex)
[16:04:43.610]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.610]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:43.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.610]                         fi_tmp[["mtime"]], msg)
[16:04:43.610]                       ex$message <- msg
[16:04:43.610]                       stop(ex)
[16:04:43.610]                     })
[16:04:43.610]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:43.610]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:43.610]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:43.610]                       fi_tmp <- file.info(pathname_tmp)
[16:04:43.610]                       fi <- file.info(pathname)
[16:04:43.610]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:43.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:43.610]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:43.610]                         fi[["size"]], fi[["mtime"]])
[16:04:43.610]                       stop(msg)
[16:04:43.610]                     }
[16:04:43.610]                     invisible(pathname)
[16:04:43.610]                   }
[16:04:43.610]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:43.610]                     rootPath = tempdir()) 
[16:04:43.610]                   {
[16:04:43.610]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:43.610]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:43.610]                       tmpdir = path, fileext = ".rds")
[16:04:43.610]                     save_rds(obj, file)
[16:04:43.610]                   }
[16:04:43.610]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:43.610]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.610]                   {
[16:04:43.610]                     inherits <- base::inherits
[16:04:43.610]                     invokeRestart <- base::invokeRestart
[16:04:43.610]                     is.null <- base::is.null
[16:04:43.610]                     muffled <- FALSE
[16:04:43.610]                     if (inherits(cond, "message")) {
[16:04:43.610]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.610]                       if (muffled) 
[16:04:43.610]                         invokeRestart("muffleMessage")
[16:04:43.610]                     }
[16:04:43.610]                     else if (inherits(cond, "warning")) {
[16:04:43.610]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.610]                       if (muffled) 
[16:04:43.610]                         invokeRestart("muffleWarning")
[16:04:43.610]                     }
[16:04:43.610]                     else if (inherits(cond, "condition")) {
[16:04:43.610]                       if (!is.null(pattern)) {
[16:04:43.610]                         computeRestarts <- base::computeRestarts
[16:04:43.610]                         grepl <- base::grepl
[16:04:43.610]                         restarts <- computeRestarts(cond)
[16:04:43.610]                         for (restart in restarts) {
[16:04:43.610]                           name <- restart$name
[16:04:43.610]                           if (is.null(name)) 
[16:04:43.610]                             next
[16:04:43.610]                           if (!grepl(pattern, name)) 
[16:04:43.610]                             next
[16:04:43.610]                           invokeRestart(restart)
[16:04:43.610]                           muffled <- TRUE
[16:04:43.610]                           break
[16:04:43.610]                         }
[16:04:43.610]                       }
[16:04:43.610]                     }
[16:04:43.610]                     invisible(muffled)
[16:04:43.610]                   }
[16:04:43.610]                   muffleCondition(cond)
[16:04:43.610]                 })
[16:04:43.610]             }))
[16:04:43.610]             future::FutureResult(value = ...future.value$value, 
[16:04:43.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.610]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.610]                     ...future.globalenv.names))
[16:04:43.610]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.610]         }, condition = base::local({
[16:04:43.610]             c <- base::c
[16:04:43.610]             inherits <- base::inherits
[16:04:43.610]             invokeRestart <- base::invokeRestart
[16:04:43.610]             length <- base::length
[16:04:43.610]             list <- base::list
[16:04:43.610]             seq.int <- base::seq.int
[16:04:43.610]             signalCondition <- base::signalCondition
[16:04:43.610]             sys.calls <- base::sys.calls
[16:04:43.610]             `[[` <- base::`[[`
[16:04:43.610]             `+` <- base::`+`
[16:04:43.610]             `<<-` <- base::`<<-`
[16:04:43.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.610]                   3L)]
[16:04:43.610]             }
[16:04:43.610]             function(cond) {
[16:04:43.610]                 is_error <- inherits(cond, "error")
[16:04:43.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.610]                   NULL)
[16:04:43.610]                 if (is_error) {
[16:04:43.610]                   sessionInformation <- function() {
[16:04:43.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.610]                       search = base::search(), system = base::Sys.info())
[16:04:43.610]                   }
[16:04:43.610]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.610]                     cond$call), session = sessionInformation(), 
[16:04:43.610]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.610]                   signalCondition(cond)
[16:04:43.610]                 }
[16:04:43.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.610]                 "immediateCondition"))) {
[16:04:43.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.610]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.610]                   if (TRUE && !signal) {
[16:04:43.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.610]                     {
[16:04:43.610]                       inherits <- base::inherits
[16:04:43.610]                       invokeRestart <- base::invokeRestart
[16:04:43.610]                       is.null <- base::is.null
[16:04:43.610]                       muffled <- FALSE
[16:04:43.610]                       if (inherits(cond, "message")) {
[16:04:43.610]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.610]                         if (muffled) 
[16:04:43.610]                           invokeRestart("muffleMessage")
[16:04:43.610]                       }
[16:04:43.610]                       else if (inherits(cond, "warning")) {
[16:04:43.610]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.610]                         if (muffled) 
[16:04:43.610]                           invokeRestart("muffleWarning")
[16:04:43.610]                       }
[16:04:43.610]                       else if (inherits(cond, "condition")) {
[16:04:43.610]                         if (!is.null(pattern)) {
[16:04:43.610]                           computeRestarts <- base::computeRestarts
[16:04:43.610]                           grepl <- base::grepl
[16:04:43.610]                           restarts <- computeRestarts(cond)
[16:04:43.610]                           for (restart in restarts) {
[16:04:43.610]                             name <- restart$name
[16:04:43.610]                             if (is.null(name)) 
[16:04:43.610]                               next
[16:04:43.610]                             if (!grepl(pattern, name)) 
[16:04:43.610]                               next
[16:04:43.610]                             invokeRestart(restart)
[16:04:43.610]                             muffled <- TRUE
[16:04:43.610]                             break
[16:04:43.610]                           }
[16:04:43.610]                         }
[16:04:43.610]                       }
[16:04:43.610]                       invisible(muffled)
[16:04:43.610]                     }
[16:04:43.610]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.610]                   }
[16:04:43.610]                 }
[16:04:43.610]                 else {
[16:04:43.610]                   if (TRUE) {
[16:04:43.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.610]                     {
[16:04:43.610]                       inherits <- base::inherits
[16:04:43.610]                       invokeRestart <- base::invokeRestart
[16:04:43.610]                       is.null <- base::is.null
[16:04:43.610]                       muffled <- FALSE
[16:04:43.610]                       if (inherits(cond, "message")) {
[16:04:43.610]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.610]                         if (muffled) 
[16:04:43.610]                           invokeRestart("muffleMessage")
[16:04:43.610]                       }
[16:04:43.610]                       else if (inherits(cond, "warning")) {
[16:04:43.610]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.610]                         if (muffled) 
[16:04:43.610]                           invokeRestart("muffleWarning")
[16:04:43.610]                       }
[16:04:43.610]                       else if (inherits(cond, "condition")) {
[16:04:43.610]                         if (!is.null(pattern)) {
[16:04:43.610]                           computeRestarts <- base::computeRestarts
[16:04:43.610]                           grepl <- base::grepl
[16:04:43.610]                           restarts <- computeRestarts(cond)
[16:04:43.610]                           for (restart in restarts) {
[16:04:43.610]                             name <- restart$name
[16:04:43.610]                             if (is.null(name)) 
[16:04:43.610]                               next
[16:04:43.610]                             if (!grepl(pattern, name)) 
[16:04:43.610]                               next
[16:04:43.610]                             invokeRestart(restart)
[16:04:43.610]                             muffled <- TRUE
[16:04:43.610]                             break
[16:04:43.610]                           }
[16:04:43.610]                         }
[16:04:43.610]                       }
[16:04:43.610]                       invisible(muffled)
[16:04:43.610]                     }
[16:04:43.610]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.610]                   }
[16:04:43.610]                 }
[16:04:43.610]             }
[16:04:43.610]         }))
[16:04:43.610]     }, error = function(ex) {
[16:04:43.610]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.610]                 ...future.rng), started = ...future.startTime, 
[16:04:43.610]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.610]             version = "1.8"), class = "FutureResult")
[16:04:43.610]     }, finally = {
[16:04:43.610]         if (!identical(...future.workdir, getwd())) 
[16:04:43.610]             setwd(...future.workdir)
[16:04:43.610]         {
[16:04:43.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.610]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.610]             }
[16:04:43.610]             base::options(...future.oldOptions)
[16:04:43.610]             if (.Platform$OS.type == "windows") {
[16:04:43.610]                 old_names <- names(...future.oldEnvVars)
[16:04:43.610]                 envs <- base::Sys.getenv()
[16:04:43.610]                 names <- names(envs)
[16:04:43.610]                 common <- intersect(names, old_names)
[16:04:43.610]                 added <- setdiff(names, old_names)
[16:04:43.610]                 removed <- setdiff(old_names, names)
[16:04:43.610]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.610]                   envs[common]]
[16:04:43.610]                 NAMES <- toupper(changed)
[16:04:43.610]                 args <- list()
[16:04:43.610]                 for (kk in seq_along(NAMES)) {
[16:04:43.610]                   name <- changed[[kk]]
[16:04:43.610]                   NAME <- NAMES[[kk]]
[16:04:43.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.610]                     next
[16:04:43.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.610]                 }
[16:04:43.610]                 NAMES <- toupper(added)
[16:04:43.610]                 for (kk in seq_along(NAMES)) {
[16:04:43.610]                   name <- added[[kk]]
[16:04:43.610]                   NAME <- NAMES[[kk]]
[16:04:43.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.610]                     next
[16:04:43.610]                   args[[name]] <- ""
[16:04:43.610]                 }
[16:04:43.610]                 NAMES <- toupper(removed)
[16:04:43.610]                 for (kk in seq_along(NAMES)) {
[16:04:43.610]                   name <- removed[[kk]]
[16:04:43.610]                   NAME <- NAMES[[kk]]
[16:04:43.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.610]                     next
[16:04:43.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.610]                 }
[16:04:43.610]                 if (length(args) > 0) 
[16:04:43.610]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.610]             }
[16:04:43.610]             else {
[16:04:43.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.610]             }
[16:04:43.610]             {
[16:04:43.610]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.610]                   0L) {
[16:04:43.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.610]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.610]                   base::options(opts)
[16:04:43.610]                 }
[16:04:43.610]                 {
[16:04:43.610]                   {
[16:04:43.610]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.610]                     NULL
[16:04:43.610]                   }
[16:04:43.610]                   options(future.plan = NULL)
[16:04:43.610]                   if (is.na(NA_character_)) 
[16:04:43.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.610]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:43.610]                     envir = parent.frame()) 
[16:04:43.610]                   {
[16:04:43.610]                     default_workers <- missing(workers)
[16:04:43.610]                     if (is.function(workers)) 
[16:04:43.610]                       workers <- workers()
[16:04:43.610]                     workers <- structure(as.integer(workers), 
[16:04:43.610]                       class = class(workers))
[16:04:43.610]                     stop_if_not(is.finite(workers), workers >= 
[16:04:43.610]                       1L)
[16:04:43.610]                     if ((workers == 1L && !inherits(workers, 
[16:04:43.610]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:43.610]                       if (default_workers) 
[16:04:43.610]                         supportsMulticore(warn = TRUE)
[16:04:43.610]                       return(sequential(..., envir = envir))
[16:04:43.610]                     }
[16:04:43.610]                     oopts <- options(mc.cores = workers)
[16:04:43.610]                     on.exit(options(oopts))
[16:04:43.610]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:43.610]                       envir = envir)
[16:04:43.610]                     if (!future$lazy) 
[16:04:43.610]                       future <- run(future)
[16:04:43.610]                     invisible(future)
[16:04:43.610]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.610]                 }
[16:04:43.610]             }
[16:04:43.610]         }
[16:04:43.610]     })
[16:04:43.610]     if (TRUE) {
[16:04:43.610]         base::sink(type = "output", split = FALSE)
[16:04:43.610]         if (TRUE) {
[16:04:43.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.610]         }
[16:04:43.610]         else {
[16:04:43.610]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.610]         }
[16:04:43.610]         base::close(...future.stdout)
[16:04:43.610]         ...future.stdout <- NULL
[16:04:43.610]     }
[16:04:43.610]     ...future.result$conditions <- ...future.conditions
[16:04:43.610]     ...future.result$finished <- base::Sys.time()
[16:04:43.610]     ...future.result
[16:04:43.610] }
[16:04:43.614] requestCore(): workers = 2
[16:04:43.615] Poll #1 (0): usedCores() = 2, workers = 2
[16:04:43.625] result() for MulticoreFuture ...
[16:04:43.626] result() for MulticoreFuture ...
[16:04:43.626] result() for MulticoreFuture ... done
[16:04:43.627] result() for MulticoreFuture ... done
[16:04:43.627] result() for MulticoreFuture ...
[16:04:43.627] result() for MulticoreFuture ... done
[16:04:43.630] MulticoreFuture started
[16:04:43.630] - Launch lazy future ... done
[16:04:43.631] run() for ‘MulticoreFuture’ ... done
[16:04:43.631] plan(): Setting new future strategy stack:
<environment: 0x55874ddb4c58> 
[16:04:43.632] List of future strategies:
[16:04:43.632] 1. sequential:
[16:04:43.632]    - args: function (..., envir = parent.frame())
[16:04:43.632]    - tweaked: FALSE
[16:04:43.632]    - call: NULL
[16:04:43.633] plan(): nbrOfWorkers() = 1
<environment: 0x55874e9f79d8> 
[16:04:43.635] plan(): Setting new future strategy stack:
[16:04:43.635] List of future strategies:
[16:04:43.635] 1. multicore:
[16:04:43.635]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:43.635]    - tweaked: FALSE
[16:04:43.635]    - call: plan(strategy)
[16:04:43.641] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:43.643] resolve() on environment ...
[16:04:43.643]  recursive: 0
[16:04:43.644]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:43.644] signalConditionsASAP(numeric, pos=1) ...
[16:04:43.644] - nx: 4
[16:04:43.644] - relay: TRUE
[16:04:43.645] - stdout: TRUE
[16:04:43.645] - signal: TRUE
[16:04:43.645] - resignal: FALSE
[16:04:43.645] - force: TRUE
[16:04:43.645] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.645] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.645]  - until=2
[16:04:43.646]  - relaying element #2
[16:04:43.646] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:43.646] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.646] signalConditionsASAP(NULL, pos=1) ... done
[16:04:43.646]  length: 3 (resolved future 1)
[16:04:43.646] Future #2
[16:04:43.646] result() for MulticoreFuture ...
[16:04:43.647] result() for MulticoreFuture ... done
[16:04:43.647] result() for MulticoreFuture ...
[16:04:43.647] result() for MulticoreFuture ... done
[16:04:43.647] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:43.647] - nx: 4
[16:04:43.647] - relay: TRUE
[16:04:43.647] - stdout: TRUE
[16:04:43.648] - signal: TRUE
[16:04:43.648] - resignal: FALSE
[16:04:43.648] - force: TRUE
[16:04:43.648] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:43.648] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:43.648]  - until=2
[16:04:43.648]  - relaying element #2
[16:04:43.648] result() for MulticoreFuture ...
[16:04:43.649] result() for MulticoreFuture ... done
[16:04:43.649] result() for MulticoreFuture ...
[16:04:43.649] result() for MulticoreFuture ... done
[16:04:43.649] result() for MulticoreFuture ...
[16:04:43.649] result() for MulticoreFuture ... done
[16:04:43.649] result() for MulticoreFuture ...
[16:04:43.649] result() for MulticoreFuture ... done
[16:04:43.649] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:43.650] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:43.650] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:43.650]  length: 2 (resolved future 2)
[16:04:43.650] Future #3
[16:04:43.650] result() for MulticoreFuture ...
[16:04:43.651] result() for MulticoreFuture ...
[16:04:43.651] result() for MulticoreFuture ... done
[16:04:43.651] result() for MulticoreFuture ... done
[16:04:43.652] result() for MulticoreFuture ...
[16:04:43.652] result() for MulticoreFuture ... done
[16:04:43.652] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:43.652] - nx: 4
[16:04:43.652] - relay: TRUE
[16:04:43.652] - stdout: TRUE
[16:04:43.652] - signal: TRUE
[16:04:43.652] - resignal: FALSE
[16:04:43.653] - force: TRUE
[16:04:43.653] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:43.653] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:43.653]  - until=3
[16:04:43.653]  - relaying element #3
[16:04:43.653] result() for MulticoreFuture ...
[16:04:43.653] result() for MulticoreFuture ... done
[16:04:43.653] result() for MulticoreFuture ...
[16:04:43.654] result() for MulticoreFuture ... done
[16:04:43.654] result() for MulticoreFuture ...
[16:04:43.654] result() for MulticoreFuture ... done
[16:04:43.654] result() for MulticoreFuture ...
[16:04:43.654] result() for MulticoreFuture ... done
[16:04:43.654] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:43.654] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:43.655] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:43.655]  length: 1 (resolved future 3)
[16:04:43.655] Future #4
[16:04:43.655] result() for MulticoreFuture ...
[16:04:43.656] result() for MulticoreFuture ...
[16:04:43.656] result() for MulticoreFuture ... done
[16:04:43.656] result() for MulticoreFuture ... done
[16:04:43.656] result() for MulticoreFuture ...
[16:04:43.657] result() for MulticoreFuture ... done
[16:04:43.657] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:04:43.657] - nx: 4
[16:04:43.657] - relay: TRUE
[16:04:43.657] - stdout: TRUE
[16:04:43.657] - signal: TRUE
[16:04:43.658] - resignal: FALSE
[16:04:43.658] - force: TRUE
[16:04:43.658] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:43.658] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:43.658]  - until=4
[16:04:43.658]  - relaying element #4
[16:04:43.658] result() for MulticoreFuture ...
[16:04:43.659] result() for MulticoreFuture ... done
[16:04:43.659] result() for MulticoreFuture ...
[16:04:43.659] result() for MulticoreFuture ... done
[16:04:43.659] result() for MulticoreFuture ...
[16:04:43.659] result() for MulticoreFuture ... done
[16:04:43.659] result() for MulticoreFuture ...
[16:04:43.660] result() for MulticoreFuture ... done
[16:04:43.660] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.660] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:43.660] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:04:43.660]  length: 0 (resolved future 4)
[16:04:43.660] Relaying remaining futures
[16:04:43.660] signalConditionsASAP(NULL, pos=0) ...
[16:04:43.660] - nx: 4
[16:04:43.660] - relay: TRUE
[16:04:43.660] - stdout: TRUE
[16:04:43.661] - signal: TRUE
[16:04:43.661] - resignal: FALSE
[16:04:43.661] - force: TRUE
[16:04:43.661] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.661] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:43.661] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:43.661] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:43.661] signalConditionsASAP(NULL, pos=0) ... done
[16:04:43.661] resolve() on environment ... DONE
[16:04:43.661] result() for MulticoreFuture ...
[16:04:43.662] result() for MulticoreFuture ... done
[16:04:43.662] result() for MulticoreFuture ...
[16:04:43.662] result() for MulticoreFuture ... done
[16:04:43.662] result() for MulticoreFuture ...
[16:04:43.662] result() for MulticoreFuture ... done
[16:04:43.662] result() for MulticoreFuture ...
[16:04:43.662] result() for MulticoreFuture ... done
[16:04:43.662] result() for MulticoreFuture ...
[16:04:43.662] result() for MulticoreFuture ... done
[16:04:43.663] result() for MulticoreFuture ...
[16:04:43.663] result() for MulticoreFuture ... done
<environment: 0x55874eb60e08> 
Type of future: multisession
[16:04:43.663] plan(): Setting new future strategy stack:
[16:04:43.663] List of future strategies:
[16:04:43.663] 1. multisession:
[16:04:43.663]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:43.663]    - tweaked: FALSE
[16:04:43.663]    - call: plan(strategy)
[16:04:43.664] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:04:43.664] multisession:
[16:04:43.664] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:43.664] - tweaked: FALSE
[16:04:43.664] - call: plan(strategy)
[16:04:43.668] getGlobalsAndPackages() ...
[16:04:43.668] Not searching for globals
[16:04:43.668] - globals: [0] <none>
[16:04:43.668] getGlobalsAndPackages() ... DONE
[16:04:43.669] [local output] makeClusterPSOCK() ...
[16:04:43.672] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:04:43.673] [local output] Base port: 11826
[16:04:43.673] [local output] Getting setup options for 2 cluster nodes ...
[16:04:43.673] [local output]  - Node 1 of 2 ...
[16:04:43.674] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:43.674] [local output] Rscript port: 11826

[16:04:43.675] [local output]  - Node 2 of 2 ...
[16:04:43.675] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:43.676] [local output] Rscript port: 11826

[16:04:43.676] [local output] Getting setup options for 2 cluster nodes ... done
[16:04:43.676] [local output]  - Parallel setup requested for some PSOCK nodes
[16:04:43.676] [local output] Setting up PSOCK nodes in parallel
[16:04:43.676] List of 36
[16:04:43.676]  $ worker          : chr "localhost"
[16:04:43.676]   ..- attr(*, "localhost")= logi TRUE
[16:04:43.676]  $ master          : chr "localhost"
[16:04:43.676]  $ port            : int 11826
[16:04:43.676]  $ connectTimeout  : num 120
[16:04:43.676]  $ timeout         : num 2592000
[16:04:43.676]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:04:43.676]  $ homogeneous     : logi TRUE
[16:04:43.676]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:04:43.676]  $ rscript_envs    : NULL
[16:04:43.676]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:43.676]  $ rscript_startup : NULL
[16:04:43.676]  $ rscript_sh      : chr "sh"
[16:04:43.676]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:43.676]  $ methods         : logi TRUE
[16:04:43.676]  $ socketOptions   : chr "no-delay"
[16:04:43.676]  $ useXDR          : logi FALSE
[16:04:43.676]  $ outfile         : chr "/dev/null"
[16:04:43.676]  $ renice          : int NA
[16:04:43.676]  $ rshcmd          : NULL
[16:04:43.676]  $ user            : chr(0) 
[16:04:43.676]  $ revtunnel       : logi FALSE
[16:04:43.676]  $ rshlogfile      : NULL
[16:04:43.676]  $ rshopts         : chr(0) 
[16:04:43.676]  $ rank            : int 1
[16:04:43.676]  $ manual          : logi FALSE
[16:04:43.676]  $ dryrun          : logi FALSE
[16:04:43.676]  $ quiet           : logi FALSE
[16:04:43.676]  $ setup_strategy  : chr "parallel"
[16:04:43.676]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:43.676]  $ pidfile         : chr "/tmp/RtmpKP9SHZ/worker.rank=1.parallelly.parent=83263.1453f571ea30d.pid"
[16:04:43.676]  $ rshcmd_label    : NULL
[16:04:43.676]  $ rsh_call        : NULL
[16:04:43.676]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:43.676]  $ localMachine    : logi TRUE
[16:04:43.676]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:04:43.676]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:04:43.676]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:04:43.676]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:04:43.676]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:04:43.676]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:04:43.676]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:04:43.676]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:04:43.676]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:04:43.676]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:04:43.676]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:04:43.676]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:04:43.676]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:04:43.676]  $ arguments       :List of 28
[16:04:43.676]   ..$ worker          : chr "localhost"
[16:04:43.676]   ..$ master          : NULL
[16:04:43.676]   ..$ port            : int 11826
[16:04:43.676]   ..$ connectTimeout  : num 120
[16:04:43.676]   ..$ timeout         : num 2592000
[16:04:43.676]   ..$ rscript         : NULL
[16:04:43.676]   ..$ homogeneous     : NULL
[16:04:43.676]   ..$ rscript_args    : NULL
[16:04:43.676]   ..$ rscript_envs    : NULL
[16:04:43.676]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:43.676]   ..$ rscript_startup : NULL
[16:04:43.676]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:04:43.676]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:43.676]   ..$ methods         : logi TRUE
[16:04:43.676]   ..$ socketOptions   : chr "no-delay"
[16:04:43.676]   ..$ useXDR          : logi FALSE
[16:04:43.676]   ..$ outfile         : chr "/dev/null"
[16:04:43.676]   ..$ renice          : int NA
[16:04:43.676]   ..$ rshcmd          : NULL
[16:04:43.676]   ..$ user            : NULL
[16:04:43.676]   ..$ revtunnel       : logi NA
[16:04:43.676]   ..$ rshlogfile      : NULL
[16:04:43.676]   ..$ rshopts         : NULL
[16:04:43.676]   ..$ rank            : int 1
[16:04:43.676]   ..$ manual          : logi FALSE
[16:04:43.676]   ..$ dryrun          : logi FALSE
[16:04:43.676]   ..$ quiet           : logi FALSE
[16:04:43.676]   ..$ setup_strategy  : chr "parallel"
[16:04:43.676]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:04:43.700] [local output] System call to launch all workers:
[16:04:43.700] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpKP9SHZ/worker.rank=1.parallelly.parent=83263.1453f571ea30d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11826 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:04:43.700] [local output] Starting PSOCK main server
[16:04:43.701] [local output] Workers launched
[16:04:43.701] [local output] Waiting for workers to connect back
[16:04:43.702]  - [local output] 0 workers out of 2 ready
[16:04:43.958]  - [local output] 0 workers out of 2 ready
[16:04:43.959]  - [local output] 1 workers out of 2 ready
[16:04:43.959]  - [local output] 2 workers out of 2 ready
[16:04:43.959] [local output] Launching of workers completed
[16:04:43.959] [local output] Collecting session information from workers
[16:04:43.960] [local output]  - Worker #1 of 2
[16:04:43.960] [local output]  - Worker #2 of 2
[16:04:43.961] [local output] makeClusterPSOCK() ... done
[16:04:43.972] Packages needed by the future expression (n = 0): <none>
[16:04:43.972] Packages needed by future strategies (n = 0): <none>
[16:04:43.973] {
[16:04:43.973]     {
[16:04:43.973]         {
[16:04:43.973]             ...future.startTime <- base::Sys.time()
[16:04:43.973]             {
[16:04:43.973]                 {
[16:04:43.973]                   {
[16:04:43.973]                     {
[16:04:43.973]                       base::local({
[16:04:43.973]                         has_future <- base::requireNamespace("future", 
[16:04:43.973]                           quietly = TRUE)
[16:04:43.973]                         if (has_future) {
[16:04:43.973]                           ns <- base::getNamespace("future")
[16:04:43.973]                           version <- ns[[".package"]][["version"]]
[16:04:43.973]                           if (is.null(version)) 
[16:04:43.973]                             version <- utils::packageVersion("future")
[16:04:43.973]                         }
[16:04:43.973]                         else {
[16:04:43.973]                           version <- NULL
[16:04:43.973]                         }
[16:04:43.973]                         if (!has_future || version < "1.8.0") {
[16:04:43.973]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:43.973]                             "", base::R.version$version.string), 
[16:04:43.973]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:43.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:43.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:43.973]                               "release", "version")], collapse = " "), 
[16:04:43.973]                             hostname = base::Sys.info()[["nodename"]])
[16:04:43.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:43.973]                             info)
[16:04:43.973]                           info <- base::paste(info, collapse = "; ")
[16:04:43.973]                           if (!has_future) {
[16:04:43.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:43.973]                               info)
[16:04:43.973]                           }
[16:04:43.973]                           else {
[16:04:43.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:43.973]                               info, version)
[16:04:43.973]                           }
[16:04:43.973]                           base::stop(msg)
[16:04:43.973]                         }
[16:04:43.973]                       })
[16:04:43.973]                     }
[16:04:43.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:43.973]                     base::options(mc.cores = 1L)
[16:04:43.973]                   }
[16:04:43.973]                   options(future.plan = NULL)
[16:04:43.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:43.973]                 }
[16:04:43.973]                 ...future.workdir <- getwd()
[16:04:43.973]             }
[16:04:43.973]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:43.973]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:43.973]         }
[16:04:43.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:43.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:43.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:43.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:43.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:43.973]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:43.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:43.973]             base::names(...future.oldOptions))
[16:04:43.973]     }
[16:04:43.973]     if (FALSE) {
[16:04:43.973]     }
[16:04:43.973]     else {
[16:04:43.973]         if (TRUE) {
[16:04:43.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:43.973]                 open = "w")
[16:04:43.973]         }
[16:04:43.973]         else {
[16:04:43.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:43.973]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:43.973]         }
[16:04:43.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:43.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:43.973]             base::sink(type = "output", split = FALSE)
[16:04:43.973]             base::close(...future.stdout)
[16:04:43.973]         }, add = TRUE)
[16:04:43.973]     }
[16:04:43.973]     ...future.frame <- base::sys.nframe()
[16:04:43.973]     ...future.conditions <- base::list()
[16:04:43.973]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:43.973]     if (FALSE) {
[16:04:43.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:43.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:43.973]     }
[16:04:43.973]     ...future.result <- base::tryCatch({
[16:04:43.973]         base::withCallingHandlers({
[16:04:43.973]             ...future.value <- base::withVisible(base::local({
[16:04:43.973]                 ...future.makeSendCondition <- base::local({
[16:04:43.973]                   sendCondition <- NULL
[16:04:43.973]                   function(frame = 1L) {
[16:04:43.973]                     if (is.function(sendCondition)) 
[16:04:43.973]                       return(sendCondition)
[16:04:43.973]                     ns <- getNamespace("parallel")
[16:04:43.973]                     if (exists("sendData", mode = "function", 
[16:04:43.973]                       envir = ns)) {
[16:04:43.973]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:43.973]                         envir = ns)
[16:04:43.973]                       envir <- sys.frame(frame)
[16:04:43.973]                       master <- NULL
[16:04:43.973]                       while (!identical(envir, .GlobalEnv) && 
[16:04:43.973]                         !identical(envir, emptyenv())) {
[16:04:43.973]                         if (exists("master", mode = "list", envir = envir, 
[16:04:43.973]                           inherits = FALSE)) {
[16:04:43.973]                           master <- get("master", mode = "list", 
[16:04:43.973]                             envir = envir, inherits = FALSE)
[16:04:43.973]                           if (inherits(master, c("SOCKnode", 
[16:04:43.973]                             "SOCK0node"))) {
[16:04:43.973]                             sendCondition <<- function(cond) {
[16:04:43.973]                               data <- list(type = "VALUE", value = cond, 
[16:04:43.973]                                 success = TRUE)
[16:04:43.973]                               parallel_sendData(master, data)
[16:04:43.973]                             }
[16:04:43.973]                             return(sendCondition)
[16:04:43.973]                           }
[16:04:43.973]                         }
[16:04:43.973]                         frame <- frame + 1L
[16:04:43.973]                         envir <- sys.frame(frame)
[16:04:43.973]                       }
[16:04:43.973]                     }
[16:04:43.973]                     sendCondition <<- function(cond) NULL
[16:04:43.973]                   }
[16:04:43.973]                 })
[16:04:43.973]                 withCallingHandlers({
[16:04:43.973]                   NA
[16:04:43.973]                 }, immediateCondition = function(cond) {
[16:04:43.973]                   sendCondition <- ...future.makeSendCondition()
[16:04:43.973]                   sendCondition(cond)
[16:04:43.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.973]                   {
[16:04:43.973]                     inherits <- base::inherits
[16:04:43.973]                     invokeRestart <- base::invokeRestart
[16:04:43.973]                     is.null <- base::is.null
[16:04:43.973]                     muffled <- FALSE
[16:04:43.973]                     if (inherits(cond, "message")) {
[16:04:43.973]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:43.973]                       if (muffled) 
[16:04:43.973]                         invokeRestart("muffleMessage")
[16:04:43.973]                     }
[16:04:43.973]                     else if (inherits(cond, "warning")) {
[16:04:43.973]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:43.973]                       if (muffled) 
[16:04:43.973]                         invokeRestart("muffleWarning")
[16:04:43.973]                     }
[16:04:43.973]                     else if (inherits(cond, "condition")) {
[16:04:43.973]                       if (!is.null(pattern)) {
[16:04:43.973]                         computeRestarts <- base::computeRestarts
[16:04:43.973]                         grepl <- base::grepl
[16:04:43.973]                         restarts <- computeRestarts(cond)
[16:04:43.973]                         for (restart in restarts) {
[16:04:43.973]                           name <- restart$name
[16:04:43.973]                           if (is.null(name)) 
[16:04:43.973]                             next
[16:04:43.973]                           if (!grepl(pattern, name)) 
[16:04:43.973]                             next
[16:04:43.973]                           invokeRestart(restart)
[16:04:43.973]                           muffled <- TRUE
[16:04:43.973]                           break
[16:04:43.973]                         }
[16:04:43.973]                       }
[16:04:43.973]                     }
[16:04:43.973]                     invisible(muffled)
[16:04:43.973]                   }
[16:04:43.973]                   muffleCondition(cond)
[16:04:43.973]                 })
[16:04:43.973]             }))
[16:04:43.973]             future::FutureResult(value = ...future.value$value, 
[16:04:43.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.973]                   ...future.rng), globalenv = if (FALSE) 
[16:04:43.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:43.973]                     ...future.globalenv.names))
[16:04:43.973]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:43.973]         }, condition = base::local({
[16:04:43.973]             c <- base::c
[16:04:43.973]             inherits <- base::inherits
[16:04:43.973]             invokeRestart <- base::invokeRestart
[16:04:43.973]             length <- base::length
[16:04:43.973]             list <- base::list
[16:04:43.973]             seq.int <- base::seq.int
[16:04:43.973]             signalCondition <- base::signalCondition
[16:04:43.973]             sys.calls <- base::sys.calls
[16:04:43.973]             `[[` <- base::`[[`
[16:04:43.973]             `+` <- base::`+`
[16:04:43.973]             `<<-` <- base::`<<-`
[16:04:43.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:43.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:43.973]                   3L)]
[16:04:43.973]             }
[16:04:43.973]             function(cond) {
[16:04:43.973]                 is_error <- inherits(cond, "error")
[16:04:43.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:43.973]                   NULL)
[16:04:43.973]                 if (is_error) {
[16:04:43.973]                   sessionInformation <- function() {
[16:04:43.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:43.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:43.973]                       search = base::search(), system = base::Sys.info())
[16:04:43.973]                   }
[16:04:43.973]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:43.973]                     cond$call), session = sessionInformation(), 
[16:04:43.973]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:43.973]                   signalCondition(cond)
[16:04:43.973]                 }
[16:04:43.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:43.973]                 "immediateCondition"))) {
[16:04:43.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:43.973]                   ...future.conditions[[length(...future.conditions) + 
[16:04:43.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:43.973]                   if (TRUE && !signal) {
[16:04:43.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.973]                     {
[16:04:43.973]                       inherits <- base::inherits
[16:04:43.973]                       invokeRestart <- base::invokeRestart
[16:04:43.973]                       is.null <- base::is.null
[16:04:43.973]                       muffled <- FALSE
[16:04:43.973]                       if (inherits(cond, "message")) {
[16:04:43.973]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.973]                         if (muffled) 
[16:04:43.973]                           invokeRestart("muffleMessage")
[16:04:43.973]                       }
[16:04:43.973]                       else if (inherits(cond, "warning")) {
[16:04:43.973]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.973]                         if (muffled) 
[16:04:43.973]                           invokeRestart("muffleWarning")
[16:04:43.973]                       }
[16:04:43.973]                       else if (inherits(cond, "condition")) {
[16:04:43.973]                         if (!is.null(pattern)) {
[16:04:43.973]                           computeRestarts <- base::computeRestarts
[16:04:43.973]                           grepl <- base::grepl
[16:04:43.973]                           restarts <- computeRestarts(cond)
[16:04:43.973]                           for (restart in restarts) {
[16:04:43.973]                             name <- restart$name
[16:04:43.973]                             if (is.null(name)) 
[16:04:43.973]                               next
[16:04:43.973]                             if (!grepl(pattern, name)) 
[16:04:43.973]                               next
[16:04:43.973]                             invokeRestart(restart)
[16:04:43.973]                             muffled <- TRUE
[16:04:43.973]                             break
[16:04:43.973]                           }
[16:04:43.973]                         }
[16:04:43.973]                       }
[16:04:43.973]                       invisible(muffled)
[16:04:43.973]                     }
[16:04:43.973]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.973]                   }
[16:04:43.973]                 }
[16:04:43.973]                 else {
[16:04:43.973]                   if (TRUE) {
[16:04:43.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:43.973]                     {
[16:04:43.973]                       inherits <- base::inherits
[16:04:43.973]                       invokeRestart <- base::invokeRestart
[16:04:43.973]                       is.null <- base::is.null
[16:04:43.973]                       muffled <- FALSE
[16:04:43.973]                       if (inherits(cond, "message")) {
[16:04:43.973]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:43.973]                         if (muffled) 
[16:04:43.973]                           invokeRestart("muffleMessage")
[16:04:43.973]                       }
[16:04:43.973]                       else if (inherits(cond, "warning")) {
[16:04:43.973]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:43.973]                         if (muffled) 
[16:04:43.973]                           invokeRestart("muffleWarning")
[16:04:43.973]                       }
[16:04:43.973]                       else if (inherits(cond, "condition")) {
[16:04:43.973]                         if (!is.null(pattern)) {
[16:04:43.973]                           computeRestarts <- base::computeRestarts
[16:04:43.973]                           grepl <- base::grepl
[16:04:43.973]                           restarts <- computeRestarts(cond)
[16:04:43.973]                           for (restart in restarts) {
[16:04:43.973]                             name <- restart$name
[16:04:43.973]                             if (is.null(name)) 
[16:04:43.973]                               next
[16:04:43.973]                             if (!grepl(pattern, name)) 
[16:04:43.973]                               next
[16:04:43.973]                             invokeRestart(restart)
[16:04:43.973]                             muffled <- TRUE
[16:04:43.973]                             break
[16:04:43.973]                           }
[16:04:43.973]                         }
[16:04:43.973]                       }
[16:04:43.973]                       invisible(muffled)
[16:04:43.973]                     }
[16:04:43.973]                     muffleCondition(cond, pattern = "^muffle")
[16:04:43.973]                   }
[16:04:43.973]                 }
[16:04:43.973]             }
[16:04:43.973]         }))
[16:04:43.973]     }, error = function(ex) {
[16:04:43.973]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:43.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:43.973]                 ...future.rng), started = ...future.startTime, 
[16:04:43.973]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:43.973]             version = "1.8"), class = "FutureResult")
[16:04:43.973]     }, finally = {
[16:04:43.973]         if (!identical(...future.workdir, getwd())) 
[16:04:43.973]             setwd(...future.workdir)
[16:04:43.973]         {
[16:04:43.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:43.973]                 ...future.oldOptions$nwarnings <- NULL
[16:04:43.973]             }
[16:04:43.973]             base::options(...future.oldOptions)
[16:04:43.973]             if (.Platform$OS.type == "windows") {
[16:04:43.973]                 old_names <- names(...future.oldEnvVars)
[16:04:43.973]                 envs <- base::Sys.getenv()
[16:04:43.973]                 names <- names(envs)
[16:04:43.973]                 common <- intersect(names, old_names)
[16:04:43.973]                 added <- setdiff(names, old_names)
[16:04:43.973]                 removed <- setdiff(old_names, names)
[16:04:43.973]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:43.973]                   envs[common]]
[16:04:43.973]                 NAMES <- toupper(changed)
[16:04:43.973]                 args <- list()
[16:04:43.973]                 for (kk in seq_along(NAMES)) {
[16:04:43.973]                   name <- changed[[kk]]
[16:04:43.973]                   NAME <- NAMES[[kk]]
[16:04:43.973]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.973]                     next
[16:04:43.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.973]                 }
[16:04:43.973]                 NAMES <- toupper(added)
[16:04:43.973]                 for (kk in seq_along(NAMES)) {
[16:04:43.973]                   name <- added[[kk]]
[16:04:43.973]                   NAME <- NAMES[[kk]]
[16:04:43.973]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.973]                     next
[16:04:43.973]                   args[[name]] <- ""
[16:04:43.973]                 }
[16:04:43.973]                 NAMES <- toupper(removed)
[16:04:43.973]                 for (kk in seq_along(NAMES)) {
[16:04:43.973]                   name <- removed[[kk]]
[16:04:43.973]                   NAME <- NAMES[[kk]]
[16:04:43.973]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:43.973]                     next
[16:04:43.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:43.973]                 }
[16:04:43.973]                 if (length(args) > 0) 
[16:04:43.973]                   base::do.call(base::Sys.setenv, args = args)
[16:04:43.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:43.973]             }
[16:04:43.973]             else {
[16:04:43.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:43.973]             }
[16:04:43.973]             {
[16:04:43.973]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:43.973]                   0L) {
[16:04:43.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:43.973]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:43.973]                   base::options(opts)
[16:04:43.973]                 }
[16:04:43.973]                 {
[16:04:43.973]                   {
[16:04:43.973]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:43.973]                     NULL
[16:04:43.973]                   }
[16:04:43.973]                   options(future.plan = NULL)
[16:04:43.973]                   if (is.na(NA_character_)) 
[16:04:43.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:43.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:43.973]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:43.973]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:43.973]                     envir = parent.frame()) 
[16:04:43.973]                   {
[16:04:43.973]                     if (is.function(workers)) 
[16:04:43.973]                       workers <- workers()
[16:04:43.973]                     workers <- structure(as.integer(workers), 
[16:04:43.973]                       class = class(workers))
[16:04:43.973]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:43.973]                       workers >= 1)
[16:04:43.973]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:43.973]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:43.973]                     }
[16:04:43.973]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:43.973]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:43.973]                       envir = envir)
[16:04:43.973]                     if (!future$lazy) 
[16:04:43.973]                       future <- run(future)
[16:04:43.973]                     invisible(future)
[16:04:43.973]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:43.973]                 }
[16:04:43.973]             }
[16:04:43.973]         }
[16:04:43.973]     })
[16:04:43.973]     if (TRUE) {
[16:04:43.973]         base::sink(type = "output", split = FALSE)
[16:04:43.973]         if (TRUE) {
[16:04:43.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:43.973]         }
[16:04:43.973]         else {
[16:04:43.973]             ...future.result["stdout"] <- base::list(NULL)
[16:04:43.973]         }
[16:04:43.973]         base::close(...future.stdout)
[16:04:43.973]         ...future.stdout <- NULL
[16:04:43.973]     }
[16:04:43.973]     ...future.result$conditions <- ...future.conditions
[16:04:43.973]     ...future.result$finished <- base::Sys.time()
[16:04:43.973]     ...future.result
[16:04:43.973] }
[16:04:44.027] MultisessionFuture started
[16:04:44.027] result() for ClusterFuture ...
[16:04:44.027] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.027] - Validating connection of MultisessionFuture
[16:04:44.072] - received message: FutureResult
[16:04:44.072] - Received FutureResult
[16:04:44.072] - Erased future from FutureRegistry
[16:04:44.072] result() for ClusterFuture ...
[16:04:44.072] - result already collected: FutureResult
[16:04:44.072] result() for ClusterFuture ... done
[16:04:44.072] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:44.073] result() for ClusterFuture ... done
[16:04:44.073] result() for ClusterFuture ...
[16:04:44.073] - result already collected: FutureResult
[16:04:44.073] result() for ClusterFuture ... done
[16:04:44.073] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:04:44.077] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:04:44.077] getGlobalsAndPackages() ...
[16:04:44.077] Searching for globals...
[16:04:44.077] 
[16:04:44.078] Searching for globals ... DONE
[16:04:44.078] - globals: [0] <none>
[16:04:44.078] getGlobalsAndPackages() ... DONE
[16:04:44.078] run() for ‘Future’ ...
[16:04:44.078] - state: ‘created’
[16:04:44.078] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.092] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.092] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.093]   - Field: ‘node’
[16:04:44.093]   - Field: ‘label’
[16:04:44.093]   - Field: ‘local’
[16:04:44.093]   - Field: ‘owner’
[16:04:44.093]   - Field: ‘envir’
[16:04:44.093]   - Field: ‘workers’
[16:04:44.093]   - Field: ‘packages’
[16:04:44.093]   - Field: ‘gc’
[16:04:44.093]   - Field: ‘conditions’
[16:04:44.094]   - Field: ‘persistent’
[16:04:44.094]   - Field: ‘expr’
[16:04:44.094]   - Field: ‘uuid’
[16:04:44.094]   - Field: ‘seed’
[16:04:44.094]   - Field: ‘version’
[16:04:44.094]   - Field: ‘result’
[16:04:44.094]   - Field: ‘asynchronous’
[16:04:44.094]   - Field: ‘calls’
[16:04:44.094]   - Field: ‘globals’
[16:04:44.095]   - Field: ‘stdout’
[16:04:44.095]   - Field: ‘earlySignal’
[16:04:44.095]   - Field: ‘lazy’
[16:04:44.095]   - Field: ‘state’
[16:04:44.095] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.095] - Launch lazy future ...
[16:04:44.095] Packages needed by the future expression (n = 0): <none>
[16:04:44.096] Packages needed by future strategies (n = 0): <none>
[16:04:44.096] {
[16:04:44.096]     {
[16:04:44.096]         {
[16:04:44.096]             ...future.startTime <- base::Sys.time()
[16:04:44.096]             {
[16:04:44.096]                 {
[16:04:44.096]                   {
[16:04:44.096]                     {
[16:04:44.096]                       base::local({
[16:04:44.096]                         has_future <- base::requireNamespace("future", 
[16:04:44.096]                           quietly = TRUE)
[16:04:44.096]                         if (has_future) {
[16:04:44.096]                           ns <- base::getNamespace("future")
[16:04:44.096]                           version <- ns[[".package"]][["version"]]
[16:04:44.096]                           if (is.null(version)) 
[16:04:44.096]                             version <- utils::packageVersion("future")
[16:04:44.096]                         }
[16:04:44.096]                         else {
[16:04:44.096]                           version <- NULL
[16:04:44.096]                         }
[16:04:44.096]                         if (!has_future || version < "1.8.0") {
[16:04:44.096]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.096]                             "", base::R.version$version.string), 
[16:04:44.096]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.096]                               "release", "version")], collapse = " "), 
[16:04:44.096]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.096]                             info)
[16:04:44.096]                           info <- base::paste(info, collapse = "; ")
[16:04:44.096]                           if (!has_future) {
[16:04:44.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.096]                               info)
[16:04:44.096]                           }
[16:04:44.096]                           else {
[16:04:44.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.096]                               info, version)
[16:04:44.096]                           }
[16:04:44.096]                           base::stop(msg)
[16:04:44.096]                         }
[16:04:44.096]                       })
[16:04:44.096]                     }
[16:04:44.096]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.096]                     base::options(mc.cores = 1L)
[16:04:44.096]                   }
[16:04:44.096]                   options(future.plan = NULL)
[16:04:44.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.096]                 }
[16:04:44.096]                 ...future.workdir <- getwd()
[16:04:44.096]             }
[16:04:44.096]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.096]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.096]         }
[16:04:44.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.096]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.096]             base::names(...future.oldOptions))
[16:04:44.096]     }
[16:04:44.096]     if (FALSE) {
[16:04:44.096]     }
[16:04:44.096]     else {
[16:04:44.096]         if (TRUE) {
[16:04:44.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.096]                 open = "w")
[16:04:44.096]         }
[16:04:44.096]         else {
[16:04:44.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.096]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.096]         }
[16:04:44.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.096]             base::sink(type = "output", split = FALSE)
[16:04:44.096]             base::close(...future.stdout)
[16:04:44.096]         }, add = TRUE)
[16:04:44.096]     }
[16:04:44.096]     ...future.frame <- base::sys.nframe()
[16:04:44.096]     ...future.conditions <- base::list()
[16:04:44.096]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.096]     if (FALSE) {
[16:04:44.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.096]     }
[16:04:44.096]     ...future.result <- base::tryCatch({
[16:04:44.096]         base::withCallingHandlers({
[16:04:44.096]             ...future.value <- base::withVisible(base::local({
[16:04:44.096]                 ...future.makeSendCondition <- base::local({
[16:04:44.096]                   sendCondition <- NULL
[16:04:44.096]                   function(frame = 1L) {
[16:04:44.096]                     if (is.function(sendCondition)) 
[16:04:44.096]                       return(sendCondition)
[16:04:44.096]                     ns <- getNamespace("parallel")
[16:04:44.096]                     if (exists("sendData", mode = "function", 
[16:04:44.096]                       envir = ns)) {
[16:04:44.096]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.096]                         envir = ns)
[16:04:44.096]                       envir <- sys.frame(frame)
[16:04:44.096]                       master <- NULL
[16:04:44.096]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.096]                         !identical(envir, emptyenv())) {
[16:04:44.096]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.096]                           inherits = FALSE)) {
[16:04:44.096]                           master <- get("master", mode = "list", 
[16:04:44.096]                             envir = envir, inherits = FALSE)
[16:04:44.096]                           if (inherits(master, c("SOCKnode", 
[16:04:44.096]                             "SOCK0node"))) {
[16:04:44.096]                             sendCondition <<- function(cond) {
[16:04:44.096]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.096]                                 success = TRUE)
[16:04:44.096]                               parallel_sendData(master, data)
[16:04:44.096]                             }
[16:04:44.096]                             return(sendCondition)
[16:04:44.096]                           }
[16:04:44.096]                         }
[16:04:44.096]                         frame <- frame + 1L
[16:04:44.096]                         envir <- sys.frame(frame)
[16:04:44.096]                       }
[16:04:44.096]                     }
[16:04:44.096]                     sendCondition <<- function(cond) NULL
[16:04:44.096]                   }
[16:04:44.096]                 })
[16:04:44.096]                 withCallingHandlers({
[16:04:44.096]                   2
[16:04:44.096]                 }, immediateCondition = function(cond) {
[16:04:44.096]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.096]                   sendCondition(cond)
[16:04:44.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.096]                   {
[16:04:44.096]                     inherits <- base::inherits
[16:04:44.096]                     invokeRestart <- base::invokeRestart
[16:04:44.096]                     is.null <- base::is.null
[16:04:44.096]                     muffled <- FALSE
[16:04:44.096]                     if (inherits(cond, "message")) {
[16:04:44.096]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.096]                       if (muffled) 
[16:04:44.096]                         invokeRestart("muffleMessage")
[16:04:44.096]                     }
[16:04:44.096]                     else if (inherits(cond, "warning")) {
[16:04:44.096]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.096]                       if (muffled) 
[16:04:44.096]                         invokeRestart("muffleWarning")
[16:04:44.096]                     }
[16:04:44.096]                     else if (inherits(cond, "condition")) {
[16:04:44.096]                       if (!is.null(pattern)) {
[16:04:44.096]                         computeRestarts <- base::computeRestarts
[16:04:44.096]                         grepl <- base::grepl
[16:04:44.096]                         restarts <- computeRestarts(cond)
[16:04:44.096]                         for (restart in restarts) {
[16:04:44.096]                           name <- restart$name
[16:04:44.096]                           if (is.null(name)) 
[16:04:44.096]                             next
[16:04:44.096]                           if (!grepl(pattern, name)) 
[16:04:44.096]                             next
[16:04:44.096]                           invokeRestart(restart)
[16:04:44.096]                           muffled <- TRUE
[16:04:44.096]                           break
[16:04:44.096]                         }
[16:04:44.096]                       }
[16:04:44.096]                     }
[16:04:44.096]                     invisible(muffled)
[16:04:44.096]                   }
[16:04:44.096]                   muffleCondition(cond)
[16:04:44.096]                 })
[16:04:44.096]             }))
[16:04:44.096]             future::FutureResult(value = ...future.value$value, 
[16:04:44.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.096]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.096]                     ...future.globalenv.names))
[16:04:44.096]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.096]         }, condition = base::local({
[16:04:44.096]             c <- base::c
[16:04:44.096]             inherits <- base::inherits
[16:04:44.096]             invokeRestart <- base::invokeRestart
[16:04:44.096]             length <- base::length
[16:04:44.096]             list <- base::list
[16:04:44.096]             seq.int <- base::seq.int
[16:04:44.096]             signalCondition <- base::signalCondition
[16:04:44.096]             sys.calls <- base::sys.calls
[16:04:44.096]             `[[` <- base::`[[`
[16:04:44.096]             `+` <- base::`+`
[16:04:44.096]             `<<-` <- base::`<<-`
[16:04:44.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.096]                   3L)]
[16:04:44.096]             }
[16:04:44.096]             function(cond) {
[16:04:44.096]                 is_error <- inherits(cond, "error")
[16:04:44.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.096]                   NULL)
[16:04:44.096]                 if (is_error) {
[16:04:44.096]                   sessionInformation <- function() {
[16:04:44.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.096]                       search = base::search(), system = base::Sys.info())
[16:04:44.096]                   }
[16:04:44.096]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.096]                     cond$call), session = sessionInformation(), 
[16:04:44.096]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.096]                   signalCondition(cond)
[16:04:44.096]                 }
[16:04:44.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.096]                 "immediateCondition"))) {
[16:04:44.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.096]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.096]                   if (TRUE && !signal) {
[16:04:44.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.096]                     {
[16:04:44.096]                       inherits <- base::inherits
[16:04:44.096]                       invokeRestart <- base::invokeRestart
[16:04:44.096]                       is.null <- base::is.null
[16:04:44.096]                       muffled <- FALSE
[16:04:44.096]                       if (inherits(cond, "message")) {
[16:04:44.096]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.096]                         if (muffled) 
[16:04:44.096]                           invokeRestart("muffleMessage")
[16:04:44.096]                       }
[16:04:44.096]                       else if (inherits(cond, "warning")) {
[16:04:44.096]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.096]                         if (muffled) 
[16:04:44.096]                           invokeRestart("muffleWarning")
[16:04:44.096]                       }
[16:04:44.096]                       else if (inherits(cond, "condition")) {
[16:04:44.096]                         if (!is.null(pattern)) {
[16:04:44.096]                           computeRestarts <- base::computeRestarts
[16:04:44.096]                           grepl <- base::grepl
[16:04:44.096]                           restarts <- computeRestarts(cond)
[16:04:44.096]                           for (restart in restarts) {
[16:04:44.096]                             name <- restart$name
[16:04:44.096]                             if (is.null(name)) 
[16:04:44.096]                               next
[16:04:44.096]                             if (!grepl(pattern, name)) 
[16:04:44.096]                               next
[16:04:44.096]                             invokeRestart(restart)
[16:04:44.096]                             muffled <- TRUE
[16:04:44.096]                             break
[16:04:44.096]                           }
[16:04:44.096]                         }
[16:04:44.096]                       }
[16:04:44.096]                       invisible(muffled)
[16:04:44.096]                     }
[16:04:44.096]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.096]                   }
[16:04:44.096]                 }
[16:04:44.096]                 else {
[16:04:44.096]                   if (TRUE) {
[16:04:44.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.096]                     {
[16:04:44.096]                       inherits <- base::inherits
[16:04:44.096]                       invokeRestart <- base::invokeRestart
[16:04:44.096]                       is.null <- base::is.null
[16:04:44.096]                       muffled <- FALSE
[16:04:44.096]                       if (inherits(cond, "message")) {
[16:04:44.096]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.096]                         if (muffled) 
[16:04:44.096]                           invokeRestart("muffleMessage")
[16:04:44.096]                       }
[16:04:44.096]                       else if (inherits(cond, "warning")) {
[16:04:44.096]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.096]                         if (muffled) 
[16:04:44.096]                           invokeRestart("muffleWarning")
[16:04:44.096]                       }
[16:04:44.096]                       else if (inherits(cond, "condition")) {
[16:04:44.096]                         if (!is.null(pattern)) {
[16:04:44.096]                           computeRestarts <- base::computeRestarts
[16:04:44.096]                           grepl <- base::grepl
[16:04:44.096]                           restarts <- computeRestarts(cond)
[16:04:44.096]                           for (restart in restarts) {
[16:04:44.096]                             name <- restart$name
[16:04:44.096]                             if (is.null(name)) 
[16:04:44.096]                               next
[16:04:44.096]                             if (!grepl(pattern, name)) 
[16:04:44.096]                               next
[16:04:44.096]                             invokeRestart(restart)
[16:04:44.096]                             muffled <- TRUE
[16:04:44.096]                             break
[16:04:44.096]                           }
[16:04:44.096]                         }
[16:04:44.096]                       }
[16:04:44.096]                       invisible(muffled)
[16:04:44.096]                     }
[16:04:44.096]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.096]                   }
[16:04:44.096]                 }
[16:04:44.096]             }
[16:04:44.096]         }))
[16:04:44.096]     }, error = function(ex) {
[16:04:44.096]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.096]                 ...future.rng), started = ...future.startTime, 
[16:04:44.096]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.096]             version = "1.8"), class = "FutureResult")
[16:04:44.096]     }, finally = {
[16:04:44.096]         if (!identical(...future.workdir, getwd())) 
[16:04:44.096]             setwd(...future.workdir)
[16:04:44.096]         {
[16:04:44.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.096]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.096]             }
[16:04:44.096]             base::options(...future.oldOptions)
[16:04:44.096]             if (.Platform$OS.type == "windows") {
[16:04:44.096]                 old_names <- names(...future.oldEnvVars)
[16:04:44.096]                 envs <- base::Sys.getenv()
[16:04:44.096]                 names <- names(envs)
[16:04:44.096]                 common <- intersect(names, old_names)
[16:04:44.096]                 added <- setdiff(names, old_names)
[16:04:44.096]                 removed <- setdiff(old_names, names)
[16:04:44.096]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.096]                   envs[common]]
[16:04:44.096]                 NAMES <- toupper(changed)
[16:04:44.096]                 args <- list()
[16:04:44.096]                 for (kk in seq_along(NAMES)) {
[16:04:44.096]                   name <- changed[[kk]]
[16:04:44.096]                   NAME <- NAMES[[kk]]
[16:04:44.096]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.096]                     next
[16:04:44.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.096]                 }
[16:04:44.096]                 NAMES <- toupper(added)
[16:04:44.096]                 for (kk in seq_along(NAMES)) {
[16:04:44.096]                   name <- added[[kk]]
[16:04:44.096]                   NAME <- NAMES[[kk]]
[16:04:44.096]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.096]                     next
[16:04:44.096]                   args[[name]] <- ""
[16:04:44.096]                 }
[16:04:44.096]                 NAMES <- toupper(removed)
[16:04:44.096]                 for (kk in seq_along(NAMES)) {
[16:04:44.096]                   name <- removed[[kk]]
[16:04:44.096]                   NAME <- NAMES[[kk]]
[16:04:44.096]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.096]                     next
[16:04:44.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.096]                 }
[16:04:44.096]                 if (length(args) > 0) 
[16:04:44.096]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.096]             }
[16:04:44.096]             else {
[16:04:44.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.096]             }
[16:04:44.096]             {
[16:04:44.096]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.096]                   0L) {
[16:04:44.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.096]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.096]                   base::options(opts)
[16:04:44.096]                 }
[16:04:44.096]                 {
[16:04:44.096]                   {
[16:04:44.096]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.096]                     NULL
[16:04:44.096]                   }
[16:04:44.096]                   options(future.plan = NULL)
[16:04:44.096]                   if (is.na(NA_character_)) 
[16:04:44.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.096]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.096]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.096]                     envir = parent.frame()) 
[16:04:44.096]                   {
[16:04:44.096]                     if (is.function(workers)) 
[16:04:44.096]                       workers <- workers()
[16:04:44.096]                     workers <- structure(as.integer(workers), 
[16:04:44.096]                       class = class(workers))
[16:04:44.096]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.096]                       workers >= 1)
[16:04:44.096]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.096]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.096]                     }
[16:04:44.096]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.096]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.096]                       envir = envir)
[16:04:44.096]                     if (!future$lazy) 
[16:04:44.096]                       future <- run(future)
[16:04:44.096]                     invisible(future)
[16:04:44.096]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.096]                 }
[16:04:44.096]             }
[16:04:44.096]         }
[16:04:44.096]     })
[16:04:44.096]     if (TRUE) {
[16:04:44.096]         base::sink(type = "output", split = FALSE)
[16:04:44.096]         if (TRUE) {
[16:04:44.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.096]         }
[16:04:44.096]         else {
[16:04:44.096]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.096]         }
[16:04:44.096]         base::close(...future.stdout)
[16:04:44.096]         ...future.stdout <- NULL
[16:04:44.096]     }
[16:04:44.096]     ...future.result$conditions <- ...future.conditions
[16:04:44.096]     ...future.result$finished <- base::Sys.time()
[16:04:44.096]     ...future.result
[16:04:44.096] }
[16:04:44.099] MultisessionFuture started
[16:04:44.099] - Launch lazy future ... done
[16:04:44.099] run() for ‘MultisessionFuture’ ... done
[16:04:44.100] getGlobalsAndPackages() ...
[16:04:44.100] Searching for globals...
[16:04:44.100] 
[16:04:44.100] Searching for globals ... DONE
[16:04:44.100] - globals: [0] <none>
[16:04:44.101] getGlobalsAndPackages() ... DONE
[16:04:44.101] run() for ‘Future’ ...
[16:04:44.101] - state: ‘created’
[16:04:44.101] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.116] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.117]   - Field: ‘node’
[16:04:44.117]   - Field: ‘label’
[16:04:44.117]   - Field: ‘local’
[16:04:44.117]   - Field: ‘owner’
[16:04:44.117]   - Field: ‘envir’
[16:04:44.117]   - Field: ‘workers’
[16:04:44.117]   - Field: ‘packages’
[16:04:44.118]   - Field: ‘gc’
[16:04:44.118]   - Field: ‘conditions’
[16:04:44.118]   - Field: ‘persistent’
[16:04:44.118]   - Field: ‘expr’
[16:04:44.118]   - Field: ‘uuid’
[16:04:44.118]   - Field: ‘seed’
[16:04:44.118]   - Field: ‘version’
[16:04:44.118]   - Field: ‘result’
[16:04:44.118]   - Field: ‘asynchronous’
[16:04:44.119]   - Field: ‘calls’
[16:04:44.119]   - Field: ‘globals’
[16:04:44.119]   - Field: ‘stdout’
[16:04:44.119]   - Field: ‘earlySignal’
[16:04:44.119]   - Field: ‘lazy’
[16:04:44.119]   - Field: ‘state’
[16:04:44.119] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.119] - Launch lazy future ...
[16:04:44.120] Packages needed by the future expression (n = 0): <none>
[16:04:44.120] Packages needed by future strategies (n = 0): <none>
[16:04:44.120] {
[16:04:44.120]     {
[16:04:44.120]         {
[16:04:44.120]             ...future.startTime <- base::Sys.time()
[16:04:44.120]             {
[16:04:44.120]                 {
[16:04:44.120]                   {
[16:04:44.120]                     {
[16:04:44.120]                       base::local({
[16:04:44.120]                         has_future <- base::requireNamespace("future", 
[16:04:44.120]                           quietly = TRUE)
[16:04:44.120]                         if (has_future) {
[16:04:44.120]                           ns <- base::getNamespace("future")
[16:04:44.120]                           version <- ns[[".package"]][["version"]]
[16:04:44.120]                           if (is.null(version)) 
[16:04:44.120]                             version <- utils::packageVersion("future")
[16:04:44.120]                         }
[16:04:44.120]                         else {
[16:04:44.120]                           version <- NULL
[16:04:44.120]                         }
[16:04:44.120]                         if (!has_future || version < "1.8.0") {
[16:04:44.120]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.120]                             "", base::R.version$version.string), 
[16:04:44.120]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.120]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.120]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.120]                               "release", "version")], collapse = " "), 
[16:04:44.120]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.120]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.120]                             info)
[16:04:44.120]                           info <- base::paste(info, collapse = "; ")
[16:04:44.120]                           if (!has_future) {
[16:04:44.120]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.120]                               info)
[16:04:44.120]                           }
[16:04:44.120]                           else {
[16:04:44.120]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.120]                               info, version)
[16:04:44.120]                           }
[16:04:44.120]                           base::stop(msg)
[16:04:44.120]                         }
[16:04:44.120]                       })
[16:04:44.120]                     }
[16:04:44.120]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.120]                     base::options(mc.cores = 1L)
[16:04:44.120]                   }
[16:04:44.120]                   options(future.plan = NULL)
[16:04:44.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.120]                 }
[16:04:44.120]                 ...future.workdir <- getwd()
[16:04:44.120]             }
[16:04:44.120]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.120]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.120]         }
[16:04:44.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.120]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.120]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.120]             base::names(...future.oldOptions))
[16:04:44.120]     }
[16:04:44.120]     if (FALSE) {
[16:04:44.120]     }
[16:04:44.120]     else {
[16:04:44.120]         if (TRUE) {
[16:04:44.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.120]                 open = "w")
[16:04:44.120]         }
[16:04:44.120]         else {
[16:04:44.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.120]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.120]         }
[16:04:44.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.120]             base::sink(type = "output", split = FALSE)
[16:04:44.120]             base::close(...future.stdout)
[16:04:44.120]         }, add = TRUE)
[16:04:44.120]     }
[16:04:44.120]     ...future.frame <- base::sys.nframe()
[16:04:44.120]     ...future.conditions <- base::list()
[16:04:44.120]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.120]     if (FALSE) {
[16:04:44.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.120]     }
[16:04:44.120]     ...future.result <- base::tryCatch({
[16:04:44.120]         base::withCallingHandlers({
[16:04:44.120]             ...future.value <- base::withVisible(base::local({
[16:04:44.120]                 ...future.makeSendCondition <- base::local({
[16:04:44.120]                   sendCondition <- NULL
[16:04:44.120]                   function(frame = 1L) {
[16:04:44.120]                     if (is.function(sendCondition)) 
[16:04:44.120]                       return(sendCondition)
[16:04:44.120]                     ns <- getNamespace("parallel")
[16:04:44.120]                     if (exists("sendData", mode = "function", 
[16:04:44.120]                       envir = ns)) {
[16:04:44.120]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.120]                         envir = ns)
[16:04:44.120]                       envir <- sys.frame(frame)
[16:04:44.120]                       master <- NULL
[16:04:44.120]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.120]                         !identical(envir, emptyenv())) {
[16:04:44.120]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.120]                           inherits = FALSE)) {
[16:04:44.120]                           master <- get("master", mode = "list", 
[16:04:44.120]                             envir = envir, inherits = FALSE)
[16:04:44.120]                           if (inherits(master, c("SOCKnode", 
[16:04:44.120]                             "SOCK0node"))) {
[16:04:44.120]                             sendCondition <<- function(cond) {
[16:04:44.120]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.120]                                 success = TRUE)
[16:04:44.120]                               parallel_sendData(master, data)
[16:04:44.120]                             }
[16:04:44.120]                             return(sendCondition)
[16:04:44.120]                           }
[16:04:44.120]                         }
[16:04:44.120]                         frame <- frame + 1L
[16:04:44.120]                         envir <- sys.frame(frame)
[16:04:44.120]                       }
[16:04:44.120]                     }
[16:04:44.120]                     sendCondition <<- function(cond) NULL
[16:04:44.120]                   }
[16:04:44.120]                 })
[16:04:44.120]                 withCallingHandlers({
[16:04:44.120]                   NULL
[16:04:44.120]                 }, immediateCondition = function(cond) {
[16:04:44.120]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.120]                   sendCondition(cond)
[16:04:44.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.120]                   {
[16:04:44.120]                     inherits <- base::inherits
[16:04:44.120]                     invokeRestart <- base::invokeRestart
[16:04:44.120]                     is.null <- base::is.null
[16:04:44.120]                     muffled <- FALSE
[16:04:44.120]                     if (inherits(cond, "message")) {
[16:04:44.120]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.120]                       if (muffled) 
[16:04:44.120]                         invokeRestart("muffleMessage")
[16:04:44.120]                     }
[16:04:44.120]                     else if (inherits(cond, "warning")) {
[16:04:44.120]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.120]                       if (muffled) 
[16:04:44.120]                         invokeRestart("muffleWarning")
[16:04:44.120]                     }
[16:04:44.120]                     else if (inherits(cond, "condition")) {
[16:04:44.120]                       if (!is.null(pattern)) {
[16:04:44.120]                         computeRestarts <- base::computeRestarts
[16:04:44.120]                         grepl <- base::grepl
[16:04:44.120]                         restarts <- computeRestarts(cond)
[16:04:44.120]                         for (restart in restarts) {
[16:04:44.120]                           name <- restart$name
[16:04:44.120]                           if (is.null(name)) 
[16:04:44.120]                             next
[16:04:44.120]                           if (!grepl(pattern, name)) 
[16:04:44.120]                             next
[16:04:44.120]                           invokeRestart(restart)
[16:04:44.120]                           muffled <- TRUE
[16:04:44.120]                           break
[16:04:44.120]                         }
[16:04:44.120]                       }
[16:04:44.120]                     }
[16:04:44.120]                     invisible(muffled)
[16:04:44.120]                   }
[16:04:44.120]                   muffleCondition(cond)
[16:04:44.120]                 })
[16:04:44.120]             }))
[16:04:44.120]             future::FutureResult(value = ...future.value$value, 
[16:04:44.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.120]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.120]                     ...future.globalenv.names))
[16:04:44.120]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.120]         }, condition = base::local({
[16:04:44.120]             c <- base::c
[16:04:44.120]             inherits <- base::inherits
[16:04:44.120]             invokeRestart <- base::invokeRestart
[16:04:44.120]             length <- base::length
[16:04:44.120]             list <- base::list
[16:04:44.120]             seq.int <- base::seq.int
[16:04:44.120]             signalCondition <- base::signalCondition
[16:04:44.120]             sys.calls <- base::sys.calls
[16:04:44.120]             `[[` <- base::`[[`
[16:04:44.120]             `+` <- base::`+`
[16:04:44.120]             `<<-` <- base::`<<-`
[16:04:44.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.120]                   3L)]
[16:04:44.120]             }
[16:04:44.120]             function(cond) {
[16:04:44.120]                 is_error <- inherits(cond, "error")
[16:04:44.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.120]                   NULL)
[16:04:44.120]                 if (is_error) {
[16:04:44.120]                   sessionInformation <- function() {
[16:04:44.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.120]                       search = base::search(), system = base::Sys.info())
[16:04:44.120]                   }
[16:04:44.120]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.120]                     cond$call), session = sessionInformation(), 
[16:04:44.120]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.120]                   signalCondition(cond)
[16:04:44.120]                 }
[16:04:44.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.120]                 "immediateCondition"))) {
[16:04:44.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.120]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.120]                   if (TRUE && !signal) {
[16:04:44.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.120]                     {
[16:04:44.120]                       inherits <- base::inherits
[16:04:44.120]                       invokeRestart <- base::invokeRestart
[16:04:44.120]                       is.null <- base::is.null
[16:04:44.120]                       muffled <- FALSE
[16:04:44.120]                       if (inherits(cond, "message")) {
[16:04:44.120]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.120]                         if (muffled) 
[16:04:44.120]                           invokeRestart("muffleMessage")
[16:04:44.120]                       }
[16:04:44.120]                       else if (inherits(cond, "warning")) {
[16:04:44.120]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.120]                         if (muffled) 
[16:04:44.120]                           invokeRestart("muffleWarning")
[16:04:44.120]                       }
[16:04:44.120]                       else if (inherits(cond, "condition")) {
[16:04:44.120]                         if (!is.null(pattern)) {
[16:04:44.120]                           computeRestarts <- base::computeRestarts
[16:04:44.120]                           grepl <- base::grepl
[16:04:44.120]                           restarts <- computeRestarts(cond)
[16:04:44.120]                           for (restart in restarts) {
[16:04:44.120]                             name <- restart$name
[16:04:44.120]                             if (is.null(name)) 
[16:04:44.120]                               next
[16:04:44.120]                             if (!grepl(pattern, name)) 
[16:04:44.120]                               next
[16:04:44.120]                             invokeRestart(restart)
[16:04:44.120]                             muffled <- TRUE
[16:04:44.120]                             break
[16:04:44.120]                           }
[16:04:44.120]                         }
[16:04:44.120]                       }
[16:04:44.120]                       invisible(muffled)
[16:04:44.120]                     }
[16:04:44.120]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.120]                   }
[16:04:44.120]                 }
[16:04:44.120]                 else {
[16:04:44.120]                   if (TRUE) {
[16:04:44.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.120]                     {
[16:04:44.120]                       inherits <- base::inherits
[16:04:44.120]                       invokeRestart <- base::invokeRestart
[16:04:44.120]                       is.null <- base::is.null
[16:04:44.120]                       muffled <- FALSE
[16:04:44.120]                       if (inherits(cond, "message")) {
[16:04:44.120]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.120]                         if (muffled) 
[16:04:44.120]                           invokeRestart("muffleMessage")
[16:04:44.120]                       }
[16:04:44.120]                       else if (inherits(cond, "warning")) {
[16:04:44.120]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.120]                         if (muffled) 
[16:04:44.120]                           invokeRestart("muffleWarning")
[16:04:44.120]                       }
[16:04:44.120]                       else if (inherits(cond, "condition")) {
[16:04:44.120]                         if (!is.null(pattern)) {
[16:04:44.120]                           computeRestarts <- base::computeRestarts
[16:04:44.120]                           grepl <- base::grepl
[16:04:44.120]                           restarts <- computeRestarts(cond)
[16:04:44.120]                           for (restart in restarts) {
[16:04:44.120]                             name <- restart$name
[16:04:44.120]                             if (is.null(name)) 
[16:04:44.120]                               next
[16:04:44.120]                             if (!grepl(pattern, name)) 
[16:04:44.120]                               next
[16:04:44.120]                             invokeRestart(restart)
[16:04:44.120]                             muffled <- TRUE
[16:04:44.120]                             break
[16:04:44.120]                           }
[16:04:44.120]                         }
[16:04:44.120]                       }
[16:04:44.120]                       invisible(muffled)
[16:04:44.120]                     }
[16:04:44.120]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.120]                   }
[16:04:44.120]                 }
[16:04:44.120]             }
[16:04:44.120]         }))
[16:04:44.120]     }, error = function(ex) {
[16:04:44.120]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.120]                 ...future.rng), started = ...future.startTime, 
[16:04:44.120]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.120]             version = "1.8"), class = "FutureResult")
[16:04:44.120]     }, finally = {
[16:04:44.120]         if (!identical(...future.workdir, getwd())) 
[16:04:44.120]             setwd(...future.workdir)
[16:04:44.120]         {
[16:04:44.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.120]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.120]             }
[16:04:44.120]             base::options(...future.oldOptions)
[16:04:44.120]             if (.Platform$OS.type == "windows") {
[16:04:44.120]                 old_names <- names(...future.oldEnvVars)
[16:04:44.120]                 envs <- base::Sys.getenv()
[16:04:44.120]                 names <- names(envs)
[16:04:44.120]                 common <- intersect(names, old_names)
[16:04:44.120]                 added <- setdiff(names, old_names)
[16:04:44.120]                 removed <- setdiff(old_names, names)
[16:04:44.120]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.120]                   envs[common]]
[16:04:44.120]                 NAMES <- toupper(changed)
[16:04:44.120]                 args <- list()
[16:04:44.120]                 for (kk in seq_along(NAMES)) {
[16:04:44.120]                   name <- changed[[kk]]
[16:04:44.120]                   NAME <- NAMES[[kk]]
[16:04:44.120]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.120]                     next
[16:04:44.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.120]                 }
[16:04:44.120]                 NAMES <- toupper(added)
[16:04:44.120]                 for (kk in seq_along(NAMES)) {
[16:04:44.120]                   name <- added[[kk]]
[16:04:44.120]                   NAME <- NAMES[[kk]]
[16:04:44.120]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.120]                     next
[16:04:44.120]                   args[[name]] <- ""
[16:04:44.120]                 }
[16:04:44.120]                 NAMES <- toupper(removed)
[16:04:44.120]                 for (kk in seq_along(NAMES)) {
[16:04:44.120]                   name <- removed[[kk]]
[16:04:44.120]                   NAME <- NAMES[[kk]]
[16:04:44.120]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.120]                     next
[16:04:44.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.120]                 }
[16:04:44.120]                 if (length(args) > 0) 
[16:04:44.120]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.120]             }
[16:04:44.120]             else {
[16:04:44.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.120]             }
[16:04:44.120]             {
[16:04:44.120]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.120]                   0L) {
[16:04:44.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.120]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.120]                   base::options(opts)
[16:04:44.120]                 }
[16:04:44.120]                 {
[16:04:44.120]                   {
[16:04:44.120]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.120]                     NULL
[16:04:44.120]                   }
[16:04:44.120]                   options(future.plan = NULL)
[16:04:44.120]                   if (is.na(NA_character_)) 
[16:04:44.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.120]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.120]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.120]                     envir = parent.frame()) 
[16:04:44.120]                   {
[16:04:44.120]                     if (is.function(workers)) 
[16:04:44.120]                       workers <- workers()
[16:04:44.120]                     workers <- structure(as.integer(workers), 
[16:04:44.120]                       class = class(workers))
[16:04:44.120]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.120]                       workers >= 1)
[16:04:44.120]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.120]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.120]                     }
[16:04:44.120]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.120]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.120]                       envir = envir)
[16:04:44.120]                     if (!future$lazy) 
[16:04:44.120]                       future <- run(future)
[16:04:44.120]                     invisible(future)
[16:04:44.120]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.120]                 }
[16:04:44.120]             }
[16:04:44.120]         }
[16:04:44.120]     })
[16:04:44.120]     if (TRUE) {
[16:04:44.120]         base::sink(type = "output", split = FALSE)
[16:04:44.120]         if (TRUE) {
[16:04:44.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.120]         }
[16:04:44.120]         else {
[16:04:44.120]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.120]         }
[16:04:44.120]         base::close(...future.stdout)
[16:04:44.120]         ...future.stdout <- NULL
[16:04:44.120]     }
[16:04:44.120]     ...future.result$conditions <- ...future.conditions
[16:04:44.120]     ...future.result$finished <- base::Sys.time()
[16:04:44.120]     ...future.result
[16:04:44.120] }
[16:04:44.176] MultisessionFuture started
[16:04:44.176] - Launch lazy future ... done
[16:04:44.177] run() for ‘MultisessionFuture’ ... done
[16:04:44.177] getGlobalsAndPackages() ...
[16:04:44.177] Searching for globals...
[16:04:44.178] - globals found: [1] ‘{’
[16:04:44.178] Searching for globals ... DONE
[16:04:44.178] Resolving globals: FALSE
[16:04:44.178] 
[16:04:44.179] 
[16:04:44.179] getGlobalsAndPackages() ... DONE
[16:04:44.179] run() for ‘Future’ ...
[16:04:44.179] - state: ‘created’
[16:04:44.179] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.193] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.194]   - Field: ‘node’
[16:04:44.194]   - Field: ‘label’
[16:04:44.194]   - Field: ‘local’
[16:04:44.194]   - Field: ‘owner’
[16:04:44.194]   - Field: ‘envir’
[16:04:44.194]   - Field: ‘workers’
[16:04:44.194]   - Field: ‘packages’
[16:04:44.194]   - Field: ‘gc’
[16:04:44.195]   - Field: ‘conditions’
[16:04:44.195]   - Field: ‘persistent’
[16:04:44.195]   - Field: ‘expr’
[16:04:44.195]   - Field: ‘uuid’
[16:04:44.195]   - Field: ‘seed’
[16:04:44.195]   - Field: ‘version’
[16:04:44.195]   - Field: ‘result’
[16:04:44.195]   - Field: ‘asynchronous’
[16:04:44.195]   - Field: ‘calls’
[16:04:44.195]   - Field: ‘globals’
[16:04:44.195]   - Field: ‘stdout’
[16:04:44.196]   - Field: ‘earlySignal’
[16:04:44.196]   - Field: ‘lazy’
[16:04:44.196]   - Field: ‘state’
[16:04:44.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.196] - Launch lazy future ...
[16:04:44.196] Packages needed by the future expression (n = 0): <none>
[16:04:44.196] Packages needed by future strategies (n = 0): <none>
[16:04:44.197] {
[16:04:44.197]     {
[16:04:44.197]         {
[16:04:44.197]             ...future.startTime <- base::Sys.time()
[16:04:44.197]             {
[16:04:44.197]                 {
[16:04:44.197]                   {
[16:04:44.197]                     {
[16:04:44.197]                       base::local({
[16:04:44.197]                         has_future <- base::requireNamespace("future", 
[16:04:44.197]                           quietly = TRUE)
[16:04:44.197]                         if (has_future) {
[16:04:44.197]                           ns <- base::getNamespace("future")
[16:04:44.197]                           version <- ns[[".package"]][["version"]]
[16:04:44.197]                           if (is.null(version)) 
[16:04:44.197]                             version <- utils::packageVersion("future")
[16:04:44.197]                         }
[16:04:44.197]                         else {
[16:04:44.197]                           version <- NULL
[16:04:44.197]                         }
[16:04:44.197]                         if (!has_future || version < "1.8.0") {
[16:04:44.197]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.197]                             "", base::R.version$version.string), 
[16:04:44.197]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.197]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.197]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.197]                               "release", "version")], collapse = " "), 
[16:04:44.197]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.197]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.197]                             info)
[16:04:44.197]                           info <- base::paste(info, collapse = "; ")
[16:04:44.197]                           if (!has_future) {
[16:04:44.197]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.197]                               info)
[16:04:44.197]                           }
[16:04:44.197]                           else {
[16:04:44.197]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.197]                               info, version)
[16:04:44.197]                           }
[16:04:44.197]                           base::stop(msg)
[16:04:44.197]                         }
[16:04:44.197]                       })
[16:04:44.197]                     }
[16:04:44.197]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.197]                     base::options(mc.cores = 1L)
[16:04:44.197]                   }
[16:04:44.197]                   options(future.plan = NULL)
[16:04:44.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.197]                 }
[16:04:44.197]                 ...future.workdir <- getwd()
[16:04:44.197]             }
[16:04:44.197]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.197]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.197]         }
[16:04:44.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.197]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.197]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.197]             base::names(...future.oldOptions))
[16:04:44.197]     }
[16:04:44.197]     if (FALSE) {
[16:04:44.197]     }
[16:04:44.197]     else {
[16:04:44.197]         if (TRUE) {
[16:04:44.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.197]                 open = "w")
[16:04:44.197]         }
[16:04:44.197]         else {
[16:04:44.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.197]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.197]         }
[16:04:44.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.197]             base::sink(type = "output", split = FALSE)
[16:04:44.197]             base::close(...future.stdout)
[16:04:44.197]         }, add = TRUE)
[16:04:44.197]     }
[16:04:44.197]     ...future.frame <- base::sys.nframe()
[16:04:44.197]     ...future.conditions <- base::list()
[16:04:44.197]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.197]     if (FALSE) {
[16:04:44.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.197]     }
[16:04:44.197]     ...future.result <- base::tryCatch({
[16:04:44.197]         base::withCallingHandlers({
[16:04:44.197]             ...future.value <- base::withVisible(base::local({
[16:04:44.197]                 ...future.makeSendCondition <- base::local({
[16:04:44.197]                   sendCondition <- NULL
[16:04:44.197]                   function(frame = 1L) {
[16:04:44.197]                     if (is.function(sendCondition)) 
[16:04:44.197]                       return(sendCondition)
[16:04:44.197]                     ns <- getNamespace("parallel")
[16:04:44.197]                     if (exists("sendData", mode = "function", 
[16:04:44.197]                       envir = ns)) {
[16:04:44.197]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.197]                         envir = ns)
[16:04:44.197]                       envir <- sys.frame(frame)
[16:04:44.197]                       master <- NULL
[16:04:44.197]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.197]                         !identical(envir, emptyenv())) {
[16:04:44.197]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.197]                           inherits = FALSE)) {
[16:04:44.197]                           master <- get("master", mode = "list", 
[16:04:44.197]                             envir = envir, inherits = FALSE)
[16:04:44.197]                           if (inherits(master, c("SOCKnode", 
[16:04:44.197]                             "SOCK0node"))) {
[16:04:44.197]                             sendCondition <<- function(cond) {
[16:04:44.197]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.197]                                 success = TRUE)
[16:04:44.197]                               parallel_sendData(master, data)
[16:04:44.197]                             }
[16:04:44.197]                             return(sendCondition)
[16:04:44.197]                           }
[16:04:44.197]                         }
[16:04:44.197]                         frame <- frame + 1L
[16:04:44.197]                         envir <- sys.frame(frame)
[16:04:44.197]                       }
[16:04:44.197]                     }
[16:04:44.197]                     sendCondition <<- function(cond) NULL
[16:04:44.197]                   }
[16:04:44.197]                 })
[16:04:44.197]                 withCallingHandlers({
[16:04:44.197]                   {
[16:04:44.197]                     4
[16:04:44.197]                   }
[16:04:44.197]                 }, immediateCondition = function(cond) {
[16:04:44.197]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.197]                   sendCondition(cond)
[16:04:44.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.197]                   {
[16:04:44.197]                     inherits <- base::inherits
[16:04:44.197]                     invokeRestart <- base::invokeRestart
[16:04:44.197]                     is.null <- base::is.null
[16:04:44.197]                     muffled <- FALSE
[16:04:44.197]                     if (inherits(cond, "message")) {
[16:04:44.197]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.197]                       if (muffled) 
[16:04:44.197]                         invokeRestart("muffleMessage")
[16:04:44.197]                     }
[16:04:44.197]                     else if (inherits(cond, "warning")) {
[16:04:44.197]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.197]                       if (muffled) 
[16:04:44.197]                         invokeRestart("muffleWarning")
[16:04:44.197]                     }
[16:04:44.197]                     else if (inherits(cond, "condition")) {
[16:04:44.197]                       if (!is.null(pattern)) {
[16:04:44.197]                         computeRestarts <- base::computeRestarts
[16:04:44.197]                         grepl <- base::grepl
[16:04:44.197]                         restarts <- computeRestarts(cond)
[16:04:44.197]                         for (restart in restarts) {
[16:04:44.197]                           name <- restart$name
[16:04:44.197]                           if (is.null(name)) 
[16:04:44.197]                             next
[16:04:44.197]                           if (!grepl(pattern, name)) 
[16:04:44.197]                             next
[16:04:44.197]                           invokeRestart(restart)
[16:04:44.197]                           muffled <- TRUE
[16:04:44.197]                           break
[16:04:44.197]                         }
[16:04:44.197]                       }
[16:04:44.197]                     }
[16:04:44.197]                     invisible(muffled)
[16:04:44.197]                   }
[16:04:44.197]                   muffleCondition(cond)
[16:04:44.197]                 })
[16:04:44.197]             }))
[16:04:44.197]             future::FutureResult(value = ...future.value$value, 
[16:04:44.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.197]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.197]                     ...future.globalenv.names))
[16:04:44.197]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.197]         }, condition = base::local({
[16:04:44.197]             c <- base::c
[16:04:44.197]             inherits <- base::inherits
[16:04:44.197]             invokeRestart <- base::invokeRestart
[16:04:44.197]             length <- base::length
[16:04:44.197]             list <- base::list
[16:04:44.197]             seq.int <- base::seq.int
[16:04:44.197]             signalCondition <- base::signalCondition
[16:04:44.197]             sys.calls <- base::sys.calls
[16:04:44.197]             `[[` <- base::`[[`
[16:04:44.197]             `+` <- base::`+`
[16:04:44.197]             `<<-` <- base::`<<-`
[16:04:44.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.197]                   3L)]
[16:04:44.197]             }
[16:04:44.197]             function(cond) {
[16:04:44.197]                 is_error <- inherits(cond, "error")
[16:04:44.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.197]                   NULL)
[16:04:44.197]                 if (is_error) {
[16:04:44.197]                   sessionInformation <- function() {
[16:04:44.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.197]                       search = base::search(), system = base::Sys.info())
[16:04:44.197]                   }
[16:04:44.197]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.197]                     cond$call), session = sessionInformation(), 
[16:04:44.197]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.197]                   signalCondition(cond)
[16:04:44.197]                 }
[16:04:44.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.197]                 "immediateCondition"))) {
[16:04:44.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.197]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.197]                   if (TRUE && !signal) {
[16:04:44.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.197]                     {
[16:04:44.197]                       inherits <- base::inherits
[16:04:44.197]                       invokeRestart <- base::invokeRestart
[16:04:44.197]                       is.null <- base::is.null
[16:04:44.197]                       muffled <- FALSE
[16:04:44.197]                       if (inherits(cond, "message")) {
[16:04:44.197]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.197]                         if (muffled) 
[16:04:44.197]                           invokeRestart("muffleMessage")
[16:04:44.197]                       }
[16:04:44.197]                       else if (inherits(cond, "warning")) {
[16:04:44.197]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.197]                         if (muffled) 
[16:04:44.197]                           invokeRestart("muffleWarning")
[16:04:44.197]                       }
[16:04:44.197]                       else if (inherits(cond, "condition")) {
[16:04:44.197]                         if (!is.null(pattern)) {
[16:04:44.197]                           computeRestarts <- base::computeRestarts
[16:04:44.197]                           grepl <- base::grepl
[16:04:44.197]                           restarts <- computeRestarts(cond)
[16:04:44.197]                           for (restart in restarts) {
[16:04:44.197]                             name <- restart$name
[16:04:44.197]                             if (is.null(name)) 
[16:04:44.197]                               next
[16:04:44.197]                             if (!grepl(pattern, name)) 
[16:04:44.197]                               next
[16:04:44.197]                             invokeRestart(restart)
[16:04:44.197]                             muffled <- TRUE
[16:04:44.197]                             break
[16:04:44.197]                           }
[16:04:44.197]                         }
[16:04:44.197]                       }
[16:04:44.197]                       invisible(muffled)
[16:04:44.197]                     }
[16:04:44.197]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.197]                   }
[16:04:44.197]                 }
[16:04:44.197]                 else {
[16:04:44.197]                   if (TRUE) {
[16:04:44.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.197]                     {
[16:04:44.197]                       inherits <- base::inherits
[16:04:44.197]                       invokeRestart <- base::invokeRestart
[16:04:44.197]                       is.null <- base::is.null
[16:04:44.197]                       muffled <- FALSE
[16:04:44.197]                       if (inherits(cond, "message")) {
[16:04:44.197]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.197]                         if (muffled) 
[16:04:44.197]                           invokeRestart("muffleMessage")
[16:04:44.197]                       }
[16:04:44.197]                       else if (inherits(cond, "warning")) {
[16:04:44.197]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.197]                         if (muffled) 
[16:04:44.197]                           invokeRestart("muffleWarning")
[16:04:44.197]                       }
[16:04:44.197]                       else if (inherits(cond, "condition")) {
[16:04:44.197]                         if (!is.null(pattern)) {
[16:04:44.197]                           computeRestarts <- base::computeRestarts
[16:04:44.197]                           grepl <- base::grepl
[16:04:44.197]                           restarts <- computeRestarts(cond)
[16:04:44.197]                           for (restart in restarts) {
[16:04:44.197]                             name <- restart$name
[16:04:44.197]                             if (is.null(name)) 
[16:04:44.197]                               next
[16:04:44.197]                             if (!grepl(pattern, name)) 
[16:04:44.197]                               next
[16:04:44.197]                             invokeRestart(restart)
[16:04:44.197]                             muffled <- TRUE
[16:04:44.197]                             break
[16:04:44.197]                           }
[16:04:44.197]                         }
[16:04:44.197]                       }
[16:04:44.197]                       invisible(muffled)
[16:04:44.197]                     }
[16:04:44.197]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.197]                   }
[16:04:44.197]                 }
[16:04:44.197]             }
[16:04:44.197]         }))
[16:04:44.197]     }, error = function(ex) {
[16:04:44.197]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.197]                 ...future.rng), started = ...future.startTime, 
[16:04:44.197]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.197]             version = "1.8"), class = "FutureResult")
[16:04:44.197]     }, finally = {
[16:04:44.197]         if (!identical(...future.workdir, getwd())) 
[16:04:44.197]             setwd(...future.workdir)
[16:04:44.197]         {
[16:04:44.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.197]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.197]             }
[16:04:44.197]             base::options(...future.oldOptions)
[16:04:44.197]             if (.Platform$OS.type == "windows") {
[16:04:44.197]                 old_names <- names(...future.oldEnvVars)
[16:04:44.197]                 envs <- base::Sys.getenv()
[16:04:44.197]                 names <- names(envs)
[16:04:44.197]                 common <- intersect(names, old_names)
[16:04:44.197]                 added <- setdiff(names, old_names)
[16:04:44.197]                 removed <- setdiff(old_names, names)
[16:04:44.197]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.197]                   envs[common]]
[16:04:44.197]                 NAMES <- toupper(changed)
[16:04:44.197]                 args <- list()
[16:04:44.197]                 for (kk in seq_along(NAMES)) {
[16:04:44.197]                   name <- changed[[kk]]
[16:04:44.197]                   NAME <- NAMES[[kk]]
[16:04:44.197]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.197]                     next
[16:04:44.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.197]                 }
[16:04:44.197]                 NAMES <- toupper(added)
[16:04:44.197]                 for (kk in seq_along(NAMES)) {
[16:04:44.197]                   name <- added[[kk]]
[16:04:44.197]                   NAME <- NAMES[[kk]]
[16:04:44.197]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.197]                     next
[16:04:44.197]                   args[[name]] <- ""
[16:04:44.197]                 }
[16:04:44.197]                 NAMES <- toupper(removed)
[16:04:44.197]                 for (kk in seq_along(NAMES)) {
[16:04:44.197]                   name <- removed[[kk]]
[16:04:44.197]                   NAME <- NAMES[[kk]]
[16:04:44.197]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.197]                     next
[16:04:44.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.197]                 }
[16:04:44.197]                 if (length(args) > 0) 
[16:04:44.197]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.197]             }
[16:04:44.197]             else {
[16:04:44.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.197]             }
[16:04:44.197]             {
[16:04:44.197]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.197]                   0L) {
[16:04:44.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.197]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.197]                   base::options(opts)
[16:04:44.197]                 }
[16:04:44.197]                 {
[16:04:44.197]                   {
[16:04:44.197]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.197]                     NULL
[16:04:44.197]                   }
[16:04:44.197]                   options(future.plan = NULL)
[16:04:44.197]                   if (is.na(NA_character_)) 
[16:04:44.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.197]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.197]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.197]                     envir = parent.frame()) 
[16:04:44.197]                   {
[16:04:44.197]                     if (is.function(workers)) 
[16:04:44.197]                       workers <- workers()
[16:04:44.197]                     workers <- structure(as.integer(workers), 
[16:04:44.197]                       class = class(workers))
[16:04:44.197]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.197]                       workers >= 1)
[16:04:44.197]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.197]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.197]                     }
[16:04:44.197]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.197]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.197]                       envir = envir)
[16:04:44.197]                     if (!future$lazy) 
[16:04:44.197]                       future <- run(future)
[16:04:44.197]                     invisible(future)
[16:04:44.197]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.197]                 }
[16:04:44.197]             }
[16:04:44.197]         }
[16:04:44.197]     })
[16:04:44.197]     if (TRUE) {
[16:04:44.197]         base::sink(type = "output", split = FALSE)
[16:04:44.197]         if (TRUE) {
[16:04:44.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.197]         }
[16:04:44.197]         else {
[16:04:44.197]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.197]         }
[16:04:44.197]         base::close(...future.stdout)
[16:04:44.197]         ...future.stdout <- NULL
[16:04:44.197]     }
[16:04:44.197]     ...future.result$conditions <- ...future.conditions
[16:04:44.197]     ...future.result$finished <- base::Sys.time()
[16:04:44.197]     ...future.result
[16:04:44.197] }
[16:04:44.199] Poll #1 (0): usedNodes() = 2, workers = 2
[16:04:44.210] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.210] - Validating connection of MultisessionFuture
[16:04:44.210] - received message: FutureResult
[16:04:44.210] - Received FutureResult
[16:04:44.211] - Erased future from FutureRegistry
[16:04:44.211] result() for ClusterFuture ...
[16:04:44.211] - result already collected: FutureResult
[16:04:44.211] result() for ClusterFuture ... done
[16:04:44.211] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:44.211] result() for ClusterFuture ...
[16:04:44.211] - result already collected: FutureResult
[16:04:44.211] result() for ClusterFuture ... done
[16:04:44.211] result() for ClusterFuture ...
[16:04:44.212] - result already collected: FutureResult
[16:04:44.212] result() for ClusterFuture ... done
[16:04:44.213] MultisessionFuture started
[16:04:44.213] - Launch lazy future ... done
[16:04:44.214] run() for ‘MultisessionFuture’ ... done
<environment: 0x55874dacb088> 
<environment: 0x55874eef9438> 
[16:04:44.222] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.223] - Validating connection of MultisessionFuture
[16:04:44.223] - received message: FutureResult
[16:04:44.223] - Received FutureResult
[16:04:44.223] - Erased future from FutureRegistry
[16:04:44.223] result() for ClusterFuture ...
[16:04:44.223] - result already collected: FutureResult
[16:04:44.223] result() for ClusterFuture ... done
[16:04:44.224] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:44.224] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.224] - Validating connection of MultisessionFuture
[16:04:44.224] - received message: FutureResult
[16:04:44.224] - Received FutureResult
[16:04:44.225] - Erased future from FutureRegistry
[16:04:44.225] result() for ClusterFuture ...
[16:04:44.225] - result already collected: FutureResult
[16:04:44.225] result() for ClusterFuture ... done
[16:04:44.225] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:44.226] resolve() on environment ...
[16:04:44.226]  recursive: 0
[16:04:44.227]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:44.227] signalConditionsASAP(numeric, pos=1) ...
[16:04:44.227] - nx: 4
[16:04:44.227] - relay: TRUE
[16:04:44.227] - stdout: TRUE
[16:04:44.227] - signal: TRUE
[16:04:44.227] - resignal: FALSE
[16:04:44.227] - force: TRUE
[16:04:44.227] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.228] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.228]  - until=2
[16:04:44.228]  - relaying element #2
[16:04:44.228] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:44.228] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.228] signalConditionsASAP(NULL, pos=1) ... done
[16:04:44.228]  length: 3 (resolved future 1)
[16:04:44.228] Future #2
[16:04:44.228] result() for ClusterFuture ...
[16:04:44.228] - result already collected: FutureResult
[16:04:44.228] result() for ClusterFuture ... done
[16:04:44.229] result() for ClusterFuture ...
[16:04:44.229] - result already collected: FutureResult
[16:04:44.229] result() for ClusterFuture ... done
[16:04:44.229] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:44.229] - nx: 4
[16:04:44.229] - relay: TRUE
[16:04:44.229] - stdout: TRUE
[16:04:44.229] - signal: TRUE
[16:04:44.229] - resignal: FALSE
[16:04:44.229] - force: TRUE
[16:04:44.229] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:44.229] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.230]  - until=2
[16:04:44.230]  - relaying element #2
[16:04:44.230] result() for ClusterFuture ...
[16:04:44.230] - result already collected: FutureResult
[16:04:44.230] result() for ClusterFuture ... done
[16:04:44.230] result() for ClusterFuture ...
[16:04:44.230] - result already collected: FutureResult
[16:04:44.230] result() for ClusterFuture ... done
[16:04:44.230] result() for ClusterFuture ...
[16:04:44.230] - result already collected: FutureResult
[16:04:44.230] result() for ClusterFuture ... done
[16:04:44.231] result() for ClusterFuture ...
[16:04:44.231] - result already collected: FutureResult
[16:04:44.231] result() for ClusterFuture ... done
[16:04:44.231] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:44.231] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:44.231] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:44.231]  length: 2 (resolved future 2)
[16:04:44.231] Future #3
[16:04:44.231] result() for ClusterFuture ...
[16:04:44.231] - result already collected: FutureResult
[16:04:44.232] result() for ClusterFuture ... done
[16:04:44.232] result() for ClusterFuture ...
[16:04:44.232] - result already collected: FutureResult
[16:04:44.232] result() for ClusterFuture ... done
[16:04:44.232] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:44.232] - nx: 4
[16:04:44.232] - relay: TRUE
[16:04:44.232] - stdout: TRUE
[16:04:44.232] - signal: TRUE
[16:04:44.232] - resignal: FALSE
[16:04:44.232] - force: TRUE
[16:04:44.232] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:44.233] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:44.233]  - until=3
[16:04:44.233]  - relaying element #3
[16:04:44.233] result() for ClusterFuture ...
[16:04:44.233] - result already collected: FutureResult
[16:04:44.233] result() for ClusterFuture ... done
[16:04:44.233] result() for ClusterFuture ...
[16:04:44.233] - result already collected: FutureResult
[16:04:44.233] result() for ClusterFuture ... done
[16:04:44.233] result() for ClusterFuture ...
[16:04:44.233] - result already collected: FutureResult
[16:04:44.234] result() for ClusterFuture ... done
[16:04:44.234] result() for ClusterFuture ...
[16:04:44.234] - result already collected: FutureResult
[16:04:44.234] result() for ClusterFuture ... done
[16:04:44.234] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:44.234] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:44.234] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:44.234]  length: 1 (resolved future 3)
[16:04:44.234] Future #4
[16:04:44.234] result() for ClusterFuture ...
[16:04:44.234] - result already collected: FutureResult
[16:04:44.235] result() for ClusterFuture ... done
[16:04:44.235] result() for ClusterFuture ...
[16:04:44.235] - result already collected: FutureResult
[16:04:44.235] result() for ClusterFuture ... done
[16:04:44.235] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:04:44.235] - nx: 4
[16:04:44.235] - relay: TRUE
[16:04:44.235] - stdout: TRUE
[16:04:44.235] - signal: TRUE
[16:04:44.235] - resignal: FALSE
[16:04:44.235] - force: TRUE
[16:04:44.235] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:44.236] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:44.236]  - until=4
[16:04:44.236]  - relaying element #4
[16:04:44.236] result() for ClusterFuture ...
[16:04:44.236] - result already collected: FutureResult
[16:04:44.236] result() for ClusterFuture ... done
[16:04:44.236] result() for ClusterFuture ...
[16:04:44.236] - result already collected: FutureResult
[16:04:44.236] result() for ClusterFuture ... done
[16:04:44.236] result() for ClusterFuture ...
[16:04:44.237] - result already collected: FutureResult
[16:04:44.237] result() for ClusterFuture ... done
[16:04:44.237] result() for ClusterFuture ...
[16:04:44.237] - result already collected: FutureResult
[16:04:44.237] result() for ClusterFuture ... done
[16:04:44.237] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.237] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:44.237] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:04:44.237]  length: 0 (resolved future 4)
[16:04:44.237] Relaying remaining futures
[16:04:44.237] signalConditionsASAP(NULL, pos=0) ...
[16:04:44.237] - nx: 4
[16:04:44.238] - relay: TRUE
[16:04:44.238] - stdout: TRUE
[16:04:44.238] - signal: TRUE
[16:04:44.238] - resignal: FALSE
[16:04:44.238] - force: TRUE
[16:04:44.238] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.238] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:44.238] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.238] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:44.238] signalConditionsASAP(NULL, pos=0) ... done
[16:04:44.238] resolve() on environment ... DONE
[16:04:44.239] result() for ClusterFuture ...
[16:04:44.239] - result already collected: FutureResult
[16:04:44.239] result() for ClusterFuture ... done
[16:04:44.239] result() for ClusterFuture ...
[16:04:44.239] - result already collected: FutureResult
[16:04:44.239] result() for ClusterFuture ... done
[16:04:44.239] result() for ClusterFuture ...
[16:04:44.239] - result already collected: FutureResult
[16:04:44.239] result() for ClusterFuture ... done
[16:04:44.239] result() for ClusterFuture ...
[16:04:44.239] - result already collected: FutureResult
[16:04:44.240] result() for ClusterFuture ... done
[16:04:44.240] result() for ClusterFuture ...
[16:04:44.240] - result already collected: FutureResult
[16:04:44.240] result() for ClusterFuture ... done
[16:04:44.240] result() for ClusterFuture ...
[16:04:44.240] - result already collected: FutureResult
[16:04:44.240] result() for ClusterFuture ... done
<environment: 0x55874f14f358> 
Dimensions: c(1, 6)
[16:04:44.240] getGlobalsAndPackages() ...
[16:04:44.241] Searching for globals...
[16:04:44.241] 
[16:04:44.241] Searching for globals ... DONE
[16:04:44.241] - globals: [0] <none>
[16:04:44.241] getGlobalsAndPackages() ... DONE
[16:04:44.241] run() for ‘Future’ ...
[16:04:44.242] - state: ‘created’
[16:04:44.242] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.256] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.256]   - Field: ‘node’
[16:04:44.256]   - Field: ‘label’
[16:04:44.256]   - Field: ‘local’
[16:04:44.256]   - Field: ‘owner’
[16:04:44.256]   - Field: ‘envir’
[16:04:44.256]   - Field: ‘workers’
[16:04:44.257]   - Field: ‘packages’
[16:04:44.257]   - Field: ‘gc’
[16:04:44.257]   - Field: ‘conditions’
[16:04:44.257]   - Field: ‘persistent’
[16:04:44.257]   - Field: ‘expr’
[16:04:44.257]   - Field: ‘uuid’
[16:04:44.257]   - Field: ‘seed’
[16:04:44.257]   - Field: ‘version’
[16:04:44.257]   - Field: ‘result’
[16:04:44.257]   - Field: ‘asynchronous’
[16:04:44.257]   - Field: ‘calls’
[16:04:44.258]   - Field: ‘globals’
[16:04:44.258]   - Field: ‘stdout’
[16:04:44.258]   - Field: ‘earlySignal’
[16:04:44.258]   - Field: ‘lazy’
[16:04:44.258]   - Field: ‘state’
[16:04:44.258] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.258] - Launch lazy future ...
[16:04:44.258] Packages needed by the future expression (n = 0): <none>
[16:04:44.259] Packages needed by future strategies (n = 0): <none>
[16:04:44.259] {
[16:04:44.259]     {
[16:04:44.259]         {
[16:04:44.259]             ...future.startTime <- base::Sys.time()
[16:04:44.259]             {
[16:04:44.259]                 {
[16:04:44.259]                   {
[16:04:44.259]                     {
[16:04:44.259]                       base::local({
[16:04:44.259]                         has_future <- base::requireNamespace("future", 
[16:04:44.259]                           quietly = TRUE)
[16:04:44.259]                         if (has_future) {
[16:04:44.259]                           ns <- base::getNamespace("future")
[16:04:44.259]                           version <- ns[[".package"]][["version"]]
[16:04:44.259]                           if (is.null(version)) 
[16:04:44.259]                             version <- utils::packageVersion("future")
[16:04:44.259]                         }
[16:04:44.259]                         else {
[16:04:44.259]                           version <- NULL
[16:04:44.259]                         }
[16:04:44.259]                         if (!has_future || version < "1.8.0") {
[16:04:44.259]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.259]                             "", base::R.version$version.string), 
[16:04:44.259]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.259]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.259]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.259]                               "release", "version")], collapse = " "), 
[16:04:44.259]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.259]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.259]                             info)
[16:04:44.259]                           info <- base::paste(info, collapse = "; ")
[16:04:44.259]                           if (!has_future) {
[16:04:44.259]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.259]                               info)
[16:04:44.259]                           }
[16:04:44.259]                           else {
[16:04:44.259]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.259]                               info, version)
[16:04:44.259]                           }
[16:04:44.259]                           base::stop(msg)
[16:04:44.259]                         }
[16:04:44.259]                       })
[16:04:44.259]                     }
[16:04:44.259]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.259]                     base::options(mc.cores = 1L)
[16:04:44.259]                   }
[16:04:44.259]                   options(future.plan = NULL)
[16:04:44.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.259]                 }
[16:04:44.259]                 ...future.workdir <- getwd()
[16:04:44.259]             }
[16:04:44.259]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.259]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.259]         }
[16:04:44.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.259]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.259]             base::names(...future.oldOptions))
[16:04:44.259]     }
[16:04:44.259]     if (FALSE) {
[16:04:44.259]     }
[16:04:44.259]     else {
[16:04:44.259]         if (TRUE) {
[16:04:44.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.259]                 open = "w")
[16:04:44.259]         }
[16:04:44.259]         else {
[16:04:44.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.259]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.259]         }
[16:04:44.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.259]             base::sink(type = "output", split = FALSE)
[16:04:44.259]             base::close(...future.stdout)
[16:04:44.259]         }, add = TRUE)
[16:04:44.259]     }
[16:04:44.259]     ...future.frame <- base::sys.nframe()
[16:04:44.259]     ...future.conditions <- base::list()
[16:04:44.259]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.259]     if (FALSE) {
[16:04:44.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.259]     }
[16:04:44.259]     ...future.result <- base::tryCatch({
[16:04:44.259]         base::withCallingHandlers({
[16:04:44.259]             ...future.value <- base::withVisible(base::local({
[16:04:44.259]                 ...future.makeSendCondition <- base::local({
[16:04:44.259]                   sendCondition <- NULL
[16:04:44.259]                   function(frame = 1L) {
[16:04:44.259]                     if (is.function(sendCondition)) 
[16:04:44.259]                       return(sendCondition)
[16:04:44.259]                     ns <- getNamespace("parallel")
[16:04:44.259]                     if (exists("sendData", mode = "function", 
[16:04:44.259]                       envir = ns)) {
[16:04:44.259]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.259]                         envir = ns)
[16:04:44.259]                       envir <- sys.frame(frame)
[16:04:44.259]                       master <- NULL
[16:04:44.259]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.259]                         !identical(envir, emptyenv())) {
[16:04:44.259]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.259]                           inherits = FALSE)) {
[16:04:44.259]                           master <- get("master", mode = "list", 
[16:04:44.259]                             envir = envir, inherits = FALSE)
[16:04:44.259]                           if (inherits(master, c("SOCKnode", 
[16:04:44.259]                             "SOCK0node"))) {
[16:04:44.259]                             sendCondition <<- function(cond) {
[16:04:44.259]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.259]                                 success = TRUE)
[16:04:44.259]                               parallel_sendData(master, data)
[16:04:44.259]                             }
[16:04:44.259]                             return(sendCondition)
[16:04:44.259]                           }
[16:04:44.259]                         }
[16:04:44.259]                         frame <- frame + 1L
[16:04:44.259]                         envir <- sys.frame(frame)
[16:04:44.259]                       }
[16:04:44.259]                     }
[16:04:44.259]                     sendCondition <<- function(cond) NULL
[16:04:44.259]                   }
[16:04:44.259]                 })
[16:04:44.259]                 withCallingHandlers({
[16:04:44.259]                   2
[16:04:44.259]                 }, immediateCondition = function(cond) {
[16:04:44.259]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.259]                   sendCondition(cond)
[16:04:44.259]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.259]                   {
[16:04:44.259]                     inherits <- base::inherits
[16:04:44.259]                     invokeRestart <- base::invokeRestart
[16:04:44.259]                     is.null <- base::is.null
[16:04:44.259]                     muffled <- FALSE
[16:04:44.259]                     if (inherits(cond, "message")) {
[16:04:44.259]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.259]                       if (muffled) 
[16:04:44.259]                         invokeRestart("muffleMessage")
[16:04:44.259]                     }
[16:04:44.259]                     else if (inherits(cond, "warning")) {
[16:04:44.259]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.259]                       if (muffled) 
[16:04:44.259]                         invokeRestart("muffleWarning")
[16:04:44.259]                     }
[16:04:44.259]                     else if (inherits(cond, "condition")) {
[16:04:44.259]                       if (!is.null(pattern)) {
[16:04:44.259]                         computeRestarts <- base::computeRestarts
[16:04:44.259]                         grepl <- base::grepl
[16:04:44.259]                         restarts <- computeRestarts(cond)
[16:04:44.259]                         for (restart in restarts) {
[16:04:44.259]                           name <- restart$name
[16:04:44.259]                           if (is.null(name)) 
[16:04:44.259]                             next
[16:04:44.259]                           if (!grepl(pattern, name)) 
[16:04:44.259]                             next
[16:04:44.259]                           invokeRestart(restart)
[16:04:44.259]                           muffled <- TRUE
[16:04:44.259]                           break
[16:04:44.259]                         }
[16:04:44.259]                       }
[16:04:44.259]                     }
[16:04:44.259]                     invisible(muffled)
[16:04:44.259]                   }
[16:04:44.259]                   muffleCondition(cond)
[16:04:44.259]                 })
[16:04:44.259]             }))
[16:04:44.259]             future::FutureResult(value = ...future.value$value, 
[16:04:44.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.259]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.259]                     ...future.globalenv.names))
[16:04:44.259]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.259]         }, condition = base::local({
[16:04:44.259]             c <- base::c
[16:04:44.259]             inherits <- base::inherits
[16:04:44.259]             invokeRestart <- base::invokeRestart
[16:04:44.259]             length <- base::length
[16:04:44.259]             list <- base::list
[16:04:44.259]             seq.int <- base::seq.int
[16:04:44.259]             signalCondition <- base::signalCondition
[16:04:44.259]             sys.calls <- base::sys.calls
[16:04:44.259]             `[[` <- base::`[[`
[16:04:44.259]             `+` <- base::`+`
[16:04:44.259]             `<<-` <- base::`<<-`
[16:04:44.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.259]                   3L)]
[16:04:44.259]             }
[16:04:44.259]             function(cond) {
[16:04:44.259]                 is_error <- inherits(cond, "error")
[16:04:44.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.259]                   NULL)
[16:04:44.259]                 if (is_error) {
[16:04:44.259]                   sessionInformation <- function() {
[16:04:44.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.259]                       search = base::search(), system = base::Sys.info())
[16:04:44.259]                   }
[16:04:44.259]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.259]                     cond$call), session = sessionInformation(), 
[16:04:44.259]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.259]                   signalCondition(cond)
[16:04:44.259]                 }
[16:04:44.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.259]                 "immediateCondition"))) {
[16:04:44.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.259]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.259]                   if (TRUE && !signal) {
[16:04:44.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.259]                     {
[16:04:44.259]                       inherits <- base::inherits
[16:04:44.259]                       invokeRestart <- base::invokeRestart
[16:04:44.259]                       is.null <- base::is.null
[16:04:44.259]                       muffled <- FALSE
[16:04:44.259]                       if (inherits(cond, "message")) {
[16:04:44.259]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.259]                         if (muffled) 
[16:04:44.259]                           invokeRestart("muffleMessage")
[16:04:44.259]                       }
[16:04:44.259]                       else if (inherits(cond, "warning")) {
[16:04:44.259]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.259]                         if (muffled) 
[16:04:44.259]                           invokeRestart("muffleWarning")
[16:04:44.259]                       }
[16:04:44.259]                       else if (inherits(cond, "condition")) {
[16:04:44.259]                         if (!is.null(pattern)) {
[16:04:44.259]                           computeRestarts <- base::computeRestarts
[16:04:44.259]                           grepl <- base::grepl
[16:04:44.259]                           restarts <- computeRestarts(cond)
[16:04:44.259]                           for (restart in restarts) {
[16:04:44.259]                             name <- restart$name
[16:04:44.259]                             if (is.null(name)) 
[16:04:44.259]                               next
[16:04:44.259]                             if (!grepl(pattern, name)) 
[16:04:44.259]                               next
[16:04:44.259]                             invokeRestart(restart)
[16:04:44.259]                             muffled <- TRUE
[16:04:44.259]                             break
[16:04:44.259]                           }
[16:04:44.259]                         }
[16:04:44.259]                       }
[16:04:44.259]                       invisible(muffled)
[16:04:44.259]                     }
[16:04:44.259]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.259]                   }
[16:04:44.259]                 }
[16:04:44.259]                 else {
[16:04:44.259]                   if (TRUE) {
[16:04:44.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.259]                     {
[16:04:44.259]                       inherits <- base::inherits
[16:04:44.259]                       invokeRestart <- base::invokeRestart
[16:04:44.259]                       is.null <- base::is.null
[16:04:44.259]                       muffled <- FALSE
[16:04:44.259]                       if (inherits(cond, "message")) {
[16:04:44.259]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.259]                         if (muffled) 
[16:04:44.259]                           invokeRestart("muffleMessage")
[16:04:44.259]                       }
[16:04:44.259]                       else if (inherits(cond, "warning")) {
[16:04:44.259]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.259]                         if (muffled) 
[16:04:44.259]                           invokeRestart("muffleWarning")
[16:04:44.259]                       }
[16:04:44.259]                       else if (inherits(cond, "condition")) {
[16:04:44.259]                         if (!is.null(pattern)) {
[16:04:44.259]                           computeRestarts <- base::computeRestarts
[16:04:44.259]                           grepl <- base::grepl
[16:04:44.259]                           restarts <- computeRestarts(cond)
[16:04:44.259]                           for (restart in restarts) {
[16:04:44.259]                             name <- restart$name
[16:04:44.259]                             if (is.null(name)) 
[16:04:44.259]                               next
[16:04:44.259]                             if (!grepl(pattern, name)) 
[16:04:44.259]                               next
[16:04:44.259]                             invokeRestart(restart)
[16:04:44.259]                             muffled <- TRUE
[16:04:44.259]                             break
[16:04:44.259]                           }
[16:04:44.259]                         }
[16:04:44.259]                       }
[16:04:44.259]                       invisible(muffled)
[16:04:44.259]                     }
[16:04:44.259]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.259]                   }
[16:04:44.259]                 }
[16:04:44.259]             }
[16:04:44.259]         }))
[16:04:44.259]     }, error = function(ex) {
[16:04:44.259]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.259]                 ...future.rng), started = ...future.startTime, 
[16:04:44.259]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.259]             version = "1.8"), class = "FutureResult")
[16:04:44.259]     }, finally = {
[16:04:44.259]         if (!identical(...future.workdir, getwd())) 
[16:04:44.259]             setwd(...future.workdir)
[16:04:44.259]         {
[16:04:44.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.259]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.259]             }
[16:04:44.259]             base::options(...future.oldOptions)
[16:04:44.259]             if (.Platform$OS.type == "windows") {
[16:04:44.259]                 old_names <- names(...future.oldEnvVars)
[16:04:44.259]                 envs <- base::Sys.getenv()
[16:04:44.259]                 names <- names(envs)
[16:04:44.259]                 common <- intersect(names, old_names)
[16:04:44.259]                 added <- setdiff(names, old_names)
[16:04:44.259]                 removed <- setdiff(old_names, names)
[16:04:44.259]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.259]                   envs[common]]
[16:04:44.259]                 NAMES <- toupper(changed)
[16:04:44.259]                 args <- list()
[16:04:44.259]                 for (kk in seq_along(NAMES)) {
[16:04:44.259]                   name <- changed[[kk]]
[16:04:44.259]                   NAME <- NAMES[[kk]]
[16:04:44.259]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.259]                     next
[16:04:44.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.259]                 }
[16:04:44.259]                 NAMES <- toupper(added)
[16:04:44.259]                 for (kk in seq_along(NAMES)) {
[16:04:44.259]                   name <- added[[kk]]
[16:04:44.259]                   NAME <- NAMES[[kk]]
[16:04:44.259]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.259]                     next
[16:04:44.259]                   args[[name]] <- ""
[16:04:44.259]                 }
[16:04:44.259]                 NAMES <- toupper(removed)
[16:04:44.259]                 for (kk in seq_along(NAMES)) {
[16:04:44.259]                   name <- removed[[kk]]
[16:04:44.259]                   NAME <- NAMES[[kk]]
[16:04:44.259]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.259]                     next
[16:04:44.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.259]                 }
[16:04:44.259]                 if (length(args) > 0) 
[16:04:44.259]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.259]             }
[16:04:44.259]             else {
[16:04:44.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.259]             }
[16:04:44.259]             {
[16:04:44.259]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.259]                   0L) {
[16:04:44.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.259]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.259]                   base::options(opts)
[16:04:44.259]                 }
[16:04:44.259]                 {
[16:04:44.259]                   {
[16:04:44.259]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.259]                     NULL
[16:04:44.259]                   }
[16:04:44.259]                   options(future.plan = NULL)
[16:04:44.259]                   if (is.na(NA_character_)) 
[16:04:44.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.259]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.259]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.259]                     envir = parent.frame()) 
[16:04:44.259]                   {
[16:04:44.259]                     if (is.function(workers)) 
[16:04:44.259]                       workers <- workers()
[16:04:44.259]                     workers <- structure(as.integer(workers), 
[16:04:44.259]                       class = class(workers))
[16:04:44.259]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.259]                       workers >= 1)
[16:04:44.259]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.259]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.259]                     }
[16:04:44.259]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.259]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.259]                       envir = envir)
[16:04:44.259]                     if (!future$lazy) 
[16:04:44.259]                       future <- run(future)
[16:04:44.259]                     invisible(future)
[16:04:44.259]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.259]                 }
[16:04:44.259]             }
[16:04:44.259]         }
[16:04:44.259]     })
[16:04:44.259]     if (TRUE) {
[16:04:44.259]         base::sink(type = "output", split = FALSE)
[16:04:44.259]         if (TRUE) {
[16:04:44.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.259]         }
[16:04:44.259]         else {
[16:04:44.259]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.259]         }
[16:04:44.259]         base::close(...future.stdout)
[16:04:44.259]         ...future.stdout <- NULL
[16:04:44.259]     }
[16:04:44.259]     ...future.result$conditions <- ...future.conditions
[16:04:44.259]     ...future.result$finished <- base::Sys.time()
[16:04:44.259]     ...future.result
[16:04:44.259] }
[16:04:44.265] MultisessionFuture started
[16:04:44.265] - Launch lazy future ... done
[16:04:44.265] run() for ‘MultisessionFuture’ ... done
[16:04:44.265] getGlobalsAndPackages() ...
[16:04:44.265] Searching for globals...
[16:04:44.266] 
[16:04:44.266] Searching for globals ... DONE
[16:04:44.266] - globals: [0] <none>
[16:04:44.266] getGlobalsAndPackages() ... DONE
[16:04:44.266] run() for ‘Future’ ...
[16:04:44.266] - state: ‘created’
[16:04:44.267] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.281] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.281] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.281]   - Field: ‘node’
[16:04:44.281]   - Field: ‘label’
[16:04:44.281]   - Field: ‘local’
[16:04:44.281]   - Field: ‘owner’
[16:04:44.281]   - Field: ‘envir’
[16:04:44.281]   - Field: ‘workers’
[16:04:44.281]   - Field: ‘packages’
[16:04:44.282]   - Field: ‘gc’
[16:04:44.282]   - Field: ‘conditions’
[16:04:44.282]   - Field: ‘persistent’
[16:04:44.282]   - Field: ‘expr’
[16:04:44.282]   - Field: ‘uuid’
[16:04:44.282]   - Field: ‘seed’
[16:04:44.282]   - Field: ‘version’
[16:04:44.282]   - Field: ‘result’
[16:04:44.282]   - Field: ‘asynchronous’
[16:04:44.282]   - Field: ‘calls’
[16:04:44.282]   - Field: ‘globals’
[16:04:44.283]   - Field: ‘stdout’
[16:04:44.283]   - Field: ‘earlySignal’
[16:04:44.283]   - Field: ‘lazy’
[16:04:44.283]   - Field: ‘state’
[16:04:44.283] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.283] - Launch lazy future ...
[16:04:44.283] Packages needed by the future expression (n = 0): <none>
[16:04:44.283] Packages needed by future strategies (n = 0): <none>
[16:04:44.284] {
[16:04:44.284]     {
[16:04:44.284]         {
[16:04:44.284]             ...future.startTime <- base::Sys.time()
[16:04:44.284]             {
[16:04:44.284]                 {
[16:04:44.284]                   {
[16:04:44.284]                     {
[16:04:44.284]                       base::local({
[16:04:44.284]                         has_future <- base::requireNamespace("future", 
[16:04:44.284]                           quietly = TRUE)
[16:04:44.284]                         if (has_future) {
[16:04:44.284]                           ns <- base::getNamespace("future")
[16:04:44.284]                           version <- ns[[".package"]][["version"]]
[16:04:44.284]                           if (is.null(version)) 
[16:04:44.284]                             version <- utils::packageVersion("future")
[16:04:44.284]                         }
[16:04:44.284]                         else {
[16:04:44.284]                           version <- NULL
[16:04:44.284]                         }
[16:04:44.284]                         if (!has_future || version < "1.8.0") {
[16:04:44.284]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.284]                             "", base::R.version$version.string), 
[16:04:44.284]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.284]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.284]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.284]                               "release", "version")], collapse = " "), 
[16:04:44.284]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.284]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.284]                             info)
[16:04:44.284]                           info <- base::paste(info, collapse = "; ")
[16:04:44.284]                           if (!has_future) {
[16:04:44.284]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.284]                               info)
[16:04:44.284]                           }
[16:04:44.284]                           else {
[16:04:44.284]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.284]                               info, version)
[16:04:44.284]                           }
[16:04:44.284]                           base::stop(msg)
[16:04:44.284]                         }
[16:04:44.284]                       })
[16:04:44.284]                     }
[16:04:44.284]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.284]                     base::options(mc.cores = 1L)
[16:04:44.284]                   }
[16:04:44.284]                   options(future.plan = NULL)
[16:04:44.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.284]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.284]                 }
[16:04:44.284]                 ...future.workdir <- getwd()
[16:04:44.284]             }
[16:04:44.284]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.284]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.284]         }
[16:04:44.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.284]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.284]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.284]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.284]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.284]             base::names(...future.oldOptions))
[16:04:44.284]     }
[16:04:44.284]     if (FALSE) {
[16:04:44.284]     }
[16:04:44.284]     else {
[16:04:44.284]         if (TRUE) {
[16:04:44.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.284]                 open = "w")
[16:04:44.284]         }
[16:04:44.284]         else {
[16:04:44.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.284]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.284]         }
[16:04:44.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.284]             base::sink(type = "output", split = FALSE)
[16:04:44.284]             base::close(...future.stdout)
[16:04:44.284]         }, add = TRUE)
[16:04:44.284]     }
[16:04:44.284]     ...future.frame <- base::sys.nframe()
[16:04:44.284]     ...future.conditions <- base::list()
[16:04:44.284]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.284]     if (FALSE) {
[16:04:44.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.284]     }
[16:04:44.284]     ...future.result <- base::tryCatch({
[16:04:44.284]         base::withCallingHandlers({
[16:04:44.284]             ...future.value <- base::withVisible(base::local({
[16:04:44.284]                 ...future.makeSendCondition <- base::local({
[16:04:44.284]                   sendCondition <- NULL
[16:04:44.284]                   function(frame = 1L) {
[16:04:44.284]                     if (is.function(sendCondition)) 
[16:04:44.284]                       return(sendCondition)
[16:04:44.284]                     ns <- getNamespace("parallel")
[16:04:44.284]                     if (exists("sendData", mode = "function", 
[16:04:44.284]                       envir = ns)) {
[16:04:44.284]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.284]                         envir = ns)
[16:04:44.284]                       envir <- sys.frame(frame)
[16:04:44.284]                       master <- NULL
[16:04:44.284]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.284]                         !identical(envir, emptyenv())) {
[16:04:44.284]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.284]                           inherits = FALSE)) {
[16:04:44.284]                           master <- get("master", mode = "list", 
[16:04:44.284]                             envir = envir, inherits = FALSE)
[16:04:44.284]                           if (inherits(master, c("SOCKnode", 
[16:04:44.284]                             "SOCK0node"))) {
[16:04:44.284]                             sendCondition <<- function(cond) {
[16:04:44.284]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.284]                                 success = TRUE)
[16:04:44.284]                               parallel_sendData(master, data)
[16:04:44.284]                             }
[16:04:44.284]                             return(sendCondition)
[16:04:44.284]                           }
[16:04:44.284]                         }
[16:04:44.284]                         frame <- frame + 1L
[16:04:44.284]                         envir <- sys.frame(frame)
[16:04:44.284]                       }
[16:04:44.284]                     }
[16:04:44.284]                     sendCondition <<- function(cond) NULL
[16:04:44.284]                   }
[16:04:44.284]                 })
[16:04:44.284]                 withCallingHandlers({
[16:04:44.284]                   NULL
[16:04:44.284]                 }, immediateCondition = function(cond) {
[16:04:44.284]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.284]                   sendCondition(cond)
[16:04:44.284]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.284]                   {
[16:04:44.284]                     inherits <- base::inherits
[16:04:44.284]                     invokeRestart <- base::invokeRestart
[16:04:44.284]                     is.null <- base::is.null
[16:04:44.284]                     muffled <- FALSE
[16:04:44.284]                     if (inherits(cond, "message")) {
[16:04:44.284]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.284]                       if (muffled) 
[16:04:44.284]                         invokeRestart("muffleMessage")
[16:04:44.284]                     }
[16:04:44.284]                     else if (inherits(cond, "warning")) {
[16:04:44.284]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.284]                       if (muffled) 
[16:04:44.284]                         invokeRestart("muffleWarning")
[16:04:44.284]                     }
[16:04:44.284]                     else if (inherits(cond, "condition")) {
[16:04:44.284]                       if (!is.null(pattern)) {
[16:04:44.284]                         computeRestarts <- base::computeRestarts
[16:04:44.284]                         grepl <- base::grepl
[16:04:44.284]                         restarts <- computeRestarts(cond)
[16:04:44.284]                         for (restart in restarts) {
[16:04:44.284]                           name <- restart$name
[16:04:44.284]                           if (is.null(name)) 
[16:04:44.284]                             next
[16:04:44.284]                           if (!grepl(pattern, name)) 
[16:04:44.284]                             next
[16:04:44.284]                           invokeRestart(restart)
[16:04:44.284]                           muffled <- TRUE
[16:04:44.284]                           break
[16:04:44.284]                         }
[16:04:44.284]                       }
[16:04:44.284]                     }
[16:04:44.284]                     invisible(muffled)
[16:04:44.284]                   }
[16:04:44.284]                   muffleCondition(cond)
[16:04:44.284]                 })
[16:04:44.284]             }))
[16:04:44.284]             future::FutureResult(value = ...future.value$value, 
[16:04:44.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.284]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.284]                     ...future.globalenv.names))
[16:04:44.284]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.284]         }, condition = base::local({
[16:04:44.284]             c <- base::c
[16:04:44.284]             inherits <- base::inherits
[16:04:44.284]             invokeRestart <- base::invokeRestart
[16:04:44.284]             length <- base::length
[16:04:44.284]             list <- base::list
[16:04:44.284]             seq.int <- base::seq.int
[16:04:44.284]             signalCondition <- base::signalCondition
[16:04:44.284]             sys.calls <- base::sys.calls
[16:04:44.284]             `[[` <- base::`[[`
[16:04:44.284]             `+` <- base::`+`
[16:04:44.284]             `<<-` <- base::`<<-`
[16:04:44.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.284]                   3L)]
[16:04:44.284]             }
[16:04:44.284]             function(cond) {
[16:04:44.284]                 is_error <- inherits(cond, "error")
[16:04:44.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.284]                   NULL)
[16:04:44.284]                 if (is_error) {
[16:04:44.284]                   sessionInformation <- function() {
[16:04:44.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.284]                       search = base::search(), system = base::Sys.info())
[16:04:44.284]                   }
[16:04:44.284]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.284]                     cond$call), session = sessionInformation(), 
[16:04:44.284]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.284]                   signalCondition(cond)
[16:04:44.284]                 }
[16:04:44.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.284]                 "immediateCondition"))) {
[16:04:44.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.284]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.284]                   if (TRUE && !signal) {
[16:04:44.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.284]                     {
[16:04:44.284]                       inherits <- base::inherits
[16:04:44.284]                       invokeRestart <- base::invokeRestart
[16:04:44.284]                       is.null <- base::is.null
[16:04:44.284]                       muffled <- FALSE
[16:04:44.284]                       if (inherits(cond, "message")) {
[16:04:44.284]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.284]                         if (muffled) 
[16:04:44.284]                           invokeRestart("muffleMessage")
[16:04:44.284]                       }
[16:04:44.284]                       else if (inherits(cond, "warning")) {
[16:04:44.284]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.284]                         if (muffled) 
[16:04:44.284]                           invokeRestart("muffleWarning")
[16:04:44.284]                       }
[16:04:44.284]                       else if (inherits(cond, "condition")) {
[16:04:44.284]                         if (!is.null(pattern)) {
[16:04:44.284]                           computeRestarts <- base::computeRestarts
[16:04:44.284]                           grepl <- base::grepl
[16:04:44.284]                           restarts <- computeRestarts(cond)
[16:04:44.284]                           for (restart in restarts) {
[16:04:44.284]                             name <- restart$name
[16:04:44.284]                             if (is.null(name)) 
[16:04:44.284]                               next
[16:04:44.284]                             if (!grepl(pattern, name)) 
[16:04:44.284]                               next
[16:04:44.284]                             invokeRestart(restart)
[16:04:44.284]                             muffled <- TRUE
[16:04:44.284]                             break
[16:04:44.284]                           }
[16:04:44.284]                         }
[16:04:44.284]                       }
[16:04:44.284]                       invisible(muffled)
[16:04:44.284]                     }
[16:04:44.284]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.284]                   }
[16:04:44.284]                 }
[16:04:44.284]                 else {
[16:04:44.284]                   if (TRUE) {
[16:04:44.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.284]                     {
[16:04:44.284]                       inherits <- base::inherits
[16:04:44.284]                       invokeRestart <- base::invokeRestart
[16:04:44.284]                       is.null <- base::is.null
[16:04:44.284]                       muffled <- FALSE
[16:04:44.284]                       if (inherits(cond, "message")) {
[16:04:44.284]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.284]                         if (muffled) 
[16:04:44.284]                           invokeRestart("muffleMessage")
[16:04:44.284]                       }
[16:04:44.284]                       else if (inherits(cond, "warning")) {
[16:04:44.284]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.284]                         if (muffled) 
[16:04:44.284]                           invokeRestart("muffleWarning")
[16:04:44.284]                       }
[16:04:44.284]                       else if (inherits(cond, "condition")) {
[16:04:44.284]                         if (!is.null(pattern)) {
[16:04:44.284]                           computeRestarts <- base::computeRestarts
[16:04:44.284]                           grepl <- base::grepl
[16:04:44.284]                           restarts <- computeRestarts(cond)
[16:04:44.284]                           for (restart in restarts) {
[16:04:44.284]                             name <- restart$name
[16:04:44.284]                             if (is.null(name)) 
[16:04:44.284]                               next
[16:04:44.284]                             if (!grepl(pattern, name)) 
[16:04:44.284]                               next
[16:04:44.284]                             invokeRestart(restart)
[16:04:44.284]                             muffled <- TRUE
[16:04:44.284]                             break
[16:04:44.284]                           }
[16:04:44.284]                         }
[16:04:44.284]                       }
[16:04:44.284]                       invisible(muffled)
[16:04:44.284]                     }
[16:04:44.284]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.284]                   }
[16:04:44.284]                 }
[16:04:44.284]             }
[16:04:44.284]         }))
[16:04:44.284]     }, error = function(ex) {
[16:04:44.284]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.284]                 ...future.rng), started = ...future.startTime, 
[16:04:44.284]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.284]             version = "1.8"), class = "FutureResult")
[16:04:44.284]     }, finally = {
[16:04:44.284]         if (!identical(...future.workdir, getwd())) 
[16:04:44.284]             setwd(...future.workdir)
[16:04:44.284]         {
[16:04:44.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.284]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.284]             }
[16:04:44.284]             base::options(...future.oldOptions)
[16:04:44.284]             if (.Platform$OS.type == "windows") {
[16:04:44.284]                 old_names <- names(...future.oldEnvVars)
[16:04:44.284]                 envs <- base::Sys.getenv()
[16:04:44.284]                 names <- names(envs)
[16:04:44.284]                 common <- intersect(names, old_names)
[16:04:44.284]                 added <- setdiff(names, old_names)
[16:04:44.284]                 removed <- setdiff(old_names, names)
[16:04:44.284]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.284]                   envs[common]]
[16:04:44.284]                 NAMES <- toupper(changed)
[16:04:44.284]                 args <- list()
[16:04:44.284]                 for (kk in seq_along(NAMES)) {
[16:04:44.284]                   name <- changed[[kk]]
[16:04:44.284]                   NAME <- NAMES[[kk]]
[16:04:44.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.284]                     next
[16:04:44.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.284]                 }
[16:04:44.284]                 NAMES <- toupper(added)
[16:04:44.284]                 for (kk in seq_along(NAMES)) {
[16:04:44.284]                   name <- added[[kk]]
[16:04:44.284]                   NAME <- NAMES[[kk]]
[16:04:44.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.284]                     next
[16:04:44.284]                   args[[name]] <- ""
[16:04:44.284]                 }
[16:04:44.284]                 NAMES <- toupper(removed)
[16:04:44.284]                 for (kk in seq_along(NAMES)) {
[16:04:44.284]                   name <- removed[[kk]]
[16:04:44.284]                   NAME <- NAMES[[kk]]
[16:04:44.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.284]                     next
[16:04:44.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.284]                 }
[16:04:44.284]                 if (length(args) > 0) 
[16:04:44.284]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.284]             }
[16:04:44.284]             else {
[16:04:44.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.284]             }
[16:04:44.284]             {
[16:04:44.284]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.284]                   0L) {
[16:04:44.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.284]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.284]                   base::options(opts)
[16:04:44.284]                 }
[16:04:44.284]                 {
[16:04:44.284]                   {
[16:04:44.284]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.284]                     NULL
[16:04:44.284]                   }
[16:04:44.284]                   options(future.plan = NULL)
[16:04:44.284]                   if (is.na(NA_character_)) 
[16:04:44.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.284]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.284]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.284]                     envir = parent.frame()) 
[16:04:44.284]                   {
[16:04:44.284]                     if (is.function(workers)) 
[16:04:44.284]                       workers <- workers()
[16:04:44.284]                     workers <- structure(as.integer(workers), 
[16:04:44.284]                       class = class(workers))
[16:04:44.284]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.284]                       workers >= 1)
[16:04:44.284]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.284]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.284]                     }
[16:04:44.284]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.284]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.284]                       envir = envir)
[16:04:44.284]                     if (!future$lazy) 
[16:04:44.284]                       future <- run(future)
[16:04:44.284]                     invisible(future)
[16:04:44.284]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.284]                 }
[16:04:44.284]             }
[16:04:44.284]         }
[16:04:44.284]     })
[16:04:44.284]     if (TRUE) {
[16:04:44.284]         base::sink(type = "output", split = FALSE)
[16:04:44.284]         if (TRUE) {
[16:04:44.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.284]         }
[16:04:44.284]         else {
[16:04:44.284]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.284]         }
[16:04:44.284]         base::close(...future.stdout)
[16:04:44.284]         ...future.stdout <- NULL
[16:04:44.284]     }
[16:04:44.284]     ...future.result$conditions <- ...future.conditions
[16:04:44.284]     ...future.result$finished <- base::Sys.time()
[16:04:44.284]     ...future.result
[16:04:44.284] }
[16:04:44.287] MultisessionFuture started
[16:04:44.287] - Launch lazy future ... done
[16:04:44.287] run() for ‘MultisessionFuture’ ... done
[16:04:44.288] getGlobalsAndPackages() ...
[16:04:44.288] Searching for globals...
[16:04:44.288] - globals found: [1] ‘{’
[16:04:44.289] Searching for globals ... DONE
[16:04:44.289] Resolving globals: FALSE
[16:04:44.289] 
[16:04:44.289] 
[16:04:44.289] getGlobalsAndPackages() ... DONE
[16:04:44.289] run() for ‘Future’ ...
[16:04:44.289] - state: ‘created’
[16:04:44.290] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.303] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.303] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.304]   - Field: ‘node’
[16:04:44.304]   - Field: ‘label’
[16:04:44.304]   - Field: ‘local’
[16:04:44.304]   - Field: ‘owner’
[16:04:44.304]   - Field: ‘envir’
[16:04:44.304]   - Field: ‘workers’
[16:04:44.304]   - Field: ‘packages’
[16:04:44.305]   - Field: ‘gc’
[16:04:44.305]   - Field: ‘conditions’
[16:04:44.305]   - Field: ‘persistent’
[16:04:44.305]   - Field: ‘expr’
[16:04:44.305]   - Field: ‘uuid’
[16:04:44.305]   - Field: ‘seed’
[16:04:44.306]   - Field: ‘version’
[16:04:44.306]   - Field: ‘result’
[16:04:44.306]   - Field: ‘asynchronous’
[16:04:44.306]   - Field: ‘calls’
[16:04:44.306]   - Field: ‘globals’
[16:04:44.306]   - Field: ‘stdout’
[16:04:44.306]   - Field: ‘earlySignal’
[16:04:44.306]   - Field: ‘lazy’
[16:04:44.306]   - Field: ‘state’
[16:04:44.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.307] - Launch lazy future ...
[16:04:44.307] Packages needed by the future expression (n = 0): <none>
[16:04:44.307] Packages needed by future strategies (n = 0): <none>
[16:04:44.308] {
[16:04:44.308]     {
[16:04:44.308]         {
[16:04:44.308]             ...future.startTime <- base::Sys.time()
[16:04:44.308]             {
[16:04:44.308]                 {
[16:04:44.308]                   {
[16:04:44.308]                     {
[16:04:44.308]                       base::local({
[16:04:44.308]                         has_future <- base::requireNamespace("future", 
[16:04:44.308]                           quietly = TRUE)
[16:04:44.308]                         if (has_future) {
[16:04:44.308]                           ns <- base::getNamespace("future")
[16:04:44.308]                           version <- ns[[".package"]][["version"]]
[16:04:44.308]                           if (is.null(version)) 
[16:04:44.308]                             version <- utils::packageVersion("future")
[16:04:44.308]                         }
[16:04:44.308]                         else {
[16:04:44.308]                           version <- NULL
[16:04:44.308]                         }
[16:04:44.308]                         if (!has_future || version < "1.8.0") {
[16:04:44.308]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.308]                             "", base::R.version$version.string), 
[16:04:44.308]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.308]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.308]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.308]                               "release", "version")], collapse = " "), 
[16:04:44.308]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.308]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.308]                             info)
[16:04:44.308]                           info <- base::paste(info, collapse = "; ")
[16:04:44.308]                           if (!has_future) {
[16:04:44.308]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.308]                               info)
[16:04:44.308]                           }
[16:04:44.308]                           else {
[16:04:44.308]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.308]                               info, version)
[16:04:44.308]                           }
[16:04:44.308]                           base::stop(msg)
[16:04:44.308]                         }
[16:04:44.308]                       })
[16:04:44.308]                     }
[16:04:44.308]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.308]                     base::options(mc.cores = 1L)
[16:04:44.308]                   }
[16:04:44.308]                   options(future.plan = NULL)
[16:04:44.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.308]                 }
[16:04:44.308]                 ...future.workdir <- getwd()
[16:04:44.308]             }
[16:04:44.308]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.308]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.308]         }
[16:04:44.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.308]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.308]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.308]             base::names(...future.oldOptions))
[16:04:44.308]     }
[16:04:44.308]     if (FALSE) {
[16:04:44.308]     }
[16:04:44.308]     else {
[16:04:44.308]         if (TRUE) {
[16:04:44.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.308]                 open = "w")
[16:04:44.308]         }
[16:04:44.308]         else {
[16:04:44.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.308]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.308]         }
[16:04:44.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.308]             base::sink(type = "output", split = FALSE)
[16:04:44.308]             base::close(...future.stdout)
[16:04:44.308]         }, add = TRUE)
[16:04:44.308]     }
[16:04:44.308]     ...future.frame <- base::sys.nframe()
[16:04:44.308]     ...future.conditions <- base::list()
[16:04:44.308]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.308]     if (FALSE) {
[16:04:44.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.308]     }
[16:04:44.308]     ...future.result <- base::tryCatch({
[16:04:44.308]         base::withCallingHandlers({
[16:04:44.308]             ...future.value <- base::withVisible(base::local({
[16:04:44.308]                 ...future.makeSendCondition <- base::local({
[16:04:44.308]                   sendCondition <- NULL
[16:04:44.308]                   function(frame = 1L) {
[16:04:44.308]                     if (is.function(sendCondition)) 
[16:04:44.308]                       return(sendCondition)
[16:04:44.308]                     ns <- getNamespace("parallel")
[16:04:44.308]                     if (exists("sendData", mode = "function", 
[16:04:44.308]                       envir = ns)) {
[16:04:44.308]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.308]                         envir = ns)
[16:04:44.308]                       envir <- sys.frame(frame)
[16:04:44.308]                       master <- NULL
[16:04:44.308]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.308]                         !identical(envir, emptyenv())) {
[16:04:44.308]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.308]                           inherits = FALSE)) {
[16:04:44.308]                           master <- get("master", mode = "list", 
[16:04:44.308]                             envir = envir, inherits = FALSE)
[16:04:44.308]                           if (inherits(master, c("SOCKnode", 
[16:04:44.308]                             "SOCK0node"))) {
[16:04:44.308]                             sendCondition <<- function(cond) {
[16:04:44.308]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.308]                                 success = TRUE)
[16:04:44.308]                               parallel_sendData(master, data)
[16:04:44.308]                             }
[16:04:44.308]                             return(sendCondition)
[16:04:44.308]                           }
[16:04:44.308]                         }
[16:04:44.308]                         frame <- frame + 1L
[16:04:44.308]                         envir <- sys.frame(frame)
[16:04:44.308]                       }
[16:04:44.308]                     }
[16:04:44.308]                     sendCondition <<- function(cond) NULL
[16:04:44.308]                   }
[16:04:44.308]                 })
[16:04:44.308]                 withCallingHandlers({
[16:04:44.308]                   {
[16:04:44.308]                     4
[16:04:44.308]                   }
[16:04:44.308]                 }, immediateCondition = function(cond) {
[16:04:44.308]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.308]                   sendCondition(cond)
[16:04:44.308]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.308]                   {
[16:04:44.308]                     inherits <- base::inherits
[16:04:44.308]                     invokeRestart <- base::invokeRestart
[16:04:44.308]                     is.null <- base::is.null
[16:04:44.308]                     muffled <- FALSE
[16:04:44.308]                     if (inherits(cond, "message")) {
[16:04:44.308]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.308]                       if (muffled) 
[16:04:44.308]                         invokeRestart("muffleMessage")
[16:04:44.308]                     }
[16:04:44.308]                     else if (inherits(cond, "warning")) {
[16:04:44.308]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.308]                       if (muffled) 
[16:04:44.308]                         invokeRestart("muffleWarning")
[16:04:44.308]                     }
[16:04:44.308]                     else if (inherits(cond, "condition")) {
[16:04:44.308]                       if (!is.null(pattern)) {
[16:04:44.308]                         computeRestarts <- base::computeRestarts
[16:04:44.308]                         grepl <- base::grepl
[16:04:44.308]                         restarts <- computeRestarts(cond)
[16:04:44.308]                         for (restart in restarts) {
[16:04:44.308]                           name <- restart$name
[16:04:44.308]                           if (is.null(name)) 
[16:04:44.308]                             next
[16:04:44.308]                           if (!grepl(pattern, name)) 
[16:04:44.308]                             next
[16:04:44.308]                           invokeRestart(restart)
[16:04:44.308]                           muffled <- TRUE
[16:04:44.308]                           break
[16:04:44.308]                         }
[16:04:44.308]                       }
[16:04:44.308]                     }
[16:04:44.308]                     invisible(muffled)
[16:04:44.308]                   }
[16:04:44.308]                   muffleCondition(cond)
[16:04:44.308]                 })
[16:04:44.308]             }))
[16:04:44.308]             future::FutureResult(value = ...future.value$value, 
[16:04:44.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.308]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.308]                     ...future.globalenv.names))
[16:04:44.308]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.308]         }, condition = base::local({
[16:04:44.308]             c <- base::c
[16:04:44.308]             inherits <- base::inherits
[16:04:44.308]             invokeRestart <- base::invokeRestart
[16:04:44.308]             length <- base::length
[16:04:44.308]             list <- base::list
[16:04:44.308]             seq.int <- base::seq.int
[16:04:44.308]             signalCondition <- base::signalCondition
[16:04:44.308]             sys.calls <- base::sys.calls
[16:04:44.308]             `[[` <- base::`[[`
[16:04:44.308]             `+` <- base::`+`
[16:04:44.308]             `<<-` <- base::`<<-`
[16:04:44.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.308]                   3L)]
[16:04:44.308]             }
[16:04:44.308]             function(cond) {
[16:04:44.308]                 is_error <- inherits(cond, "error")
[16:04:44.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.308]                   NULL)
[16:04:44.308]                 if (is_error) {
[16:04:44.308]                   sessionInformation <- function() {
[16:04:44.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.308]                       search = base::search(), system = base::Sys.info())
[16:04:44.308]                   }
[16:04:44.308]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.308]                     cond$call), session = sessionInformation(), 
[16:04:44.308]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.308]                   signalCondition(cond)
[16:04:44.308]                 }
[16:04:44.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.308]                 "immediateCondition"))) {
[16:04:44.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.308]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.308]                   if (TRUE && !signal) {
[16:04:44.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.308]                     {
[16:04:44.308]                       inherits <- base::inherits
[16:04:44.308]                       invokeRestart <- base::invokeRestart
[16:04:44.308]                       is.null <- base::is.null
[16:04:44.308]                       muffled <- FALSE
[16:04:44.308]                       if (inherits(cond, "message")) {
[16:04:44.308]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.308]                         if (muffled) 
[16:04:44.308]                           invokeRestart("muffleMessage")
[16:04:44.308]                       }
[16:04:44.308]                       else if (inherits(cond, "warning")) {
[16:04:44.308]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.308]                         if (muffled) 
[16:04:44.308]                           invokeRestart("muffleWarning")
[16:04:44.308]                       }
[16:04:44.308]                       else if (inherits(cond, "condition")) {
[16:04:44.308]                         if (!is.null(pattern)) {
[16:04:44.308]                           computeRestarts <- base::computeRestarts
[16:04:44.308]                           grepl <- base::grepl
[16:04:44.308]                           restarts <- computeRestarts(cond)
[16:04:44.308]                           for (restart in restarts) {
[16:04:44.308]                             name <- restart$name
[16:04:44.308]                             if (is.null(name)) 
[16:04:44.308]                               next
[16:04:44.308]                             if (!grepl(pattern, name)) 
[16:04:44.308]                               next
[16:04:44.308]                             invokeRestart(restart)
[16:04:44.308]                             muffled <- TRUE
[16:04:44.308]                             break
[16:04:44.308]                           }
[16:04:44.308]                         }
[16:04:44.308]                       }
[16:04:44.308]                       invisible(muffled)
[16:04:44.308]                     }
[16:04:44.308]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.308]                   }
[16:04:44.308]                 }
[16:04:44.308]                 else {
[16:04:44.308]                   if (TRUE) {
[16:04:44.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.308]                     {
[16:04:44.308]                       inherits <- base::inherits
[16:04:44.308]                       invokeRestart <- base::invokeRestart
[16:04:44.308]                       is.null <- base::is.null
[16:04:44.308]                       muffled <- FALSE
[16:04:44.308]                       if (inherits(cond, "message")) {
[16:04:44.308]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.308]                         if (muffled) 
[16:04:44.308]                           invokeRestart("muffleMessage")
[16:04:44.308]                       }
[16:04:44.308]                       else if (inherits(cond, "warning")) {
[16:04:44.308]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.308]                         if (muffled) 
[16:04:44.308]                           invokeRestart("muffleWarning")
[16:04:44.308]                       }
[16:04:44.308]                       else if (inherits(cond, "condition")) {
[16:04:44.308]                         if (!is.null(pattern)) {
[16:04:44.308]                           computeRestarts <- base::computeRestarts
[16:04:44.308]                           grepl <- base::grepl
[16:04:44.308]                           restarts <- computeRestarts(cond)
[16:04:44.308]                           for (restart in restarts) {
[16:04:44.308]                             name <- restart$name
[16:04:44.308]                             if (is.null(name)) 
[16:04:44.308]                               next
[16:04:44.308]                             if (!grepl(pattern, name)) 
[16:04:44.308]                               next
[16:04:44.308]                             invokeRestart(restart)
[16:04:44.308]                             muffled <- TRUE
[16:04:44.308]                             break
[16:04:44.308]                           }
[16:04:44.308]                         }
[16:04:44.308]                       }
[16:04:44.308]                       invisible(muffled)
[16:04:44.308]                     }
[16:04:44.308]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.308]                   }
[16:04:44.308]                 }
[16:04:44.308]             }
[16:04:44.308]         }))
[16:04:44.308]     }, error = function(ex) {
[16:04:44.308]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.308]                 ...future.rng), started = ...future.startTime, 
[16:04:44.308]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.308]             version = "1.8"), class = "FutureResult")
[16:04:44.308]     }, finally = {
[16:04:44.308]         if (!identical(...future.workdir, getwd())) 
[16:04:44.308]             setwd(...future.workdir)
[16:04:44.308]         {
[16:04:44.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.308]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.308]             }
[16:04:44.308]             base::options(...future.oldOptions)
[16:04:44.308]             if (.Platform$OS.type == "windows") {
[16:04:44.308]                 old_names <- names(...future.oldEnvVars)
[16:04:44.308]                 envs <- base::Sys.getenv()
[16:04:44.308]                 names <- names(envs)
[16:04:44.308]                 common <- intersect(names, old_names)
[16:04:44.308]                 added <- setdiff(names, old_names)
[16:04:44.308]                 removed <- setdiff(old_names, names)
[16:04:44.308]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.308]                   envs[common]]
[16:04:44.308]                 NAMES <- toupper(changed)
[16:04:44.308]                 args <- list()
[16:04:44.308]                 for (kk in seq_along(NAMES)) {
[16:04:44.308]                   name <- changed[[kk]]
[16:04:44.308]                   NAME <- NAMES[[kk]]
[16:04:44.308]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.308]                     next
[16:04:44.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.308]                 }
[16:04:44.308]                 NAMES <- toupper(added)
[16:04:44.308]                 for (kk in seq_along(NAMES)) {
[16:04:44.308]                   name <- added[[kk]]
[16:04:44.308]                   NAME <- NAMES[[kk]]
[16:04:44.308]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.308]                     next
[16:04:44.308]                   args[[name]] <- ""
[16:04:44.308]                 }
[16:04:44.308]                 NAMES <- toupper(removed)
[16:04:44.308]                 for (kk in seq_along(NAMES)) {
[16:04:44.308]                   name <- removed[[kk]]
[16:04:44.308]                   NAME <- NAMES[[kk]]
[16:04:44.308]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.308]                     next
[16:04:44.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.308]                 }
[16:04:44.308]                 if (length(args) > 0) 
[16:04:44.308]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.308]             }
[16:04:44.308]             else {
[16:04:44.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.308]             }
[16:04:44.308]             {
[16:04:44.308]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.308]                   0L) {
[16:04:44.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.308]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.308]                   base::options(opts)
[16:04:44.308]                 }
[16:04:44.308]                 {
[16:04:44.308]                   {
[16:04:44.308]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.308]                     NULL
[16:04:44.308]                   }
[16:04:44.308]                   options(future.plan = NULL)
[16:04:44.308]                   if (is.na(NA_character_)) 
[16:04:44.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.308]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.308]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.308]                     envir = parent.frame()) 
[16:04:44.308]                   {
[16:04:44.308]                     if (is.function(workers)) 
[16:04:44.308]                       workers <- workers()
[16:04:44.308]                     workers <- structure(as.integer(workers), 
[16:04:44.308]                       class = class(workers))
[16:04:44.308]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.308]                       workers >= 1)
[16:04:44.308]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.308]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.308]                     }
[16:04:44.308]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.308]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.308]                       envir = envir)
[16:04:44.308]                     if (!future$lazy) 
[16:04:44.308]                       future <- run(future)
[16:04:44.308]                     invisible(future)
[16:04:44.308]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.308]                 }
[16:04:44.308]             }
[16:04:44.308]         }
[16:04:44.308]     })
[16:04:44.308]     if (TRUE) {
[16:04:44.308]         base::sink(type = "output", split = FALSE)
[16:04:44.308]         if (TRUE) {
[16:04:44.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.308]         }
[16:04:44.308]         else {
[16:04:44.308]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.308]         }
[16:04:44.308]         base::close(...future.stdout)
[16:04:44.308]         ...future.stdout <- NULL
[16:04:44.308]     }
[16:04:44.308]     ...future.result$conditions <- ...future.conditions
[16:04:44.308]     ...future.result$finished <- base::Sys.time()
[16:04:44.308]     ...future.result
[16:04:44.308] }
[16:04:44.310] Poll #1 (0): usedNodes() = 2, workers = 2
[16:04:44.321] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.321] - Validating connection of MultisessionFuture
[16:04:44.321] - received message: FutureResult
[16:04:44.322] - Received FutureResult
[16:04:44.322] - Erased future from FutureRegistry
[16:04:44.322] result() for ClusterFuture ...
[16:04:44.322] - result already collected: FutureResult
[16:04:44.322] result() for ClusterFuture ... done
[16:04:44.322] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:44.322] result() for ClusterFuture ...
[16:04:44.322] - result already collected: FutureResult
[16:04:44.322] result() for ClusterFuture ... done
[16:04:44.322] result() for ClusterFuture ...
[16:04:44.323] - result already collected: FutureResult
[16:04:44.323] result() for ClusterFuture ... done
[16:04:44.324] MultisessionFuture started
[16:04:44.324] - Launch lazy future ... done
[16:04:44.324] run() for ‘MultisessionFuture’ ... done
<environment: 0x55874f93f458> 
<environment: 0x55874c625198> 
[16:04:44.336] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.336] - Validating connection of MultisessionFuture
[16:04:44.336] - received message: FutureResult
[16:04:44.336] - Received FutureResult
[16:04:44.336] - Erased future from FutureRegistry
[16:04:44.337] result() for ClusterFuture ...
[16:04:44.337] - result already collected: FutureResult
[16:04:44.337] result() for ClusterFuture ... done
[16:04:44.337] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:44.349] resolve() on environment ...
[16:04:44.349]  recursive: 0
[16:04:44.349]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:44.349] signalConditionsASAP(numeric, pos=1) ...
[16:04:44.349] - nx: 4
[16:04:44.350] - relay: TRUE
[16:04:44.350] - stdout: TRUE
[16:04:44.350] - signal: TRUE
[16:04:44.350] - resignal: FALSE
[16:04:44.350] - force: TRUE
[16:04:44.350] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.350] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.350]  - until=2
[16:04:44.350]  - relaying element #2
[16:04:44.350] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:44.350] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.351] signalConditionsASAP(NULL, pos=1) ... done
[16:04:44.351]  length: 3 (resolved future 1)
[16:04:44.351] Future #2
[16:04:44.351] result() for ClusterFuture ...
[16:04:44.351] - result already collected: FutureResult
[16:04:44.351] result() for ClusterFuture ... done
[16:04:44.351] result() for ClusterFuture ...
[16:04:44.351] - result already collected: FutureResult
[16:04:44.351] result() for ClusterFuture ... done
[16:04:44.351] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:44.352] - nx: 4
[16:04:44.352] - relay: TRUE
[16:04:44.352] - stdout: TRUE
[16:04:44.352] - signal: TRUE
[16:04:44.352] - resignal: FALSE
[16:04:44.352] - force: TRUE
[16:04:44.352] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:44.352] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.352]  - until=2
[16:04:44.352]  - relaying element #2
[16:04:44.352] result() for ClusterFuture ...
[16:04:44.352] - result already collected: FutureResult
[16:04:44.353] result() for ClusterFuture ... done
[16:04:44.353] result() for ClusterFuture ...
[16:04:44.353] - result already collected: FutureResult
[16:04:44.353] result() for ClusterFuture ... done
[16:04:44.353] result() for ClusterFuture ...
[16:04:44.353] - result already collected: FutureResult
[16:04:44.353] result() for ClusterFuture ... done
[16:04:44.353] result() for ClusterFuture ...
[16:04:44.353] - result already collected: FutureResult
[16:04:44.353] result() for ClusterFuture ... done
[16:04:44.353] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:44.354] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:44.354] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:44.354]  length: 2 (resolved future 2)
[16:04:44.354] Future #3
[16:04:44.354] result() for ClusterFuture ...
[16:04:44.354] - result already collected: FutureResult
[16:04:44.354] result() for ClusterFuture ... done
[16:04:44.354] result() for ClusterFuture ...
[16:04:44.354] - result already collected: FutureResult
[16:04:44.354] result() for ClusterFuture ... done
[16:04:44.354] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:44.355] - nx: 4
[16:04:44.355] - relay: TRUE
[16:04:44.355] - stdout: TRUE
[16:04:44.355] - signal: TRUE
[16:04:44.355] - resignal: FALSE
[16:04:44.355] - force: TRUE
[16:04:44.355] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:44.355] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:44.355]  - until=3
[16:04:44.355]  - relaying element #3
[16:04:44.355] result() for ClusterFuture ...
[16:04:44.356] - result already collected: FutureResult
[16:04:44.356] result() for ClusterFuture ... done
[16:04:44.356] result() for ClusterFuture ...
[16:04:44.356] - result already collected: FutureResult
[16:04:44.356] result() for ClusterFuture ... done
[16:04:44.356] result() for ClusterFuture ...
[16:04:44.356] - result already collected: FutureResult
[16:04:44.356] result() for ClusterFuture ... done
[16:04:44.356] result() for ClusterFuture ...
[16:04:44.356] - result already collected: FutureResult
[16:04:44.356] result() for ClusterFuture ... done
[16:04:44.356] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:44.357] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:44.357] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:44.357]  length: 1 (resolved future 3)
[16:04:44.378] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.378] - Validating connection of MultisessionFuture
[16:04:44.378] - received message: FutureResult
[16:04:44.378] - Received FutureResult
[16:04:44.379] - Erased future from FutureRegistry
[16:04:44.379] result() for ClusterFuture ...
[16:04:44.379] - result already collected: FutureResult
[16:04:44.379] result() for ClusterFuture ... done
[16:04:44.379] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:44.379] Future #4
[16:04:44.379] result() for ClusterFuture ...
[16:04:44.379] - result already collected: FutureResult
[16:04:44.379] result() for ClusterFuture ... done
[16:04:44.380] result() for ClusterFuture ...
[16:04:44.380] - result already collected: FutureResult
[16:04:44.380] result() for ClusterFuture ... done
[16:04:44.380] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:04:44.380] - nx: 4
[16:04:44.380] - relay: TRUE
[16:04:44.380] - stdout: TRUE
[16:04:44.380] - signal: TRUE
[16:04:44.380] - resignal: FALSE
[16:04:44.380] - force: TRUE
[16:04:44.380] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:44.380] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:44.381]  - until=4
[16:04:44.381]  - relaying element #4
[16:04:44.381] result() for ClusterFuture ...
[16:04:44.381] - result already collected: FutureResult
[16:04:44.381] result() for ClusterFuture ... done
[16:04:44.381] result() for ClusterFuture ...
[16:04:44.381] - result already collected: FutureResult
[16:04:44.381] result() for ClusterFuture ... done
[16:04:44.381] result() for ClusterFuture ...
[16:04:44.381] - result already collected: FutureResult
[16:04:44.381] result() for ClusterFuture ... done
[16:04:44.382] result() for ClusterFuture ...
[16:04:44.382] - result already collected: FutureResult
[16:04:44.382] result() for ClusterFuture ... done
[16:04:44.382] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.382] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:44.382] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:04:44.382]  length: 0 (resolved future 4)
[16:04:44.382] Relaying remaining futures
[16:04:44.382] signalConditionsASAP(NULL, pos=0) ...
[16:04:44.382] - nx: 4
[16:04:44.382] - relay: TRUE
[16:04:44.382] - stdout: TRUE
[16:04:44.383] - signal: TRUE
[16:04:44.383] - resignal: FALSE
[16:04:44.383] - force: TRUE
[16:04:44.383] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.383] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:44.383] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.383] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:44.383] signalConditionsASAP(NULL, pos=0) ... done
[16:04:44.383] resolve() on environment ... DONE
[16:04:44.383] result() for ClusterFuture ...
[16:04:44.384] - result already collected: FutureResult
[16:04:44.384] result() for ClusterFuture ... done
[16:04:44.384] result() for ClusterFuture ...
[16:04:44.384] - result already collected: FutureResult
[16:04:44.384] result() for ClusterFuture ... done
[16:04:44.384] result() for ClusterFuture ...
[16:04:44.384] - result already collected: FutureResult
[16:04:44.384] result() for ClusterFuture ... done
[16:04:44.384] result() for ClusterFuture ...
[16:04:44.384] - result already collected: FutureResult
[16:04:44.384] result() for ClusterFuture ... done
[16:04:44.385] result() for ClusterFuture ...
[16:04:44.385] - result already collected: FutureResult
[16:04:44.385] result() for ClusterFuture ... done
[16:04:44.385] result() for ClusterFuture ...
[16:04:44.385] - result already collected: FutureResult
[16:04:44.385] result() for ClusterFuture ... done
<environment: 0x55874d18aa20> 
Dimensions: c(2, 3)
[16:04:44.385] getGlobalsAndPackages() ...
[16:04:44.386] Searching for globals...
[16:04:44.386] 
[16:04:44.386] Searching for globals ... DONE
[16:04:44.386] - globals: [0] <none>
[16:04:44.386] getGlobalsAndPackages() ... DONE
[16:04:44.386] run() for ‘Future’ ...
[16:04:44.387] - state: ‘created’
[16:04:44.387] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.400] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.401]   - Field: ‘node’
[16:04:44.401]   - Field: ‘label’
[16:04:44.401]   - Field: ‘local’
[16:04:44.401]   - Field: ‘owner’
[16:04:44.401]   - Field: ‘envir’
[16:04:44.401]   - Field: ‘workers’
[16:04:44.401]   - Field: ‘packages’
[16:04:44.401]   - Field: ‘gc’
[16:04:44.402]   - Field: ‘conditions’
[16:04:44.402]   - Field: ‘persistent’
[16:04:44.402]   - Field: ‘expr’
[16:04:44.402]   - Field: ‘uuid’
[16:04:44.402]   - Field: ‘seed’
[16:04:44.402]   - Field: ‘version’
[16:04:44.402]   - Field: ‘result’
[16:04:44.402]   - Field: ‘asynchronous’
[16:04:44.402]   - Field: ‘calls’
[16:04:44.402]   - Field: ‘globals’
[16:04:44.402]   - Field: ‘stdout’
[16:04:44.403]   - Field: ‘earlySignal’
[16:04:44.403]   - Field: ‘lazy’
[16:04:44.403]   - Field: ‘state’
[16:04:44.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.403] - Launch lazy future ...
[16:04:44.403] Packages needed by the future expression (n = 0): <none>
[16:04:44.403] Packages needed by future strategies (n = 0): <none>
[16:04:44.404] {
[16:04:44.404]     {
[16:04:44.404]         {
[16:04:44.404]             ...future.startTime <- base::Sys.time()
[16:04:44.404]             {
[16:04:44.404]                 {
[16:04:44.404]                   {
[16:04:44.404]                     {
[16:04:44.404]                       base::local({
[16:04:44.404]                         has_future <- base::requireNamespace("future", 
[16:04:44.404]                           quietly = TRUE)
[16:04:44.404]                         if (has_future) {
[16:04:44.404]                           ns <- base::getNamespace("future")
[16:04:44.404]                           version <- ns[[".package"]][["version"]]
[16:04:44.404]                           if (is.null(version)) 
[16:04:44.404]                             version <- utils::packageVersion("future")
[16:04:44.404]                         }
[16:04:44.404]                         else {
[16:04:44.404]                           version <- NULL
[16:04:44.404]                         }
[16:04:44.404]                         if (!has_future || version < "1.8.0") {
[16:04:44.404]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.404]                             "", base::R.version$version.string), 
[16:04:44.404]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.404]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.404]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.404]                               "release", "version")], collapse = " "), 
[16:04:44.404]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.404]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.404]                             info)
[16:04:44.404]                           info <- base::paste(info, collapse = "; ")
[16:04:44.404]                           if (!has_future) {
[16:04:44.404]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.404]                               info)
[16:04:44.404]                           }
[16:04:44.404]                           else {
[16:04:44.404]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.404]                               info, version)
[16:04:44.404]                           }
[16:04:44.404]                           base::stop(msg)
[16:04:44.404]                         }
[16:04:44.404]                       })
[16:04:44.404]                     }
[16:04:44.404]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.404]                     base::options(mc.cores = 1L)
[16:04:44.404]                   }
[16:04:44.404]                   options(future.plan = NULL)
[16:04:44.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.404]                 }
[16:04:44.404]                 ...future.workdir <- getwd()
[16:04:44.404]             }
[16:04:44.404]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.404]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.404]         }
[16:04:44.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.404]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.404]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.404]             base::names(...future.oldOptions))
[16:04:44.404]     }
[16:04:44.404]     if (FALSE) {
[16:04:44.404]     }
[16:04:44.404]     else {
[16:04:44.404]         if (TRUE) {
[16:04:44.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.404]                 open = "w")
[16:04:44.404]         }
[16:04:44.404]         else {
[16:04:44.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.404]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.404]         }
[16:04:44.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.404]             base::sink(type = "output", split = FALSE)
[16:04:44.404]             base::close(...future.stdout)
[16:04:44.404]         }, add = TRUE)
[16:04:44.404]     }
[16:04:44.404]     ...future.frame <- base::sys.nframe()
[16:04:44.404]     ...future.conditions <- base::list()
[16:04:44.404]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.404]     if (FALSE) {
[16:04:44.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.404]     }
[16:04:44.404]     ...future.result <- base::tryCatch({
[16:04:44.404]         base::withCallingHandlers({
[16:04:44.404]             ...future.value <- base::withVisible(base::local({
[16:04:44.404]                 ...future.makeSendCondition <- base::local({
[16:04:44.404]                   sendCondition <- NULL
[16:04:44.404]                   function(frame = 1L) {
[16:04:44.404]                     if (is.function(sendCondition)) 
[16:04:44.404]                       return(sendCondition)
[16:04:44.404]                     ns <- getNamespace("parallel")
[16:04:44.404]                     if (exists("sendData", mode = "function", 
[16:04:44.404]                       envir = ns)) {
[16:04:44.404]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.404]                         envir = ns)
[16:04:44.404]                       envir <- sys.frame(frame)
[16:04:44.404]                       master <- NULL
[16:04:44.404]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.404]                         !identical(envir, emptyenv())) {
[16:04:44.404]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.404]                           inherits = FALSE)) {
[16:04:44.404]                           master <- get("master", mode = "list", 
[16:04:44.404]                             envir = envir, inherits = FALSE)
[16:04:44.404]                           if (inherits(master, c("SOCKnode", 
[16:04:44.404]                             "SOCK0node"))) {
[16:04:44.404]                             sendCondition <<- function(cond) {
[16:04:44.404]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.404]                                 success = TRUE)
[16:04:44.404]                               parallel_sendData(master, data)
[16:04:44.404]                             }
[16:04:44.404]                             return(sendCondition)
[16:04:44.404]                           }
[16:04:44.404]                         }
[16:04:44.404]                         frame <- frame + 1L
[16:04:44.404]                         envir <- sys.frame(frame)
[16:04:44.404]                       }
[16:04:44.404]                     }
[16:04:44.404]                     sendCondition <<- function(cond) NULL
[16:04:44.404]                   }
[16:04:44.404]                 })
[16:04:44.404]                 withCallingHandlers({
[16:04:44.404]                   2
[16:04:44.404]                 }, immediateCondition = function(cond) {
[16:04:44.404]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.404]                   sendCondition(cond)
[16:04:44.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.404]                   {
[16:04:44.404]                     inherits <- base::inherits
[16:04:44.404]                     invokeRestart <- base::invokeRestart
[16:04:44.404]                     is.null <- base::is.null
[16:04:44.404]                     muffled <- FALSE
[16:04:44.404]                     if (inherits(cond, "message")) {
[16:04:44.404]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.404]                       if (muffled) 
[16:04:44.404]                         invokeRestart("muffleMessage")
[16:04:44.404]                     }
[16:04:44.404]                     else if (inherits(cond, "warning")) {
[16:04:44.404]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.404]                       if (muffled) 
[16:04:44.404]                         invokeRestart("muffleWarning")
[16:04:44.404]                     }
[16:04:44.404]                     else if (inherits(cond, "condition")) {
[16:04:44.404]                       if (!is.null(pattern)) {
[16:04:44.404]                         computeRestarts <- base::computeRestarts
[16:04:44.404]                         grepl <- base::grepl
[16:04:44.404]                         restarts <- computeRestarts(cond)
[16:04:44.404]                         for (restart in restarts) {
[16:04:44.404]                           name <- restart$name
[16:04:44.404]                           if (is.null(name)) 
[16:04:44.404]                             next
[16:04:44.404]                           if (!grepl(pattern, name)) 
[16:04:44.404]                             next
[16:04:44.404]                           invokeRestart(restart)
[16:04:44.404]                           muffled <- TRUE
[16:04:44.404]                           break
[16:04:44.404]                         }
[16:04:44.404]                       }
[16:04:44.404]                     }
[16:04:44.404]                     invisible(muffled)
[16:04:44.404]                   }
[16:04:44.404]                   muffleCondition(cond)
[16:04:44.404]                 })
[16:04:44.404]             }))
[16:04:44.404]             future::FutureResult(value = ...future.value$value, 
[16:04:44.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.404]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.404]                     ...future.globalenv.names))
[16:04:44.404]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.404]         }, condition = base::local({
[16:04:44.404]             c <- base::c
[16:04:44.404]             inherits <- base::inherits
[16:04:44.404]             invokeRestart <- base::invokeRestart
[16:04:44.404]             length <- base::length
[16:04:44.404]             list <- base::list
[16:04:44.404]             seq.int <- base::seq.int
[16:04:44.404]             signalCondition <- base::signalCondition
[16:04:44.404]             sys.calls <- base::sys.calls
[16:04:44.404]             `[[` <- base::`[[`
[16:04:44.404]             `+` <- base::`+`
[16:04:44.404]             `<<-` <- base::`<<-`
[16:04:44.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.404]                   3L)]
[16:04:44.404]             }
[16:04:44.404]             function(cond) {
[16:04:44.404]                 is_error <- inherits(cond, "error")
[16:04:44.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.404]                   NULL)
[16:04:44.404]                 if (is_error) {
[16:04:44.404]                   sessionInformation <- function() {
[16:04:44.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.404]                       search = base::search(), system = base::Sys.info())
[16:04:44.404]                   }
[16:04:44.404]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.404]                     cond$call), session = sessionInformation(), 
[16:04:44.404]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.404]                   signalCondition(cond)
[16:04:44.404]                 }
[16:04:44.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.404]                 "immediateCondition"))) {
[16:04:44.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.404]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.404]                   if (TRUE && !signal) {
[16:04:44.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.404]                     {
[16:04:44.404]                       inherits <- base::inherits
[16:04:44.404]                       invokeRestart <- base::invokeRestart
[16:04:44.404]                       is.null <- base::is.null
[16:04:44.404]                       muffled <- FALSE
[16:04:44.404]                       if (inherits(cond, "message")) {
[16:04:44.404]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.404]                         if (muffled) 
[16:04:44.404]                           invokeRestart("muffleMessage")
[16:04:44.404]                       }
[16:04:44.404]                       else if (inherits(cond, "warning")) {
[16:04:44.404]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.404]                         if (muffled) 
[16:04:44.404]                           invokeRestart("muffleWarning")
[16:04:44.404]                       }
[16:04:44.404]                       else if (inherits(cond, "condition")) {
[16:04:44.404]                         if (!is.null(pattern)) {
[16:04:44.404]                           computeRestarts <- base::computeRestarts
[16:04:44.404]                           grepl <- base::grepl
[16:04:44.404]                           restarts <- computeRestarts(cond)
[16:04:44.404]                           for (restart in restarts) {
[16:04:44.404]                             name <- restart$name
[16:04:44.404]                             if (is.null(name)) 
[16:04:44.404]                               next
[16:04:44.404]                             if (!grepl(pattern, name)) 
[16:04:44.404]                               next
[16:04:44.404]                             invokeRestart(restart)
[16:04:44.404]                             muffled <- TRUE
[16:04:44.404]                             break
[16:04:44.404]                           }
[16:04:44.404]                         }
[16:04:44.404]                       }
[16:04:44.404]                       invisible(muffled)
[16:04:44.404]                     }
[16:04:44.404]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.404]                   }
[16:04:44.404]                 }
[16:04:44.404]                 else {
[16:04:44.404]                   if (TRUE) {
[16:04:44.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.404]                     {
[16:04:44.404]                       inherits <- base::inherits
[16:04:44.404]                       invokeRestart <- base::invokeRestart
[16:04:44.404]                       is.null <- base::is.null
[16:04:44.404]                       muffled <- FALSE
[16:04:44.404]                       if (inherits(cond, "message")) {
[16:04:44.404]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.404]                         if (muffled) 
[16:04:44.404]                           invokeRestart("muffleMessage")
[16:04:44.404]                       }
[16:04:44.404]                       else if (inherits(cond, "warning")) {
[16:04:44.404]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.404]                         if (muffled) 
[16:04:44.404]                           invokeRestart("muffleWarning")
[16:04:44.404]                       }
[16:04:44.404]                       else if (inherits(cond, "condition")) {
[16:04:44.404]                         if (!is.null(pattern)) {
[16:04:44.404]                           computeRestarts <- base::computeRestarts
[16:04:44.404]                           grepl <- base::grepl
[16:04:44.404]                           restarts <- computeRestarts(cond)
[16:04:44.404]                           for (restart in restarts) {
[16:04:44.404]                             name <- restart$name
[16:04:44.404]                             if (is.null(name)) 
[16:04:44.404]                               next
[16:04:44.404]                             if (!grepl(pattern, name)) 
[16:04:44.404]                               next
[16:04:44.404]                             invokeRestart(restart)
[16:04:44.404]                             muffled <- TRUE
[16:04:44.404]                             break
[16:04:44.404]                           }
[16:04:44.404]                         }
[16:04:44.404]                       }
[16:04:44.404]                       invisible(muffled)
[16:04:44.404]                     }
[16:04:44.404]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.404]                   }
[16:04:44.404]                 }
[16:04:44.404]             }
[16:04:44.404]         }))
[16:04:44.404]     }, error = function(ex) {
[16:04:44.404]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.404]                 ...future.rng), started = ...future.startTime, 
[16:04:44.404]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.404]             version = "1.8"), class = "FutureResult")
[16:04:44.404]     }, finally = {
[16:04:44.404]         if (!identical(...future.workdir, getwd())) 
[16:04:44.404]             setwd(...future.workdir)
[16:04:44.404]         {
[16:04:44.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.404]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.404]             }
[16:04:44.404]             base::options(...future.oldOptions)
[16:04:44.404]             if (.Platform$OS.type == "windows") {
[16:04:44.404]                 old_names <- names(...future.oldEnvVars)
[16:04:44.404]                 envs <- base::Sys.getenv()
[16:04:44.404]                 names <- names(envs)
[16:04:44.404]                 common <- intersect(names, old_names)
[16:04:44.404]                 added <- setdiff(names, old_names)
[16:04:44.404]                 removed <- setdiff(old_names, names)
[16:04:44.404]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.404]                   envs[common]]
[16:04:44.404]                 NAMES <- toupper(changed)
[16:04:44.404]                 args <- list()
[16:04:44.404]                 for (kk in seq_along(NAMES)) {
[16:04:44.404]                   name <- changed[[kk]]
[16:04:44.404]                   NAME <- NAMES[[kk]]
[16:04:44.404]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.404]                     next
[16:04:44.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.404]                 }
[16:04:44.404]                 NAMES <- toupper(added)
[16:04:44.404]                 for (kk in seq_along(NAMES)) {
[16:04:44.404]                   name <- added[[kk]]
[16:04:44.404]                   NAME <- NAMES[[kk]]
[16:04:44.404]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.404]                     next
[16:04:44.404]                   args[[name]] <- ""
[16:04:44.404]                 }
[16:04:44.404]                 NAMES <- toupper(removed)
[16:04:44.404]                 for (kk in seq_along(NAMES)) {
[16:04:44.404]                   name <- removed[[kk]]
[16:04:44.404]                   NAME <- NAMES[[kk]]
[16:04:44.404]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.404]                     next
[16:04:44.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.404]                 }
[16:04:44.404]                 if (length(args) > 0) 
[16:04:44.404]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.404]             }
[16:04:44.404]             else {
[16:04:44.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.404]             }
[16:04:44.404]             {
[16:04:44.404]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.404]                   0L) {
[16:04:44.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.404]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.404]                   base::options(opts)
[16:04:44.404]                 }
[16:04:44.404]                 {
[16:04:44.404]                   {
[16:04:44.404]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.404]                     NULL
[16:04:44.404]                   }
[16:04:44.404]                   options(future.plan = NULL)
[16:04:44.404]                   if (is.na(NA_character_)) 
[16:04:44.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.404]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.404]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.404]                     envir = parent.frame()) 
[16:04:44.404]                   {
[16:04:44.404]                     if (is.function(workers)) 
[16:04:44.404]                       workers <- workers()
[16:04:44.404]                     workers <- structure(as.integer(workers), 
[16:04:44.404]                       class = class(workers))
[16:04:44.404]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.404]                       workers >= 1)
[16:04:44.404]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.404]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.404]                     }
[16:04:44.404]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.404]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.404]                       envir = envir)
[16:04:44.404]                     if (!future$lazy) 
[16:04:44.404]                       future <- run(future)
[16:04:44.404]                     invisible(future)
[16:04:44.404]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.404]                 }
[16:04:44.404]             }
[16:04:44.404]         }
[16:04:44.404]     })
[16:04:44.404]     if (TRUE) {
[16:04:44.404]         base::sink(type = "output", split = FALSE)
[16:04:44.404]         if (TRUE) {
[16:04:44.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.404]         }
[16:04:44.404]         else {
[16:04:44.404]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.404]         }
[16:04:44.404]         base::close(...future.stdout)
[16:04:44.404]         ...future.stdout <- NULL
[16:04:44.404]     }
[16:04:44.404]     ...future.result$conditions <- ...future.conditions
[16:04:44.404]     ...future.result$finished <- base::Sys.time()
[16:04:44.404]     ...future.result
[16:04:44.404] }
[16:04:44.407] MultisessionFuture started
[16:04:44.407] - Launch lazy future ... done
[16:04:44.407] run() for ‘MultisessionFuture’ ... done
[16:04:44.407] getGlobalsAndPackages() ...
[16:04:44.407] Searching for globals...
[16:04:44.408] 
[16:04:44.408] Searching for globals ... DONE
[16:04:44.408] - globals: [0] <none>
[16:04:44.408] getGlobalsAndPackages() ... DONE
[16:04:44.408] run() for ‘Future’ ...
[16:04:44.408] - state: ‘created’
[16:04:44.408] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.422] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.422]   - Field: ‘node’
[16:04:44.423]   - Field: ‘label’
[16:04:44.423]   - Field: ‘local’
[16:04:44.423]   - Field: ‘owner’
[16:04:44.423]   - Field: ‘envir’
[16:04:44.423]   - Field: ‘workers’
[16:04:44.423]   - Field: ‘packages’
[16:04:44.423]   - Field: ‘gc’
[16:04:44.423]   - Field: ‘conditions’
[16:04:44.423]   - Field: ‘persistent’
[16:04:44.423]   - Field: ‘expr’
[16:04:44.424]   - Field: ‘uuid’
[16:04:44.424]   - Field: ‘seed’
[16:04:44.424]   - Field: ‘version’
[16:04:44.424]   - Field: ‘result’
[16:04:44.424]   - Field: ‘asynchronous’
[16:04:44.424]   - Field: ‘calls’
[16:04:44.424]   - Field: ‘globals’
[16:04:44.424]   - Field: ‘stdout’
[16:04:44.424]   - Field: ‘earlySignal’
[16:04:44.424]   - Field: ‘lazy’
[16:04:44.424]   - Field: ‘state’
[16:04:44.425] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.425] - Launch lazy future ...
[16:04:44.425] Packages needed by the future expression (n = 0): <none>
[16:04:44.425] Packages needed by future strategies (n = 0): <none>
[16:04:44.425] {
[16:04:44.425]     {
[16:04:44.425]         {
[16:04:44.425]             ...future.startTime <- base::Sys.time()
[16:04:44.425]             {
[16:04:44.425]                 {
[16:04:44.425]                   {
[16:04:44.425]                     {
[16:04:44.425]                       base::local({
[16:04:44.425]                         has_future <- base::requireNamespace("future", 
[16:04:44.425]                           quietly = TRUE)
[16:04:44.425]                         if (has_future) {
[16:04:44.425]                           ns <- base::getNamespace("future")
[16:04:44.425]                           version <- ns[[".package"]][["version"]]
[16:04:44.425]                           if (is.null(version)) 
[16:04:44.425]                             version <- utils::packageVersion("future")
[16:04:44.425]                         }
[16:04:44.425]                         else {
[16:04:44.425]                           version <- NULL
[16:04:44.425]                         }
[16:04:44.425]                         if (!has_future || version < "1.8.0") {
[16:04:44.425]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.425]                             "", base::R.version$version.string), 
[16:04:44.425]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.425]                               "release", "version")], collapse = " "), 
[16:04:44.425]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.425]                             info)
[16:04:44.425]                           info <- base::paste(info, collapse = "; ")
[16:04:44.425]                           if (!has_future) {
[16:04:44.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.425]                               info)
[16:04:44.425]                           }
[16:04:44.425]                           else {
[16:04:44.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.425]                               info, version)
[16:04:44.425]                           }
[16:04:44.425]                           base::stop(msg)
[16:04:44.425]                         }
[16:04:44.425]                       })
[16:04:44.425]                     }
[16:04:44.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.425]                     base::options(mc.cores = 1L)
[16:04:44.425]                   }
[16:04:44.425]                   options(future.plan = NULL)
[16:04:44.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.425]                 }
[16:04:44.425]                 ...future.workdir <- getwd()
[16:04:44.425]             }
[16:04:44.425]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.425]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.425]         }
[16:04:44.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.425]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.425]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.425]             base::names(...future.oldOptions))
[16:04:44.425]     }
[16:04:44.425]     if (FALSE) {
[16:04:44.425]     }
[16:04:44.425]     else {
[16:04:44.425]         if (TRUE) {
[16:04:44.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.425]                 open = "w")
[16:04:44.425]         }
[16:04:44.425]         else {
[16:04:44.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.425]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.425]         }
[16:04:44.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.425]             base::sink(type = "output", split = FALSE)
[16:04:44.425]             base::close(...future.stdout)
[16:04:44.425]         }, add = TRUE)
[16:04:44.425]     }
[16:04:44.425]     ...future.frame <- base::sys.nframe()
[16:04:44.425]     ...future.conditions <- base::list()
[16:04:44.425]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.425]     if (FALSE) {
[16:04:44.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.425]     }
[16:04:44.425]     ...future.result <- base::tryCatch({
[16:04:44.425]         base::withCallingHandlers({
[16:04:44.425]             ...future.value <- base::withVisible(base::local({
[16:04:44.425]                 ...future.makeSendCondition <- base::local({
[16:04:44.425]                   sendCondition <- NULL
[16:04:44.425]                   function(frame = 1L) {
[16:04:44.425]                     if (is.function(sendCondition)) 
[16:04:44.425]                       return(sendCondition)
[16:04:44.425]                     ns <- getNamespace("parallel")
[16:04:44.425]                     if (exists("sendData", mode = "function", 
[16:04:44.425]                       envir = ns)) {
[16:04:44.425]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.425]                         envir = ns)
[16:04:44.425]                       envir <- sys.frame(frame)
[16:04:44.425]                       master <- NULL
[16:04:44.425]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.425]                         !identical(envir, emptyenv())) {
[16:04:44.425]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.425]                           inherits = FALSE)) {
[16:04:44.425]                           master <- get("master", mode = "list", 
[16:04:44.425]                             envir = envir, inherits = FALSE)
[16:04:44.425]                           if (inherits(master, c("SOCKnode", 
[16:04:44.425]                             "SOCK0node"))) {
[16:04:44.425]                             sendCondition <<- function(cond) {
[16:04:44.425]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.425]                                 success = TRUE)
[16:04:44.425]                               parallel_sendData(master, data)
[16:04:44.425]                             }
[16:04:44.425]                             return(sendCondition)
[16:04:44.425]                           }
[16:04:44.425]                         }
[16:04:44.425]                         frame <- frame + 1L
[16:04:44.425]                         envir <- sys.frame(frame)
[16:04:44.425]                       }
[16:04:44.425]                     }
[16:04:44.425]                     sendCondition <<- function(cond) NULL
[16:04:44.425]                   }
[16:04:44.425]                 })
[16:04:44.425]                 withCallingHandlers({
[16:04:44.425]                   NULL
[16:04:44.425]                 }, immediateCondition = function(cond) {
[16:04:44.425]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.425]                   sendCondition(cond)
[16:04:44.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.425]                   {
[16:04:44.425]                     inherits <- base::inherits
[16:04:44.425]                     invokeRestart <- base::invokeRestart
[16:04:44.425]                     is.null <- base::is.null
[16:04:44.425]                     muffled <- FALSE
[16:04:44.425]                     if (inherits(cond, "message")) {
[16:04:44.425]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.425]                       if (muffled) 
[16:04:44.425]                         invokeRestart("muffleMessage")
[16:04:44.425]                     }
[16:04:44.425]                     else if (inherits(cond, "warning")) {
[16:04:44.425]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.425]                       if (muffled) 
[16:04:44.425]                         invokeRestart("muffleWarning")
[16:04:44.425]                     }
[16:04:44.425]                     else if (inherits(cond, "condition")) {
[16:04:44.425]                       if (!is.null(pattern)) {
[16:04:44.425]                         computeRestarts <- base::computeRestarts
[16:04:44.425]                         grepl <- base::grepl
[16:04:44.425]                         restarts <- computeRestarts(cond)
[16:04:44.425]                         for (restart in restarts) {
[16:04:44.425]                           name <- restart$name
[16:04:44.425]                           if (is.null(name)) 
[16:04:44.425]                             next
[16:04:44.425]                           if (!grepl(pattern, name)) 
[16:04:44.425]                             next
[16:04:44.425]                           invokeRestart(restart)
[16:04:44.425]                           muffled <- TRUE
[16:04:44.425]                           break
[16:04:44.425]                         }
[16:04:44.425]                       }
[16:04:44.425]                     }
[16:04:44.425]                     invisible(muffled)
[16:04:44.425]                   }
[16:04:44.425]                   muffleCondition(cond)
[16:04:44.425]                 })
[16:04:44.425]             }))
[16:04:44.425]             future::FutureResult(value = ...future.value$value, 
[16:04:44.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.425]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.425]                     ...future.globalenv.names))
[16:04:44.425]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.425]         }, condition = base::local({
[16:04:44.425]             c <- base::c
[16:04:44.425]             inherits <- base::inherits
[16:04:44.425]             invokeRestart <- base::invokeRestart
[16:04:44.425]             length <- base::length
[16:04:44.425]             list <- base::list
[16:04:44.425]             seq.int <- base::seq.int
[16:04:44.425]             signalCondition <- base::signalCondition
[16:04:44.425]             sys.calls <- base::sys.calls
[16:04:44.425]             `[[` <- base::`[[`
[16:04:44.425]             `+` <- base::`+`
[16:04:44.425]             `<<-` <- base::`<<-`
[16:04:44.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.425]                   3L)]
[16:04:44.425]             }
[16:04:44.425]             function(cond) {
[16:04:44.425]                 is_error <- inherits(cond, "error")
[16:04:44.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.425]                   NULL)
[16:04:44.425]                 if (is_error) {
[16:04:44.425]                   sessionInformation <- function() {
[16:04:44.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.425]                       search = base::search(), system = base::Sys.info())
[16:04:44.425]                   }
[16:04:44.425]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.425]                     cond$call), session = sessionInformation(), 
[16:04:44.425]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.425]                   signalCondition(cond)
[16:04:44.425]                 }
[16:04:44.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.425]                 "immediateCondition"))) {
[16:04:44.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.425]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.425]                   if (TRUE && !signal) {
[16:04:44.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.425]                     {
[16:04:44.425]                       inherits <- base::inherits
[16:04:44.425]                       invokeRestart <- base::invokeRestart
[16:04:44.425]                       is.null <- base::is.null
[16:04:44.425]                       muffled <- FALSE
[16:04:44.425]                       if (inherits(cond, "message")) {
[16:04:44.425]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.425]                         if (muffled) 
[16:04:44.425]                           invokeRestart("muffleMessage")
[16:04:44.425]                       }
[16:04:44.425]                       else if (inherits(cond, "warning")) {
[16:04:44.425]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.425]                         if (muffled) 
[16:04:44.425]                           invokeRestart("muffleWarning")
[16:04:44.425]                       }
[16:04:44.425]                       else if (inherits(cond, "condition")) {
[16:04:44.425]                         if (!is.null(pattern)) {
[16:04:44.425]                           computeRestarts <- base::computeRestarts
[16:04:44.425]                           grepl <- base::grepl
[16:04:44.425]                           restarts <- computeRestarts(cond)
[16:04:44.425]                           for (restart in restarts) {
[16:04:44.425]                             name <- restart$name
[16:04:44.425]                             if (is.null(name)) 
[16:04:44.425]                               next
[16:04:44.425]                             if (!grepl(pattern, name)) 
[16:04:44.425]                               next
[16:04:44.425]                             invokeRestart(restart)
[16:04:44.425]                             muffled <- TRUE
[16:04:44.425]                             break
[16:04:44.425]                           }
[16:04:44.425]                         }
[16:04:44.425]                       }
[16:04:44.425]                       invisible(muffled)
[16:04:44.425]                     }
[16:04:44.425]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.425]                   }
[16:04:44.425]                 }
[16:04:44.425]                 else {
[16:04:44.425]                   if (TRUE) {
[16:04:44.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.425]                     {
[16:04:44.425]                       inherits <- base::inherits
[16:04:44.425]                       invokeRestart <- base::invokeRestart
[16:04:44.425]                       is.null <- base::is.null
[16:04:44.425]                       muffled <- FALSE
[16:04:44.425]                       if (inherits(cond, "message")) {
[16:04:44.425]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.425]                         if (muffled) 
[16:04:44.425]                           invokeRestart("muffleMessage")
[16:04:44.425]                       }
[16:04:44.425]                       else if (inherits(cond, "warning")) {
[16:04:44.425]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.425]                         if (muffled) 
[16:04:44.425]                           invokeRestart("muffleWarning")
[16:04:44.425]                       }
[16:04:44.425]                       else if (inherits(cond, "condition")) {
[16:04:44.425]                         if (!is.null(pattern)) {
[16:04:44.425]                           computeRestarts <- base::computeRestarts
[16:04:44.425]                           grepl <- base::grepl
[16:04:44.425]                           restarts <- computeRestarts(cond)
[16:04:44.425]                           for (restart in restarts) {
[16:04:44.425]                             name <- restart$name
[16:04:44.425]                             if (is.null(name)) 
[16:04:44.425]                               next
[16:04:44.425]                             if (!grepl(pattern, name)) 
[16:04:44.425]                               next
[16:04:44.425]                             invokeRestart(restart)
[16:04:44.425]                             muffled <- TRUE
[16:04:44.425]                             break
[16:04:44.425]                           }
[16:04:44.425]                         }
[16:04:44.425]                       }
[16:04:44.425]                       invisible(muffled)
[16:04:44.425]                     }
[16:04:44.425]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.425]                   }
[16:04:44.425]                 }
[16:04:44.425]             }
[16:04:44.425]         }))
[16:04:44.425]     }, error = function(ex) {
[16:04:44.425]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.425]                 ...future.rng), started = ...future.startTime, 
[16:04:44.425]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.425]             version = "1.8"), class = "FutureResult")
[16:04:44.425]     }, finally = {
[16:04:44.425]         if (!identical(...future.workdir, getwd())) 
[16:04:44.425]             setwd(...future.workdir)
[16:04:44.425]         {
[16:04:44.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.425]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.425]             }
[16:04:44.425]             base::options(...future.oldOptions)
[16:04:44.425]             if (.Platform$OS.type == "windows") {
[16:04:44.425]                 old_names <- names(...future.oldEnvVars)
[16:04:44.425]                 envs <- base::Sys.getenv()
[16:04:44.425]                 names <- names(envs)
[16:04:44.425]                 common <- intersect(names, old_names)
[16:04:44.425]                 added <- setdiff(names, old_names)
[16:04:44.425]                 removed <- setdiff(old_names, names)
[16:04:44.425]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.425]                   envs[common]]
[16:04:44.425]                 NAMES <- toupper(changed)
[16:04:44.425]                 args <- list()
[16:04:44.425]                 for (kk in seq_along(NAMES)) {
[16:04:44.425]                   name <- changed[[kk]]
[16:04:44.425]                   NAME <- NAMES[[kk]]
[16:04:44.425]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.425]                     next
[16:04:44.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.425]                 }
[16:04:44.425]                 NAMES <- toupper(added)
[16:04:44.425]                 for (kk in seq_along(NAMES)) {
[16:04:44.425]                   name <- added[[kk]]
[16:04:44.425]                   NAME <- NAMES[[kk]]
[16:04:44.425]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.425]                     next
[16:04:44.425]                   args[[name]] <- ""
[16:04:44.425]                 }
[16:04:44.425]                 NAMES <- toupper(removed)
[16:04:44.425]                 for (kk in seq_along(NAMES)) {
[16:04:44.425]                   name <- removed[[kk]]
[16:04:44.425]                   NAME <- NAMES[[kk]]
[16:04:44.425]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.425]                     next
[16:04:44.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.425]                 }
[16:04:44.425]                 if (length(args) > 0) 
[16:04:44.425]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.425]             }
[16:04:44.425]             else {
[16:04:44.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.425]             }
[16:04:44.425]             {
[16:04:44.425]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.425]                   0L) {
[16:04:44.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.425]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.425]                   base::options(opts)
[16:04:44.425]                 }
[16:04:44.425]                 {
[16:04:44.425]                   {
[16:04:44.425]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.425]                     NULL
[16:04:44.425]                   }
[16:04:44.425]                   options(future.plan = NULL)
[16:04:44.425]                   if (is.na(NA_character_)) 
[16:04:44.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.425]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.425]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.425]                     envir = parent.frame()) 
[16:04:44.425]                   {
[16:04:44.425]                     if (is.function(workers)) 
[16:04:44.425]                       workers <- workers()
[16:04:44.425]                     workers <- structure(as.integer(workers), 
[16:04:44.425]                       class = class(workers))
[16:04:44.425]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.425]                       workers >= 1)
[16:04:44.425]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.425]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.425]                     }
[16:04:44.425]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.425]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.425]                       envir = envir)
[16:04:44.425]                     if (!future$lazy) 
[16:04:44.425]                       future <- run(future)
[16:04:44.425]                     invisible(future)
[16:04:44.425]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.425]                 }
[16:04:44.425]             }
[16:04:44.425]         }
[16:04:44.425]     })
[16:04:44.425]     if (TRUE) {
[16:04:44.425]         base::sink(type = "output", split = FALSE)
[16:04:44.425]         if (TRUE) {
[16:04:44.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.425]         }
[16:04:44.425]         else {
[16:04:44.425]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.425]         }
[16:04:44.425]         base::close(...future.stdout)
[16:04:44.425]         ...future.stdout <- NULL
[16:04:44.425]     }
[16:04:44.425]     ...future.result$conditions <- ...future.conditions
[16:04:44.425]     ...future.result$finished <- base::Sys.time()
[16:04:44.425]     ...future.result
[16:04:44.425] }
[16:04:44.428] MultisessionFuture started
[16:04:44.429] - Launch lazy future ... done
[16:04:44.429] run() for ‘MultisessionFuture’ ... done
[16:04:44.429] getGlobalsAndPackages() ...
[16:04:44.429] Searching for globals...
[16:04:44.430] - globals found: [1] ‘{’
[16:04:44.430] Searching for globals ... DONE
[16:04:44.430] Resolving globals: FALSE
[16:04:44.430] 
[16:04:44.430] 
[16:04:44.430] getGlobalsAndPackages() ... DONE
[16:04:44.431] run() for ‘Future’ ...
[16:04:44.431] - state: ‘created’
[16:04:44.431] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.444] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.445] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.445]   - Field: ‘node’
[16:04:44.445]   - Field: ‘label’
[16:04:44.445]   - Field: ‘local’
[16:04:44.445]   - Field: ‘owner’
[16:04:44.445]   - Field: ‘envir’
[16:04:44.445]   - Field: ‘workers’
[16:04:44.445]   - Field: ‘packages’
[16:04:44.445]   - Field: ‘gc’
[16:04:44.445]   - Field: ‘conditions’
[16:04:44.446]   - Field: ‘persistent’
[16:04:44.446]   - Field: ‘expr’
[16:04:44.446]   - Field: ‘uuid’
[16:04:44.446]   - Field: ‘seed’
[16:04:44.446]   - Field: ‘version’
[16:04:44.446]   - Field: ‘result’
[16:04:44.446]   - Field: ‘asynchronous’
[16:04:44.446]   - Field: ‘calls’
[16:04:44.446]   - Field: ‘globals’
[16:04:44.446]   - Field: ‘stdout’
[16:04:44.446]   - Field: ‘earlySignal’
[16:04:44.447]   - Field: ‘lazy’
[16:04:44.447]   - Field: ‘state’
[16:04:44.447] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.447] - Launch lazy future ...
[16:04:44.447] Packages needed by the future expression (n = 0): <none>
[16:04:44.447] Packages needed by future strategies (n = 0): <none>
[16:04:44.448] {
[16:04:44.448]     {
[16:04:44.448]         {
[16:04:44.448]             ...future.startTime <- base::Sys.time()
[16:04:44.448]             {
[16:04:44.448]                 {
[16:04:44.448]                   {
[16:04:44.448]                     {
[16:04:44.448]                       base::local({
[16:04:44.448]                         has_future <- base::requireNamespace("future", 
[16:04:44.448]                           quietly = TRUE)
[16:04:44.448]                         if (has_future) {
[16:04:44.448]                           ns <- base::getNamespace("future")
[16:04:44.448]                           version <- ns[[".package"]][["version"]]
[16:04:44.448]                           if (is.null(version)) 
[16:04:44.448]                             version <- utils::packageVersion("future")
[16:04:44.448]                         }
[16:04:44.448]                         else {
[16:04:44.448]                           version <- NULL
[16:04:44.448]                         }
[16:04:44.448]                         if (!has_future || version < "1.8.0") {
[16:04:44.448]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.448]                             "", base::R.version$version.string), 
[16:04:44.448]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.448]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.448]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.448]                               "release", "version")], collapse = " "), 
[16:04:44.448]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.448]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.448]                             info)
[16:04:44.448]                           info <- base::paste(info, collapse = "; ")
[16:04:44.448]                           if (!has_future) {
[16:04:44.448]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.448]                               info)
[16:04:44.448]                           }
[16:04:44.448]                           else {
[16:04:44.448]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.448]                               info, version)
[16:04:44.448]                           }
[16:04:44.448]                           base::stop(msg)
[16:04:44.448]                         }
[16:04:44.448]                       })
[16:04:44.448]                     }
[16:04:44.448]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.448]                     base::options(mc.cores = 1L)
[16:04:44.448]                   }
[16:04:44.448]                   options(future.plan = NULL)
[16:04:44.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.448]                 }
[16:04:44.448]                 ...future.workdir <- getwd()
[16:04:44.448]             }
[16:04:44.448]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.448]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.448]         }
[16:04:44.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.448]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.448]             base::names(...future.oldOptions))
[16:04:44.448]     }
[16:04:44.448]     if (FALSE) {
[16:04:44.448]     }
[16:04:44.448]     else {
[16:04:44.448]         if (TRUE) {
[16:04:44.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.448]                 open = "w")
[16:04:44.448]         }
[16:04:44.448]         else {
[16:04:44.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.448]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.448]         }
[16:04:44.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.448]             base::sink(type = "output", split = FALSE)
[16:04:44.448]             base::close(...future.stdout)
[16:04:44.448]         }, add = TRUE)
[16:04:44.448]     }
[16:04:44.448]     ...future.frame <- base::sys.nframe()
[16:04:44.448]     ...future.conditions <- base::list()
[16:04:44.448]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.448]     if (FALSE) {
[16:04:44.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.448]     }
[16:04:44.448]     ...future.result <- base::tryCatch({
[16:04:44.448]         base::withCallingHandlers({
[16:04:44.448]             ...future.value <- base::withVisible(base::local({
[16:04:44.448]                 ...future.makeSendCondition <- base::local({
[16:04:44.448]                   sendCondition <- NULL
[16:04:44.448]                   function(frame = 1L) {
[16:04:44.448]                     if (is.function(sendCondition)) 
[16:04:44.448]                       return(sendCondition)
[16:04:44.448]                     ns <- getNamespace("parallel")
[16:04:44.448]                     if (exists("sendData", mode = "function", 
[16:04:44.448]                       envir = ns)) {
[16:04:44.448]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.448]                         envir = ns)
[16:04:44.448]                       envir <- sys.frame(frame)
[16:04:44.448]                       master <- NULL
[16:04:44.448]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.448]                         !identical(envir, emptyenv())) {
[16:04:44.448]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.448]                           inherits = FALSE)) {
[16:04:44.448]                           master <- get("master", mode = "list", 
[16:04:44.448]                             envir = envir, inherits = FALSE)
[16:04:44.448]                           if (inherits(master, c("SOCKnode", 
[16:04:44.448]                             "SOCK0node"))) {
[16:04:44.448]                             sendCondition <<- function(cond) {
[16:04:44.448]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.448]                                 success = TRUE)
[16:04:44.448]                               parallel_sendData(master, data)
[16:04:44.448]                             }
[16:04:44.448]                             return(sendCondition)
[16:04:44.448]                           }
[16:04:44.448]                         }
[16:04:44.448]                         frame <- frame + 1L
[16:04:44.448]                         envir <- sys.frame(frame)
[16:04:44.448]                       }
[16:04:44.448]                     }
[16:04:44.448]                     sendCondition <<- function(cond) NULL
[16:04:44.448]                   }
[16:04:44.448]                 })
[16:04:44.448]                 withCallingHandlers({
[16:04:44.448]                   {
[16:04:44.448]                     4
[16:04:44.448]                   }
[16:04:44.448]                 }, immediateCondition = function(cond) {
[16:04:44.448]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.448]                   sendCondition(cond)
[16:04:44.448]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.448]                   {
[16:04:44.448]                     inherits <- base::inherits
[16:04:44.448]                     invokeRestart <- base::invokeRestart
[16:04:44.448]                     is.null <- base::is.null
[16:04:44.448]                     muffled <- FALSE
[16:04:44.448]                     if (inherits(cond, "message")) {
[16:04:44.448]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.448]                       if (muffled) 
[16:04:44.448]                         invokeRestart("muffleMessage")
[16:04:44.448]                     }
[16:04:44.448]                     else if (inherits(cond, "warning")) {
[16:04:44.448]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.448]                       if (muffled) 
[16:04:44.448]                         invokeRestart("muffleWarning")
[16:04:44.448]                     }
[16:04:44.448]                     else if (inherits(cond, "condition")) {
[16:04:44.448]                       if (!is.null(pattern)) {
[16:04:44.448]                         computeRestarts <- base::computeRestarts
[16:04:44.448]                         grepl <- base::grepl
[16:04:44.448]                         restarts <- computeRestarts(cond)
[16:04:44.448]                         for (restart in restarts) {
[16:04:44.448]                           name <- restart$name
[16:04:44.448]                           if (is.null(name)) 
[16:04:44.448]                             next
[16:04:44.448]                           if (!grepl(pattern, name)) 
[16:04:44.448]                             next
[16:04:44.448]                           invokeRestart(restart)
[16:04:44.448]                           muffled <- TRUE
[16:04:44.448]                           break
[16:04:44.448]                         }
[16:04:44.448]                       }
[16:04:44.448]                     }
[16:04:44.448]                     invisible(muffled)
[16:04:44.448]                   }
[16:04:44.448]                   muffleCondition(cond)
[16:04:44.448]                 })
[16:04:44.448]             }))
[16:04:44.448]             future::FutureResult(value = ...future.value$value, 
[16:04:44.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.448]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.448]                     ...future.globalenv.names))
[16:04:44.448]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.448]         }, condition = base::local({
[16:04:44.448]             c <- base::c
[16:04:44.448]             inherits <- base::inherits
[16:04:44.448]             invokeRestart <- base::invokeRestart
[16:04:44.448]             length <- base::length
[16:04:44.448]             list <- base::list
[16:04:44.448]             seq.int <- base::seq.int
[16:04:44.448]             signalCondition <- base::signalCondition
[16:04:44.448]             sys.calls <- base::sys.calls
[16:04:44.448]             `[[` <- base::`[[`
[16:04:44.448]             `+` <- base::`+`
[16:04:44.448]             `<<-` <- base::`<<-`
[16:04:44.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.448]                   3L)]
[16:04:44.448]             }
[16:04:44.448]             function(cond) {
[16:04:44.448]                 is_error <- inherits(cond, "error")
[16:04:44.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.448]                   NULL)
[16:04:44.448]                 if (is_error) {
[16:04:44.448]                   sessionInformation <- function() {
[16:04:44.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.448]                       search = base::search(), system = base::Sys.info())
[16:04:44.448]                   }
[16:04:44.448]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.448]                     cond$call), session = sessionInformation(), 
[16:04:44.448]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.448]                   signalCondition(cond)
[16:04:44.448]                 }
[16:04:44.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.448]                 "immediateCondition"))) {
[16:04:44.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.448]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.448]                   if (TRUE && !signal) {
[16:04:44.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.448]                     {
[16:04:44.448]                       inherits <- base::inherits
[16:04:44.448]                       invokeRestart <- base::invokeRestart
[16:04:44.448]                       is.null <- base::is.null
[16:04:44.448]                       muffled <- FALSE
[16:04:44.448]                       if (inherits(cond, "message")) {
[16:04:44.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.448]                         if (muffled) 
[16:04:44.448]                           invokeRestart("muffleMessage")
[16:04:44.448]                       }
[16:04:44.448]                       else if (inherits(cond, "warning")) {
[16:04:44.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.448]                         if (muffled) 
[16:04:44.448]                           invokeRestart("muffleWarning")
[16:04:44.448]                       }
[16:04:44.448]                       else if (inherits(cond, "condition")) {
[16:04:44.448]                         if (!is.null(pattern)) {
[16:04:44.448]                           computeRestarts <- base::computeRestarts
[16:04:44.448]                           grepl <- base::grepl
[16:04:44.448]                           restarts <- computeRestarts(cond)
[16:04:44.448]                           for (restart in restarts) {
[16:04:44.448]                             name <- restart$name
[16:04:44.448]                             if (is.null(name)) 
[16:04:44.448]                               next
[16:04:44.448]                             if (!grepl(pattern, name)) 
[16:04:44.448]                               next
[16:04:44.448]                             invokeRestart(restart)
[16:04:44.448]                             muffled <- TRUE
[16:04:44.448]                             break
[16:04:44.448]                           }
[16:04:44.448]                         }
[16:04:44.448]                       }
[16:04:44.448]                       invisible(muffled)
[16:04:44.448]                     }
[16:04:44.448]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.448]                   }
[16:04:44.448]                 }
[16:04:44.448]                 else {
[16:04:44.448]                   if (TRUE) {
[16:04:44.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.448]                     {
[16:04:44.448]                       inherits <- base::inherits
[16:04:44.448]                       invokeRestart <- base::invokeRestart
[16:04:44.448]                       is.null <- base::is.null
[16:04:44.448]                       muffled <- FALSE
[16:04:44.448]                       if (inherits(cond, "message")) {
[16:04:44.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.448]                         if (muffled) 
[16:04:44.448]                           invokeRestart("muffleMessage")
[16:04:44.448]                       }
[16:04:44.448]                       else if (inherits(cond, "warning")) {
[16:04:44.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.448]                         if (muffled) 
[16:04:44.448]                           invokeRestart("muffleWarning")
[16:04:44.448]                       }
[16:04:44.448]                       else if (inherits(cond, "condition")) {
[16:04:44.448]                         if (!is.null(pattern)) {
[16:04:44.448]                           computeRestarts <- base::computeRestarts
[16:04:44.448]                           grepl <- base::grepl
[16:04:44.448]                           restarts <- computeRestarts(cond)
[16:04:44.448]                           for (restart in restarts) {
[16:04:44.448]                             name <- restart$name
[16:04:44.448]                             if (is.null(name)) 
[16:04:44.448]                               next
[16:04:44.448]                             if (!grepl(pattern, name)) 
[16:04:44.448]                               next
[16:04:44.448]                             invokeRestart(restart)
[16:04:44.448]                             muffled <- TRUE
[16:04:44.448]                             break
[16:04:44.448]                           }
[16:04:44.448]                         }
[16:04:44.448]                       }
[16:04:44.448]                       invisible(muffled)
[16:04:44.448]                     }
[16:04:44.448]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.448]                   }
[16:04:44.448]                 }
[16:04:44.448]             }
[16:04:44.448]         }))
[16:04:44.448]     }, error = function(ex) {
[16:04:44.448]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.448]                 ...future.rng), started = ...future.startTime, 
[16:04:44.448]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.448]             version = "1.8"), class = "FutureResult")
[16:04:44.448]     }, finally = {
[16:04:44.448]         if (!identical(...future.workdir, getwd())) 
[16:04:44.448]             setwd(...future.workdir)
[16:04:44.448]         {
[16:04:44.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.448]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.448]             }
[16:04:44.448]             base::options(...future.oldOptions)
[16:04:44.448]             if (.Platform$OS.type == "windows") {
[16:04:44.448]                 old_names <- names(...future.oldEnvVars)
[16:04:44.448]                 envs <- base::Sys.getenv()
[16:04:44.448]                 names <- names(envs)
[16:04:44.448]                 common <- intersect(names, old_names)
[16:04:44.448]                 added <- setdiff(names, old_names)
[16:04:44.448]                 removed <- setdiff(old_names, names)
[16:04:44.448]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.448]                   envs[common]]
[16:04:44.448]                 NAMES <- toupper(changed)
[16:04:44.448]                 args <- list()
[16:04:44.448]                 for (kk in seq_along(NAMES)) {
[16:04:44.448]                   name <- changed[[kk]]
[16:04:44.448]                   NAME <- NAMES[[kk]]
[16:04:44.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.448]                     next
[16:04:44.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.448]                 }
[16:04:44.448]                 NAMES <- toupper(added)
[16:04:44.448]                 for (kk in seq_along(NAMES)) {
[16:04:44.448]                   name <- added[[kk]]
[16:04:44.448]                   NAME <- NAMES[[kk]]
[16:04:44.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.448]                     next
[16:04:44.448]                   args[[name]] <- ""
[16:04:44.448]                 }
[16:04:44.448]                 NAMES <- toupper(removed)
[16:04:44.448]                 for (kk in seq_along(NAMES)) {
[16:04:44.448]                   name <- removed[[kk]]
[16:04:44.448]                   NAME <- NAMES[[kk]]
[16:04:44.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.448]                     next
[16:04:44.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.448]                 }
[16:04:44.448]                 if (length(args) > 0) 
[16:04:44.448]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.448]             }
[16:04:44.448]             else {
[16:04:44.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.448]             }
[16:04:44.448]             {
[16:04:44.448]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.448]                   0L) {
[16:04:44.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.448]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.448]                   base::options(opts)
[16:04:44.448]                 }
[16:04:44.448]                 {
[16:04:44.448]                   {
[16:04:44.448]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.448]                     NULL
[16:04:44.448]                   }
[16:04:44.448]                   options(future.plan = NULL)
[16:04:44.448]                   if (is.na(NA_character_)) 
[16:04:44.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.448]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.448]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.448]                     envir = parent.frame()) 
[16:04:44.448]                   {
[16:04:44.448]                     if (is.function(workers)) 
[16:04:44.448]                       workers <- workers()
[16:04:44.448]                     workers <- structure(as.integer(workers), 
[16:04:44.448]                       class = class(workers))
[16:04:44.448]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.448]                       workers >= 1)
[16:04:44.448]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.448]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.448]                     }
[16:04:44.448]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.448]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.448]                       envir = envir)
[16:04:44.448]                     if (!future$lazy) 
[16:04:44.448]                       future <- run(future)
[16:04:44.448]                     invisible(future)
[16:04:44.448]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.448]                 }
[16:04:44.448]             }
[16:04:44.448]         }
[16:04:44.448]     })
[16:04:44.448]     if (TRUE) {
[16:04:44.448]         base::sink(type = "output", split = FALSE)
[16:04:44.448]         if (TRUE) {
[16:04:44.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.448]         }
[16:04:44.448]         else {
[16:04:44.448]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.448]         }
[16:04:44.448]         base::close(...future.stdout)
[16:04:44.448]         ...future.stdout <- NULL
[16:04:44.448]     }
[16:04:44.448]     ...future.result$conditions <- ...future.conditions
[16:04:44.448]     ...future.result$finished <- base::Sys.time()
[16:04:44.448]     ...future.result
[16:04:44.448] }
[16:04:44.450] Poll #1 (0): usedNodes() = 2, workers = 2
[16:04:44.461] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.461] - Validating connection of MultisessionFuture
[16:04:44.461] - received message: FutureResult
[16:04:44.461] - Received FutureResult
[16:04:44.461] - Erased future from FutureRegistry
[16:04:44.461] result() for ClusterFuture ...
[16:04:44.461] - result already collected: FutureResult
[16:04:44.461] result() for ClusterFuture ... done
[16:04:44.462] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:44.462] result() for ClusterFuture ...
[16:04:44.462] - result already collected: FutureResult
[16:04:44.462] result() for ClusterFuture ... done
[16:04:44.462] result() for ClusterFuture ...
[16:04:44.462] - result already collected: FutureResult
[16:04:44.462] result() for ClusterFuture ... done
[16:04:44.463] MultisessionFuture started
[16:04:44.463] - Launch lazy future ... done
[16:04:44.463] run() for ‘MultisessionFuture’ ... done
<environment: 0x55874eef9e10> 
<environment: 0x55874fa4bfe8> 
[16:04:44.476] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.476] - Validating connection of MultisessionFuture
[16:04:44.476] - received message: FutureResult
[16:04:44.476] - Received FutureResult
[16:04:44.476] - Erased future from FutureRegistry
[16:04:44.476] result() for ClusterFuture ...
[16:04:44.477] - result already collected: FutureResult
[16:04:44.477] result() for ClusterFuture ... done
[16:04:44.477] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:44.488] resolve() on environment ...
[16:04:44.488]  recursive: 0
[16:04:44.489]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:44.489] signalConditionsASAP(numeric, pos=1) ...
[16:04:44.489] - nx: 4
[16:04:44.489] - relay: TRUE
[16:04:44.489] - stdout: TRUE
[16:04:44.489] - signal: TRUE
[16:04:44.490] - resignal: FALSE
[16:04:44.490] - force: TRUE
[16:04:44.490] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.490] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.490]  - until=2
[16:04:44.490]  - relaying element #2
[16:04:44.490] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:44.490] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.490] signalConditionsASAP(NULL, pos=1) ... done
[16:04:44.490]  length: 3 (resolved future 1)
[16:04:44.490] Future #2
[16:04:44.491] result() for ClusterFuture ...
[16:04:44.491] - result already collected: FutureResult
[16:04:44.491] result() for ClusterFuture ... done
[16:04:44.491] result() for ClusterFuture ...
[16:04:44.491] - result already collected: FutureResult
[16:04:44.491] result() for ClusterFuture ... done
[16:04:44.491] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:44.491] - nx: 4
[16:04:44.491] - relay: TRUE
[16:04:44.491] - stdout: TRUE
[16:04:44.491] - signal: TRUE
[16:04:44.492] - resignal: FALSE
[16:04:44.492] - force: TRUE
[16:04:44.492] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:44.492] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.492]  - until=2
[16:04:44.492]  - relaying element #2
[16:04:44.492] result() for ClusterFuture ...
[16:04:44.492] - result already collected: FutureResult
[16:04:44.492] result() for ClusterFuture ... done
[16:04:44.492] result() for ClusterFuture ...
[16:04:44.492] - result already collected: FutureResult
[16:04:44.492] result() for ClusterFuture ... done
[16:04:44.493] result() for ClusterFuture ...
[16:04:44.493] - result already collected: FutureResult
[16:04:44.493] result() for ClusterFuture ... done
[16:04:44.493] result() for ClusterFuture ...
[16:04:44.493] - result already collected: FutureResult
[16:04:44.493] result() for ClusterFuture ... done
[16:04:44.493] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:44.493] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:44.493] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:44.493]  length: 2 (resolved future 2)
[16:04:44.493] Future #3
[16:04:44.494] result() for ClusterFuture ...
[16:04:44.494] - result already collected: FutureResult
[16:04:44.494] result() for ClusterFuture ... done
[16:04:44.494] result() for ClusterFuture ...
[16:04:44.494] - result already collected: FutureResult
[16:04:44.494] result() for ClusterFuture ... done
[16:04:44.494] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:44.494] - nx: 4
[16:04:44.494] - relay: TRUE
[16:04:44.494] - stdout: TRUE
[16:04:44.494] - signal: TRUE
[16:04:44.494] - resignal: FALSE
[16:04:44.495] - force: TRUE
[16:04:44.495] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:44.495] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:44.495]  - until=3
[16:04:44.495]  - relaying element #3
[16:04:44.495] result() for ClusterFuture ...
[16:04:44.495] - result already collected: FutureResult
[16:04:44.495] result() for ClusterFuture ... done
[16:04:44.495] result() for ClusterFuture ...
[16:04:44.495] - result already collected: FutureResult
[16:04:44.495] result() for ClusterFuture ... done
[16:04:44.496] result() for ClusterFuture ...
[16:04:44.496] - result already collected: FutureResult
[16:04:44.496] result() for ClusterFuture ... done
[16:04:44.496] result() for ClusterFuture ...
[16:04:44.496] - result already collected: FutureResult
[16:04:44.496] result() for ClusterFuture ... done
[16:04:44.496] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:44.496] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:44.496] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:44.496]  length: 1 (resolved future 3)
[16:04:44.517] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.517] - Validating connection of MultisessionFuture
[16:04:44.518] - received message: FutureResult
[16:04:44.518] - Received FutureResult
[16:04:44.518] - Erased future from FutureRegistry
[16:04:44.518] result() for ClusterFuture ...
[16:04:44.518] - result already collected: FutureResult
[16:04:44.518] result() for ClusterFuture ... done
[16:04:44.518] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:44.518] Future #4
[16:04:44.518] result() for ClusterFuture ...
[16:04:44.519] - result already collected: FutureResult
[16:04:44.519] result() for ClusterFuture ... done
[16:04:44.519] result() for ClusterFuture ...
[16:04:44.519] - result already collected: FutureResult
[16:04:44.519] result() for ClusterFuture ... done
[16:04:44.519] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:04:44.519] - nx: 4
[16:04:44.519] - relay: TRUE
[16:04:44.519] - stdout: TRUE
[16:04:44.519] - signal: TRUE
[16:04:44.519] - resignal: FALSE
[16:04:44.520] - force: TRUE
[16:04:44.520] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:44.520] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:44.520]  - until=4
[16:04:44.520]  - relaying element #4
[16:04:44.520] result() for ClusterFuture ...
[16:04:44.520] - result already collected: FutureResult
[16:04:44.520] result() for ClusterFuture ... done
[16:04:44.520] result() for ClusterFuture ...
[16:04:44.520] - result already collected: FutureResult
[16:04:44.520] result() for ClusterFuture ... done
[16:04:44.521] result() for ClusterFuture ...
[16:04:44.521] - result already collected: FutureResult
[16:04:44.521] result() for ClusterFuture ... done
[16:04:44.521] result() for ClusterFuture ...
[16:04:44.521] - result already collected: FutureResult
[16:04:44.521] result() for ClusterFuture ... done
[16:04:44.521] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.521] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:44.521] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:04:44.521]  length: 0 (resolved future 4)
[16:04:44.521] Relaying remaining futures
[16:04:44.521] signalConditionsASAP(NULL, pos=0) ...
[16:04:44.522] - nx: 4
[16:04:44.522] - relay: TRUE
[16:04:44.522] - stdout: TRUE
[16:04:44.522] - signal: TRUE
[16:04:44.522] - resignal: FALSE
[16:04:44.522] - force: TRUE
[16:04:44.522] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.522] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:44.522] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.522] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:44.522] signalConditionsASAP(NULL, pos=0) ... done
[16:04:44.522] resolve() on environment ... DONE
[16:04:44.523] result() for ClusterFuture ...
[16:04:44.523] - result already collected: FutureResult
[16:04:44.523] result() for ClusterFuture ... done
[16:04:44.523] result() for ClusterFuture ...
[16:04:44.523] - result already collected: FutureResult
[16:04:44.523] result() for ClusterFuture ... done
[16:04:44.523] result() for ClusterFuture ...
[16:04:44.523] - result already collected: FutureResult
[16:04:44.523] result() for ClusterFuture ... done
[16:04:44.523] result() for ClusterFuture ...
[16:04:44.524] - result already collected: FutureResult
[16:04:44.524] result() for ClusterFuture ... done
[16:04:44.524] result() for ClusterFuture ...
[16:04:44.524] - result already collected: FutureResult
[16:04:44.524] result() for ClusterFuture ... done
[16:04:44.524] result() for ClusterFuture ...
[16:04:44.524] - result already collected: FutureResult
[16:04:44.524] result() for ClusterFuture ... done
<environment: 0x55874e2366c0> 
Dimensions: c(2, 3, 1)
[16:04:44.525] getGlobalsAndPackages() ...
[16:04:44.525] Searching for globals...
[16:04:44.525] 
[16:04:44.525] Searching for globals ... DONE
[16:04:44.525] - globals: [0] <none>
[16:04:44.525] getGlobalsAndPackages() ... DONE
[16:04:44.526] run() for ‘Future’ ...
[16:04:44.526] - state: ‘created’
[16:04:44.526] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.541] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.542]   - Field: ‘node’
[16:04:44.542]   - Field: ‘label’
[16:04:44.542]   - Field: ‘local’
[16:04:44.542]   - Field: ‘owner’
[16:04:44.542]   - Field: ‘envir’
[16:04:44.542]   - Field: ‘workers’
[16:04:44.542]   - Field: ‘packages’
[16:04:44.542]   - Field: ‘gc’
[16:04:44.543]   - Field: ‘conditions’
[16:04:44.543]   - Field: ‘persistent’
[16:04:44.543]   - Field: ‘expr’
[16:04:44.543]   - Field: ‘uuid’
[16:04:44.543]   - Field: ‘seed’
[16:04:44.543]   - Field: ‘version’
[16:04:44.543]   - Field: ‘result’
[16:04:44.543]   - Field: ‘asynchronous’
[16:04:44.543]   - Field: ‘calls’
[16:04:44.543]   - Field: ‘globals’
[16:04:44.544]   - Field: ‘stdout’
[16:04:44.544]   - Field: ‘earlySignal’
[16:04:44.544]   - Field: ‘lazy’
[16:04:44.544]   - Field: ‘state’
[16:04:44.544] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.544] - Launch lazy future ...
[16:04:44.544] Packages needed by the future expression (n = 0): <none>
[16:04:44.544] Packages needed by future strategies (n = 0): <none>
[16:04:44.545] {
[16:04:44.545]     {
[16:04:44.545]         {
[16:04:44.545]             ...future.startTime <- base::Sys.time()
[16:04:44.545]             {
[16:04:44.545]                 {
[16:04:44.545]                   {
[16:04:44.545]                     {
[16:04:44.545]                       base::local({
[16:04:44.545]                         has_future <- base::requireNamespace("future", 
[16:04:44.545]                           quietly = TRUE)
[16:04:44.545]                         if (has_future) {
[16:04:44.545]                           ns <- base::getNamespace("future")
[16:04:44.545]                           version <- ns[[".package"]][["version"]]
[16:04:44.545]                           if (is.null(version)) 
[16:04:44.545]                             version <- utils::packageVersion("future")
[16:04:44.545]                         }
[16:04:44.545]                         else {
[16:04:44.545]                           version <- NULL
[16:04:44.545]                         }
[16:04:44.545]                         if (!has_future || version < "1.8.0") {
[16:04:44.545]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.545]                             "", base::R.version$version.string), 
[16:04:44.545]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.545]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.545]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.545]                               "release", "version")], collapse = " "), 
[16:04:44.545]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.545]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.545]                             info)
[16:04:44.545]                           info <- base::paste(info, collapse = "; ")
[16:04:44.545]                           if (!has_future) {
[16:04:44.545]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.545]                               info)
[16:04:44.545]                           }
[16:04:44.545]                           else {
[16:04:44.545]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.545]                               info, version)
[16:04:44.545]                           }
[16:04:44.545]                           base::stop(msg)
[16:04:44.545]                         }
[16:04:44.545]                       })
[16:04:44.545]                     }
[16:04:44.545]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.545]                     base::options(mc.cores = 1L)
[16:04:44.545]                   }
[16:04:44.545]                   options(future.plan = NULL)
[16:04:44.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.545]                 }
[16:04:44.545]                 ...future.workdir <- getwd()
[16:04:44.545]             }
[16:04:44.545]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.545]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.545]         }
[16:04:44.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.545]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.545]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.545]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.545]             base::names(...future.oldOptions))
[16:04:44.545]     }
[16:04:44.545]     if (FALSE) {
[16:04:44.545]     }
[16:04:44.545]     else {
[16:04:44.545]         if (TRUE) {
[16:04:44.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.545]                 open = "w")
[16:04:44.545]         }
[16:04:44.545]         else {
[16:04:44.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.545]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.545]         }
[16:04:44.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.545]             base::sink(type = "output", split = FALSE)
[16:04:44.545]             base::close(...future.stdout)
[16:04:44.545]         }, add = TRUE)
[16:04:44.545]     }
[16:04:44.545]     ...future.frame <- base::sys.nframe()
[16:04:44.545]     ...future.conditions <- base::list()
[16:04:44.545]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.545]     if (FALSE) {
[16:04:44.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.545]     }
[16:04:44.545]     ...future.result <- base::tryCatch({
[16:04:44.545]         base::withCallingHandlers({
[16:04:44.545]             ...future.value <- base::withVisible(base::local({
[16:04:44.545]                 ...future.makeSendCondition <- base::local({
[16:04:44.545]                   sendCondition <- NULL
[16:04:44.545]                   function(frame = 1L) {
[16:04:44.545]                     if (is.function(sendCondition)) 
[16:04:44.545]                       return(sendCondition)
[16:04:44.545]                     ns <- getNamespace("parallel")
[16:04:44.545]                     if (exists("sendData", mode = "function", 
[16:04:44.545]                       envir = ns)) {
[16:04:44.545]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.545]                         envir = ns)
[16:04:44.545]                       envir <- sys.frame(frame)
[16:04:44.545]                       master <- NULL
[16:04:44.545]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.545]                         !identical(envir, emptyenv())) {
[16:04:44.545]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.545]                           inherits = FALSE)) {
[16:04:44.545]                           master <- get("master", mode = "list", 
[16:04:44.545]                             envir = envir, inherits = FALSE)
[16:04:44.545]                           if (inherits(master, c("SOCKnode", 
[16:04:44.545]                             "SOCK0node"))) {
[16:04:44.545]                             sendCondition <<- function(cond) {
[16:04:44.545]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.545]                                 success = TRUE)
[16:04:44.545]                               parallel_sendData(master, data)
[16:04:44.545]                             }
[16:04:44.545]                             return(sendCondition)
[16:04:44.545]                           }
[16:04:44.545]                         }
[16:04:44.545]                         frame <- frame + 1L
[16:04:44.545]                         envir <- sys.frame(frame)
[16:04:44.545]                       }
[16:04:44.545]                     }
[16:04:44.545]                     sendCondition <<- function(cond) NULL
[16:04:44.545]                   }
[16:04:44.545]                 })
[16:04:44.545]                 withCallingHandlers({
[16:04:44.545]                   2
[16:04:44.545]                 }, immediateCondition = function(cond) {
[16:04:44.545]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.545]                   sendCondition(cond)
[16:04:44.545]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.545]                   {
[16:04:44.545]                     inherits <- base::inherits
[16:04:44.545]                     invokeRestart <- base::invokeRestart
[16:04:44.545]                     is.null <- base::is.null
[16:04:44.545]                     muffled <- FALSE
[16:04:44.545]                     if (inherits(cond, "message")) {
[16:04:44.545]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.545]                       if (muffled) 
[16:04:44.545]                         invokeRestart("muffleMessage")
[16:04:44.545]                     }
[16:04:44.545]                     else if (inherits(cond, "warning")) {
[16:04:44.545]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.545]                       if (muffled) 
[16:04:44.545]                         invokeRestart("muffleWarning")
[16:04:44.545]                     }
[16:04:44.545]                     else if (inherits(cond, "condition")) {
[16:04:44.545]                       if (!is.null(pattern)) {
[16:04:44.545]                         computeRestarts <- base::computeRestarts
[16:04:44.545]                         grepl <- base::grepl
[16:04:44.545]                         restarts <- computeRestarts(cond)
[16:04:44.545]                         for (restart in restarts) {
[16:04:44.545]                           name <- restart$name
[16:04:44.545]                           if (is.null(name)) 
[16:04:44.545]                             next
[16:04:44.545]                           if (!grepl(pattern, name)) 
[16:04:44.545]                             next
[16:04:44.545]                           invokeRestart(restart)
[16:04:44.545]                           muffled <- TRUE
[16:04:44.545]                           break
[16:04:44.545]                         }
[16:04:44.545]                       }
[16:04:44.545]                     }
[16:04:44.545]                     invisible(muffled)
[16:04:44.545]                   }
[16:04:44.545]                   muffleCondition(cond)
[16:04:44.545]                 })
[16:04:44.545]             }))
[16:04:44.545]             future::FutureResult(value = ...future.value$value, 
[16:04:44.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.545]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.545]                     ...future.globalenv.names))
[16:04:44.545]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.545]         }, condition = base::local({
[16:04:44.545]             c <- base::c
[16:04:44.545]             inherits <- base::inherits
[16:04:44.545]             invokeRestart <- base::invokeRestart
[16:04:44.545]             length <- base::length
[16:04:44.545]             list <- base::list
[16:04:44.545]             seq.int <- base::seq.int
[16:04:44.545]             signalCondition <- base::signalCondition
[16:04:44.545]             sys.calls <- base::sys.calls
[16:04:44.545]             `[[` <- base::`[[`
[16:04:44.545]             `+` <- base::`+`
[16:04:44.545]             `<<-` <- base::`<<-`
[16:04:44.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.545]                   3L)]
[16:04:44.545]             }
[16:04:44.545]             function(cond) {
[16:04:44.545]                 is_error <- inherits(cond, "error")
[16:04:44.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.545]                   NULL)
[16:04:44.545]                 if (is_error) {
[16:04:44.545]                   sessionInformation <- function() {
[16:04:44.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.545]                       search = base::search(), system = base::Sys.info())
[16:04:44.545]                   }
[16:04:44.545]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.545]                     cond$call), session = sessionInformation(), 
[16:04:44.545]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.545]                   signalCondition(cond)
[16:04:44.545]                 }
[16:04:44.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.545]                 "immediateCondition"))) {
[16:04:44.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.545]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.545]                   if (TRUE && !signal) {
[16:04:44.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.545]                     {
[16:04:44.545]                       inherits <- base::inherits
[16:04:44.545]                       invokeRestart <- base::invokeRestart
[16:04:44.545]                       is.null <- base::is.null
[16:04:44.545]                       muffled <- FALSE
[16:04:44.545]                       if (inherits(cond, "message")) {
[16:04:44.545]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.545]                         if (muffled) 
[16:04:44.545]                           invokeRestart("muffleMessage")
[16:04:44.545]                       }
[16:04:44.545]                       else if (inherits(cond, "warning")) {
[16:04:44.545]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.545]                         if (muffled) 
[16:04:44.545]                           invokeRestart("muffleWarning")
[16:04:44.545]                       }
[16:04:44.545]                       else if (inherits(cond, "condition")) {
[16:04:44.545]                         if (!is.null(pattern)) {
[16:04:44.545]                           computeRestarts <- base::computeRestarts
[16:04:44.545]                           grepl <- base::grepl
[16:04:44.545]                           restarts <- computeRestarts(cond)
[16:04:44.545]                           for (restart in restarts) {
[16:04:44.545]                             name <- restart$name
[16:04:44.545]                             if (is.null(name)) 
[16:04:44.545]                               next
[16:04:44.545]                             if (!grepl(pattern, name)) 
[16:04:44.545]                               next
[16:04:44.545]                             invokeRestart(restart)
[16:04:44.545]                             muffled <- TRUE
[16:04:44.545]                             break
[16:04:44.545]                           }
[16:04:44.545]                         }
[16:04:44.545]                       }
[16:04:44.545]                       invisible(muffled)
[16:04:44.545]                     }
[16:04:44.545]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.545]                   }
[16:04:44.545]                 }
[16:04:44.545]                 else {
[16:04:44.545]                   if (TRUE) {
[16:04:44.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.545]                     {
[16:04:44.545]                       inherits <- base::inherits
[16:04:44.545]                       invokeRestart <- base::invokeRestart
[16:04:44.545]                       is.null <- base::is.null
[16:04:44.545]                       muffled <- FALSE
[16:04:44.545]                       if (inherits(cond, "message")) {
[16:04:44.545]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.545]                         if (muffled) 
[16:04:44.545]                           invokeRestart("muffleMessage")
[16:04:44.545]                       }
[16:04:44.545]                       else if (inherits(cond, "warning")) {
[16:04:44.545]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.545]                         if (muffled) 
[16:04:44.545]                           invokeRestart("muffleWarning")
[16:04:44.545]                       }
[16:04:44.545]                       else if (inherits(cond, "condition")) {
[16:04:44.545]                         if (!is.null(pattern)) {
[16:04:44.545]                           computeRestarts <- base::computeRestarts
[16:04:44.545]                           grepl <- base::grepl
[16:04:44.545]                           restarts <- computeRestarts(cond)
[16:04:44.545]                           for (restart in restarts) {
[16:04:44.545]                             name <- restart$name
[16:04:44.545]                             if (is.null(name)) 
[16:04:44.545]                               next
[16:04:44.545]                             if (!grepl(pattern, name)) 
[16:04:44.545]                               next
[16:04:44.545]                             invokeRestart(restart)
[16:04:44.545]                             muffled <- TRUE
[16:04:44.545]                             break
[16:04:44.545]                           }
[16:04:44.545]                         }
[16:04:44.545]                       }
[16:04:44.545]                       invisible(muffled)
[16:04:44.545]                     }
[16:04:44.545]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.545]                   }
[16:04:44.545]                 }
[16:04:44.545]             }
[16:04:44.545]         }))
[16:04:44.545]     }, error = function(ex) {
[16:04:44.545]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.545]                 ...future.rng), started = ...future.startTime, 
[16:04:44.545]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.545]             version = "1.8"), class = "FutureResult")
[16:04:44.545]     }, finally = {
[16:04:44.545]         if (!identical(...future.workdir, getwd())) 
[16:04:44.545]             setwd(...future.workdir)
[16:04:44.545]         {
[16:04:44.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.545]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.545]             }
[16:04:44.545]             base::options(...future.oldOptions)
[16:04:44.545]             if (.Platform$OS.type == "windows") {
[16:04:44.545]                 old_names <- names(...future.oldEnvVars)
[16:04:44.545]                 envs <- base::Sys.getenv()
[16:04:44.545]                 names <- names(envs)
[16:04:44.545]                 common <- intersect(names, old_names)
[16:04:44.545]                 added <- setdiff(names, old_names)
[16:04:44.545]                 removed <- setdiff(old_names, names)
[16:04:44.545]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.545]                   envs[common]]
[16:04:44.545]                 NAMES <- toupper(changed)
[16:04:44.545]                 args <- list()
[16:04:44.545]                 for (kk in seq_along(NAMES)) {
[16:04:44.545]                   name <- changed[[kk]]
[16:04:44.545]                   NAME <- NAMES[[kk]]
[16:04:44.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.545]                     next
[16:04:44.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.545]                 }
[16:04:44.545]                 NAMES <- toupper(added)
[16:04:44.545]                 for (kk in seq_along(NAMES)) {
[16:04:44.545]                   name <- added[[kk]]
[16:04:44.545]                   NAME <- NAMES[[kk]]
[16:04:44.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.545]                     next
[16:04:44.545]                   args[[name]] <- ""
[16:04:44.545]                 }
[16:04:44.545]                 NAMES <- toupper(removed)
[16:04:44.545]                 for (kk in seq_along(NAMES)) {
[16:04:44.545]                   name <- removed[[kk]]
[16:04:44.545]                   NAME <- NAMES[[kk]]
[16:04:44.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.545]                     next
[16:04:44.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.545]                 }
[16:04:44.545]                 if (length(args) > 0) 
[16:04:44.545]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.545]             }
[16:04:44.545]             else {
[16:04:44.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.545]             }
[16:04:44.545]             {
[16:04:44.545]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.545]                   0L) {
[16:04:44.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.545]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.545]                   base::options(opts)
[16:04:44.545]                 }
[16:04:44.545]                 {
[16:04:44.545]                   {
[16:04:44.545]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.545]                     NULL
[16:04:44.545]                   }
[16:04:44.545]                   options(future.plan = NULL)
[16:04:44.545]                   if (is.na(NA_character_)) 
[16:04:44.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.545]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.545]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.545]                     envir = parent.frame()) 
[16:04:44.545]                   {
[16:04:44.545]                     if (is.function(workers)) 
[16:04:44.545]                       workers <- workers()
[16:04:44.545]                     workers <- structure(as.integer(workers), 
[16:04:44.545]                       class = class(workers))
[16:04:44.545]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.545]                       workers >= 1)
[16:04:44.545]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.545]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.545]                     }
[16:04:44.545]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.545]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.545]                       envir = envir)
[16:04:44.545]                     if (!future$lazy) 
[16:04:44.545]                       future <- run(future)
[16:04:44.545]                     invisible(future)
[16:04:44.545]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.545]                 }
[16:04:44.545]             }
[16:04:44.545]         }
[16:04:44.545]     })
[16:04:44.545]     if (TRUE) {
[16:04:44.545]         base::sink(type = "output", split = FALSE)
[16:04:44.545]         if (TRUE) {
[16:04:44.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.545]         }
[16:04:44.545]         else {
[16:04:44.545]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.545]         }
[16:04:44.545]         base::close(...future.stdout)
[16:04:44.545]         ...future.stdout <- NULL
[16:04:44.545]     }
[16:04:44.545]     ...future.result$conditions <- ...future.conditions
[16:04:44.545]     ...future.result$finished <- base::Sys.time()
[16:04:44.545]     ...future.result
[16:04:44.545] }
[16:04:44.548] MultisessionFuture started
[16:04:44.548] - Launch lazy future ... done
[16:04:44.548] run() for ‘MultisessionFuture’ ... done
[16:04:44.548] getGlobalsAndPackages() ...
[16:04:44.549] Searching for globals...
[16:04:44.549] 
[16:04:44.549] Searching for globals ... DONE
[16:04:44.549] - globals: [0] <none>
[16:04:44.549] getGlobalsAndPackages() ... DONE
[16:04:44.549] run() for ‘Future’ ...
[16:04:44.550] - state: ‘created’
[16:04:44.550] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.563] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.563] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.563]   - Field: ‘node’
[16:04:44.564]   - Field: ‘label’
[16:04:44.564]   - Field: ‘local’
[16:04:44.564]   - Field: ‘owner’
[16:04:44.564]   - Field: ‘envir’
[16:04:44.564]   - Field: ‘workers’
[16:04:44.564]   - Field: ‘packages’
[16:04:44.564]   - Field: ‘gc’
[16:04:44.564]   - Field: ‘conditions’
[16:04:44.564]   - Field: ‘persistent’
[16:04:44.564]   - Field: ‘expr’
[16:04:44.564]   - Field: ‘uuid’
[16:04:44.565]   - Field: ‘seed’
[16:04:44.565]   - Field: ‘version’
[16:04:44.565]   - Field: ‘result’
[16:04:44.565]   - Field: ‘asynchronous’
[16:04:44.565]   - Field: ‘calls’
[16:04:44.565]   - Field: ‘globals’
[16:04:44.565]   - Field: ‘stdout’
[16:04:44.565]   - Field: ‘earlySignal’
[16:04:44.565]   - Field: ‘lazy’
[16:04:44.565]   - Field: ‘state’
[16:04:44.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.566] - Launch lazy future ...
[16:04:44.566] Packages needed by the future expression (n = 0): <none>
[16:04:44.566] Packages needed by future strategies (n = 0): <none>
[16:04:44.566] {
[16:04:44.566]     {
[16:04:44.566]         {
[16:04:44.566]             ...future.startTime <- base::Sys.time()
[16:04:44.566]             {
[16:04:44.566]                 {
[16:04:44.566]                   {
[16:04:44.566]                     {
[16:04:44.566]                       base::local({
[16:04:44.566]                         has_future <- base::requireNamespace("future", 
[16:04:44.566]                           quietly = TRUE)
[16:04:44.566]                         if (has_future) {
[16:04:44.566]                           ns <- base::getNamespace("future")
[16:04:44.566]                           version <- ns[[".package"]][["version"]]
[16:04:44.566]                           if (is.null(version)) 
[16:04:44.566]                             version <- utils::packageVersion("future")
[16:04:44.566]                         }
[16:04:44.566]                         else {
[16:04:44.566]                           version <- NULL
[16:04:44.566]                         }
[16:04:44.566]                         if (!has_future || version < "1.8.0") {
[16:04:44.566]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.566]                             "", base::R.version$version.string), 
[16:04:44.566]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.566]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.566]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.566]                               "release", "version")], collapse = " "), 
[16:04:44.566]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.566]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.566]                             info)
[16:04:44.566]                           info <- base::paste(info, collapse = "; ")
[16:04:44.566]                           if (!has_future) {
[16:04:44.566]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.566]                               info)
[16:04:44.566]                           }
[16:04:44.566]                           else {
[16:04:44.566]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.566]                               info, version)
[16:04:44.566]                           }
[16:04:44.566]                           base::stop(msg)
[16:04:44.566]                         }
[16:04:44.566]                       })
[16:04:44.566]                     }
[16:04:44.566]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.566]                     base::options(mc.cores = 1L)
[16:04:44.566]                   }
[16:04:44.566]                   options(future.plan = NULL)
[16:04:44.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.566]                 }
[16:04:44.566]                 ...future.workdir <- getwd()
[16:04:44.566]             }
[16:04:44.566]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.566]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.566]         }
[16:04:44.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.566]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.566]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.566]             base::names(...future.oldOptions))
[16:04:44.566]     }
[16:04:44.566]     if (FALSE) {
[16:04:44.566]     }
[16:04:44.566]     else {
[16:04:44.566]         if (TRUE) {
[16:04:44.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.566]                 open = "w")
[16:04:44.566]         }
[16:04:44.566]         else {
[16:04:44.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.566]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.566]         }
[16:04:44.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.566]             base::sink(type = "output", split = FALSE)
[16:04:44.566]             base::close(...future.stdout)
[16:04:44.566]         }, add = TRUE)
[16:04:44.566]     }
[16:04:44.566]     ...future.frame <- base::sys.nframe()
[16:04:44.566]     ...future.conditions <- base::list()
[16:04:44.566]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.566]     if (FALSE) {
[16:04:44.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.566]     }
[16:04:44.566]     ...future.result <- base::tryCatch({
[16:04:44.566]         base::withCallingHandlers({
[16:04:44.566]             ...future.value <- base::withVisible(base::local({
[16:04:44.566]                 ...future.makeSendCondition <- base::local({
[16:04:44.566]                   sendCondition <- NULL
[16:04:44.566]                   function(frame = 1L) {
[16:04:44.566]                     if (is.function(sendCondition)) 
[16:04:44.566]                       return(sendCondition)
[16:04:44.566]                     ns <- getNamespace("parallel")
[16:04:44.566]                     if (exists("sendData", mode = "function", 
[16:04:44.566]                       envir = ns)) {
[16:04:44.566]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.566]                         envir = ns)
[16:04:44.566]                       envir <- sys.frame(frame)
[16:04:44.566]                       master <- NULL
[16:04:44.566]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.566]                         !identical(envir, emptyenv())) {
[16:04:44.566]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.566]                           inherits = FALSE)) {
[16:04:44.566]                           master <- get("master", mode = "list", 
[16:04:44.566]                             envir = envir, inherits = FALSE)
[16:04:44.566]                           if (inherits(master, c("SOCKnode", 
[16:04:44.566]                             "SOCK0node"))) {
[16:04:44.566]                             sendCondition <<- function(cond) {
[16:04:44.566]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.566]                                 success = TRUE)
[16:04:44.566]                               parallel_sendData(master, data)
[16:04:44.566]                             }
[16:04:44.566]                             return(sendCondition)
[16:04:44.566]                           }
[16:04:44.566]                         }
[16:04:44.566]                         frame <- frame + 1L
[16:04:44.566]                         envir <- sys.frame(frame)
[16:04:44.566]                       }
[16:04:44.566]                     }
[16:04:44.566]                     sendCondition <<- function(cond) NULL
[16:04:44.566]                   }
[16:04:44.566]                 })
[16:04:44.566]                 withCallingHandlers({
[16:04:44.566]                   NULL
[16:04:44.566]                 }, immediateCondition = function(cond) {
[16:04:44.566]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.566]                   sendCondition(cond)
[16:04:44.566]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.566]                   {
[16:04:44.566]                     inherits <- base::inherits
[16:04:44.566]                     invokeRestart <- base::invokeRestart
[16:04:44.566]                     is.null <- base::is.null
[16:04:44.566]                     muffled <- FALSE
[16:04:44.566]                     if (inherits(cond, "message")) {
[16:04:44.566]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.566]                       if (muffled) 
[16:04:44.566]                         invokeRestart("muffleMessage")
[16:04:44.566]                     }
[16:04:44.566]                     else if (inherits(cond, "warning")) {
[16:04:44.566]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.566]                       if (muffled) 
[16:04:44.566]                         invokeRestart("muffleWarning")
[16:04:44.566]                     }
[16:04:44.566]                     else if (inherits(cond, "condition")) {
[16:04:44.566]                       if (!is.null(pattern)) {
[16:04:44.566]                         computeRestarts <- base::computeRestarts
[16:04:44.566]                         grepl <- base::grepl
[16:04:44.566]                         restarts <- computeRestarts(cond)
[16:04:44.566]                         for (restart in restarts) {
[16:04:44.566]                           name <- restart$name
[16:04:44.566]                           if (is.null(name)) 
[16:04:44.566]                             next
[16:04:44.566]                           if (!grepl(pattern, name)) 
[16:04:44.566]                             next
[16:04:44.566]                           invokeRestart(restart)
[16:04:44.566]                           muffled <- TRUE
[16:04:44.566]                           break
[16:04:44.566]                         }
[16:04:44.566]                       }
[16:04:44.566]                     }
[16:04:44.566]                     invisible(muffled)
[16:04:44.566]                   }
[16:04:44.566]                   muffleCondition(cond)
[16:04:44.566]                 })
[16:04:44.566]             }))
[16:04:44.566]             future::FutureResult(value = ...future.value$value, 
[16:04:44.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.566]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.566]                     ...future.globalenv.names))
[16:04:44.566]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.566]         }, condition = base::local({
[16:04:44.566]             c <- base::c
[16:04:44.566]             inherits <- base::inherits
[16:04:44.566]             invokeRestart <- base::invokeRestart
[16:04:44.566]             length <- base::length
[16:04:44.566]             list <- base::list
[16:04:44.566]             seq.int <- base::seq.int
[16:04:44.566]             signalCondition <- base::signalCondition
[16:04:44.566]             sys.calls <- base::sys.calls
[16:04:44.566]             `[[` <- base::`[[`
[16:04:44.566]             `+` <- base::`+`
[16:04:44.566]             `<<-` <- base::`<<-`
[16:04:44.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.566]                   3L)]
[16:04:44.566]             }
[16:04:44.566]             function(cond) {
[16:04:44.566]                 is_error <- inherits(cond, "error")
[16:04:44.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.566]                   NULL)
[16:04:44.566]                 if (is_error) {
[16:04:44.566]                   sessionInformation <- function() {
[16:04:44.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.566]                       search = base::search(), system = base::Sys.info())
[16:04:44.566]                   }
[16:04:44.566]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.566]                     cond$call), session = sessionInformation(), 
[16:04:44.566]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.566]                   signalCondition(cond)
[16:04:44.566]                 }
[16:04:44.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.566]                 "immediateCondition"))) {
[16:04:44.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.566]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.566]                   if (TRUE && !signal) {
[16:04:44.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.566]                     {
[16:04:44.566]                       inherits <- base::inherits
[16:04:44.566]                       invokeRestart <- base::invokeRestart
[16:04:44.566]                       is.null <- base::is.null
[16:04:44.566]                       muffled <- FALSE
[16:04:44.566]                       if (inherits(cond, "message")) {
[16:04:44.566]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.566]                         if (muffled) 
[16:04:44.566]                           invokeRestart("muffleMessage")
[16:04:44.566]                       }
[16:04:44.566]                       else if (inherits(cond, "warning")) {
[16:04:44.566]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.566]                         if (muffled) 
[16:04:44.566]                           invokeRestart("muffleWarning")
[16:04:44.566]                       }
[16:04:44.566]                       else if (inherits(cond, "condition")) {
[16:04:44.566]                         if (!is.null(pattern)) {
[16:04:44.566]                           computeRestarts <- base::computeRestarts
[16:04:44.566]                           grepl <- base::grepl
[16:04:44.566]                           restarts <- computeRestarts(cond)
[16:04:44.566]                           for (restart in restarts) {
[16:04:44.566]                             name <- restart$name
[16:04:44.566]                             if (is.null(name)) 
[16:04:44.566]                               next
[16:04:44.566]                             if (!grepl(pattern, name)) 
[16:04:44.566]                               next
[16:04:44.566]                             invokeRestart(restart)
[16:04:44.566]                             muffled <- TRUE
[16:04:44.566]                             break
[16:04:44.566]                           }
[16:04:44.566]                         }
[16:04:44.566]                       }
[16:04:44.566]                       invisible(muffled)
[16:04:44.566]                     }
[16:04:44.566]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.566]                   }
[16:04:44.566]                 }
[16:04:44.566]                 else {
[16:04:44.566]                   if (TRUE) {
[16:04:44.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.566]                     {
[16:04:44.566]                       inherits <- base::inherits
[16:04:44.566]                       invokeRestart <- base::invokeRestart
[16:04:44.566]                       is.null <- base::is.null
[16:04:44.566]                       muffled <- FALSE
[16:04:44.566]                       if (inherits(cond, "message")) {
[16:04:44.566]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.566]                         if (muffled) 
[16:04:44.566]                           invokeRestart("muffleMessage")
[16:04:44.566]                       }
[16:04:44.566]                       else if (inherits(cond, "warning")) {
[16:04:44.566]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.566]                         if (muffled) 
[16:04:44.566]                           invokeRestart("muffleWarning")
[16:04:44.566]                       }
[16:04:44.566]                       else if (inherits(cond, "condition")) {
[16:04:44.566]                         if (!is.null(pattern)) {
[16:04:44.566]                           computeRestarts <- base::computeRestarts
[16:04:44.566]                           grepl <- base::grepl
[16:04:44.566]                           restarts <- computeRestarts(cond)
[16:04:44.566]                           for (restart in restarts) {
[16:04:44.566]                             name <- restart$name
[16:04:44.566]                             if (is.null(name)) 
[16:04:44.566]                               next
[16:04:44.566]                             if (!grepl(pattern, name)) 
[16:04:44.566]                               next
[16:04:44.566]                             invokeRestart(restart)
[16:04:44.566]                             muffled <- TRUE
[16:04:44.566]                             break
[16:04:44.566]                           }
[16:04:44.566]                         }
[16:04:44.566]                       }
[16:04:44.566]                       invisible(muffled)
[16:04:44.566]                     }
[16:04:44.566]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.566]                   }
[16:04:44.566]                 }
[16:04:44.566]             }
[16:04:44.566]         }))
[16:04:44.566]     }, error = function(ex) {
[16:04:44.566]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.566]                 ...future.rng), started = ...future.startTime, 
[16:04:44.566]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.566]             version = "1.8"), class = "FutureResult")
[16:04:44.566]     }, finally = {
[16:04:44.566]         if (!identical(...future.workdir, getwd())) 
[16:04:44.566]             setwd(...future.workdir)
[16:04:44.566]         {
[16:04:44.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.566]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.566]             }
[16:04:44.566]             base::options(...future.oldOptions)
[16:04:44.566]             if (.Platform$OS.type == "windows") {
[16:04:44.566]                 old_names <- names(...future.oldEnvVars)
[16:04:44.566]                 envs <- base::Sys.getenv()
[16:04:44.566]                 names <- names(envs)
[16:04:44.566]                 common <- intersect(names, old_names)
[16:04:44.566]                 added <- setdiff(names, old_names)
[16:04:44.566]                 removed <- setdiff(old_names, names)
[16:04:44.566]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.566]                   envs[common]]
[16:04:44.566]                 NAMES <- toupper(changed)
[16:04:44.566]                 args <- list()
[16:04:44.566]                 for (kk in seq_along(NAMES)) {
[16:04:44.566]                   name <- changed[[kk]]
[16:04:44.566]                   NAME <- NAMES[[kk]]
[16:04:44.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.566]                     next
[16:04:44.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.566]                 }
[16:04:44.566]                 NAMES <- toupper(added)
[16:04:44.566]                 for (kk in seq_along(NAMES)) {
[16:04:44.566]                   name <- added[[kk]]
[16:04:44.566]                   NAME <- NAMES[[kk]]
[16:04:44.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.566]                     next
[16:04:44.566]                   args[[name]] <- ""
[16:04:44.566]                 }
[16:04:44.566]                 NAMES <- toupper(removed)
[16:04:44.566]                 for (kk in seq_along(NAMES)) {
[16:04:44.566]                   name <- removed[[kk]]
[16:04:44.566]                   NAME <- NAMES[[kk]]
[16:04:44.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.566]                     next
[16:04:44.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.566]                 }
[16:04:44.566]                 if (length(args) > 0) 
[16:04:44.566]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.566]             }
[16:04:44.566]             else {
[16:04:44.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.566]             }
[16:04:44.566]             {
[16:04:44.566]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.566]                   0L) {
[16:04:44.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.566]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.566]                   base::options(opts)
[16:04:44.566]                 }
[16:04:44.566]                 {
[16:04:44.566]                   {
[16:04:44.566]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.566]                     NULL
[16:04:44.566]                   }
[16:04:44.566]                   options(future.plan = NULL)
[16:04:44.566]                   if (is.na(NA_character_)) 
[16:04:44.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.566]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.566]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.566]                     envir = parent.frame()) 
[16:04:44.566]                   {
[16:04:44.566]                     if (is.function(workers)) 
[16:04:44.566]                       workers <- workers()
[16:04:44.566]                     workers <- structure(as.integer(workers), 
[16:04:44.566]                       class = class(workers))
[16:04:44.566]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.566]                       workers >= 1)
[16:04:44.566]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.566]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.566]                     }
[16:04:44.566]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.566]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.566]                       envir = envir)
[16:04:44.566]                     if (!future$lazy) 
[16:04:44.566]                       future <- run(future)
[16:04:44.566]                     invisible(future)
[16:04:44.566]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.566]                 }
[16:04:44.566]             }
[16:04:44.566]         }
[16:04:44.566]     })
[16:04:44.566]     if (TRUE) {
[16:04:44.566]         base::sink(type = "output", split = FALSE)
[16:04:44.566]         if (TRUE) {
[16:04:44.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.566]         }
[16:04:44.566]         else {
[16:04:44.566]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.566]         }
[16:04:44.566]         base::close(...future.stdout)
[16:04:44.566]         ...future.stdout <- NULL
[16:04:44.566]     }
[16:04:44.566]     ...future.result$conditions <- ...future.conditions
[16:04:44.566]     ...future.result$finished <- base::Sys.time()
[16:04:44.566]     ...future.result
[16:04:44.566] }
[16:04:44.570] MultisessionFuture started
[16:04:44.570] - Launch lazy future ... done
[16:04:44.570] run() for ‘MultisessionFuture’ ... done
[16:04:44.570] getGlobalsAndPackages() ...
[16:04:44.570] Searching for globals...
[16:04:44.571] - globals found: [1] ‘{’
[16:04:44.571] Searching for globals ... DONE
[16:04:44.571] Resolving globals: FALSE
[16:04:44.571] 
[16:04:44.571] 
[16:04:44.571] getGlobalsAndPackages() ... DONE
[16:04:44.572] run() for ‘Future’ ...
[16:04:44.572] - state: ‘created’
[16:04:44.572] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.586] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.586]   - Field: ‘node’
[16:04:44.586]   - Field: ‘label’
[16:04:44.586]   - Field: ‘local’
[16:04:44.586]   - Field: ‘owner’
[16:04:44.586]   - Field: ‘envir’
[16:04:44.586]   - Field: ‘workers’
[16:04:44.587]   - Field: ‘packages’
[16:04:44.587]   - Field: ‘gc’
[16:04:44.587]   - Field: ‘conditions’
[16:04:44.587]   - Field: ‘persistent’
[16:04:44.587]   - Field: ‘expr’
[16:04:44.587]   - Field: ‘uuid’
[16:04:44.587]   - Field: ‘seed’
[16:04:44.587]   - Field: ‘version’
[16:04:44.587]   - Field: ‘result’
[16:04:44.587]   - Field: ‘asynchronous’
[16:04:44.588]   - Field: ‘calls’
[16:04:44.588]   - Field: ‘globals’
[16:04:44.588]   - Field: ‘stdout’
[16:04:44.588]   - Field: ‘earlySignal’
[16:04:44.588]   - Field: ‘lazy’
[16:04:44.588]   - Field: ‘state’
[16:04:44.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.588] - Launch lazy future ...
[16:04:44.588] Packages needed by the future expression (n = 0): <none>
[16:04:44.589] Packages needed by future strategies (n = 0): <none>
[16:04:44.589] {
[16:04:44.589]     {
[16:04:44.589]         {
[16:04:44.589]             ...future.startTime <- base::Sys.time()
[16:04:44.589]             {
[16:04:44.589]                 {
[16:04:44.589]                   {
[16:04:44.589]                     {
[16:04:44.589]                       base::local({
[16:04:44.589]                         has_future <- base::requireNamespace("future", 
[16:04:44.589]                           quietly = TRUE)
[16:04:44.589]                         if (has_future) {
[16:04:44.589]                           ns <- base::getNamespace("future")
[16:04:44.589]                           version <- ns[[".package"]][["version"]]
[16:04:44.589]                           if (is.null(version)) 
[16:04:44.589]                             version <- utils::packageVersion("future")
[16:04:44.589]                         }
[16:04:44.589]                         else {
[16:04:44.589]                           version <- NULL
[16:04:44.589]                         }
[16:04:44.589]                         if (!has_future || version < "1.8.0") {
[16:04:44.589]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.589]                             "", base::R.version$version.string), 
[16:04:44.589]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.589]                               "release", "version")], collapse = " "), 
[16:04:44.589]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.589]                             info)
[16:04:44.589]                           info <- base::paste(info, collapse = "; ")
[16:04:44.589]                           if (!has_future) {
[16:04:44.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.589]                               info)
[16:04:44.589]                           }
[16:04:44.589]                           else {
[16:04:44.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.589]                               info, version)
[16:04:44.589]                           }
[16:04:44.589]                           base::stop(msg)
[16:04:44.589]                         }
[16:04:44.589]                       })
[16:04:44.589]                     }
[16:04:44.589]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.589]                     base::options(mc.cores = 1L)
[16:04:44.589]                   }
[16:04:44.589]                   options(future.plan = NULL)
[16:04:44.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.589]                 }
[16:04:44.589]                 ...future.workdir <- getwd()
[16:04:44.589]             }
[16:04:44.589]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.589]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.589]         }
[16:04:44.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.589]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.589]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.589]             base::names(...future.oldOptions))
[16:04:44.589]     }
[16:04:44.589]     if (FALSE) {
[16:04:44.589]     }
[16:04:44.589]     else {
[16:04:44.589]         if (TRUE) {
[16:04:44.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.589]                 open = "w")
[16:04:44.589]         }
[16:04:44.589]         else {
[16:04:44.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.589]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.589]         }
[16:04:44.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.589]             base::sink(type = "output", split = FALSE)
[16:04:44.589]             base::close(...future.stdout)
[16:04:44.589]         }, add = TRUE)
[16:04:44.589]     }
[16:04:44.589]     ...future.frame <- base::sys.nframe()
[16:04:44.589]     ...future.conditions <- base::list()
[16:04:44.589]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.589]     if (FALSE) {
[16:04:44.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.589]     }
[16:04:44.589]     ...future.result <- base::tryCatch({
[16:04:44.589]         base::withCallingHandlers({
[16:04:44.589]             ...future.value <- base::withVisible(base::local({
[16:04:44.589]                 ...future.makeSendCondition <- base::local({
[16:04:44.589]                   sendCondition <- NULL
[16:04:44.589]                   function(frame = 1L) {
[16:04:44.589]                     if (is.function(sendCondition)) 
[16:04:44.589]                       return(sendCondition)
[16:04:44.589]                     ns <- getNamespace("parallel")
[16:04:44.589]                     if (exists("sendData", mode = "function", 
[16:04:44.589]                       envir = ns)) {
[16:04:44.589]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.589]                         envir = ns)
[16:04:44.589]                       envir <- sys.frame(frame)
[16:04:44.589]                       master <- NULL
[16:04:44.589]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.589]                         !identical(envir, emptyenv())) {
[16:04:44.589]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.589]                           inherits = FALSE)) {
[16:04:44.589]                           master <- get("master", mode = "list", 
[16:04:44.589]                             envir = envir, inherits = FALSE)
[16:04:44.589]                           if (inherits(master, c("SOCKnode", 
[16:04:44.589]                             "SOCK0node"))) {
[16:04:44.589]                             sendCondition <<- function(cond) {
[16:04:44.589]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.589]                                 success = TRUE)
[16:04:44.589]                               parallel_sendData(master, data)
[16:04:44.589]                             }
[16:04:44.589]                             return(sendCondition)
[16:04:44.589]                           }
[16:04:44.589]                         }
[16:04:44.589]                         frame <- frame + 1L
[16:04:44.589]                         envir <- sys.frame(frame)
[16:04:44.589]                       }
[16:04:44.589]                     }
[16:04:44.589]                     sendCondition <<- function(cond) NULL
[16:04:44.589]                   }
[16:04:44.589]                 })
[16:04:44.589]                 withCallingHandlers({
[16:04:44.589]                   {
[16:04:44.589]                     4
[16:04:44.589]                   }
[16:04:44.589]                 }, immediateCondition = function(cond) {
[16:04:44.589]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.589]                   sendCondition(cond)
[16:04:44.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.589]                   {
[16:04:44.589]                     inherits <- base::inherits
[16:04:44.589]                     invokeRestart <- base::invokeRestart
[16:04:44.589]                     is.null <- base::is.null
[16:04:44.589]                     muffled <- FALSE
[16:04:44.589]                     if (inherits(cond, "message")) {
[16:04:44.589]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.589]                       if (muffled) 
[16:04:44.589]                         invokeRestart("muffleMessage")
[16:04:44.589]                     }
[16:04:44.589]                     else if (inherits(cond, "warning")) {
[16:04:44.589]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.589]                       if (muffled) 
[16:04:44.589]                         invokeRestart("muffleWarning")
[16:04:44.589]                     }
[16:04:44.589]                     else if (inherits(cond, "condition")) {
[16:04:44.589]                       if (!is.null(pattern)) {
[16:04:44.589]                         computeRestarts <- base::computeRestarts
[16:04:44.589]                         grepl <- base::grepl
[16:04:44.589]                         restarts <- computeRestarts(cond)
[16:04:44.589]                         for (restart in restarts) {
[16:04:44.589]                           name <- restart$name
[16:04:44.589]                           if (is.null(name)) 
[16:04:44.589]                             next
[16:04:44.589]                           if (!grepl(pattern, name)) 
[16:04:44.589]                             next
[16:04:44.589]                           invokeRestart(restart)
[16:04:44.589]                           muffled <- TRUE
[16:04:44.589]                           break
[16:04:44.589]                         }
[16:04:44.589]                       }
[16:04:44.589]                     }
[16:04:44.589]                     invisible(muffled)
[16:04:44.589]                   }
[16:04:44.589]                   muffleCondition(cond)
[16:04:44.589]                 })
[16:04:44.589]             }))
[16:04:44.589]             future::FutureResult(value = ...future.value$value, 
[16:04:44.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.589]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.589]                     ...future.globalenv.names))
[16:04:44.589]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.589]         }, condition = base::local({
[16:04:44.589]             c <- base::c
[16:04:44.589]             inherits <- base::inherits
[16:04:44.589]             invokeRestart <- base::invokeRestart
[16:04:44.589]             length <- base::length
[16:04:44.589]             list <- base::list
[16:04:44.589]             seq.int <- base::seq.int
[16:04:44.589]             signalCondition <- base::signalCondition
[16:04:44.589]             sys.calls <- base::sys.calls
[16:04:44.589]             `[[` <- base::`[[`
[16:04:44.589]             `+` <- base::`+`
[16:04:44.589]             `<<-` <- base::`<<-`
[16:04:44.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.589]                   3L)]
[16:04:44.589]             }
[16:04:44.589]             function(cond) {
[16:04:44.589]                 is_error <- inherits(cond, "error")
[16:04:44.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.589]                   NULL)
[16:04:44.589]                 if (is_error) {
[16:04:44.589]                   sessionInformation <- function() {
[16:04:44.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.589]                       search = base::search(), system = base::Sys.info())
[16:04:44.589]                   }
[16:04:44.589]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.589]                     cond$call), session = sessionInformation(), 
[16:04:44.589]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.589]                   signalCondition(cond)
[16:04:44.589]                 }
[16:04:44.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.589]                 "immediateCondition"))) {
[16:04:44.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.589]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.589]                   if (TRUE && !signal) {
[16:04:44.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.589]                     {
[16:04:44.589]                       inherits <- base::inherits
[16:04:44.589]                       invokeRestart <- base::invokeRestart
[16:04:44.589]                       is.null <- base::is.null
[16:04:44.589]                       muffled <- FALSE
[16:04:44.589]                       if (inherits(cond, "message")) {
[16:04:44.589]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.589]                         if (muffled) 
[16:04:44.589]                           invokeRestart("muffleMessage")
[16:04:44.589]                       }
[16:04:44.589]                       else if (inherits(cond, "warning")) {
[16:04:44.589]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.589]                         if (muffled) 
[16:04:44.589]                           invokeRestart("muffleWarning")
[16:04:44.589]                       }
[16:04:44.589]                       else if (inherits(cond, "condition")) {
[16:04:44.589]                         if (!is.null(pattern)) {
[16:04:44.589]                           computeRestarts <- base::computeRestarts
[16:04:44.589]                           grepl <- base::grepl
[16:04:44.589]                           restarts <- computeRestarts(cond)
[16:04:44.589]                           for (restart in restarts) {
[16:04:44.589]                             name <- restart$name
[16:04:44.589]                             if (is.null(name)) 
[16:04:44.589]                               next
[16:04:44.589]                             if (!grepl(pattern, name)) 
[16:04:44.589]                               next
[16:04:44.589]                             invokeRestart(restart)
[16:04:44.589]                             muffled <- TRUE
[16:04:44.589]                             break
[16:04:44.589]                           }
[16:04:44.589]                         }
[16:04:44.589]                       }
[16:04:44.589]                       invisible(muffled)
[16:04:44.589]                     }
[16:04:44.589]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.589]                   }
[16:04:44.589]                 }
[16:04:44.589]                 else {
[16:04:44.589]                   if (TRUE) {
[16:04:44.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.589]                     {
[16:04:44.589]                       inherits <- base::inherits
[16:04:44.589]                       invokeRestart <- base::invokeRestart
[16:04:44.589]                       is.null <- base::is.null
[16:04:44.589]                       muffled <- FALSE
[16:04:44.589]                       if (inherits(cond, "message")) {
[16:04:44.589]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.589]                         if (muffled) 
[16:04:44.589]                           invokeRestart("muffleMessage")
[16:04:44.589]                       }
[16:04:44.589]                       else if (inherits(cond, "warning")) {
[16:04:44.589]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.589]                         if (muffled) 
[16:04:44.589]                           invokeRestart("muffleWarning")
[16:04:44.589]                       }
[16:04:44.589]                       else if (inherits(cond, "condition")) {
[16:04:44.589]                         if (!is.null(pattern)) {
[16:04:44.589]                           computeRestarts <- base::computeRestarts
[16:04:44.589]                           grepl <- base::grepl
[16:04:44.589]                           restarts <- computeRestarts(cond)
[16:04:44.589]                           for (restart in restarts) {
[16:04:44.589]                             name <- restart$name
[16:04:44.589]                             if (is.null(name)) 
[16:04:44.589]                               next
[16:04:44.589]                             if (!grepl(pattern, name)) 
[16:04:44.589]                               next
[16:04:44.589]                             invokeRestart(restart)
[16:04:44.589]                             muffled <- TRUE
[16:04:44.589]                             break
[16:04:44.589]                           }
[16:04:44.589]                         }
[16:04:44.589]                       }
[16:04:44.589]                       invisible(muffled)
[16:04:44.589]                     }
[16:04:44.589]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.589]                   }
[16:04:44.589]                 }
[16:04:44.589]             }
[16:04:44.589]         }))
[16:04:44.589]     }, error = function(ex) {
[16:04:44.589]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.589]                 ...future.rng), started = ...future.startTime, 
[16:04:44.589]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.589]             version = "1.8"), class = "FutureResult")
[16:04:44.589]     }, finally = {
[16:04:44.589]         if (!identical(...future.workdir, getwd())) 
[16:04:44.589]             setwd(...future.workdir)
[16:04:44.589]         {
[16:04:44.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.589]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.589]             }
[16:04:44.589]             base::options(...future.oldOptions)
[16:04:44.589]             if (.Platform$OS.type == "windows") {
[16:04:44.589]                 old_names <- names(...future.oldEnvVars)
[16:04:44.589]                 envs <- base::Sys.getenv()
[16:04:44.589]                 names <- names(envs)
[16:04:44.589]                 common <- intersect(names, old_names)
[16:04:44.589]                 added <- setdiff(names, old_names)
[16:04:44.589]                 removed <- setdiff(old_names, names)
[16:04:44.589]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.589]                   envs[common]]
[16:04:44.589]                 NAMES <- toupper(changed)
[16:04:44.589]                 args <- list()
[16:04:44.589]                 for (kk in seq_along(NAMES)) {
[16:04:44.589]                   name <- changed[[kk]]
[16:04:44.589]                   NAME <- NAMES[[kk]]
[16:04:44.589]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.589]                     next
[16:04:44.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.589]                 }
[16:04:44.589]                 NAMES <- toupper(added)
[16:04:44.589]                 for (kk in seq_along(NAMES)) {
[16:04:44.589]                   name <- added[[kk]]
[16:04:44.589]                   NAME <- NAMES[[kk]]
[16:04:44.589]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.589]                     next
[16:04:44.589]                   args[[name]] <- ""
[16:04:44.589]                 }
[16:04:44.589]                 NAMES <- toupper(removed)
[16:04:44.589]                 for (kk in seq_along(NAMES)) {
[16:04:44.589]                   name <- removed[[kk]]
[16:04:44.589]                   NAME <- NAMES[[kk]]
[16:04:44.589]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.589]                     next
[16:04:44.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.589]                 }
[16:04:44.589]                 if (length(args) > 0) 
[16:04:44.589]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.589]             }
[16:04:44.589]             else {
[16:04:44.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.589]             }
[16:04:44.589]             {
[16:04:44.589]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.589]                   0L) {
[16:04:44.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.589]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.589]                   base::options(opts)
[16:04:44.589]                 }
[16:04:44.589]                 {
[16:04:44.589]                   {
[16:04:44.589]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.589]                     NULL
[16:04:44.589]                   }
[16:04:44.589]                   options(future.plan = NULL)
[16:04:44.589]                   if (is.na(NA_character_)) 
[16:04:44.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.589]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.589]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.589]                     envir = parent.frame()) 
[16:04:44.589]                   {
[16:04:44.589]                     if (is.function(workers)) 
[16:04:44.589]                       workers <- workers()
[16:04:44.589]                     workers <- structure(as.integer(workers), 
[16:04:44.589]                       class = class(workers))
[16:04:44.589]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.589]                       workers >= 1)
[16:04:44.589]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.589]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.589]                     }
[16:04:44.589]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.589]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.589]                       envir = envir)
[16:04:44.589]                     if (!future$lazy) 
[16:04:44.589]                       future <- run(future)
[16:04:44.589]                     invisible(future)
[16:04:44.589]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.589]                 }
[16:04:44.589]             }
[16:04:44.589]         }
[16:04:44.589]     })
[16:04:44.589]     if (TRUE) {
[16:04:44.589]         base::sink(type = "output", split = FALSE)
[16:04:44.589]         if (TRUE) {
[16:04:44.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.589]         }
[16:04:44.589]         else {
[16:04:44.589]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.589]         }
[16:04:44.589]         base::close(...future.stdout)
[16:04:44.589]         ...future.stdout <- NULL
[16:04:44.589]     }
[16:04:44.589]     ...future.result$conditions <- ...future.conditions
[16:04:44.589]     ...future.result$finished <- base::Sys.time()
[16:04:44.589]     ...future.result
[16:04:44.589] }
[16:04:44.591] Poll #1 (0): usedNodes() = 2, workers = 2
[16:04:44.602] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.602] - Validating connection of MultisessionFuture
[16:04:44.603] - received message: FutureResult
[16:04:44.603] - Received FutureResult
[16:04:44.603] - Erased future from FutureRegistry
[16:04:44.603] result() for ClusterFuture ...
[16:04:44.603] - result already collected: FutureResult
[16:04:44.603] result() for ClusterFuture ... done
[16:04:44.603] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:44.604] result() for ClusterFuture ...
[16:04:44.604] - result already collected: FutureResult
[16:04:44.604] result() for ClusterFuture ... done
[16:04:44.604] result() for ClusterFuture ...
[16:04:44.604] - result already collected: FutureResult
[16:04:44.604] result() for ClusterFuture ... done
[16:04:44.605] MultisessionFuture started
[16:04:44.605] - Launch lazy future ... done
[16:04:44.605] run() for ‘MultisessionFuture’ ... done
<environment: 0x55874c5e1cf0> 
<environment: 0x55874f38bcb0> 
[16:04:44.616] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.616] - Validating connection of MultisessionFuture
[16:04:44.616] - received message: FutureResult
[16:04:44.616] - Received FutureResult
[16:04:44.616] - Erased future from FutureRegistry
[16:04:44.616] result() for ClusterFuture ...
[16:04:44.616] - result already collected: FutureResult
[16:04:44.617] result() for ClusterFuture ... done
[16:04:44.617] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:44.628] resolve() on environment ...
[16:04:44.628]  recursive: 0
[16:04:44.629]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:44.629] signalConditionsASAP(numeric, pos=1) ...
[16:04:44.629] - nx: 4
[16:04:44.629] - relay: TRUE
[16:04:44.629] - stdout: TRUE
[16:04:44.630] - signal: TRUE
[16:04:44.630] - resignal: FALSE
[16:04:44.630] - force: TRUE
[16:04:44.630] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.630] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.630]  - until=2
[16:04:44.630]  - relaying element #2
[16:04:44.630] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:44.630] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.630] signalConditionsASAP(NULL, pos=1) ... done
[16:04:44.630]  length: 3 (resolved future 1)
[16:04:44.631] Future #2
[16:04:44.631] result() for ClusterFuture ...
[16:04:44.631] - result already collected: FutureResult
[16:04:44.631] result() for ClusterFuture ... done
[16:04:44.631] result() for ClusterFuture ...
[16:04:44.631] - result already collected: FutureResult
[16:04:44.631] result() for ClusterFuture ... done
[16:04:44.631] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:44.631] - nx: 4
[16:04:44.631] - relay: TRUE
[16:04:44.631] - stdout: TRUE
[16:04:44.632] - signal: TRUE
[16:04:44.632] - resignal: FALSE
[16:04:44.632] - force: TRUE
[16:04:44.632] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:44.632] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.632]  - until=2
[16:04:44.632]  - relaying element #2
[16:04:44.632] result() for ClusterFuture ...
[16:04:44.632] - result already collected: FutureResult
[16:04:44.632] result() for ClusterFuture ... done
[16:04:44.632] result() for ClusterFuture ...
[16:04:44.633] - result already collected: FutureResult
[16:04:44.633] result() for ClusterFuture ... done
[16:04:44.633] result() for ClusterFuture ...
[16:04:44.633] - result already collected: FutureResult
[16:04:44.633] result() for ClusterFuture ... done
[16:04:44.633] result() for ClusterFuture ...
[16:04:44.633] - result already collected: FutureResult
[16:04:44.633] result() for ClusterFuture ... done
[16:04:44.633] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:44.633] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:44.633] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:44.634]  length: 2 (resolved future 2)
[16:04:44.634] Future #3
[16:04:44.634] result() for ClusterFuture ...
[16:04:44.634] - result already collected: FutureResult
[16:04:44.634] result() for ClusterFuture ... done
[16:04:44.634] result() for ClusterFuture ...
[16:04:44.634] - result already collected: FutureResult
[16:04:44.634] result() for ClusterFuture ... done
[16:04:44.634] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:44.634] - nx: 4
[16:04:44.634] - relay: TRUE
[16:04:44.634] - stdout: TRUE
[16:04:44.635] - signal: TRUE
[16:04:44.635] - resignal: FALSE
[16:04:44.635] - force: TRUE
[16:04:44.635] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:44.635] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:44.635]  - until=3
[16:04:44.635]  - relaying element #3
[16:04:44.635] result() for ClusterFuture ...
[16:04:44.635] - result already collected: FutureResult
[16:04:44.635] result() for ClusterFuture ... done
[16:04:44.635] result() for ClusterFuture ...
[16:04:44.636] - result already collected: FutureResult
[16:04:44.636] result() for ClusterFuture ... done
[16:04:44.636] result() for ClusterFuture ...
[16:04:44.636] - result already collected: FutureResult
[16:04:44.636] result() for ClusterFuture ... done
[16:04:44.636] result() for ClusterFuture ...
[16:04:44.636] - result already collected: FutureResult
[16:04:44.636] result() for ClusterFuture ... done
[16:04:44.636] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:44.636] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:44.636] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:44.637]  length: 1 (resolved future 3)
[16:04:44.658] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.658] - Validating connection of MultisessionFuture
[16:04:44.658] - received message: FutureResult
[16:04:44.658] - Received FutureResult
[16:04:44.658] - Erased future from FutureRegistry
[16:04:44.658] result() for ClusterFuture ...
[16:04:44.658] - result already collected: FutureResult
[16:04:44.658] result() for ClusterFuture ... done
[16:04:44.659] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:44.659] Future #4
[16:04:44.659] result() for ClusterFuture ...
[16:04:44.659] - result already collected: FutureResult
[16:04:44.659] result() for ClusterFuture ... done
[16:04:44.659] result() for ClusterFuture ...
[16:04:44.659] - result already collected: FutureResult
[16:04:44.659] result() for ClusterFuture ... done
[16:04:44.659] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:04:44.659] - nx: 4
[16:04:44.660] - relay: TRUE
[16:04:44.660] - stdout: TRUE
[16:04:44.660] - signal: TRUE
[16:04:44.660] - resignal: FALSE
[16:04:44.660] - force: TRUE
[16:04:44.660] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:44.660] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:44.660]  - until=4
[16:04:44.660]  - relaying element #4
[16:04:44.660] result() for ClusterFuture ...
[16:04:44.660] - result already collected: FutureResult
[16:04:44.660] result() for ClusterFuture ... done
[16:04:44.661] result() for ClusterFuture ...
[16:04:44.661] - result already collected: FutureResult
[16:04:44.661] result() for ClusterFuture ... done
[16:04:44.661] result() for ClusterFuture ...
[16:04:44.661] - result already collected: FutureResult
[16:04:44.661] result() for ClusterFuture ... done
[16:04:44.661] result() for ClusterFuture ...
[16:04:44.661] - result already collected: FutureResult
[16:04:44.661] result() for ClusterFuture ... done
[16:04:44.661] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.661] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:44.662] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:04:44.662]  length: 0 (resolved future 4)
[16:04:44.662] Relaying remaining futures
[16:04:44.662] signalConditionsASAP(NULL, pos=0) ...
[16:04:44.662] - nx: 4
[16:04:44.662] - relay: TRUE
[16:04:44.662] - stdout: TRUE
[16:04:44.662] - signal: TRUE
[16:04:44.662] - resignal: FALSE
[16:04:44.662] - force: TRUE
[16:04:44.662] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.662] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:44.663] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.663] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:44.663] signalConditionsASAP(NULL, pos=0) ... done
[16:04:44.663] resolve() on environment ... DONE
[16:04:44.663] result() for ClusterFuture ...
[16:04:44.663] - result already collected: FutureResult
[16:04:44.663] result() for ClusterFuture ... done
[16:04:44.663] result() for ClusterFuture ...
[16:04:44.663] - result already collected: FutureResult
[16:04:44.663] result() for ClusterFuture ... done
[16:04:44.666] result() for ClusterFuture ...
[16:04:44.666] - result already collected: FutureResult
[16:04:44.666] result() for ClusterFuture ... done
[16:04:44.666] result() for ClusterFuture ...
[16:04:44.666] - result already collected: FutureResult
[16:04:44.666] result() for ClusterFuture ... done
[16:04:44.667] result() for ClusterFuture ...
[16:04:44.667] - result already collected: FutureResult
[16:04:44.667] result() for ClusterFuture ... done
[16:04:44.667] result() for ClusterFuture ...
[16:04:44.667] - result already collected: FutureResult
[16:04:44.667] result() for ClusterFuture ... done
<environment: 0x55874f5985c8> 
Dimensions: c(2, 1, 3, 1)
[16:04:44.668] getGlobalsAndPackages() ...
[16:04:44.668] Searching for globals...
[16:04:44.668] 
[16:04:44.668] Searching for globals ... DONE
[16:04:44.668] - globals: [0] <none>
[16:04:44.668] getGlobalsAndPackages() ... DONE
[16:04:44.668] run() for ‘Future’ ...
[16:04:44.669] - state: ‘created’
[16:04:44.669] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.683] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.683] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.683]   - Field: ‘node’
[16:04:44.683]   - Field: ‘label’
[16:04:44.683]   - Field: ‘local’
[16:04:44.683]   - Field: ‘owner’
[16:04:44.683]   - Field: ‘envir’
[16:04:44.683]   - Field: ‘workers’
[16:04:44.683]   - Field: ‘packages’
[16:04:44.684]   - Field: ‘gc’
[16:04:44.684]   - Field: ‘conditions’
[16:04:44.684]   - Field: ‘persistent’
[16:04:44.684]   - Field: ‘expr’
[16:04:44.684]   - Field: ‘uuid’
[16:04:44.684]   - Field: ‘seed’
[16:04:44.684]   - Field: ‘version’
[16:04:44.684]   - Field: ‘result’
[16:04:44.684]   - Field: ‘asynchronous’
[16:04:44.684]   - Field: ‘calls’
[16:04:44.684]   - Field: ‘globals’
[16:04:44.684]   - Field: ‘stdout’
[16:04:44.685]   - Field: ‘earlySignal’
[16:04:44.685]   - Field: ‘lazy’
[16:04:44.685]   - Field: ‘state’
[16:04:44.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.685] - Launch lazy future ...
[16:04:44.685] Packages needed by the future expression (n = 0): <none>
[16:04:44.685] Packages needed by future strategies (n = 0): <none>
[16:04:44.686] {
[16:04:44.686]     {
[16:04:44.686]         {
[16:04:44.686]             ...future.startTime <- base::Sys.time()
[16:04:44.686]             {
[16:04:44.686]                 {
[16:04:44.686]                   {
[16:04:44.686]                     {
[16:04:44.686]                       base::local({
[16:04:44.686]                         has_future <- base::requireNamespace("future", 
[16:04:44.686]                           quietly = TRUE)
[16:04:44.686]                         if (has_future) {
[16:04:44.686]                           ns <- base::getNamespace("future")
[16:04:44.686]                           version <- ns[[".package"]][["version"]]
[16:04:44.686]                           if (is.null(version)) 
[16:04:44.686]                             version <- utils::packageVersion("future")
[16:04:44.686]                         }
[16:04:44.686]                         else {
[16:04:44.686]                           version <- NULL
[16:04:44.686]                         }
[16:04:44.686]                         if (!has_future || version < "1.8.0") {
[16:04:44.686]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.686]                             "", base::R.version$version.string), 
[16:04:44.686]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.686]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.686]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.686]                               "release", "version")], collapse = " "), 
[16:04:44.686]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.686]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.686]                             info)
[16:04:44.686]                           info <- base::paste(info, collapse = "; ")
[16:04:44.686]                           if (!has_future) {
[16:04:44.686]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.686]                               info)
[16:04:44.686]                           }
[16:04:44.686]                           else {
[16:04:44.686]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.686]                               info, version)
[16:04:44.686]                           }
[16:04:44.686]                           base::stop(msg)
[16:04:44.686]                         }
[16:04:44.686]                       })
[16:04:44.686]                     }
[16:04:44.686]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.686]                     base::options(mc.cores = 1L)
[16:04:44.686]                   }
[16:04:44.686]                   options(future.plan = NULL)
[16:04:44.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.686]                 }
[16:04:44.686]                 ...future.workdir <- getwd()
[16:04:44.686]             }
[16:04:44.686]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.686]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.686]         }
[16:04:44.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.686]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.686]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.686]             base::names(...future.oldOptions))
[16:04:44.686]     }
[16:04:44.686]     if (FALSE) {
[16:04:44.686]     }
[16:04:44.686]     else {
[16:04:44.686]         if (TRUE) {
[16:04:44.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.686]                 open = "w")
[16:04:44.686]         }
[16:04:44.686]         else {
[16:04:44.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.686]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.686]         }
[16:04:44.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.686]             base::sink(type = "output", split = FALSE)
[16:04:44.686]             base::close(...future.stdout)
[16:04:44.686]         }, add = TRUE)
[16:04:44.686]     }
[16:04:44.686]     ...future.frame <- base::sys.nframe()
[16:04:44.686]     ...future.conditions <- base::list()
[16:04:44.686]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.686]     if (FALSE) {
[16:04:44.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.686]     }
[16:04:44.686]     ...future.result <- base::tryCatch({
[16:04:44.686]         base::withCallingHandlers({
[16:04:44.686]             ...future.value <- base::withVisible(base::local({
[16:04:44.686]                 ...future.makeSendCondition <- base::local({
[16:04:44.686]                   sendCondition <- NULL
[16:04:44.686]                   function(frame = 1L) {
[16:04:44.686]                     if (is.function(sendCondition)) 
[16:04:44.686]                       return(sendCondition)
[16:04:44.686]                     ns <- getNamespace("parallel")
[16:04:44.686]                     if (exists("sendData", mode = "function", 
[16:04:44.686]                       envir = ns)) {
[16:04:44.686]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.686]                         envir = ns)
[16:04:44.686]                       envir <- sys.frame(frame)
[16:04:44.686]                       master <- NULL
[16:04:44.686]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.686]                         !identical(envir, emptyenv())) {
[16:04:44.686]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.686]                           inherits = FALSE)) {
[16:04:44.686]                           master <- get("master", mode = "list", 
[16:04:44.686]                             envir = envir, inherits = FALSE)
[16:04:44.686]                           if (inherits(master, c("SOCKnode", 
[16:04:44.686]                             "SOCK0node"))) {
[16:04:44.686]                             sendCondition <<- function(cond) {
[16:04:44.686]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.686]                                 success = TRUE)
[16:04:44.686]                               parallel_sendData(master, data)
[16:04:44.686]                             }
[16:04:44.686]                             return(sendCondition)
[16:04:44.686]                           }
[16:04:44.686]                         }
[16:04:44.686]                         frame <- frame + 1L
[16:04:44.686]                         envir <- sys.frame(frame)
[16:04:44.686]                       }
[16:04:44.686]                     }
[16:04:44.686]                     sendCondition <<- function(cond) NULL
[16:04:44.686]                   }
[16:04:44.686]                 })
[16:04:44.686]                 withCallingHandlers({
[16:04:44.686]                   2
[16:04:44.686]                 }, immediateCondition = function(cond) {
[16:04:44.686]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.686]                   sendCondition(cond)
[16:04:44.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.686]                   {
[16:04:44.686]                     inherits <- base::inherits
[16:04:44.686]                     invokeRestart <- base::invokeRestart
[16:04:44.686]                     is.null <- base::is.null
[16:04:44.686]                     muffled <- FALSE
[16:04:44.686]                     if (inherits(cond, "message")) {
[16:04:44.686]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.686]                       if (muffled) 
[16:04:44.686]                         invokeRestart("muffleMessage")
[16:04:44.686]                     }
[16:04:44.686]                     else if (inherits(cond, "warning")) {
[16:04:44.686]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.686]                       if (muffled) 
[16:04:44.686]                         invokeRestart("muffleWarning")
[16:04:44.686]                     }
[16:04:44.686]                     else if (inherits(cond, "condition")) {
[16:04:44.686]                       if (!is.null(pattern)) {
[16:04:44.686]                         computeRestarts <- base::computeRestarts
[16:04:44.686]                         grepl <- base::grepl
[16:04:44.686]                         restarts <- computeRestarts(cond)
[16:04:44.686]                         for (restart in restarts) {
[16:04:44.686]                           name <- restart$name
[16:04:44.686]                           if (is.null(name)) 
[16:04:44.686]                             next
[16:04:44.686]                           if (!grepl(pattern, name)) 
[16:04:44.686]                             next
[16:04:44.686]                           invokeRestart(restart)
[16:04:44.686]                           muffled <- TRUE
[16:04:44.686]                           break
[16:04:44.686]                         }
[16:04:44.686]                       }
[16:04:44.686]                     }
[16:04:44.686]                     invisible(muffled)
[16:04:44.686]                   }
[16:04:44.686]                   muffleCondition(cond)
[16:04:44.686]                 })
[16:04:44.686]             }))
[16:04:44.686]             future::FutureResult(value = ...future.value$value, 
[16:04:44.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.686]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.686]                     ...future.globalenv.names))
[16:04:44.686]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.686]         }, condition = base::local({
[16:04:44.686]             c <- base::c
[16:04:44.686]             inherits <- base::inherits
[16:04:44.686]             invokeRestart <- base::invokeRestart
[16:04:44.686]             length <- base::length
[16:04:44.686]             list <- base::list
[16:04:44.686]             seq.int <- base::seq.int
[16:04:44.686]             signalCondition <- base::signalCondition
[16:04:44.686]             sys.calls <- base::sys.calls
[16:04:44.686]             `[[` <- base::`[[`
[16:04:44.686]             `+` <- base::`+`
[16:04:44.686]             `<<-` <- base::`<<-`
[16:04:44.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.686]                   3L)]
[16:04:44.686]             }
[16:04:44.686]             function(cond) {
[16:04:44.686]                 is_error <- inherits(cond, "error")
[16:04:44.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.686]                   NULL)
[16:04:44.686]                 if (is_error) {
[16:04:44.686]                   sessionInformation <- function() {
[16:04:44.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.686]                       search = base::search(), system = base::Sys.info())
[16:04:44.686]                   }
[16:04:44.686]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.686]                     cond$call), session = sessionInformation(), 
[16:04:44.686]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.686]                   signalCondition(cond)
[16:04:44.686]                 }
[16:04:44.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.686]                 "immediateCondition"))) {
[16:04:44.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.686]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.686]                   if (TRUE && !signal) {
[16:04:44.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.686]                     {
[16:04:44.686]                       inherits <- base::inherits
[16:04:44.686]                       invokeRestart <- base::invokeRestart
[16:04:44.686]                       is.null <- base::is.null
[16:04:44.686]                       muffled <- FALSE
[16:04:44.686]                       if (inherits(cond, "message")) {
[16:04:44.686]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.686]                         if (muffled) 
[16:04:44.686]                           invokeRestart("muffleMessage")
[16:04:44.686]                       }
[16:04:44.686]                       else if (inherits(cond, "warning")) {
[16:04:44.686]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.686]                         if (muffled) 
[16:04:44.686]                           invokeRestart("muffleWarning")
[16:04:44.686]                       }
[16:04:44.686]                       else if (inherits(cond, "condition")) {
[16:04:44.686]                         if (!is.null(pattern)) {
[16:04:44.686]                           computeRestarts <- base::computeRestarts
[16:04:44.686]                           grepl <- base::grepl
[16:04:44.686]                           restarts <- computeRestarts(cond)
[16:04:44.686]                           for (restart in restarts) {
[16:04:44.686]                             name <- restart$name
[16:04:44.686]                             if (is.null(name)) 
[16:04:44.686]                               next
[16:04:44.686]                             if (!grepl(pattern, name)) 
[16:04:44.686]                               next
[16:04:44.686]                             invokeRestart(restart)
[16:04:44.686]                             muffled <- TRUE
[16:04:44.686]                             break
[16:04:44.686]                           }
[16:04:44.686]                         }
[16:04:44.686]                       }
[16:04:44.686]                       invisible(muffled)
[16:04:44.686]                     }
[16:04:44.686]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.686]                   }
[16:04:44.686]                 }
[16:04:44.686]                 else {
[16:04:44.686]                   if (TRUE) {
[16:04:44.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.686]                     {
[16:04:44.686]                       inherits <- base::inherits
[16:04:44.686]                       invokeRestart <- base::invokeRestart
[16:04:44.686]                       is.null <- base::is.null
[16:04:44.686]                       muffled <- FALSE
[16:04:44.686]                       if (inherits(cond, "message")) {
[16:04:44.686]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.686]                         if (muffled) 
[16:04:44.686]                           invokeRestart("muffleMessage")
[16:04:44.686]                       }
[16:04:44.686]                       else if (inherits(cond, "warning")) {
[16:04:44.686]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.686]                         if (muffled) 
[16:04:44.686]                           invokeRestart("muffleWarning")
[16:04:44.686]                       }
[16:04:44.686]                       else if (inherits(cond, "condition")) {
[16:04:44.686]                         if (!is.null(pattern)) {
[16:04:44.686]                           computeRestarts <- base::computeRestarts
[16:04:44.686]                           grepl <- base::grepl
[16:04:44.686]                           restarts <- computeRestarts(cond)
[16:04:44.686]                           for (restart in restarts) {
[16:04:44.686]                             name <- restart$name
[16:04:44.686]                             if (is.null(name)) 
[16:04:44.686]                               next
[16:04:44.686]                             if (!grepl(pattern, name)) 
[16:04:44.686]                               next
[16:04:44.686]                             invokeRestart(restart)
[16:04:44.686]                             muffled <- TRUE
[16:04:44.686]                             break
[16:04:44.686]                           }
[16:04:44.686]                         }
[16:04:44.686]                       }
[16:04:44.686]                       invisible(muffled)
[16:04:44.686]                     }
[16:04:44.686]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.686]                   }
[16:04:44.686]                 }
[16:04:44.686]             }
[16:04:44.686]         }))
[16:04:44.686]     }, error = function(ex) {
[16:04:44.686]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.686]                 ...future.rng), started = ...future.startTime, 
[16:04:44.686]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.686]             version = "1.8"), class = "FutureResult")
[16:04:44.686]     }, finally = {
[16:04:44.686]         if (!identical(...future.workdir, getwd())) 
[16:04:44.686]             setwd(...future.workdir)
[16:04:44.686]         {
[16:04:44.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.686]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.686]             }
[16:04:44.686]             base::options(...future.oldOptions)
[16:04:44.686]             if (.Platform$OS.type == "windows") {
[16:04:44.686]                 old_names <- names(...future.oldEnvVars)
[16:04:44.686]                 envs <- base::Sys.getenv()
[16:04:44.686]                 names <- names(envs)
[16:04:44.686]                 common <- intersect(names, old_names)
[16:04:44.686]                 added <- setdiff(names, old_names)
[16:04:44.686]                 removed <- setdiff(old_names, names)
[16:04:44.686]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.686]                   envs[common]]
[16:04:44.686]                 NAMES <- toupper(changed)
[16:04:44.686]                 args <- list()
[16:04:44.686]                 for (kk in seq_along(NAMES)) {
[16:04:44.686]                   name <- changed[[kk]]
[16:04:44.686]                   NAME <- NAMES[[kk]]
[16:04:44.686]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.686]                     next
[16:04:44.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.686]                 }
[16:04:44.686]                 NAMES <- toupper(added)
[16:04:44.686]                 for (kk in seq_along(NAMES)) {
[16:04:44.686]                   name <- added[[kk]]
[16:04:44.686]                   NAME <- NAMES[[kk]]
[16:04:44.686]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.686]                     next
[16:04:44.686]                   args[[name]] <- ""
[16:04:44.686]                 }
[16:04:44.686]                 NAMES <- toupper(removed)
[16:04:44.686]                 for (kk in seq_along(NAMES)) {
[16:04:44.686]                   name <- removed[[kk]]
[16:04:44.686]                   NAME <- NAMES[[kk]]
[16:04:44.686]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.686]                     next
[16:04:44.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.686]                 }
[16:04:44.686]                 if (length(args) > 0) 
[16:04:44.686]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.686]             }
[16:04:44.686]             else {
[16:04:44.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.686]             }
[16:04:44.686]             {
[16:04:44.686]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.686]                   0L) {
[16:04:44.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.686]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.686]                   base::options(opts)
[16:04:44.686]                 }
[16:04:44.686]                 {
[16:04:44.686]                   {
[16:04:44.686]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.686]                     NULL
[16:04:44.686]                   }
[16:04:44.686]                   options(future.plan = NULL)
[16:04:44.686]                   if (is.na(NA_character_)) 
[16:04:44.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.686]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.686]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.686]                     envir = parent.frame()) 
[16:04:44.686]                   {
[16:04:44.686]                     if (is.function(workers)) 
[16:04:44.686]                       workers <- workers()
[16:04:44.686]                     workers <- structure(as.integer(workers), 
[16:04:44.686]                       class = class(workers))
[16:04:44.686]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.686]                       workers >= 1)
[16:04:44.686]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.686]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.686]                     }
[16:04:44.686]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.686]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.686]                       envir = envir)
[16:04:44.686]                     if (!future$lazy) 
[16:04:44.686]                       future <- run(future)
[16:04:44.686]                     invisible(future)
[16:04:44.686]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.686]                 }
[16:04:44.686]             }
[16:04:44.686]         }
[16:04:44.686]     })
[16:04:44.686]     if (TRUE) {
[16:04:44.686]         base::sink(type = "output", split = FALSE)
[16:04:44.686]         if (TRUE) {
[16:04:44.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.686]         }
[16:04:44.686]         else {
[16:04:44.686]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.686]         }
[16:04:44.686]         base::close(...future.stdout)
[16:04:44.686]         ...future.stdout <- NULL
[16:04:44.686]     }
[16:04:44.686]     ...future.result$conditions <- ...future.conditions
[16:04:44.686]     ...future.result$finished <- base::Sys.time()
[16:04:44.686]     ...future.result
[16:04:44.686] }
[16:04:44.689] MultisessionFuture started
[16:04:44.689] - Launch lazy future ... done
[16:04:44.689] run() for ‘MultisessionFuture’ ... done
[16:04:44.689] getGlobalsAndPackages() ...
[16:04:44.689] Searching for globals...
[16:04:44.690] 
[16:04:44.690] Searching for globals ... DONE
[16:04:44.690] - globals: [0] <none>
[16:04:44.690] getGlobalsAndPackages() ... DONE
[16:04:44.690] run() for ‘Future’ ...
[16:04:44.690] - state: ‘created’
[16:04:44.691] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.704] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.704] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.704]   - Field: ‘node’
[16:04:44.704]   - Field: ‘label’
[16:04:44.704]   - Field: ‘local’
[16:04:44.704]   - Field: ‘owner’
[16:04:44.705]   - Field: ‘envir’
[16:04:44.705]   - Field: ‘workers’
[16:04:44.705]   - Field: ‘packages’
[16:04:44.705]   - Field: ‘gc’
[16:04:44.705]   - Field: ‘conditions’
[16:04:44.705]   - Field: ‘persistent’
[16:04:44.705]   - Field: ‘expr’
[16:04:44.705]   - Field: ‘uuid’
[16:04:44.705]   - Field: ‘seed’
[16:04:44.705]   - Field: ‘version’
[16:04:44.705]   - Field: ‘result’
[16:04:44.706]   - Field: ‘asynchronous’
[16:04:44.706]   - Field: ‘calls’
[16:04:44.706]   - Field: ‘globals’
[16:04:44.706]   - Field: ‘stdout’
[16:04:44.706]   - Field: ‘earlySignal’
[16:04:44.706]   - Field: ‘lazy’
[16:04:44.706]   - Field: ‘state’
[16:04:44.706] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.706] - Launch lazy future ...
[16:04:44.707] Packages needed by the future expression (n = 0): <none>
[16:04:44.707] Packages needed by future strategies (n = 0): <none>
[16:04:44.707] {
[16:04:44.707]     {
[16:04:44.707]         {
[16:04:44.707]             ...future.startTime <- base::Sys.time()
[16:04:44.707]             {
[16:04:44.707]                 {
[16:04:44.707]                   {
[16:04:44.707]                     {
[16:04:44.707]                       base::local({
[16:04:44.707]                         has_future <- base::requireNamespace("future", 
[16:04:44.707]                           quietly = TRUE)
[16:04:44.707]                         if (has_future) {
[16:04:44.707]                           ns <- base::getNamespace("future")
[16:04:44.707]                           version <- ns[[".package"]][["version"]]
[16:04:44.707]                           if (is.null(version)) 
[16:04:44.707]                             version <- utils::packageVersion("future")
[16:04:44.707]                         }
[16:04:44.707]                         else {
[16:04:44.707]                           version <- NULL
[16:04:44.707]                         }
[16:04:44.707]                         if (!has_future || version < "1.8.0") {
[16:04:44.707]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.707]                             "", base::R.version$version.string), 
[16:04:44.707]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.707]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.707]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.707]                               "release", "version")], collapse = " "), 
[16:04:44.707]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.707]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.707]                             info)
[16:04:44.707]                           info <- base::paste(info, collapse = "; ")
[16:04:44.707]                           if (!has_future) {
[16:04:44.707]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.707]                               info)
[16:04:44.707]                           }
[16:04:44.707]                           else {
[16:04:44.707]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.707]                               info, version)
[16:04:44.707]                           }
[16:04:44.707]                           base::stop(msg)
[16:04:44.707]                         }
[16:04:44.707]                       })
[16:04:44.707]                     }
[16:04:44.707]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.707]                     base::options(mc.cores = 1L)
[16:04:44.707]                   }
[16:04:44.707]                   options(future.plan = NULL)
[16:04:44.707]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.707]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.707]                 }
[16:04:44.707]                 ...future.workdir <- getwd()
[16:04:44.707]             }
[16:04:44.707]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.707]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.707]         }
[16:04:44.707]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.707]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.707]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.707]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.707]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.707]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.707]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.707]             base::names(...future.oldOptions))
[16:04:44.707]     }
[16:04:44.707]     if (FALSE) {
[16:04:44.707]     }
[16:04:44.707]     else {
[16:04:44.707]         if (TRUE) {
[16:04:44.707]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.707]                 open = "w")
[16:04:44.707]         }
[16:04:44.707]         else {
[16:04:44.707]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.707]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.707]         }
[16:04:44.707]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.707]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.707]             base::sink(type = "output", split = FALSE)
[16:04:44.707]             base::close(...future.stdout)
[16:04:44.707]         }, add = TRUE)
[16:04:44.707]     }
[16:04:44.707]     ...future.frame <- base::sys.nframe()
[16:04:44.707]     ...future.conditions <- base::list()
[16:04:44.707]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.707]     if (FALSE) {
[16:04:44.707]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.707]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.707]     }
[16:04:44.707]     ...future.result <- base::tryCatch({
[16:04:44.707]         base::withCallingHandlers({
[16:04:44.707]             ...future.value <- base::withVisible(base::local({
[16:04:44.707]                 ...future.makeSendCondition <- base::local({
[16:04:44.707]                   sendCondition <- NULL
[16:04:44.707]                   function(frame = 1L) {
[16:04:44.707]                     if (is.function(sendCondition)) 
[16:04:44.707]                       return(sendCondition)
[16:04:44.707]                     ns <- getNamespace("parallel")
[16:04:44.707]                     if (exists("sendData", mode = "function", 
[16:04:44.707]                       envir = ns)) {
[16:04:44.707]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.707]                         envir = ns)
[16:04:44.707]                       envir <- sys.frame(frame)
[16:04:44.707]                       master <- NULL
[16:04:44.707]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.707]                         !identical(envir, emptyenv())) {
[16:04:44.707]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.707]                           inherits = FALSE)) {
[16:04:44.707]                           master <- get("master", mode = "list", 
[16:04:44.707]                             envir = envir, inherits = FALSE)
[16:04:44.707]                           if (inherits(master, c("SOCKnode", 
[16:04:44.707]                             "SOCK0node"))) {
[16:04:44.707]                             sendCondition <<- function(cond) {
[16:04:44.707]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.707]                                 success = TRUE)
[16:04:44.707]                               parallel_sendData(master, data)
[16:04:44.707]                             }
[16:04:44.707]                             return(sendCondition)
[16:04:44.707]                           }
[16:04:44.707]                         }
[16:04:44.707]                         frame <- frame + 1L
[16:04:44.707]                         envir <- sys.frame(frame)
[16:04:44.707]                       }
[16:04:44.707]                     }
[16:04:44.707]                     sendCondition <<- function(cond) NULL
[16:04:44.707]                   }
[16:04:44.707]                 })
[16:04:44.707]                 withCallingHandlers({
[16:04:44.707]                   NULL
[16:04:44.707]                 }, immediateCondition = function(cond) {
[16:04:44.707]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.707]                   sendCondition(cond)
[16:04:44.707]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.707]                   {
[16:04:44.707]                     inherits <- base::inherits
[16:04:44.707]                     invokeRestart <- base::invokeRestart
[16:04:44.707]                     is.null <- base::is.null
[16:04:44.707]                     muffled <- FALSE
[16:04:44.707]                     if (inherits(cond, "message")) {
[16:04:44.707]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.707]                       if (muffled) 
[16:04:44.707]                         invokeRestart("muffleMessage")
[16:04:44.707]                     }
[16:04:44.707]                     else if (inherits(cond, "warning")) {
[16:04:44.707]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.707]                       if (muffled) 
[16:04:44.707]                         invokeRestart("muffleWarning")
[16:04:44.707]                     }
[16:04:44.707]                     else if (inherits(cond, "condition")) {
[16:04:44.707]                       if (!is.null(pattern)) {
[16:04:44.707]                         computeRestarts <- base::computeRestarts
[16:04:44.707]                         grepl <- base::grepl
[16:04:44.707]                         restarts <- computeRestarts(cond)
[16:04:44.707]                         for (restart in restarts) {
[16:04:44.707]                           name <- restart$name
[16:04:44.707]                           if (is.null(name)) 
[16:04:44.707]                             next
[16:04:44.707]                           if (!grepl(pattern, name)) 
[16:04:44.707]                             next
[16:04:44.707]                           invokeRestart(restart)
[16:04:44.707]                           muffled <- TRUE
[16:04:44.707]                           break
[16:04:44.707]                         }
[16:04:44.707]                       }
[16:04:44.707]                     }
[16:04:44.707]                     invisible(muffled)
[16:04:44.707]                   }
[16:04:44.707]                   muffleCondition(cond)
[16:04:44.707]                 })
[16:04:44.707]             }))
[16:04:44.707]             future::FutureResult(value = ...future.value$value, 
[16:04:44.707]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.707]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.707]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.707]                     ...future.globalenv.names))
[16:04:44.707]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.707]         }, condition = base::local({
[16:04:44.707]             c <- base::c
[16:04:44.707]             inherits <- base::inherits
[16:04:44.707]             invokeRestart <- base::invokeRestart
[16:04:44.707]             length <- base::length
[16:04:44.707]             list <- base::list
[16:04:44.707]             seq.int <- base::seq.int
[16:04:44.707]             signalCondition <- base::signalCondition
[16:04:44.707]             sys.calls <- base::sys.calls
[16:04:44.707]             `[[` <- base::`[[`
[16:04:44.707]             `+` <- base::`+`
[16:04:44.707]             `<<-` <- base::`<<-`
[16:04:44.707]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.707]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.707]                   3L)]
[16:04:44.707]             }
[16:04:44.707]             function(cond) {
[16:04:44.707]                 is_error <- inherits(cond, "error")
[16:04:44.707]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.707]                   NULL)
[16:04:44.707]                 if (is_error) {
[16:04:44.707]                   sessionInformation <- function() {
[16:04:44.707]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.707]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.707]                       search = base::search(), system = base::Sys.info())
[16:04:44.707]                   }
[16:04:44.707]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.707]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.707]                     cond$call), session = sessionInformation(), 
[16:04:44.707]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.707]                   signalCondition(cond)
[16:04:44.707]                 }
[16:04:44.707]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.707]                 "immediateCondition"))) {
[16:04:44.707]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.707]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.707]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.707]                   if (TRUE && !signal) {
[16:04:44.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.707]                     {
[16:04:44.707]                       inherits <- base::inherits
[16:04:44.707]                       invokeRestart <- base::invokeRestart
[16:04:44.707]                       is.null <- base::is.null
[16:04:44.707]                       muffled <- FALSE
[16:04:44.707]                       if (inherits(cond, "message")) {
[16:04:44.707]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.707]                         if (muffled) 
[16:04:44.707]                           invokeRestart("muffleMessage")
[16:04:44.707]                       }
[16:04:44.707]                       else if (inherits(cond, "warning")) {
[16:04:44.707]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.707]                         if (muffled) 
[16:04:44.707]                           invokeRestart("muffleWarning")
[16:04:44.707]                       }
[16:04:44.707]                       else if (inherits(cond, "condition")) {
[16:04:44.707]                         if (!is.null(pattern)) {
[16:04:44.707]                           computeRestarts <- base::computeRestarts
[16:04:44.707]                           grepl <- base::grepl
[16:04:44.707]                           restarts <- computeRestarts(cond)
[16:04:44.707]                           for (restart in restarts) {
[16:04:44.707]                             name <- restart$name
[16:04:44.707]                             if (is.null(name)) 
[16:04:44.707]                               next
[16:04:44.707]                             if (!grepl(pattern, name)) 
[16:04:44.707]                               next
[16:04:44.707]                             invokeRestart(restart)
[16:04:44.707]                             muffled <- TRUE
[16:04:44.707]                             break
[16:04:44.707]                           }
[16:04:44.707]                         }
[16:04:44.707]                       }
[16:04:44.707]                       invisible(muffled)
[16:04:44.707]                     }
[16:04:44.707]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.707]                   }
[16:04:44.707]                 }
[16:04:44.707]                 else {
[16:04:44.707]                   if (TRUE) {
[16:04:44.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.707]                     {
[16:04:44.707]                       inherits <- base::inherits
[16:04:44.707]                       invokeRestart <- base::invokeRestart
[16:04:44.707]                       is.null <- base::is.null
[16:04:44.707]                       muffled <- FALSE
[16:04:44.707]                       if (inherits(cond, "message")) {
[16:04:44.707]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.707]                         if (muffled) 
[16:04:44.707]                           invokeRestart("muffleMessage")
[16:04:44.707]                       }
[16:04:44.707]                       else if (inherits(cond, "warning")) {
[16:04:44.707]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.707]                         if (muffled) 
[16:04:44.707]                           invokeRestart("muffleWarning")
[16:04:44.707]                       }
[16:04:44.707]                       else if (inherits(cond, "condition")) {
[16:04:44.707]                         if (!is.null(pattern)) {
[16:04:44.707]                           computeRestarts <- base::computeRestarts
[16:04:44.707]                           grepl <- base::grepl
[16:04:44.707]                           restarts <- computeRestarts(cond)
[16:04:44.707]                           for (restart in restarts) {
[16:04:44.707]                             name <- restart$name
[16:04:44.707]                             if (is.null(name)) 
[16:04:44.707]                               next
[16:04:44.707]                             if (!grepl(pattern, name)) 
[16:04:44.707]                               next
[16:04:44.707]                             invokeRestart(restart)
[16:04:44.707]                             muffled <- TRUE
[16:04:44.707]                             break
[16:04:44.707]                           }
[16:04:44.707]                         }
[16:04:44.707]                       }
[16:04:44.707]                       invisible(muffled)
[16:04:44.707]                     }
[16:04:44.707]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.707]                   }
[16:04:44.707]                 }
[16:04:44.707]             }
[16:04:44.707]         }))
[16:04:44.707]     }, error = function(ex) {
[16:04:44.707]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.707]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.707]                 ...future.rng), started = ...future.startTime, 
[16:04:44.707]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.707]             version = "1.8"), class = "FutureResult")
[16:04:44.707]     }, finally = {
[16:04:44.707]         if (!identical(...future.workdir, getwd())) 
[16:04:44.707]             setwd(...future.workdir)
[16:04:44.707]         {
[16:04:44.707]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.707]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.707]             }
[16:04:44.707]             base::options(...future.oldOptions)
[16:04:44.707]             if (.Platform$OS.type == "windows") {
[16:04:44.707]                 old_names <- names(...future.oldEnvVars)
[16:04:44.707]                 envs <- base::Sys.getenv()
[16:04:44.707]                 names <- names(envs)
[16:04:44.707]                 common <- intersect(names, old_names)
[16:04:44.707]                 added <- setdiff(names, old_names)
[16:04:44.707]                 removed <- setdiff(old_names, names)
[16:04:44.707]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.707]                   envs[common]]
[16:04:44.707]                 NAMES <- toupper(changed)
[16:04:44.707]                 args <- list()
[16:04:44.707]                 for (kk in seq_along(NAMES)) {
[16:04:44.707]                   name <- changed[[kk]]
[16:04:44.707]                   NAME <- NAMES[[kk]]
[16:04:44.707]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.707]                     next
[16:04:44.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.707]                 }
[16:04:44.707]                 NAMES <- toupper(added)
[16:04:44.707]                 for (kk in seq_along(NAMES)) {
[16:04:44.707]                   name <- added[[kk]]
[16:04:44.707]                   NAME <- NAMES[[kk]]
[16:04:44.707]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.707]                     next
[16:04:44.707]                   args[[name]] <- ""
[16:04:44.707]                 }
[16:04:44.707]                 NAMES <- toupper(removed)
[16:04:44.707]                 for (kk in seq_along(NAMES)) {
[16:04:44.707]                   name <- removed[[kk]]
[16:04:44.707]                   NAME <- NAMES[[kk]]
[16:04:44.707]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.707]                     next
[16:04:44.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.707]                 }
[16:04:44.707]                 if (length(args) > 0) 
[16:04:44.707]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.707]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.707]             }
[16:04:44.707]             else {
[16:04:44.707]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.707]             }
[16:04:44.707]             {
[16:04:44.707]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.707]                   0L) {
[16:04:44.707]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.707]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.707]                   base::options(opts)
[16:04:44.707]                 }
[16:04:44.707]                 {
[16:04:44.707]                   {
[16:04:44.707]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.707]                     NULL
[16:04:44.707]                   }
[16:04:44.707]                   options(future.plan = NULL)
[16:04:44.707]                   if (is.na(NA_character_)) 
[16:04:44.707]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.707]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.707]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.707]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.707]                     envir = parent.frame()) 
[16:04:44.707]                   {
[16:04:44.707]                     if (is.function(workers)) 
[16:04:44.707]                       workers <- workers()
[16:04:44.707]                     workers <- structure(as.integer(workers), 
[16:04:44.707]                       class = class(workers))
[16:04:44.707]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.707]                       workers >= 1)
[16:04:44.707]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.707]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.707]                     }
[16:04:44.707]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.707]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.707]                       envir = envir)
[16:04:44.707]                     if (!future$lazy) 
[16:04:44.707]                       future <- run(future)
[16:04:44.707]                     invisible(future)
[16:04:44.707]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.707]                 }
[16:04:44.707]             }
[16:04:44.707]         }
[16:04:44.707]     })
[16:04:44.707]     if (TRUE) {
[16:04:44.707]         base::sink(type = "output", split = FALSE)
[16:04:44.707]         if (TRUE) {
[16:04:44.707]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.707]         }
[16:04:44.707]         else {
[16:04:44.707]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.707]         }
[16:04:44.707]         base::close(...future.stdout)
[16:04:44.707]         ...future.stdout <- NULL
[16:04:44.707]     }
[16:04:44.707]     ...future.result$conditions <- ...future.conditions
[16:04:44.707]     ...future.result$finished <- base::Sys.time()
[16:04:44.707]     ...future.result
[16:04:44.707] }
[16:04:44.710] MultisessionFuture started
[16:04:44.710] - Launch lazy future ... done
[16:04:44.710] run() for ‘MultisessionFuture’ ... done
[16:04:44.711] getGlobalsAndPackages() ...
[16:04:44.711] Searching for globals...
[16:04:44.711] - globals found: [1] ‘{’
[16:04:44.711] Searching for globals ... DONE
[16:04:44.712] Resolving globals: FALSE
[16:04:44.712] 
[16:04:44.712] 
[16:04:44.712] getGlobalsAndPackages() ... DONE
[16:04:44.712] run() for ‘Future’ ...
[16:04:44.712] - state: ‘created’
[16:04:44.713] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.727] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:44.727]   - Field: ‘node’
[16:04:44.727]   - Field: ‘label’
[16:04:44.728]   - Field: ‘local’
[16:04:44.728]   - Field: ‘owner’
[16:04:44.728]   - Field: ‘envir’
[16:04:44.728]   - Field: ‘workers’
[16:04:44.728]   - Field: ‘packages’
[16:04:44.728]   - Field: ‘gc’
[16:04:44.728]   - Field: ‘conditions’
[16:04:44.728]   - Field: ‘persistent’
[16:04:44.728]   - Field: ‘expr’
[16:04:44.728]   - Field: ‘uuid’
[16:04:44.728]   - Field: ‘seed’
[16:04:44.729]   - Field: ‘version’
[16:04:44.729]   - Field: ‘result’
[16:04:44.729]   - Field: ‘asynchronous’
[16:04:44.729]   - Field: ‘calls’
[16:04:44.729]   - Field: ‘globals’
[16:04:44.729]   - Field: ‘stdout’
[16:04:44.729]   - Field: ‘earlySignal’
[16:04:44.729]   - Field: ‘lazy’
[16:04:44.729]   - Field: ‘state’
[16:04:44.729] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:44.729] - Launch lazy future ...
[16:04:44.730] Packages needed by the future expression (n = 0): <none>
[16:04:44.730] Packages needed by future strategies (n = 0): <none>
[16:04:44.730] {
[16:04:44.730]     {
[16:04:44.730]         {
[16:04:44.730]             ...future.startTime <- base::Sys.time()
[16:04:44.730]             {
[16:04:44.730]                 {
[16:04:44.730]                   {
[16:04:44.730]                     {
[16:04:44.730]                       base::local({
[16:04:44.730]                         has_future <- base::requireNamespace("future", 
[16:04:44.730]                           quietly = TRUE)
[16:04:44.730]                         if (has_future) {
[16:04:44.730]                           ns <- base::getNamespace("future")
[16:04:44.730]                           version <- ns[[".package"]][["version"]]
[16:04:44.730]                           if (is.null(version)) 
[16:04:44.730]                             version <- utils::packageVersion("future")
[16:04:44.730]                         }
[16:04:44.730]                         else {
[16:04:44.730]                           version <- NULL
[16:04:44.730]                         }
[16:04:44.730]                         if (!has_future || version < "1.8.0") {
[16:04:44.730]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.730]                             "", base::R.version$version.string), 
[16:04:44.730]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.730]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.730]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.730]                               "release", "version")], collapse = " "), 
[16:04:44.730]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.730]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.730]                             info)
[16:04:44.730]                           info <- base::paste(info, collapse = "; ")
[16:04:44.730]                           if (!has_future) {
[16:04:44.730]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.730]                               info)
[16:04:44.730]                           }
[16:04:44.730]                           else {
[16:04:44.730]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.730]                               info, version)
[16:04:44.730]                           }
[16:04:44.730]                           base::stop(msg)
[16:04:44.730]                         }
[16:04:44.730]                       })
[16:04:44.730]                     }
[16:04:44.730]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.730]                     base::options(mc.cores = 1L)
[16:04:44.730]                   }
[16:04:44.730]                   options(future.plan = NULL)
[16:04:44.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.730]                 }
[16:04:44.730]                 ...future.workdir <- getwd()
[16:04:44.730]             }
[16:04:44.730]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.730]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.730]         }
[16:04:44.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.730]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.730]             base::names(...future.oldOptions))
[16:04:44.730]     }
[16:04:44.730]     if (FALSE) {
[16:04:44.730]     }
[16:04:44.730]     else {
[16:04:44.730]         if (TRUE) {
[16:04:44.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.730]                 open = "w")
[16:04:44.730]         }
[16:04:44.730]         else {
[16:04:44.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.730]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.730]         }
[16:04:44.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.730]             base::sink(type = "output", split = FALSE)
[16:04:44.730]             base::close(...future.stdout)
[16:04:44.730]         }, add = TRUE)
[16:04:44.730]     }
[16:04:44.730]     ...future.frame <- base::sys.nframe()
[16:04:44.730]     ...future.conditions <- base::list()
[16:04:44.730]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.730]     if (FALSE) {
[16:04:44.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.730]     }
[16:04:44.730]     ...future.result <- base::tryCatch({
[16:04:44.730]         base::withCallingHandlers({
[16:04:44.730]             ...future.value <- base::withVisible(base::local({
[16:04:44.730]                 ...future.makeSendCondition <- base::local({
[16:04:44.730]                   sendCondition <- NULL
[16:04:44.730]                   function(frame = 1L) {
[16:04:44.730]                     if (is.function(sendCondition)) 
[16:04:44.730]                       return(sendCondition)
[16:04:44.730]                     ns <- getNamespace("parallel")
[16:04:44.730]                     if (exists("sendData", mode = "function", 
[16:04:44.730]                       envir = ns)) {
[16:04:44.730]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:44.730]                         envir = ns)
[16:04:44.730]                       envir <- sys.frame(frame)
[16:04:44.730]                       master <- NULL
[16:04:44.730]                       while (!identical(envir, .GlobalEnv) && 
[16:04:44.730]                         !identical(envir, emptyenv())) {
[16:04:44.730]                         if (exists("master", mode = "list", envir = envir, 
[16:04:44.730]                           inherits = FALSE)) {
[16:04:44.730]                           master <- get("master", mode = "list", 
[16:04:44.730]                             envir = envir, inherits = FALSE)
[16:04:44.730]                           if (inherits(master, c("SOCKnode", 
[16:04:44.730]                             "SOCK0node"))) {
[16:04:44.730]                             sendCondition <<- function(cond) {
[16:04:44.730]                               data <- list(type = "VALUE", value = cond, 
[16:04:44.730]                                 success = TRUE)
[16:04:44.730]                               parallel_sendData(master, data)
[16:04:44.730]                             }
[16:04:44.730]                             return(sendCondition)
[16:04:44.730]                           }
[16:04:44.730]                         }
[16:04:44.730]                         frame <- frame + 1L
[16:04:44.730]                         envir <- sys.frame(frame)
[16:04:44.730]                       }
[16:04:44.730]                     }
[16:04:44.730]                     sendCondition <<- function(cond) NULL
[16:04:44.730]                   }
[16:04:44.730]                 })
[16:04:44.730]                 withCallingHandlers({
[16:04:44.730]                   {
[16:04:44.730]                     4
[16:04:44.730]                   }
[16:04:44.730]                 }, immediateCondition = function(cond) {
[16:04:44.730]                   sendCondition <- ...future.makeSendCondition()
[16:04:44.730]                   sendCondition(cond)
[16:04:44.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.730]                   {
[16:04:44.730]                     inherits <- base::inherits
[16:04:44.730]                     invokeRestart <- base::invokeRestart
[16:04:44.730]                     is.null <- base::is.null
[16:04:44.730]                     muffled <- FALSE
[16:04:44.730]                     if (inherits(cond, "message")) {
[16:04:44.730]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.730]                       if (muffled) 
[16:04:44.730]                         invokeRestart("muffleMessage")
[16:04:44.730]                     }
[16:04:44.730]                     else if (inherits(cond, "warning")) {
[16:04:44.730]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.730]                       if (muffled) 
[16:04:44.730]                         invokeRestart("muffleWarning")
[16:04:44.730]                     }
[16:04:44.730]                     else if (inherits(cond, "condition")) {
[16:04:44.730]                       if (!is.null(pattern)) {
[16:04:44.730]                         computeRestarts <- base::computeRestarts
[16:04:44.730]                         grepl <- base::grepl
[16:04:44.730]                         restarts <- computeRestarts(cond)
[16:04:44.730]                         for (restart in restarts) {
[16:04:44.730]                           name <- restart$name
[16:04:44.730]                           if (is.null(name)) 
[16:04:44.730]                             next
[16:04:44.730]                           if (!grepl(pattern, name)) 
[16:04:44.730]                             next
[16:04:44.730]                           invokeRestart(restart)
[16:04:44.730]                           muffled <- TRUE
[16:04:44.730]                           break
[16:04:44.730]                         }
[16:04:44.730]                       }
[16:04:44.730]                     }
[16:04:44.730]                     invisible(muffled)
[16:04:44.730]                   }
[16:04:44.730]                   muffleCondition(cond)
[16:04:44.730]                 })
[16:04:44.730]             }))
[16:04:44.730]             future::FutureResult(value = ...future.value$value, 
[16:04:44.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.730]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.730]                     ...future.globalenv.names))
[16:04:44.730]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.730]         }, condition = base::local({
[16:04:44.730]             c <- base::c
[16:04:44.730]             inherits <- base::inherits
[16:04:44.730]             invokeRestart <- base::invokeRestart
[16:04:44.730]             length <- base::length
[16:04:44.730]             list <- base::list
[16:04:44.730]             seq.int <- base::seq.int
[16:04:44.730]             signalCondition <- base::signalCondition
[16:04:44.730]             sys.calls <- base::sys.calls
[16:04:44.730]             `[[` <- base::`[[`
[16:04:44.730]             `+` <- base::`+`
[16:04:44.730]             `<<-` <- base::`<<-`
[16:04:44.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.730]                   3L)]
[16:04:44.730]             }
[16:04:44.730]             function(cond) {
[16:04:44.730]                 is_error <- inherits(cond, "error")
[16:04:44.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.730]                   NULL)
[16:04:44.730]                 if (is_error) {
[16:04:44.730]                   sessionInformation <- function() {
[16:04:44.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.730]                       search = base::search(), system = base::Sys.info())
[16:04:44.730]                   }
[16:04:44.730]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.730]                     cond$call), session = sessionInformation(), 
[16:04:44.730]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.730]                   signalCondition(cond)
[16:04:44.730]                 }
[16:04:44.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.730]                 "immediateCondition"))) {
[16:04:44.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.730]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.730]                   if (TRUE && !signal) {
[16:04:44.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.730]                     {
[16:04:44.730]                       inherits <- base::inherits
[16:04:44.730]                       invokeRestart <- base::invokeRestart
[16:04:44.730]                       is.null <- base::is.null
[16:04:44.730]                       muffled <- FALSE
[16:04:44.730]                       if (inherits(cond, "message")) {
[16:04:44.730]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.730]                         if (muffled) 
[16:04:44.730]                           invokeRestart("muffleMessage")
[16:04:44.730]                       }
[16:04:44.730]                       else if (inherits(cond, "warning")) {
[16:04:44.730]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.730]                         if (muffled) 
[16:04:44.730]                           invokeRestart("muffleWarning")
[16:04:44.730]                       }
[16:04:44.730]                       else if (inherits(cond, "condition")) {
[16:04:44.730]                         if (!is.null(pattern)) {
[16:04:44.730]                           computeRestarts <- base::computeRestarts
[16:04:44.730]                           grepl <- base::grepl
[16:04:44.730]                           restarts <- computeRestarts(cond)
[16:04:44.730]                           for (restart in restarts) {
[16:04:44.730]                             name <- restart$name
[16:04:44.730]                             if (is.null(name)) 
[16:04:44.730]                               next
[16:04:44.730]                             if (!grepl(pattern, name)) 
[16:04:44.730]                               next
[16:04:44.730]                             invokeRestart(restart)
[16:04:44.730]                             muffled <- TRUE
[16:04:44.730]                             break
[16:04:44.730]                           }
[16:04:44.730]                         }
[16:04:44.730]                       }
[16:04:44.730]                       invisible(muffled)
[16:04:44.730]                     }
[16:04:44.730]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.730]                   }
[16:04:44.730]                 }
[16:04:44.730]                 else {
[16:04:44.730]                   if (TRUE) {
[16:04:44.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.730]                     {
[16:04:44.730]                       inherits <- base::inherits
[16:04:44.730]                       invokeRestart <- base::invokeRestart
[16:04:44.730]                       is.null <- base::is.null
[16:04:44.730]                       muffled <- FALSE
[16:04:44.730]                       if (inherits(cond, "message")) {
[16:04:44.730]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.730]                         if (muffled) 
[16:04:44.730]                           invokeRestart("muffleMessage")
[16:04:44.730]                       }
[16:04:44.730]                       else if (inherits(cond, "warning")) {
[16:04:44.730]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.730]                         if (muffled) 
[16:04:44.730]                           invokeRestart("muffleWarning")
[16:04:44.730]                       }
[16:04:44.730]                       else if (inherits(cond, "condition")) {
[16:04:44.730]                         if (!is.null(pattern)) {
[16:04:44.730]                           computeRestarts <- base::computeRestarts
[16:04:44.730]                           grepl <- base::grepl
[16:04:44.730]                           restarts <- computeRestarts(cond)
[16:04:44.730]                           for (restart in restarts) {
[16:04:44.730]                             name <- restart$name
[16:04:44.730]                             if (is.null(name)) 
[16:04:44.730]                               next
[16:04:44.730]                             if (!grepl(pattern, name)) 
[16:04:44.730]                               next
[16:04:44.730]                             invokeRestart(restart)
[16:04:44.730]                             muffled <- TRUE
[16:04:44.730]                             break
[16:04:44.730]                           }
[16:04:44.730]                         }
[16:04:44.730]                       }
[16:04:44.730]                       invisible(muffled)
[16:04:44.730]                     }
[16:04:44.730]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.730]                   }
[16:04:44.730]                 }
[16:04:44.730]             }
[16:04:44.730]         }))
[16:04:44.730]     }, error = function(ex) {
[16:04:44.730]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.730]                 ...future.rng), started = ...future.startTime, 
[16:04:44.730]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.730]             version = "1.8"), class = "FutureResult")
[16:04:44.730]     }, finally = {
[16:04:44.730]         if (!identical(...future.workdir, getwd())) 
[16:04:44.730]             setwd(...future.workdir)
[16:04:44.730]         {
[16:04:44.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.730]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.730]             }
[16:04:44.730]             base::options(...future.oldOptions)
[16:04:44.730]             if (.Platform$OS.type == "windows") {
[16:04:44.730]                 old_names <- names(...future.oldEnvVars)
[16:04:44.730]                 envs <- base::Sys.getenv()
[16:04:44.730]                 names <- names(envs)
[16:04:44.730]                 common <- intersect(names, old_names)
[16:04:44.730]                 added <- setdiff(names, old_names)
[16:04:44.730]                 removed <- setdiff(old_names, names)
[16:04:44.730]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.730]                   envs[common]]
[16:04:44.730]                 NAMES <- toupper(changed)
[16:04:44.730]                 args <- list()
[16:04:44.730]                 for (kk in seq_along(NAMES)) {
[16:04:44.730]                   name <- changed[[kk]]
[16:04:44.730]                   NAME <- NAMES[[kk]]
[16:04:44.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.730]                     next
[16:04:44.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.730]                 }
[16:04:44.730]                 NAMES <- toupper(added)
[16:04:44.730]                 for (kk in seq_along(NAMES)) {
[16:04:44.730]                   name <- added[[kk]]
[16:04:44.730]                   NAME <- NAMES[[kk]]
[16:04:44.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.730]                     next
[16:04:44.730]                   args[[name]] <- ""
[16:04:44.730]                 }
[16:04:44.730]                 NAMES <- toupper(removed)
[16:04:44.730]                 for (kk in seq_along(NAMES)) {
[16:04:44.730]                   name <- removed[[kk]]
[16:04:44.730]                   NAME <- NAMES[[kk]]
[16:04:44.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.730]                     next
[16:04:44.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.730]                 }
[16:04:44.730]                 if (length(args) > 0) 
[16:04:44.730]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.730]             }
[16:04:44.730]             else {
[16:04:44.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.730]             }
[16:04:44.730]             {
[16:04:44.730]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.730]                   0L) {
[16:04:44.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.730]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.730]                   base::options(opts)
[16:04:44.730]                 }
[16:04:44.730]                 {
[16:04:44.730]                   {
[16:04:44.730]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.730]                     NULL
[16:04:44.730]                   }
[16:04:44.730]                   options(future.plan = NULL)
[16:04:44.730]                   if (is.na(NA_character_)) 
[16:04:44.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.730]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:44.730]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:44.730]                     envir = parent.frame()) 
[16:04:44.730]                   {
[16:04:44.730]                     if (is.function(workers)) 
[16:04:44.730]                       workers <- workers()
[16:04:44.730]                     workers <- structure(as.integer(workers), 
[16:04:44.730]                       class = class(workers))
[16:04:44.730]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:44.730]                       workers >= 1)
[16:04:44.730]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:44.730]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:44.730]                     }
[16:04:44.730]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:44.730]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:44.730]                       envir = envir)
[16:04:44.730]                     if (!future$lazy) 
[16:04:44.730]                       future <- run(future)
[16:04:44.730]                     invisible(future)
[16:04:44.730]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.730]                 }
[16:04:44.730]             }
[16:04:44.730]         }
[16:04:44.730]     })
[16:04:44.730]     if (TRUE) {
[16:04:44.730]         base::sink(type = "output", split = FALSE)
[16:04:44.730]         if (TRUE) {
[16:04:44.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.730]         }
[16:04:44.730]         else {
[16:04:44.730]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.730]         }
[16:04:44.730]         base::close(...future.stdout)
[16:04:44.730]         ...future.stdout <- NULL
[16:04:44.730]     }
[16:04:44.730]     ...future.result$conditions <- ...future.conditions
[16:04:44.730]     ...future.result$finished <- base::Sys.time()
[16:04:44.730]     ...future.result
[16:04:44.730] }
[16:04:44.734] Poll #1 (0): usedNodes() = 2, workers = 2
[16:04:44.744] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.745] - Validating connection of MultisessionFuture
[16:04:44.745] - received message: FutureResult
[16:04:44.745] - Received FutureResult
[16:04:44.745] - Erased future from FutureRegistry
[16:04:44.745] result() for ClusterFuture ...
[16:04:44.745] - result already collected: FutureResult
[16:04:44.745] result() for ClusterFuture ... done
[16:04:44.745] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:44.745] result() for ClusterFuture ...
[16:04:44.746] - result already collected: FutureResult
[16:04:44.746] result() for ClusterFuture ... done
[16:04:44.746] result() for ClusterFuture ...
[16:04:44.746] - result already collected: FutureResult
[16:04:44.746] result() for ClusterFuture ... done
[16:04:44.747] MultisessionFuture started
[16:04:44.747] - Launch lazy future ... done
[16:04:44.747] run() for ‘MultisessionFuture’ ... done
<environment: 0x55874e43ebb0> 
<environment: 0x55874e4a3220> 
 Named logi [1:4] TRUE TRUE FALSE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:04:44.771] resolve() on environment ...
[16:04:44.771]  recursive: 0
[16:04:44.771]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:04:44.771] signalConditionsASAP(numeric, pos=1) ...
[16:04:44.771] - nx: 4
[16:04:44.772] - relay: TRUE
[16:04:44.772] - stdout: TRUE
[16:04:44.772] - signal: TRUE
[16:04:44.772] - resignal: FALSE
[16:04:44.772] - force: TRUE
[16:04:44.772] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.772] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.772]  - until=2
[16:04:44.772]  - relaying element #2
[16:04:44.772] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:44.772] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.773] signalConditionsASAP(NULL, pos=1) ... done
[16:04:44.773]  length: 3 (resolved future 1)
[16:04:44.773] Future #2
[16:04:44.773] result() for ClusterFuture ...
[16:04:44.773] - result already collected: FutureResult
[16:04:44.773] result() for ClusterFuture ... done
[16:04:44.773] result() for ClusterFuture ...
[16:04:44.773] - result already collected: FutureResult
[16:04:44.773] result() for ClusterFuture ... done
[16:04:44.773] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:44.774] - nx: 4
[16:04:44.774] - relay: TRUE
[16:04:44.774] - stdout: TRUE
[16:04:44.774] - signal: TRUE
[16:04:44.774] - resignal: FALSE
[16:04:44.774] - force: TRUE
[16:04:44.774] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:04:44.774] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:04:44.774]  - until=2
[16:04:44.774]  - relaying element #2
[16:04:44.774] result() for ClusterFuture ...
[16:04:44.774] - result already collected: FutureResult
[16:04:44.774] result() for ClusterFuture ... done
[16:04:44.775] result() for ClusterFuture ...
[16:04:44.775] - result already collected: FutureResult
[16:04:44.775] result() for ClusterFuture ... done
[16:04:44.775] result() for ClusterFuture ...
[16:04:44.775] - result already collected: FutureResult
[16:04:44.775] result() for ClusterFuture ... done
[16:04:44.775] result() for ClusterFuture ...
[16:04:44.775] - result already collected: FutureResult
[16:04:44.775] result() for ClusterFuture ... done
[16:04:44.775] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:44.776] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:44.776] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:44.776]  length: 2 (resolved future 2)
[16:04:44.776] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.776] - Validating connection of MultisessionFuture
[16:04:44.776] - received message: FutureResult
[16:04:44.777] - Received FutureResult
[16:04:44.777] - Erased future from FutureRegistry
[16:04:44.777] result() for ClusterFuture ...
[16:04:44.777] - result already collected: FutureResult
[16:04:44.777] result() for ClusterFuture ... done
[16:04:44.777] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:44.777] Future #3
[16:04:44.777] result() for ClusterFuture ...
[16:04:44.777] - result already collected: FutureResult
[16:04:44.777] result() for ClusterFuture ... done
[16:04:44.777] result() for ClusterFuture ...
[16:04:44.778] - result already collected: FutureResult
[16:04:44.778] result() for ClusterFuture ... done
[16:04:44.778] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:44.778] - nx: 4
[16:04:44.778] - relay: TRUE
[16:04:44.778] - stdout: TRUE
[16:04:44.778] - signal: TRUE
[16:04:44.778] - resignal: FALSE
[16:04:44.778] - force: TRUE
[16:04:44.778] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:04:44.778] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:04:44.778]  - until=3
[16:04:44.779]  - relaying element #3
[16:04:44.779] result() for ClusterFuture ...
[16:04:44.779] - result already collected: FutureResult
[16:04:44.779] result() for ClusterFuture ... done
[16:04:44.779] result() for ClusterFuture ...
[16:04:44.779] - result already collected: FutureResult
[16:04:44.779] result() for ClusterFuture ... done
[16:04:44.779] result() for ClusterFuture ...
[16:04:44.779] - result already collected: FutureResult
[16:04:44.779] result() for ClusterFuture ... done
[16:04:44.779] result() for ClusterFuture ...
[16:04:44.780] - result already collected: FutureResult
[16:04:44.780] result() for ClusterFuture ... done
[16:04:44.780] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:44.780] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:44.780] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:44.780]  length: 1 (resolved future 3)
[16:04:44.801] receiveMessageFromWorker() for ClusterFuture ...
[16:04:44.801] - Validating connection of MultisessionFuture
[16:04:44.801] - received message: FutureResult
[16:04:44.801] - Received FutureResult
[16:04:44.802] - Erased future from FutureRegistry
[16:04:44.802] result() for ClusterFuture ...
[16:04:44.802] - result already collected: FutureResult
[16:04:44.802] result() for ClusterFuture ... done
[16:04:44.802] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:44.802] Future #4
[16:04:44.802] result() for ClusterFuture ...
[16:04:44.802] - result already collected: FutureResult
[16:04:44.802] result() for ClusterFuture ... done
[16:04:44.802] result() for ClusterFuture ...
[16:04:44.802] - result already collected: FutureResult
[16:04:44.803] result() for ClusterFuture ... done
[16:04:44.803] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:04:44.803] - nx: 4
[16:04:44.803] - relay: TRUE
[16:04:44.803] - stdout: TRUE
[16:04:44.803] - signal: TRUE
[16:04:44.803] - resignal: FALSE
[16:04:44.803] - force: TRUE
[16:04:44.803] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:04:44.803] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:04:44.803]  - until=4
[16:04:44.804]  - relaying element #4
[16:04:44.804] result() for ClusterFuture ...
[16:04:44.804] - result already collected: FutureResult
[16:04:44.804] result() for ClusterFuture ... done
[16:04:44.804] result() for ClusterFuture ...
[16:04:44.804] - result already collected: FutureResult
[16:04:44.804] result() for ClusterFuture ... done
[16:04:44.804] result() for ClusterFuture ...
[16:04:44.804] - result already collected: FutureResult
[16:04:44.804] result() for ClusterFuture ... done
[16:04:44.804] result() for ClusterFuture ...
[16:04:44.805] - result already collected: FutureResult
[16:04:44.805] result() for ClusterFuture ... done
[16:04:44.805] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.805] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:44.805] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:04:44.805]  length: 0 (resolved future 4)
[16:04:44.805] Relaying remaining futures
[16:04:44.805] signalConditionsASAP(NULL, pos=0) ...
[16:04:44.805] - nx: 4
[16:04:44.805] - relay: TRUE
[16:04:44.805] - stdout: TRUE
[16:04:44.805] - signal: TRUE
[16:04:44.806] - resignal: FALSE
[16:04:44.806] - force: TRUE
[16:04:44.806] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.806] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:04:44.806] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:04:44.806] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:04:44.806] signalConditionsASAP(NULL, pos=0) ... done
[16:04:44.806] resolve() on environment ... DONE
[16:04:44.806] result() for ClusterFuture ...
[16:04:44.806] - result already collected: FutureResult
[16:04:44.806] result() for ClusterFuture ... done
[16:04:44.807] result() for ClusterFuture ...
[16:04:44.807] - result already collected: FutureResult
[16:04:44.807] result() for ClusterFuture ... done
[16:04:44.807] result() for ClusterFuture ...
[16:04:44.807] - result already collected: FutureResult
[16:04:44.807] result() for ClusterFuture ... done
[16:04:44.807] result() for ClusterFuture ...
[16:04:44.807] - result already collected: FutureResult
[16:04:44.807] result() for ClusterFuture ... done
[16:04:44.807] result() for ClusterFuture ...
[16:04:44.808] - result already collected: FutureResult
[16:04:44.808] result() for ClusterFuture ... done
[16:04:44.808] result() for ClusterFuture ...
[16:04:44.808] - result already collected: FutureResult
[16:04:44.808] result() for ClusterFuture ... done
<environment: 0x55874ea0b9a0> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[16:04:44.809] plan(): Setting new future strategy stack:
[16:04:44.809] List of future strategies:
[16:04:44.809] 1. multicore:
[16:04:44.809]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:44.809]    - tweaked: FALSE
[16:04:44.809]    - call: plan(strategy)
[16:04:44.814] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:04:44.814] getGlobalsAndPackages() ...
[16:04:44.814] Searching for globals...
[16:04:44.814] 
[16:04:44.815] Searching for globals ... DONE
[16:04:44.815] - globals: [0] <none>
[16:04:44.815] getGlobalsAndPackages() ... DONE
[16:04:44.815] run() for ‘Future’ ...
[16:04:44.815] - state: ‘created’
[16:04:44.816] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.820] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.820] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:44.820]   - Field: ‘label’
[16:04:44.821]   - Field: ‘local’
[16:04:44.821]   - Field: ‘owner’
[16:04:44.821]   - Field: ‘envir’
[16:04:44.821]   - Field: ‘workers’
[16:04:44.821]   - Field: ‘packages’
[16:04:44.821]   - Field: ‘gc’
[16:04:44.821]   - Field: ‘job’
[16:04:44.821]   - Field: ‘conditions’
[16:04:44.821]   - Field: ‘expr’
[16:04:44.821]   - Field: ‘uuid’
[16:04:44.822]   - Field: ‘seed’
[16:04:44.822]   - Field: ‘version’
[16:04:44.822]   - Field: ‘result’
[16:04:44.822]   - Field: ‘asynchronous’
[16:04:44.822]   - Field: ‘calls’
[16:04:44.822]   - Field: ‘globals’
[16:04:44.822]   - Field: ‘stdout’
[16:04:44.822]   - Field: ‘earlySignal’
[16:04:44.822]   - Field: ‘lazy’
[16:04:44.822]   - Field: ‘state’
[16:04:44.822] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:44.823] - Launch lazy future ...
[16:04:44.823] Packages needed by the future expression (n = 0): <none>
[16:04:44.823] Packages needed by future strategies (n = 0): <none>
[16:04:44.823] {
[16:04:44.823]     {
[16:04:44.823]         {
[16:04:44.823]             ...future.startTime <- base::Sys.time()
[16:04:44.823]             {
[16:04:44.823]                 {
[16:04:44.823]                   {
[16:04:44.823]                     {
[16:04:44.823]                       base::local({
[16:04:44.823]                         has_future <- base::requireNamespace("future", 
[16:04:44.823]                           quietly = TRUE)
[16:04:44.823]                         if (has_future) {
[16:04:44.823]                           ns <- base::getNamespace("future")
[16:04:44.823]                           version <- ns[[".package"]][["version"]]
[16:04:44.823]                           if (is.null(version)) 
[16:04:44.823]                             version <- utils::packageVersion("future")
[16:04:44.823]                         }
[16:04:44.823]                         else {
[16:04:44.823]                           version <- NULL
[16:04:44.823]                         }
[16:04:44.823]                         if (!has_future || version < "1.8.0") {
[16:04:44.823]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.823]                             "", base::R.version$version.string), 
[16:04:44.823]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.823]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.823]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.823]                               "release", "version")], collapse = " "), 
[16:04:44.823]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.823]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.823]                             info)
[16:04:44.823]                           info <- base::paste(info, collapse = "; ")
[16:04:44.823]                           if (!has_future) {
[16:04:44.823]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.823]                               info)
[16:04:44.823]                           }
[16:04:44.823]                           else {
[16:04:44.823]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.823]                               info, version)
[16:04:44.823]                           }
[16:04:44.823]                           base::stop(msg)
[16:04:44.823]                         }
[16:04:44.823]                       })
[16:04:44.823]                     }
[16:04:44.823]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.823]                     base::options(mc.cores = 1L)
[16:04:44.823]                   }
[16:04:44.823]                   options(future.plan = NULL)
[16:04:44.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.823]                 }
[16:04:44.823]                 ...future.workdir <- getwd()
[16:04:44.823]             }
[16:04:44.823]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.823]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.823]         }
[16:04:44.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.823]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.823]             base::names(...future.oldOptions))
[16:04:44.823]     }
[16:04:44.823]     if (FALSE) {
[16:04:44.823]     }
[16:04:44.823]     else {
[16:04:44.823]         if (TRUE) {
[16:04:44.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.823]                 open = "w")
[16:04:44.823]         }
[16:04:44.823]         else {
[16:04:44.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.823]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.823]         }
[16:04:44.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.823]             base::sink(type = "output", split = FALSE)
[16:04:44.823]             base::close(...future.stdout)
[16:04:44.823]         }, add = TRUE)
[16:04:44.823]     }
[16:04:44.823]     ...future.frame <- base::sys.nframe()
[16:04:44.823]     ...future.conditions <- base::list()
[16:04:44.823]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.823]     if (FALSE) {
[16:04:44.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.823]     }
[16:04:44.823]     ...future.result <- base::tryCatch({
[16:04:44.823]         base::withCallingHandlers({
[16:04:44.823]             ...future.value <- base::withVisible(base::local({
[16:04:44.823]                 withCallingHandlers({
[16:04:44.823]                   2
[16:04:44.823]                 }, immediateCondition = function(cond) {
[16:04:44.823]                   save_rds <- function (object, pathname, ...) 
[16:04:44.823]                   {
[16:04:44.823]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:44.823]                     if (file_test("-f", pathname_tmp)) {
[16:04:44.823]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.823]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:44.823]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.823]                         fi_tmp[["mtime"]])
[16:04:44.823]                     }
[16:04:44.823]                     tryCatch({
[16:04:44.823]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:44.823]                     }, error = function(ex) {
[16:04:44.823]                       msg <- conditionMessage(ex)
[16:04:44.823]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.823]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:44.823]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.823]                         fi_tmp[["mtime"]], msg)
[16:04:44.823]                       ex$message <- msg
[16:04:44.823]                       stop(ex)
[16:04:44.823]                     })
[16:04:44.823]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:44.823]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:44.823]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:44.823]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.823]                       fi <- file.info(pathname)
[16:04:44.823]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:44.823]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.823]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:44.823]                         fi[["size"]], fi[["mtime"]])
[16:04:44.823]                       stop(msg)
[16:04:44.823]                     }
[16:04:44.823]                     invisible(pathname)
[16:04:44.823]                   }
[16:04:44.823]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:44.823]                     rootPath = tempdir()) 
[16:04:44.823]                   {
[16:04:44.823]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:44.823]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:44.823]                       tmpdir = path, fileext = ".rds")
[16:04:44.823]                     save_rds(obj, file)
[16:04:44.823]                   }
[16:04:44.823]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:44.823]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.823]                   {
[16:04:44.823]                     inherits <- base::inherits
[16:04:44.823]                     invokeRestart <- base::invokeRestart
[16:04:44.823]                     is.null <- base::is.null
[16:04:44.823]                     muffled <- FALSE
[16:04:44.823]                     if (inherits(cond, "message")) {
[16:04:44.823]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.823]                       if (muffled) 
[16:04:44.823]                         invokeRestart("muffleMessage")
[16:04:44.823]                     }
[16:04:44.823]                     else if (inherits(cond, "warning")) {
[16:04:44.823]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.823]                       if (muffled) 
[16:04:44.823]                         invokeRestart("muffleWarning")
[16:04:44.823]                     }
[16:04:44.823]                     else if (inherits(cond, "condition")) {
[16:04:44.823]                       if (!is.null(pattern)) {
[16:04:44.823]                         computeRestarts <- base::computeRestarts
[16:04:44.823]                         grepl <- base::grepl
[16:04:44.823]                         restarts <- computeRestarts(cond)
[16:04:44.823]                         for (restart in restarts) {
[16:04:44.823]                           name <- restart$name
[16:04:44.823]                           if (is.null(name)) 
[16:04:44.823]                             next
[16:04:44.823]                           if (!grepl(pattern, name)) 
[16:04:44.823]                             next
[16:04:44.823]                           invokeRestart(restart)
[16:04:44.823]                           muffled <- TRUE
[16:04:44.823]                           break
[16:04:44.823]                         }
[16:04:44.823]                       }
[16:04:44.823]                     }
[16:04:44.823]                     invisible(muffled)
[16:04:44.823]                   }
[16:04:44.823]                   muffleCondition(cond)
[16:04:44.823]                 })
[16:04:44.823]             }))
[16:04:44.823]             future::FutureResult(value = ...future.value$value, 
[16:04:44.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.823]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.823]                     ...future.globalenv.names))
[16:04:44.823]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.823]         }, condition = base::local({
[16:04:44.823]             c <- base::c
[16:04:44.823]             inherits <- base::inherits
[16:04:44.823]             invokeRestart <- base::invokeRestart
[16:04:44.823]             length <- base::length
[16:04:44.823]             list <- base::list
[16:04:44.823]             seq.int <- base::seq.int
[16:04:44.823]             signalCondition <- base::signalCondition
[16:04:44.823]             sys.calls <- base::sys.calls
[16:04:44.823]             `[[` <- base::`[[`
[16:04:44.823]             `+` <- base::`+`
[16:04:44.823]             `<<-` <- base::`<<-`
[16:04:44.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.823]                   3L)]
[16:04:44.823]             }
[16:04:44.823]             function(cond) {
[16:04:44.823]                 is_error <- inherits(cond, "error")
[16:04:44.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.823]                   NULL)
[16:04:44.823]                 if (is_error) {
[16:04:44.823]                   sessionInformation <- function() {
[16:04:44.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.823]                       search = base::search(), system = base::Sys.info())
[16:04:44.823]                   }
[16:04:44.823]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.823]                     cond$call), session = sessionInformation(), 
[16:04:44.823]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.823]                   signalCondition(cond)
[16:04:44.823]                 }
[16:04:44.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.823]                 "immediateCondition"))) {
[16:04:44.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.823]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.823]                   if (TRUE && !signal) {
[16:04:44.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.823]                     {
[16:04:44.823]                       inherits <- base::inherits
[16:04:44.823]                       invokeRestart <- base::invokeRestart
[16:04:44.823]                       is.null <- base::is.null
[16:04:44.823]                       muffled <- FALSE
[16:04:44.823]                       if (inherits(cond, "message")) {
[16:04:44.823]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.823]                         if (muffled) 
[16:04:44.823]                           invokeRestart("muffleMessage")
[16:04:44.823]                       }
[16:04:44.823]                       else if (inherits(cond, "warning")) {
[16:04:44.823]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.823]                         if (muffled) 
[16:04:44.823]                           invokeRestart("muffleWarning")
[16:04:44.823]                       }
[16:04:44.823]                       else if (inherits(cond, "condition")) {
[16:04:44.823]                         if (!is.null(pattern)) {
[16:04:44.823]                           computeRestarts <- base::computeRestarts
[16:04:44.823]                           grepl <- base::grepl
[16:04:44.823]                           restarts <- computeRestarts(cond)
[16:04:44.823]                           for (restart in restarts) {
[16:04:44.823]                             name <- restart$name
[16:04:44.823]                             if (is.null(name)) 
[16:04:44.823]                               next
[16:04:44.823]                             if (!grepl(pattern, name)) 
[16:04:44.823]                               next
[16:04:44.823]                             invokeRestart(restart)
[16:04:44.823]                             muffled <- TRUE
[16:04:44.823]                             break
[16:04:44.823]                           }
[16:04:44.823]                         }
[16:04:44.823]                       }
[16:04:44.823]                       invisible(muffled)
[16:04:44.823]                     }
[16:04:44.823]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.823]                   }
[16:04:44.823]                 }
[16:04:44.823]                 else {
[16:04:44.823]                   if (TRUE) {
[16:04:44.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.823]                     {
[16:04:44.823]                       inherits <- base::inherits
[16:04:44.823]                       invokeRestart <- base::invokeRestart
[16:04:44.823]                       is.null <- base::is.null
[16:04:44.823]                       muffled <- FALSE
[16:04:44.823]                       if (inherits(cond, "message")) {
[16:04:44.823]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.823]                         if (muffled) 
[16:04:44.823]                           invokeRestart("muffleMessage")
[16:04:44.823]                       }
[16:04:44.823]                       else if (inherits(cond, "warning")) {
[16:04:44.823]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.823]                         if (muffled) 
[16:04:44.823]                           invokeRestart("muffleWarning")
[16:04:44.823]                       }
[16:04:44.823]                       else if (inherits(cond, "condition")) {
[16:04:44.823]                         if (!is.null(pattern)) {
[16:04:44.823]                           computeRestarts <- base::computeRestarts
[16:04:44.823]                           grepl <- base::grepl
[16:04:44.823]                           restarts <- computeRestarts(cond)
[16:04:44.823]                           for (restart in restarts) {
[16:04:44.823]                             name <- restart$name
[16:04:44.823]                             if (is.null(name)) 
[16:04:44.823]                               next
[16:04:44.823]                             if (!grepl(pattern, name)) 
[16:04:44.823]                               next
[16:04:44.823]                             invokeRestart(restart)
[16:04:44.823]                             muffled <- TRUE
[16:04:44.823]                             break
[16:04:44.823]                           }
[16:04:44.823]                         }
[16:04:44.823]                       }
[16:04:44.823]                       invisible(muffled)
[16:04:44.823]                     }
[16:04:44.823]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.823]                   }
[16:04:44.823]                 }
[16:04:44.823]             }
[16:04:44.823]         }))
[16:04:44.823]     }, error = function(ex) {
[16:04:44.823]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.823]                 ...future.rng), started = ...future.startTime, 
[16:04:44.823]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.823]             version = "1.8"), class = "FutureResult")
[16:04:44.823]     }, finally = {
[16:04:44.823]         if (!identical(...future.workdir, getwd())) 
[16:04:44.823]             setwd(...future.workdir)
[16:04:44.823]         {
[16:04:44.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.823]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.823]             }
[16:04:44.823]             base::options(...future.oldOptions)
[16:04:44.823]             if (.Platform$OS.type == "windows") {
[16:04:44.823]                 old_names <- names(...future.oldEnvVars)
[16:04:44.823]                 envs <- base::Sys.getenv()
[16:04:44.823]                 names <- names(envs)
[16:04:44.823]                 common <- intersect(names, old_names)
[16:04:44.823]                 added <- setdiff(names, old_names)
[16:04:44.823]                 removed <- setdiff(old_names, names)
[16:04:44.823]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.823]                   envs[common]]
[16:04:44.823]                 NAMES <- toupper(changed)
[16:04:44.823]                 args <- list()
[16:04:44.823]                 for (kk in seq_along(NAMES)) {
[16:04:44.823]                   name <- changed[[kk]]
[16:04:44.823]                   NAME <- NAMES[[kk]]
[16:04:44.823]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.823]                     next
[16:04:44.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.823]                 }
[16:04:44.823]                 NAMES <- toupper(added)
[16:04:44.823]                 for (kk in seq_along(NAMES)) {
[16:04:44.823]                   name <- added[[kk]]
[16:04:44.823]                   NAME <- NAMES[[kk]]
[16:04:44.823]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.823]                     next
[16:04:44.823]                   args[[name]] <- ""
[16:04:44.823]                 }
[16:04:44.823]                 NAMES <- toupper(removed)
[16:04:44.823]                 for (kk in seq_along(NAMES)) {
[16:04:44.823]                   name <- removed[[kk]]
[16:04:44.823]                   NAME <- NAMES[[kk]]
[16:04:44.823]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.823]                     next
[16:04:44.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.823]                 }
[16:04:44.823]                 if (length(args) > 0) 
[16:04:44.823]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.823]             }
[16:04:44.823]             else {
[16:04:44.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.823]             }
[16:04:44.823]             {
[16:04:44.823]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.823]                   0L) {
[16:04:44.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.823]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.823]                   base::options(opts)
[16:04:44.823]                 }
[16:04:44.823]                 {
[16:04:44.823]                   {
[16:04:44.823]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.823]                     NULL
[16:04:44.823]                   }
[16:04:44.823]                   options(future.plan = NULL)
[16:04:44.823]                   if (is.na(NA_character_)) 
[16:04:44.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.823]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:44.823]                     envir = parent.frame()) 
[16:04:44.823]                   {
[16:04:44.823]                     default_workers <- missing(workers)
[16:04:44.823]                     if (is.function(workers)) 
[16:04:44.823]                       workers <- workers()
[16:04:44.823]                     workers <- structure(as.integer(workers), 
[16:04:44.823]                       class = class(workers))
[16:04:44.823]                     stop_if_not(is.finite(workers), workers >= 
[16:04:44.823]                       1L)
[16:04:44.823]                     if ((workers == 1L && !inherits(workers, 
[16:04:44.823]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:44.823]                       if (default_workers) 
[16:04:44.823]                         supportsMulticore(warn = TRUE)
[16:04:44.823]                       return(sequential(..., envir = envir))
[16:04:44.823]                     }
[16:04:44.823]                     oopts <- options(mc.cores = workers)
[16:04:44.823]                     on.exit(options(oopts))
[16:04:44.823]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:44.823]                       envir = envir)
[16:04:44.823]                     if (!future$lazy) 
[16:04:44.823]                       future <- run(future)
[16:04:44.823]                     invisible(future)
[16:04:44.823]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.823]                 }
[16:04:44.823]             }
[16:04:44.823]         }
[16:04:44.823]     })
[16:04:44.823]     if (TRUE) {
[16:04:44.823]         base::sink(type = "output", split = FALSE)
[16:04:44.823]         if (TRUE) {
[16:04:44.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.823]         }
[16:04:44.823]         else {
[16:04:44.823]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.823]         }
[16:04:44.823]         base::close(...future.stdout)
[16:04:44.823]         ...future.stdout <- NULL
[16:04:44.823]     }
[16:04:44.823]     ...future.result$conditions <- ...future.conditions
[16:04:44.823]     ...future.result$finished <- base::Sys.time()
[16:04:44.823]     ...future.result
[16:04:44.823] }
[16:04:44.826] requestCore(): workers = 2
[16:04:44.828] MulticoreFuture started
[16:04:44.829] - Launch lazy future ... done
[16:04:44.829] run() for ‘MulticoreFuture’ ... done
[16:04:44.829] getGlobalsAndPackages() ...
[16:04:44.829] Searching for globals...
[16:04:44.829] plan(): Setting new future strategy stack:
[16:04:44.830] List of future strategies:
[16:04:44.830] 1. sequential:
[16:04:44.830]    - args: function (..., envir = parent.frame())
[16:04:44.830]    - tweaked: FALSE
[16:04:44.830]    - call: NULL
[16:04:44.830] 
[16:04:44.830] Searching for globals ... DONE
[16:04:44.830] plan(): nbrOfWorkers() = 1
[16:04:44.831] - globals: [0] <none>
[16:04:44.831] getGlobalsAndPackages() ... DONE
[16:04:44.831] run() for ‘Future’ ...
[16:04:44.831] - state: ‘created’
[16:04:44.832] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.832] plan(): Setting new future strategy stack:
[16:04:44.832] List of future strategies:
[16:04:44.832] 1. multicore:
[16:04:44.832]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:44.832]    - tweaked: FALSE
[16:04:44.832]    - call: plan(strategy)
[16:04:44.837] plan(): nbrOfWorkers() = 2
[16:04:44.838] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.838] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:44.838]   - Field: ‘label’
[16:04:44.838]   - Field: ‘local’
[16:04:44.838]   - Field: ‘owner’
[16:04:44.838]   - Field: ‘envir’
[16:04:44.839]   - Field: ‘workers’
[16:04:44.839]   - Field: ‘packages’
[16:04:44.839]   - Field: ‘gc’
[16:04:44.839]   - Field: ‘job’
[16:04:44.839]   - Field: ‘conditions’
[16:04:44.839]   - Field: ‘expr’
[16:04:44.840]   - Field: ‘uuid’
[16:04:44.840]   - Field: ‘seed’
[16:04:44.840]   - Field: ‘version’
[16:04:44.840]   - Field: ‘result’
[16:04:44.840]   - Field: ‘asynchronous’
[16:04:44.840]   - Field: ‘calls’
[16:04:44.840]   - Field: ‘globals’
[16:04:44.840]   - Field: ‘stdout’
[16:04:44.841]   - Field: ‘earlySignal’
[16:04:44.841]   - Field: ‘lazy’
[16:04:44.841]   - Field: ‘state’
[16:04:44.841] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:44.841] - Launch lazy future ...
[16:04:44.842] Packages needed by the future expression (n = 0): <none>
[16:04:44.842] Packages needed by future strategies (n = 0): <none>
[16:04:44.843] {
[16:04:44.843]     {
[16:04:44.843]         {
[16:04:44.843]             ...future.startTime <- base::Sys.time()
[16:04:44.843]             {
[16:04:44.843]                 {
[16:04:44.843]                   {
[16:04:44.843]                     {
[16:04:44.843]                       base::local({
[16:04:44.843]                         has_future <- base::requireNamespace("future", 
[16:04:44.843]                           quietly = TRUE)
[16:04:44.843]                         if (has_future) {
[16:04:44.843]                           ns <- base::getNamespace("future")
[16:04:44.843]                           version <- ns[[".package"]][["version"]]
[16:04:44.843]                           if (is.null(version)) 
[16:04:44.843]                             version <- utils::packageVersion("future")
[16:04:44.843]                         }
[16:04:44.843]                         else {
[16:04:44.843]                           version <- NULL
[16:04:44.843]                         }
[16:04:44.843]                         if (!has_future || version < "1.8.0") {
[16:04:44.843]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.843]                             "", base::R.version$version.string), 
[16:04:44.843]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.843]                               "release", "version")], collapse = " "), 
[16:04:44.843]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.843]                             info)
[16:04:44.843]                           info <- base::paste(info, collapse = "; ")
[16:04:44.843]                           if (!has_future) {
[16:04:44.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.843]                               info)
[16:04:44.843]                           }
[16:04:44.843]                           else {
[16:04:44.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.843]                               info, version)
[16:04:44.843]                           }
[16:04:44.843]                           base::stop(msg)
[16:04:44.843]                         }
[16:04:44.843]                       })
[16:04:44.843]                     }
[16:04:44.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.843]                     base::options(mc.cores = 1L)
[16:04:44.843]                   }
[16:04:44.843]                   options(future.plan = NULL)
[16:04:44.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.843]                 }
[16:04:44.843]                 ...future.workdir <- getwd()
[16:04:44.843]             }
[16:04:44.843]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.843]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.843]         }
[16:04:44.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.843]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.843]             base::names(...future.oldOptions))
[16:04:44.843]     }
[16:04:44.843]     if (FALSE) {
[16:04:44.843]     }
[16:04:44.843]     else {
[16:04:44.843]         if (TRUE) {
[16:04:44.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.843]                 open = "w")
[16:04:44.843]         }
[16:04:44.843]         else {
[16:04:44.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.843]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.843]         }
[16:04:44.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.843]             base::sink(type = "output", split = FALSE)
[16:04:44.843]             base::close(...future.stdout)
[16:04:44.843]         }, add = TRUE)
[16:04:44.843]     }
[16:04:44.843]     ...future.frame <- base::sys.nframe()
[16:04:44.843]     ...future.conditions <- base::list()
[16:04:44.843]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.843]     if (FALSE) {
[16:04:44.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.843]     }
[16:04:44.843]     ...future.result <- base::tryCatch({
[16:04:44.843]         base::withCallingHandlers({
[16:04:44.843]             ...future.value <- base::withVisible(base::local({
[16:04:44.843]                 withCallingHandlers({
[16:04:44.843]                   NULL
[16:04:44.843]                 }, immediateCondition = function(cond) {
[16:04:44.843]                   save_rds <- function (object, pathname, ...) 
[16:04:44.843]                   {
[16:04:44.843]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:44.843]                     if (file_test("-f", pathname_tmp)) {
[16:04:44.843]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.843]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:44.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.843]                         fi_tmp[["mtime"]])
[16:04:44.843]                     }
[16:04:44.843]                     tryCatch({
[16:04:44.843]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:44.843]                     }, error = function(ex) {
[16:04:44.843]                       msg <- conditionMessage(ex)
[16:04:44.843]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.843]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:44.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.843]                         fi_tmp[["mtime"]], msg)
[16:04:44.843]                       ex$message <- msg
[16:04:44.843]                       stop(ex)
[16:04:44.843]                     })
[16:04:44.843]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:44.843]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:44.843]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:44.843]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.843]                       fi <- file.info(pathname)
[16:04:44.843]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:44.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.843]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:44.843]                         fi[["size"]], fi[["mtime"]])
[16:04:44.843]                       stop(msg)
[16:04:44.843]                     }
[16:04:44.843]                     invisible(pathname)
[16:04:44.843]                   }
[16:04:44.843]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:44.843]                     rootPath = tempdir()) 
[16:04:44.843]                   {
[16:04:44.843]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:44.843]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:44.843]                       tmpdir = path, fileext = ".rds")
[16:04:44.843]                     save_rds(obj, file)
[16:04:44.843]                   }
[16:04:44.843]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:44.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.843]                   {
[16:04:44.843]                     inherits <- base::inherits
[16:04:44.843]                     invokeRestart <- base::invokeRestart
[16:04:44.843]                     is.null <- base::is.null
[16:04:44.843]                     muffled <- FALSE
[16:04:44.843]                     if (inherits(cond, "message")) {
[16:04:44.843]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.843]                       if (muffled) 
[16:04:44.843]                         invokeRestart("muffleMessage")
[16:04:44.843]                     }
[16:04:44.843]                     else if (inherits(cond, "warning")) {
[16:04:44.843]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.843]                       if (muffled) 
[16:04:44.843]                         invokeRestart("muffleWarning")
[16:04:44.843]                     }
[16:04:44.843]                     else if (inherits(cond, "condition")) {
[16:04:44.843]                       if (!is.null(pattern)) {
[16:04:44.843]                         computeRestarts <- base::computeRestarts
[16:04:44.843]                         grepl <- base::grepl
[16:04:44.843]                         restarts <- computeRestarts(cond)
[16:04:44.843]                         for (restart in restarts) {
[16:04:44.843]                           name <- restart$name
[16:04:44.843]                           if (is.null(name)) 
[16:04:44.843]                             next
[16:04:44.843]                           if (!grepl(pattern, name)) 
[16:04:44.843]                             next
[16:04:44.843]                           invokeRestart(restart)
[16:04:44.843]                           muffled <- TRUE
[16:04:44.843]                           break
[16:04:44.843]                         }
[16:04:44.843]                       }
[16:04:44.843]                     }
[16:04:44.843]                     invisible(muffled)
[16:04:44.843]                   }
[16:04:44.843]                   muffleCondition(cond)
[16:04:44.843]                 })
[16:04:44.843]             }))
[16:04:44.843]             future::FutureResult(value = ...future.value$value, 
[16:04:44.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.843]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.843]                     ...future.globalenv.names))
[16:04:44.843]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.843]         }, condition = base::local({
[16:04:44.843]             c <- base::c
[16:04:44.843]             inherits <- base::inherits
[16:04:44.843]             invokeRestart <- base::invokeRestart
[16:04:44.843]             length <- base::length
[16:04:44.843]             list <- base::list
[16:04:44.843]             seq.int <- base::seq.int
[16:04:44.843]             signalCondition <- base::signalCondition
[16:04:44.843]             sys.calls <- base::sys.calls
[16:04:44.843]             `[[` <- base::`[[`
[16:04:44.843]             `+` <- base::`+`
[16:04:44.843]             `<<-` <- base::`<<-`
[16:04:44.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.843]                   3L)]
[16:04:44.843]             }
[16:04:44.843]             function(cond) {
[16:04:44.843]                 is_error <- inherits(cond, "error")
[16:04:44.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.843]                   NULL)
[16:04:44.843]                 if (is_error) {
[16:04:44.843]                   sessionInformation <- function() {
[16:04:44.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.843]                       search = base::search(), system = base::Sys.info())
[16:04:44.843]                   }
[16:04:44.843]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.843]                     cond$call), session = sessionInformation(), 
[16:04:44.843]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.843]                   signalCondition(cond)
[16:04:44.843]                 }
[16:04:44.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.843]                 "immediateCondition"))) {
[16:04:44.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.843]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.843]                   if (TRUE && !signal) {
[16:04:44.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.843]                     {
[16:04:44.843]                       inherits <- base::inherits
[16:04:44.843]                       invokeRestart <- base::invokeRestart
[16:04:44.843]                       is.null <- base::is.null
[16:04:44.843]                       muffled <- FALSE
[16:04:44.843]                       if (inherits(cond, "message")) {
[16:04:44.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.843]                         if (muffled) 
[16:04:44.843]                           invokeRestart("muffleMessage")
[16:04:44.843]                       }
[16:04:44.843]                       else if (inherits(cond, "warning")) {
[16:04:44.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.843]                         if (muffled) 
[16:04:44.843]                           invokeRestart("muffleWarning")
[16:04:44.843]                       }
[16:04:44.843]                       else if (inherits(cond, "condition")) {
[16:04:44.843]                         if (!is.null(pattern)) {
[16:04:44.843]                           computeRestarts <- base::computeRestarts
[16:04:44.843]                           grepl <- base::grepl
[16:04:44.843]                           restarts <- computeRestarts(cond)
[16:04:44.843]                           for (restart in restarts) {
[16:04:44.843]                             name <- restart$name
[16:04:44.843]                             if (is.null(name)) 
[16:04:44.843]                               next
[16:04:44.843]                             if (!grepl(pattern, name)) 
[16:04:44.843]                               next
[16:04:44.843]                             invokeRestart(restart)
[16:04:44.843]                             muffled <- TRUE
[16:04:44.843]                             break
[16:04:44.843]                           }
[16:04:44.843]                         }
[16:04:44.843]                       }
[16:04:44.843]                       invisible(muffled)
[16:04:44.843]                     }
[16:04:44.843]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.843]                   }
[16:04:44.843]                 }
[16:04:44.843]                 else {
[16:04:44.843]                   if (TRUE) {
[16:04:44.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.843]                     {
[16:04:44.843]                       inherits <- base::inherits
[16:04:44.843]                       invokeRestart <- base::invokeRestart
[16:04:44.843]                       is.null <- base::is.null
[16:04:44.843]                       muffled <- FALSE
[16:04:44.843]                       if (inherits(cond, "message")) {
[16:04:44.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.843]                         if (muffled) 
[16:04:44.843]                           invokeRestart("muffleMessage")
[16:04:44.843]                       }
[16:04:44.843]                       else if (inherits(cond, "warning")) {
[16:04:44.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.843]                         if (muffled) 
[16:04:44.843]                           invokeRestart("muffleWarning")
[16:04:44.843]                       }
[16:04:44.843]                       else if (inherits(cond, "condition")) {
[16:04:44.843]                         if (!is.null(pattern)) {
[16:04:44.843]                           computeRestarts <- base::computeRestarts
[16:04:44.843]                           grepl <- base::grepl
[16:04:44.843]                           restarts <- computeRestarts(cond)
[16:04:44.843]                           for (restart in restarts) {
[16:04:44.843]                             name <- restart$name
[16:04:44.843]                             if (is.null(name)) 
[16:04:44.843]                               next
[16:04:44.843]                             if (!grepl(pattern, name)) 
[16:04:44.843]                               next
[16:04:44.843]                             invokeRestart(restart)
[16:04:44.843]                             muffled <- TRUE
[16:04:44.843]                             break
[16:04:44.843]                           }
[16:04:44.843]                         }
[16:04:44.843]                       }
[16:04:44.843]                       invisible(muffled)
[16:04:44.843]                     }
[16:04:44.843]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.843]                   }
[16:04:44.843]                 }
[16:04:44.843]             }
[16:04:44.843]         }))
[16:04:44.843]     }, error = function(ex) {
[16:04:44.843]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.843]                 ...future.rng), started = ...future.startTime, 
[16:04:44.843]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.843]             version = "1.8"), class = "FutureResult")
[16:04:44.843]     }, finally = {
[16:04:44.843]         if (!identical(...future.workdir, getwd())) 
[16:04:44.843]             setwd(...future.workdir)
[16:04:44.843]         {
[16:04:44.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.843]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.843]             }
[16:04:44.843]             base::options(...future.oldOptions)
[16:04:44.843]             if (.Platform$OS.type == "windows") {
[16:04:44.843]                 old_names <- names(...future.oldEnvVars)
[16:04:44.843]                 envs <- base::Sys.getenv()
[16:04:44.843]                 names <- names(envs)
[16:04:44.843]                 common <- intersect(names, old_names)
[16:04:44.843]                 added <- setdiff(names, old_names)
[16:04:44.843]                 removed <- setdiff(old_names, names)
[16:04:44.843]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.843]                   envs[common]]
[16:04:44.843]                 NAMES <- toupper(changed)
[16:04:44.843]                 args <- list()
[16:04:44.843]                 for (kk in seq_along(NAMES)) {
[16:04:44.843]                   name <- changed[[kk]]
[16:04:44.843]                   NAME <- NAMES[[kk]]
[16:04:44.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.843]                     next
[16:04:44.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.843]                 }
[16:04:44.843]                 NAMES <- toupper(added)
[16:04:44.843]                 for (kk in seq_along(NAMES)) {
[16:04:44.843]                   name <- added[[kk]]
[16:04:44.843]                   NAME <- NAMES[[kk]]
[16:04:44.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.843]                     next
[16:04:44.843]                   args[[name]] <- ""
[16:04:44.843]                 }
[16:04:44.843]                 NAMES <- toupper(removed)
[16:04:44.843]                 for (kk in seq_along(NAMES)) {
[16:04:44.843]                   name <- removed[[kk]]
[16:04:44.843]                   NAME <- NAMES[[kk]]
[16:04:44.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.843]                     next
[16:04:44.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.843]                 }
[16:04:44.843]                 if (length(args) > 0) 
[16:04:44.843]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.843]             }
[16:04:44.843]             else {
[16:04:44.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.843]             }
[16:04:44.843]             {
[16:04:44.843]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.843]                   0L) {
[16:04:44.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.843]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.843]                   base::options(opts)
[16:04:44.843]                 }
[16:04:44.843]                 {
[16:04:44.843]                   {
[16:04:44.843]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.843]                     NULL
[16:04:44.843]                   }
[16:04:44.843]                   options(future.plan = NULL)
[16:04:44.843]                   if (is.na(NA_character_)) 
[16:04:44.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.843]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:44.843]                     envir = parent.frame()) 
[16:04:44.843]                   {
[16:04:44.843]                     default_workers <- missing(workers)
[16:04:44.843]                     if (is.function(workers)) 
[16:04:44.843]                       workers <- workers()
[16:04:44.843]                     workers <- structure(as.integer(workers), 
[16:04:44.843]                       class = class(workers))
[16:04:44.843]                     stop_if_not(is.finite(workers), workers >= 
[16:04:44.843]                       1L)
[16:04:44.843]                     if ((workers == 1L && !inherits(workers, 
[16:04:44.843]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:44.843]                       if (default_workers) 
[16:04:44.843]                         supportsMulticore(warn = TRUE)
[16:04:44.843]                       return(sequential(..., envir = envir))
[16:04:44.843]                     }
[16:04:44.843]                     oopts <- options(mc.cores = workers)
[16:04:44.843]                     on.exit(options(oopts))
[16:04:44.843]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:44.843]                       envir = envir)
[16:04:44.843]                     if (!future$lazy) 
[16:04:44.843]                       future <- run(future)
[16:04:44.843]                     invisible(future)
[16:04:44.843]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.843]                 }
[16:04:44.843]             }
[16:04:44.843]         }
[16:04:44.843]     })
[16:04:44.843]     if (TRUE) {
[16:04:44.843]         base::sink(type = "output", split = FALSE)
[16:04:44.843]         if (TRUE) {
[16:04:44.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.843]         }
[16:04:44.843]         else {
[16:04:44.843]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.843]         }
[16:04:44.843]         base::close(...future.stdout)
[16:04:44.843]         ...future.stdout <- NULL
[16:04:44.843]     }
[16:04:44.843]     ...future.result$conditions <- ...future.conditions
[16:04:44.843]     ...future.result$finished <- base::Sys.time()
[16:04:44.843]     ...future.result
[16:04:44.843] }
[16:04:44.846] requestCore(): workers = 2
[16:04:44.849] MulticoreFuture started
[16:04:44.849] - Launch lazy future ... done
[16:04:44.849] run() for ‘MulticoreFuture’ ... done
[16:04:44.850] plan(): Setting new future strategy stack:
[16:04:44.850] getGlobalsAndPackages() ...
[16:04:44.851] Searching for globals...
[16:04:44.850] List of future strategies:
[16:04:44.850] 1. sequential:
[16:04:44.850]    - args: function (..., envir = parent.frame())
[16:04:44.850]    - tweaked: FALSE
[16:04:44.850]    - call: NULL
[16:04:44.851] plan(): nbrOfWorkers() = 1
[16:04:44.852] - globals found: [1] ‘{’
[16:04:44.852] Searching for globals ... DONE
[16:04:44.852] Resolving globals: FALSE
[16:04:44.853] 
[16:04:44.853] 
[16:04:44.853] plan(): Setting new future strategy stack:
[16:04:44.853] getGlobalsAndPackages() ... DONE
[16:04:44.853] List of future strategies:
[16:04:44.853] 1. multicore:
[16:04:44.853]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:44.853]    - tweaked: FALSE
[16:04:44.853]    - call: plan(strategy)
[16:04:44.854] run() for ‘Future’ ...
[16:04:44.861] - state: ‘created’
[16:04:44.862] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.866] plan(): nbrOfWorkers() = 2
[16:04:44.869] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.869] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:44.869]   - Field: ‘label’
[16:04:44.869]   - Field: ‘local’
[16:04:44.869]   - Field: ‘owner’
[16:04:44.870]   - Field: ‘envir’
[16:04:44.870]   - Field: ‘workers’
[16:04:44.870]   - Field: ‘packages’
[16:04:44.870]   - Field: ‘gc’
[16:04:44.870]   - Field: ‘job’
[16:04:44.870]   - Field: ‘conditions’
[16:04:44.870]   - Field: ‘expr’
[16:04:44.871]   - Field: ‘uuid’
[16:04:44.871]   - Field: ‘seed’
[16:04:44.871]   - Field: ‘version’
[16:04:44.871]   - Field: ‘result’
[16:04:44.871]   - Field: ‘asynchronous’
[16:04:44.871]   - Field: ‘calls’
[16:04:44.872]   - Field: ‘globals’
[16:04:44.872]   - Field: ‘stdout’
[16:04:44.872]   - Field: ‘earlySignal’
[16:04:44.872]   - Field: ‘lazy’
[16:04:44.872]   - Field: ‘state’
[16:04:44.872] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:44.872] - Launch lazy future ...
[16:04:44.873] Packages needed by the future expression (n = 0): <none>
[16:04:44.873] Packages needed by future strategies (n = 0): <none>
[16:04:44.874] {
[16:04:44.874]     {
[16:04:44.874]         {
[16:04:44.874]             ...future.startTime <- base::Sys.time()
[16:04:44.874]             {
[16:04:44.874]                 {
[16:04:44.874]                   {
[16:04:44.874]                     {
[16:04:44.874]                       base::local({
[16:04:44.874]                         has_future <- base::requireNamespace("future", 
[16:04:44.874]                           quietly = TRUE)
[16:04:44.874]                         if (has_future) {
[16:04:44.874]                           ns <- base::getNamespace("future")
[16:04:44.874]                           version <- ns[[".package"]][["version"]]
[16:04:44.874]                           if (is.null(version)) 
[16:04:44.874]                             version <- utils::packageVersion("future")
[16:04:44.874]                         }
[16:04:44.874]                         else {
[16:04:44.874]                           version <- NULL
[16:04:44.874]                         }
[16:04:44.874]                         if (!has_future || version < "1.8.0") {
[16:04:44.874]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.874]                             "", base::R.version$version.string), 
[16:04:44.874]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.874]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.874]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.874]                               "release", "version")], collapse = " "), 
[16:04:44.874]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.874]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.874]                             info)
[16:04:44.874]                           info <- base::paste(info, collapse = "; ")
[16:04:44.874]                           if (!has_future) {
[16:04:44.874]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.874]                               info)
[16:04:44.874]                           }
[16:04:44.874]                           else {
[16:04:44.874]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.874]                               info, version)
[16:04:44.874]                           }
[16:04:44.874]                           base::stop(msg)
[16:04:44.874]                         }
[16:04:44.874]                       })
[16:04:44.874]                     }
[16:04:44.874]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.874]                     base::options(mc.cores = 1L)
[16:04:44.874]                   }
[16:04:44.874]                   options(future.plan = NULL)
[16:04:44.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.874]                 }
[16:04:44.874]                 ...future.workdir <- getwd()
[16:04:44.874]             }
[16:04:44.874]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.874]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.874]         }
[16:04:44.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.874]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.874]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.874]             base::names(...future.oldOptions))
[16:04:44.874]     }
[16:04:44.874]     if (FALSE) {
[16:04:44.874]     }
[16:04:44.874]     else {
[16:04:44.874]         if (TRUE) {
[16:04:44.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.874]                 open = "w")
[16:04:44.874]         }
[16:04:44.874]         else {
[16:04:44.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.874]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.874]         }
[16:04:44.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.874]             base::sink(type = "output", split = FALSE)
[16:04:44.874]             base::close(...future.stdout)
[16:04:44.874]         }, add = TRUE)
[16:04:44.874]     }
[16:04:44.874]     ...future.frame <- base::sys.nframe()
[16:04:44.874]     ...future.conditions <- base::list()
[16:04:44.874]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.874]     if (FALSE) {
[16:04:44.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.874]     }
[16:04:44.874]     ...future.result <- base::tryCatch({
[16:04:44.874]         base::withCallingHandlers({
[16:04:44.874]             ...future.value <- base::withVisible(base::local({
[16:04:44.874]                 withCallingHandlers({
[16:04:44.874]                   {
[16:04:44.874]                     4
[16:04:44.874]                   }
[16:04:44.874]                 }, immediateCondition = function(cond) {
[16:04:44.874]                   save_rds <- function (object, pathname, ...) 
[16:04:44.874]                   {
[16:04:44.874]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:44.874]                     if (file_test("-f", pathname_tmp)) {
[16:04:44.874]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.874]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:44.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.874]                         fi_tmp[["mtime"]])
[16:04:44.874]                     }
[16:04:44.874]                     tryCatch({
[16:04:44.874]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:44.874]                     }, error = function(ex) {
[16:04:44.874]                       msg <- conditionMessage(ex)
[16:04:44.874]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.874]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:44.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.874]                         fi_tmp[["mtime"]], msg)
[16:04:44.874]                       ex$message <- msg
[16:04:44.874]                       stop(ex)
[16:04:44.874]                     })
[16:04:44.874]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:44.874]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:44.874]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:44.874]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.874]                       fi <- file.info(pathname)
[16:04:44.874]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:44.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.874]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:44.874]                         fi[["size"]], fi[["mtime"]])
[16:04:44.874]                       stop(msg)
[16:04:44.874]                     }
[16:04:44.874]                     invisible(pathname)
[16:04:44.874]                   }
[16:04:44.874]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:44.874]                     rootPath = tempdir()) 
[16:04:44.874]                   {
[16:04:44.874]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:44.874]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:44.874]                       tmpdir = path, fileext = ".rds")
[16:04:44.874]                     save_rds(obj, file)
[16:04:44.874]                   }
[16:04:44.874]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:44.874]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.874]                   {
[16:04:44.874]                     inherits <- base::inherits
[16:04:44.874]                     invokeRestart <- base::invokeRestart
[16:04:44.874]                     is.null <- base::is.null
[16:04:44.874]                     muffled <- FALSE
[16:04:44.874]                     if (inherits(cond, "message")) {
[16:04:44.874]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.874]                       if (muffled) 
[16:04:44.874]                         invokeRestart("muffleMessage")
[16:04:44.874]                     }
[16:04:44.874]                     else if (inherits(cond, "warning")) {
[16:04:44.874]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.874]                       if (muffled) 
[16:04:44.874]                         invokeRestart("muffleWarning")
[16:04:44.874]                     }
[16:04:44.874]                     else if (inherits(cond, "condition")) {
[16:04:44.874]                       if (!is.null(pattern)) {
[16:04:44.874]                         computeRestarts <- base::computeRestarts
[16:04:44.874]                         grepl <- base::grepl
[16:04:44.874]                         restarts <- computeRestarts(cond)
[16:04:44.874]                         for (restart in restarts) {
[16:04:44.874]                           name <- restart$name
[16:04:44.874]                           if (is.null(name)) 
[16:04:44.874]                             next
[16:04:44.874]                           if (!grepl(pattern, name)) 
[16:04:44.874]                             next
[16:04:44.874]                           invokeRestart(restart)
[16:04:44.874]                           muffled <- TRUE
[16:04:44.874]                           break
[16:04:44.874]                         }
[16:04:44.874]                       }
[16:04:44.874]                     }
[16:04:44.874]                     invisible(muffled)
[16:04:44.874]                   }
[16:04:44.874]                   muffleCondition(cond)
[16:04:44.874]                 })
[16:04:44.874]             }))
[16:04:44.874]             future::FutureResult(value = ...future.value$value, 
[16:04:44.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.874]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.874]                     ...future.globalenv.names))
[16:04:44.874]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.874]         }, condition = base::local({
[16:04:44.874]             c <- base::c
[16:04:44.874]             inherits <- base::inherits
[16:04:44.874]             invokeRestart <- base::invokeRestart
[16:04:44.874]             length <- base::length
[16:04:44.874]             list <- base::list
[16:04:44.874]             seq.int <- base::seq.int
[16:04:44.874]             signalCondition <- base::signalCondition
[16:04:44.874]             sys.calls <- base::sys.calls
[16:04:44.874]             `[[` <- base::`[[`
[16:04:44.874]             `+` <- base::`+`
[16:04:44.874]             `<<-` <- base::`<<-`
[16:04:44.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.874]                   3L)]
[16:04:44.874]             }
[16:04:44.874]             function(cond) {
[16:04:44.874]                 is_error <- inherits(cond, "error")
[16:04:44.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.874]                   NULL)
[16:04:44.874]                 if (is_error) {
[16:04:44.874]                   sessionInformation <- function() {
[16:04:44.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.874]                       search = base::search(), system = base::Sys.info())
[16:04:44.874]                   }
[16:04:44.874]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.874]                     cond$call), session = sessionInformation(), 
[16:04:44.874]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.874]                   signalCondition(cond)
[16:04:44.874]                 }
[16:04:44.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.874]                 "immediateCondition"))) {
[16:04:44.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.874]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.874]                   if (TRUE && !signal) {
[16:04:44.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.874]                     {
[16:04:44.874]                       inherits <- base::inherits
[16:04:44.874]                       invokeRestart <- base::invokeRestart
[16:04:44.874]                       is.null <- base::is.null
[16:04:44.874]                       muffled <- FALSE
[16:04:44.874]                       if (inherits(cond, "message")) {
[16:04:44.874]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.874]                         if (muffled) 
[16:04:44.874]                           invokeRestart("muffleMessage")
[16:04:44.874]                       }
[16:04:44.874]                       else if (inherits(cond, "warning")) {
[16:04:44.874]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.874]                         if (muffled) 
[16:04:44.874]                           invokeRestart("muffleWarning")
[16:04:44.874]                       }
[16:04:44.874]                       else if (inherits(cond, "condition")) {
[16:04:44.874]                         if (!is.null(pattern)) {
[16:04:44.874]                           computeRestarts <- base::computeRestarts
[16:04:44.874]                           grepl <- base::grepl
[16:04:44.874]                           restarts <- computeRestarts(cond)
[16:04:44.874]                           for (restart in restarts) {
[16:04:44.874]                             name <- restart$name
[16:04:44.874]                             if (is.null(name)) 
[16:04:44.874]                               next
[16:04:44.874]                             if (!grepl(pattern, name)) 
[16:04:44.874]                               next
[16:04:44.874]                             invokeRestart(restart)
[16:04:44.874]                             muffled <- TRUE
[16:04:44.874]                             break
[16:04:44.874]                           }
[16:04:44.874]                         }
[16:04:44.874]                       }
[16:04:44.874]                       invisible(muffled)
[16:04:44.874]                     }
[16:04:44.874]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.874]                   }
[16:04:44.874]                 }
[16:04:44.874]                 else {
[16:04:44.874]                   if (TRUE) {
[16:04:44.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.874]                     {
[16:04:44.874]                       inherits <- base::inherits
[16:04:44.874]                       invokeRestart <- base::invokeRestart
[16:04:44.874]                       is.null <- base::is.null
[16:04:44.874]                       muffled <- FALSE
[16:04:44.874]                       if (inherits(cond, "message")) {
[16:04:44.874]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.874]                         if (muffled) 
[16:04:44.874]                           invokeRestart("muffleMessage")
[16:04:44.874]                       }
[16:04:44.874]                       else if (inherits(cond, "warning")) {
[16:04:44.874]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.874]                         if (muffled) 
[16:04:44.874]                           invokeRestart("muffleWarning")
[16:04:44.874]                       }
[16:04:44.874]                       else if (inherits(cond, "condition")) {
[16:04:44.874]                         if (!is.null(pattern)) {
[16:04:44.874]                           computeRestarts <- base::computeRestarts
[16:04:44.874]                           grepl <- base::grepl
[16:04:44.874]                           restarts <- computeRestarts(cond)
[16:04:44.874]                           for (restart in restarts) {
[16:04:44.874]                             name <- restart$name
[16:04:44.874]                             if (is.null(name)) 
[16:04:44.874]                               next
[16:04:44.874]                             if (!grepl(pattern, name)) 
[16:04:44.874]                               next
[16:04:44.874]                             invokeRestart(restart)
[16:04:44.874]                             muffled <- TRUE
[16:04:44.874]                             break
[16:04:44.874]                           }
[16:04:44.874]                         }
[16:04:44.874]                       }
[16:04:44.874]                       invisible(muffled)
[16:04:44.874]                     }
[16:04:44.874]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.874]                   }
[16:04:44.874]                 }
[16:04:44.874]             }
[16:04:44.874]         }))
[16:04:44.874]     }, error = function(ex) {
[16:04:44.874]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.874]                 ...future.rng), started = ...future.startTime, 
[16:04:44.874]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.874]             version = "1.8"), class = "FutureResult")
[16:04:44.874]     }, finally = {
[16:04:44.874]         if (!identical(...future.workdir, getwd())) 
[16:04:44.874]             setwd(...future.workdir)
[16:04:44.874]         {
[16:04:44.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.874]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.874]             }
[16:04:44.874]             base::options(...future.oldOptions)
[16:04:44.874]             if (.Platform$OS.type == "windows") {
[16:04:44.874]                 old_names <- names(...future.oldEnvVars)
[16:04:44.874]                 envs <- base::Sys.getenv()
[16:04:44.874]                 names <- names(envs)
[16:04:44.874]                 common <- intersect(names, old_names)
[16:04:44.874]                 added <- setdiff(names, old_names)
[16:04:44.874]                 removed <- setdiff(old_names, names)
[16:04:44.874]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.874]                   envs[common]]
[16:04:44.874]                 NAMES <- toupper(changed)
[16:04:44.874]                 args <- list()
[16:04:44.874]                 for (kk in seq_along(NAMES)) {
[16:04:44.874]                   name <- changed[[kk]]
[16:04:44.874]                   NAME <- NAMES[[kk]]
[16:04:44.874]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.874]                     next
[16:04:44.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.874]                 }
[16:04:44.874]                 NAMES <- toupper(added)
[16:04:44.874]                 for (kk in seq_along(NAMES)) {
[16:04:44.874]                   name <- added[[kk]]
[16:04:44.874]                   NAME <- NAMES[[kk]]
[16:04:44.874]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.874]                     next
[16:04:44.874]                   args[[name]] <- ""
[16:04:44.874]                 }
[16:04:44.874]                 NAMES <- toupper(removed)
[16:04:44.874]                 for (kk in seq_along(NAMES)) {
[16:04:44.874]                   name <- removed[[kk]]
[16:04:44.874]                   NAME <- NAMES[[kk]]
[16:04:44.874]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.874]                     next
[16:04:44.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.874]                 }
[16:04:44.874]                 if (length(args) > 0) 
[16:04:44.874]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.874]             }
[16:04:44.874]             else {
[16:04:44.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.874]             }
[16:04:44.874]             {
[16:04:44.874]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.874]                   0L) {
[16:04:44.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.874]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.874]                   base::options(opts)
[16:04:44.874]                 }
[16:04:44.874]                 {
[16:04:44.874]                   {
[16:04:44.874]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.874]                     NULL
[16:04:44.874]                   }
[16:04:44.874]                   options(future.plan = NULL)
[16:04:44.874]                   if (is.na(NA_character_)) 
[16:04:44.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.874]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:44.874]                     envir = parent.frame()) 
[16:04:44.874]                   {
[16:04:44.874]                     default_workers <- missing(workers)
[16:04:44.874]                     if (is.function(workers)) 
[16:04:44.874]                       workers <- workers()
[16:04:44.874]                     workers <- structure(as.integer(workers), 
[16:04:44.874]                       class = class(workers))
[16:04:44.874]                     stop_if_not(is.finite(workers), workers >= 
[16:04:44.874]                       1L)
[16:04:44.874]                     if ((workers == 1L && !inherits(workers, 
[16:04:44.874]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:44.874]                       if (default_workers) 
[16:04:44.874]                         supportsMulticore(warn = TRUE)
[16:04:44.874]                       return(sequential(..., envir = envir))
[16:04:44.874]                     }
[16:04:44.874]                     oopts <- options(mc.cores = workers)
[16:04:44.874]                     on.exit(options(oopts))
[16:04:44.874]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:44.874]                       envir = envir)
[16:04:44.874]                     if (!future$lazy) 
[16:04:44.874]                       future <- run(future)
[16:04:44.874]                     invisible(future)
[16:04:44.874]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.874]                 }
[16:04:44.874]             }
[16:04:44.874]         }
[16:04:44.874]     })
[16:04:44.874]     if (TRUE) {
[16:04:44.874]         base::sink(type = "output", split = FALSE)
[16:04:44.874]         if (TRUE) {
[16:04:44.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.874]         }
[16:04:44.874]         else {
[16:04:44.874]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.874]         }
[16:04:44.874]         base::close(...future.stdout)
[16:04:44.874]         ...future.stdout <- NULL
[16:04:44.874]     }
[16:04:44.874]     ...future.result$conditions <- ...future.conditions
[16:04:44.874]     ...future.result$finished <- base::Sys.time()
[16:04:44.874]     ...future.result
[16:04:44.874] }
[16:04:44.877] requestCore(): workers = 2
[16:04:44.877] Poll #1 (0): usedCores() = 2, workers = 2
[16:04:44.888] result() for MulticoreFuture ...
[16:04:44.889] result() for MulticoreFuture ...
[16:04:44.889] result() for MulticoreFuture ... done
[16:04:44.889] result() for MulticoreFuture ... done
[16:04:44.889] result() for MulticoreFuture ...
[16:04:44.889] result() for MulticoreFuture ... done
[16:04:44.892] MulticoreFuture started
[16:04:44.893] - Launch lazy future ... done
[16:04:44.893] run() for ‘MulticoreFuture’ ... done
[16:04:44.893] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55874f5b1d78> 
[16:04:44.894] List of future strategies:
[16:04:44.894] 1. sequential:
[16:04:44.894]    - args: function (..., envir = parent.frame())
[16:04:44.894]    - tweaked: FALSE
[16:04:44.894]    - call: NULL
[16:04:44.895] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55874de5e940> 
[16:04:44.898] plan(): Setting new future strategy stack:
[16:04:44.898] List of future strategies:
[16:04:44.898] 1. multicore:
[16:04:44.898]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:44.898]    - tweaked: FALSE
[16:04:44.898]    - call: plan(strategy)
[16:04:44.904] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:44.907] resolve() on list environment ...
[16:04:44.908]  recursive: 0
[16:04:44.909]  length: 6
[16:04:44.909]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:44.909] signalConditionsASAP(numeric, pos=1) ...
[16:04:44.909] - nx: 6
[16:04:44.910] - relay: TRUE
[16:04:44.910] - stdout: TRUE
[16:04:44.910] - signal: TRUE
[16:04:44.910] - resignal: FALSE
[16:04:44.910] - force: TRUE
[16:04:44.910] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:44.910] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:44.911]  - until=2
[16:04:44.911]  - relaying element #2
[16:04:44.911] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:44.911] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:44.911] signalConditionsASAP(NULL, pos=1) ... done
[16:04:44.911]  length: 5 (resolved future 1)
[16:04:44.911] Future #2
[16:04:44.912] result() for MulticoreFuture ...
[16:04:44.912] result() for MulticoreFuture ... done
[16:04:44.912] result() for MulticoreFuture ...
[16:04:44.912] result() for MulticoreFuture ... done
[16:04:44.912] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:44.912] - nx: 6
[16:04:44.912] - relay: TRUE
[16:04:44.913] - stdout: TRUE
[16:04:44.913] - signal: TRUE
[16:04:44.913] - resignal: FALSE
[16:04:44.913] - force: TRUE
[16:04:44.913] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:44.913] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:44.913]  - until=2
[16:04:44.913]  - relaying element #2
[16:04:44.914] result() for MulticoreFuture ...
[16:04:44.914] result() for MulticoreFuture ... done
[16:04:44.914] result() for MulticoreFuture ...
[16:04:44.914] result() for MulticoreFuture ... done
[16:04:44.914] result() for MulticoreFuture ...
[16:04:44.914] result() for MulticoreFuture ... done
[16:04:44.914] result() for MulticoreFuture ...
[16:04:44.915] result() for MulticoreFuture ... done
[16:04:44.915] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:44.915] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:44.915] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:44.915]  length: 4 (resolved future 2)
[16:04:44.916] Future #3
[16:04:44.916] result() for MulticoreFuture ...
[16:04:44.917] result() for MulticoreFuture ...
[16:04:44.917] result() for MulticoreFuture ... done
[16:04:44.917] result() for MulticoreFuture ... done
[16:04:44.917] result() for MulticoreFuture ...
[16:04:44.917] result() for MulticoreFuture ... done
[16:04:44.918] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:44.918] - nx: 6
[16:04:44.918] - relay: TRUE
[16:04:44.918] - stdout: TRUE
[16:04:44.918] - signal: TRUE
[16:04:44.918] - resignal: FALSE
[16:04:44.919] - force: TRUE
[16:04:44.919] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:44.919] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:44.919]  - until=3
[16:04:44.920]  - relaying element #3
[16:04:44.920] result() for MulticoreFuture ...
[16:04:44.920] result() for MulticoreFuture ... done
[16:04:44.920] result() for MulticoreFuture ...
[16:04:44.920] result() for MulticoreFuture ... done
[16:04:44.921] result() for MulticoreFuture ...
[16:04:44.921] result() for MulticoreFuture ... done
[16:04:44.921] result() for MulticoreFuture ...
[16:04:44.921] result() for MulticoreFuture ... done
[16:04:44.921] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:44.922] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:44.922] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:44.922]  length: 3 (resolved future 3)
[16:04:44.922] Future #4
[16:04:44.923] result() for MulticoreFuture ...
[16:04:44.924] result() for MulticoreFuture ...
[16:04:44.924] result() for MulticoreFuture ... done
[16:04:44.924] result() for MulticoreFuture ... done
[16:04:44.925] result() for MulticoreFuture ...
[16:04:44.925] result() for MulticoreFuture ... done
[16:04:44.925] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:04:44.925] - nx: 6
[16:04:44.925] - relay: TRUE
[16:04:44.925] - stdout: TRUE
[16:04:44.926] - signal: TRUE
[16:04:44.926] - resignal: FALSE
[16:04:44.926] - force: TRUE
[16:04:44.926] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:44.926] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:44.926]  - until=4
[16:04:44.927]  - relaying element #4
[16:04:44.927] result() for MulticoreFuture ...
[16:04:44.927] result() for MulticoreFuture ... done
[16:04:44.927] result() for MulticoreFuture ...
[16:04:44.927] result() for MulticoreFuture ... done
[16:04:44.928] result() for MulticoreFuture ...
[16:04:44.928] result() for MulticoreFuture ... done
[16:04:44.928] result() for MulticoreFuture ...
[16:04:44.928] result() for MulticoreFuture ... done
[16:04:44.928] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:44.928] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:44.928] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:04:44.928]  length: 2 (resolved future 4)
[16:04:44.929] signalConditionsASAP(NULL, pos=5) ...
[16:04:44.929] - nx: 6
[16:04:44.929] - relay: TRUE
[16:04:44.929] - stdout: TRUE
[16:04:44.929] - signal: TRUE
[16:04:44.929] - resignal: FALSE
[16:04:44.929] - force: TRUE
[16:04:44.929] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:44.929] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:44.930]  - until=6
[16:04:44.930]  - relaying element #6
[16:04:44.930] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:44.930] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:44.930] signalConditionsASAP(NULL, pos=5) ... done
[16:04:44.930]  length: 1 (resolved future 5)
[16:04:44.930] signalConditionsASAP(numeric, pos=6) ...
[16:04:44.930] - nx: 6
[16:04:44.930] - relay: TRUE
[16:04:44.931] - stdout: TRUE
[16:04:44.931] - signal: TRUE
[16:04:44.931] - resignal: FALSE
[16:04:44.931] - force: TRUE
[16:04:44.931] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:44.931] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:44.931]  - until=6
[16:04:44.931] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:44.932] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:44.932] signalConditionsASAP(numeric, pos=6) ... done
[16:04:44.932]  length: 0 (resolved future 6)
[16:04:44.932] Relaying remaining futures
[16:04:44.932] signalConditionsASAP(NULL, pos=0) ...
[16:04:44.932] - nx: 6
[16:04:44.932] - relay: TRUE
[16:04:44.932] - stdout: TRUE
[16:04:44.932] - signal: TRUE
[16:04:44.932] - resignal: FALSE
[16:04:44.933] - force: TRUE
[16:04:44.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:44.933] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:44.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:44.933] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:44.933] signalConditionsASAP(NULL, pos=0) ... done
[16:04:44.933] resolve() on list environment ... DONE
[16:04:44.933] result() for MulticoreFuture ...
[16:04:44.934] result() for MulticoreFuture ... done
[16:04:44.934] result() for MulticoreFuture ...
[16:04:44.934] result() for MulticoreFuture ... done
[16:04:44.934] result() for MulticoreFuture ...
[16:04:44.934] result() for MulticoreFuture ... done
[16:04:44.934] result() for MulticoreFuture ...
[16:04:44.934] result() for MulticoreFuture ... done
[16:04:44.935] result() for MulticoreFuture ...
[16:04:44.935] result() for MulticoreFuture ... done
[16:04:44.935] result() for MulticoreFuture ...
[16:04:44.935] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55874dbe3268> 
Dimensions: c(1, 6)
[16:04:44.936] getGlobalsAndPackages() ...
[16:04:44.936] Searching for globals...
[16:04:44.936] 
[16:04:44.936] Searching for globals ... DONE
[16:04:44.936] - globals: [0] <none>
[16:04:44.936] getGlobalsAndPackages() ... DONE
[16:04:44.937] run() for ‘Future’ ...
[16:04:44.937] - state: ‘created’
[16:04:44.937] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.941] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.941] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:44.942]   - Field: ‘label’
[16:04:44.942]   - Field: ‘local’
[16:04:44.942]   - Field: ‘owner’
[16:04:44.942]   - Field: ‘envir’
[16:04:44.942]   - Field: ‘workers’
[16:04:44.942]   - Field: ‘packages’
[16:04:44.942]   - Field: ‘gc’
[16:04:44.942]   - Field: ‘job’
[16:04:44.942]   - Field: ‘conditions’
[16:04:44.943]   - Field: ‘expr’
[16:04:44.943]   - Field: ‘uuid’
[16:04:44.943]   - Field: ‘seed’
[16:04:44.943]   - Field: ‘version’
[16:04:44.943]   - Field: ‘result’
[16:04:44.943]   - Field: ‘asynchronous’
[16:04:44.943]   - Field: ‘calls’
[16:04:44.943]   - Field: ‘globals’
[16:04:44.943]   - Field: ‘stdout’
[16:04:44.944]   - Field: ‘earlySignal’
[16:04:44.944]   - Field: ‘lazy’
[16:04:44.944]   - Field: ‘state’
[16:04:44.944] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:44.944] - Launch lazy future ...
[16:04:44.944] Packages needed by the future expression (n = 0): <none>
[16:04:44.944] Packages needed by future strategies (n = 0): <none>
[16:04:44.945] {
[16:04:44.945]     {
[16:04:44.945]         {
[16:04:44.945]             ...future.startTime <- base::Sys.time()
[16:04:44.945]             {
[16:04:44.945]                 {
[16:04:44.945]                   {
[16:04:44.945]                     {
[16:04:44.945]                       base::local({
[16:04:44.945]                         has_future <- base::requireNamespace("future", 
[16:04:44.945]                           quietly = TRUE)
[16:04:44.945]                         if (has_future) {
[16:04:44.945]                           ns <- base::getNamespace("future")
[16:04:44.945]                           version <- ns[[".package"]][["version"]]
[16:04:44.945]                           if (is.null(version)) 
[16:04:44.945]                             version <- utils::packageVersion("future")
[16:04:44.945]                         }
[16:04:44.945]                         else {
[16:04:44.945]                           version <- NULL
[16:04:44.945]                         }
[16:04:44.945]                         if (!has_future || version < "1.8.0") {
[16:04:44.945]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.945]                             "", base::R.version$version.string), 
[16:04:44.945]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.945]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.945]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.945]                               "release", "version")], collapse = " "), 
[16:04:44.945]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.945]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.945]                             info)
[16:04:44.945]                           info <- base::paste(info, collapse = "; ")
[16:04:44.945]                           if (!has_future) {
[16:04:44.945]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.945]                               info)
[16:04:44.945]                           }
[16:04:44.945]                           else {
[16:04:44.945]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.945]                               info, version)
[16:04:44.945]                           }
[16:04:44.945]                           base::stop(msg)
[16:04:44.945]                         }
[16:04:44.945]                       })
[16:04:44.945]                     }
[16:04:44.945]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.945]                     base::options(mc.cores = 1L)
[16:04:44.945]                   }
[16:04:44.945]                   options(future.plan = NULL)
[16:04:44.945]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.945]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.945]                 }
[16:04:44.945]                 ...future.workdir <- getwd()
[16:04:44.945]             }
[16:04:44.945]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.945]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.945]         }
[16:04:44.945]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.945]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.945]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.945]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.945]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.945]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.945]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.945]             base::names(...future.oldOptions))
[16:04:44.945]     }
[16:04:44.945]     if (FALSE) {
[16:04:44.945]     }
[16:04:44.945]     else {
[16:04:44.945]         if (TRUE) {
[16:04:44.945]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.945]                 open = "w")
[16:04:44.945]         }
[16:04:44.945]         else {
[16:04:44.945]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.945]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.945]         }
[16:04:44.945]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.945]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.945]             base::sink(type = "output", split = FALSE)
[16:04:44.945]             base::close(...future.stdout)
[16:04:44.945]         }, add = TRUE)
[16:04:44.945]     }
[16:04:44.945]     ...future.frame <- base::sys.nframe()
[16:04:44.945]     ...future.conditions <- base::list()
[16:04:44.945]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.945]     if (FALSE) {
[16:04:44.945]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.945]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.945]     }
[16:04:44.945]     ...future.result <- base::tryCatch({
[16:04:44.945]         base::withCallingHandlers({
[16:04:44.945]             ...future.value <- base::withVisible(base::local({
[16:04:44.945]                 withCallingHandlers({
[16:04:44.945]                   2
[16:04:44.945]                 }, immediateCondition = function(cond) {
[16:04:44.945]                   save_rds <- function (object, pathname, ...) 
[16:04:44.945]                   {
[16:04:44.945]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:44.945]                     if (file_test("-f", pathname_tmp)) {
[16:04:44.945]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.945]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:44.945]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.945]                         fi_tmp[["mtime"]])
[16:04:44.945]                     }
[16:04:44.945]                     tryCatch({
[16:04:44.945]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:44.945]                     }, error = function(ex) {
[16:04:44.945]                       msg <- conditionMessage(ex)
[16:04:44.945]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.945]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:44.945]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.945]                         fi_tmp[["mtime"]], msg)
[16:04:44.945]                       ex$message <- msg
[16:04:44.945]                       stop(ex)
[16:04:44.945]                     })
[16:04:44.945]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:44.945]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:44.945]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:44.945]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.945]                       fi <- file.info(pathname)
[16:04:44.945]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:44.945]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.945]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:44.945]                         fi[["size"]], fi[["mtime"]])
[16:04:44.945]                       stop(msg)
[16:04:44.945]                     }
[16:04:44.945]                     invisible(pathname)
[16:04:44.945]                   }
[16:04:44.945]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:44.945]                     rootPath = tempdir()) 
[16:04:44.945]                   {
[16:04:44.945]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:44.945]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:44.945]                       tmpdir = path, fileext = ".rds")
[16:04:44.945]                     save_rds(obj, file)
[16:04:44.945]                   }
[16:04:44.945]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:44.945]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.945]                   {
[16:04:44.945]                     inherits <- base::inherits
[16:04:44.945]                     invokeRestart <- base::invokeRestart
[16:04:44.945]                     is.null <- base::is.null
[16:04:44.945]                     muffled <- FALSE
[16:04:44.945]                     if (inherits(cond, "message")) {
[16:04:44.945]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.945]                       if (muffled) 
[16:04:44.945]                         invokeRestart("muffleMessage")
[16:04:44.945]                     }
[16:04:44.945]                     else if (inherits(cond, "warning")) {
[16:04:44.945]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.945]                       if (muffled) 
[16:04:44.945]                         invokeRestart("muffleWarning")
[16:04:44.945]                     }
[16:04:44.945]                     else if (inherits(cond, "condition")) {
[16:04:44.945]                       if (!is.null(pattern)) {
[16:04:44.945]                         computeRestarts <- base::computeRestarts
[16:04:44.945]                         grepl <- base::grepl
[16:04:44.945]                         restarts <- computeRestarts(cond)
[16:04:44.945]                         for (restart in restarts) {
[16:04:44.945]                           name <- restart$name
[16:04:44.945]                           if (is.null(name)) 
[16:04:44.945]                             next
[16:04:44.945]                           if (!grepl(pattern, name)) 
[16:04:44.945]                             next
[16:04:44.945]                           invokeRestart(restart)
[16:04:44.945]                           muffled <- TRUE
[16:04:44.945]                           break
[16:04:44.945]                         }
[16:04:44.945]                       }
[16:04:44.945]                     }
[16:04:44.945]                     invisible(muffled)
[16:04:44.945]                   }
[16:04:44.945]                   muffleCondition(cond)
[16:04:44.945]                 })
[16:04:44.945]             }))
[16:04:44.945]             future::FutureResult(value = ...future.value$value, 
[16:04:44.945]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.945]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.945]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.945]                     ...future.globalenv.names))
[16:04:44.945]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.945]         }, condition = base::local({
[16:04:44.945]             c <- base::c
[16:04:44.945]             inherits <- base::inherits
[16:04:44.945]             invokeRestart <- base::invokeRestart
[16:04:44.945]             length <- base::length
[16:04:44.945]             list <- base::list
[16:04:44.945]             seq.int <- base::seq.int
[16:04:44.945]             signalCondition <- base::signalCondition
[16:04:44.945]             sys.calls <- base::sys.calls
[16:04:44.945]             `[[` <- base::`[[`
[16:04:44.945]             `+` <- base::`+`
[16:04:44.945]             `<<-` <- base::`<<-`
[16:04:44.945]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.945]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.945]                   3L)]
[16:04:44.945]             }
[16:04:44.945]             function(cond) {
[16:04:44.945]                 is_error <- inherits(cond, "error")
[16:04:44.945]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.945]                   NULL)
[16:04:44.945]                 if (is_error) {
[16:04:44.945]                   sessionInformation <- function() {
[16:04:44.945]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.945]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.945]                       search = base::search(), system = base::Sys.info())
[16:04:44.945]                   }
[16:04:44.945]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.945]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.945]                     cond$call), session = sessionInformation(), 
[16:04:44.945]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.945]                   signalCondition(cond)
[16:04:44.945]                 }
[16:04:44.945]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.945]                 "immediateCondition"))) {
[16:04:44.945]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.945]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.945]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.945]                   if (TRUE && !signal) {
[16:04:44.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.945]                     {
[16:04:44.945]                       inherits <- base::inherits
[16:04:44.945]                       invokeRestart <- base::invokeRestart
[16:04:44.945]                       is.null <- base::is.null
[16:04:44.945]                       muffled <- FALSE
[16:04:44.945]                       if (inherits(cond, "message")) {
[16:04:44.945]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.945]                         if (muffled) 
[16:04:44.945]                           invokeRestart("muffleMessage")
[16:04:44.945]                       }
[16:04:44.945]                       else if (inherits(cond, "warning")) {
[16:04:44.945]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.945]                         if (muffled) 
[16:04:44.945]                           invokeRestart("muffleWarning")
[16:04:44.945]                       }
[16:04:44.945]                       else if (inherits(cond, "condition")) {
[16:04:44.945]                         if (!is.null(pattern)) {
[16:04:44.945]                           computeRestarts <- base::computeRestarts
[16:04:44.945]                           grepl <- base::grepl
[16:04:44.945]                           restarts <- computeRestarts(cond)
[16:04:44.945]                           for (restart in restarts) {
[16:04:44.945]                             name <- restart$name
[16:04:44.945]                             if (is.null(name)) 
[16:04:44.945]                               next
[16:04:44.945]                             if (!grepl(pattern, name)) 
[16:04:44.945]                               next
[16:04:44.945]                             invokeRestart(restart)
[16:04:44.945]                             muffled <- TRUE
[16:04:44.945]                             break
[16:04:44.945]                           }
[16:04:44.945]                         }
[16:04:44.945]                       }
[16:04:44.945]                       invisible(muffled)
[16:04:44.945]                     }
[16:04:44.945]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.945]                   }
[16:04:44.945]                 }
[16:04:44.945]                 else {
[16:04:44.945]                   if (TRUE) {
[16:04:44.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.945]                     {
[16:04:44.945]                       inherits <- base::inherits
[16:04:44.945]                       invokeRestart <- base::invokeRestart
[16:04:44.945]                       is.null <- base::is.null
[16:04:44.945]                       muffled <- FALSE
[16:04:44.945]                       if (inherits(cond, "message")) {
[16:04:44.945]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.945]                         if (muffled) 
[16:04:44.945]                           invokeRestart("muffleMessage")
[16:04:44.945]                       }
[16:04:44.945]                       else if (inherits(cond, "warning")) {
[16:04:44.945]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.945]                         if (muffled) 
[16:04:44.945]                           invokeRestart("muffleWarning")
[16:04:44.945]                       }
[16:04:44.945]                       else if (inherits(cond, "condition")) {
[16:04:44.945]                         if (!is.null(pattern)) {
[16:04:44.945]                           computeRestarts <- base::computeRestarts
[16:04:44.945]                           grepl <- base::grepl
[16:04:44.945]                           restarts <- computeRestarts(cond)
[16:04:44.945]                           for (restart in restarts) {
[16:04:44.945]                             name <- restart$name
[16:04:44.945]                             if (is.null(name)) 
[16:04:44.945]                               next
[16:04:44.945]                             if (!grepl(pattern, name)) 
[16:04:44.945]                               next
[16:04:44.945]                             invokeRestart(restart)
[16:04:44.945]                             muffled <- TRUE
[16:04:44.945]                             break
[16:04:44.945]                           }
[16:04:44.945]                         }
[16:04:44.945]                       }
[16:04:44.945]                       invisible(muffled)
[16:04:44.945]                     }
[16:04:44.945]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.945]                   }
[16:04:44.945]                 }
[16:04:44.945]             }
[16:04:44.945]         }))
[16:04:44.945]     }, error = function(ex) {
[16:04:44.945]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.945]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.945]                 ...future.rng), started = ...future.startTime, 
[16:04:44.945]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.945]             version = "1.8"), class = "FutureResult")
[16:04:44.945]     }, finally = {
[16:04:44.945]         if (!identical(...future.workdir, getwd())) 
[16:04:44.945]             setwd(...future.workdir)
[16:04:44.945]         {
[16:04:44.945]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.945]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.945]             }
[16:04:44.945]             base::options(...future.oldOptions)
[16:04:44.945]             if (.Platform$OS.type == "windows") {
[16:04:44.945]                 old_names <- names(...future.oldEnvVars)
[16:04:44.945]                 envs <- base::Sys.getenv()
[16:04:44.945]                 names <- names(envs)
[16:04:44.945]                 common <- intersect(names, old_names)
[16:04:44.945]                 added <- setdiff(names, old_names)
[16:04:44.945]                 removed <- setdiff(old_names, names)
[16:04:44.945]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.945]                   envs[common]]
[16:04:44.945]                 NAMES <- toupper(changed)
[16:04:44.945]                 args <- list()
[16:04:44.945]                 for (kk in seq_along(NAMES)) {
[16:04:44.945]                   name <- changed[[kk]]
[16:04:44.945]                   NAME <- NAMES[[kk]]
[16:04:44.945]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.945]                     next
[16:04:44.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.945]                 }
[16:04:44.945]                 NAMES <- toupper(added)
[16:04:44.945]                 for (kk in seq_along(NAMES)) {
[16:04:44.945]                   name <- added[[kk]]
[16:04:44.945]                   NAME <- NAMES[[kk]]
[16:04:44.945]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.945]                     next
[16:04:44.945]                   args[[name]] <- ""
[16:04:44.945]                 }
[16:04:44.945]                 NAMES <- toupper(removed)
[16:04:44.945]                 for (kk in seq_along(NAMES)) {
[16:04:44.945]                   name <- removed[[kk]]
[16:04:44.945]                   NAME <- NAMES[[kk]]
[16:04:44.945]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.945]                     next
[16:04:44.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.945]                 }
[16:04:44.945]                 if (length(args) > 0) 
[16:04:44.945]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.945]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.945]             }
[16:04:44.945]             else {
[16:04:44.945]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.945]             }
[16:04:44.945]             {
[16:04:44.945]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.945]                   0L) {
[16:04:44.945]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.945]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.945]                   base::options(opts)
[16:04:44.945]                 }
[16:04:44.945]                 {
[16:04:44.945]                   {
[16:04:44.945]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.945]                     NULL
[16:04:44.945]                   }
[16:04:44.945]                   options(future.plan = NULL)
[16:04:44.945]                   if (is.na(NA_character_)) 
[16:04:44.945]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.945]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.945]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:44.945]                     envir = parent.frame()) 
[16:04:44.945]                   {
[16:04:44.945]                     default_workers <- missing(workers)
[16:04:44.945]                     if (is.function(workers)) 
[16:04:44.945]                       workers <- workers()
[16:04:44.945]                     workers <- structure(as.integer(workers), 
[16:04:44.945]                       class = class(workers))
[16:04:44.945]                     stop_if_not(is.finite(workers), workers >= 
[16:04:44.945]                       1L)
[16:04:44.945]                     if ((workers == 1L && !inherits(workers, 
[16:04:44.945]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:44.945]                       if (default_workers) 
[16:04:44.945]                         supportsMulticore(warn = TRUE)
[16:04:44.945]                       return(sequential(..., envir = envir))
[16:04:44.945]                     }
[16:04:44.945]                     oopts <- options(mc.cores = workers)
[16:04:44.945]                     on.exit(options(oopts))
[16:04:44.945]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:44.945]                       envir = envir)
[16:04:44.945]                     if (!future$lazy) 
[16:04:44.945]                       future <- run(future)
[16:04:44.945]                     invisible(future)
[16:04:44.945]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.945]                 }
[16:04:44.945]             }
[16:04:44.945]         }
[16:04:44.945]     })
[16:04:44.945]     if (TRUE) {
[16:04:44.945]         base::sink(type = "output", split = FALSE)
[16:04:44.945]         if (TRUE) {
[16:04:44.945]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.945]         }
[16:04:44.945]         else {
[16:04:44.945]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.945]         }
[16:04:44.945]         base::close(...future.stdout)
[16:04:44.945]         ...future.stdout <- NULL
[16:04:44.945]     }
[16:04:44.945]     ...future.result$conditions <- ...future.conditions
[16:04:44.945]     ...future.result$finished <- base::Sys.time()
[16:04:44.945]     ...future.result
[16:04:44.945] }
[16:04:44.948] requestCore(): workers = 2
[16:04:44.950] MulticoreFuture started
[16:04:44.950] - Launch lazy future ... done
[16:04:44.951] run() for ‘MulticoreFuture’ ... done
[16:04:44.951] getGlobalsAndPackages() ...
[16:04:44.951] Searching for globals...
[16:04:44.951] plan(): Setting new future strategy stack:
[16:04:44.951] List of future strategies:
[16:04:44.951] 1. sequential:
[16:04:44.951]    - args: function (..., envir = parent.frame())
[16:04:44.951]    - tweaked: FALSE
[16:04:44.951]    - call: NULL
[16:04:44.952] 
[16:04:44.952] Searching for globals ... DONE
[16:04:44.952] plan(): nbrOfWorkers() = 1
[16:04:44.952] - globals: [0] <none>
[16:04:44.952] getGlobalsAndPackages() ... DONE
[16:04:44.953] run() for ‘Future’ ...
[16:04:44.953] - state: ‘created’
[16:04:44.953] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.954] plan(): Setting new future strategy stack:
[16:04:44.954] List of future strategies:
[16:04:44.954] 1. multicore:
[16:04:44.954]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:44.954]    - tweaked: FALSE
[16:04:44.954]    - call: plan(strategy)
[16:04:44.959] plan(): nbrOfWorkers() = 2
[16:04:44.959] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.959] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:44.959]   - Field: ‘label’
[16:04:44.959]   - Field: ‘local’
[16:04:44.959]   - Field: ‘owner’
[16:04:44.960]   - Field: ‘envir’
[16:04:44.960]   - Field: ‘workers’
[16:04:44.960]   - Field: ‘packages’
[16:04:44.960]   - Field: ‘gc’
[16:04:44.960]   - Field: ‘job’
[16:04:44.960]   - Field: ‘conditions’
[16:04:44.960]   - Field: ‘expr’
[16:04:44.961]   - Field: ‘uuid’
[16:04:44.961]   - Field: ‘seed’
[16:04:44.961]   - Field: ‘version’
[16:04:44.961]   - Field: ‘result’
[16:04:44.961]   - Field: ‘asynchronous’
[16:04:44.961]   - Field: ‘calls’
[16:04:44.961]   - Field: ‘globals’
[16:04:44.962]   - Field: ‘stdout’
[16:04:44.962]   - Field: ‘earlySignal’
[16:04:44.962]   - Field: ‘lazy’
[16:04:44.962]   - Field: ‘state’
[16:04:44.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:44.962] - Launch lazy future ...
[16:04:44.963] Packages needed by the future expression (n = 0): <none>
[16:04:44.963] Packages needed by future strategies (n = 0): <none>
[16:04:44.964] {
[16:04:44.964]     {
[16:04:44.964]         {
[16:04:44.964]             ...future.startTime <- base::Sys.time()
[16:04:44.964]             {
[16:04:44.964]                 {
[16:04:44.964]                   {
[16:04:44.964]                     {
[16:04:44.964]                       base::local({
[16:04:44.964]                         has_future <- base::requireNamespace("future", 
[16:04:44.964]                           quietly = TRUE)
[16:04:44.964]                         if (has_future) {
[16:04:44.964]                           ns <- base::getNamespace("future")
[16:04:44.964]                           version <- ns[[".package"]][["version"]]
[16:04:44.964]                           if (is.null(version)) 
[16:04:44.964]                             version <- utils::packageVersion("future")
[16:04:44.964]                         }
[16:04:44.964]                         else {
[16:04:44.964]                           version <- NULL
[16:04:44.964]                         }
[16:04:44.964]                         if (!has_future || version < "1.8.0") {
[16:04:44.964]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.964]                             "", base::R.version$version.string), 
[16:04:44.964]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.964]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.964]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.964]                               "release", "version")], collapse = " "), 
[16:04:44.964]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.964]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.964]                             info)
[16:04:44.964]                           info <- base::paste(info, collapse = "; ")
[16:04:44.964]                           if (!has_future) {
[16:04:44.964]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.964]                               info)
[16:04:44.964]                           }
[16:04:44.964]                           else {
[16:04:44.964]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.964]                               info, version)
[16:04:44.964]                           }
[16:04:44.964]                           base::stop(msg)
[16:04:44.964]                         }
[16:04:44.964]                       })
[16:04:44.964]                     }
[16:04:44.964]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.964]                     base::options(mc.cores = 1L)
[16:04:44.964]                   }
[16:04:44.964]                   options(future.plan = NULL)
[16:04:44.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.964]                 }
[16:04:44.964]                 ...future.workdir <- getwd()
[16:04:44.964]             }
[16:04:44.964]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.964]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.964]         }
[16:04:44.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.964]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.964]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.964]             base::names(...future.oldOptions))
[16:04:44.964]     }
[16:04:44.964]     if (FALSE) {
[16:04:44.964]     }
[16:04:44.964]     else {
[16:04:44.964]         if (TRUE) {
[16:04:44.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.964]                 open = "w")
[16:04:44.964]         }
[16:04:44.964]         else {
[16:04:44.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.964]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.964]         }
[16:04:44.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.964]             base::sink(type = "output", split = FALSE)
[16:04:44.964]             base::close(...future.stdout)
[16:04:44.964]         }, add = TRUE)
[16:04:44.964]     }
[16:04:44.964]     ...future.frame <- base::sys.nframe()
[16:04:44.964]     ...future.conditions <- base::list()
[16:04:44.964]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.964]     if (FALSE) {
[16:04:44.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.964]     }
[16:04:44.964]     ...future.result <- base::tryCatch({
[16:04:44.964]         base::withCallingHandlers({
[16:04:44.964]             ...future.value <- base::withVisible(base::local({
[16:04:44.964]                 withCallingHandlers({
[16:04:44.964]                   NULL
[16:04:44.964]                 }, immediateCondition = function(cond) {
[16:04:44.964]                   save_rds <- function (object, pathname, ...) 
[16:04:44.964]                   {
[16:04:44.964]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:44.964]                     if (file_test("-f", pathname_tmp)) {
[16:04:44.964]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.964]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:44.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.964]                         fi_tmp[["mtime"]])
[16:04:44.964]                     }
[16:04:44.964]                     tryCatch({
[16:04:44.964]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:44.964]                     }, error = function(ex) {
[16:04:44.964]                       msg <- conditionMessage(ex)
[16:04:44.964]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.964]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:44.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.964]                         fi_tmp[["mtime"]], msg)
[16:04:44.964]                       ex$message <- msg
[16:04:44.964]                       stop(ex)
[16:04:44.964]                     })
[16:04:44.964]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:44.964]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:44.964]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:44.964]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.964]                       fi <- file.info(pathname)
[16:04:44.964]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:44.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.964]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:44.964]                         fi[["size"]], fi[["mtime"]])
[16:04:44.964]                       stop(msg)
[16:04:44.964]                     }
[16:04:44.964]                     invisible(pathname)
[16:04:44.964]                   }
[16:04:44.964]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:44.964]                     rootPath = tempdir()) 
[16:04:44.964]                   {
[16:04:44.964]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:44.964]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:44.964]                       tmpdir = path, fileext = ".rds")
[16:04:44.964]                     save_rds(obj, file)
[16:04:44.964]                   }
[16:04:44.964]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:44.964]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.964]                   {
[16:04:44.964]                     inherits <- base::inherits
[16:04:44.964]                     invokeRestart <- base::invokeRestart
[16:04:44.964]                     is.null <- base::is.null
[16:04:44.964]                     muffled <- FALSE
[16:04:44.964]                     if (inherits(cond, "message")) {
[16:04:44.964]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.964]                       if (muffled) 
[16:04:44.964]                         invokeRestart("muffleMessage")
[16:04:44.964]                     }
[16:04:44.964]                     else if (inherits(cond, "warning")) {
[16:04:44.964]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.964]                       if (muffled) 
[16:04:44.964]                         invokeRestart("muffleWarning")
[16:04:44.964]                     }
[16:04:44.964]                     else if (inherits(cond, "condition")) {
[16:04:44.964]                       if (!is.null(pattern)) {
[16:04:44.964]                         computeRestarts <- base::computeRestarts
[16:04:44.964]                         grepl <- base::grepl
[16:04:44.964]                         restarts <- computeRestarts(cond)
[16:04:44.964]                         for (restart in restarts) {
[16:04:44.964]                           name <- restart$name
[16:04:44.964]                           if (is.null(name)) 
[16:04:44.964]                             next
[16:04:44.964]                           if (!grepl(pattern, name)) 
[16:04:44.964]                             next
[16:04:44.964]                           invokeRestart(restart)
[16:04:44.964]                           muffled <- TRUE
[16:04:44.964]                           break
[16:04:44.964]                         }
[16:04:44.964]                       }
[16:04:44.964]                     }
[16:04:44.964]                     invisible(muffled)
[16:04:44.964]                   }
[16:04:44.964]                   muffleCondition(cond)
[16:04:44.964]                 })
[16:04:44.964]             }))
[16:04:44.964]             future::FutureResult(value = ...future.value$value, 
[16:04:44.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.964]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.964]                     ...future.globalenv.names))
[16:04:44.964]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.964]         }, condition = base::local({
[16:04:44.964]             c <- base::c
[16:04:44.964]             inherits <- base::inherits
[16:04:44.964]             invokeRestart <- base::invokeRestart
[16:04:44.964]             length <- base::length
[16:04:44.964]             list <- base::list
[16:04:44.964]             seq.int <- base::seq.int
[16:04:44.964]             signalCondition <- base::signalCondition
[16:04:44.964]             sys.calls <- base::sys.calls
[16:04:44.964]             `[[` <- base::`[[`
[16:04:44.964]             `+` <- base::`+`
[16:04:44.964]             `<<-` <- base::`<<-`
[16:04:44.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.964]                   3L)]
[16:04:44.964]             }
[16:04:44.964]             function(cond) {
[16:04:44.964]                 is_error <- inherits(cond, "error")
[16:04:44.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.964]                   NULL)
[16:04:44.964]                 if (is_error) {
[16:04:44.964]                   sessionInformation <- function() {
[16:04:44.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.964]                       search = base::search(), system = base::Sys.info())
[16:04:44.964]                   }
[16:04:44.964]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.964]                     cond$call), session = sessionInformation(), 
[16:04:44.964]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.964]                   signalCondition(cond)
[16:04:44.964]                 }
[16:04:44.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.964]                 "immediateCondition"))) {
[16:04:44.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.964]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.964]                   if (TRUE && !signal) {
[16:04:44.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.964]                     {
[16:04:44.964]                       inherits <- base::inherits
[16:04:44.964]                       invokeRestart <- base::invokeRestart
[16:04:44.964]                       is.null <- base::is.null
[16:04:44.964]                       muffled <- FALSE
[16:04:44.964]                       if (inherits(cond, "message")) {
[16:04:44.964]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.964]                         if (muffled) 
[16:04:44.964]                           invokeRestart("muffleMessage")
[16:04:44.964]                       }
[16:04:44.964]                       else if (inherits(cond, "warning")) {
[16:04:44.964]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.964]                         if (muffled) 
[16:04:44.964]                           invokeRestart("muffleWarning")
[16:04:44.964]                       }
[16:04:44.964]                       else if (inherits(cond, "condition")) {
[16:04:44.964]                         if (!is.null(pattern)) {
[16:04:44.964]                           computeRestarts <- base::computeRestarts
[16:04:44.964]                           grepl <- base::grepl
[16:04:44.964]                           restarts <- computeRestarts(cond)
[16:04:44.964]                           for (restart in restarts) {
[16:04:44.964]                             name <- restart$name
[16:04:44.964]                             if (is.null(name)) 
[16:04:44.964]                               next
[16:04:44.964]                             if (!grepl(pattern, name)) 
[16:04:44.964]                               next
[16:04:44.964]                             invokeRestart(restart)
[16:04:44.964]                             muffled <- TRUE
[16:04:44.964]                             break
[16:04:44.964]                           }
[16:04:44.964]                         }
[16:04:44.964]                       }
[16:04:44.964]                       invisible(muffled)
[16:04:44.964]                     }
[16:04:44.964]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.964]                   }
[16:04:44.964]                 }
[16:04:44.964]                 else {
[16:04:44.964]                   if (TRUE) {
[16:04:44.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.964]                     {
[16:04:44.964]                       inherits <- base::inherits
[16:04:44.964]                       invokeRestart <- base::invokeRestart
[16:04:44.964]                       is.null <- base::is.null
[16:04:44.964]                       muffled <- FALSE
[16:04:44.964]                       if (inherits(cond, "message")) {
[16:04:44.964]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.964]                         if (muffled) 
[16:04:44.964]                           invokeRestart("muffleMessage")
[16:04:44.964]                       }
[16:04:44.964]                       else if (inherits(cond, "warning")) {
[16:04:44.964]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.964]                         if (muffled) 
[16:04:44.964]                           invokeRestart("muffleWarning")
[16:04:44.964]                       }
[16:04:44.964]                       else if (inherits(cond, "condition")) {
[16:04:44.964]                         if (!is.null(pattern)) {
[16:04:44.964]                           computeRestarts <- base::computeRestarts
[16:04:44.964]                           grepl <- base::grepl
[16:04:44.964]                           restarts <- computeRestarts(cond)
[16:04:44.964]                           for (restart in restarts) {
[16:04:44.964]                             name <- restart$name
[16:04:44.964]                             if (is.null(name)) 
[16:04:44.964]                               next
[16:04:44.964]                             if (!grepl(pattern, name)) 
[16:04:44.964]                               next
[16:04:44.964]                             invokeRestart(restart)
[16:04:44.964]                             muffled <- TRUE
[16:04:44.964]                             break
[16:04:44.964]                           }
[16:04:44.964]                         }
[16:04:44.964]                       }
[16:04:44.964]                       invisible(muffled)
[16:04:44.964]                     }
[16:04:44.964]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.964]                   }
[16:04:44.964]                 }
[16:04:44.964]             }
[16:04:44.964]         }))
[16:04:44.964]     }, error = function(ex) {
[16:04:44.964]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.964]                 ...future.rng), started = ...future.startTime, 
[16:04:44.964]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.964]             version = "1.8"), class = "FutureResult")
[16:04:44.964]     }, finally = {
[16:04:44.964]         if (!identical(...future.workdir, getwd())) 
[16:04:44.964]             setwd(...future.workdir)
[16:04:44.964]         {
[16:04:44.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.964]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.964]             }
[16:04:44.964]             base::options(...future.oldOptions)
[16:04:44.964]             if (.Platform$OS.type == "windows") {
[16:04:44.964]                 old_names <- names(...future.oldEnvVars)
[16:04:44.964]                 envs <- base::Sys.getenv()
[16:04:44.964]                 names <- names(envs)
[16:04:44.964]                 common <- intersect(names, old_names)
[16:04:44.964]                 added <- setdiff(names, old_names)
[16:04:44.964]                 removed <- setdiff(old_names, names)
[16:04:44.964]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.964]                   envs[common]]
[16:04:44.964]                 NAMES <- toupper(changed)
[16:04:44.964]                 args <- list()
[16:04:44.964]                 for (kk in seq_along(NAMES)) {
[16:04:44.964]                   name <- changed[[kk]]
[16:04:44.964]                   NAME <- NAMES[[kk]]
[16:04:44.964]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.964]                     next
[16:04:44.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.964]                 }
[16:04:44.964]                 NAMES <- toupper(added)
[16:04:44.964]                 for (kk in seq_along(NAMES)) {
[16:04:44.964]                   name <- added[[kk]]
[16:04:44.964]                   NAME <- NAMES[[kk]]
[16:04:44.964]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.964]                     next
[16:04:44.964]                   args[[name]] <- ""
[16:04:44.964]                 }
[16:04:44.964]                 NAMES <- toupper(removed)
[16:04:44.964]                 for (kk in seq_along(NAMES)) {
[16:04:44.964]                   name <- removed[[kk]]
[16:04:44.964]                   NAME <- NAMES[[kk]]
[16:04:44.964]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.964]                     next
[16:04:44.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.964]                 }
[16:04:44.964]                 if (length(args) > 0) 
[16:04:44.964]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.964]             }
[16:04:44.964]             else {
[16:04:44.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.964]             }
[16:04:44.964]             {
[16:04:44.964]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.964]                   0L) {
[16:04:44.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.964]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.964]                   base::options(opts)
[16:04:44.964]                 }
[16:04:44.964]                 {
[16:04:44.964]                   {
[16:04:44.964]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.964]                     NULL
[16:04:44.964]                   }
[16:04:44.964]                   options(future.plan = NULL)
[16:04:44.964]                   if (is.na(NA_character_)) 
[16:04:44.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.964]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:44.964]                     envir = parent.frame()) 
[16:04:44.964]                   {
[16:04:44.964]                     default_workers <- missing(workers)
[16:04:44.964]                     if (is.function(workers)) 
[16:04:44.964]                       workers <- workers()
[16:04:44.964]                     workers <- structure(as.integer(workers), 
[16:04:44.964]                       class = class(workers))
[16:04:44.964]                     stop_if_not(is.finite(workers), workers >= 
[16:04:44.964]                       1L)
[16:04:44.964]                     if ((workers == 1L && !inherits(workers, 
[16:04:44.964]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:44.964]                       if (default_workers) 
[16:04:44.964]                         supportsMulticore(warn = TRUE)
[16:04:44.964]                       return(sequential(..., envir = envir))
[16:04:44.964]                     }
[16:04:44.964]                     oopts <- options(mc.cores = workers)
[16:04:44.964]                     on.exit(options(oopts))
[16:04:44.964]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:44.964]                       envir = envir)
[16:04:44.964]                     if (!future$lazy) 
[16:04:44.964]                       future <- run(future)
[16:04:44.964]                     invisible(future)
[16:04:44.964]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.964]                 }
[16:04:44.964]             }
[16:04:44.964]         }
[16:04:44.964]     })
[16:04:44.964]     if (TRUE) {
[16:04:44.964]         base::sink(type = "output", split = FALSE)
[16:04:44.964]         if (TRUE) {
[16:04:44.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.964]         }
[16:04:44.964]         else {
[16:04:44.964]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.964]         }
[16:04:44.964]         base::close(...future.stdout)
[16:04:44.964]         ...future.stdout <- NULL
[16:04:44.964]     }
[16:04:44.964]     ...future.result$conditions <- ...future.conditions
[16:04:44.964]     ...future.result$finished <- base::Sys.time()
[16:04:44.964]     ...future.result
[16:04:44.964] }
[16:04:44.968] requestCore(): workers = 2
[16:04:44.970] MulticoreFuture started
[16:04:44.971] - Launch lazy future ... done
[16:04:44.971] run() for ‘MulticoreFuture’ ... done
[16:04:44.972] plan(): Setting new future strategy stack:
[16:04:44.972] getGlobalsAndPackages() ...
[16:04:44.972] Searching for globals...
[16:04:44.972] List of future strategies:
[16:04:44.972] 1. sequential:
[16:04:44.972]    - args: function (..., envir = parent.frame())
[16:04:44.972]    - tweaked: FALSE
[16:04:44.972]    - call: NULL
[16:04:44.973] plan(): nbrOfWorkers() = 1
[16:04:44.974] - globals found: [1] ‘{’
[16:04:44.974] Searching for globals ... DONE
[16:04:44.974] Resolving globals: FALSE
[16:04:44.974] 
[16:04:44.975] 
[16:04:44.975] getGlobalsAndPackages() ... DONE
[16:04:44.975] plan(): Setting new future strategy stack:
[16:04:44.975] run() for ‘Future’ ...
[16:04:44.975] List of future strategies:
[16:04:44.975] 1. multicore:
[16:04:44.975]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:44.975]    - tweaked: FALSE
[16:04:44.975]    - call: plan(strategy)
[16:04:44.975] - state: ‘created’
[16:04:44.976] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:44.980] plan(): nbrOfWorkers() = 2
[16:04:44.981] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:44.981] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:44.981]   - Field: ‘label’
[16:04:44.981]   - Field: ‘local’
[16:04:44.982]   - Field: ‘owner’
[16:04:44.982]   - Field: ‘envir’
[16:04:44.982]   - Field: ‘workers’
[16:04:44.982]   - Field: ‘packages’
[16:04:44.982]   - Field: ‘gc’
[16:04:44.982]   - Field: ‘job’
[16:04:44.982]   - Field: ‘conditions’
[16:04:44.983]   - Field: ‘expr’
[16:04:44.983]   - Field: ‘uuid’
[16:04:44.983]   - Field: ‘seed’
[16:04:44.983]   - Field: ‘version’
[16:04:44.983]   - Field: ‘result’
[16:04:44.983]   - Field: ‘asynchronous’
[16:04:44.983]   - Field: ‘calls’
[16:04:44.984]   - Field: ‘globals’
[16:04:44.984]   - Field: ‘stdout’
[16:04:44.984]   - Field: ‘earlySignal’
[16:04:44.984]   - Field: ‘lazy’
[16:04:44.984]   - Field: ‘state’
[16:04:44.984] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:44.984] - Launch lazy future ...
[16:04:44.985] Packages needed by the future expression (n = 0): <none>
[16:04:44.985] Packages needed by future strategies (n = 0): <none>
[16:04:44.986] {
[16:04:44.986]     {
[16:04:44.986]         {
[16:04:44.986]             ...future.startTime <- base::Sys.time()
[16:04:44.986]             {
[16:04:44.986]                 {
[16:04:44.986]                   {
[16:04:44.986]                     {
[16:04:44.986]                       base::local({
[16:04:44.986]                         has_future <- base::requireNamespace("future", 
[16:04:44.986]                           quietly = TRUE)
[16:04:44.986]                         if (has_future) {
[16:04:44.986]                           ns <- base::getNamespace("future")
[16:04:44.986]                           version <- ns[[".package"]][["version"]]
[16:04:44.986]                           if (is.null(version)) 
[16:04:44.986]                             version <- utils::packageVersion("future")
[16:04:44.986]                         }
[16:04:44.986]                         else {
[16:04:44.986]                           version <- NULL
[16:04:44.986]                         }
[16:04:44.986]                         if (!has_future || version < "1.8.0") {
[16:04:44.986]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:44.986]                             "", base::R.version$version.string), 
[16:04:44.986]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:44.986]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:44.986]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:44.986]                               "release", "version")], collapse = " "), 
[16:04:44.986]                             hostname = base::Sys.info()[["nodename"]])
[16:04:44.986]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:44.986]                             info)
[16:04:44.986]                           info <- base::paste(info, collapse = "; ")
[16:04:44.986]                           if (!has_future) {
[16:04:44.986]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:44.986]                               info)
[16:04:44.986]                           }
[16:04:44.986]                           else {
[16:04:44.986]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:44.986]                               info, version)
[16:04:44.986]                           }
[16:04:44.986]                           base::stop(msg)
[16:04:44.986]                         }
[16:04:44.986]                       })
[16:04:44.986]                     }
[16:04:44.986]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:44.986]                     base::options(mc.cores = 1L)
[16:04:44.986]                   }
[16:04:44.986]                   options(future.plan = NULL)
[16:04:44.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:44.986]                 }
[16:04:44.986]                 ...future.workdir <- getwd()
[16:04:44.986]             }
[16:04:44.986]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:44.986]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:44.986]         }
[16:04:44.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:44.986]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:44.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:44.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:44.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:44.986]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:44.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:44.986]             base::names(...future.oldOptions))
[16:04:44.986]     }
[16:04:44.986]     if (FALSE) {
[16:04:44.986]     }
[16:04:44.986]     else {
[16:04:44.986]         if (TRUE) {
[16:04:44.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:44.986]                 open = "w")
[16:04:44.986]         }
[16:04:44.986]         else {
[16:04:44.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:44.986]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:44.986]         }
[16:04:44.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:44.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:44.986]             base::sink(type = "output", split = FALSE)
[16:04:44.986]             base::close(...future.stdout)
[16:04:44.986]         }, add = TRUE)
[16:04:44.986]     }
[16:04:44.986]     ...future.frame <- base::sys.nframe()
[16:04:44.986]     ...future.conditions <- base::list()
[16:04:44.986]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:44.986]     if (FALSE) {
[16:04:44.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:44.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:44.986]     }
[16:04:44.986]     ...future.result <- base::tryCatch({
[16:04:44.986]         base::withCallingHandlers({
[16:04:44.986]             ...future.value <- base::withVisible(base::local({
[16:04:44.986]                 withCallingHandlers({
[16:04:44.986]                   {
[16:04:44.986]                     4
[16:04:44.986]                   }
[16:04:44.986]                 }, immediateCondition = function(cond) {
[16:04:44.986]                   save_rds <- function (object, pathname, ...) 
[16:04:44.986]                   {
[16:04:44.986]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:44.986]                     if (file_test("-f", pathname_tmp)) {
[16:04:44.986]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.986]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:44.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.986]                         fi_tmp[["mtime"]])
[16:04:44.986]                     }
[16:04:44.986]                     tryCatch({
[16:04:44.986]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:44.986]                     }, error = function(ex) {
[16:04:44.986]                       msg <- conditionMessage(ex)
[16:04:44.986]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.986]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:44.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.986]                         fi_tmp[["mtime"]], msg)
[16:04:44.986]                       ex$message <- msg
[16:04:44.986]                       stop(ex)
[16:04:44.986]                     })
[16:04:44.986]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:44.986]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:44.986]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:44.986]                       fi_tmp <- file.info(pathname_tmp)
[16:04:44.986]                       fi <- file.info(pathname)
[16:04:44.986]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:44.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:44.986]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:44.986]                         fi[["size"]], fi[["mtime"]])
[16:04:44.986]                       stop(msg)
[16:04:44.986]                     }
[16:04:44.986]                     invisible(pathname)
[16:04:44.986]                   }
[16:04:44.986]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:44.986]                     rootPath = tempdir()) 
[16:04:44.986]                   {
[16:04:44.986]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:44.986]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:44.986]                       tmpdir = path, fileext = ".rds")
[16:04:44.986]                     save_rds(obj, file)
[16:04:44.986]                   }
[16:04:44.986]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:44.986]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.986]                   {
[16:04:44.986]                     inherits <- base::inherits
[16:04:44.986]                     invokeRestart <- base::invokeRestart
[16:04:44.986]                     is.null <- base::is.null
[16:04:44.986]                     muffled <- FALSE
[16:04:44.986]                     if (inherits(cond, "message")) {
[16:04:44.986]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:44.986]                       if (muffled) 
[16:04:44.986]                         invokeRestart("muffleMessage")
[16:04:44.986]                     }
[16:04:44.986]                     else if (inherits(cond, "warning")) {
[16:04:44.986]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:44.986]                       if (muffled) 
[16:04:44.986]                         invokeRestart("muffleWarning")
[16:04:44.986]                     }
[16:04:44.986]                     else if (inherits(cond, "condition")) {
[16:04:44.986]                       if (!is.null(pattern)) {
[16:04:44.986]                         computeRestarts <- base::computeRestarts
[16:04:44.986]                         grepl <- base::grepl
[16:04:44.986]                         restarts <- computeRestarts(cond)
[16:04:44.986]                         for (restart in restarts) {
[16:04:44.986]                           name <- restart$name
[16:04:44.986]                           if (is.null(name)) 
[16:04:44.986]                             next
[16:04:44.986]                           if (!grepl(pattern, name)) 
[16:04:44.986]                             next
[16:04:44.986]                           invokeRestart(restart)
[16:04:44.986]                           muffled <- TRUE
[16:04:44.986]                           break
[16:04:44.986]                         }
[16:04:44.986]                       }
[16:04:44.986]                     }
[16:04:44.986]                     invisible(muffled)
[16:04:44.986]                   }
[16:04:44.986]                   muffleCondition(cond)
[16:04:44.986]                 })
[16:04:44.986]             }))
[16:04:44.986]             future::FutureResult(value = ...future.value$value, 
[16:04:44.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.986]                   ...future.rng), globalenv = if (FALSE) 
[16:04:44.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:44.986]                     ...future.globalenv.names))
[16:04:44.986]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:44.986]         }, condition = base::local({
[16:04:44.986]             c <- base::c
[16:04:44.986]             inherits <- base::inherits
[16:04:44.986]             invokeRestart <- base::invokeRestart
[16:04:44.986]             length <- base::length
[16:04:44.986]             list <- base::list
[16:04:44.986]             seq.int <- base::seq.int
[16:04:44.986]             signalCondition <- base::signalCondition
[16:04:44.986]             sys.calls <- base::sys.calls
[16:04:44.986]             `[[` <- base::`[[`
[16:04:44.986]             `+` <- base::`+`
[16:04:44.986]             `<<-` <- base::`<<-`
[16:04:44.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:44.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:44.986]                   3L)]
[16:04:44.986]             }
[16:04:44.986]             function(cond) {
[16:04:44.986]                 is_error <- inherits(cond, "error")
[16:04:44.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:44.986]                   NULL)
[16:04:44.986]                 if (is_error) {
[16:04:44.986]                   sessionInformation <- function() {
[16:04:44.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:44.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:44.986]                       search = base::search(), system = base::Sys.info())
[16:04:44.986]                   }
[16:04:44.986]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:44.986]                     cond$call), session = sessionInformation(), 
[16:04:44.986]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:44.986]                   signalCondition(cond)
[16:04:44.986]                 }
[16:04:44.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:44.986]                 "immediateCondition"))) {
[16:04:44.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:44.986]                   ...future.conditions[[length(...future.conditions) + 
[16:04:44.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:44.986]                   if (TRUE && !signal) {
[16:04:44.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.986]                     {
[16:04:44.986]                       inherits <- base::inherits
[16:04:44.986]                       invokeRestart <- base::invokeRestart
[16:04:44.986]                       is.null <- base::is.null
[16:04:44.986]                       muffled <- FALSE
[16:04:44.986]                       if (inherits(cond, "message")) {
[16:04:44.986]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.986]                         if (muffled) 
[16:04:44.986]                           invokeRestart("muffleMessage")
[16:04:44.986]                       }
[16:04:44.986]                       else if (inherits(cond, "warning")) {
[16:04:44.986]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.986]                         if (muffled) 
[16:04:44.986]                           invokeRestart("muffleWarning")
[16:04:44.986]                       }
[16:04:44.986]                       else if (inherits(cond, "condition")) {
[16:04:44.986]                         if (!is.null(pattern)) {
[16:04:44.986]                           computeRestarts <- base::computeRestarts
[16:04:44.986]                           grepl <- base::grepl
[16:04:44.986]                           restarts <- computeRestarts(cond)
[16:04:44.986]                           for (restart in restarts) {
[16:04:44.986]                             name <- restart$name
[16:04:44.986]                             if (is.null(name)) 
[16:04:44.986]                               next
[16:04:44.986]                             if (!grepl(pattern, name)) 
[16:04:44.986]                               next
[16:04:44.986]                             invokeRestart(restart)
[16:04:44.986]                             muffled <- TRUE
[16:04:44.986]                             break
[16:04:44.986]                           }
[16:04:44.986]                         }
[16:04:44.986]                       }
[16:04:44.986]                       invisible(muffled)
[16:04:44.986]                     }
[16:04:44.986]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.986]                   }
[16:04:44.986]                 }
[16:04:44.986]                 else {
[16:04:44.986]                   if (TRUE) {
[16:04:44.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:44.986]                     {
[16:04:44.986]                       inherits <- base::inherits
[16:04:44.986]                       invokeRestart <- base::invokeRestart
[16:04:44.986]                       is.null <- base::is.null
[16:04:44.986]                       muffled <- FALSE
[16:04:44.986]                       if (inherits(cond, "message")) {
[16:04:44.986]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:44.986]                         if (muffled) 
[16:04:44.986]                           invokeRestart("muffleMessage")
[16:04:44.986]                       }
[16:04:44.986]                       else if (inherits(cond, "warning")) {
[16:04:44.986]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:44.986]                         if (muffled) 
[16:04:44.986]                           invokeRestart("muffleWarning")
[16:04:44.986]                       }
[16:04:44.986]                       else if (inherits(cond, "condition")) {
[16:04:44.986]                         if (!is.null(pattern)) {
[16:04:44.986]                           computeRestarts <- base::computeRestarts
[16:04:44.986]                           grepl <- base::grepl
[16:04:44.986]                           restarts <- computeRestarts(cond)
[16:04:44.986]                           for (restart in restarts) {
[16:04:44.986]                             name <- restart$name
[16:04:44.986]                             if (is.null(name)) 
[16:04:44.986]                               next
[16:04:44.986]                             if (!grepl(pattern, name)) 
[16:04:44.986]                               next
[16:04:44.986]                             invokeRestart(restart)
[16:04:44.986]                             muffled <- TRUE
[16:04:44.986]                             break
[16:04:44.986]                           }
[16:04:44.986]                         }
[16:04:44.986]                       }
[16:04:44.986]                       invisible(muffled)
[16:04:44.986]                     }
[16:04:44.986]                     muffleCondition(cond, pattern = "^muffle")
[16:04:44.986]                   }
[16:04:44.986]                 }
[16:04:44.986]             }
[16:04:44.986]         }))
[16:04:44.986]     }, error = function(ex) {
[16:04:44.986]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:44.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:44.986]                 ...future.rng), started = ...future.startTime, 
[16:04:44.986]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:44.986]             version = "1.8"), class = "FutureResult")
[16:04:44.986]     }, finally = {
[16:04:44.986]         if (!identical(...future.workdir, getwd())) 
[16:04:44.986]             setwd(...future.workdir)
[16:04:44.986]         {
[16:04:44.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:44.986]                 ...future.oldOptions$nwarnings <- NULL
[16:04:44.986]             }
[16:04:44.986]             base::options(...future.oldOptions)
[16:04:44.986]             if (.Platform$OS.type == "windows") {
[16:04:44.986]                 old_names <- names(...future.oldEnvVars)
[16:04:44.986]                 envs <- base::Sys.getenv()
[16:04:44.986]                 names <- names(envs)
[16:04:44.986]                 common <- intersect(names, old_names)
[16:04:44.986]                 added <- setdiff(names, old_names)
[16:04:44.986]                 removed <- setdiff(old_names, names)
[16:04:44.986]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:44.986]                   envs[common]]
[16:04:44.986]                 NAMES <- toupper(changed)
[16:04:44.986]                 args <- list()
[16:04:44.986]                 for (kk in seq_along(NAMES)) {
[16:04:44.986]                   name <- changed[[kk]]
[16:04:44.986]                   NAME <- NAMES[[kk]]
[16:04:44.986]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.986]                     next
[16:04:44.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.986]                 }
[16:04:44.986]                 NAMES <- toupper(added)
[16:04:44.986]                 for (kk in seq_along(NAMES)) {
[16:04:44.986]                   name <- added[[kk]]
[16:04:44.986]                   NAME <- NAMES[[kk]]
[16:04:44.986]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.986]                     next
[16:04:44.986]                   args[[name]] <- ""
[16:04:44.986]                 }
[16:04:44.986]                 NAMES <- toupper(removed)
[16:04:44.986]                 for (kk in seq_along(NAMES)) {
[16:04:44.986]                   name <- removed[[kk]]
[16:04:44.986]                   NAME <- NAMES[[kk]]
[16:04:44.986]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:44.986]                     next
[16:04:44.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:44.986]                 }
[16:04:44.986]                 if (length(args) > 0) 
[16:04:44.986]                   base::do.call(base::Sys.setenv, args = args)
[16:04:44.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:44.986]             }
[16:04:44.986]             else {
[16:04:44.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:44.986]             }
[16:04:44.986]             {
[16:04:44.986]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:44.986]                   0L) {
[16:04:44.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:44.986]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:44.986]                   base::options(opts)
[16:04:44.986]                 }
[16:04:44.986]                 {
[16:04:44.986]                   {
[16:04:44.986]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:44.986]                     NULL
[16:04:44.986]                   }
[16:04:44.986]                   options(future.plan = NULL)
[16:04:44.986]                   if (is.na(NA_character_)) 
[16:04:44.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:44.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:44.986]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:44.986]                     envir = parent.frame()) 
[16:04:44.986]                   {
[16:04:44.986]                     default_workers <- missing(workers)
[16:04:44.986]                     if (is.function(workers)) 
[16:04:44.986]                       workers <- workers()
[16:04:44.986]                     workers <- structure(as.integer(workers), 
[16:04:44.986]                       class = class(workers))
[16:04:44.986]                     stop_if_not(is.finite(workers), workers >= 
[16:04:44.986]                       1L)
[16:04:44.986]                     if ((workers == 1L && !inherits(workers, 
[16:04:44.986]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:44.986]                       if (default_workers) 
[16:04:44.986]                         supportsMulticore(warn = TRUE)
[16:04:44.986]                       return(sequential(..., envir = envir))
[16:04:44.986]                     }
[16:04:44.986]                     oopts <- options(mc.cores = workers)
[16:04:44.986]                     on.exit(options(oopts))
[16:04:44.986]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:44.986]                       envir = envir)
[16:04:44.986]                     if (!future$lazy) 
[16:04:44.986]                       future <- run(future)
[16:04:44.986]                     invisible(future)
[16:04:44.986]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:44.986]                 }
[16:04:44.986]             }
[16:04:44.986]         }
[16:04:44.986]     })
[16:04:44.986]     if (TRUE) {
[16:04:44.986]         base::sink(type = "output", split = FALSE)
[16:04:44.986]         if (TRUE) {
[16:04:44.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:44.986]         }
[16:04:44.986]         else {
[16:04:44.986]             ...future.result["stdout"] <- base::list(NULL)
[16:04:44.986]         }
[16:04:44.986]         base::close(...future.stdout)
[16:04:44.986]         ...future.stdout <- NULL
[16:04:44.986]     }
[16:04:44.986]     ...future.result$conditions <- ...future.conditions
[16:04:44.986]     ...future.result$finished <- base::Sys.time()
[16:04:44.986]     ...future.result
[16:04:44.986] }
[16:04:44.990] requestCore(): workers = 2
[16:04:44.990] Poll #1 (0): usedCores() = 2, workers = 2
[16:04:45.001] result() for MulticoreFuture ...
[16:04:45.002] result() for MulticoreFuture ...
[16:04:45.002] result() for MulticoreFuture ... done
[16:04:45.002] result() for MulticoreFuture ... done
[16:04:45.002] result() for MulticoreFuture ...
[16:04:45.002] result() for MulticoreFuture ... done
[16:04:45.005] MulticoreFuture started
[16:04:45.005] - Launch lazy future ... done
[16:04:45.006] run() for ‘MulticoreFuture’ ... done
[16:04:45.006] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55874c99d670> 
[16:04:45.007] List of future strategies:
[16:04:45.007] 1. sequential:
[16:04:45.007]    - args: function (..., envir = parent.frame())
[16:04:45.007]    - tweaked: FALSE
[16:04:45.007]    - call: NULL
[16:04:45.008] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55874f63efa8> 
 - attr(*, "dim.")=[16:04:45.011] plan(): Setting new future strategy stack:
 int [1:2] 1 6
 - attr(*, "dimnames.")=[16:04:45.011] List of future strategies:
[16:04:45.011] 1. multicore:
[16:04:45.011]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:45.011]    - tweaked: FALSE
[16:04:45.011]    - call: plan(strategy)
List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:04:45.017] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:45.021] resolve() on list environment ...
[16:04:45.021]  recursive: 0
[16:04:45.022]  length: 6
[16:04:45.022]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:45.022] signalConditionsASAP(numeric, pos=1) ...
[16:04:45.023] - nx: 6
[16:04:45.023] - relay: TRUE
[16:04:45.023] - stdout: TRUE
[16:04:45.023] - signal: TRUE
[16:04:45.023] - resignal: FALSE
[16:04:45.023] - force: TRUE
[16:04:45.023] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.023] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.024]  - until=2
[16:04:45.024]  - relaying element #2
[16:04:45.024] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.024] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.024] signalConditionsASAP(NULL, pos=1) ... done
[16:04:45.024]  length: 5 (resolved future 1)
[16:04:45.024] Future #2
[16:04:45.025] result() for MulticoreFuture ...
[16:04:45.025] result() for MulticoreFuture ... done
[16:04:45.025] result() for MulticoreFuture ...
[16:04:45.025] result() for MulticoreFuture ... done
[16:04:45.025] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:45.025] - nx: 6
[16:04:45.025] - relay: TRUE
[16:04:45.026] - stdout: TRUE
[16:04:45.026] - signal: TRUE
[16:04:45.026] - resignal: FALSE
[16:04:45.026] - force: TRUE
[16:04:45.026] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.026] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.026]  - until=2
[16:04:45.026]  - relaying element #2
[16:04:45.027] result() for MulticoreFuture ...
[16:04:45.027] result() for MulticoreFuture ... done
[16:04:45.027] result() for MulticoreFuture ...
[16:04:45.027] result() for MulticoreFuture ... done
[16:04:45.027] result() for MulticoreFuture ...
[16:04:45.027] result() for MulticoreFuture ... done
[16:04:45.027] result() for MulticoreFuture ...
[16:04:45.027] result() for MulticoreFuture ... done
[16:04:45.028] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.028] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.028] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:45.028]  length: 4 (resolved future 2)
[16:04:45.028] Future #3
[16:04:45.028] result() for MulticoreFuture ...
[16:04:45.029] result() for MulticoreFuture ...
[16:04:45.029] result() for MulticoreFuture ... done
[16:04:45.030] result() for MulticoreFuture ... done
[16:04:45.030] result() for MulticoreFuture ...
[16:04:45.030] result() for MulticoreFuture ... done
[16:04:45.030] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:45.030] - nx: 6
[16:04:45.030] - relay: TRUE
[16:04:45.030] - stdout: TRUE
[16:04:45.031] - signal: TRUE
[16:04:45.031] - resignal: FALSE
[16:04:45.031] - force: TRUE
[16:04:45.031] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.031] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.031]  - until=3
[16:04:45.031]  - relaying element #3
[16:04:45.031] result() for MulticoreFuture ...
[16:04:45.032] result() for MulticoreFuture ... done
[16:04:45.039] result() for MulticoreFuture ...
[16:04:45.039] result() for MulticoreFuture ... done
[16:04:45.040] result() for MulticoreFuture ...
[16:04:45.040] result() for MulticoreFuture ... done
[16:04:45.040] result() for MulticoreFuture ...
[16:04:45.041] result() for MulticoreFuture ... done
[16:04:45.041] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.041] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.041] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:45.041]  length: 3 (resolved future 3)
[16:04:45.042] Future #4
[16:04:45.042] result() for MulticoreFuture ...
[16:04:45.043] result() for MulticoreFuture ...
[16:04:45.043] result() for MulticoreFuture ... done
[16:04:45.043] result() for MulticoreFuture ... done
[16:04:45.043] result() for MulticoreFuture ...
[16:04:45.043] result() for MulticoreFuture ... done
[16:04:45.044] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:04:45.044] - nx: 6
[16:04:45.044] - relay: TRUE
[16:04:45.044] - stdout: TRUE
[16:04:45.044] - signal: TRUE
[16:04:45.045] - resignal: FALSE
[16:04:45.045] - force: TRUE
[16:04:45.045] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.045] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.045]  - until=4
[16:04:45.045]  - relaying element #4
[16:04:45.046] result() for MulticoreFuture ...
[16:04:45.046] result() for MulticoreFuture ... done
[16:04:45.046] result() for MulticoreFuture ...
[16:04:45.046] result() for MulticoreFuture ... done
[16:04:45.046] result() for MulticoreFuture ...
[16:04:45.046] result() for MulticoreFuture ... done
[16:04:45.046] result() for MulticoreFuture ...
[16:04:45.047] result() for MulticoreFuture ... done
[16:04:45.047] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.047] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.047] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:04:45.047]  length: 2 (resolved future 4)
[16:04:45.047] signalConditionsASAP(NULL, pos=5) ...
[16:04:45.048] - nx: 6
[16:04:45.048] - relay: TRUE
[16:04:45.048] - stdout: TRUE
[16:04:45.048] - signal: TRUE
[16:04:45.048] - resignal: FALSE
[16:04:45.048] - force: TRUE
[16:04:45.048] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.048] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.048]  - until=6
[16:04:45.048]  - relaying element #6
[16:04:45.048] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:45.049] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.049] signalConditionsASAP(NULL, pos=5) ... done
[16:04:45.049]  length: 1 (resolved future 5)
[16:04:45.049] signalConditionsASAP(numeric, pos=6) ...
[16:04:45.049] - nx: 6
[16:04:45.049] - relay: TRUE
[16:04:45.049] - stdout: TRUE
[16:04:45.049] - signal: TRUE
[16:04:45.049] - resignal: FALSE
[16:04:45.049] - force: TRUE
[16:04:45.050] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:45.050] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.050]  - until=6
[16:04:45.050] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:45.050] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.050] signalConditionsASAP(numeric, pos=6) ... done
[16:04:45.050]  length: 0 (resolved future 6)
[16:04:45.050] Relaying remaining futures
[16:04:45.050] signalConditionsASAP(NULL, pos=0) ...
[16:04:45.050] - nx: 6
[16:04:45.051] - relay: TRUE
[16:04:45.051] - stdout: TRUE
[16:04:45.051] - signal: TRUE
[16:04:45.051] - resignal: FALSE
[16:04:45.051] - force: TRUE
[16:04:45.051] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:45.051] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:45.051] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:45.051] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.052] signalConditionsASAP(NULL, pos=0) ... done
[16:04:45.052] resolve() on list environment ... DONE
[16:04:45.052] result() for MulticoreFuture ...
[16:04:45.052] result() for MulticoreFuture ... done
[16:04:45.052] result() for MulticoreFuture ...
[16:04:45.052] result() for MulticoreFuture ... done
[16:04:45.052] result() for MulticoreFuture ...
[16:04:45.052] result() for MulticoreFuture ... done
[16:04:45.053] result() for MulticoreFuture ...
[16:04:45.053] result() for MulticoreFuture ... done
[16:04:45.053] result() for MulticoreFuture ...
[16:04:45.053] result() for MulticoreFuture ... done
[16:04:45.053] result() for MulticoreFuture ...
[16:04:45.053] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55874f89bc18> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:04:45.055] getGlobalsAndPackages() ...
[16:04:45.055] Searching for globals...
[16:04:45.056] 
[16:04:45.056] Searching for globals ... DONE
[16:04:45.056] - globals: [0] <none>
[16:04:45.056] getGlobalsAndPackages() ... DONE
[16:04:45.056] run() for ‘Future’ ...
[16:04:45.056] - state: ‘created’
[16:04:45.057] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:45.061] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:45.061] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:45.061]   - Field: ‘label’
[16:04:45.061]   - Field: ‘local’
[16:04:45.061]   - Field: ‘owner’
[16:04:45.061]   - Field: ‘envir’
[16:04:45.061]   - Field: ‘workers’
[16:04:45.061]   - Field: ‘packages’
[16:04:45.062]   - Field: ‘gc’
[16:04:45.062]   - Field: ‘job’
[16:04:45.062]   - Field: ‘conditions’
[16:04:45.062]   - Field: ‘expr’
[16:04:45.062]   - Field: ‘uuid’
[16:04:45.062]   - Field: ‘seed’
[16:04:45.062]   - Field: ‘version’
[16:04:45.062]   - Field: ‘result’
[16:04:45.062]   - Field: ‘asynchronous’
[16:04:45.063]   - Field: ‘calls’
[16:04:45.063]   - Field: ‘globals’
[16:04:45.063]   - Field: ‘stdout’
[16:04:45.063]   - Field: ‘earlySignal’
[16:04:45.063]   - Field: ‘lazy’
[16:04:45.063]   - Field: ‘state’
[16:04:45.063] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:45.063] - Launch lazy future ...
[16:04:45.064] Packages needed by the future expression (n = 0): <none>
[16:04:45.064] Packages needed by future strategies (n = 0): <none>
[16:04:45.064] {
[16:04:45.064]     {
[16:04:45.064]         {
[16:04:45.064]             ...future.startTime <- base::Sys.time()
[16:04:45.064]             {
[16:04:45.064]                 {
[16:04:45.064]                   {
[16:04:45.064]                     {
[16:04:45.064]                       base::local({
[16:04:45.064]                         has_future <- base::requireNamespace("future", 
[16:04:45.064]                           quietly = TRUE)
[16:04:45.064]                         if (has_future) {
[16:04:45.064]                           ns <- base::getNamespace("future")
[16:04:45.064]                           version <- ns[[".package"]][["version"]]
[16:04:45.064]                           if (is.null(version)) 
[16:04:45.064]                             version <- utils::packageVersion("future")
[16:04:45.064]                         }
[16:04:45.064]                         else {
[16:04:45.064]                           version <- NULL
[16:04:45.064]                         }
[16:04:45.064]                         if (!has_future || version < "1.8.0") {
[16:04:45.064]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.064]                             "", base::R.version$version.string), 
[16:04:45.064]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.064]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.064]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.064]                               "release", "version")], collapse = " "), 
[16:04:45.064]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.064]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.064]                             info)
[16:04:45.064]                           info <- base::paste(info, collapse = "; ")
[16:04:45.064]                           if (!has_future) {
[16:04:45.064]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.064]                               info)
[16:04:45.064]                           }
[16:04:45.064]                           else {
[16:04:45.064]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.064]                               info, version)
[16:04:45.064]                           }
[16:04:45.064]                           base::stop(msg)
[16:04:45.064]                         }
[16:04:45.064]                       })
[16:04:45.064]                     }
[16:04:45.064]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.064]                     base::options(mc.cores = 1L)
[16:04:45.064]                   }
[16:04:45.064]                   options(future.plan = NULL)
[16:04:45.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.064]                 }
[16:04:45.064]                 ...future.workdir <- getwd()
[16:04:45.064]             }
[16:04:45.064]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.064]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.064]         }
[16:04:45.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.064]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.064]             base::names(...future.oldOptions))
[16:04:45.064]     }
[16:04:45.064]     if (FALSE) {
[16:04:45.064]     }
[16:04:45.064]     else {
[16:04:45.064]         if (TRUE) {
[16:04:45.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.064]                 open = "w")
[16:04:45.064]         }
[16:04:45.064]         else {
[16:04:45.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.064]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.064]         }
[16:04:45.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.064]             base::sink(type = "output", split = FALSE)
[16:04:45.064]             base::close(...future.stdout)
[16:04:45.064]         }, add = TRUE)
[16:04:45.064]     }
[16:04:45.064]     ...future.frame <- base::sys.nframe()
[16:04:45.064]     ...future.conditions <- base::list()
[16:04:45.064]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.064]     if (FALSE) {
[16:04:45.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.064]     }
[16:04:45.064]     ...future.result <- base::tryCatch({
[16:04:45.064]         base::withCallingHandlers({
[16:04:45.064]             ...future.value <- base::withVisible(base::local({
[16:04:45.064]                 withCallingHandlers({
[16:04:45.064]                   2
[16:04:45.064]                 }, immediateCondition = function(cond) {
[16:04:45.064]                   save_rds <- function (object, pathname, ...) 
[16:04:45.064]                   {
[16:04:45.064]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:45.064]                     if (file_test("-f", pathname_tmp)) {
[16:04:45.064]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.064]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:45.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.064]                         fi_tmp[["mtime"]])
[16:04:45.064]                     }
[16:04:45.064]                     tryCatch({
[16:04:45.064]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:45.064]                     }, error = function(ex) {
[16:04:45.064]                       msg <- conditionMessage(ex)
[16:04:45.064]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.064]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:45.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.064]                         fi_tmp[["mtime"]], msg)
[16:04:45.064]                       ex$message <- msg
[16:04:45.064]                       stop(ex)
[16:04:45.064]                     })
[16:04:45.064]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:45.064]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:45.064]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:45.064]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.064]                       fi <- file.info(pathname)
[16:04:45.064]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:45.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.064]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:45.064]                         fi[["size"]], fi[["mtime"]])
[16:04:45.064]                       stop(msg)
[16:04:45.064]                     }
[16:04:45.064]                     invisible(pathname)
[16:04:45.064]                   }
[16:04:45.064]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:45.064]                     rootPath = tempdir()) 
[16:04:45.064]                   {
[16:04:45.064]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:45.064]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:45.064]                       tmpdir = path, fileext = ".rds")
[16:04:45.064]                     save_rds(obj, file)
[16:04:45.064]                   }
[16:04:45.064]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:45.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.064]                   {
[16:04:45.064]                     inherits <- base::inherits
[16:04:45.064]                     invokeRestart <- base::invokeRestart
[16:04:45.064]                     is.null <- base::is.null
[16:04:45.064]                     muffled <- FALSE
[16:04:45.064]                     if (inherits(cond, "message")) {
[16:04:45.064]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.064]                       if (muffled) 
[16:04:45.064]                         invokeRestart("muffleMessage")
[16:04:45.064]                     }
[16:04:45.064]                     else if (inherits(cond, "warning")) {
[16:04:45.064]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.064]                       if (muffled) 
[16:04:45.064]                         invokeRestart("muffleWarning")
[16:04:45.064]                     }
[16:04:45.064]                     else if (inherits(cond, "condition")) {
[16:04:45.064]                       if (!is.null(pattern)) {
[16:04:45.064]                         computeRestarts <- base::computeRestarts
[16:04:45.064]                         grepl <- base::grepl
[16:04:45.064]                         restarts <- computeRestarts(cond)
[16:04:45.064]                         for (restart in restarts) {
[16:04:45.064]                           name <- restart$name
[16:04:45.064]                           if (is.null(name)) 
[16:04:45.064]                             next
[16:04:45.064]                           if (!grepl(pattern, name)) 
[16:04:45.064]                             next
[16:04:45.064]                           invokeRestart(restart)
[16:04:45.064]                           muffled <- TRUE
[16:04:45.064]                           break
[16:04:45.064]                         }
[16:04:45.064]                       }
[16:04:45.064]                     }
[16:04:45.064]                     invisible(muffled)
[16:04:45.064]                   }
[16:04:45.064]                   muffleCondition(cond)
[16:04:45.064]                 })
[16:04:45.064]             }))
[16:04:45.064]             future::FutureResult(value = ...future.value$value, 
[16:04:45.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.064]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.064]                     ...future.globalenv.names))
[16:04:45.064]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.064]         }, condition = base::local({
[16:04:45.064]             c <- base::c
[16:04:45.064]             inherits <- base::inherits
[16:04:45.064]             invokeRestart <- base::invokeRestart
[16:04:45.064]             length <- base::length
[16:04:45.064]             list <- base::list
[16:04:45.064]             seq.int <- base::seq.int
[16:04:45.064]             signalCondition <- base::signalCondition
[16:04:45.064]             sys.calls <- base::sys.calls
[16:04:45.064]             `[[` <- base::`[[`
[16:04:45.064]             `+` <- base::`+`
[16:04:45.064]             `<<-` <- base::`<<-`
[16:04:45.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.064]                   3L)]
[16:04:45.064]             }
[16:04:45.064]             function(cond) {
[16:04:45.064]                 is_error <- inherits(cond, "error")
[16:04:45.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.064]                   NULL)
[16:04:45.064]                 if (is_error) {
[16:04:45.064]                   sessionInformation <- function() {
[16:04:45.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.064]                       search = base::search(), system = base::Sys.info())
[16:04:45.064]                   }
[16:04:45.064]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.064]                     cond$call), session = sessionInformation(), 
[16:04:45.064]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.064]                   signalCondition(cond)
[16:04:45.064]                 }
[16:04:45.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.064]                 "immediateCondition"))) {
[16:04:45.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.064]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.064]                   if (TRUE && !signal) {
[16:04:45.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.064]                     {
[16:04:45.064]                       inherits <- base::inherits
[16:04:45.064]                       invokeRestart <- base::invokeRestart
[16:04:45.064]                       is.null <- base::is.null
[16:04:45.064]                       muffled <- FALSE
[16:04:45.064]                       if (inherits(cond, "message")) {
[16:04:45.064]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.064]                         if (muffled) 
[16:04:45.064]                           invokeRestart("muffleMessage")
[16:04:45.064]                       }
[16:04:45.064]                       else if (inherits(cond, "warning")) {
[16:04:45.064]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.064]                         if (muffled) 
[16:04:45.064]                           invokeRestart("muffleWarning")
[16:04:45.064]                       }
[16:04:45.064]                       else if (inherits(cond, "condition")) {
[16:04:45.064]                         if (!is.null(pattern)) {
[16:04:45.064]                           computeRestarts <- base::computeRestarts
[16:04:45.064]                           grepl <- base::grepl
[16:04:45.064]                           restarts <- computeRestarts(cond)
[16:04:45.064]                           for (restart in restarts) {
[16:04:45.064]                             name <- restart$name
[16:04:45.064]                             if (is.null(name)) 
[16:04:45.064]                               next
[16:04:45.064]                             if (!grepl(pattern, name)) 
[16:04:45.064]                               next
[16:04:45.064]                             invokeRestart(restart)
[16:04:45.064]                             muffled <- TRUE
[16:04:45.064]                             break
[16:04:45.064]                           }
[16:04:45.064]                         }
[16:04:45.064]                       }
[16:04:45.064]                       invisible(muffled)
[16:04:45.064]                     }
[16:04:45.064]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.064]                   }
[16:04:45.064]                 }
[16:04:45.064]                 else {
[16:04:45.064]                   if (TRUE) {
[16:04:45.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.064]                     {
[16:04:45.064]                       inherits <- base::inherits
[16:04:45.064]                       invokeRestart <- base::invokeRestart
[16:04:45.064]                       is.null <- base::is.null
[16:04:45.064]                       muffled <- FALSE
[16:04:45.064]                       if (inherits(cond, "message")) {
[16:04:45.064]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.064]                         if (muffled) 
[16:04:45.064]                           invokeRestart("muffleMessage")
[16:04:45.064]                       }
[16:04:45.064]                       else if (inherits(cond, "warning")) {
[16:04:45.064]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.064]                         if (muffled) 
[16:04:45.064]                           invokeRestart("muffleWarning")
[16:04:45.064]                       }
[16:04:45.064]                       else if (inherits(cond, "condition")) {
[16:04:45.064]                         if (!is.null(pattern)) {
[16:04:45.064]                           computeRestarts <- base::computeRestarts
[16:04:45.064]                           grepl <- base::grepl
[16:04:45.064]                           restarts <- computeRestarts(cond)
[16:04:45.064]                           for (restart in restarts) {
[16:04:45.064]                             name <- restart$name
[16:04:45.064]                             if (is.null(name)) 
[16:04:45.064]                               next
[16:04:45.064]                             if (!grepl(pattern, name)) 
[16:04:45.064]                               next
[16:04:45.064]                             invokeRestart(restart)
[16:04:45.064]                             muffled <- TRUE
[16:04:45.064]                             break
[16:04:45.064]                           }
[16:04:45.064]                         }
[16:04:45.064]                       }
[16:04:45.064]                       invisible(muffled)
[16:04:45.064]                     }
[16:04:45.064]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.064]                   }
[16:04:45.064]                 }
[16:04:45.064]             }
[16:04:45.064]         }))
[16:04:45.064]     }, error = function(ex) {
[16:04:45.064]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.064]                 ...future.rng), started = ...future.startTime, 
[16:04:45.064]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.064]             version = "1.8"), class = "FutureResult")
[16:04:45.064]     }, finally = {
[16:04:45.064]         if (!identical(...future.workdir, getwd())) 
[16:04:45.064]             setwd(...future.workdir)
[16:04:45.064]         {
[16:04:45.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.064]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.064]             }
[16:04:45.064]             base::options(...future.oldOptions)
[16:04:45.064]             if (.Platform$OS.type == "windows") {
[16:04:45.064]                 old_names <- names(...future.oldEnvVars)
[16:04:45.064]                 envs <- base::Sys.getenv()
[16:04:45.064]                 names <- names(envs)
[16:04:45.064]                 common <- intersect(names, old_names)
[16:04:45.064]                 added <- setdiff(names, old_names)
[16:04:45.064]                 removed <- setdiff(old_names, names)
[16:04:45.064]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.064]                   envs[common]]
[16:04:45.064]                 NAMES <- toupper(changed)
[16:04:45.064]                 args <- list()
[16:04:45.064]                 for (kk in seq_along(NAMES)) {
[16:04:45.064]                   name <- changed[[kk]]
[16:04:45.064]                   NAME <- NAMES[[kk]]
[16:04:45.064]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.064]                     next
[16:04:45.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.064]                 }
[16:04:45.064]                 NAMES <- toupper(added)
[16:04:45.064]                 for (kk in seq_along(NAMES)) {
[16:04:45.064]                   name <- added[[kk]]
[16:04:45.064]                   NAME <- NAMES[[kk]]
[16:04:45.064]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.064]                     next
[16:04:45.064]                   args[[name]] <- ""
[16:04:45.064]                 }
[16:04:45.064]                 NAMES <- toupper(removed)
[16:04:45.064]                 for (kk in seq_along(NAMES)) {
[16:04:45.064]                   name <- removed[[kk]]
[16:04:45.064]                   NAME <- NAMES[[kk]]
[16:04:45.064]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.064]                     next
[16:04:45.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.064]                 }
[16:04:45.064]                 if (length(args) > 0) 
[16:04:45.064]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.064]             }
[16:04:45.064]             else {
[16:04:45.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.064]             }
[16:04:45.064]             {
[16:04:45.064]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.064]                   0L) {
[16:04:45.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.064]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.064]                   base::options(opts)
[16:04:45.064]                 }
[16:04:45.064]                 {
[16:04:45.064]                   {
[16:04:45.064]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.064]                     NULL
[16:04:45.064]                   }
[16:04:45.064]                   options(future.plan = NULL)
[16:04:45.064]                   if (is.na(NA_character_)) 
[16:04:45.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.064]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:45.064]                     envir = parent.frame()) 
[16:04:45.064]                   {
[16:04:45.064]                     default_workers <- missing(workers)
[16:04:45.064]                     if (is.function(workers)) 
[16:04:45.064]                       workers <- workers()
[16:04:45.064]                     workers <- structure(as.integer(workers), 
[16:04:45.064]                       class = class(workers))
[16:04:45.064]                     stop_if_not(is.finite(workers), workers >= 
[16:04:45.064]                       1L)
[16:04:45.064]                     if ((workers == 1L && !inherits(workers, 
[16:04:45.064]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:45.064]                       if (default_workers) 
[16:04:45.064]                         supportsMulticore(warn = TRUE)
[16:04:45.064]                       return(sequential(..., envir = envir))
[16:04:45.064]                     }
[16:04:45.064]                     oopts <- options(mc.cores = workers)
[16:04:45.064]                     on.exit(options(oopts))
[16:04:45.064]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:45.064]                       envir = envir)
[16:04:45.064]                     if (!future$lazy) 
[16:04:45.064]                       future <- run(future)
[16:04:45.064]                     invisible(future)
[16:04:45.064]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.064]                 }
[16:04:45.064]             }
[16:04:45.064]         }
[16:04:45.064]     })
[16:04:45.064]     if (TRUE) {
[16:04:45.064]         base::sink(type = "output", split = FALSE)
[16:04:45.064]         if (TRUE) {
[16:04:45.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.064]         }
[16:04:45.064]         else {
[16:04:45.064]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.064]         }
[16:04:45.064]         base::close(...future.stdout)
[16:04:45.064]         ...future.stdout <- NULL
[16:04:45.064]     }
[16:04:45.064]     ...future.result$conditions <- ...future.conditions
[16:04:45.064]     ...future.result$finished <- base::Sys.time()
[16:04:45.064]     ...future.result
[16:04:45.064] }
[16:04:45.067] requestCore(): workers = 2
[16:04:45.069] MulticoreFuture started
[16:04:45.069] - Launch lazy future ... done
[16:04:45.070] run() for ‘MulticoreFuture’ ... done
[16:04:45.070] getGlobalsAndPackages() ...
[16:04:45.070] Searching for globals...
[16:04:45.070] plan(): Setting new future strategy stack:
[16:04:45.071] 
[16:04:45.071] List of future strategies:
[16:04:45.071] 1. sequential:
[16:04:45.071]    - args: function (..., envir = parent.frame())
[16:04:45.071]    - tweaked: FALSE
[16:04:45.071]    - call: NULL
[16:04:45.071] Searching for globals ... DONE
[16:04:45.071] plan(): nbrOfWorkers() = 1
[16:04:45.072] - globals: [0] <none>
[16:04:45.072] getGlobalsAndPackages() ... DONE
[16:04:45.072] run() for ‘Future’ ...
[16:04:45.072] - state: ‘created’
[16:04:45.073] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:45.073] plan(): Setting new future strategy stack:
[16:04:45.073] List of future strategies:
[16:04:45.073] 1. multicore:
[16:04:45.073]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:45.073]    - tweaked: FALSE
[16:04:45.073]    - call: plan(strategy)
[16:04:45.078] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:45.079] plan(): nbrOfWorkers() = 2
[16:04:45.079] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:45.079]   - Field: ‘label’
[16:04:45.079]   - Field: ‘local’
[16:04:45.079]   - Field: ‘owner’
[16:04:45.080]   - Field: ‘envir’
[16:04:45.080]   - Field: ‘workers’
[16:04:45.080]   - Field: ‘packages’
[16:04:45.080]   - Field: ‘gc’
[16:04:45.081]   - Field: ‘job’
[16:04:45.081]   - Field: ‘conditions’
[16:04:45.081]   - Field: ‘expr’
[16:04:45.081]   - Field: ‘uuid’
[16:04:45.081]   - Field: ‘seed’
[16:04:45.081]   - Field: ‘version’
[16:04:45.082]   - Field: ‘result’
[16:04:45.082]   - Field: ‘asynchronous’
[16:04:45.082]   - Field: ‘calls’
[16:04:45.082]   - Field: ‘globals’
[16:04:45.082]   - Field: ‘stdout’
[16:04:45.083]   - Field: ‘earlySignal’
[16:04:45.083]   - Field: ‘lazy’
[16:04:45.083]   - Field: ‘state’
[16:04:45.083] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:45.083] - Launch lazy future ...
[16:04:45.084] Packages needed by the future expression (n = 0): <none>
[16:04:45.084] Packages needed by future strategies (n = 0): <none>
[16:04:45.085] {
[16:04:45.085]     {
[16:04:45.085]         {
[16:04:45.085]             ...future.startTime <- base::Sys.time()
[16:04:45.085]             {
[16:04:45.085]                 {
[16:04:45.085]                   {
[16:04:45.085]                     {
[16:04:45.085]                       base::local({
[16:04:45.085]                         has_future <- base::requireNamespace("future", 
[16:04:45.085]                           quietly = TRUE)
[16:04:45.085]                         if (has_future) {
[16:04:45.085]                           ns <- base::getNamespace("future")
[16:04:45.085]                           version <- ns[[".package"]][["version"]]
[16:04:45.085]                           if (is.null(version)) 
[16:04:45.085]                             version <- utils::packageVersion("future")
[16:04:45.085]                         }
[16:04:45.085]                         else {
[16:04:45.085]                           version <- NULL
[16:04:45.085]                         }
[16:04:45.085]                         if (!has_future || version < "1.8.0") {
[16:04:45.085]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.085]                             "", base::R.version$version.string), 
[16:04:45.085]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.085]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.085]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.085]                               "release", "version")], collapse = " "), 
[16:04:45.085]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.085]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.085]                             info)
[16:04:45.085]                           info <- base::paste(info, collapse = "; ")
[16:04:45.085]                           if (!has_future) {
[16:04:45.085]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.085]                               info)
[16:04:45.085]                           }
[16:04:45.085]                           else {
[16:04:45.085]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.085]                               info, version)
[16:04:45.085]                           }
[16:04:45.085]                           base::stop(msg)
[16:04:45.085]                         }
[16:04:45.085]                       })
[16:04:45.085]                     }
[16:04:45.085]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.085]                     base::options(mc.cores = 1L)
[16:04:45.085]                   }
[16:04:45.085]                   options(future.plan = NULL)
[16:04:45.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.085]                 }
[16:04:45.085]                 ...future.workdir <- getwd()
[16:04:45.085]             }
[16:04:45.085]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.085]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.085]         }
[16:04:45.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.085]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.085]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.085]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.085]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.085]             base::names(...future.oldOptions))
[16:04:45.085]     }
[16:04:45.085]     if (FALSE) {
[16:04:45.085]     }
[16:04:45.085]     else {
[16:04:45.085]         if (TRUE) {
[16:04:45.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.085]                 open = "w")
[16:04:45.085]         }
[16:04:45.085]         else {
[16:04:45.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.085]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.085]         }
[16:04:45.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.085]             base::sink(type = "output", split = FALSE)
[16:04:45.085]             base::close(...future.stdout)
[16:04:45.085]         }, add = TRUE)
[16:04:45.085]     }
[16:04:45.085]     ...future.frame <- base::sys.nframe()
[16:04:45.085]     ...future.conditions <- base::list()
[16:04:45.085]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.085]     if (FALSE) {
[16:04:45.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.085]     }
[16:04:45.085]     ...future.result <- base::tryCatch({
[16:04:45.085]         base::withCallingHandlers({
[16:04:45.085]             ...future.value <- base::withVisible(base::local({
[16:04:45.085]                 withCallingHandlers({
[16:04:45.085]                   NULL
[16:04:45.085]                 }, immediateCondition = function(cond) {
[16:04:45.085]                   save_rds <- function (object, pathname, ...) 
[16:04:45.085]                   {
[16:04:45.085]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:45.085]                     if (file_test("-f", pathname_tmp)) {
[16:04:45.085]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.085]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:45.085]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.085]                         fi_tmp[["mtime"]])
[16:04:45.085]                     }
[16:04:45.085]                     tryCatch({
[16:04:45.085]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:45.085]                     }, error = function(ex) {
[16:04:45.085]                       msg <- conditionMessage(ex)
[16:04:45.085]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.085]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:45.085]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.085]                         fi_tmp[["mtime"]], msg)
[16:04:45.085]                       ex$message <- msg
[16:04:45.085]                       stop(ex)
[16:04:45.085]                     })
[16:04:45.085]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:45.085]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:45.085]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:45.085]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.085]                       fi <- file.info(pathname)
[16:04:45.085]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:45.085]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.085]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:45.085]                         fi[["size"]], fi[["mtime"]])
[16:04:45.085]                       stop(msg)
[16:04:45.085]                     }
[16:04:45.085]                     invisible(pathname)
[16:04:45.085]                   }
[16:04:45.085]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:45.085]                     rootPath = tempdir()) 
[16:04:45.085]                   {
[16:04:45.085]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:45.085]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:45.085]                       tmpdir = path, fileext = ".rds")
[16:04:45.085]                     save_rds(obj, file)
[16:04:45.085]                   }
[16:04:45.085]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:45.085]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.085]                   {
[16:04:45.085]                     inherits <- base::inherits
[16:04:45.085]                     invokeRestart <- base::invokeRestart
[16:04:45.085]                     is.null <- base::is.null
[16:04:45.085]                     muffled <- FALSE
[16:04:45.085]                     if (inherits(cond, "message")) {
[16:04:45.085]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.085]                       if (muffled) 
[16:04:45.085]                         invokeRestart("muffleMessage")
[16:04:45.085]                     }
[16:04:45.085]                     else if (inherits(cond, "warning")) {
[16:04:45.085]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.085]                       if (muffled) 
[16:04:45.085]                         invokeRestart("muffleWarning")
[16:04:45.085]                     }
[16:04:45.085]                     else if (inherits(cond, "condition")) {
[16:04:45.085]                       if (!is.null(pattern)) {
[16:04:45.085]                         computeRestarts <- base::computeRestarts
[16:04:45.085]                         grepl <- base::grepl
[16:04:45.085]                         restarts <- computeRestarts(cond)
[16:04:45.085]                         for (restart in restarts) {
[16:04:45.085]                           name <- restart$name
[16:04:45.085]                           if (is.null(name)) 
[16:04:45.085]                             next
[16:04:45.085]                           if (!grepl(pattern, name)) 
[16:04:45.085]                             next
[16:04:45.085]                           invokeRestart(restart)
[16:04:45.085]                           muffled <- TRUE
[16:04:45.085]                           break
[16:04:45.085]                         }
[16:04:45.085]                       }
[16:04:45.085]                     }
[16:04:45.085]                     invisible(muffled)
[16:04:45.085]                   }
[16:04:45.085]                   muffleCondition(cond)
[16:04:45.085]                 })
[16:04:45.085]             }))
[16:04:45.085]             future::FutureResult(value = ...future.value$value, 
[16:04:45.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.085]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.085]                     ...future.globalenv.names))
[16:04:45.085]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.085]         }, condition = base::local({
[16:04:45.085]             c <- base::c
[16:04:45.085]             inherits <- base::inherits
[16:04:45.085]             invokeRestart <- base::invokeRestart
[16:04:45.085]             length <- base::length
[16:04:45.085]             list <- base::list
[16:04:45.085]             seq.int <- base::seq.int
[16:04:45.085]             signalCondition <- base::signalCondition
[16:04:45.085]             sys.calls <- base::sys.calls
[16:04:45.085]             `[[` <- base::`[[`
[16:04:45.085]             `+` <- base::`+`
[16:04:45.085]             `<<-` <- base::`<<-`
[16:04:45.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.085]                   3L)]
[16:04:45.085]             }
[16:04:45.085]             function(cond) {
[16:04:45.085]                 is_error <- inherits(cond, "error")
[16:04:45.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.085]                   NULL)
[16:04:45.085]                 if (is_error) {
[16:04:45.085]                   sessionInformation <- function() {
[16:04:45.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.085]                       search = base::search(), system = base::Sys.info())
[16:04:45.085]                   }
[16:04:45.085]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.085]                     cond$call), session = sessionInformation(), 
[16:04:45.085]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.085]                   signalCondition(cond)
[16:04:45.085]                 }
[16:04:45.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.085]                 "immediateCondition"))) {
[16:04:45.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.085]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.085]                   if (TRUE && !signal) {
[16:04:45.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.085]                     {
[16:04:45.085]                       inherits <- base::inherits
[16:04:45.085]                       invokeRestart <- base::invokeRestart
[16:04:45.085]                       is.null <- base::is.null
[16:04:45.085]                       muffled <- FALSE
[16:04:45.085]                       if (inherits(cond, "message")) {
[16:04:45.085]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.085]                         if (muffled) 
[16:04:45.085]                           invokeRestart("muffleMessage")
[16:04:45.085]                       }
[16:04:45.085]                       else if (inherits(cond, "warning")) {
[16:04:45.085]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.085]                         if (muffled) 
[16:04:45.085]                           invokeRestart("muffleWarning")
[16:04:45.085]                       }
[16:04:45.085]                       else if (inherits(cond, "condition")) {
[16:04:45.085]                         if (!is.null(pattern)) {
[16:04:45.085]                           computeRestarts <- base::computeRestarts
[16:04:45.085]                           grepl <- base::grepl
[16:04:45.085]                           restarts <- computeRestarts(cond)
[16:04:45.085]                           for (restart in restarts) {
[16:04:45.085]                             name <- restart$name
[16:04:45.085]                             if (is.null(name)) 
[16:04:45.085]                               next
[16:04:45.085]                             if (!grepl(pattern, name)) 
[16:04:45.085]                               next
[16:04:45.085]                             invokeRestart(restart)
[16:04:45.085]                             muffled <- TRUE
[16:04:45.085]                             break
[16:04:45.085]                           }
[16:04:45.085]                         }
[16:04:45.085]                       }
[16:04:45.085]                       invisible(muffled)
[16:04:45.085]                     }
[16:04:45.085]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.085]                   }
[16:04:45.085]                 }
[16:04:45.085]                 else {
[16:04:45.085]                   if (TRUE) {
[16:04:45.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.085]                     {
[16:04:45.085]                       inherits <- base::inherits
[16:04:45.085]                       invokeRestart <- base::invokeRestart
[16:04:45.085]                       is.null <- base::is.null
[16:04:45.085]                       muffled <- FALSE
[16:04:45.085]                       if (inherits(cond, "message")) {
[16:04:45.085]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.085]                         if (muffled) 
[16:04:45.085]                           invokeRestart("muffleMessage")
[16:04:45.085]                       }
[16:04:45.085]                       else if (inherits(cond, "warning")) {
[16:04:45.085]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.085]                         if (muffled) 
[16:04:45.085]                           invokeRestart("muffleWarning")
[16:04:45.085]                       }
[16:04:45.085]                       else if (inherits(cond, "condition")) {
[16:04:45.085]                         if (!is.null(pattern)) {
[16:04:45.085]                           computeRestarts <- base::computeRestarts
[16:04:45.085]                           grepl <- base::grepl
[16:04:45.085]                           restarts <- computeRestarts(cond)
[16:04:45.085]                           for (restart in restarts) {
[16:04:45.085]                             name <- restart$name
[16:04:45.085]                             if (is.null(name)) 
[16:04:45.085]                               next
[16:04:45.085]                             if (!grepl(pattern, name)) 
[16:04:45.085]                               next
[16:04:45.085]                             invokeRestart(restart)
[16:04:45.085]                             muffled <- TRUE
[16:04:45.085]                             break
[16:04:45.085]                           }
[16:04:45.085]                         }
[16:04:45.085]                       }
[16:04:45.085]                       invisible(muffled)
[16:04:45.085]                     }
[16:04:45.085]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.085]                   }
[16:04:45.085]                 }
[16:04:45.085]             }
[16:04:45.085]         }))
[16:04:45.085]     }, error = function(ex) {
[16:04:45.085]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.085]                 ...future.rng), started = ...future.startTime, 
[16:04:45.085]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.085]             version = "1.8"), class = "FutureResult")
[16:04:45.085]     }, finally = {
[16:04:45.085]         if (!identical(...future.workdir, getwd())) 
[16:04:45.085]             setwd(...future.workdir)
[16:04:45.085]         {
[16:04:45.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.085]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.085]             }
[16:04:45.085]             base::options(...future.oldOptions)
[16:04:45.085]             if (.Platform$OS.type == "windows") {
[16:04:45.085]                 old_names <- names(...future.oldEnvVars)
[16:04:45.085]                 envs <- base::Sys.getenv()
[16:04:45.085]                 names <- names(envs)
[16:04:45.085]                 common <- intersect(names, old_names)
[16:04:45.085]                 added <- setdiff(names, old_names)
[16:04:45.085]                 removed <- setdiff(old_names, names)
[16:04:45.085]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.085]                   envs[common]]
[16:04:45.085]                 NAMES <- toupper(changed)
[16:04:45.085]                 args <- list()
[16:04:45.085]                 for (kk in seq_along(NAMES)) {
[16:04:45.085]                   name <- changed[[kk]]
[16:04:45.085]                   NAME <- NAMES[[kk]]
[16:04:45.085]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.085]                     next
[16:04:45.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.085]                 }
[16:04:45.085]                 NAMES <- toupper(added)
[16:04:45.085]                 for (kk in seq_along(NAMES)) {
[16:04:45.085]                   name <- added[[kk]]
[16:04:45.085]                   NAME <- NAMES[[kk]]
[16:04:45.085]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.085]                     next
[16:04:45.085]                   args[[name]] <- ""
[16:04:45.085]                 }
[16:04:45.085]                 NAMES <- toupper(removed)
[16:04:45.085]                 for (kk in seq_along(NAMES)) {
[16:04:45.085]                   name <- removed[[kk]]
[16:04:45.085]                   NAME <- NAMES[[kk]]
[16:04:45.085]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.085]                     next
[16:04:45.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.085]                 }
[16:04:45.085]                 if (length(args) > 0) 
[16:04:45.085]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.085]             }
[16:04:45.085]             else {
[16:04:45.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.085]             }
[16:04:45.085]             {
[16:04:45.085]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.085]                   0L) {
[16:04:45.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.085]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.085]                   base::options(opts)
[16:04:45.085]                 }
[16:04:45.085]                 {
[16:04:45.085]                   {
[16:04:45.085]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.085]                     NULL
[16:04:45.085]                   }
[16:04:45.085]                   options(future.plan = NULL)
[16:04:45.085]                   if (is.na(NA_character_)) 
[16:04:45.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.085]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:45.085]                     envir = parent.frame()) 
[16:04:45.085]                   {
[16:04:45.085]                     default_workers <- missing(workers)
[16:04:45.085]                     if (is.function(workers)) 
[16:04:45.085]                       workers <- workers()
[16:04:45.085]                     workers <- structure(as.integer(workers), 
[16:04:45.085]                       class = class(workers))
[16:04:45.085]                     stop_if_not(is.finite(workers), workers >= 
[16:04:45.085]                       1L)
[16:04:45.085]                     if ((workers == 1L && !inherits(workers, 
[16:04:45.085]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:45.085]                       if (default_workers) 
[16:04:45.085]                         supportsMulticore(warn = TRUE)
[16:04:45.085]                       return(sequential(..., envir = envir))
[16:04:45.085]                     }
[16:04:45.085]                     oopts <- options(mc.cores = workers)
[16:04:45.085]                     on.exit(options(oopts))
[16:04:45.085]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:45.085]                       envir = envir)
[16:04:45.085]                     if (!future$lazy) 
[16:04:45.085]                       future <- run(future)
[16:04:45.085]                     invisible(future)
[16:04:45.085]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.085]                 }
[16:04:45.085]             }
[16:04:45.085]         }
[16:04:45.085]     })
[16:04:45.085]     if (TRUE) {
[16:04:45.085]         base::sink(type = "output", split = FALSE)
[16:04:45.085]         if (TRUE) {
[16:04:45.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.085]         }
[16:04:45.085]         else {
[16:04:45.085]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.085]         }
[16:04:45.085]         base::close(...future.stdout)
[16:04:45.085]         ...future.stdout <- NULL
[16:04:45.085]     }
[16:04:45.085]     ...future.result$conditions <- ...future.conditions
[16:04:45.085]     ...future.result$finished <- base::Sys.time()
[16:04:45.085]     ...future.result
[16:04:45.085] }
[16:04:45.089] requestCore(): workers = 2
[16:04:45.091] MulticoreFuture started
[16:04:45.092] - Launch lazy future ... done
[16:04:45.092] run() for ‘MulticoreFuture’ ... done
[16:04:45.093] plan(): Setting new future strategy stack:
[16:04:45.093] getGlobalsAndPackages() ...
[16:04:45.093] Searching for globals...
[16:04:45.093] List of future strategies:
[16:04:45.093] 1. sequential:
[16:04:45.093]    - args: function (..., envir = parent.frame())
[16:04:45.093]    - tweaked: FALSE
[16:04:45.093]    - call: NULL
[16:04:45.094] plan(): nbrOfWorkers() = 1
[16:04:45.095] - globals found: [1] ‘{’
[16:04:45.095] Searching for globals ... DONE
[16:04:45.095] Resolving globals: FALSE
[16:04:45.096] 
[16:04:45.096] plan(): Setting new future strategy stack:
[16:04:45.096] 
[16:04:45.096] getGlobalsAndPackages() ... DONE
[16:04:45.096] List of future strategies:
[16:04:45.096] 1. multicore:
[16:04:45.096]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:45.096]    - tweaked: FALSE
[16:04:45.096]    - call: plan(strategy)
[16:04:45.097] run() for ‘Future’ ...
[16:04:45.097] - state: ‘created’
[16:04:45.097] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:45.101] plan(): nbrOfWorkers() = 2
[16:04:45.102] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:45.102] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:45.102]   - Field: ‘label’
[16:04:45.102]   - Field: ‘local’
[16:04:45.102]   - Field: ‘owner’
[16:04:45.103]   - Field: ‘envir’
[16:04:45.103]   - Field: ‘workers’
[16:04:45.103]   - Field: ‘packages’
[16:04:45.103]   - Field: ‘gc’
[16:04:45.103]   - Field: ‘job’
[16:04:45.103]   - Field: ‘conditions’
[16:04:45.104]   - Field: ‘expr’
[16:04:45.104]   - Field: ‘uuid’
[16:04:45.104]   - Field: ‘seed’
[16:04:45.104]   - Field: ‘version’
[16:04:45.104]   - Field: ‘result’
[16:04:45.104]   - Field: ‘asynchronous’
[16:04:45.104]   - Field: ‘calls’
[16:04:45.105]   - Field: ‘globals’
[16:04:45.105]   - Field: ‘stdout’
[16:04:45.105]   - Field: ‘earlySignal’
[16:04:45.105]   - Field: ‘lazy’
[16:04:45.105]   - Field: ‘state’
[16:04:45.105] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:45.105] - Launch lazy future ...
[16:04:45.106] Packages needed by the future expression (n = 0): <none>
[16:04:45.106] Packages needed by future strategies (n = 0): <none>
[16:04:45.107] {
[16:04:45.107]     {
[16:04:45.107]         {
[16:04:45.107]             ...future.startTime <- base::Sys.time()
[16:04:45.107]             {
[16:04:45.107]                 {
[16:04:45.107]                   {
[16:04:45.107]                     {
[16:04:45.107]                       base::local({
[16:04:45.107]                         has_future <- base::requireNamespace("future", 
[16:04:45.107]                           quietly = TRUE)
[16:04:45.107]                         if (has_future) {
[16:04:45.107]                           ns <- base::getNamespace("future")
[16:04:45.107]                           version <- ns[[".package"]][["version"]]
[16:04:45.107]                           if (is.null(version)) 
[16:04:45.107]                             version <- utils::packageVersion("future")
[16:04:45.107]                         }
[16:04:45.107]                         else {
[16:04:45.107]                           version <- NULL
[16:04:45.107]                         }
[16:04:45.107]                         if (!has_future || version < "1.8.0") {
[16:04:45.107]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.107]                             "", base::R.version$version.string), 
[16:04:45.107]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.107]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.107]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.107]                               "release", "version")], collapse = " "), 
[16:04:45.107]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.107]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.107]                             info)
[16:04:45.107]                           info <- base::paste(info, collapse = "; ")
[16:04:45.107]                           if (!has_future) {
[16:04:45.107]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.107]                               info)
[16:04:45.107]                           }
[16:04:45.107]                           else {
[16:04:45.107]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.107]                               info, version)
[16:04:45.107]                           }
[16:04:45.107]                           base::stop(msg)
[16:04:45.107]                         }
[16:04:45.107]                       })
[16:04:45.107]                     }
[16:04:45.107]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.107]                     base::options(mc.cores = 1L)
[16:04:45.107]                   }
[16:04:45.107]                   options(future.plan = NULL)
[16:04:45.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.107]                 }
[16:04:45.107]                 ...future.workdir <- getwd()
[16:04:45.107]             }
[16:04:45.107]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.107]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.107]         }
[16:04:45.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.107]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.107]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.107]             base::names(...future.oldOptions))
[16:04:45.107]     }
[16:04:45.107]     if (FALSE) {
[16:04:45.107]     }
[16:04:45.107]     else {
[16:04:45.107]         if (TRUE) {
[16:04:45.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.107]                 open = "w")
[16:04:45.107]         }
[16:04:45.107]         else {
[16:04:45.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.107]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.107]         }
[16:04:45.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.107]             base::sink(type = "output", split = FALSE)
[16:04:45.107]             base::close(...future.stdout)
[16:04:45.107]         }, add = TRUE)
[16:04:45.107]     }
[16:04:45.107]     ...future.frame <- base::sys.nframe()
[16:04:45.107]     ...future.conditions <- base::list()
[16:04:45.107]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.107]     if (FALSE) {
[16:04:45.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.107]     }
[16:04:45.107]     ...future.result <- base::tryCatch({
[16:04:45.107]         base::withCallingHandlers({
[16:04:45.107]             ...future.value <- base::withVisible(base::local({
[16:04:45.107]                 withCallingHandlers({
[16:04:45.107]                   {
[16:04:45.107]                     4
[16:04:45.107]                   }
[16:04:45.107]                 }, immediateCondition = function(cond) {
[16:04:45.107]                   save_rds <- function (object, pathname, ...) 
[16:04:45.107]                   {
[16:04:45.107]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:45.107]                     if (file_test("-f", pathname_tmp)) {
[16:04:45.107]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.107]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:45.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.107]                         fi_tmp[["mtime"]])
[16:04:45.107]                     }
[16:04:45.107]                     tryCatch({
[16:04:45.107]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:45.107]                     }, error = function(ex) {
[16:04:45.107]                       msg <- conditionMessage(ex)
[16:04:45.107]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.107]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:45.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.107]                         fi_tmp[["mtime"]], msg)
[16:04:45.107]                       ex$message <- msg
[16:04:45.107]                       stop(ex)
[16:04:45.107]                     })
[16:04:45.107]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:45.107]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:45.107]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:45.107]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.107]                       fi <- file.info(pathname)
[16:04:45.107]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:45.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.107]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:45.107]                         fi[["size"]], fi[["mtime"]])
[16:04:45.107]                       stop(msg)
[16:04:45.107]                     }
[16:04:45.107]                     invisible(pathname)
[16:04:45.107]                   }
[16:04:45.107]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:45.107]                     rootPath = tempdir()) 
[16:04:45.107]                   {
[16:04:45.107]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:45.107]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:45.107]                       tmpdir = path, fileext = ".rds")
[16:04:45.107]                     save_rds(obj, file)
[16:04:45.107]                   }
[16:04:45.107]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:45.107]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.107]                   {
[16:04:45.107]                     inherits <- base::inherits
[16:04:45.107]                     invokeRestart <- base::invokeRestart
[16:04:45.107]                     is.null <- base::is.null
[16:04:45.107]                     muffled <- FALSE
[16:04:45.107]                     if (inherits(cond, "message")) {
[16:04:45.107]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.107]                       if (muffled) 
[16:04:45.107]                         invokeRestart("muffleMessage")
[16:04:45.107]                     }
[16:04:45.107]                     else if (inherits(cond, "warning")) {
[16:04:45.107]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.107]                       if (muffled) 
[16:04:45.107]                         invokeRestart("muffleWarning")
[16:04:45.107]                     }
[16:04:45.107]                     else if (inherits(cond, "condition")) {
[16:04:45.107]                       if (!is.null(pattern)) {
[16:04:45.107]                         computeRestarts <- base::computeRestarts
[16:04:45.107]                         grepl <- base::grepl
[16:04:45.107]                         restarts <- computeRestarts(cond)
[16:04:45.107]                         for (restart in restarts) {
[16:04:45.107]                           name <- restart$name
[16:04:45.107]                           if (is.null(name)) 
[16:04:45.107]                             next
[16:04:45.107]                           if (!grepl(pattern, name)) 
[16:04:45.107]                             next
[16:04:45.107]                           invokeRestart(restart)
[16:04:45.107]                           muffled <- TRUE
[16:04:45.107]                           break
[16:04:45.107]                         }
[16:04:45.107]                       }
[16:04:45.107]                     }
[16:04:45.107]                     invisible(muffled)
[16:04:45.107]                   }
[16:04:45.107]                   muffleCondition(cond)
[16:04:45.107]                 })
[16:04:45.107]             }))
[16:04:45.107]             future::FutureResult(value = ...future.value$value, 
[16:04:45.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.107]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.107]                     ...future.globalenv.names))
[16:04:45.107]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.107]         }, condition = base::local({
[16:04:45.107]             c <- base::c
[16:04:45.107]             inherits <- base::inherits
[16:04:45.107]             invokeRestart <- base::invokeRestart
[16:04:45.107]             length <- base::length
[16:04:45.107]             list <- base::list
[16:04:45.107]             seq.int <- base::seq.int
[16:04:45.107]             signalCondition <- base::signalCondition
[16:04:45.107]             sys.calls <- base::sys.calls
[16:04:45.107]             `[[` <- base::`[[`
[16:04:45.107]             `+` <- base::`+`
[16:04:45.107]             `<<-` <- base::`<<-`
[16:04:45.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.107]                   3L)]
[16:04:45.107]             }
[16:04:45.107]             function(cond) {
[16:04:45.107]                 is_error <- inherits(cond, "error")
[16:04:45.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.107]                   NULL)
[16:04:45.107]                 if (is_error) {
[16:04:45.107]                   sessionInformation <- function() {
[16:04:45.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.107]                       search = base::search(), system = base::Sys.info())
[16:04:45.107]                   }
[16:04:45.107]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.107]                     cond$call), session = sessionInformation(), 
[16:04:45.107]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.107]                   signalCondition(cond)
[16:04:45.107]                 }
[16:04:45.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.107]                 "immediateCondition"))) {
[16:04:45.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.107]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.107]                   if (TRUE && !signal) {
[16:04:45.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.107]                     {
[16:04:45.107]                       inherits <- base::inherits
[16:04:45.107]                       invokeRestart <- base::invokeRestart
[16:04:45.107]                       is.null <- base::is.null
[16:04:45.107]                       muffled <- FALSE
[16:04:45.107]                       if (inherits(cond, "message")) {
[16:04:45.107]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.107]                         if (muffled) 
[16:04:45.107]                           invokeRestart("muffleMessage")
[16:04:45.107]                       }
[16:04:45.107]                       else if (inherits(cond, "warning")) {
[16:04:45.107]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.107]                         if (muffled) 
[16:04:45.107]                           invokeRestart("muffleWarning")
[16:04:45.107]                       }
[16:04:45.107]                       else if (inherits(cond, "condition")) {
[16:04:45.107]                         if (!is.null(pattern)) {
[16:04:45.107]                           computeRestarts <- base::computeRestarts
[16:04:45.107]                           grepl <- base::grepl
[16:04:45.107]                           restarts <- computeRestarts(cond)
[16:04:45.107]                           for (restart in restarts) {
[16:04:45.107]                             name <- restart$name
[16:04:45.107]                             if (is.null(name)) 
[16:04:45.107]                               next
[16:04:45.107]                             if (!grepl(pattern, name)) 
[16:04:45.107]                               next
[16:04:45.107]                             invokeRestart(restart)
[16:04:45.107]                             muffled <- TRUE
[16:04:45.107]                             break
[16:04:45.107]                           }
[16:04:45.107]                         }
[16:04:45.107]                       }
[16:04:45.107]                       invisible(muffled)
[16:04:45.107]                     }
[16:04:45.107]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.107]                   }
[16:04:45.107]                 }
[16:04:45.107]                 else {
[16:04:45.107]                   if (TRUE) {
[16:04:45.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.107]                     {
[16:04:45.107]                       inherits <- base::inherits
[16:04:45.107]                       invokeRestart <- base::invokeRestart
[16:04:45.107]                       is.null <- base::is.null
[16:04:45.107]                       muffled <- FALSE
[16:04:45.107]                       if (inherits(cond, "message")) {
[16:04:45.107]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.107]                         if (muffled) 
[16:04:45.107]                           invokeRestart("muffleMessage")
[16:04:45.107]                       }
[16:04:45.107]                       else if (inherits(cond, "warning")) {
[16:04:45.107]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.107]                         if (muffled) 
[16:04:45.107]                           invokeRestart("muffleWarning")
[16:04:45.107]                       }
[16:04:45.107]                       else if (inherits(cond, "condition")) {
[16:04:45.107]                         if (!is.null(pattern)) {
[16:04:45.107]                           computeRestarts <- base::computeRestarts
[16:04:45.107]                           grepl <- base::grepl
[16:04:45.107]                           restarts <- computeRestarts(cond)
[16:04:45.107]                           for (restart in restarts) {
[16:04:45.107]                             name <- restart$name
[16:04:45.107]                             if (is.null(name)) 
[16:04:45.107]                               next
[16:04:45.107]                             if (!grepl(pattern, name)) 
[16:04:45.107]                               next
[16:04:45.107]                             invokeRestart(restart)
[16:04:45.107]                             muffled <- TRUE
[16:04:45.107]                             break
[16:04:45.107]                           }
[16:04:45.107]                         }
[16:04:45.107]                       }
[16:04:45.107]                       invisible(muffled)
[16:04:45.107]                     }
[16:04:45.107]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.107]                   }
[16:04:45.107]                 }
[16:04:45.107]             }
[16:04:45.107]         }))
[16:04:45.107]     }, error = function(ex) {
[16:04:45.107]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.107]                 ...future.rng), started = ...future.startTime, 
[16:04:45.107]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.107]             version = "1.8"), class = "FutureResult")
[16:04:45.107]     }, finally = {
[16:04:45.107]         if (!identical(...future.workdir, getwd())) 
[16:04:45.107]             setwd(...future.workdir)
[16:04:45.107]         {
[16:04:45.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.107]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.107]             }
[16:04:45.107]             base::options(...future.oldOptions)
[16:04:45.107]             if (.Platform$OS.type == "windows") {
[16:04:45.107]                 old_names <- names(...future.oldEnvVars)
[16:04:45.107]                 envs <- base::Sys.getenv()
[16:04:45.107]                 names <- names(envs)
[16:04:45.107]                 common <- intersect(names, old_names)
[16:04:45.107]                 added <- setdiff(names, old_names)
[16:04:45.107]                 removed <- setdiff(old_names, names)
[16:04:45.107]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.107]                   envs[common]]
[16:04:45.107]                 NAMES <- toupper(changed)
[16:04:45.107]                 args <- list()
[16:04:45.107]                 for (kk in seq_along(NAMES)) {
[16:04:45.107]                   name <- changed[[kk]]
[16:04:45.107]                   NAME <- NAMES[[kk]]
[16:04:45.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.107]                     next
[16:04:45.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.107]                 }
[16:04:45.107]                 NAMES <- toupper(added)
[16:04:45.107]                 for (kk in seq_along(NAMES)) {
[16:04:45.107]                   name <- added[[kk]]
[16:04:45.107]                   NAME <- NAMES[[kk]]
[16:04:45.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.107]                     next
[16:04:45.107]                   args[[name]] <- ""
[16:04:45.107]                 }
[16:04:45.107]                 NAMES <- toupper(removed)
[16:04:45.107]                 for (kk in seq_along(NAMES)) {
[16:04:45.107]                   name <- removed[[kk]]
[16:04:45.107]                   NAME <- NAMES[[kk]]
[16:04:45.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.107]                     next
[16:04:45.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.107]                 }
[16:04:45.107]                 if (length(args) > 0) 
[16:04:45.107]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.107]             }
[16:04:45.107]             else {
[16:04:45.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.107]             }
[16:04:45.107]             {
[16:04:45.107]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.107]                   0L) {
[16:04:45.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.107]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.107]                   base::options(opts)
[16:04:45.107]                 }
[16:04:45.107]                 {
[16:04:45.107]                   {
[16:04:45.107]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.107]                     NULL
[16:04:45.107]                   }
[16:04:45.107]                   options(future.plan = NULL)
[16:04:45.107]                   if (is.na(NA_character_)) 
[16:04:45.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.107]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:45.107]                     envir = parent.frame()) 
[16:04:45.107]                   {
[16:04:45.107]                     default_workers <- missing(workers)
[16:04:45.107]                     if (is.function(workers)) 
[16:04:45.107]                       workers <- workers()
[16:04:45.107]                     workers <- structure(as.integer(workers), 
[16:04:45.107]                       class = class(workers))
[16:04:45.107]                     stop_if_not(is.finite(workers), workers >= 
[16:04:45.107]                       1L)
[16:04:45.107]                     if ((workers == 1L && !inherits(workers, 
[16:04:45.107]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:45.107]                       if (default_workers) 
[16:04:45.107]                         supportsMulticore(warn = TRUE)
[16:04:45.107]                       return(sequential(..., envir = envir))
[16:04:45.107]                     }
[16:04:45.107]                     oopts <- options(mc.cores = workers)
[16:04:45.107]                     on.exit(options(oopts))
[16:04:45.107]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:45.107]                       envir = envir)
[16:04:45.107]                     if (!future$lazy) 
[16:04:45.107]                       future <- run(future)
[16:04:45.107]                     invisible(future)
[16:04:45.107]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.107]                 }
[16:04:45.107]             }
[16:04:45.107]         }
[16:04:45.107]     })
[16:04:45.107]     if (TRUE) {
[16:04:45.107]         base::sink(type = "output", split = FALSE)
[16:04:45.107]         if (TRUE) {
[16:04:45.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.107]         }
[16:04:45.107]         else {
[16:04:45.107]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.107]         }
[16:04:45.107]         base::close(...future.stdout)
[16:04:45.107]         ...future.stdout <- NULL
[16:04:45.107]     }
[16:04:45.107]     ...future.result$conditions <- ...future.conditions
[16:04:45.107]     ...future.result$finished <- base::Sys.time()
[16:04:45.107]     ...future.result
[16:04:45.107] }
[16:04:45.111] requestCore(): workers = 2
[16:04:45.111] Poll #1 (0): usedCores() = 2, workers = 2
[16:04:45.122] result() for MulticoreFuture ...
[16:04:45.123] result() for MulticoreFuture ...
[16:04:45.123] result() for MulticoreFuture ... done
[16:04:45.123] result() for MulticoreFuture ... done
[16:04:45.123] result() for MulticoreFuture ...
[16:04:45.123] result() for MulticoreFuture ... done
[16:04:45.127] MulticoreFuture started
[16:04:45.127] - Launch lazy future ... done
[16:04:45.127] run() for ‘MulticoreFuture’ ... done
[16:04:45.128] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55874db2dfe0> 
[16:04:45.128] List of future strategies:
[16:04:45.128] 1. sequential:
[16:04:45.128]    - args: function (..., envir = parent.frame())
[16:04:45.128]    - tweaked: FALSE
[16:04:45.128]    - call: NULL
[16:04:45.129] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55874ec4a630> 
 - attr(*, "dim.")=[16:04:45.131] plan(): Setting new future strategy stack:
 int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ :[16:04:45.131] List of future strategies:
[16:04:45.131] 1. multicore:
[16:04:45.131]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:45.131]    - tweaked: FALSE
[16:04:45.131]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:04:45.136] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:45.139] resolve() on list environment ...
[16:04:45.140]  recursive: 0
[16:04:45.141]  length: 6
[16:04:45.141]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:45.141] signalConditionsASAP(numeric, pos=1) ...
[16:04:45.141] - nx: 6
[16:04:45.142] - relay: TRUE
[16:04:45.142] - stdout: TRUE
[16:04:45.142] - signal: TRUE
[16:04:45.142] - resignal: FALSE
[16:04:45.142] - force: TRUE
[16:04:45.142] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.142] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.142]  - until=2
[16:04:45.143]  - relaying element #2
[16:04:45.143] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.143] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.143] signalConditionsASAP(NULL, pos=1) ... done
[16:04:45.143]  length: 5 (resolved future 1)
[16:04:45.143] Future #2
[16:04:45.144] result() for MulticoreFuture ...
[16:04:45.144] result() for MulticoreFuture ... done
[16:04:45.144] result() for MulticoreFuture ...
[16:04:45.144] result() for MulticoreFuture ... done
[16:04:45.144] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:45.144] - nx: 6
[16:04:45.144] - relay: TRUE
[16:04:45.144] - stdout: TRUE
[16:04:45.145] - signal: TRUE
[16:04:45.145] - resignal: FALSE
[16:04:45.145] - force: TRUE
[16:04:45.145] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.145] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.145]  - until=2
[16:04:45.145]  - relaying element #2
[16:04:45.145] result() for MulticoreFuture ...
[16:04:45.146] result() for MulticoreFuture ... done
[16:04:45.146] result() for MulticoreFuture ...
[16:04:45.146] result() for MulticoreFuture ... done
[16:04:45.146] result() for MulticoreFuture ...
[16:04:45.146] result() for MulticoreFuture ... done
[16:04:45.146] result() for MulticoreFuture ...
[16:04:45.146] result() for MulticoreFuture ... done
[16:04:45.147] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.147] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.147] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:45.147]  length: 4 (resolved future 2)
[16:04:45.147] Future #3
[16:04:45.148] result() for MulticoreFuture ...
[16:04:45.148] result() for MulticoreFuture ...
[16:04:45.149] result() for MulticoreFuture ... done
[16:04:45.149] result() for MulticoreFuture ... done
[16:04:45.149] result() for MulticoreFuture ...
[16:04:45.149] result() for MulticoreFuture ... done
[16:04:45.149] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:45.149] - nx: 6
[16:04:45.149] - relay: TRUE
[16:04:45.149] - stdout: TRUE
[16:04:45.150] - signal: TRUE
[16:04:45.150] - resignal: FALSE
[16:04:45.150] - force: TRUE
[16:04:45.150] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.150] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.150]  - until=3
[16:04:45.150]  - relaying element #3
[16:04:45.150] result() for MulticoreFuture ...
[16:04:45.151] result() for MulticoreFuture ... done
[16:04:45.151] result() for MulticoreFuture ...
[16:04:45.151] result() for MulticoreFuture ... done
[16:04:45.151] result() for MulticoreFuture ...
[16:04:45.151] result() for MulticoreFuture ... done
[16:04:45.151] result() for MulticoreFuture ...
[16:04:45.151] result() for MulticoreFuture ... done
[16:04:45.152] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.152] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.152] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:45.152]  length: 3 (resolved future 3)
[16:04:45.152] Future #4
[16:04:45.152] result() for MulticoreFuture ...
[16:04:45.153] result() for MulticoreFuture ...
[16:04:45.153] result() for MulticoreFuture ... done
[16:04:45.153] result() for MulticoreFuture ... done
[16:04:45.153] result() for MulticoreFuture ...
[16:04:45.154] result() for MulticoreFuture ... done
[16:04:45.154] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:04:45.154] - nx: 6
[16:04:45.154] - relay: TRUE
[16:04:45.154] - stdout: TRUE
[16:04:45.154] - signal: TRUE
[16:04:45.154] - resignal: FALSE
[16:04:45.154] - force: TRUE
[16:04:45.154] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.155] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.155]  - until=4
[16:04:45.155]  - relaying element #4
[16:04:45.155] result() for MulticoreFuture ...
[16:04:45.155] result() for MulticoreFuture ... done
[16:04:45.155] result() for MulticoreFuture ...
[16:04:45.155] result() for MulticoreFuture ... done
[16:04:45.156] result() for MulticoreFuture ...
[16:04:45.156] result() for MulticoreFuture ... done
[16:04:45.156] result() for MulticoreFuture ...
[16:04:45.156] result() for MulticoreFuture ... done
[16:04:45.156] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.156] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.156] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:04:45.156]  length: 2 (resolved future 4)
[16:04:45.156] signalConditionsASAP(NULL, pos=5) ...
[16:04:45.157] - nx: 6
[16:04:45.157] - relay: TRUE
[16:04:45.157] - stdout: TRUE
[16:04:45.157] - signal: TRUE
[16:04:45.157] - resignal: FALSE
[16:04:45.157] - force: TRUE
[16:04:45.157] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.157] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.157]  - until=6
[16:04:45.157]  - relaying element #6
[16:04:45.157] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:45.158] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.158] signalConditionsASAP(NULL, pos=5) ... done
[16:04:45.158]  length: 1 (resolved future 5)
[16:04:45.158] signalConditionsASAP(numeric, pos=6) ...
[16:04:45.158] - nx: 6
[16:04:45.158] - relay: TRUE
[16:04:45.158] - stdout: TRUE
[16:04:45.158] - signal: TRUE
[16:04:45.158] - resignal: FALSE
[16:04:45.159] - force: TRUE
[16:04:45.159] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:45.159] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.159]  - until=6
[16:04:45.159] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:45.159] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.159] signalConditionsASAP(numeric, pos=6) ... done
[16:04:45.159]  length: 0 (resolved future 6)
[16:04:45.159] Relaying remaining futures
[16:04:45.160] signalConditionsASAP(NULL, pos=0) ...
[16:04:45.160] - nx: 6
[16:04:45.160] - relay: TRUE
[16:04:45.160] - stdout: TRUE
[16:04:45.160] - signal: TRUE
[16:04:45.160] - resignal: FALSE
[16:04:45.160] - force: TRUE
[16:04:45.160] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:45.160] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:45.160] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:45.161] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.161] signalConditionsASAP(NULL, pos=0) ... done
[16:04:45.161] resolve() on list environment ... DONE
[16:04:45.161] result() for MulticoreFuture ...
[16:04:45.161] result() for MulticoreFuture ... done
[16:04:45.161] result() for MulticoreFuture ...
[16:04:45.161] result() for MulticoreFuture ... done
[16:04:45.161] result() for MulticoreFuture ...
[16:04:45.161] result() for MulticoreFuture ... done
[16:04:45.162] result() for MulticoreFuture ...
[16:04:45.162] result() for MulticoreFuture ... done
[16:04:45.162] result() for MulticoreFuture ...
[16:04:45.162] result() for MulticoreFuture ... done
[16:04:45.162] result() for MulticoreFuture ...
[16:04:45.162] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55874ef039b0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:04:45.164] getGlobalsAndPackages() ...
[16:04:45.164] Searching for globals...
[16:04:45.165] 
[16:04:45.165] Searching for globals ... DONE
[16:04:45.165] - globals: [0] <none>
[16:04:45.165] getGlobalsAndPackages() ... DONE
[16:04:45.165] run() for ‘Future’ ...
[16:04:45.166] - state: ‘created’
[16:04:45.166] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:45.170] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:45.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:45.170]   - Field: ‘label’
[16:04:45.170]   - Field: ‘local’
[16:04:45.170]   - Field: ‘owner’
[16:04:45.171]   - Field: ‘envir’
[16:04:45.171]   - Field: ‘workers’
[16:04:45.171]   - Field: ‘packages’
[16:04:45.171]   - Field: ‘gc’
[16:04:45.171]   - Field: ‘job’
[16:04:45.171]   - Field: ‘conditions’
[16:04:45.171]   - Field: ‘expr’
[16:04:45.171]   - Field: ‘uuid’
[16:04:45.171]   - Field: ‘seed’
[16:04:45.172]   - Field: ‘version’
[16:04:45.172]   - Field: ‘result’
[16:04:45.172]   - Field: ‘asynchronous’
[16:04:45.172]   - Field: ‘calls’
[16:04:45.172]   - Field: ‘globals’
[16:04:45.172]   - Field: ‘stdout’
[16:04:45.172]   - Field: ‘earlySignal’
[16:04:45.172]   - Field: ‘lazy’
[16:04:45.172]   - Field: ‘state’
[16:04:45.173] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:45.173] - Launch lazy future ...
[16:04:45.173] Packages needed by the future expression (n = 0): <none>
[16:04:45.173] Packages needed by future strategies (n = 0): <none>
[16:04:45.174] {
[16:04:45.174]     {
[16:04:45.174]         {
[16:04:45.174]             ...future.startTime <- base::Sys.time()
[16:04:45.174]             {
[16:04:45.174]                 {
[16:04:45.174]                   {
[16:04:45.174]                     {
[16:04:45.174]                       base::local({
[16:04:45.174]                         has_future <- base::requireNamespace("future", 
[16:04:45.174]                           quietly = TRUE)
[16:04:45.174]                         if (has_future) {
[16:04:45.174]                           ns <- base::getNamespace("future")
[16:04:45.174]                           version <- ns[[".package"]][["version"]]
[16:04:45.174]                           if (is.null(version)) 
[16:04:45.174]                             version <- utils::packageVersion("future")
[16:04:45.174]                         }
[16:04:45.174]                         else {
[16:04:45.174]                           version <- NULL
[16:04:45.174]                         }
[16:04:45.174]                         if (!has_future || version < "1.8.0") {
[16:04:45.174]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.174]                             "", base::R.version$version.string), 
[16:04:45.174]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.174]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.174]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.174]                               "release", "version")], collapse = " "), 
[16:04:45.174]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.174]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.174]                             info)
[16:04:45.174]                           info <- base::paste(info, collapse = "; ")
[16:04:45.174]                           if (!has_future) {
[16:04:45.174]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.174]                               info)
[16:04:45.174]                           }
[16:04:45.174]                           else {
[16:04:45.174]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.174]                               info, version)
[16:04:45.174]                           }
[16:04:45.174]                           base::stop(msg)
[16:04:45.174]                         }
[16:04:45.174]                       })
[16:04:45.174]                     }
[16:04:45.174]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.174]                     base::options(mc.cores = 1L)
[16:04:45.174]                   }
[16:04:45.174]                   options(future.plan = NULL)
[16:04:45.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.174]                 }
[16:04:45.174]                 ...future.workdir <- getwd()
[16:04:45.174]             }
[16:04:45.174]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.174]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.174]         }
[16:04:45.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.174]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.174]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.174]             base::names(...future.oldOptions))
[16:04:45.174]     }
[16:04:45.174]     if (FALSE) {
[16:04:45.174]     }
[16:04:45.174]     else {
[16:04:45.174]         if (TRUE) {
[16:04:45.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.174]                 open = "w")
[16:04:45.174]         }
[16:04:45.174]         else {
[16:04:45.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.174]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.174]         }
[16:04:45.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.174]             base::sink(type = "output", split = FALSE)
[16:04:45.174]             base::close(...future.stdout)
[16:04:45.174]         }, add = TRUE)
[16:04:45.174]     }
[16:04:45.174]     ...future.frame <- base::sys.nframe()
[16:04:45.174]     ...future.conditions <- base::list()
[16:04:45.174]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.174]     if (FALSE) {
[16:04:45.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.174]     }
[16:04:45.174]     ...future.result <- base::tryCatch({
[16:04:45.174]         base::withCallingHandlers({
[16:04:45.174]             ...future.value <- base::withVisible(base::local({
[16:04:45.174]                 withCallingHandlers({
[16:04:45.174]                   2
[16:04:45.174]                 }, immediateCondition = function(cond) {
[16:04:45.174]                   save_rds <- function (object, pathname, ...) 
[16:04:45.174]                   {
[16:04:45.174]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:45.174]                     if (file_test("-f", pathname_tmp)) {
[16:04:45.174]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.174]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:45.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.174]                         fi_tmp[["mtime"]])
[16:04:45.174]                     }
[16:04:45.174]                     tryCatch({
[16:04:45.174]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:45.174]                     }, error = function(ex) {
[16:04:45.174]                       msg <- conditionMessage(ex)
[16:04:45.174]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.174]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:45.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.174]                         fi_tmp[["mtime"]], msg)
[16:04:45.174]                       ex$message <- msg
[16:04:45.174]                       stop(ex)
[16:04:45.174]                     })
[16:04:45.174]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:45.174]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:45.174]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:45.174]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.174]                       fi <- file.info(pathname)
[16:04:45.174]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:45.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.174]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:45.174]                         fi[["size"]], fi[["mtime"]])
[16:04:45.174]                       stop(msg)
[16:04:45.174]                     }
[16:04:45.174]                     invisible(pathname)
[16:04:45.174]                   }
[16:04:45.174]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:45.174]                     rootPath = tempdir()) 
[16:04:45.174]                   {
[16:04:45.174]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:45.174]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:45.174]                       tmpdir = path, fileext = ".rds")
[16:04:45.174]                     save_rds(obj, file)
[16:04:45.174]                   }
[16:04:45.174]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:45.174]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.174]                   {
[16:04:45.174]                     inherits <- base::inherits
[16:04:45.174]                     invokeRestart <- base::invokeRestart
[16:04:45.174]                     is.null <- base::is.null
[16:04:45.174]                     muffled <- FALSE
[16:04:45.174]                     if (inherits(cond, "message")) {
[16:04:45.174]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.174]                       if (muffled) 
[16:04:45.174]                         invokeRestart("muffleMessage")
[16:04:45.174]                     }
[16:04:45.174]                     else if (inherits(cond, "warning")) {
[16:04:45.174]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.174]                       if (muffled) 
[16:04:45.174]                         invokeRestart("muffleWarning")
[16:04:45.174]                     }
[16:04:45.174]                     else if (inherits(cond, "condition")) {
[16:04:45.174]                       if (!is.null(pattern)) {
[16:04:45.174]                         computeRestarts <- base::computeRestarts
[16:04:45.174]                         grepl <- base::grepl
[16:04:45.174]                         restarts <- computeRestarts(cond)
[16:04:45.174]                         for (restart in restarts) {
[16:04:45.174]                           name <- restart$name
[16:04:45.174]                           if (is.null(name)) 
[16:04:45.174]                             next
[16:04:45.174]                           if (!grepl(pattern, name)) 
[16:04:45.174]                             next
[16:04:45.174]                           invokeRestart(restart)
[16:04:45.174]                           muffled <- TRUE
[16:04:45.174]                           break
[16:04:45.174]                         }
[16:04:45.174]                       }
[16:04:45.174]                     }
[16:04:45.174]                     invisible(muffled)
[16:04:45.174]                   }
[16:04:45.174]                   muffleCondition(cond)
[16:04:45.174]                 })
[16:04:45.174]             }))
[16:04:45.174]             future::FutureResult(value = ...future.value$value, 
[16:04:45.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.174]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.174]                     ...future.globalenv.names))
[16:04:45.174]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.174]         }, condition = base::local({
[16:04:45.174]             c <- base::c
[16:04:45.174]             inherits <- base::inherits
[16:04:45.174]             invokeRestart <- base::invokeRestart
[16:04:45.174]             length <- base::length
[16:04:45.174]             list <- base::list
[16:04:45.174]             seq.int <- base::seq.int
[16:04:45.174]             signalCondition <- base::signalCondition
[16:04:45.174]             sys.calls <- base::sys.calls
[16:04:45.174]             `[[` <- base::`[[`
[16:04:45.174]             `+` <- base::`+`
[16:04:45.174]             `<<-` <- base::`<<-`
[16:04:45.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.174]                   3L)]
[16:04:45.174]             }
[16:04:45.174]             function(cond) {
[16:04:45.174]                 is_error <- inherits(cond, "error")
[16:04:45.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.174]                   NULL)
[16:04:45.174]                 if (is_error) {
[16:04:45.174]                   sessionInformation <- function() {
[16:04:45.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.174]                       search = base::search(), system = base::Sys.info())
[16:04:45.174]                   }
[16:04:45.174]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.174]                     cond$call), session = sessionInformation(), 
[16:04:45.174]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.174]                   signalCondition(cond)
[16:04:45.174]                 }
[16:04:45.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.174]                 "immediateCondition"))) {
[16:04:45.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.174]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.174]                   if (TRUE && !signal) {
[16:04:45.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.174]                     {
[16:04:45.174]                       inherits <- base::inherits
[16:04:45.174]                       invokeRestart <- base::invokeRestart
[16:04:45.174]                       is.null <- base::is.null
[16:04:45.174]                       muffled <- FALSE
[16:04:45.174]                       if (inherits(cond, "message")) {
[16:04:45.174]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.174]                         if (muffled) 
[16:04:45.174]                           invokeRestart("muffleMessage")
[16:04:45.174]                       }
[16:04:45.174]                       else if (inherits(cond, "warning")) {
[16:04:45.174]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.174]                         if (muffled) 
[16:04:45.174]                           invokeRestart("muffleWarning")
[16:04:45.174]                       }
[16:04:45.174]                       else if (inherits(cond, "condition")) {
[16:04:45.174]                         if (!is.null(pattern)) {
[16:04:45.174]                           computeRestarts <- base::computeRestarts
[16:04:45.174]                           grepl <- base::grepl
[16:04:45.174]                           restarts <- computeRestarts(cond)
[16:04:45.174]                           for (restart in restarts) {
[16:04:45.174]                             name <- restart$name
[16:04:45.174]                             if (is.null(name)) 
[16:04:45.174]                               next
[16:04:45.174]                             if (!grepl(pattern, name)) 
[16:04:45.174]                               next
[16:04:45.174]                             invokeRestart(restart)
[16:04:45.174]                             muffled <- TRUE
[16:04:45.174]                             break
[16:04:45.174]                           }
[16:04:45.174]                         }
[16:04:45.174]                       }
[16:04:45.174]                       invisible(muffled)
[16:04:45.174]                     }
[16:04:45.174]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.174]                   }
[16:04:45.174]                 }
[16:04:45.174]                 else {
[16:04:45.174]                   if (TRUE) {
[16:04:45.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.174]                     {
[16:04:45.174]                       inherits <- base::inherits
[16:04:45.174]                       invokeRestart <- base::invokeRestart
[16:04:45.174]                       is.null <- base::is.null
[16:04:45.174]                       muffled <- FALSE
[16:04:45.174]                       if (inherits(cond, "message")) {
[16:04:45.174]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.174]                         if (muffled) 
[16:04:45.174]                           invokeRestart("muffleMessage")
[16:04:45.174]                       }
[16:04:45.174]                       else if (inherits(cond, "warning")) {
[16:04:45.174]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.174]                         if (muffled) 
[16:04:45.174]                           invokeRestart("muffleWarning")
[16:04:45.174]                       }
[16:04:45.174]                       else if (inherits(cond, "condition")) {
[16:04:45.174]                         if (!is.null(pattern)) {
[16:04:45.174]                           computeRestarts <- base::computeRestarts
[16:04:45.174]                           grepl <- base::grepl
[16:04:45.174]                           restarts <- computeRestarts(cond)
[16:04:45.174]                           for (restart in restarts) {
[16:04:45.174]                             name <- restart$name
[16:04:45.174]                             if (is.null(name)) 
[16:04:45.174]                               next
[16:04:45.174]                             if (!grepl(pattern, name)) 
[16:04:45.174]                               next
[16:04:45.174]                             invokeRestart(restart)
[16:04:45.174]                             muffled <- TRUE
[16:04:45.174]                             break
[16:04:45.174]                           }
[16:04:45.174]                         }
[16:04:45.174]                       }
[16:04:45.174]                       invisible(muffled)
[16:04:45.174]                     }
[16:04:45.174]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.174]                   }
[16:04:45.174]                 }
[16:04:45.174]             }
[16:04:45.174]         }))
[16:04:45.174]     }, error = function(ex) {
[16:04:45.174]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.174]                 ...future.rng), started = ...future.startTime, 
[16:04:45.174]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.174]             version = "1.8"), class = "FutureResult")
[16:04:45.174]     }, finally = {
[16:04:45.174]         if (!identical(...future.workdir, getwd())) 
[16:04:45.174]             setwd(...future.workdir)
[16:04:45.174]         {
[16:04:45.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.174]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.174]             }
[16:04:45.174]             base::options(...future.oldOptions)
[16:04:45.174]             if (.Platform$OS.type == "windows") {
[16:04:45.174]                 old_names <- names(...future.oldEnvVars)
[16:04:45.174]                 envs <- base::Sys.getenv()
[16:04:45.174]                 names <- names(envs)
[16:04:45.174]                 common <- intersect(names, old_names)
[16:04:45.174]                 added <- setdiff(names, old_names)
[16:04:45.174]                 removed <- setdiff(old_names, names)
[16:04:45.174]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.174]                   envs[common]]
[16:04:45.174]                 NAMES <- toupper(changed)
[16:04:45.174]                 args <- list()
[16:04:45.174]                 for (kk in seq_along(NAMES)) {
[16:04:45.174]                   name <- changed[[kk]]
[16:04:45.174]                   NAME <- NAMES[[kk]]
[16:04:45.174]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.174]                     next
[16:04:45.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.174]                 }
[16:04:45.174]                 NAMES <- toupper(added)
[16:04:45.174]                 for (kk in seq_along(NAMES)) {
[16:04:45.174]                   name <- added[[kk]]
[16:04:45.174]                   NAME <- NAMES[[kk]]
[16:04:45.174]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.174]                     next
[16:04:45.174]                   args[[name]] <- ""
[16:04:45.174]                 }
[16:04:45.174]                 NAMES <- toupper(removed)
[16:04:45.174]                 for (kk in seq_along(NAMES)) {
[16:04:45.174]                   name <- removed[[kk]]
[16:04:45.174]                   NAME <- NAMES[[kk]]
[16:04:45.174]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.174]                     next
[16:04:45.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.174]                 }
[16:04:45.174]                 if (length(args) > 0) 
[16:04:45.174]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.174]             }
[16:04:45.174]             else {
[16:04:45.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.174]             }
[16:04:45.174]             {
[16:04:45.174]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.174]                   0L) {
[16:04:45.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.174]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.174]                   base::options(opts)
[16:04:45.174]                 }
[16:04:45.174]                 {
[16:04:45.174]                   {
[16:04:45.174]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.174]                     NULL
[16:04:45.174]                   }
[16:04:45.174]                   options(future.plan = NULL)
[16:04:45.174]                   if (is.na(NA_character_)) 
[16:04:45.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.174]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:45.174]                     envir = parent.frame()) 
[16:04:45.174]                   {
[16:04:45.174]                     default_workers <- missing(workers)
[16:04:45.174]                     if (is.function(workers)) 
[16:04:45.174]                       workers <- workers()
[16:04:45.174]                     workers <- structure(as.integer(workers), 
[16:04:45.174]                       class = class(workers))
[16:04:45.174]                     stop_if_not(is.finite(workers), workers >= 
[16:04:45.174]                       1L)
[16:04:45.174]                     if ((workers == 1L && !inherits(workers, 
[16:04:45.174]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:45.174]                       if (default_workers) 
[16:04:45.174]                         supportsMulticore(warn = TRUE)
[16:04:45.174]                       return(sequential(..., envir = envir))
[16:04:45.174]                     }
[16:04:45.174]                     oopts <- options(mc.cores = workers)
[16:04:45.174]                     on.exit(options(oopts))
[16:04:45.174]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:45.174]                       envir = envir)
[16:04:45.174]                     if (!future$lazy) 
[16:04:45.174]                       future <- run(future)
[16:04:45.174]                     invisible(future)
[16:04:45.174]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.174]                 }
[16:04:45.174]             }
[16:04:45.174]         }
[16:04:45.174]     })
[16:04:45.174]     if (TRUE) {
[16:04:45.174]         base::sink(type = "output", split = FALSE)
[16:04:45.174]         if (TRUE) {
[16:04:45.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.174]         }
[16:04:45.174]         else {
[16:04:45.174]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.174]         }
[16:04:45.174]         base::close(...future.stdout)
[16:04:45.174]         ...future.stdout <- NULL
[16:04:45.174]     }
[16:04:45.174]     ...future.result$conditions <- ...future.conditions
[16:04:45.174]     ...future.result$finished <- base::Sys.time()
[16:04:45.174]     ...future.result
[16:04:45.174] }
[16:04:45.176] requestCore(): workers = 2
[16:04:45.183] MulticoreFuture started
[16:04:45.183] - Launch lazy future ... done
[16:04:45.184] run() for ‘MulticoreFuture’ ... done
[16:04:45.184] plan(): Setting new future strategy stack:
[16:04:45.185] getGlobalsAndPackages() ...
[16:04:45.185] Searching for globals...
[16:04:45.184] List of future strategies:
[16:04:45.184] 1. sequential:
[16:04:45.184]    - args: function (..., envir = parent.frame())
[16:04:45.184]    - tweaked: FALSE
[16:04:45.184]    - call: NULL
[16:04:45.186] plan(): nbrOfWorkers() = 1
[16:04:45.186] 
[16:04:45.186] Searching for globals ... DONE
[16:04:45.186] - globals: [0] <none>
[16:04:45.187] getGlobalsAndPackages() ... DONE
[16:04:45.187] run() for ‘Future’ ...
[16:04:45.187] - state: ‘created’
[16:04:45.188] plan(): Setting new future strategy stack:
[16:04:45.188] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:45.188] List of future strategies:
[16:04:45.188] 1. multicore:
[16:04:45.188]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:45.188]    - tweaked: FALSE
[16:04:45.188]    - call: plan(strategy)
[16:04:45.192] plan(): nbrOfWorkers() = 2
[16:04:45.193] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:45.193] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:45.193]   - Field: ‘label’
[16:04:45.193]   - Field: ‘local’
[16:04:45.193]   - Field: ‘owner’
[16:04:45.193]   - Field: ‘envir’
[16:04:45.194]   - Field: ‘workers’
[16:04:45.194]   - Field: ‘packages’
[16:04:45.194]   - Field: ‘gc’
[16:04:45.194]   - Field: ‘job’
[16:04:45.194]   - Field: ‘conditions’
[16:04:45.194]   - Field: ‘expr’
[16:04:45.195]   - Field: ‘uuid’
[16:04:45.195]   - Field: ‘seed’
[16:04:45.195]   - Field: ‘version’
[16:04:45.195]   - Field: ‘result’
[16:04:45.195]   - Field: ‘asynchronous’
[16:04:45.195]   - Field: ‘calls’
[16:04:45.195]   - Field: ‘globals’
[16:04:45.196]   - Field: ‘stdout’
[16:04:45.196]   - Field: ‘earlySignal’
[16:04:45.196]   - Field: ‘lazy’
[16:04:45.196]   - Field: ‘state’
[16:04:45.196] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:45.196] - Launch lazy future ...
[16:04:45.197] Packages needed by the future expression (n = 0): <none>
[16:04:45.197] Packages needed by future strategies (n = 0): <none>
[16:04:45.198] {
[16:04:45.198]     {
[16:04:45.198]         {
[16:04:45.198]             ...future.startTime <- base::Sys.time()
[16:04:45.198]             {
[16:04:45.198]                 {
[16:04:45.198]                   {
[16:04:45.198]                     {
[16:04:45.198]                       base::local({
[16:04:45.198]                         has_future <- base::requireNamespace("future", 
[16:04:45.198]                           quietly = TRUE)
[16:04:45.198]                         if (has_future) {
[16:04:45.198]                           ns <- base::getNamespace("future")
[16:04:45.198]                           version <- ns[[".package"]][["version"]]
[16:04:45.198]                           if (is.null(version)) 
[16:04:45.198]                             version <- utils::packageVersion("future")
[16:04:45.198]                         }
[16:04:45.198]                         else {
[16:04:45.198]                           version <- NULL
[16:04:45.198]                         }
[16:04:45.198]                         if (!has_future || version < "1.8.0") {
[16:04:45.198]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.198]                             "", base::R.version$version.string), 
[16:04:45.198]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.198]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.198]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.198]                               "release", "version")], collapse = " "), 
[16:04:45.198]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.198]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.198]                             info)
[16:04:45.198]                           info <- base::paste(info, collapse = "; ")
[16:04:45.198]                           if (!has_future) {
[16:04:45.198]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.198]                               info)
[16:04:45.198]                           }
[16:04:45.198]                           else {
[16:04:45.198]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.198]                               info, version)
[16:04:45.198]                           }
[16:04:45.198]                           base::stop(msg)
[16:04:45.198]                         }
[16:04:45.198]                       })
[16:04:45.198]                     }
[16:04:45.198]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.198]                     base::options(mc.cores = 1L)
[16:04:45.198]                   }
[16:04:45.198]                   options(future.plan = NULL)
[16:04:45.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.198]                 }
[16:04:45.198]                 ...future.workdir <- getwd()
[16:04:45.198]             }
[16:04:45.198]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.198]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.198]         }
[16:04:45.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.198]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.198]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.198]             base::names(...future.oldOptions))
[16:04:45.198]     }
[16:04:45.198]     if (FALSE) {
[16:04:45.198]     }
[16:04:45.198]     else {
[16:04:45.198]         if (TRUE) {
[16:04:45.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.198]                 open = "w")
[16:04:45.198]         }
[16:04:45.198]         else {
[16:04:45.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.198]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.198]         }
[16:04:45.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.198]             base::sink(type = "output", split = FALSE)
[16:04:45.198]             base::close(...future.stdout)
[16:04:45.198]         }, add = TRUE)
[16:04:45.198]     }
[16:04:45.198]     ...future.frame <- base::sys.nframe()
[16:04:45.198]     ...future.conditions <- base::list()
[16:04:45.198]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.198]     if (FALSE) {
[16:04:45.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.198]     }
[16:04:45.198]     ...future.result <- base::tryCatch({
[16:04:45.198]         base::withCallingHandlers({
[16:04:45.198]             ...future.value <- base::withVisible(base::local({
[16:04:45.198]                 withCallingHandlers({
[16:04:45.198]                   NULL
[16:04:45.198]                 }, immediateCondition = function(cond) {
[16:04:45.198]                   save_rds <- function (object, pathname, ...) 
[16:04:45.198]                   {
[16:04:45.198]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:45.198]                     if (file_test("-f", pathname_tmp)) {
[16:04:45.198]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.198]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:45.198]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.198]                         fi_tmp[["mtime"]])
[16:04:45.198]                     }
[16:04:45.198]                     tryCatch({
[16:04:45.198]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:45.198]                     }, error = function(ex) {
[16:04:45.198]                       msg <- conditionMessage(ex)
[16:04:45.198]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.198]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:45.198]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.198]                         fi_tmp[["mtime"]], msg)
[16:04:45.198]                       ex$message <- msg
[16:04:45.198]                       stop(ex)
[16:04:45.198]                     })
[16:04:45.198]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:45.198]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:45.198]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:45.198]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.198]                       fi <- file.info(pathname)
[16:04:45.198]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:45.198]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.198]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:45.198]                         fi[["size"]], fi[["mtime"]])
[16:04:45.198]                       stop(msg)
[16:04:45.198]                     }
[16:04:45.198]                     invisible(pathname)
[16:04:45.198]                   }
[16:04:45.198]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:45.198]                     rootPath = tempdir()) 
[16:04:45.198]                   {
[16:04:45.198]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:45.198]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:45.198]                       tmpdir = path, fileext = ".rds")
[16:04:45.198]                     save_rds(obj, file)
[16:04:45.198]                   }
[16:04:45.198]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:45.198]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.198]                   {
[16:04:45.198]                     inherits <- base::inherits
[16:04:45.198]                     invokeRestart <- base::invokeRestart
[16:04:45.198]                     is.null <- base::is.null
[16:04:45.198]                     muffled <- FALSE
[16:04:45.198]                     if (inherits(cond, "message")) {
[16:04:45.198]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.198]                       if (muffled) 
[16:04:45.198]                         invokeRestart("muffleMessage")
[16:04:45.198]                     }
[16:04:45.198]                     else if (inherits(cond, "warning")) {
[16:04:45.198]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.198]                       if (muffled) 
[16:04:45.198]                         invokeRestart("muffleWarning")
[16:04:45.198]                     }
[16:04:45.198]                     else if (inherits(cond, "condition")) {
[16:04:45.198]                       if (!is.null(pattern)) {
[16:04:45.198]                         computeRestarts <- base::computeRestarts
[16:04:45.198]                         grepl <- base::grepl
[16:04:45.198]                         restarts <- computeRestarts(cond)
[16:04:45.198]                         for (restart in restarts) {
[16:04:45.198]                           name <- restart$name
[16:04:45.198]                           if (is.null(name)) 
[16:04:45.198]                             next
[16:04:45.198]                           if (!grepl(pattern, name)) 
[16:04:45.198]                             next
[16:04:45.198]                           invokeRestart(restart)
[16:04:45.198]                           muffled <- TRUE
[16:04:45.198]                           break
[16:04:45.198]                         }
[16:04:45.198]                       }
[16:04:45.198]                     }
[16:04:45.198]                     invisible(muffled)
[16:04:45.198]                   }
[16:04:45.198]                   muffleCondition(cond)
[16:04:45.198]                 })
[16:04:45.198]             }))
[16:04:45.198]             future::FutureResult(value = ...future.value$value, 
[16:04:45.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.198]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.198]                     ...future.globalenv.names))
[16:04:45.198]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.198]         }, condition = base::local({
[16:04:45.198]             c <- base::c
[16:04:45.198]             inherits <- base::inherits
[16:04:45.198]             invokeRestart <- base::invokeRestart
[16:04:45.198]             length <- base::length
[16:04:45.198]             list <- base::list
[16:04:45.198]             seq.int <- base::seq.int
[16:04:45.198]             signalCondition <- base::signalCondition
[16:04:45.198]             sys.calls <- base::sys.calls
[16:04:45.198]             `[[` <- base::`[[`
[16:04:45.198]             `+` <- base::`+`
[16:04:45.198]             `<<-` <- base::`<<-`
[16:04:45.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.198]                   3L)]
[16:04:45.198]             }
[16:04:45.198]             function(cond) {
[16:04:45.198]                 is_error <- inherits(cond, "error")
[16:04:45.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.198]                   NULL)
[16:04:45.198]                 if (is_error) {
[16:04:45.198]                   sessionInformation <- function() {
[16:04:45.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.198]                       search = base::search(), system = base::Sys.info())
[16:04:45.198]                   }
[16:04:45.198]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.198]                     cond$call), session = sessionInformation(), 
[16:04:45.198]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.198]                   signalCondition(cond)
[16:04:45.198]                 }
[16:04:45.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.198]                 "immediateCondition"))) {
[16:04:45.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.198]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.198]                   if (TRUE && !signal) {
[16:04:45.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.198]                     {
[16:04:45.198]                       inherits <- base::inherits
[16:04:45.198]                       invokeRestart <- base::invokeRestart
[16:04:45.198]                       is.null <- base::is.null
[16:04:45.198]                       muffled <- FALSE
[16:04:45.198]                       if (inherits(cond, "message")) {
[16:04:45.198]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.198]                         if (muffled) 
[16:04:45.198]                           invokeRestart("muffleMessage")
[16:04:45.198]                       }
[16:04:45.198]                       else if (inherits(cond, "warning")) {
[16:04:45.198]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.198]                         if (muffled) 
[16:04:45.198]                           invokeRestart("muffleWarning")
[16:04:45.198]                       }
[16:04:45.198]                       else if (inherits(cond, "condition")) {
[16:04:45.198]                         if (!is.null(pattern)) {
[16:04:45.198]                           computeRestarts <- base::computeRestarts
[16:04:45.198]                           grepl <- base::grepl
[16:04:45.198]                           restarts <- computeRestarts(cond)
[16:04:45.198]                           for (restart in restarts) {
[16:04:45.198]                             name <- restart$name
[16:04:45.198]                             if (is.null(name)) 
[16:04:45.198]                               next
[16:04:45.198]                             if (!grepl(pattern, name)) 
[16:04:45.198]                               next
[16:04:45.198]                             invokeRestart(restart)
[16:04:45.198]                             muffled <- TRUE
[16:04:45.198]                             break
[16:04:45.198]                           }
[16:04:45.198]                         }
[16:04:45.198]                       }
[16:04:45.198]                       invisible(muffled)
[16:04:45.198]                     }
[16:04:45.198]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.198]                   }
[16:04:45.198]                 }
[16:04:45.198]                 else {
[16:04:45.198]                   if (TRUE) {
[16:04:45.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.198]                     {
[16:04:45.198]                       inherits <- base::inherits
[16:04:45.198]                       invokeRestart <- base::invokeRestart
[16:04:45.198]                       is.null <- base::is.null
[16:04:45.198]                       muffled <- FALSE
[16:04:45.198]                       if (inherits(cond, "message")) {
[16:04:45.198]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.198]                         if (muffled) 
[16:04:45.198]                           invokeRestart("muffleMessage")
[16:04:45.198]                       }
[16:04:45.198]                       else if (inherits(cond, "warning")) {
[16:04:45.198]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.198]                         if (muffled) 
[16:04:45.198]                           invokeRestart("muffleWarning")
[16:04:45.198]                       }
[16:04:45.198]                       else if (inherits(cond, "condition")) {
[16:04:45.198]                         if (!is.null(pattern)) {
[16:04:45.198]                           computeRestarts <- base::computeRestarts
[16:04:45.198]                           grepl <- base::grepl
[16:04:45.198]                           restarts <- computeRestarts(cond)
[16:04:45.198]                           for (restart in restarts) {
[16:04:45.198]                             name <- restart$name
[16:04:45.198]                             if (is.null(name)) 
[16:04:45.198]                               next
[16:04:45.198]                             if (!grepl(pattern, name)) 
[16:04:45.198]                               next
[16:04:45.198]                             invokeRestart(restart)
[16:04:45.198]                             muffled <- TRUE
[16:04:45.198]                             break
[16:04:45.198]                           }
[16:04:45.198]                         }
[16:04:45.198]                       }
[16:04:45.198]                       invisible(muffled)
[16:04:45.198]                     }
[16:04:45.198]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.198]                   }
[16:04:45.198]                 }
[16:04:45.198]             }
[16:04:45.198]         }))
[16:04:45.198]     }, error = function(ex) {
[16:04:45.198]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.198]                 ...future.rng), started = ...future.startTime, 
[16:04:45.198]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.198]             version = "1.8"), class = "FutureResult")
[16:04:45.198]     }, finally = {
[16:04:45.198]         if (!identical(...future.workdir, getwd())) 
[16:04:45.198]             setwd(...future.workdir)
[16:04:45.198]         {
[16:04:45.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.198]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.198]             }
[16:04:45.198]             base::options(...future.oldOptions)
[16:04:45.198]             if (.Platform$OS.type == "windows") {
[16:04:45.198]                 old_names <- names(...future.oldEnvVars)
[16:04:45.198]                 envs <- base::Sys.getenv()
[16:04:45.198]                 names <- names(envs)
[16:04:45.198]                 common <- intersect(names, old_names)
[16:04:45.198]                 added <- setdiff(names, old_names)
[16:04:45.198]                 removed <- setdiff(old_names, names)
[16:04:45.198]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.198]                   envs[common]]
[16:04:45.198]                 NAMES <- toupper(changed)
[16:04:45.198]                 args <- list()
[16:04:45.198]                 for (kk in seq_along(NAMES)) {
[16:04:45.198]                   name <- changed[[kk]]
[16:04:45.198]                   NAME <- NAMES[[kk]]
[16:04:45.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.198]                     next
[16:04:45.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.198]                 }
[16:04:45.198]                 NAMES <- toupper(added)
[16:04:45.198]                 for (kk in seq_along(NAMES)) {
[16:04:45.198]                   name <- added[[kk]]
[16:04:45.198]                   NAME <- NAMES[[kk]]
[16:04:45.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.198]                     next
[16:04:45.198]                   args[[name]] <- ""
[16:04:45.198]                 }
[16:04:45.198]                 NAMES <- toupper(removed)
[16:04:45.198]                 for (kk in seq_along(NAMES)) {
[16:04:45.198]                   name <- removed[[kk]]
[16:04:45.198]                   NAME <- NAMES[[kk]]
[16:04:45.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.198]                     next
[16:04:45.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.198]                 }
[16:04:45.198]                 if (length(args) > 0) 
[16:04:45.198]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.198]             }
[16:04:45.198]             else {
[16:04:45.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.198]             }
[16:04:45.198]             {
[16:04:45.198]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.198]                   0L) {
[16:04:45.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.198]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.198]                   base::options(opts)
[16:04:45.198]                 }
[16:04:45.198]                 {
[16:04:45.198]                   {
[16:04:45.198]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.198]                     NULL
[16:04:45.198]                   }
[16:04:45.198]                   options(future.plan = NULL)
[16:04:45.198]                   if (is.na(NA_character_)) 
[16:04:45.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.198]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:45.198]                     envir = parent.frame()) 
[16:04:45.198]                   {
[16:04:45.198]                     default_workers <- missing(workers)
[16:04:45.198]                     if (is.function(workers)) 
[16:04:45.198]                       workers <- workers()
[16:04:45.198]                     workers <- structure(as.integer(workers), 
[16:04:45.198]                       class = class(workers))
[16:04:45.198]                     stop_if_not(is.finite(workers), workers >= 
[16:04:45.198]                       1L)
[16:04:45.198]                     if ((workers == 1L && !inherits(workers, 
[16:04:45.198]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:45.198]                       if (default_workers) 
[16:04:45.198]                         supportsMulticore(warn = TRUE)
[16:04:45.198]                       return(sequential(..., envir = envir))
[16:04:45.198]                     }
[16:04:45.198]                     oopts <- options(mc.cores = workers)
[16:04:45.198]                     on.exit(options(oopts))
[16:04:45.198]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:45.198]                       envir = envir)
[16:04:45.198]                     if (!future$lazy) 
[16:04:45.198]                       future <- run(future)
[16:04:45.198]                     invisible(future)
[16:04:45.198]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.198]                 }
[16:04:45.198]             }
[16:04:45.198]         }
[16:04:45.198]     })
[16:04:45.198]     if (TRUE) {
[16:04:45.198]         base::sink(type = "output", split = FALSE)
[16:04:45.198]         if (TRUE) {
[16:04:45.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.198]         }
[16:04:45.198]         else {
[16:04:45.198]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.198]         }
[16:04:45.198]         base::close(...future.stdout)
[16:04:45.198]         ...future.stdout <- NULL
[16:04:45.198]     }
[16:04:45.198]     ...future.result$conditions <- ...future.conditions
[16:04:45.198]     ...future.result$finished <- base::Sys.time()
[16:04:45.198]     ...future.result
[16:04:45.198] }
[16:04:45.202] requestCore(): workers = 2
[16:04:45.205] MulticoreFuture started
[16:04:45.205] - Launch lazy future ... done
[16:04:45.205] run() for ‘MulticoreFuture’ ... done
[16:04:45.206] plan(): Setting new future strategy stack:
[16:04:45.206] getGlobalsAndPackages() ...
[16:04:45.206] Searching for globals...
[16:04:45.206] List of future strategies:
[16:04:45.206] 1. sequential:
[16:04:45.206]    - args: function (..., envir = parent.frame())
[16:04:45.206]    - tweaked: FALSE
[16:04:45.206]    - call: NULL
[16:04:45.207] plan(): nbrOfWorkers() = 1
[16:04:45.208] - globals found: [1] ‘{’
[16:04:45.208] Searching for globals ... DONE
[16:04:45.208] Resolving globals: FALSE
[16:04:45.209] 
[16:04:45.209] 
[16:04:45.209] plan(): Setting new future strategy stack:
[16:04:45.209] getGlobalsAndPackages() ... DONE
[16:04:45.210] run() for ‘Future’ ...
[16:04:45.209] List of future strategies:
[16:04:45.209] 1. multicore:
[16:04:45.209]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:45.209]    - tweaked: FALSE
[16:04:45.209]    - call: plan(strategy)
[16:04:45.210] - state: ‘created’
[16:04:45.210] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:45.215] plan(): nbrOfWorkers() = 2
[16:04:45.215] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:45.216] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:45.216]   - Field: ‘label’
[16:04:45.216]   - Field: ‘local’
[16:04:45.216]   - Field: ‘owner’
[16:04:45.216]   - Field: ‘envir’
[16:04:45.217]   - Field: ‘workers’
[16:04:45.217]   - Field: ‘packages’
[16:04:45.217]   - Field: ‘gc’
[16:04:45.217]   - Field: ‘job’
[16:04:45.217]   - Field: ‘conditions’
[16:04:45.217]   - Field: ‘expr’
[16:04:45.217]   - Field: ‘uuid’
[16:04:45.218]   - Field: ‘seed’
[16:04:45.218]   - Field: ‘version’
[16:04:45.218]   - Field: ‘result’
[16:04:45.218]   - Field: ‘asynchronous’
[16:04:45.218]   - Field: ‘calls’
[16:04:45.218]   - Field: ‘globals’
[16:04:45.218]   - Field: ‘stdout’
[16:04:45.218]   - Field: ‘earlySignal’
[16:04:45.219]   - Field: ‘lazy’
[16:04:45.219]   - Field: ‘state’
[16:04:45.219] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:45.219] - Launch lazy future ...
[16:04:45.220] Packages needed by the future expression (n = 0): <none>
[16:04:45.220] Packages needed by future strategies (n = 0): <none>
[16:04:45.220] {
[16:04:45.220]     {
[16:04:45.220]         {
[16:04:45.220]             ...future.startTime <- base::Sys.time()
[16:04:45.220]             {
[16:04:45.220]                 {
[16:04:45.220]                   {
[16:04:45.220]                     {
[16:04:45.220]                       base::local({
[16:04:45.220]                         has_future <- base::requireNamespace("future", 
[16:04:45.220]                           quietly = TRUE)
[16:04:45.220]                         if (has_future) {
[16:04:45.220]                           ns <- base::getNamespace("future")
[16:04:45.220]                           version <- ns[[".package"]][["version"]]
[16:04:45.220]                           if (is.null(version)) 
[16:04:45.220]                             version <- utils::packageVersion("future")
[16:04:45.220]                         }
[16:04:45.220]                         else {
[16:04:45.220]                           version <- NULL
[16:04:45.220]                         }
[16:04:45.220]                         if (!has_future || version < "1.8.0") {
[16:04:45.220]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.220]                             "", base::R.version$version.string), 
[16:04:45.220]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.220]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.220]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.220]                               "release", "version")], collapse = " "), 
[16:04:45.220]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.220]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.220]                             info)
[16:04:45.220]                           info <- base::paste(info, collapse = "; ")
[16:04:45.220]                           if (!has_future) {
[16:04:45.220]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.220]                               info)
[16:04:45.220]                           }
[16:04:45.220]                           else {
[16:04:45.220]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.220]                               info, version)
[16:04:45.220]                           }
[16:04:45.220]                           base::stop(msg)
[16:04:45.220]                         }
[16:04:45.220]                       })
[16:04:45.220]                     }
[16:04:45.220]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.220]                     base::options(mc.cores = 1L)
[16:04:45.220]                   }
[16:04:45.220]                   options(future.plan = NULL)
[16:04:45.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.220]                 }
[16:04:45.220]                 ...future.workdir <- getwd()
[16:04:45.220]             }
[16:04:45.220]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.220]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.220]         }
[16:04:45.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.220]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.220]             base::names(...future.oldOptions))
[16:04:45.220]     }
[16:04:45.220]     if (FALSE) {
[16:04:45.220]     }
[16:04:45.220]     else {
[16:04:45.220]         if (TRUE) {
[16:04:45.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.220]                 open = "w")
[16:04:45.220]         }
[16:04:45.220]         else {
[16:04:45.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.220]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.220]         }
[16:04:45.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.220]             base::sink(type = "output", split = FALSE)
[16:04:45.220]             base::close(...future.stdout)
[16:04:45.220]         }, add = TRUE)
[16:04:45.220]     }
[16:04:45.220]     ...future.frame <- base::sys.nframe()
[16:04:45.220]     ...future.conditions <- base::list()
[16:04:45.220]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.220]     if (FALSE) {
[16:04:45.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.220]     }
[16:04:45.220]     ...future.result <- base::tryCatch({
[16:04:45.220]         base::withCallingHandlers({
[16:04:45.220]             ...future.value <- base::withVisible(base::local({
[16:04:45.220]                 withCallingHandlers({
[16:04:45.220]                   {
[16:04:45.220]                     4
[16:04:45.220]                   }
[16:04:45.220]                 }, immediateCondition = function(cond) {
[16:04:45.220]                   save_rds <- function (object, pathname, ...) 
[16:04:45.220]                   {
[16:04:45.220]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:45.220]                     if (file_test("-f", pathname_tmp)) {
[16:04:45.220]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.220]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:45.220]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.220]                         fi_tmp[["mtime"]])
[16:04:45.220]                     }
[16:04:45.220]                     tryCatch({
[16:04:45.220]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:45.220]                     }, error = function(ex) {
[16:04:45.220]                       msg <- conditionMessage(ex)
[16:04:45.220]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.220]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:45.220]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.220]                         fi_tmp[["mtime"]], msg)
[16:04:45.220]                       ex$message <- msg
[16:04:45.220]                       stop(ex)
[16:04:45.220]                     })
[16:04:45.220]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:45.220]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:45.220]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:45.220]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.220]                       fi <- file.info(pathname)
[16:04:45.220]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:45.220]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.220]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:45.220]                         fi[["size"]], fi[["mtime"]])
[16:04:45.220]                       stop(msg)
[16:04:45.220]                     }
[16:04:45.220]                     invisible(pathname)
[16:04:45.220]                   }
[16:04:45.220]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:45.220]                     rootPath = tempdir()) 
[16:04:45.220]                   {
[16:04:45.220]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:45.220]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:45.220]                       tmpdir = path, fileext = ".rds")
[16:04:45.220]                     save_rds(obj, file)
[16:04:45.220]                   }
[16:04:45.220]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:45.220]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.220]                   {
[16:04:45.220]                     inherits <- base::inherits
[16:04:45.220]                     invokeRestart <- base::invokeRestart
[16:04:45.220]                     is.null <- base::is.null
[16:04:45.220]                     muffled <- FALSE
[16:04:45.220]                     if (inherits(cond, "message")) {
[16:04:45.220]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.220]                       if (muffled) 
[16:04:45.220]                         invokeRestart("muffleMessage")
[16:04:45.220]                     }
[16:04:45.220]                     else if (inherits(cond, "warning")) {
[16:04:45.220]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.220]                       if (muffled) 
[16:04:45.220]                         invokeRestart("muffleWarning")
[16:04:45.220]                     }
[16:04:45.220]                     else if (inherits(cond, "condition")) {
[16:04:45.220]                       if (!is.null(pattern)) {
[16:04:45.220]                         computeRestarts <- base::computeRestarts
[16:04:45.220]                         grepl <- base::grepl
[16:04:45.220]                         restarts <- computeRestarts(cond)
[16:04:45.220]                         for (restart in restarts) {
[16:04:45.220]                           name <- restart$name
[16:04:45.220]                           if (is.null(name)) 
[16:04:45.220]                             next
[16:04:45.220]                           if (!grepl(pattern, name)) 
[16:04:45.220]                             next
[16:04:45.220]                           invokeRestart(restart)
[16:04:45.220]                           muffled <- TRUE
[16:04:45.220]                           break
[16:04:45.220]                         }
[16:04:45.220]                       }
[16:04:45.220]                     }
[16:04:45.220]                     invisible(muffled)
[16:04:45.220]                   }
[16:04:45.220]                   muffleCondition(cond)
[16:04:45.220]                 })
[16:04:45.220]             }))
[16:04:45.220]             future::FutureResult(value = ...future.value$value, 
[16:04:45.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.220]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.220]                     ...future.globalenv.names))
[16:04:45.220]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.220]         }, condition = base::local({
[16:04:45.220]             c <- base::c
[16:04:45.220]             inherits <- base::inherits
[16:04:45.220]             invokeRestart <- base::invokeRestart
[16:04:45.220]             length <- base::length
[16:04:45.220]             list <- base::list
[16:04:45.220]             seq.int <- base::seq.int
[16:04:45.220]             signalCondition <- base::signalCondition
[16:04:45.220]             sys.calls <- base::sys.calls
[16:04:45.220]             `[[` <- base::`[[`
[16:04:45.220]             `+` <- base::`+`
[16:04:45.220]             `<<-` <- base::`<<-`
[16:04:45.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.220]                   3L)]
[16:04:45.220]             }
[16:04:45.220]             function(cond) {
[16:04:45.220]                 is_error <- inherits(cond, "error")
[16:04:45.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.220]                   NULL)
[16:04:45.220]                 if (is_error) {
[16:04:45.220]                   sessionInformation <- function() {
[16:04:45.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.220]                       search = base::search(), system = base::Sys.info())
[16:04:45.220]                   }
[16:04:45.220]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.220]                     cond$call), session = sessionInformation(), 
[16:04:45.220]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.220]                   signalCondition(cond)
[16:04:45.220]                 }
[16:04:45.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.220]                 "immediateCondition"))) {
[16:04:45.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.220]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.220]                   if (TRUE && !signal) {
[16:04:45.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.220]                     {
[16:04:45.220]                       inherits <- base::inherits
[16:04:45.220]                       invokeRestart <- base::invokeRestart
[16:04:45.220]                       is.null <- base::is.null
[16:04:45.220]                       muffled <- FALSE
[16:04:45.220]                       if (inherits(cond, "message")) {
[16:04:45.220]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.220]                         if (muffled) 
[16:04:45.220]                           invokeRestart("muffleMessage")
[16:04:45.220]                       }
[16:04:45.220]                       else if (inherits(cond, "warning")) {
[16:04:45.220]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.220]                         if (muffled) 
[16:04:45.220]                           invokeRestart("muffleWarning")
[16:04:45.220]                       }
[16:04:45.220]                       else if (inherits(cond, "condition")) {
[16:04:45.220]                         if (!is.null(pattern)) {
[16:04:45.220]                           computeRestarts <- base::computeRestarts
[16:04:45.220]                           grepl <- base::grepl
[16:04:45.220]                           restarts <- computeRestarts(cond)
[16:04:45.220]                           for (restart in restarts) {
[16:04:45.220]                             name <- restart$name
[16:04:45.220]                             if (is.null(name)) 
[16:04:45.220]                               next
[16:04:45.220]                             if (!grepl(pattern, name)) 
[16:04:45.220]                               next
[16:04:45.220]                             invokeRestart(restart)
[16:04:45.220]                             muffled <- TRUE
[16:04:45.220]                             break
[16:04:45.220]                           }
[16:04:45.220]                         }
[16:04:45.220]                       }
[16:04:45.220]                       invisible(muffled)
[16:04:45.220]                     }
[16:04:45.220]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.220]                   }
[16:04:45.220]                 }
[16:04:45.220]                 else {
[16:04:45.220]                   if (TRUE) {
[16:04:45.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.220]                     {
[16:04:45.220]                       inherits <- base::inherits
[16:04:45.220]                       invokeRestart <- base::invokeRestart
[16:04:45.220]                       is.null <- base::is.null
[16:04:45.220]                       muffled <- FALSE
[16:04:45.220]                       if (inherits(cond, "message")) {
[16:04:45.220]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.220]                         if (muffled) 
[16:04:45.220]                           invokeRestart("muffleMessage")
[16:04:45.220]                       }
[16:04:45.220]                       else if (inherits(cond, "warning")) {
[16:04:45.220]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.220]                         if (muffled) 
[16:04:45.220]                           invokeRestart("muffleWarning")
[16:04:45.220]                       }
[16:04:45.220]                       else if (inherits(cond, "condition")) {
[16:04:45.220]                         if (!is.null(pattern)) {
[16:04:45.220]                           computeRestarts <- base::computeRestarts
[16:04:45.220]                           grepl <- base::grepl
[16:04:45.220]                           restarts <- computeRestarts(cond)
[16:04:45.220]                           for (restart in restarts) {
[16:04:45.220]                             name <- restart$name
[16:04:45.220]                             if (is.null(name)) 
[16:04:45.220]                               next
[16:04:45.220]                             if (!grepl(pattern, name)) 
[16:04:45.220]                               next
[16:04:45.220]                             invokeRestart(restart)
[16:04:45.220]                             muffled <- TRUE
[16:04:45.220]                             break
[16:04:45.220]                           }
[16:04:45.220]                         }
[16:04:45.220]                       }
[16:04:45.220]                       invisible(muffled)
[16:04:45.220]                     }
[16:04:45.220]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.220]                   }
[16:04:45.220]                 }
[16:04:45.220]             }
[16:04:45.220]         }))
[16:04:45.220]     }, error = function(ex) {
[16:04:45.220]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.220]                 ...future.rng), started = ...future.startTime, 
[16:04:45.220]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.220]             version = "1.8"), class = "FutureResult")
[16:04:45.220]     }, finally = {
[16:04:45.220]         if (!identical(...future.workdir, getwd())) 
[16:04:45.220]             setwd(...future.workdir)
[16:04:45.220]         {
[16:04:45.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.220]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.220]             }
[16:04:45.220]             base::options(...future.oldOptions)
[16:04:45.220]             if (.Platform$OS.type == "windows") {
[16:04:45.220]                 old_names <- names(...future.oldEnvVars)
[16:04:45.220]                 envs <- base::Sys.getenv()
[16:04:45.220]                 names <- names(envs)
[16:04:45.220]                 common <- intersect(names, old_names)
[16:04:45.220]                 added <- setdiff(names, old_names)
[16:04:45.220]                 removed <- setdiff(old_names, names)
[16:04:45.220]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.220]                   envs[common]]
[16:04:45.220]                 NAMES <- toupper(changed)
[16:04:45.220]                 args <- list()
[16:04:45.220]                 for (kk in seq_along(NAMES)) {
[16:04:45.220]                   name <- changed[[kk]]
[16:04:45.220]                   NAME <- NAMES[[kk]]
[16:04:45.220]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.220]                     next
[16:04:45.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.220]                 }
[16:04:45.220]                 NAMES <- toupper(added)
[16:04:45.220]                 for (kk in seq_along(NAMES)) {
[16:04:45.220]                   name <- added[[kk]]
[16:04:45.220]                   NAME <- NAMES[[kk]]
[16:04:45.220]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.220]                     next
[16:04:45.220]                   args[[name]] <- ""
[16:04:45.220]                 }
[16:04:45.220]                 NAMES <- toupper(removed)
[16:04:45.220]                 for (kk in seq_along(NAMES)) {
[16:04:45.220]                   name <- removed[[kk]]
[16:04:45.220]                   NAME <- NAMES[[kk]]
[16:04:45.220]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.220]                     next
[16:04:45.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.220]                 }
[16:04:45.220]                 if (length(args) > 0) 
[16:04:45.220]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.220]             }
[16:04:45.220]             else {
[16:04:45.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.220]             }
[16:04:45.220]             {
[16:04:45.220]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.220]                   0L) {
[16:04:45.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.220]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.220]                   base::options(opts)
[16:04:45.220]                 }
[16:04:45.220]                 {
[16:04:45.220]                   {
[16:04:45.220]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.220]                     NULL
[16:04:45.220]                   }
[16:04:45.220]                   options(future.plan = NULL)
[16:04:45.220]                   if (is.na(NA_character_)) 
[16:04:45.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.220]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:45.220]                     envir = parent.frame()) 
[16:04:45.220]                   {
[16:04:45.220]                     default_workers <- missing(workers)
[16:04:45.220]                     if (is.function(workers)) 
[16:04:45.220]                       workers <- workers()
[16:04:45.220]                     workers <- structure(as.integer(workers), 
[16:04:45.220]                       class = class(workers))
[16:04:45.220]                     stop_if_not(is.finite(workers), workers >= 
[16:04:45.220]                       1L)
[16:04:45.220]                     if ((workers == 1L && !inherits(workers, 
[16:04:45.220]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:45.220]                       if (default_workers) 
[16:04:45.220]                         supportsMulticore(warn = TRUE)
[16:04:45.220]                       return(sequential(..., envir = envir))
[16:04:45.220]                     }
[16:04:45.220]                     oopts <- options(mc.cores = workers)
[16:04:45.220]                     on.exit(options(oopts))
[16:04:45.220]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:45.220]                       envir = envir)
[16:04:45.220]                     if (!future$lazy) 
[16:04:45.220]                       future <- run(future)
[16:04:45.220]                     invisible(future)
[16:04:45.220]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.220]                 }
[16:04:45.220]             }
[16:04:45.220]         }
[16:04:45.220]     })
[16:04:45.220]     if (TRUE) {
[16:04:45.220]         base::sink(type = "output", split = FALSE)
[16:04:45.220]         if (TRUE) {
[16:04:45.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.220]         }
[16:04:45.220]         else {
[16:04:45.220]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.220]         }
[16:04:45.220]         base::close(...future.stdout)
[16:04:45.220]         ...future.stdout <- NULL
[16:04:45.220]     }
[16:04:45.220]     ...future.result$conditions <- ...future.conditions
[16:04:45.220]     ...future.result$finished <- base::Sys.time()
[16:04:45.220]     ...future.result
[16:04:45.220] }
[16:04:45.224] requestCore(): workers = 2
[16:04:45.225] Poll #1 (0): usedCores() = 2, workers = 2
[16:04:45.236] result() for MulticoreFuture ...
[16:04:45.237] result() for MulticoreFuture ...
[16:04:45.237] result() for MulticoreFuture ... done
[16:04:45.237] result() for MulticoreFuture ... done
[16:04:45.237] result() for MulticoreFuture ...
[16:04:45.237] result() for MulticoreFuture ... done
[16:04:45.241] MulticoreFuture started
[16:04:45.241] - Launch lazy future ... done
[16:04:45.242] run() for ‘MulticoreFuture’ ... done
[16:04:45.242] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55874f9994a0> 
[16:04:45.242] List of future strategies:
[16:04:45.242] 1. sequential:
[16:04:45.242]    - args: function (..., envir = parent.frame())
[16:04:45.242]    - tweaked: FALSE
[16:04:45.242]    - call: NULL
[16:04:45.243] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55874d764260> 
 - attr(*, "dim.")=[16:04:45.245] plan(): Setting new future strategy stack:
 int [1:3] 2 3 1
 - attr(*, "dimnames.")=[16:04:45.245] List of future strategies:
[16:04:45.245] 1. multicore:
[16:04:45.245]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:45.245]    - tweaked: FALSE
[16:04:45.245]    - call: plan(strategy)
List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:04:45.251] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:45.256] resolve() on list environment ...
[16:04:45.256]  recursive: 0
[16:04:45.258]  length: 6
[16:04:45.258]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:45.259] signalConditionsASAP(numeric, pos=1) ...
[16:04:45.259] - nx: 6
[16:04:45.259] - relay: TRUE
[16:04:45.259] - stdout: TRUE
[16:04:45.259] - signal: TRUE
[16:04:45.259] - resignal: FALSE
[16:04:45.260] - force: TRUE
[16:04:45.260] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.260] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.260]  - until=2
[16:04:45.260]  - relaying element #2
[16:04:45.260] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.260] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.261] signalConditionsASAP(NULL, pos=1) ... done
[16:04:45.261]  length: 5 (resolved future 1)
[16:04:45.261] Future #2
[16:04:45.261] result() for MulticoreFuture ...
[16:04:45.261] result() for MulticoreFuture ... done
[16:04:45.261] result() for MulticoreFuture ...
[16:04:45.262] result() for MulticoreFuture ... done
[16:04:45.262] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:45.262] - nx: 6
[16:04:45.262] - relay: TRUE
[16:04:45.262] - stdout: TRUE
[16:04:45.262] - signal: TRUE
[16:04:45.262] - resignal: FALSE
[16:04:45.263] - force: TRUE
[16:04:45.263] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.263] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.263]  - until=2
[16:04:45.263]  - relaying element #2
[16:04:45.263] result() for MulticoreFuture ...
[16:04:45.264] result() for MulticoreFuture ... done
[16:04:45.264] result() for MulticoreFuture ...
[16:04:45.264] result() for MulticoreFuture ... done
[16:04:45.264] result() for MulticoreFuture ...
[16:04:45.264] result() for MulticoreFuture ... done
[16:04:45.264] result() for MulticoreFuture ...
[16:04:45.264] result() for MulticoreFuture ... done
[16:04:45.265] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.265] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.265] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:45.265]  length: 4 (resolved future 2)
[16:04:45.265] Future #3
[16:04:45.266] result() for MulticoreFuture ...
[16:04:45.266] result() for MulticoreFuture ...
[16:04:45.267] result() for MulticoreFuture ... done
[16:04:45.267] result() for MulticoreFuture ... done
[16:04:45.267] result() for MulticoreFuture ...
[16:04:45.267] result() for MulticoreFuture ... done
[16:04:45.267] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:45.268] - nx: 6
[16:04:45.268] - relay: TRUE
[16:04:45.268] - stdout: TRUE
[16:04:45.268] - signal: TRUE
[16:04:45.268] - resignal: FALSE
[16:04:45.268] - force: TRUE
[16:04:45.269] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.269] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.269]  - until=3
[16:04:45.269]  - relaying element #3
[16:04:45.269] result() for MulticoreFuture ...
[16:04:45.270] result() for MulticoreFuture ... done
[16:04:45.270] result() for MulticoreFuture ...
[16:04:45.270] result() for MulticoreFuture ... done
[16:04:45.270] result() for MulticoreFuture ...
[16:04:45.270] result() for MulticoreFuture ... done
[16:04:45.271] result() for MulticoreFuture ...
[16:04:45.271] result() for MulticoreFuture ... done
[16:04:45.271] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.271] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.271] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:45.271]  length: 3 (resolved future 3)
[16:04:45.272] Future #4
[16:04:45.272] result() for MulticoreFuture ...
[16:04:45.273] result() for MulticoreFuture ...
[16:04:45.273] result() for MulticoreFuture ... done
[16:04:45.273] result() for MulticoreFuture ... done
[16:04:45.273] result() for MulticoreFuture ...
[16:04:45.273] result() for MulticoreFuture ... done
[16:04:45.273] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:04:45.273] - nx: 6
[16:04:45.274] - relay: TRUE
[16:04:45.274] - stdout: TRUE
[16:04:45.274] - signal: TRUE
[16:04:45.274] - resignal: FALSE
[16:04:45.274] - force: TRUE
[16:04:45.274] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.274] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.274]  - until=4
[16:04:45.275]  - relaying element #4
[16:04:45.275] result() for MulticoreFuture ...
[16:04:45.275] result() for MulticoreFuture ... done
[16:04:45.275] result() for MulticoreFuture ...
[16:04:45.275] result() for MulticoreFuture ... done
[16:04:45.275] result() for MulticoreFuture ...
[16:04:45.275] result() for MulticoreFuture ... done
[16:04:45.275] result() for MulticoreFuture ...
[16:04:45.275] result() for MulticoreFuture ... done
[16:04:45.276] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.276] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.276] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:04:45.276]  length: 2 (resolved future 4)
[16:04:45.276] signalConditionsASAP(NULL, pos=5) ...
[16:04:45.276] - nx: 6
[16:04:45.276] - relay: TRUE
[16:04:45.276] - stdout: TRUE
[16:04:45.276] - signal: TRUE
[16:04:45.277] - resignal: FALSE
[16:04:45.277] - force: TRUE
[16:04:45.277] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.277] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.277]  - until=6
[16:04:45.277]  - relaying element #6
[16:04:45.277] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:45.277] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.277] signalConditionsASAP(NULL, pos=5) ... done
[16:04:45.277]  length: 1 (resolved future 5)
[16:04:45.278] signalConditionsASAP(numeric, pos=6) ...
[16:04:45.278] - nx: 6
[16:04:45.278] - relay: TRUE
[16:04:45.278] - stdout: TRUE
[16:04:45.278] - signal: TRUE
[16:04:45.278] - resignal: FALSE
[16:04:45.278] - force: TRUE
[16:04:45.278] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:45.278] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.278]  - until=6
[16:04:45.279] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:45.279] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.279] signalConditionsASAP(numeric, pos=6) ... done
[16:04:45.279]  length: 0 (resolved future 6)
[16:04:45.279] Relaying remaining futures
[16:04:45.279] signalConditionsASAP(NULL, pos=0) ...
[16:04:45.279] - nx: 6
[16:04:45.279] - relay: TRUE
[16:04:45.279] - stdout: TRUE
[16:04:45.280] - signal: TRUE
[16:04:45.280] - resignal: FALSE
[16:04:45.280] - force: TRUE
[16:04:45.280] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:45.280] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:45.280] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:45.280] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.280] signalConditionsASAP(NULL, pos=0) ... done
[16:04:45.280] resolve() on list environment ... DONE
[16:04:45.281] result() for MulticoreFuture ...
[16:04:45.281] result() for MulticoreFuture ... done
[16:04:45.281] result() for MulticoreFuture ...
[16:04:45.281] result() for MulticoreFuture ... done
[16:04:45.281] result() for MulticoreFuture ...
[16:04:45.281] result() for MulticoreFuture ... done
[16:04:45.281] result() for MulticoreFuture ...
[16:04:45.281] result() for MulticoreFuture ... done
[16:04:45.282] result() for MulticoreFuture ...
[16:04:45.282] result() for MulticoreFuture ... done
[16:04:45.282] result() for MulticoreFuture ...
[16:04:45.282] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55874c814210> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:04:45.284] getGlobalsAndPackages() ...
[16:04:45.284] Searching for globals...
[16:04:45.285] 
[16:04:45.285] Searching for globals ... DONE
[16:04:45.285] - globals: [0] <none>
[16:04:45.285] getGlobalsAndPackages() ... DONE
[16:04:45.285] run() for ‘Future’ ...
[16:04:45.286] - state: ‘created’
[16:04:45.286] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:45.290] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:45.290] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:45.290]   - Field: ‘label’
[16:04:45.291]   - Field: ‘local’
[16:04:45.291]   - Field: ‘owner’
[16:04:45.291]   - Field: ‘envir’
[16:04:45.291]   - Field: ‘workers’
[16:04:45.291]   - Field: ‘packages’
[16:04:45.291]   - Field: ‘gc’
[16:04:45.291]   - Field: ‘job’
[16:04:45.291]   - Field: ‘conditions’
[16:04:45.292]   - Field: ‘expr’
[16:04:45.292]   - Field: ‘uuid’
[16:04:45.292]   - Field: ‘seed’
[16:04:45.292]   - Field: ‘version’
[16:04:45.292]   - Field: ‘result’
[16:04:45.292]   - Field: ‘asynchronous’
[16:04:45.292]   - Field: ‘calls’
[16:04:45.292]   - Field: ‘globals’
[16:04:45.292]   - Field: ‘stdout’
[16:04:45.293]   - Field: ‘earlySignal’
[16:04:45.293]   - Field: ‘lazy’
[16:04:45.293]   - Field: ‘state’
[16:04:45.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:45.293] - Launch lazy future ...
[16:04:45.293] Packages needed by the future expression (n = 0): <none>
[16:04:45.293] Packages needed by future strategies (n = 0): <none>
[16:04:45.294] {
[16:04:45.294]     {
[16:04:45.294]         {
[16:04:45.294]             ...future.startTime <- base::Sys.time()
[16:04:45.294]             {
[16:04:45.294]                 {
[16:04:45.294]                   {
[16:04:45.294]                     {
[16:04:45.294]                       base::local({
[16:04:45.294]                         has_future <- base::requireNamespace("future", 
[16:04:45.294]                           quietly = TRUE)
[16:04:45.294]                         if (has_future) {
[16:04:45.294]                           ns <- base::getNamespace("future")
[16:04:45.294]                           version <- ns[[".package"]][["version"]]
[16:04:45.294]                           if (is.null(version)) 
[16:04:45.294]                             version <- utils::packageVersion("future")
[16:04:45.294]                         }
[16:04:45.294]                         else {
[16:04:45.294]                           version <- NULL
[16:04:45.294]                         }
[16:04:45.294]                         if (!has_future || version < "1.8.0") {
[16:04:45.294]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.294]                             "", base::R.version$version.string), 
[16:04:45.294]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.294]                               "release", "version")], collapse = " "), 
[16:04:45.294]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.294]                             info)
[16:04:45.294]                           info <- base::paste(info, collapse = "; ")
[16:04:45.294]                           if (!has_future) {
[16:04:45.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.294]                               info)
[16:04:45.294]                           }
[16:04:45.294]                           else {
[16:04:45.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.294]                               info, version)
[16:04:45.294]                           }
[16:04:45.294]                           base::stop(msg)
[16:04:45.294]                         }
[16:04:45.294]                       })
[16:04:45.294]                     }
[16:04:45.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.294]                     base::options(mc.cores = 1L)
[16:04:45.294]                   }
[16:04:45.294]                   options(future.plan = NULL)
[16:04:45.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.294]                 }
[16:04:45.294]                 ...future.workdir <- getwd()
[16:04:45.294]             }
[16:04:45.294]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.294]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.294]         }
[16:04:45.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.294]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.294]             base::names(...future.oldOptions))
[16:04:45.294]     }
[16:04:45.294]     if (FALSE) {
[16:04:45.294]     }
[16:04:45.294]     else {
[16:04:45.294]         if (TRUE) {
[16:04:45.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.294]                 open = "w")
[16:04:45.294]         }
[16:04:45.294]         else {
[16:04:45.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.294]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.294]         }
[16:04:45.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.294]             base::sink(type = "output", split = FALSE)
[16:04:45.294]             base::close(...future.stdout)
[16:04:45.294]         }, add = TRUE)
[16:04:45.294]     }
[16:04:45.294]     ...future.frame <- base::sys.nframe()
[16:04:45.294]     ...future.conditions <- base::list()
[16:04:45.294]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.294]     if (FALSE) {
[16:04:45.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.294]     }
[16:04:45.294]     ...future.result <- base::tryCatch({
[16:04:45.294]         base::withCallingHandlers({
[16:04:45.294]             ...future.value <- base::withVisible(base::local({
[16:04:45.294]                 withCallingHandlers({
[16:04:45.294]                   2
[16:04:45.294]                 }, immediateCondition = function(cond) {
[16:04:45.294]                   save_rds <- function (object, pathname, ...) 
[16:04:45.294]                   {
[16:04:45.294]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:45.294]                     if (file_test("-f", pathname_tmp)) {
[16:04:45.294]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.294]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:45.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.294]                         fi_tmp[["mtime"]])
[16:04:45.294]                     }
[16:04:45.294]                     tryCatch({
[16:04:45.294]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:45.294]                     }, error = function(ex) {
[16:04:45.294]                       msg <- conditionMessage(ex)
[16:04:45.294]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.294]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:45.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.294]                         fi_tmp[["mtime"]], msg)
[16:04:45.294]                       ex$message <- msg
[16:04:45.294]                       stop(ex)
[16:04:45.294]                     })
[16:04:45.294]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:45.294]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:45.294]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:45.294]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.294]                       fi <- file.info(pathname)
[16:04:45.294]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:45.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.294]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:45.294]                         fi[["size"]], fi[["mtime"]])
[16:04:45.294]                       stop(msg)
[16:04:45.294]                     }
[16:04:45.294]                     invisible(pathname)
[16:04:45.294]                   }
[16:04:45.294]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:45.294]                     rootPath = tempdir()) 
[16:04:45.294]                   {
[16:04:45.294]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:45.294]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:45.294]                       tmpdir = path, fileext = ".rds")
[16:04:45.294]                     save_rds(obj, file)
[16:04:45.294]                   }
[16:04:45.294]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:45.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.294]                   {
[16:04:45.294]                     inherits <- base::inherits
[16:04:45.294]                     invokeRestart <- base::invokeRestart
[16:04:45.294]                     is.null <- base::is.null
[16:04:45.294]                     muffled <- FALSE
[16:04:45.294]                     if (inherits(cond, "message")) {
[16:04:45.294]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.294]                       if (muffled) 
[16:04:45.294]                         invokeRestart("muffleMessage")
[16:04:45.294]                     }
[16:04:45.294]                     else if (inherits(cond, "warning")) {
[16:04:45.294]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.294]                       if (muffled) 
[16:04:45.294]                         invokeRestart("muffleWarning")
[16:04:45.294]                     }
[16:04:45.294]                     else if (inherits(cond, "condition")) {
[16:04:45.294]                       if (!is.null(pattern)) {
[16:04:45.294]                         computeRestarts <- base::computeRestarts
[16:04:45.294]                         grepl <- base::grepl
[16:04:45.294]                         restarts <- computeRestarts(cond)
[16:04:45.294]                         for (restart in restarts) {
[16:04:45.294]                           name <- restart$name
[16:04:45.294]                           if (is.null(name)) 
[16:04:45.294]                             next
[16:04:45.294]                           if (!grepl(pattern, name)) 
[16:04:45.294]                             next
[16:04:45.294]                           invokeRestart(restart)
[16:04:45.294]                           muffled <- TRUE
[16:04:45.294]                           break
[16:04:45.294]                         }
[16:04:45.294]                       }
[16:04:45.294]                     }
[16:04:45.294]                     invisible(muffled)
[16:04:45.294]                   }
[16:04:45.294]                   muffleCondition(cond)
[16:04:45.294]                 })
[16:04:45.294]             }))
[16:04:45.294]             future::FutureResult(value = ...future.value$value, 
[16:04:45.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.294]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.294]                     ...future.globalenv.names))
[16:04:45.294]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.294]         }, condition = base::local({
[16:04:45.294]             c <- base::c
[16:04:45.294]             inherits <- base::inherits
[16:04:45.294]             invokeRestart <- base::invokeRestart
[16:04:45.294]             length <- base::length
[16:04:45.294]             list <- base::list
[16:04:45.294]             seq.int <- base::seq.int
[16:04:45.294]             signalCondition <- base::signalCondition
[16:04:45.294]             sys.calls <- base::sys.calls
[16:04:45.294]             `[[` <- base::`[[`
[16:04:45.294]             `+` <- base::`+`
[16:04:45.294]             `<<-` <- base::`<<-`
[16:04:45.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.294]                   3L)]
[16:04:45.294]             }
[16:04:45.294]             function(cond) {
[16:04:45.294]                 is_error <- inherits(cond, "error")
[16:04:45.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.294]                   NULL)
[16:04:45.294]                 if (is_error) {
[16:04:45.294]                   sessionInformation <- function() {
[16:04:45.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.294]                       search = base::search(), system = base::Sys.info())
[16:04:45.294]                   }
[16:04:45.294]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.294]                     cond$call), session = sessionInformation(), 
[16:04:45.294]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.294]                   signalCondition(cond)
[16:04:45.294]                 }
[16:04:45.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.294]                 "immediateCondition"))) {
[16:04:45.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.294]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.294]                   if (TRUE && !signal) {
[16:04:45.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.294]                     {
[16:04:45.294]                       inherits <- base::inherits
[16:04:45.294]                       invokeRestart <- base::invokeRestart
[16:04:45.294]                       is.null <- base::is.null
[16:04:45.294]                       muffled <- FALSE
[16:04:45.294]                       if (inherits(cond, "message")) {
[16:04:45.294]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.294]                         if (muffled) 
[16:04:45.294]                           invokeRestart("muffleMessage")
[16:04:45.294]                       }
[16:04:45.294]                       else if (inherits(cond, "warning")) {
[16:04:45.294]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.294]                         if (muffled) 
[16:04:45.294]                           invokeRestart("muffleWarning")
[16:04:45.294]                       }
[16:04:45.294]                       else if (inherits(cond, "condition")) {
[16:04:45.294]                         if (!is.null(pattern)) {
[16:04:45.294]                           computeRestarts <- base::computeRestarts
[16:04:45.294]                           grepl <- base::grepl
[16:04:45.294]                           restarts <- computeRestarts(cond)
[16:04:45.294]                           for (restart in restarts) {
[16:04:45.294]                             name <- restart$name
[16:04:45.294]                             if (is.null(name)) 
[16:04:45.294]                               next
[16:04:45.294]                             if (!grepl(pattern, name)) 
[16:04:45.294]                               next
[16:04:45.294]                             invokeRestart(restart)
[16:04:45.294]                             muffled <- TRUE
[16:04:45.294]                             break
[16:04:45.294]                           }
[16:04:45.294]                         }
[16:04:45.294]                       }
[16:04:45.294]                       invisible(muffled)
[16:04:45.294]                     }
[16:04:45.294]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.294]                   }
[16:04:45.294]                 }
[16:04:45.294]                 else {
[16:04:45.294]                   if (TRUE) {
[16:04:45.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.294]                     {
[16:04:45.294]                       inherits <- base::inherits
[16:04:45.294]                       invokeRestart <- base::invokeRestart
[16:04:45.294]                       is.null <- base::is.null
[16:04:45.294]                       muffled <- FALSE
[16:04:45.294]                       if (inherits(cond, "message")) {
[16:04:45.294]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.294]                         if (muffled) 
[16:04:45.294]                           invokeRestart("muffleMessage")
[16:04:45.294]                       }
[16:04:45.294]                       else if (inherits(cond, "warning")) {
[16:04:45.294]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.294]                         if (muffled) 
[16:04:45.294]                           invokeRestart("muffleWarning")
[16:04:45.294]                       }
[16:04:45.294]                       else if (inherits(cond, "condition")) {
[16:04:45.294]                         if (!is.null(pattern)) {
[16:04:45.294]                           computeRestarts <- base::computeRestarts
[16:04:45.294]                           grepl <- base::grepl
[16:04:45.294]                           restarts <- computeRestarts(cond)
[16:04:45.294]                           for (restart in restarts) {
[16:04:45.294]                             name <- restart$name
[16:04:45.294]                             if (is.null(name)) 
[16:04:45.294]                               next
[16:04:45.294]                             if (!grepl(pattern, name)) 
[16:04:45.294]                               next
[16:04:45.294]                             invokeRestart(restart)
[16:04:45.294]                             muffled <- TRUE
[16:04:45.294]                             break
[16:04:45.294]                           }
[16:04:45.294]                         }
[16:04:45.294]                       }
[16:04:45.294]                       invisible(muffled)
[16:04:45.294]                     }
[16:04:45.294]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.294]                   }
[16:04:45.294]                 }
[16:04:45.294]             }
[16:04:45.294]         }))
[16:04:45.294]     }, error = function(ex) {
[16:04:45.294]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.294]                 ...future.rng), started = ...future.startTime, 
[16:04:45.294]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.294]             version = "1.8"), class = "FutureResult")
[16:04:45.294]     }, finally = {
[16:04:45.294]         if (!identical(...future.workdir, getwd())) 
[16:04:45.294]             setwd(...future.workdir)
[16:04:45.294]         {
[16:04:45.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.294]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.294]             }
[16:04:45.294]             base::options(...future.oldOptions)
[16:04:45.294]             if (.Platform$OS.type == "windows") {
[16:04:45.294]                 old_names <- names(...future.oldEnvVars)
[16:04:45.294]                 envs <- base::Sys.getenv()
[16:04:45.294]                 names <- names(envs)
[16:04:45.294]                 common <- intersect(names, old_names)
[16:04:45.294]                 added <- setdiff(names, old_names)
[16:04:45.294]                 removed <- setdiff(old_names, names)
[16:04:45.294]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.294]                   envs[common]]
[16:04:45.294]                 NAMES <- toupper(changed)
[16:04:45.294]                 args <- list()
[16:04:45.294]                 for (kk in seq_along(NAMES)) {
[16:04:45.294]                   name <- changed[[kk]]
[16:04:45.294]                   NAME <- NAMES[[kk]]
[16:04:45.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.294]                     next
[16:04:45.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.294]                 }
[16:04:45.294]                 NAMES <- toupper(added)
[16:04:45.294]                 for (kk in seq_along(NAMES)) {
[16:04:45.294]                   name <- added[[kk]]
[16:04:45.294]                   NAME <- NAMES[[kk]]
[16:04:45.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.294]                     next
[16:04:45.294]                   args[[name]] <- ""
[16:04:45.294]                 }
[16:04:45.294]                 NAMES <- toupper(removed)
[16:04:45.294]                 for (kk in seq_along(NAMES)) {
[16:04:45.294]                   name <- removed[[kk]]
[16:04:45.294]                   NAME <- NAMES[[kk]]
[16:04:45.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.294]                     next
[16:04:45.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.294]                 }
[16:04:45.294]                 if (length(args) > 0) 
[16:04:45.294]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.294]             }
[16:04:45.294]             else {
[16:04:45.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.294]             }
[16:04:45.294]             {
[16:04:45.294]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.294]                   0L) {
[16:04:45.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.294]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.294]                   base::options(opts)
[16:04:45.294]                 }
[16:04:45.294]                 {
[16:04:45.294]                   {
[16:04:45.294]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.294]                     NULL
[16:04:45.294]                   }
[16:04:45.294]                   options(future.plan = NULL)
[16:04:45.294]                   if (is.na(NA_character_)) 
[16:04:45.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.294]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:45.294]                     envir = parent.frame()) 
[16:04:45.294]                   {
[16:04:45.294]                     default_workers <- missing(workers)
[16:04:45.294]                     if (is.function(workers)) 
[16:04:45.294]                       workers <- workers()
[16:04:45.294]                     workers <- structure(as.integer(workers), 
[16:04:45.294]                       class = class(workers))
[16:04:45.294]                     stop_if_not(is.finite(workers), workers >= 
[16:04:45.294]                       1L)
[16:04:45.294]                     if ((workers == 1L && !inherits(workers, 
[16:04:45.294]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:45.294]                       if (default_workers) 
[16:04:45.294]                         supportsMulticore(warn = TRUE)
[16:04:45.294]                       return(sequential(..., envir = envir))
[16:04:45.294]                     }
[16:04:45.294]                     oopts <- options(mc.cores = workers)
[16:04:45.294]                     on.exit(options(oopts))
[16:04:45.294]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:45.294]                       envir = envir)
[16:04:45.294]                     if (!future$lazy) 
[16:04:45.294]                       future <- run(future)
[16:04:45.294]                     invisible(future)
[16:04:45.294]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.294]                 }
[16:04:45.294]             }
[16:04:45.294]         }
[16:04:45.294]     })
[16:04:45.294]     if (TRUE) {
[16:04:45.294]         base::sink(type = "output", split = FALSE)
[16:04:45.294]         if (TRUE) {
[16:04:45.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.294]         }
[16:04:45.294]         else {
[16:04:45.294]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.294]         }
[16:04:45.294]         base::close(...future.stdout)
[16:04:45.294]         ...future.stdout <- NULL
[16:04:45.294]     }
[16:04:45.294]     ...future.result$conditions <- ...future.conditions
[16:04:45.294]     ...future.result$finished <- base::Sys.time()
[16:04:45.294]     ...future.result
[16:04:45.294] }
[16:04:45.297] requestCore(): workers = 2
[16:04:45.299] MulticoreFuture started
[16:04:45.300] - Launch lazy future ... done
[16:04:45.300] run() for ‘MulticoreFuture’ ... done
[16:04:45.300] getGlobalsAndPackages() ...
[16:04:45.300] Searching for globals...
[16:04:45.300] plan(): Setting new future strategy stack:
[16:04:45.301] 
[16:04:45.301] List of future strategies:
[16:04:45.301] 1. sequential:
[16:04:45.301]    - args: function (..., envir = parent.frame())
[16:04:45.301]    - tweaked: FALSE
[16:04:45.301]    - call: NULL
[16:04:45.301] Searching for globals ... DONE
[16:04:45.301] - globals: [0] <none>
[16:04:45.301] plan(): nbrOfWorkers() = 1
[16:04:45.302] getGlobalsAndPackages() ... DONE
[16:04:45.302] run() for ‘Future’ ...
[16:04:45.302] - state: ‘created’
[16:04:45.302] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:45.303] plan(): Setting new future strategy stack:
[16:04:45.303] List of future strategies:
[16:04:45.303] 1. multicore:
[16:04:45.303]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:45.303]    - tweaked: FALSE
[16:04:45.303]    - call: plan(strategy)
[16:04:45.308] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:45.308] plan(): nbrOfWorkers() = 2
[16:04:45.308] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:45.309]   - Field: ‘label’
[16:04:45.309]   - Field: ‘local’
[16:04:45.309]   - Field: ‘owner’
[16:04:45.309]   - Field: ‘envir’
[16:04:45.309]   - Field: ‘workers’
[16:04:45.309]   - Field: ‘packages’
[16:04:45.310]   - Field: ‘gc’
[16:04:45.310]   - Field: ‘job’
[16:04:45.310]   - Field: ‘conditions’
[16:04:45.310]   - Field: ‘expr’
[16:04:45.310]   - Field: ‘uuid’
[16:04:45.310]   - Field: ‘seed’
[16:04:45.310]   - Field: ‘version’
[16:04:45.311]   - Field: ‘result’
[16:04:45.311]   - Field: ‘asynchronous’
[16:04:45.311]   - Field: ‘calls’
[16:04:45.311]   - Field: ‘globals’
[16:04:45.311]   - Field: ‘stdout’
[16:04:45.311]   - Field: ‘earlySignal’
[16:04:45.311]   - Field: ‘lazy’
[16:04:45.312]   - Field: ‘state’
[16:04:45.312] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:45.312] - Launch lazy future ...
[16:04:45.312] Packages needed by the future expression (n = 0): <none>
[16:04:45.313] Packages needed by future strategies (n = 0): <none>
[16:04:45.313] {
[16:04:45.313]     {
[16:04:45.313]         {
[16:04:45.313]             ...future.startTime <- base::Sys.time()
[16:04:45.313]             {
[16:04:45.313]                 {
[16:04:45.313]                   {
[16:04:45.313]                     {
[16:04:45.313]                       base::local({
[16:04:45.313]                         has_future <- base::requireNamespace("future", 
[16:04:45.313]                           quietly = TRUE)
[16:04:45.313]                         if (has_future) {
[16:04:45.313]                           ns <- base::getNamespace("future")
[16:04:45.313]                           version <- ns[[".package"]][["version"]]
[16:04:45.313]                           if (is.null(version)) 
[16:04:45.313]                             version <- utils::packageVersion("future")
[16:04:45.313]                         }
[16:04:45.313]                         else {
[16:04:45.313]                           version <- NULL
[16:04:45.313]                         }
[16:04:45.313]                         if (!has_future || version < "1.8.0") {
[16:04:45.313]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.313]                             "", base::R.version$version.string), 
[16:04:45.313]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.313]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.313]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.313]                               "release", "version")], collapse = " "), 
[16:04:45.313]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.313]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.313]                             info)
[16:04:45.313]                           info <- base::paste(info, collapse = "; ")
[16:04:45.313]                           if (!has_future) {
[16:04:45.313]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.313]                               info)
[16:04:45.313]                           }
[16:04:45.313]                           else {
[16:04:45.313]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.313]                               info, version)
[16:04:45.313]                           }
[16:04:45.313]                           base::stop(msg)
[16:04:45.313]                         }
[16:04:45.313]                       })
[16:04:45.313]                     }
[16:04:45.313]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.313]                     base::options(mc.cores = 1L)
[16:04:45.313]                   }
[16:04:45.313]                   options(future.plan = NULL)
[16:04:45.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.313]                 }
[16:04:45.313]                 ...future.workdir <- getwd()
[16:04:45.313]             }
[16:04:45.313]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.313]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.313]         }
[16:04:45.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.313]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.313]             base::names(...future.oldOptions))
[16:04:45.313]     }
[16:04:45.313]     if (FALSE) {
[16:04:45.313]     }
[16:04:45.313]     else {
[16:04:45.313]         if (TRUE) {
[16:04:45.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.313]                 open = "w")
[16:04:45.313]         }
[16:04:45.313]         else {
[16:04:45.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.313]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.313]         }
[16:04:45.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.313]             base::sink(type = "output", split = FALSE)
[16:04:45.313]             base::close(...future.stdout)
[16:04:45.313]         }, add = TRUE)
[16:04:45.313]     }
[16:04:45.313]     ...future.frame <- base::sys.nframe()
[16:04:45.313]     ...future.conditions <- base::list()
[16:04:45.313]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.313]     if (FALSE) {
[16:04:45.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.313]     }
[16:04:45.313]     ...future.result <- base::tryCatch({
[16:04:45.313]         base::withCallingHandlers({
[16:04:45.313]             ...future.value <- base::withVisible(base::local({
[16:04:45.313]                 withCallingHandlers({
[16:04:45.313]                   NULL
[16:04:45.313]                 }, immediateCondition = function(cond) {
[16:04:45.313]                   save_rds <- function (object, pathname, ...) 
[16:04:45.313]                   {
[16:04:45.313]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:45.313]                     if (file_test("-f", pathname_tmp)) {
[16:04:45.313]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.313]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:45.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.313]                         fi_tmp[["mtime"]])
[16:04:45.313]                     }
[16:04:45.313]                     tryCatch({
[16:04:45.313]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:45.313]                     }, error = function(ex) {
[16:04:45.313]                       msg <- conditionMessage(ex)
[16:04:45.313]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.313]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:45.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.313]                         fi_tmp[["mtime"]], msg)
[16:04:45.313]                       ex$message <- msg
[16:04:45.313]                       stop(ex)
[16:04:45.313]                     })
[16:04:45.313]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:45.313]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:45.313]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:45.313]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.313]                       fi <- file.info(pathname)
[16:04:45.313]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:45.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.313]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:45.313]                         fi[["size"]], fi[["mtime"]])
[16:04:45.313]                       stop(msg)
[16:04:45.313]                     }
[16:04:45.313]                     invisible(pathname)
[16:04:45.313]                   }
[16:04:45.313]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:45.313]                     rootPath = tempdir()) 
[16:04:45.313]                   {
[16:04:45.313]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:45.313]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:45.313]                       tmpdir = path, fileext = ".rds")
[16:04:45.313]                     save_rds(obj, file)
[16:04:45.313]                   }
[16:04:45.313]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:45.313]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.313]                   {
[16:04:45.313]                     inherits <- base::inherits
[16:04:45.313]                     invokeRestart <- base::invokeRestart
[16:04:45.313]                     is.null <- base::is.null
[16:04:45.313]                     muffled <- FALSE
[16:04:45.313]                     if (inherits(cond, "message")) {
[16:04:45.313]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.313]                       if (muffled) 
[16:04:45.313]                         invokeRestart("muffleMessage")
[16:04:45.313]                     }
[16:04:45.313]                     else if (inherits(cond, "warning")) {
[16:04:45.313]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.313]                       if (muffled) 
[16:04:45.313]                         invokeRestart("muffleWarning")
[16:04:45.313]                     }
[16:04:45.313]                     else if (inherits(cond, "condition")) {
[16:04:45.313]                       if (!is.null(pattern)) {
[16:04:45.313]                         computeRestarts <- base::computeRestarts
[16:04:45.313]                         grepl <- base::grepl
[16:04:45.313]                         restarts <- computeRestarts(cond)
[16:04:45.313]                         for (restart in restarts) {
[16:04:45.313]                           name <- restart$name
[16:04:45.313]                           if (is.null(name)) 
[16:04:45.313]                             next
[16:04:45.313]                           if (!grepl(pattern, name)) 
[16:04:45.313]                             next
[16:04:45.313]                           invokeRestart(restart)
[16:04:45.313]                           muffled <- TRUE
[16:04:45.313]                           break
[16:04:45.313]                         }
[16:04:45.313]                       }
[16:04:45.313]                     }
[16:04:45.313]                     invisible(muffled)
[16:04:45.313]                   }
[16:04:45.313]                   muffleCondition(cond)
[16:04:45.313]                 })
[16:04:45.313]             }))
[16:04:45.313]             future::FutureResult(value = ...future.value$value, 
[16:04:45.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.313]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.313]                     ...future.globalenv.names))
[16:04:45.313]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.313]         }, condition = base::local({
[16:04:45.313]             c <- base::c
[16:04:45.313]             inherits <- base::inherits
[16:04:45.313]             invokeRestart <- base::invokeRestart
[16:04:45.313]             length <- base::length
[16:04:45.313]             list <- base::list
[16:04:45.313]             seq.int <- base::seq.int
[16:04:45.313]             signalCondition <- base::signalCondition
[16:04:45.313]             sys.calls <- base::sys.calls
[16:04:45.313]             `[[` <- base::`[[`
[16:04:45.313]             `+` <- base::`+`
[16:04:45.313]             `<<-` <- base::`<<-`
[16:04:45.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.313]                   3L)]
[16:04:45.313]             }
[16:04:45.313]             function(cond) {
[16:04:45.313]                 is_error <- inherits(cond, "error")
[16:04:45.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.313]                   NULL)
[16:04:45.313]                 if (is_error) {
[16:04:45.313]                   sessionInformation <- function() {
[16:04:45.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.313]                       search = base::search(), system = base::Sys.info())
[16:04:45.313]                   }
[16:04:45.313]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.313]                     cond$call), session = sessionInformation(), 
[16:04:45.313]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.313]                   signalCondition(cond)
[16:04:45.313]                 }
[16:04:45.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.313]                 "immediateCondition"))) {
[16:04:45.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.313]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.313]                   if (TRUE && !signal) {
[16:04:45.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.313]                     {
[16:04:45.313]                       inherits <- base::inherits
[16:04:45.313]                       invokeRestart <- base::invokeRestart
[16:04:45.313]                       is.null <- base::is.null
[16:04:45.313]                       muffled <- FALSE
[16:04:45.313]                       if (inherits(cond, "message")) {
[16:04:45.313]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.313]                         if (muffled) 
[16:04:45.313]                           invokeRestart("muffleMessage")
[16:04:45.313]                       }
[16:04:45.313]                       else if (inherits(cond, "warning")) {
[16:04:45.313]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.313]                         if (muffled) 
[16:04:45.313]                           invokeRestart("muffleWarning")
[16:04:45.313]                       }
[16:04:45.313]                       else if (inherits(cond, "condition")) {
[16:04:45.313]                         if (!is.null(pattern)) {
[16:04:45.313]                           computeRestarts <- base::computeRestarts
[16:04:45.313]                           grepl <- base::grepl
[16:04:45.313]                           restarts <- computeRestarts(cond)
[16:04:45.313]                           for (restart in restarts) {
[16:04:45.313]                             name <- restart$name
[16:04:45.313]                             if (is.null(name)) 
[16:04:45.313]                               next
[16:04:45.313]                             if (!grepl(pattern, name)) 
[16:04:45.313]                               next
[16:04:45.313]                             invokeRestart(restart)
[16:04:45.313]                             muffled <- TRUE
[16:04:45.313]                             break
[16:04:45.313]                           }
[16:04:45.313]                         }
[16:04:45.313]                       }
[16:04:45.313]                       invisible(muffled)
[16:04:45.313]                     }
[16:04:45.313]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.313]                   }
[16:04:45.313]                 }
[16:04:45.313]                 else {
[16:04:45.313]                   if (TRUE) {
[16:04:45.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.313]                     {
[16:04:45.313]                       inherits <- base::inherits
[16:04:45.313]                       invokeRestart <- base::invokeRestart
[16:04:45.313]                       is.null <- base::is.null
[16:04:45.313]                       muffled <- FALSE
[16:04:45.313]                       if (inherits(cond, "message")) {
[16:04:45.313]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.313]                         if (muffled) 
[16:04:45.313]                           invokeRestart("muffleMessage")
[16:04:45.313]                       }
[16:04:45.313]                       else if (inherits(cond, "warning")) {
[16:04:45.313]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.313]                         if (muffled) 
[16:04:45.313]                           invokeRestart("muffleWarning")
[16:04:45.313]                       }
[16:04:45.313]                       else if (inherits(cond, "condition")) {
[16:04:45.313]                         if (!is.null(pattern)) {
[16:04:45.313]                           computeRestarts <- base::computeRestarts
[16:04:45.313]                           grepl <- base::grepl
[16:04:45.313]                           restarts <- computeRestarts(cond)
[16:04:45.313]                           for (restart in restarts) {
[16:04:45.313]                             name <- restart$name
[16:04:45.313]                             if (is.null(name)) 
[16:04:45.313]                               next
[16:04:45.313]                             if (!grepl(pattern, name)) 
[16:04:45.313]                               next
[16:04:45.313]                             invokeRestart(restart)
[16:04:45.313]                             muffled <- TRUE
[16:04:45.313]                             break
[16:04:45.313]                           }
[16:04:45.313]                         }
[16:04:45.313]                       }
[16:04:45.313]                       invisible(muffled)
[16:04:45.313]                     }
[16:04:45.313]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.313]                   }
[16:04:45.313]                 }
[16:04:45.313]             }
[16:04:45.313]         }))
[16:04:45.313]     }, error = function(ex) {
[16:04:45.313]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.313]                 ...future.rng), started = ...future.startTime, 
[16:04:45.313]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.313]             version = "1.8"), class = "FutureResult")
[16:04:45.313]     }, finally = {
[16:04:45.313]         if (!identical(...future.workdir, getwd())) 
[16:04:45.313]             setwd(...future.workdir)
[16:04:45.313]         {
[16:04:45.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.313]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.313]             }
[16:04:45.313]             base::options(...future.oldOptions)
[16:04:45.313]             if (.Platform$OS.type == "windows") {
[16:04:45.313]                 old_names <- names(...future.oldEnvVars)
[16:04:45.313]                 envs <- base::Sys.getenv()
[16:04:45.313]                 names <- names(envs)
[16:04:45.313]                 common <- intersect(names, old_names)
[16:04:45.313]                 added <- setdiff(names, old_names)
[16:04:45.313]                 removed <- setdiff(old_names, names)
[16:04:45.313]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.313]                   envs[common]]
[16:04:45.313]                 NAMES <- toupper(changed)
[16:04:45.313]                 args <- list()
[16:04:45.313]                 for (kk in seq_along(NAMES)) {
[16:04:45.313]                   name <- changed[[kk]]
[16:04:45.313]                   NAME <- NAMES[[kk]]
[16:04:45.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.313]                     next
[16:04:45.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.313]                 }
[16:04:45.313]                 NAMES <- toupper(added)
[16:04:45.313]                 for (kk in seq_along(NAMES)) {
[16:04:45.313]                   name <- added[[kk]]
[16:04:45.313]                   NAME <- NAMES[[kk]]
[16:04:45.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.313]                     next
[16:04:45.313]                   args[[name]] <- ""
[16:04:45.313]                 }
[16:04:45.313]                 NAMES <- toupper(removed)
[16:04:45.313]                 for (kk in seq_along(NAMES)) {
[16:04:45.313]                   name <- removed[[kk]]
[16:04:45.313]                   NAME <- NAMES[[kk]]
[16:04:45.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.313]                     next
[16:04:45.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.313]                 }
[16:04:45.313]                 if (length(args) > 0) 
[16:04:45.313]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.313]             }
[16:04:45.313]             else {
[16:04:45.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.313]             }
[16:04:45.313]             {
[16:04:45.313]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.313]                   0L) {
[16:04:45.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.313]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.313]                   base::options(opts)
[16:04:45.313]                 }
[16:04:45.313]                 {
[16:04:45.313]                   {
[16:04:45.313]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.313]                     NULL
[16:04:45.313]                   }
[16:04:45.313]                   options(future.plan = NULL)
[16:04:45.313]                   if (is.na(NA_character_)) 
[16:04:45.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.313]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:45.313]                     envir = parent.frame()) 
[16:04:45.313]                   {
[16:04:45.313]                     default_workers <- missing(workers)
[16:04:45.313]                     if (is.function(workers)) 
[16:04:45.313]                       workers <- workers()
[16:04:45.313]                     workers <- structure(as.integer(workers), 
[16:04:45.313]                       class = class(workers))
[16:04:45.313]                     stop_if_not(is.finite(workers), workers >= 
[16:04:45.313]                       1L)
[16:04:45.313]                     if ((workers == 1L && !inherits(workers, 
[16:04:45.313]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:45.313]                       if (default_workers) 
[16:04:45.313]                         supportsMulticore(warn = TRUE)
[16:04:45.313]                       return(sequential(..., envir = envir))
[16:04:45.313]                     }
[16:04:45.313]                     oopts <- options(mc.cores = workers)
[16:04:45.313]                     on.exit(options(oopts))
[16:04:45.313]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:45.313]                       envir = envir)
[16:04:45.313]                     if (!future$lazy) 
[16:04:45.313]                       future <- run(future)
[16:04:45.313]                     invisible(future)
[16:04:45.313]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.313]                 }
[16:04:45.313]             }
[16:04:45.313]         }
[16:04:45.313]     })
[16:04:45.313]     if (TRUE) {
[16:04:45.313]         base::sink(type = "output", split = FALSE)
[16:04:45.313]         if (TRUE) {
[16:04:45.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.313]         }
[16:04:45.313]         else {
[16:04:45.313]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.313]         }
[16:04:45.313]         base::close(...future.stdout)
[16:04:45.313]         ...future.stdout <- NULL
[16:04:45.313]     }
[16:04:45.313]     ...future.result$conditions <- ...future.conditions
[16:04:45.313]     ...future.result$finished <- base::Sys.time()
[16:04:45.313]     ...future.result
[16:04:45.313] }
[16:04:45.317] requestCore(): workers = 2
[16:04:45.320] MulticoreFuture started
[16:04:45.320] - Launch lazy future ... done
[16:04:45.320] run() for ‘MulticoreFuture’ ... done
[16:04:45.321] plan(): Setting new future strategy stack:
[16:04:45.321] getGlobalsAndPackages() ...
[16:04:45.321] Searching for globals...
[16:04:45.321] List of future strategies:
[16:04:45.321] 1. sequential:
[16:04:45.321]    - args: function (..., envir = parent.frame())
[16:04:45.321]    - tweaked: FALSE
[16:04:45.321]    - call: NULL
[16:04:45.322] plan(): nbrOfWorkers() = 1
[16:04:45.323] - globals found: [1] ‘{’
[16:04:45.323] Searching for globals ... DONE
[16:04:45.323] Resolving globals: FALSE
[16:04:45.324] plan(): Setting new future strategy stack:
[16:04:45.324] 
[16:04:45.324] 
[16:04:45.324] getGlobalsAndPackages() ... DONE
[16:04:45.324] List of future strategies:
[16:04:45.324] 1. multicore:
[16:04:45.324]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:45.324]    - tweaked: FALSE
[16:04:45.324]    - call: plan(strategy)
[16:04:45.324] run() for ‘Future’ ...
[16:04:45.324] - state: ‘created’
[16:04:45.325] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:45.329] plan(): nbrOfWorkers() = 2
[16:04:45.329] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:45.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:45.330]   - Field: ‘label’
[16:04:45.330]   - Field: ‘local’
[16:04:45.330]   - Field: ‘owner’
[16:04:45.330]   - Field: ‘envir’
[16:04:45.330]   - Field: ‘workers’
[16:04:45.330]   - Field: ‘packages’
[16:04:45.331]   - Field: ‘gc’
[16:04:45.331]   - Field: ‘job’
[16:04:45.331]   - Field: ‘conditions’
[16:04:45.331]   - Field: ‘expr’
[16:04:45.331]   - Field: ‘uuid’
[16:04:45.332]   - Field: ‘seed’
[16:04:45.332]   - Field: ‘version’
[16:04:45.332]   - Field: ‘result’
[16:04:45.332]   - Field: ‘asynchronous’
[16:04:45.332]   - Field: ‘calls’
[16:04:45.332]   - Field: ‘globals’
[16:04:45.332]   - Field: ‘stdout’
[16:04:45.333]   - Field: ‘earlySignal’
[16:04:45.333]   - Field: ‘lazy’
[16:04:45.333]   - Field: ‘state’
[16:04:45.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:45.333] - Launch lazy future ...
[16:04:45.334] Packages needed by the future expression (n = 0): <none>
[16:04:45.334] Packages needed by future strategies (n = 0): <none>
[16:04:45.335] {
[16:04:45.335]     {
[16:04:45.335]         {
[16:04:45.335]             ...future.startTime <- base::Sys.time()
[16:04:45.335]             {
[16:04:45.335]                 {
[16:04:45.335]                   {
[16:04:45.335]                     {
[16:04:45.335]                       base::local({
[16:04:45.335]                         has_future <- base::requireNamespace("future", 
[16:04:45.335]                           quietly = TRUE)
[16:04:45.335]                         if (has_future) {
[16:04:45.335]                           ns <- base::getNamespace("future")
[16:04:45.335]                           version <- ns[[".package"]][["version"]]
[16:04:45.335]                           if (is.null(version)) 
[16:04:45.335]                             version <- utils::packageVersion("future")
[16:04:45.335]                         }
[16:04:45.335]                         else {
[16:04:45.335]                           version <- NULL
[16:04:45.335]                         }
[16:04:45.335]                         if (!has_future || version < "1.8.0") {
[16:04:45.335]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.335]                             "", base::R.version$version.string), 
[16:04:45.335]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.335]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.335]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.335]                               "release", "version")], collapse = " "), 
[16:04:45.335]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.335]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.335]                             info)
[16:04:45.335]                           info <- base::paste(info, collapse = "; ")
[16:04:45.335]                           if (!has_future) {
[16:04:45.335]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.335]                               info)
[16:04:45.335]                           }
[16:04:45.335]                           else {
[16:04:45.335]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.335]                               info, version)
[16:04:45.335]                           }
[16:04:45.335]                           base::stop(msg)
[16:04:45.335]                         }
[16:04:45.335]                       })
[16:04:45.335]                     }
[16:04:45.335]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.335]                     base::options(mc.cores = 1L)
[16:04:45.335]                   }
[16:04:45.335]                   options(future.plan = NULL)
[16:04:45.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.335]                 }
[16:04:45.335]                 ...future.workdir <- getwd()
[16:04:45.335]             }
[16:04:45.335]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.335]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.335]         }
[16:04:45.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.335]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.335]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.335]             base::names(...future.oldOptions))
[16:04:45.335]     }
[16:04:45.335]     if (FALSE) {
[16:04:45.335]     }
[16:04:45.335]     else {
[16:04:45.335]         if (TRUE) {
[16:04:45.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.335]                 open = "w")
[16:04:45.335]         }
[16:04:45.335]         else {
[16:04:45.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.335]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.335]         }
[16:04:45.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.335]             base::sink(type = "output", split = FALSE)
[16:04:45.335]             base::close(...future.stdout)
[16:04:45.335]         }, add = TRUE)
[16:04:45.335]     }
[16:04:45.335]     ...future.frame <- base::sys.nframe()
[16:04:45.335]     ...future.conditions <- base::list()
[16:04:45.335]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.335]     if (FALSE) {
[16:04:45.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.335]     }
[16:04:45.335]     ...future.result <- base::tryCatch({
[16:04:45.335]         base::withCallingHandlers({
[16:04:45.335]             ...future.value <- base::withVisible(base::local({
[16:04:45.335]                 withCallingHandlers({
[16:04:45.335]                   {
[16:04:45.335]                     4
[16:04:45.335]                   }
[16:04:45.335]                 }, immediateCondition = function(cond) {
[16:04:45.335]                   save_rds <- function (object, pathname, ...) 
[16:04:45.335]                   {
[16:04:45.335]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:45.335]                     if (file_test("-f", pathname_tmp)) {
[16:04:45.335]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.335]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:45.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.335]                         fi_tmp[["mtime"]])
[16:04:45.335]                     }
[16:04:45.335]                     tryCatch({
[16:04:45.335]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:45.335]                     }, error = function(ex) {
[16:04:45.335]                       msg <- conditionMessage(ex)
[16:04:45.335]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.335]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:45.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.335]                         fi_tmp[["mtime"]], msg)
[16:04:45.335]                       ex$message <- msg
[16:04:45.335]                       stop(ex)
[16:04:45.335]                     })
[16:04:45.335]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:45.335]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:45.335]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:45.335]                       fi_tmp <- file.info(pathname_tmp)
[16:04:45.335]                       fi <- file.info(pathname)
[16:04:45.335]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:45.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:45.335]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:45.335]                         fi[["size"]], fi[["mtime"]])
[16:04:45.335]                       stop(msg)
[16:04:45.335]                     }
[16:04:45.335]                     invisible(pathname)
[16:04:45.335]                   }
[16:04:45.335]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:45.335]                     rootPath = tempdir()) 
[16:04:45.335]                   {
[16:04:45.335]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:45.335]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:45.335]                       tmpdir = path, fileext = ".rds")
[16:04:45.335]                     save_rds(obj, file)
[16:04:45.335]                   }
[16:04:45.335]                   saveImmediateCondition(cond, path = "/tmp/RtmpKP9SHZ/.future/immediateConditions")
[16:04:45.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.335]                   {
[16:04:45.335]                     inherits <- base::inherits
[16:04:45.335]                     invokeRestart <- base::invokeRestart
[16:04:45.335]                     is.null <- base::is.null
[16:04:45.335]                     muffled <- FALSE
[16:04:45.335]                     if (inherits(cond, "message")) {
[16:04:45.335]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.335]                       if (muffled) 
[16:04:45.335]                         invokeRestart("muffleMessage")
[16:04:45.335]                     }
[16:04:45.335]                     else if (inherits(cond, "warning")) {
[16:04:45.335]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.335]                       if (muffled) 
[16:04:45.335]                         invokeRestart("muffleWarning")
[16:04:45.335]                     }
[16:04:45.335]                     else if (inherits(cond, "condition")) {
[16:04:45.335]                       if (!is.null(pattern)) {
[16:04:45.335]                         computeRestarts <- base::computeRestarts
[16:04:45.335]                         grepl <- base::grepl
[16:04:45.335]                         restarts <- computeRestarts(cond)
[16:04:45.335]                         for (restart in restarts) {
[16:04:45.335]                           name <- restart$name
[16:04:45.335]                           if (is.null(name)) 
[16:04:45.335]                             next
[16:04:45.335]                           if (!grepl(pattern, name)) 
[16:04:45.335]                             next
[16:04:45.335]                           invokeRestart(restart)
[16:04:45.335]                           muffled <- TRUE
[16:04:45.335]                           break
[16:04:45.335]                         }
[16:04:45.335]                       }
[16:04:45.335]                     }
[16:04:45.335]                     invisible(muffled)
[16:04:45.335]                   }
[16:04:45.335]                   muffleCondition(cond)
[16:04:45.335]                 })
[16:04:45.335]             }))
[16:04:45.335]             future::FutureResult(value = ...future.value$value, 
[16:04:45.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.335]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.335]                     ...future.globalenv.names))
[16:04:45.335]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.335]         }, condition = base::local({
[16:04:45.335]             c <- base::c
[16:04:45.335]             inherits <- base::inherits
[16:04:45.335]             invokeRestart <- base::invokeRestart
[16:04:45.335]             length <- base::length
[16:04:45.335]             list <- base::list
[16:04:45.335]             seq.int <- base::seq.int
[16:04:45.335]             signalCondition <- base::signalCondition
[16:04:45.335]             sys.calls <- base::sys.calls
[16:04:45.335]             `[[` <- base::`[[`
[16:04:45.335]             `+` <- base::`+`
[16:04:45.335]             `<<-` <- base::`<<-`
[16:04:45.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.335]                   3L)]
[16:04:45.335]             }
[16:04:45.335]             function(cond) {
[16:04:45.335]                 is_error <- inherits(cond, "error")
[16:04:45.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.335]                   NULL)
[16:04:45.335]                 if (is_error) {
[16:04:45.335]                   sessionInformation <- function() {
[16:04:45.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.335]                       search = base::search(), system = base::Sys.info())
[16:04:45.335]                   }
[16:04:45.335]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.335]                     cond$call), session = sessionInformation(), 
[16:04:45.335]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.335]                   signalCondition(cond)
[16:04:45.335]                 }
[16:04:45.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.335]                 "immediateCondition"))) {
[16:04:45.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.335]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.335]                   if (TRUE && !signal) {
[16:04:45.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.335]                     {
[16:04:45.335]                       inherits <- base::inherits
[16:04:45.335]                       invokeRestart <- base::invokeRestart
[16:04:45.335]                       is.null <- base::is.null
[16:04:45.335]                       muffled <- FALSE
[16:04:45.335]                       if (inherits(cond, "message")) {
[16:04:45.335]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.335]                         if (muffled) 
[16:04:45.335]                           invokeRestart("muffleMessage")
[16:04:45.335]                       }
[16:04:45.335]                       else if (inherits(cond, "warning")) {
[16:04:45.335]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.335]                         if (muffled) 
[16:04:45.335]                           invokeRestart("muffleWarning")
[16:04:45.335]                       }
[16:04:45.335]                       else if (inherits(cond, "condition")) {
[16:04:45.335]                         if (!is.null(pattern)) {
[16:04:45.335]                           computeRestarts <- base::computeRestarts
[16:04:45.335]                           grepl <- base::grepl
[16:04:45.335]                           restarts <- computeRestarts(cond)
[16:04:45.335]                           for (restart in restarts) {
[16:04:45.335]                             name <- restart$name
[16:04:45.335]                             if (is.null(name)) 
[16:04:45.335]                               next
[16:04:45.335]                             if (!grepl(pattern, name)) 
[16:04:45.335]                               next
[16:04:45.335]                             invokeRestart(restart)
[16:04:45.335]                             muffled <- TRUE
[16:04:45.335]                             break
[16:04:45.335]                           }
[16:04:45.335]                         }
[16:04:45.335]                       }
[16:04:45.335]                       invisible(muffled)
[16:04:45.335]                     }
[16:04:45.335]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.335]                   }
[16:04:45.335]                 }
[16:04:45.335]                 else {
[16:04:45.335]                   if (TRUE) {
[16:04:45.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.335]                     {
[16:04:45.335]                       inherits <- base::inherits
[16:04:45.335]                       invokeRestart <- base::invokeRestart
[16:04:45.335]                       is.null <- base::is.null
[16:04:45.335]                       muffled <- FALSE
[16:04:45.335]                       if (inherits(cond, "message")) {
[16:04:45.335]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.335]                         if (muffled) 
[16:04:45.335]                           invokeRestart("muffleMessage")
[16:04:45.335]                       }
[16:04:45.335]                       else if (inherits(cond, "warning")) {
[16:04:45.335]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.335]                         if (muffled) 
[16:04:45.335]                           invokeRestart("muffleWarning")
[16:04:45.335]                       }
[16:04:45.335]                       else if (inherits(cond, "condition")) {
[16:04:45.335]                         if (!is.null(pattern)) {
[16:04:45.335]                           computeRestarts <- base::computeRestarts
[16:04:45.335]                           grepl <- base::grepl
[16:04:45.335]                           restarts <- computeRestarts(cond)
[16:04:45.335]                           for (restart in restarts) {
[16:04:45.335]                             name <- restart$name
[16:04:45.335]                             if (is.null(name)) 
[16:04:45.335]                               next
[16:04:45.335]                             if (!grepl(pattern, name)) 
[16:04:45.335]                               next
[16:04:45.335]                             invokeRestart(restart)
[16:04:45.335]                             muffled <- TRUE
[16:04:45.335]                             break
[16:04:45.335]                           }
[16:04:45.335]                         }
[16:04:45.335]                       }
[16:04:45.335]                       invisible(muffled)
[16:04:45.335]                     }
[16:04:45.335]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.335]                   }
[16:04:45.335]                 }
[16:04:45.335]             }
[16:04:45.335]         }))
[16:04:45.335]     }, error = function(ex) {
[16:04:45.335]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.335]                 ...future.rng), started = ...future.startTime, 
[16:04:45.335]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.335]             version = "1.8"), class = "FutureResult")
[16:04:45.335]     }, finally = {
[16:04:45.335]         if (!identical(...future.workdir, getwd())) 
[16:04:45.335]             setwd(...future.workdir)
[16:04:45.335]         {
[16:04:45.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.335]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.335]             }
[16:04:45.335]             base::options(...future.oldOptions)
[16:04:45.335]             if (.Platform$OS.type == "windows") {
[16:04:45.335]                 old_names <- names(...future.oldEnvVars)
[16:04:45.335]                 envs <- base::Sys.getenv()
[16:04:45.335]                 names <- names(envs)
[16:04:45.335]                 common <- intersect(names, old_names)
[16:04:45.335]                 added <- setdiff(names, old_names)
[16:04:45.335]                 removed <- setdiff(old_names, names)
[16:04:45.335]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.335]                   envs[common]]
[16:04:45.335]                 NAMES <- toupper(changed)
[16:04:45.335]                 args <- list()
[16:04:45.335]                 for (kk in seq_along(NAMES)) {
[16:04:45.335]                   name <- changed[[kk]]
[16:04:45.335]                   NAME <- NAMES[[kk]]
[16:04:45.335]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.335]                     next
[16:04:45.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.335]                 }
[16:04:45.335]                 NAMES <- toupper(added)
[16:04:45.335]                 for (kk in seq_along(NAMES)) {
[16:04:45.335]                   name <- added[[kk]]
[16:04:45.335]                   NAME <- NAMES[[kk]]
[16:04:45.335]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.335]                     next
[16:04:45.335]                   args[[name]] <- ""
[16:04:45.335]                 }
[16:04:45.335]                 NAMES <- toupper(removed)
[16:04:45.335]                 for (kk in seq_along(NAMES)) {
[16:04:45.335]                   name <- removed[[kk]]
[16:04:45.335]                   NAME <- NAMES[[kk]]
[16:04:45.335]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.335]                     next
[16:04:45.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.335]                 }
[16:04:45.335]                 if (length(args) > 0) 
[16:04:45.335]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.335]             }
[16:04:45.335]             else {
[16:04:45.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.335]             }
[16:04:45.335]             {
[16:04:45.335]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.335]                   0L) {
[16:04:45.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.335]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.335]                   base::options(opts)
[16:04:45.335]                 }
[16:04:45.335]                 {
[16:04:45.335]                   {
[16:04:45.335]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.335]                     NULL
[16:04:45.335]                   }
[16:04:45.335]                   options(future.plan = NULL)
[16:04:45.335]                   if (is.na(NA_character_)) 
[16:04:45.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.335]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:45.335]                     envir = parent.frame()) 
[16:04:45.335]                   {
[16:04:45.335]                     default_workers <- missing(workers)
[16:04:45.335]                     if (is.function(workers)) 
[16:04:45.335]                       workers <- workers()
[16:04:45.335]                     workers <- structure(as.integer(workers), 
[16:04:45.335]                       class = class(workers))
[16:04:45.335]                     stop_if_not(is.finite(workers), workers >= 
[16:04:45.335]                       1L)
[16:04:45.335]                     if ((workers == 1L && !inherits(workers, 
[16:04:45.335]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:45.335]                       if (default_workers) 
[16:04:45.335]                         supportsMulticore(warn = TRUE)
[16:04:45.335]                       return(sequential(..., envir = envir))
[16:04:45.335]                     }
[16:04:45.335]                     oopts <- options(mc.cores = workers)
[16:04:45.335]                     on.exit(options(oopts))
[16:04:45.335]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:45.335]                       envir = envir)
[16:04:45.335]                     if (!future$lazy) 
[16:04:45.335]                       future <- run(future)
[16:04:45.335]                     invisible(future)
[16:04:45.335]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.335]                 }
[16:04:45.335]             }
[16:04:45.335]         }
[16:04:45.335]     })
[16:04:45.335]     if (TRUE) {
[16:04:45.335]         base::sink(type = "output", split = FALSE)
[16:04:45.335]         if (TRUE) {
[16:04:45.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.335]         }
[16:04:45.335]         else {
[16:04:45.335]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.335]         }
[16:04:45.335]         base::close(...future.stdout)
[16:04:45.335]         ...future.stdout <- NULL
[16:04:45.335]     }
[16:04:45.335]     ...future.result$conditions <- ...future.conditions
[16:04:45.335]     ...future.result$finished <- base::Sys.time()
[16:04:45.335]     ...future.result
[16:04:45.335] }
[16:04:45.339] requestCore(): workers = 2
[16:04:45.339] Poll #1 (0): usedCores() = 2, workers = 2
[16:04:45.350] result() for MulticoreFuture ...
[16:04:45.351] result() for MulticoreFuture ...
[16:04:45.351] result() for MulticoreFuture ... done
[16:04:45.351] result() for MulticoreFuture ... done
[16:04:45.351] result() for MulticoreFuture ...
[16:04:45.352] result() for MulticoreFuture ... done
[16:04:45.355] MulticoreFuture started
[16:04:45.355] - Launch lazy future ... done
[16:04:45.355] run() for ‘MulticoreFuture’ ... done
[16:04:45.356] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55874f12fa10> 
[16:04:45.356] List of future strategies:
[16:04:45.356] 1. sequential:
[16:04:45.356]    - args: function (..., envir = parent.frame())
[16:04:45.356]    - tweaked: FALSE
[16:04:45.356]    - call: NULL
[16:04:45.357] plan(): nbrOfWorkers() = 1
[16:04:45.367] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' [16:04:45.368] List of future strategies:
[16:04:45.368] 1. multicore:
[16:04:45.368]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:45.368]    - tweaked: FALSE
[16:04:45.368]    - call: plan(strategy)
<environment: 0x55874fcfa158> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:04:45.373] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:45.378] resolve() on list environment ...
[16:04:45.378]  recursive: 0
[16:04:45.380]  length: 6
[16:04:45.380]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:45.380] signalConditionsASAP(numeric, pos=1) ...
[16:04:45.380] - nx: 6
[16:04:45.381] - relay: TRUE
[16:04:45.381] - stdout: TRUE
[16:04:45.381] - signal: TRUE
[16:04:45.381] - resignal: FALSE
[16:04:45.381] - force: TRUE
[16:04:45.381] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.381] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.381]  - until=2
[16:04:45.381]  - relaying element #2
[16:04:45.382] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.382] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.382] signalConditionsASAP(NULL, pos=1) ... done
[16:04:45.382]  length: 5 (resolved future 1)
[16:04:45.382] Future #2
[16:04:45.382] result() for MulticoreFuture ...
[16:04:45.382] result() for MulticoreFuture ... done
[16:04:45.383] result() for MulticoreFuture ...
[16:04:45.383] result() for MulticoreFuture ... done
[16:04:45.383] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:04:45.383] - nx: 6
[16:04:45.383] - relay: TRUE
[16:04:45.383] - stdout: TRUE
[16:04:45.383] - signal: TRUE
[16:04:45.384] - resignal: FALSE
[16:04:45.384] - force: TRUE
[16:04:45.384] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.384] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.384]  - until=2
[16:04:45.384]  - relaying element #2
[16:04:45.384] result() for MulticoreFuture ...
[16:04:45.384] result() for MulticoreFuture ... done
[16:04:45.385] result() for MulticoreFuture ...
[16:04:45.385] result() for MulticoreFuture ... done
[16:04:45.385] result() for MulticoreFuture ...
[16:04:45.385] result() for MulticoreFuture ... done
[16:04:45.385] result() for MulticoreFuture ...
[16:04:45.385] result() for MulticoreFuture ... done
[16:04:45.385] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.385] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.386] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:04:45.386]  length: 4 (resolved future 2)
[16:04:45.386] Future #3
[16:04:45.386] result() for MulticoreFuture ...
[16:04:45.387] result() for MulticoreFuture ...
[16:04:45.387] result() for MulticoreFuture ... done
[16:04:45.387] result() for MulticoreFuture ... done
[16:04:45.387] result() for MulticoreFuture ...
[16:04:45.388] result() for MulticoreFuture ... done
[16:04:45.388] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:04:45.388] - nx: 6
[16:04:45.388] - relay: TRUE
[16:04:45.388] - stdout: TRUE
[16:04:45.388] - signal: TRUE
[16:04:45.388] - resignal: FALSE
[16:04:45.388] - force: TRUE
[16:04:45.389] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.389] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.389]  - until=3
[16:04:45.389]  - relaying element #3
[16:04:45.389] result() for MulticoreFuture ...
[16:04:45.389] result() for MulticoreFuture ... done
[16:04:45.389] result() for MulticoreFuture ...
[16:04:45.389] result() for MulticoreFuture ... done
[16:04:45.390] result() for MulticoreFuture ...
[16:04:45.390] result() for MulticoreFuture ... done
[16:04:45.390] result() for MulticoreFuture ...
[16:04:45.390] result() for MulticoreFuture ... done
[16:04:45.390] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.390] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.390] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:04:45.390]  length: 3 (resolved future 3)
[16:04:45.391] Future #4
[16:04:45.391] result() for MulticoreFuture ...
[16:04:45.392] result() for MulticoreFuture ...
[16:04:45.392] result() for MulticoreFuture ... done
[16:04:45.392] result() for MulticoreFuture ... done
[16:04:45.392] result() for MulticoreFuture ...
[16:04:45.392] result() for MulticoreFuture ... done
[16:04:45.392] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:04:45.392] - nx: 6
[16:04:45.392] - relay: TRUE
[16:04:45.393] - stdout: TRUE
[16:04:45.393] - signal: TRUE
[16:04:45.393] - resignal: FALSE
[16:04:45.393] - force: TRUE
[16:04:45.393] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.393] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.393]  - until=4
[16:04:45.393]  - relaying element #4
[16:04:45.393] result() for MulticoreFuture ...
[16:04:45.394] result() for MulticoreFuture ... done
[16:04:45.394] result() for MulticoreFuture ...
[16:04:45.394] result() for MulticoreFuture ... done
[16:04:45.394] result() for MulticoreFuture ...
[16:04:45.394] result() for MulticoreFuture ... done
[16:04:45.394] result() for MulticoreFuture ...
[16:04:45.394] result() for MulticoreFuture ... done
[16:04:45.394] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.394] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.395] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:04:45.395]  length: 2 (resolved future 4)
[16:04:45.395] signalConditionsASAP(NULL, pos=5) ...
[16:04:45.395] - nx: 6
[16:04:45.395] - relay: TRUE
[16:04:45.395] - stdout: TRUE
[16:04:45.395] - signal: TRUE
[16:04:45.395] - resignal: FALSE
[16:04:45.395] - force: TRUE
[16:04:45.395] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.396] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.396]  - until=6
[16:04:45.396]  - relaying element #6
[16:04:45.396] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:45.396] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.396] signalConditionsASAP(NULL, pos=5) ... done
[16:04:45.396]  length: 1 (resolved future 5)
[16:04:45.396] signalConditionsASAP(numeric, pos=6) ...
[16:04:45.397] - nx: 6
[16:04:45.397] - relay: TRUE
[16:04:45.397] - stdout: TRUE
[16:04:45.397] - signal: TRUE
[16:04:45.397] - resignal: FALSE
[16:04:45.397] - force: TRUE
[16:04:45.397] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:45.397] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.397]  - until=6
[16:04:45.398] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:45.398] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.398] signalConditionsASAP(numeric, pos=6) ... done
[16:04:45.398]  length: 0 (resolved future 6)
[16:04:45.398] Relaying remaining futures
[16:04:45.398] signalConditionsASAP(NULL, pos=0) ...
[16:04:45.398] - nx: 6
[16:04:45.398] - relay: TRUE
[16:04:45.398] - stdout: TRUE
[16:04:45.399] - signal: TRUE
[16:04:45.399] - resignal: FALSE
[16:04:45.399] - force: TRUE
[16:04:45.399] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:45.399] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:45.399] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:45.399] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:45.399] signalConditionsASAP(NULL, pos=0) ... done
[16:04:45.400] resolve() on list environment ... DONE
[16:04:45.400] result() for MulticoreFuture ...
[16:04:45.400] result() for MulticoreFuture ... done
[16:04:45.400] result() for MulticoreFuture ...
[16:04:45.400] result() for MulticoreFuture ... done
[16:04:45.400] result() for MulticoreFuture ...
[16:04:45.400] result() for MulticoreFuture ... done
[16:04:45.400] result() for MulticoreFuture ...
[16:04:45.401] result() for MulticoreFuture ... done
[16:04:45.401] result() for MulticoreFuture ...
[16:04:45.401] result() for MulticoreFuture ... done
[16:04:45.401] result() for MulticoreFuture ...
[16:04:45.401] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55874df13670> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[16:04:45.404] plan(): Setting new future strategy stack:
[16:04:45.404] List of future strategies:
[16:04:45.404] 1. multisession:
[16:04:45.404]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:45.404]    - tweaked: FALSE
[16:04:45.404]    - call: plan(strategy)
[16:04:45.404] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:04:45.404] multisession:
[16:04:45.404] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:45.404] - tweaked: FALSE
[16:04:45.404] - call: plan(strategy)
[16:04:45.408] getGlobalsAndPackages() ...
[16:04:45.409] Not searching for globals
[16:04:45.409] - globals: [0] <none>
[16:04:45.409] getGlobalsAndPackages() ... DONE
[16:04:45.409] [local output] makeClusterPSOCK() ...
[16:04:45.413] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:04:45.414] [local output] Base port: 11968
[16:04:45.414] [local output] Getting setup options for 2 cluster nodes ...
[16:04:45.414] [local output]  - Node 1 of 2 ...
[16:04:45.414] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:45.415] [local output] Rscript port: 11968

[16:04:45.415] [local output]  - Node 2 of 2 ...
[16:04:45.416] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:45.416] [local output] Rscript port: 11968

[16:04:45.417] [local output] Getting setup options for 2 cluster nodes ... done
[16:04:45.417] [local output]  - Parallel setup requested for some PSOCK nodes
[16:04:45.417] [local output] Setting up PSOCK nodes in parallel
[16:04:45.417] List of 36
[16:04:45.417]  $ worker          : chr "localhost"
[16:04:45.417]   ..- attr(*, "localhost")= logi TRUE
[16:04:45.417]  $ master          : chr "localhost"
[16:04:45.417]  $ port            : int 11968
[16:04:45.417]  $ connectTimeout  : num 120
[16:04:45.417]  $ timeout         : num 2592000
[16:04:45.417]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:04:45.417]  $ homogeneous     : logi TRUE
[16:04:45.417]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:04:45.417]  $ rscript_envs    : NULL
[16:04:45.417]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:45.417]  $ rscript_startup : NULL
[16:04:45.417]  $ rscript_sh      : chr "sh"
[16:04:45.417]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:45.417]  $ methods         : logi TRUE
[16:04:45.417]  $ socketOptions   : chr "no-delay"
[16:04:45.417]  $ useXDR          : logi FALSE
[16:04:45.417]  $ outfile         : chr "/dev/null"
[16:04:45.417]  $ renice          : int NA
[16:04:45.417]  $ rshcmd          : NULL
[16:04:45.417]  $ user            : chr(0) 
[16:04:45.417]  $ revtunnel       : logi FALSE
[16:04:45.417]  $ rshlogfile      : NULL
[16:04:45.417]  $ rshopts         : chr(0) 
[16:04:45.417]  $ rank            : int 1
[16:04:45.417]  $ manual          : logi FALSE
[16:04:45.417]  $ dryrun          : logi FALSE
[16:04:45.417]  $ quiet           : logi FALSE
[16:04:45.417]  $ setup_strategy  : chr "parallel"
[16:04:45.417]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:45.417]  $ pidfile         : chr "/tmp/RtmpKP9SHZ/worker.rank=1.parallelly.parent=83263.1453f79144c9c.pid"
[16:04:45.417]  $ rshcmd_label    : NULL
[16:04:45.417]  $ rsh_call        : NULL
[16:04:45.417]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:45.417]  $ localMachine    : logi TRUE
[16:04:45.417]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:04:45.417]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:04:45.417]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:04:45.417]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:04:45.417]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:04:45.417]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:04:45.417]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:04:45.417]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:04:45.417]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:04:45.417]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:04:45.417]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:04:45.417]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:04:45.417]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:04:45.417]  $ arguments       :List of 28
[16:04:45.417]   ..$ worker          : chr "localhost"
[16:04:45.417]   ..$ master          : NULL
[16:04:45.417]   ..$ port            : int 11968
[16:04:45.417]   ..$ connectTimeout  : num 120
[16:04:45.417]   ..$ timeout         : num 2592000
[16:04:45.417]   ..$ rscript         : NULL
[16:04:45.417]   ..$ homogeneous     : NULL
[16:04:45.417]   ..$ rscript_args    : NULL
[16:04:45.417]   ..$ rscript_envs    : NULL
[16:04:45.417]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:45.417]   ..$ rscript_startup : NULL
[16:04:45.417]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:04:45.417]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:45.417]   ..$ methods         : logi TRUE
[16:04:45.417]   ..$ socketOptions   : chr "no-delay"
[16:04:45.417]   ..$ useXDR          : logi FALSE
[16:04:45.417]   ..$ outfile         : chr "/dev/null"
[16:04:45.417]   ..$ renice          : int NA
[16:04:45.417]   ..$ rshcmd          : NULL
[16:04:45.417]   ..$ user            : NULL
[16:04:45.417]   ..$ revtunnel       : logi NA
[16:04:45.417]   ..$ rshlogfile      : NULL
[16:04:45.417]   ..$ rshopts         : NULL
[16:04:45.417]   ..$ rank            : int 1
[16:04:45.417]   ..$ manual          : logi FALSE
[16:04:45.417]   ..$ dryrun          : logi FALSE
[16:04:45.417]   ..$ quiet           : logi FALSE
[16:04:45.417]   ..$ setup_strategy  : chr "parallel"
[16:04:45.417]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:04:45.436] [local output] System call to launch all workers:
[16:04:45.436] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpKP9SHZ/worker.rank=1.parallelly.parent=83263.1453f79144c9c.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11968 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:04:45.437] [local output] Starting PSOCK main server
[16:04:45.438] [local output] Workers launched
[16:04:45.438] [local output] Waiting for workers to connect back
[16:04:45.438]  - [local output] 0 workers out of 2 ready
[16:04:45.691]  - [local output] 0 workers out of 2 ready
[16:04:45.691]  - [local output] 1 workers out of 2 ready
[16:04:45.698]  - [local output] 1 workers out of 2 ready
[16:04:45.698]  - [local output] 2 workers out of 2 ready
[16:04:45.698] [local output] Launching of workers completed
[16:04:45.698] [local output] Collecting session information from workers
[16:04:45.699] [local output]  - Worker #1 of 2
[16:04:45.700] [local output]  - Worker #2 of 2
[16:04:45.700] [local output] makeClusterPSOCK() ... done
[16:04:45.711] Packages needed by the future expression (n = 0): <none>
[16:04:45.711] Packages needed by future strategies (n = 0): <none>
[16:04:45.712] {
[16:04:45.712]     {
[16:04:45.712]         {
[16:04:45.712]             ...future.startTime <- base::Sys.time()
[16:04:45.712]             {
[16:04:45.712]                 {
[16:04:45.712]                   {
[16:04:45.712]                     {
[16:04:45.712]                       base::local({
[16:04:45.712]                         has_future <- base::requireNamespace("future", 
[16:04:45.712]                           quietly = TRUE)
[16:04:45.712]                         if (has_future) {
[16:04:45.712]                           ns <- base::getNamespace("future")
[16:04:45.712]                           version <- ns[[".package"]][["version"]]
[16:04:45.712]                           if (is.null(version)) 
[16:04:45.712]                             version <- utils::packageVersion("future")
[16:04:45.712]                         }
[16:04:45.712]                         else {
[16:04:45.712]                           version <- NULL
[16:04:45.712]                         }
[16:04:45.712]                         if (!has_future || version < "1.8.0") {
[16:04:45.712]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.712]                             "", base::R.version$version.string), 
[16:04:45.712]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.712]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.712]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.712]                               "release", "version")], collapse = " "), 
[16:04:45.712]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.712]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.712]                             info)
[16:04:45.712]                           info <- base::paste(info, collapse = "; ")
[16:04:45.712]                           if (!has_future) {
[16:04:45.712]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.712]                               info)
[16:04:45.712]                           }
[16:04:45.712]                           else {
[16:04:45.712]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.712]                               info, version)
[16:04:45.712]                           }
[16:04:45.712]                           base::stop(msg)
[16:04:45.712]                         }
[16:04:45.712]                       })
[16:04:45.712]                     }
[16:04:45.712]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.712]                     base::options(mc.cores = 1L)
[16:04:45.712]                   }
[16:04:45.712]                   options(future.plan = NULL)
[16:04:45.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.712]                 }
[16:04:45.712]                 ...future.workdir <- getwd()
[16:04:45.712]             }
[16:04:45.712]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.712]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.712]         }
[16:04:45.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.712]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.712]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.712]             base::names(...future.oldOptions))
[16:04:45.712]     }
[16:04:45.712]     if (FALSE) {
[16:04:45.712]     }
[16:04:45.712]     else {
[16:04:45.712]         if (TRUE) {
[16:04:45.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.712]                 open = "w")
[16:04:45.712]         }
[16:04:45.712]         else {
[16:04:45.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.712]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.712]         }
[16:04:45.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.712]             base::sink(type = "output", split = FALSE)
[16:04:45.712]             base::close(...future.stdout)
[16:04:45.712]         }, add = TRUE)
[16:04:45.712]     }
[16:04:45.712]     ...future.frame <- base::sys.nframe()
[16:04:45.712]     ...future.conditions <- base::list()
[16:04:45.712]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.712]     if (FALSE) {
[16:04:45.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.712]     }
[16:04:45.712]     ...future.result <- base::tryCatch({
[16:04:45.712]         base::withCallingHandlers({
[16:04:45.712]             ...future.value <- base::withVisible(base::local({
[16:04:45.712]                 ...future.makeSendCondition <- base::local({
[16:04:45.712]                   sendCondition <- NULL
[16:04:45.712]                   function(frame = 1L) {
[16:04:45.712]                     if (is.function(sendCondition)) 
[16:04:45.712]                       return(sendCondition)
[16:04:45.712]                     ns <- getNamespace("parallel")
[16:04:45.712]                     if (exists("sendData", mode = "function", 
[16:04:45.712]                       envir = ns)) {
[16:04:45.712]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:45.712]                         envir = ns)
[16:04:45.712]                       envir <- sys.frame(frame)
[16:04:45.712]                       master <- NULL
[16:04:45.712]                       while (!identical(envir, .GlobalEnv) && 
[16:04:45.712]                         !identical(envir, emptyenv())) {
[16:04:45.712]                         if (exists("master", mode = "list", envir = envir, 
[16:04:45.712]                           inherits = FALSE)) {
[16:04:45.712]                           master <- get("master", mode = "list", 
[16:04:45.712]                             envir = envir, inherits = FALSE)
[16:04:45.712]                           if (inherits(master, c("SOCKnode", 
[16:04:45.712]                             "SOCK0node"))) {
[16:04:45.712]                             sendCondition <<- function(cond) {
[16:04:45.712]                               data <- list(type = "VALUE", value = cond, 
[16:04:45.712]                                 success = TRUE)
[16:04:45.712]                               parallel_sendData(master, data)
[16:04:45.712]                             }
[16:04:45.712]                             return(sendCondition)
[16:04:45.712]                           }
[16:04:45.712]                         }
[16:04:45.712]                         frame <- frame + 1L
[16:04:45.712]                         envir <- sys.frame(frame)
[16:04:45.712]                       }
[16:04:45.712]                     }
[16:04:45.712]                     sendCondition <<- function(cond) NULL
[16:04:45.712]                   }
[16:04:45.712]                 })
[16:04:45.712]                 withCallingHandlers({
[16:04:45.712]                   NA
[16:04:45.712]                 }, immediateCondition = function(cond) {
[16:04:45.712]                   sendCondition <- ...future.makeSendCondition()
[16:04:45.712]                   sendCondition(cond)
[16:04:45.712]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.712]                   {
[16:04:45.712]                     inherits <- base::inherits
[16:04:45.712]                     invokeRestart <- base::invokeRestart
[16:04:45.712]                     is.null <- base::is.null
[16:04:45.712]                     muffled <- FALSE
[16:04:45.712]                     if (inherits(cond, "message")) {
[16:04:45.712]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.712]                       if (muffled) 
[16:04:45.712]                         invokeRestart("muffleMessage")
[16:04:45.712]                     }
[16:04:45.712]                     else if (inherits(cond, "warning")) {
[16:04:45.712]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.712]                       if (muffled) 
[16:04:45.712]                         invokeRestart("muffleWarning")
[16:04:45.712]                     }
[16:04:45.712]                     else if (inherits(cond, "condition")) {
[16:04:45.712]                       if (!is.null(pattern)) {
[16:04:45.712]                         computeRestarts <- base::computeRestarts
[16:04:45.712]                         grepl <- base::grepl
[16:04:45.712]                         restarts <- computeRestarts(cond)
[16:04:45.712]                         for (restart in restarts) {
[16:04:45.712]                           name <- restart$name
[16:04:45.712]                           if (is.null(name)) 
[16:04:45.712]                             next
[16:04:45.712]                           if (!grepl(pattern, name)) 
[16:04:45.712]                             next
[16:04:45.712]                           invokeRestart(restart)
[16:04:45.712]                           muffled <- TRUE
[16:04:45.712]                           break
[16:04:45.712]                         }
[16:04:45.712]                       }
[16:04:45.712]                     }
[16:04:45.712]                     invisible(muffled)
[16:04:45.712]                   }
[16:04:45.712]                   muffleCondition(cond)
[16:04:45.712]                 })
[16:04:45.712]             }))
[16:04:45.712]             future::FutureResult(value = ...future.value$value, 
[16:04:45.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.712]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.712]                     ...future.globalenv.names))
[16:04:45.712]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.712]         }, condition = base::local({
[16:04:45.712]             c <- base::c
[16:04:45.712]             inherits <- base::inherits
[16:04:45.712]             invokeRestart <- base::invokeRestart
[16:04:45.712]             length <- base::length
[16:04:45.712]             list <- base::list
[16:04:45.712]             seq.int <- base::seq.int
[16:04:45.712]             signalCondition <- base::signalCondition
[16:04:45.712]             sys.calls <- base::sys.calls
[16:04:45.712]             `[[` <- base::`[[`
[16:04:45.712]             `+` <- base::`+`
[16:04:45.712]             `<<-` <- base::`<<-`
[16:04:45.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.712]                   3L)]
[16:04:45.712]             }
[16:04:45.712]             function(cond) {
[16:04:45.712]                 is_error <- inherits(cond, "error")
[16:04:45.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.712]                   NULL)
[16:04:45.712]                 if (is_error) {
[16:04:45.712]                   sessionInformation <- function() {
[16:04:45.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.712]                       search = base::search(), system = base::Sys.info())
[16:04:45.712]                   }
[16:04:45.712]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.712]                     cond$call), session = sessionInformation(), 
[16:04:45.712]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.712]                   signalCondition(cond)
[16:04:45.712]                 }
[16:04:45.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.712]                 "immediateCondition"))) {
[16:04:45.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.712]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.712]                   if (TRUE && !signal) {
[16:04:45.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.712]                     {
[16:04:45.712]                       inherits <- base::inherits
[16:04:45.712]                       invokeRestart <- base::invokeRestart
[16:04:45.712]                       is.null <- base::is.null
[16:04:45.712]                       muffled <- FALSE
[16:04:45.712]                       if (inherits(cond, "message")) {
[16:04:45.712]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.712]                         if (muffled) 
[16:04:45.712]                           invokeRestart("muffleMessage")
[16:04:45.712]                       }
[16:04:45.712]                       else if (inherits(cond, "warning")) {
[16:04:45.712]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.712]                         if (muffled) 
[16:04:45.712]                           invokeRestart("muffleWarning")
[16:04:45.712]                       }
[16:04:45.712]                       else if (inherits(cond, "condition")) {
[16:04:45.712]                         if (!is.null(pattern)) {
[16:04:45.712]                           computeRestarts <- base::computeRestarts
[16:04:45.712]                           grepl <- base::grepl
[16:04:45.712]                           restarts <- computeRestarts(cond)
[16:04:45.712]                           for (restart in restarts) {
[16:04:45.712]                             name <- restart$name
[16:04:45.712]                             if (is.null(name)) 
[16:04:45.712]                               next
[16:04:45.712]                             if (!grepl(pattern, name)) 
[16:04:45.712]                               next
[16:04:45.712]                             invokeRestart(restart)
[16:04:45.712]                             muffled <- TRUE
[16:04:45.712]                             break
[16:04:45.712]                           }
[16:04:45.712]                         }
[16:04:45.712]                       }
[16:04:45.712]                       invisible(muffled)
[16:04:45.712]                     }
[16:04:45.712]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.712]                   }
[16:04:45.712]                 }
[16:04:45.712]                 else {
[16:04:45.712]                   if (TRUE) {
[16:04:45.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.712]                     {
[16:04:45.712]                       inherits <- base::inherits
[16:04:45.712]                       invokeRestart <- base::invokeRestart
[16:04:45.712]                       is.null <- base::is.null
[16:04:45.712]                       muffled <- FALSE
[16:04:45.712]                       if (inherits(cond, "message")) {
[16:04:45.712]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.712]                         if (muffled) 
[16:04:45.712]                           invokeRestart("muffleMessage")
[16:04:45.712]                       }
[16:04:45.712]                       else if (inherits(cond, "warning")) {
[16:04:45.712]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.712]                         if (muffled) 
[16:04:45.712]                           invokeRestart("muffleWarning")
[16:04:45.712]                       }
[16:04:45.712]                       else if (inherits(cond, "condition")) {
[16:04:45.712]                         if (!is.null(pattern)) {
[16:04:45.712]                           computeRestarts <- base::computeRestarts
[16:04:45.712]                           grepl <- base::grepl
[16:04:45.712]                           restarts <- computeRestarts(cond)
[16:04:45.712]                           for (restart in restarts) {
[16:04:45.712]                             name <- restart$name
[16:04:45.712]                             if (is.null(name)) 
[16:04:45.712]                               next
[16:04:45.712]                             if (!grepl(pattern, name)) 
[16:04:45.712]                               next
[16:04:45.712]                             invokeRestart(restart)
[16:04:45.712]                             muffled <- TRUE
[16:04:45.712]                             break
[16:04:45.712]                           }
[16:04:45.712]                         }
[16:04:45.712]                       }
[16:04:45.712]                       invisible(muffled)
[16:04:45.712]                     }
[16:04:45.712]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.712]                   }
[16:04:45.712]                 }
[16:04:45.712]             }
[16:04:45.712]         }))
[16:04:45.712]     }, error = function(ex) {
[16:04:45.712]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.712]                 ...future.rng), started = ...future.startTime, 
[16:04:45.712]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.712]             version = "1.8"), class = "FutureResult")
[16:04:45.712]     }, finally = {
[16:04:45.712]         if (!identical(...future.workdir, getwd())) 
[16:04:45.712]             setwd(...future.workdir)
[16:04:45.712]         {
[16:04:45.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.712]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.712]             }
[16:04:45.712]             base::options(...future.oldOptions)
[16:04:45.712]             if (.Platform$OS.type == "windows") {
[16:04:45.712]                 old_names <- names(...future.oldEnvVars)
[16:04:45.712]                 envs <- base::Sys.getenv()
[16:04:45.712]                 names <- names(envs)
[16:04:45.712]                 common <- intersect(names, old_names)
[16:04:45.712]                 added <- setdiff(names, old_names)
[16:04:45.712]                 removed <- setdiff(old_names, names)
[16:04:45.712]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.712]                   envs[common]]
[16:04:45.712]                 NAMES <- toupper(changed)
[16:04:45.712]                 args <- list()
[16:04:45.712]                 for (kk in seq_along(NAMES)) {
[16:04:45.712]                   name <- changed[[kk]]
[16:04:45.712]                   NAME <- NAMES[[kk]]
[16:04:45.712]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.712]                     next
[16:04:45.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.712]                 }
[16:04:45.712]                 NAMES <- toupper(added)
[16:04:45.712]                 for (kk in seq_along(NAMES)) {
[16:04:45.712]                   name <- added[[kk]]
[16:04:45.712]                   NAME <- NAMES[[kk]]
[16:04:45.712]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.712]                     next
[16:04:45.712]                   args[[name]] <- ""
[16:04:45.712]                 }
[16:04:45.712]                 NAMES <- toupper(removed)
[16:04:45.712]                 for (kk in seq_along(NAMES)) {
[16:04:45.712]                   name <- removed[[kk]]
[16:04:45.712]                   NAME <- NAMES[[kk]]
[16:04:45.712]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.712]                     next
[16:04:45.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.712]                 }
[16:04:45.712]                 if (length(args) > 0) 
[16:04:45.712]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.712]             }
[16:04:45.712]             else {
[16:04:45.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.712]             }
[16:04:45.712]             {
[16:04:45.712]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.712]                   0L) {
[16:04:45.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.712]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.712]                   base::options(opts)
[16:04:45.712]                 }
[16:04:45.712]                 {
[16:04:45.712]                   {
[16:04:45.712]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.712]                     NULL
[16:04:45.712]                   }
[16:04:45.712]                   options(future.plan = NULL)
[16:04:45.712]                   if (is.na(NA_character_)) 
[16:04:45.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.712]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:45.712]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:45.712]                     envir = parent.frame()) 
[16:04:45.712]                   {
[16:04:45.712]                     if (is.function(workers)) 
[16:04:45.712]                       workers <- workers()
[16:04:45.712]                     workers <- structure(as.integer(workers), 
[16:04:45.712]                       class = class(workers))
[16:04:45.712]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:45.712]                       workers >= 1)
[16:04:45.712]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:45.712]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:45.712]                     }
[16:04:45.712]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:45.712]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:45.712]                       envir = envir)
[16:04:45.712]                     if (!future$lazy) 
[16:04:45.712]                       future <- run(future)
[16:04:45.712]                     invisible(future)
[16:04:45.712]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.712]                 }
[16:04:45.712]             }
[16:04:45.712]         }
[16:04:45.712]     })
[16:04:45.712]     if (TRUE) {
[16:04:45.712]         base::sink(type = "output", split = FALSE)
[16:04:45.712]         if (TRUE) {
[16:04:45.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.712]         }
[16:04:45.712]         else {
[16:04:45.712]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.712]         }
[16:04:45.712]         base::close(...future.stdout)
[16:04:45.712]         ...future.stdout <- NULL
[16:04:45.712]     }
[16:04:45.712]     ...future.result$conditions <- ...future.conditions
[16:04:45.712]     ...future.result$finished <- base::Sys.time()
[16:04:45.712]     ...future.result
[16:04:45.712] }
[16:04:45.766] MultisessionFuture started
[16:04:45.766] result() for ClusterFuture ...
[16:04:45.766] receiveMessageFromWorker() for ClusterFuture ...
[16:04:45.766] - Validating connection of MultisessionFuture
[16:04:45.810] - received message: FutureResult
[16:04:45.811] - Received FutureResult
[16:04:45.811] - Erased future from FutureRegistry
[16:04:45.811] result() for ClusterFuture ...
[16:04:45.811] - result already collected: FutureResult
[16:04:45.811] result() for ClusterFuture ... done
[16:04:45.811] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:45.811] result() for ClusterFuture ... done
[16:04:45.811] result() for ClusterFuture ...
[16:04:45.812] - result already collected: FutureResult
[16:04:45.812] result() for ClusterFuture ... done
[16:04:45.812] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:04:45.815] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:04:45.816] getGlobalsAndPackages() ...
[16:04:45.816] Searching for globals...
[16:04:45.816] 
[16:04:45.816] Searching for globals ... DONE
[16:04:45.816] - globals: [0] <none>
[16:04:45.816] getGlobalsAndPackages() ... DONE
[16:04:45.817] run() for ‘Future’ ...
[16:04:45.817] - state: ‘created’
[16:04:45.817] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:45.831] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:45.834] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:45.834]   - Field: ‘node’
[16:04:45.835]   - Field: ‘label’
[16:04:45.835]   - Field: ‘local’
[16:04:45.835]   - Field: ‘owner’
[16:04:45.835]   - Field: ‘envir’
[16:04:45.835]   - Field: ‘workers’
[16:04:45.835]   - Field: ‘packages’
[16:04:45.835]   - Field: ‘gc’
[16:04:45.835]   - Field: ‘conditions’
[16:04:45.836]   - Field: ‘persistent’
[16:04:45.836]   - Field: ‘expr’
[16:04:45.836]   - Field: ‘uuid’
[16:04:45.836]   - Field: ‘seed’
[16:04:45.836]   - Field: ‘version’
[16:04:45.836]   - Field: ‘result’
[16:04:45.836]   - Field: ‘asynchronous’
[16:04:45.836]   - Field: ‘calls’
[16:04:45.836]   - Field: ‘globals’
[16:04:45.836]   - Field: ‘stdout’
[16:04:45.836]   - Field: ‘earlySignal’
[16:04:45.837]   - Field: ‘lazy’
[16:04:45.837]   - Field: ‘state’
[16:04:45.837] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:45.837] - Launch lazy future ...
[16:04:45.837] Packages needed by the future expression (n = 0): <none>
[16:04:45.837] Packages needed by future strategies (n = 0): <none>
[16:04:45.838] {
[16:04:45.838]     {
[16:04:45.838]         {
[16:04:45.838]             ...future.startTime <- base::Sys.time()
[16:04:45.838]             {
[16:04:45.838]                 {
[16:04:45.838]                   {
[16:04:45.838]                     {
[16:04:45.838]                       base::local({
[16:04:45.838]                         has_future <- base::requireNamespace("future", 
[16:04:45.838]                           quietly = TRUE)
[16:04:45.838]                         if (has_future) {
[16:04:45.838]                           ns <- base::getNamespace("future")
[16:04:45.838]                           version <- ns[[".package"]][["version"]]
[16:04:45.838]                           if (is.null(version)) 
[16:04:45.838]                             version <- utils::packageVersion("future")
[16:04:45.838]                         }
[16:04:45.838]                         else {
[16:04:45.838]                           version <- NULL
[16:04:45.838]                         }
[16:04:45.838]                         if (!has_future || version < "1.8.0") {
[16:04:45.838]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.838]                             "", base::R.version$version.string), 
[16:04:45.838]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.838]                               "release", "version")], collapse = " "), 
[16:04:45.838]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.838]                             info)
[16:04:45.838]                           info <- base::paste(info, collapse = "; ")
[16:04:45.838]                           if (!has_future) {
[16:04:45.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.838]                               info)
[16:04:45.838]                           }
[16:04:45.838]                           else {
[16:04:45.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.838]                               info, version)
[16:04:45.838]                           }
[16:04:45.838]                           base::stop(msg)
[16:04:45.838]                         }
[16:04:45.838]                       })
[16:04:45.838]                     }
[16:04:45.838]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.838]                     base::options(mc.cores = 1L)
[16:04:45.838]                   }
[16:04:45.838]                   options(future.plan = NULL)
[16:04:45.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.838]                 }
[16:04:45.838]                 ...future.workdir <- getwd()
[16:04:45.838]             }
[16:04:45.838]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.838]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.838]         }
[16:04:45.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.838]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.838]             base::names(...future.oldOptions))
[16:04:45.838]     }
[16:04:45.838]     if (FALSE) {
[16:04:45.838]     }
[16:04:45.838]     else {
[16:04:45.838]         if (TRUE) {
[16:04:45.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.838]                 open = "w")
[16:04:45.838]         }
[16:04:45.838]         else {
[16:04:45.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.838]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.838]         }
[16:04:45.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.838]             base::sink(type = "output", split = FALSE)
[16:04:45.838]             base::close(...future.stdout)
[16:04:45.838]         }, add = TRUE)
[16:04:45.838]     }
[16:04:45.838]     ...future.frame <- base::sys.nframe()
[16:04:45.838]     ...future.conditions <- base::list()
[16:04:45.838]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.838]     if (FALSE) {
[16:04:45.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.838]     }
[16:04:45.838]     ...future.result <- base::tryCatch({
[16:04:45.838]         base::withCallingHandlers({
[16:04:45.838]             ...future.value <- base::withVisible(base::local({
[16:04:45.838]                 ...future.makeSendCondition <- base::local({
[16:04:45.838]                   sendCondition <- NULL
[16:04:45.838]                   function(frame = 1L) {
[16:04:45.838]                     if (is.function(sendCondition)) 
[16:04:45.838]                       return(sendCondition)
[16:04:45.838]                     ns <- getNamespace("parallel")
[16:04:45.838]                     if (exists("sendData", mode = "function", 
[16:04:45.838]                       envir = ns)) {
[16:04:45.838]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:45.838]                         envir = ns)
[16:04:45.838]                       envir <- sys.frame(frame)
[16:04:45.838]                       master <- NULL
[16:04:45.838]                       while (!identical(envir, .GlobalEnv) && 
[16:04:45.838]                         !identical(envir, emptyenv())) {
[16:04:45.838]                         if (exists("master", mode = "list", envir = envir, 
[16:04:45.838]                           inherits = FALSE)) {
[16:04:45.838]                           master <- get("master", mode = "list", 
[16:04:45.838]                             envir = envir, inherits = FALSE)
[16:04:45.838]                           if (inherits(master, c("SOCKnode", 
[16:04:45.838]                             "SOCK0node"))) {
[16:04:45.838]                             sendCondition <<- function(cond) {
[16:04:45.838]                               data <- list(type = "VALUE", value = cond, 
[16:04:45.838]                                 success = TRUE)
[16:04:45.838]                               parallel_sendData(master, data)
[16:04:45.838]                             }
[16:04:45.838]                             return(sendCondition)
[16:04:45.838]                           }
[16:04:45.838]                         }
[16:04:45.838]                         frame <- frame + 1L
[16:04:45.838]                         envir <- sys.frame(frame)
[16:04:45.838]                       }
[16:04:45.838]                     }
[16:04:45.838]                     sendCondition <<- function(cond) NULL
[16:04:45.838]                   }
[16:04:45.838]                 })
[16:04:45.838]                 withCallingHandlers({
[16:04:45.838]                   2
[16:04:45.838]                 }, immediateCondition = function(cond) {
[16:04:45.838]                   sendCondition <- ...future.makeSendCondition()
[16:04:45.838]                   sendCondition(cond)
[16:04:45.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.838]                   {
[16:04:45.838]                     inherits <- base::inherits
[16:04:45.838]                     invokeRestart <- base::invokeRestart
[16:04:45.838]                     is.null <- base::is.null
[16:04:45.838]                     muffled <- FALSE
[16:04:45.838]                     if (inherits(cond, "message")) {
[16:04:45.838]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.838]                       if (muffled) 
[16:04:45.838]                         invokeRestart("muffleMessage")
[16:04:45.838]                     }
[16:04:45.838]                     else if (inherits(cond, "warning")) {
[16:04:45.838]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.838]                       if (muffled) 
[16:04:45.838]                         invokeRestart("muffleWarning")
[16:04:45.838]                     }
[16:04:45.838]                     else if (inherits(cond, "condition")) {
[16:04:45.838]                       if (!is.null(pattern)) {
[16:04:45.838]                         computeRestarts <- base::computeRestarts
[16:04:45.838]                         grepl <- base::grepl
[16:04:45.838]                         restarts <- computeRestarts(cond)
[16:04:45.838]                         for (restart in restarts) {
[16:04:45.838]                           name <- restart$name
[16:04:45.838]                           if (is.null(name)) 
[16:04:45.838]                             next
[16:04:45.838]                           if (!grepl(pattern, name)) 
[16:04:45.838]                             next
[16:04:45.838]                           invokeRestart(restart)
[16:04:45.838]                           muffled <- TRUE
[16:04:45.838]                           break
[16:04:45.838]                         }
[16:04:45.838]                       }
[16:04:45.838]                     }
[16:04:45.838]                     invisible(muffled)
[16:04:45.838]                   }
[16:04:45.838]                   muffleCondition(cond)
[16:04:45.838]                 })
[16:04:45.838]             }))
[16:04:45.838]             future::FutureResult(value = ...future.value$value, 
[16:04:45.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.838]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.838]                     ...future.globalenv.names))
[16:04:45.838]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.838]         }, condition = base::local({
[16:04:45.838]             c <- base::c
[16:04:45.838]             inherits <- base::inherits
[16:04:45.838]             invokeRestart <- base::invokeRestart
[16:04:45.838]             length <- base::length
[16:04:45.838]             list <- base::list
[16:04:45.838]             seq.int <- base::seq.int
[16:04:45.838]             signalCondition <- base::signalCondition
[16:04:45.838]             sys.calls <- base::sys.calls
[16:04:45.838]             `[[` <- base::`[[`
[16:04:45.838]             `+` <- base::`+`
[16:04:45.838]             `<<-` <- base::`<<-`
[16:04:45.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.838]                   3L)]
[16:04:45.838]             }
[16:04:45.838]             function(cond) {
[16:04:45.838]                 is_error <- inherits(cond, "error")
[16:04:45.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.838]                   NULL)
[16:04:45.838]                 if (is_error) {
[16:04:45.838]                   sessionInformation <- function() {
[16:04:45.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.838]                       search = base::search(), system = base::Sys.info())
[16:04:45.838]                   }
[16:04:45.838]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.838]                     cond$call), session = sessionInformation(), 
[16:04:45.838]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.838]                   signalCondition(cond)
[16:04:45.838]                 }
[16:04:45.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.838]                 "immediateCondition"))) {
[16:04:45.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.838]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.838]                   if (TRUE && !signal) {
[16:04:45.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.838]                     {
[16:04:45.838]                       inherits <- base::inherits
[16:04:45.838]                       invokeRestart <- base::invokeRestart
[16:04:45.838]                       is.null <- base::is.null
[16:04:45.838]                       muffled <- FALSE
[16:04:45.838]                       if (inherits(cond, "message")) {
[16:04:45.838]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.838]                         if (muffled) 
[16:04:45.838]                           invokeRestart("muffleMessage")
[16:04:45.838]                       }
[16:04:45.838]                       else if (inherits(cond, "warning")) {
[16:04:45.838]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.838]                         if (muffled) 
[16:04:45.838]                           invokeRestart("muffleWarning")
[16:04:45.838]                       }
[16:04:45.838]                       else if (inherits(cond, "condition")) {
[16:04:45.838]                         if (!is.null(pattern)) {
[16:04:45.838]                           computeRestarts <- base::computeRestarts
[16:04:45.838]                           grepl <- base::grepl
[16:04:45.838]                           restarts <- computeRestarts(cond)
[16:04:45.838]                           for (restart in restarts) {
[16:04:45.838]                             name <- restart$name
[16:04:45.838]                             if (is.null(name)) 
[16:04:45.838]                               next
[16:04:45.838]                             if (!grepl(pattern, name)) 
[16:04:45.838]                               next
[16:04:45.838]                             invokeRestart(restart)
[16:04:45.838]                             muffled <- TRUE
[16:04:45.838]                             break
[16:04:45.838]                           }
[16:04:45.838]                         }
[16:04:45.838]                       }
[16:04:45.838]                       invisible(muffled)
[16:04:45.838]                     }
[16:04:45.838]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.838]                   }
[16:04:45.838]                 }
[16:04:45.838]                 else {
[16:04:45.838]                   if (TRUE) {
[16:04:45.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.838]                     {
[16:04:45.838]                       inherits <- base::inherits
[16:04:45.838]                       invokeRestart <- base::invokeRestart
[16:04:45.838]                       is.null <- base::is.null
[16:04:45.838]                       muffled <- FALSE
[16:04:45.838]                       if (inherits(cond, "message")) {
[16:04:45.838]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.838]                         if (muffled) 
[16:04:45.838]                           invokeRestart("muffleMessage")
[16:04:45.838]                       }
[16:04:45.838]                       else if (inherits(cond, "warning")) {
[16:04:45.838]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.838]                         if (muffled) 
[16:04:45.838]                           invokeRestart("muffleWarning")
[16:04:45.838]                       }
[16:04:45.838]                       else if (inherits(cond, "condition")) {
[16:04:45.838]                         if (!is.null(pattern)) {
[16:04:45.838]                           computeRestarts <- base::computeRestarts
[16:04:45.838]                           grepl <- base::grepl
[16:04:45.838]                           restarts <- computeRestarts(cond)
[16:04:45.838]                           for (restart in restarts) {
[16:04:45.838]                             name <- restart$name
[16:04:45.838]                             if (is.null(name)) 
[16:04:45.838]                               next
[16:04:45.838]                             if (!grepl(pattern, name)) 
[16:04:45.838]                               next
[16:04:45.838]                             invokeRestart(restart)
[16:04:45.838]                             muffled <- TRUE
[16:04:45.838]                             break
[16:04:45.838]                           }
[16:04:45.838]                         }
[16:04:45.838]                       }
[16:04:45.838]                       invisible(muffled)
[16:04:45.838]                     }
[16:04:45.838]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.838]                   }
[16:04:45.838]                 }
[16:04:45.838]             }
[16:04:45.838]         }))
[16:04:45.838]     }, error = function(ex) {
[16:04:45.838]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.838]                 ...future.rng), started = ...future.startTime, 
[16:04:45.838]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.838]             version = "1.8"), class = "FutureResult")
[16:04:45.838]     }, finally = {
[16:04:45.838]         if (!identical(...future.workdir, getwd())) 
[16:04:45.838]             setwd(...future.workdir)
[16:04:45.838]         {
[16:04:45.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.838]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.838]             }
[16:04:45.838]             base::options(...future.oldOptions)
[16:04:45.838]             if (.Platform$OS.type == "windows") {
[16:04:45.838]                 old_names <- names(...future.oldEnvVars)
[16:04:45.838]                 envs <- base::Sys.getenv()
[16:04:45.838]                 names <- names(envs)
[16:04:45.838]                 common <- intersect(names, old_names)
[16:04:45.838]                 added <- setdiff(names, old_names)
[16:04:45.838]                 removed <- setdiff(old_names, names)
[16:04:45.838]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.838]                   envs[common]]
[16:04:45.838]                 NAMES <- toupper(changed)
[16:04:45.838]                 args <- list()
[16:04:45.838]                 for (kk in seq_along(NAMES)) {
[16:04:45.838]                   name <- changed[[kk]]
[16:04:45.838]                   NAME <- NAMES[[kk]]
[16:04:45.838]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.838]                     next
[16:04:45.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.838]                 }
[16:04:45.838]                 NAMES <- toupper(added)
[16:04:45.838]                 for (kk in seq_along(NAMES)) {
[16:04:45.838]                   name <- added[[kk]]
[16:04:45.838]                   NAME <- NAMES[[kk]]
[16:04:45.838]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.838]                     next
[16:04:45.838]                   args[[name]] <- ""
[16:04:45.838]                 }
[16:04:45.838]                 NAMES <- toupper(removed)
[16:04:45.838]                 for (kk in seq_along(NAMES)) {
[16:04:45.838]                   name <- removed[[kk]]
[16:04:45.838]                   NAME <- NAMES[[kk]]
[16:04:45.838]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.838]                     next
[16:04:45.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.838]                 }
[16:04:45.838]                 if (length(args) > 0) 
[16:04:45.838]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.838]             }
[16:04:45.838]             else {
[16:04:45.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.838]             }
[16:04:45.838]             {
[16:04:45.838]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.838]                   0L) {
[16:04:45.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.838]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.838]                   base::options(opts)
[16:04:45.838]                 }
[16:04:45.838]                 {
[16:04:45.838]                   {
[16:04:45.838]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.838]                     NULL
[16:04:45.838]                   }
[16:04:45.838]                   options(future.plan = NULL)
[16:04:45.838]                   if (is.na(NA_character_)) 
[16:04:45.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.838]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:45.838]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:45.838]                     envir = parent.frame()) 
[16:04:45.838]                   {
[16:04:45.838]                     if (is.function(workers)) 
[16:04:45.838]                       workers <- workers()
[16:04:45.838]                     workers <- structure(as.integer(workers), 
[16:04:45.838]                       class = class(workers))
[16:04:45.838]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:45.838]                       workers >= 1)
[16:04:45.838]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:45.838]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:45.838]                     }
[16:04:45.838]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:45.838]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:45.838]                       envir = envir)
[16:04:45.838]                     if (!future$lazy) 
[16:04:45.838]                       future <- run(future)
[16:04:45.838]                     invisible(future)
[16:04:45.838]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.838]                 }
[16:04:45.838]             }
[16:04:45.838]         }
[16:04:45.838]     })
[16:04:45.838]     if (TRUE) {
[16:04:45.838]         base::sink(type = "output", split = FALSE)
[16:04:45.838]         if (TRUE) {
[16:04:45.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.838]         }
[16:04:45.838]         else {
[16:04:45.838]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.838]         }
[16:04:45.838]         base::close(...future.stdout)
[16:04:45.838]         ...future.stdout <- NULL
[16:04:45.838]     }
[16:04:45.838]     ...future.result$conditions <- ...future.conditions
[16:04:45.838]     ...future.result$finished <- base::Sys.time()
[16:04:45.838]     ...future.result
[16:04:45.838] }
[16:04:45.841] MultisessionFuture started
[16:04:45.841] - Launch lazy future ... done
[16:04:45.841] run() for ‘MultisessionFuture’ ... done
[16:04:45.841] getGlobalsAndPackages() ...
[16:04:45.841] Searching for globals...
[16:04:45.842] 
[16:04:45.842] Searching for globals ... DONE
[16:04:45.842] - globals: [0] <none>
[16:04:45.842] getGlobalsAndPackages() ... DONE
[16:04:45.842] run() for ‘Future’ ...
[16:04:45.842] - state: ‘created’
[16:04:45.842] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:45.856] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:45.856] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:45.856]   - Field: ‘node’
[16:04:45.856]   - Field: ‘label’
[16:04:45.856]   - Field: ‘local’
[16:04:45.856]   - Field: ‘owner’
[16:04:45.857]   - Field: ‘envir’
[16:04:45.857]   - Field: ‘workers’
[16:04:45.857]   - Field: ‘packages’
[16:04:45.857]   - Field: ‘gc’
[16:04:45.857]   - Field: ‘conditions’
[16:04:45.857]   - Field: ‘persistent’
[16:04:45.857]   - Field: ‘expr’
[16:04:45.857]   - Field: ‘uuid’
[16:04:45.857]   - Field: ‘seed’
[16:04:45.857]   - Field: ‘version’
[16:04:45.857]   - Field: ‘result’
[16:04:45.858]   - Field: ‘asynchronous’
[16:04:45.858]   - Field: ‘calls’
[16:04:45.858]   - Field: ‘globals’
[16:04:45.858]   - Field: ‘stdout’
[16:04:45.858]   - Field: ‘earlySignal’
[16:04:45.858]   - Field: ‘lazy’
[16:04:45.858]   - Field: ‘state’
[16:04:45.858] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:45.858] - Launch lazy future ...
[16:04:45.859] Packages needed by the future expression (n = 0): <none>
[16:04:45.859] Packages needed by future strategies (n = 0): <none>
[16:04:45.859] {
[16:04:45.859]     {
[16:04:45.859]         {
[16:04:45.859]             ...future.startTime <- base::Sys.time()
[16:04:45.859]             {
[16:04:45.859]                 {
[16:04:45.859]                   {
[16:04:45.859]                     {
[16:04:45.859]                       base::local({
[16:04:45.859]                         has_future <- base::requireNamespace("future", 
[16:04:45.859]                           quietly = TRUE)
[16:04:45.859]                         if (has_future) {
[16:04:45.859]                           ns <- base::getNamespace("future")
[16:04:45.859]                           version <- ns[[".package"]][["version"]]
[16:04:45.859]                           if (is.null(version)) 
[16:04:45.859]                             version <- utils::packageVersion("future")
[16:04:45.859]                         }
[16:04:45.859]                         else {
[16:04:45.859]                           version <- NULL
[16:04:45.859]                         }
[16:04:45.859]                         if (!has_future || version < "1.8.0") {
[16:04:45.859]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.859]                             "", base::R.version$version.string), 
[16:04:45.859]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.859]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.859]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.859]                               "release", "version")], collapse = " "), 
[16:04:45.859]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.859]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.859]                             info)
[16:04:45.859]                           info <- base::paste(info, collapse = "; ")
[16:04:45.859]                           if (!has_future) {
[16:04:45.859]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.859]                               info)
[16:04:45.859]                           }
[16:04:45.859]                           else {
[16:04:45.859]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.859]                               info, version)
[16:04:45.859]                           }
[16:04:45.859]                           base::stop(msg)
[16:04:45.859]                         }
[16:04:45.859]                       })
[16:04:45.859]                     }
[16:04:45.859]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.859]                     base::options(mc.cores = 1L)
[16:04:45.859]                   }
[16:04:45.859]                   options(future.plan = NULL)
[16:04:45.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.859]                 }
[16:04:45.859]                 ...future.workdir <- getwd()
[16:04:45.859]             }
[16:04:45.859]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.859]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.859]         }
[16:04:45.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.859]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.859]             base::names(...future.oldOptions))
[16:04:45.859]     }
[16:04:45.859]     if (FALSE) {
[16:04:45.859]     }
[16:04:45.859]     else {
[16:04:45.859]         if (TRUE) {
[16:04:45.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.859]                 open = "w")
[16:04:45.859]         }
[16:04:45.859]         else {
[16:04:45.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.859]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.859]         }
[16:04:45.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.859]             base::sink(type = "output", split = FALSE)
[16:04:45.859]             base::close(...future.stdout)
[16:04:45.859]         }, add = TRUE)
[16:04:45.859]     }
[16:04:45.859]     ...future.frame <- base::sys.nframe()
[16:04:45.859]     ...future.conditions <- base::list()
[16:04:45.859]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.859]     if (FALSE) {
[16:04:45.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.859]     }
[16:04:45.859]     ...future.result <- base::tryCatch({
[16:04:45.859]         base::withCallingHandlers({
[16:04:45.859]             ...future.value <- base::withVisible(base::local({
[16:04:45.859]                 ...future.makeSendCondition <- base::local({
[16:04:45.859]                   sendCondition <- NULL
[16:04:45.859]                   function(frame = 1L) {
[16:04:45.859]                     if (is.function(sendCondition)) 
[16:04:45.859]                       return(sendCondition)
[16:04:45.859]                     ns <- getNamespace("parallel")
[16:04:45.859]                     if (exists("sendData", mode = "function", 
[16:04:45.859]                       envir = ns)) {
[16:04:45.859]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:45.859]                         envir = ns)
[16:04:45.859]                       envir <- sys.frame(frame)
[16:04:45.859]                       master <- NULL
[16:04:45.859]                       while (!identical(envir, .GlobalEnv) && 
[16:04:45.859]                         !identical(envir, emptyenv())) {
[16:04:45.859]                         if (exists("master", mode = "list", envir = envir, 
[16:04:45.859]                           inherits = FALSE)) {
[16:04:45.859]                           master <- get("master", mode = "list", 
[16:04:45.859]                             envir = envir, inherits = FALSE)
[16:04:45.859]                           if (inherits(master, c("SOCKnode", 
[16:04:45.859]                             "SOCK0node"))) {
[16:04:45.859]                             sendCondition <<- function(cond) {
[16:04:45.859]                               data <- list(type = "VALUE", value = cond, 
[16:04:45.859]                                 success = TRUE)
[16:04:45.859]                               parallel_sendData(master, data)
[16:04:45.859]                             }
[16:04:45.859]                             return(sendCondition)
[16:04:45.859]                           }
[16:04:45.859]                         }
[16:04:45.859]                         frame <- frame + 1L
[16:04:45.859]                         envir <- sys.frame(frame)
[16:04:45.859]                       }
[16:04:45.859]                     }
[16:04:45.859]                     sendCondition <<- function(cond) NULL
[16:04:45.859]                   }
[16:04:45.859]                 })
[16:04:45.859]                 withCallingHandlers({
[16:04:45.859]                   NULL
[16:04:45.859]                 }, immediateCondition = function(cond) {
[16:04:45.859]                   sendCondition <- ...future.makeSendCondition()
[16:04:45.859]                   sendCondition(cond)
[16:04:45.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.859]                   {
[16:04:45.859]                     inherits <- base::inherits
[16:04:45.859]                     invokeRestart <- base::invokeRestart
[16:04:45.859]                     is.null <- base::is.null
[16:04:45.859]                     muffled <- FALSE
[16:04:45.859]                     if (inherits(cond, "message")) {
[16:04:45.859]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.859]                       if (muffled) 
[16:04:45.859]                         invokeRestart("muffleMessage")
[16:04:45.859]                     }
[16:04:45.859]                     else if (inherits(cond, "warning")) {
[16:04:45.859]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.859]                       if (muffled) 
[16:04:45.859]                         invokeRestart("muffleWarning")
[16:04:45.859]                     }
[16:04:45.859]                     else if (inherits(cond, "condition")) {
[16:04:45.859]                       if (!is.null(pattern)) {
[16:04:45.859]                         computeRestarts <- base::computeRestarts
[16:04:45.859]                         grepl <- base::grepl
[16:04:45.859]                         restarts <- computeRestarts(cond)
[16:04:45.859]                         for (restart in restarts) {
[16:04:45.859]                           name <- restart$name
[16:04:45.859]                           if (is.null(name)) 
[16:04:45.859]                             next
[16:04:45.859]                           if (!grepl(pattern, name)) 
[16:04:45.859]                             next
[16:04:45.859]                           invokeRestart(restart)
[16:04:45.859]                           muffled <- TRUE
[16:04:45.859]                           break
[16:04:45.859]                         }
[16:04:45.859]                       }
[16:04:45.859]                     }
[16:04:45.859]                     invisible(muffled)
[16:04:45.859]                   }
[16:04:45.859]                   muffleCondition(cond)
[16:04:45.859]                 })
[16:04:45.859]             }))
[16:04:45.859]             future::FutureResult(value = ...future.value$value, 
[16:04:45.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.859]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.859]                     ...future.globalenv.names))
[16:04:45.859]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.859]         }, condition = base::local({
[16:04:45.859]             c <- base::c
[16:04:45.859]             inherits <- base::inherits
[16:04:45.859]             invokeRestart <- base::invokeRestart
[16:04:45.859]             length <- base::length
[16:04:45.859]             list <- base::list
[16:04:45.859]             seq.int <- base::seq.int
[16:04:45.859]             signalCondition <- base::signalCondition
[16:04:45.859]             sys.calls <- base::sys.calls
[16:04:45.859]             `[[` <- base::`[[`
[16:04:45.859]             `+` <- base::`+`
[16:04:45.859]             `<<-` <- base::`<<-`
[16:04:45.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.859]                   3L)]
[16:04:45.859]             }
[16:04:45.859]             function(cond) {
[16:04:45.859]                 is_error <- inherits(cond, "error")
[16:04:45.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.859]                   NULL)
[16:04:45.859]                 if (is_error) {
[16:04:45.859]                   sessionInformation <- function() {
[16:04:45.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.859]                       search = base::search(), system = base::Sys.info())
[16:04:45.859]                   }
[16:04:45.859]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.859]                     cond$call), session = sessionInformation(), 
[16:04:45.859]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.859]                   signalCondition(cond)
[16:04:45.859]                 }
[16:04:45.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.859]                 "immediateCondition"))) {
[16:04:45.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.859]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.859]                   if (TRUE && !signal) {
[16:04:45.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.859]                     {
[16:04:45.859]                       inherits <- base::inherits
[16:04:45.859]                       invokeRestart <- base::invokeRestart
[16:04:45.859]                       is.null <- base::is.null
[16:04:45.859]                       muffled <- FALSE
[16:04:45.859]                       if (inherits(cond, "message")) {
[16:04:45.859]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.859]                         if (muffled) 
[16:04:45.859]                           invokeRestart("muffleMessage")
[16:04:45.859]                       }
[16:04:45.859]                       else if (inherits(cond, "warning")) {
[16:04:45.859]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.859]                         if (muffled) 
[16:04:45.859]                           invokeRestart("muffleWarning")
[16:04:45.859]                       }
[16:04:45.859]                       else if (inherits(cond, "condition")) {
[16:04:45.859]                         if (!is.null(pattern)) {
[16:04:45.859]                           computeRestarts <- base::computeRestarts
[16:04:45.859]                           grepl <- base::grepl
[16:04:45.859]                           restarts <- computeRestarts(cond)
[16:04:45.859]                           for (restart in restarts) {
[16:04:45.859]                             name <- restart$name
[16:04:45.859]                             if (is.null(name)) 
[16:04:45.859]                               next
[16:04:45.859]                             if (!grepl(pattern, name)) 
[16:04:45.859]                               next
[16:04:45.859]                             invokeRestart(restart)
[16:04:45.859]                             muffled <- TRUE
[16:04:45.859]                             break
[16:04:45.859]                           }
[16:04:45.859]                         }
[16:04:45.859]                       }
[16:04:45.859]                       invisible(muffled)
[16:04:45.859]                     }
[16:04:45.859]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.859]                   }
[16:04:45.859]                 }
[16:04:45.859]                 else {
[16:04:45.859]                   if (TRUE) {
[16:04:45.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.859]                     {
[16:04:45.859]                       inherits <- base::inherits
[16:04:45.859]                       invokeRestart <- base::invokeRestart
[16:04:45.859]                       is.null <- base::is.null
[16:04:45.859]                       muffled <- FALSE
[16:04:45.859]                       if (inherits(cond, "message")) {
[16:04:45.859]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.859]                         if (muffled) 
[16:04:45.859]                           invokeRestart("muffleMessage")
[16:04:45.859]                       }
[16:04:45.859]                       else if (inherits(cond, "warning")) {
[16:04:45.859]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.859]                         if (muffled) 
[16:04:45.859]                           invokeRestart("muffleWarning")
[16:04:45.859]                       }
[16:04:45.859]                       else if (inherits(cond, "condition")) {
[16:04:45.859]                         if (!is.null(pattern)) {
[16:04:45.859]                           computeRestarts <- base::computeRestarts
[16:04:45.859]                           grepl <- base::grepl
[16:04:45.859]                           restarts <- computeRestarts(cond)
[16:04:45.859]                           for (restart in restarts) {
[16:04:45.859]                             name <- restart$name
[16:04:45.859]                             if (is.null(name)) 
[16:04:45.859]                               next
[16:04:45.859]                             if (!grepl(pattern, name)) 
[16:04:45.859]                               next
[16:04:45.859]                             invokeRestart(restart)
[16:04:45.859]                             muffled <- TRUE
[16:04:45.859]                             break
[16:04:45.859]                           }
[16:04:45.859]                         }
[16:04:45.859]                       }
[16:04:45.859]                       invisible(muffled)
[16:04:45.859]                     }
[16:04:45.859]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.859]                   }
[16:04:45.859]                 }
[16:04:45.859]             }
[16:04:45.859]         }))
[16:04:45.859]     }, error = function(ex) {
[16:04:45.859]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.859]                 ...future.rng), started = ...future.startTime, 
[16:04:45.859]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.859]             version = "1.8"), class = "FutureResult")
[16:04:45.859]     }, finally = {
[16:04:45.859]         if (!identical(...future.workdir, getwd())) 
[16:04:45.859]             setwd(...future.workdir)
[16:04:45.859]         {
[16:04:45.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.859]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.859]             }
[16:04:45.859]             base::options(...future.oldOptions)
[16:04:45.859]             if (.Platform$OS.type == "windows") {
[16:04:45.859]                 old_names <- names(...future.oldEnvVars)
[16:04:45.859]                 envs <- base::Sys.getenv()
[16:04:45.859]                 names <- names(envs)
[16:04:45.859]                 common <- intersect(names, old_names)
[16:04:45.859]                 added <- setdiff(names, old_names)
[16:04:45.859]                 removed <- setdiff(old_names, names)
[16:04:45.859]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.859]                   envs[common]]
[16:04:45.859]                 NAMES <- toupper(changed)
[16:04:45.859]                 args <- list()
[16:04:45.859]                 for (kk in seq_along(NAMES)) {
[16:04:45.859]                   name <- changed[[kk]]
[16:04:45.859]                   NAME <- NAMES[[kk]]
[16:04:45.859]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.859]                     next
[16:04:45.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.859]                 }
[16:04:45.859]                 NAMES <- toupper(added)
[16:04:45.859]                 for (kk in seq_along(NAMES)) {
[16:04:45.859]                   name <- added[[kk]]
[16:04:45.859]                   NAME <- NAMES[[kk]]
[16:04:45.859]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.859]                     next
[16:04:45.859]                   args[[name]] <- ""
[16:04:45.859]                 }
[16:04:45.859]                 NAMES <- toupper(removed)
[16:04:45.859]                 for (kk in seq_along(NAMES)) {
[16:04:45.859]                   name <- removed[[kk]]
[16:04:45.859]                   NAME <- NAMES[[kk]]
[16:04:45.859]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.859]                     next
[16:04:45.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.859]                 }
[16:04:45.859]                 if (length(args) > 0) 
[16:04:45.859]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.859]             }
[16:04:45.859]             else {
[16:04:45.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.859]             }
[16:04:45.859]             {
[16:04:45.859]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.859]                   0L) {
[16:04:45.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.859]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.859]                   base::options(opts)
[16:04:45.859]                 }
[16:04:45.859]                 {
[16:04:45.859]                   {
[16:04:45.859]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.859]                     NULL
[16:04:45.859]                   }
[16:04:45.859]                   options(future.plan = NULL)
[16:04:45.859]                   if (is.na(NA_character_)) 
[16:04:45.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.859]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:45.859]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:45.859]                     envir = parent.frame()) 
[16:04:45.859]                   {
[16:04:45.859]                     if (is.function(workers)) 
[16:04:45.859]                       workers <- workers()
[16:04:45.859]                     workers <- structure(as.integer(workers), 
[16:04:45.859]                       class = class(workers))
[16:04:45.859]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:45.859]                       workers >= 1)
[16:04:45.859]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:45.859]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:45.859]                     }
[16:04:45.859]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:45.859]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:45.859]                       envir = envir)
[16:04:45.859]                     if (!future$lazy) 
[16:04:45.859]                       future <- run(future)
[16:04:45.859]                     invisible(future)
[16:04:45.859]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.859]                 }
[16:04:45.859]             }
[16:04:45.859]         }
[16:04:45.859]     })
[16:04:45.859]     if (TRUE) {
[16:04:45.859]         base::sink(type = "output", split = FALSE)
[16:04:45.859]         if (TRUE) {
[16:04:45.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.859]         }
[16:04:45.859]         else {
[16:04:45.859]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.859]         }
[16:04:45.859]         base::close(...future.stdout)
[16:04:45.859]         ...future.stdout <- NULL
[16:04:45.859]     }
[16:04:45.859]     ...future.result$conditions <- ...future.conditions
[16:04:45.859]     ...future.result$finished <- base::Sys.time()
[16:04:45.859]     ...future.result
[16:04:45.859] }
[16:04:45.914] MultisessionFuture started
[16:04:45.914] - Launch lazy future ... done
[16:04:45.914] run() for ‘MultisessionFuture’ ... done
[16:04:45.914] getGlobalsAndPackages() ...
[16:04:45.914] Searching for globals...
[16:04:45.915] - globals found: [1] ‘{’
[16:04:45.915] Searching for globals ... DONE
[16:04:45.915] Resolving globals: FALSE
[16:04:45.916] 
[16:04:45.916] 
[16:04:45.916] getGlobalsAndPackages() ... DONE
[16:04:45.916] run() for ‘Future’ ...
[16:04:45.916] - state: ‘created’
[16:04:45.916] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:45.934] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:45.934] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:45.935]   - Field: ‘node’
[16:04:45.935]   - Field: ‘label’
[16:04:45.935]   - Field: ‘local’
[16:04:45.935]   - Field: ‘owner’
[16:04:45.935]   - Field: ‘envir’
[16:04:45.936]   - Field: ‘workers’
[16:04:45.936]   - Field: ‘packages’
[16:04:45.936]   - Field: ‘gc’
[16:04:45.936]   - Field: ‘conditions’
[16:04:45.936]   - Field: ‘persistent’
[16:04:45.936]   - Field: ‘expr’
[16:04:45.937]   - Field: ‘uuid’
[16:04:45.937]   - Field: ‘seed’
[16:04:45.937]   - Field: ‘version’
[16:04:45.937]   - Field: ‘result’
[16:04:45.937]   - Field: ‘asynchronous’
[16:04:45.937]   - Field: ‘calls’
[16:04:45.938]   - Field: ‘globals’
[16:04:45.938]   - Field: ‘stdout’
[16:04:45.938]   - Field: ‘earlySignal’
[16:04:45.938]   - Field: ‘lazy’
[16:04:45.938]   - Field: ‘state’
[16:04:45.938] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:45.939] - Launch lazy future ...
[16:04:45.939] Packages needed by the future expression (n = 0): <none>
[16:04:45.939] Packages needed by future strategies (n = 0): <none>
[16:04:45.941] {
[16:04:45.941]     {
[16:04:45.941]         {
[16:04:45.941]             ...future.startTime <- base::Sys.time()
[16:04:45.941]             {
[16:04:45.941]                 {
[16:04:45.941]                   {
[16:04:45.941]                     {
[16:04:45.941]                       base::local({
[16:04:45.941]                         has_future <- base::requireNamespace("future", 
[16:04:45.941]                           quietly = TRUE)
[16:04:45.941]                         if (has_future) {
[16:04:45.941]                           ns <- base::getNamespace("future")
[16:04:45.941]                           version <- ns[[".package"]][["version"]]
[16:04:45.941]                           if (is.null(version)) 
[16:04:45.941]                             version <- utils::packageVersion("future")
[16:04:45.941]                         }
[16:04:45.941]                         else {
[16:04:45.941]                           version <- NULL
[16:04:45.941]                         }
[16:04:45.941]                         if (!has_future || version < "1.8.0") {
[16:04:45.941]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:45.941]                             "", base::R.version$version.string), 
[16:04:45.941]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:45.941]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:45.941]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:45.941]                               "release", "version")], collapse = " "), 
[16:04:45.941]                             hostname = base::Sys.info()[["nodename"]])
[16:04:45.941]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:45.941]                             info)
[16:04:45.941]                           info <- base::paste(info, collapse = "; ")
[16:04:45.941]                           if (!has_future) {
[16:04:45.941]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:45.941]                               info)
[16:04:45.941]                           }
[16:04:45.941]                           else {
[16:04:45.941]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:45.941]                               info, version)
[16:04:45.941]                           }
[16:04:45.941]                           base::stop(msg)
[16:04:45.941]                         }
[16:04:45.941]                       })
[16:04:45.941]                     }
[16:04:45.941]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:45.941]                     base::options(mc.cores = 1L)
[16:04:45.941]                   }
[16:04:45.941]                   options(future.plan = NULL)
[16:04:45.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:45.941]                 }
[16:04:45.941]                 ...future.workdir <- getwd()
[16:04:45.941]             }
[16:04:45.941]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:45.941]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:45.941]         }
[16:04:45.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:45.941]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:45.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:45.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:45.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:45.941]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:45.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:45.941]             base::names(...future.oldOptions))
[16:04:45.941]     }
[16:04:45.941]     if (FALSE) {
[16:04:45.941]     }
[16:04:45.941]     else {
[16:04:45.941]         if (TRUE) {
[16:04:45.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:45.941]                 open = "w")
[16:04:45.941]         }
[16:04:45.941]         else {
[16:04:45.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:45.941]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:45.941]         }
[16:04:45.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:45.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:45.941]             base::sink(type = "output", split = FALSE)
[16:04:45.941]             base::close(...future.stdout)
[16:04:45.941]         }, add = TRUE)
[16:04:45.941]     }
[16:04:45.941]     ...future.frame <- base::sys.nframe()
[16:04:45.941]     ...future.conditions <- base::list()
[16:04:45.941]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:45.941]     if (FALSE) {
[16:04:45.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:45.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:45.941]     }
[16:04:45.941]     ...future.result <- base::tryCatch({
[16:04:45.941]         base::withCallingHandlers({
[16:04:45.941]             ...future.value <- base::withVisible(base::local({
[16:04:45.941]                 ...future.makeSendCondition <- base::local({
[16:04:45.941]                   sendCondition <- NULL
[16:04:45.941]                   function(frame = 1L) {
[16:04:45.941]                     if (is.function(sendCondition)) 
[16:04:45.941]                       return(sendCondition)
[16:04:45.941]                     ns <- getNamespace("parallel")
[16:04:45.941]                     if (exists("sendData", mode = "function", 
[16:04:45.941]                       envir = ns)) {
[16:04:45.941]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:45.941]                         envir = ns)
[16:04:45.941]                       envir <- sys.frame(frame)
[16:04:45.941]                       master <- NULL
[16:04:45.941]                       while (!identical(envir, .GlobalEnv) && 
[16:04:45.941]                         !identical(envir, emptyenv())) {
[16:04:45.941]                         if (exists("master", mode = "list", envir = envir, 
[16:04:45.941]                           inherits = FALSE)) {
[16:04:45.941]                           master <- get("master", mode = "list", 
[16:04:45.941]                             envir = envir, inherits = FALSE)
[16:04:45.941]                           if (inherits(master, c("SOCKnode", 
[16:04:45.941]                             "SOCK0node"))) {
[16:04:45.941]                             sendCondition <<- function(cond) {
[16:04:45.941]                               data <- list(type = "VALUE", value = cond, 
[16:04:45.941]                                 success = TRUE)
[16:04:45.941]                               parallel_sendData(master, data)
[16:04:45.941]                             }
[16:04:45.941]                             return(sendCondition)
[16:04:45.941]                           }
[16:04:45.941]                         }
[16:04:45.941]                         frame <- frame + 1L
[16:04:45.941]                         envir <- sys.frame(frame)
[16:04:45.941]                       }
[16:04:45.941]                     }
[16:04:45.941]                     sendCondition <<- function(cond) NULL
[16:04:45.941]                   }
[16:04:45.941]                 })
[16:04:45.941]                 withCallingHandlers({
[16:04:45.941]                   {
[16:04:45.941]                     4
[16:04:45.941]                   }
[16:04:45.941]                 }, immediateCondition = function(cond) {
[16:04:45.941]                   sendCondition <- ...future.makeSendCondition()
[16:04:45.941]                   sendCondition(cond)
[16:04:45.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.941]                   {
[16:04:45.941]                     inherits <- base::inherits
[16:04:45.941]                     invokeRestart <- base::invokeRestart
[16:04:45.941]                     is.null <- base::is.null
[16:04:45.941]                     muffled <- FALSE
[16:04:45.941]                     if (inherits(cond, "message")) {
[16:04:45.941]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:45.941]                       if (muffled) 
[16:04:45.941]                         invokeRestart("muffleMessage")
[16:04:45.941]                     }
[16:04:45.941]                     else if (inherits(cond, "warning")) {
[16:04:45.941]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:45.941]                       if (muffled) 
[16:04:45.941]                         invokeRestart("muffleWarning")
[16:04:45.941]                     }
[16:04:45.941]                     else if (inherits(cond, "condition")) {
[16:04:45.941]                       if (!is.null(pattern)) {
[16:04:45.941]                         computeRestarts <- base::computeRestarts
[16:04:45.941]                         grepl <- base::grepl
[16:04:45.941]                         restarts <- computeRestarts(cond)
[16:04:45.941]                         for (restart in restarts) {
[16:04:45.941]                           name <- restart$name
[16:04:45.941]                           if (is.null(name)) 
[16:04:45.941]                             next
[16:04:45.941]                           if (!grepl(pattern, name)) 
[16:04:45.941]                             next
[16:04:45.941]                           invokeRestart(restart)
[16:04:45.941]                           muffled <- TRUE
[16:04:45.941]                           break
[16:04:45.941]                         }
[16:04:45.941]                       }
[16:04:45.941]                     }
[16:04:45.941]                     invisible(muffled)
[16:04:45.941]                   }
[16:04:45.941]                   muffleCondition(cond)
[16:04:45.941]                 })
[16:04:45.941]             }))
[16:04:45.941]             future::FutureResult(value = ...future.value$value, 
[16:04:45.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.941]                   ...future.rng), globalenv = if (FALSE) 
[16:04:45.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:45.941]                     ...future.globalenv.names))
[16:04:45.941]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:45.941]         }, condition = base::local({
[16:04:45.941]             c <- base::c
[16:04:45.941]             inherits <- base::inherits
[16:04:45.941]             invokeRestart <- base::invokeRestart
[16:04:45.941]             length <- base::length
[16:04:45.941]             list <- base::list
[16:04:45.941]             seq.int <- base::seq.int
[16:04:45.941]             signalCondition <- base::signalCondition
[16:04:45.941]             sys.calls <- base::sys.calls
[16:04:45.941]             `[[` <- base::`[[`
[16:04:45.941]             `+` <- base::`+`
[16:04:45.941]             `<<-` <- base::`<<-`
[16:04:45.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:45.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:45.941]                   3L)]
[16:04:45.941]             }
[16:04:45.941]             function(cond) {
[16:04:45.941]                 is_error <- inherits(cond, "error")
[16:04:45.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:45.941]                   NULL)
[16:04:45.941]                 if (is_error) {
[16:04:45.941]                   sessionInformation <- function() {
[16:04:45.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:45.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:45.941]                       search = base::search(), system = base::Sys.info())
[16:04:45.941]                   }
[16:04:45.941]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:45.941]                     cond$call), session = sessionInformation(), 
[16:04:45.941]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:45.941]                   signalCondition(cond)
[16:04:45.941]                 }
[16:04:45.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:45.941]                 "immediateCondition"))) {
[16:04:45.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:45.941]                   ...future.conditions[[length(...future.conditions) + 
[16:04:45.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:45.941]                   if (TRUE && !signal) {
[16:04:45.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.941]                     {
[16:04:45.941]                       inherits <- base::inherits
[16:04:45.941]                       invokeRestart <- base::invokeRestart
[16:04:45.941]                       is.null <- base::is.null
[16:04:45.941]                       muffled <- FALSE
[16:04:45.941]                       if (inherits(cond, "message")) {
[16:04:45.941]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.941]                         if (muffled) 
[16:04:45.941]                           invokeRestart("muffleMessage")
[16:04:45.941]                       }
[16:04:45.941]                       else if (inherits(cond, "warning")) {
[16:04:45.941]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.941]                         if (muffled) 
[16:04:45.941]                           invokeRestart("muffleWarning")
[16:04:45.941]                       }
[16:04:45.941]                       else if (inherits(cond, "condition")) {
[16:04:45.941]                         if (!is.null(pattern)) {
[16:04:45.941]                           computeRestarts <- base::computeRestarts
[16:04:45.941]                           grepl <- base::grepl
[16:04:45.941]                           restarts <- computeRestarts(cond)
[16:04:45.941]                           for (restart in restarts) {
[16:04:45.941]                             name <- restart$name
[16:04:45.941]                             if (is.null(name)) 
[16:04:45.941]                               next
[16:04:45.941]                             if (!grepl(pattern, name)) 
[16:04:45.941]                               next
[16:04:45.941]                             invokeRestart(restart)
[16:04:45.941]                             muffled <- TRUE
[16:04:45.941]                             break
[16:04:45.941]                           }
[16:04:45.941]                         }
[16:04:45.941]                       }
[16:04:45.941]                       invisible(muffled)
[16:04:45.941]                     }
[16:04:45.941]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.941]                   }
[16:04:45.941]                 }
[16:04:45.941]                 else {
[16:04:45.941]                   if (TRUE) {
[16:04:45.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:45.941]                     {
[16:04:45.941]                       inherits <- base::inherits
[16:04:45.941]                       invokeRestart <- base::invokeRestart
[16:04:45.941]                       is.null <- base::is.null
[16:04:45.941]                       muffled <- FALSE
[16:04:45.941]                       if (inherits(cond, "message")) {
[16:04:45.941]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:45.941]                         if (muffled) 
[16:04:45.941]                           invokeRestart("muffleMessage")
[16:04:45.941]                       }
[16:04:45.941]                       else if (inherits(cond, "warning")) {
[16:04:45.941]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:45.941]                         if (muffled) 
[16:04:45.941]                           invokeRestart("muffleWarning")
[16:04:45.941]                       }
[16:04:45.941]                       else if (inherits(cond, "condition")) {
[16:04:45.941]                         if (!is.null(pattern)) {
[16:04:45.941]                           computeRestarts <- base::computeRestarts
[16:04:45.941]                           grepl <- base::grepl
[16:04:45.941]                           restarts <- computeRestarts(cond)
[16:04:45.941]                           for (restart in restarts) {
[16:04:45.941]                             name <- restart$name
[16:04:45.941]                             if (is.null(name)) 
[16:04:45.941]                               next
[16:04:45.941]                             if (!grepl(pattern, name)) 
[16:04:45.941]                               next
[16:04:45.941]                             invokeRestart(restart)
[16:04:45.941]                             muffled <- TRUE
[16:04:45.941]                             break
[16:04:45.941]                           }
[16:04:45.941]                         }
[16:04:45.941]                       }
[16:04:45.941]                       invisible(muffled)
[16:04:45.941]                     }
[16:04:45.941]                     muffleCondition(cond, pattern = "^muffle")
[16:04:45.941]                   }
[16:04:45.941]                 }
[16:04:45.941]             }
[16:04:45.941]         }))
[16:04:45.941]     }, error = function(ex) {
[16:04:45.941]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:45.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:45.941]                 ...future.rng), started = ...future.startTime, 
[16:04:45.941]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:45.941]             version = "1.8"), class = "FutureResult")
[16:04:45.941]     }, finally = {
[16:04:45.941]         if (!identical(...future.workdir, getwd())) 
[16:04:45.941]             setwd(...future.workdir)
[16:04:45.941]         {
[16:04:45.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:45.941]                 ...future.oldOptions$nwarnings <- NULL
[16:04:45.941]             }
[16:04:45.941]             base::options(...future.oldOptions)
[16:04:45.941]             if (.Platform$OS.type == "windows") {
[16:04:45.941]                 old_names <- names(...future.oldEnvVars)
[16:04:45.941]                 envs <- base::Sys.getenv()
[16:04:45.941]                 names <- names(envs)
[16:04:45.941]                 common <- intersect(names, old_names)
[16:04:45.941]                 added <- setdiff(names, old_names)
[16:04:45.941]                 removed <- setdiff(old_names, names)
[16:04:45.941]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:45.941]                   envs[common]]
[16:04:45.941]                 NAMES <- toupper(changed)
[16:04:45.941]                 args <- list()
[16:04:45.941]                 for (kk in seq_along(NAMES)) {
[16:04:45.941]                   name <- changed[[kk]]
[16:04:45.941]                   NAME <- NAMES[[kk]]
[16:04:45.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.941]                     next
[16:04:45.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.941]                 }
[16:04:45.941]                 NAMES <- toupper(added)
[16:04:45.941]                 for (kk in seq_along(NAMES)) {
[16:04:45.941]                   name <- added[[kk]]
[16:04:45.941]                   NAME <- NAMES[[kk]]
[16:04:45.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.941]                     next
[16:04:45.941]                   args[[name]] <- ""
[16:04:45.941]                 }
[16:04:45.941]                 NAMES <- toupper(removed)
[16:04:45.941]                 for (kk in seq_along(NAMES)) {
[16:04:45.941]                   name <- removed[[kk]]
[16:04:45.941]                   NAME <- NAMES[[kk]]
[16:04:45.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:45.941]                     next
[16:04:45.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:45.941]                 }
[16:04:45.941]                 if (length(args) > 0) 
[16:04:45.941]                   base::do.call(base::Sys.setenv, args = args)
[16:04:45.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:45.941]             }
[16:04:45.941]             else {
[16:04:45.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:45.941]             }
[16:04:45.941]             {
[16:04:45.941]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:45.941]                   0L) {
[16:04:45.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:45.941]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:45.941]                   base::options(opts)
[16:04:45.941]                 }
[16:04:45.941]                 {
[16:04:45.941]                   {
[16:04:45.941]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:45.941]                     NULL
[16:04:45.941]                   }
[16:04:45.941]                   options(future.plan = NULL)
[16:04:45.941]                   if (is.na(NA_character_)) 
[16:04:45.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:45.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:45.941]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:45.941]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:45.941]                     envir = parent.frame()) 
[16:04:45.941]                   {
[16:04:45.941]                     if (is.function(workers)) 
[16:04:45.941]                       workers <- workers()
[16:04:45.941]                     workers <- structure(as.integer(workers), 
[16:04:45.941]                       class = class(workers))
[16:04:45.941]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:45.941]                       workers >= 1)
[16:04:45.941]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:45.941]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:45.941]                     }
[16:04:45.941]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:45.941]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:45.941]                       envir = envir)
[16:04:45.941]                     if (!future$lazy) 
[16:04:45.941]                       future <- run(future)
[16:04:45.941]                     invisible(future)
[16:04:45.941]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:45.941]                 }
[16:04:45.941]             }
[16:04:45.941]         }
[16:04:45.941]     })
[16:04:45.941]     if (TRUE) {
[16:04:45.941]         base::sink(type = "output", split = FALSE)
[16:04:45.941]         if (TRUE) {
[16:04:45.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:45.941]         }
[16:04:45.941]         else {
[16:04:45.941]             ...future.result["stdout"] <- base::list(NULL)
[16:04:45.941]         }
[16:04:45.941]         base::close(...future.stdout)
[16:04:45.941]         ...future.stdout <- NULL
[16:04:45.941]     }
[16:04:45.941]     ...future.result$conditions <- ...future.conditions
[16:04:45.941]     ...future.result$finished <- base::Sys.time()
[16:04:45.941]     ...future.result
[16:04:45.941] }
[16:04:45.945] Poll #1 (0): usedNodes() = 2, workers = 2
[16:04:45.956] receiveMessageFromWorker() for ClusterFuture ...
[16:04:45.956] - Validating connection of MultisessionFuture
[16:04:45.956] - received message: FutureResult
[16:04:45.956] - Received FutureResult
[16:04:45.956] - Erased future from FutureRegistry
[16:04:45.957] result() for ClusterFuture ...
[16:04:45.957] - result already collected: FutureResult
[16:04:45.957] result() for ClusterFuture ... done
[16:04:45.957] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:45.957] result() for ClusterFuture ...
[16:04:45.957] - result already collected: FutureResult
[16:04:45.958] result() for ClusterFuture ... done
[16:04:45.958] result() for ClusterFuture ...
[16:04:45.958] - result already collected: FutureResult
[16:04:45.958] result() for ClusterFuture ... done
[16:04:45.959] MultisessionFuture started
[16:04:45.960] - Launch lazy future ... done
[16:04:45.960] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55874fabf428> 
Classes 'listenv', 'environment' <environment: 0x55874c2a3b00> 
[16:04:45.970] receiveMessageFromWorker() for ClusterFuture ...
[16:04:45.970] - Validating connection of MultisessionFuture
[16:04:45.970] - received message: FutureResult
[16:04:45.970] - Received FutureResult
[16:04:45.970] - Erased future from FutureRegistry
[16:04:45.970] result() for ClusterFuture ...
[16:04:45.970] - result already collected: FutureResult
[16:04:45.970] result() for ClusterFuture ... done
[16:04:45.971] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:45.983] resolve() on list environment ...
[16:04:45.983]  recursive: 0
[16:04:45.984]  length: 6
[16:04:45.984]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:45.984] signalConditionsASAP(numeric, pos=1) ...
[16:04:45.984] - nx: 6
[16:04:45.984] - relay: TRUE
[16:04:45.984] - stdout: TRUE
[16:04:45.984] - signal: TRUE
[16:04:45.984] - resignal: FALSE
[16:04:45.984] - force: TRUE
[16:04:45.984] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.985] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.985]  - until=2
[16:04:45.985]  - relaying element #2
[16:04:45.985] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.985] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.985] signalConditionsASAP(NULL, pos=1) ... done
[16:04:45.985]  length: 5 (resolved future 1)
[16:04:45.985] Future #2
[16:04:45.985] result() for ClusterFuture ...
[16:04:45.985] - result already collected: FutureResult
[16:04:45.986] result() for ClusterFuture ... done
[16:04:45.986] result() for ClusterFuture ...
[16:04:45.986] - result already collected: FutureResult
[16:04:45.986] result() for ClusterFuture ... done
[16:04:45.986] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:45.986] - nx: 6
[16:04:45.986] - relay: TRUE
[16:04:45.986] - stdout: TRUE
[16:04:45.986] - signal: TRUE
[16:04:45.986] - resignal: FALSE
[16:04:45.986] - force: TRUE
[16:04:45.986] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.987] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:45.987]  - until=2
[16:04:45.987]  - relaying element #2
[16:04:45.987] result() for ClusterFuture ...
[16:04:45.987] - result already collected: FutureResult
[16:04:45.987] result() for ClusterFuture ... done
[16:04:45.987] result() for ClusterFuture ...
[16:04:45.987] - result already collected: FutureResult
[16:04:45.987] result() for ClusterFuture ... done
[16:04:45.987] result() for ClusterFuture ...
[16:04:45.988] - result already collected: FutureResult
[16:04:45.988] result() for ClusterFuture ... done
[16:04:45.988] result() for ClusterFuture ...
[16:04:45.988] - result already collected: FutureResult
[16:04:45.988] result() for ClusterFuture ... done
[16:04:45.988] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.988] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.988] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:45.988]  length: 4 (resolved future 2)
[16:04:45.988] Future #3
[16:04:45.989] result() for ClusterFuture ...
[16:04:45.989] - result already collected: FutureResult
[16:04:45.989] result() for ClusterFuture ... done
[16:04:45.989] result() for ClusterFuture ...
[16:04:45.989] - result already collected: FutureResult
[16:04:45.989] result() for ClusterFuture ... done
[16:04:45.989] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:45.989] - nx: 6
[16:04:45.989] - relay: TRUE
[16:04:45.989] - stdout: TRUE
[16:04:45.989] - signal: TRUE
[16:04:45.989] - resignal: FALSE
[16:04:45.990] - force: TRUE
[16:04:45.990] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.990] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:45.990]  - until=3
[16:04:45.990]  - relaying element #3
[16:04:45.990] result() for ClusterFuture ...
[16:04:45.990] - result already collected: FutureResult
[16:04:45.990] result() for ClusterFuture ... done
[16:04:45.990] result() for ClusterFuture ...
[16:04:45.990] - result already collected: FutureResult
[16:04:45.990] result() for ClusterFuture ... done
[16:04:45.990] result() for ClusterFuture ...
[16:04:45.991] - result already collected: FutureResult
[16:04:45.991] result() for ClusterFuture ... done
[16:04:45.991] result() for ClusterFuture ...
[16:04:45.991] - result already collected: FutureResult
[16:04:45.991] result() for ClusterFuture ... done
[16:04:45.991] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.991] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:45.991] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:45.991]  length: 3 (resolved future 3)
[16:04:46.002] signalConditionsASAP(NULL, pos=5) ...
[16:04:46.002] - nx: 6
[16:04:46.002] - relay: TRUE
[16:04:46.002] - stdout: TRUE
[16:04:46.002] - signal: TRUE
[16:04:46.002] - resignal: FALSE
[16:04:46.002] - force: TRUE
[16:04:46.003] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.003] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.003]  - until=6
[16:04:46.003]  - relaying element #4
[16:04:46.003]  - relaying element #6
[16:04:46.003] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:04:46.003] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.003] signalConditionsASAP(NULL, pos=5) ... done
[16:04:46.003]  length: 2 (resolved future 5)
[16:04:46.004] signalConditionsASAP(numeric, pos=6) ...
[16:04:46.004] - nx: 6
[16:04:46.004] - relay: TRUE
[16:04:46.004] - stdout: TRUE
[16:04:46.004] - signal: TRUE
[16:04:46.004] - resignal: FALSE
[16:04:46.004] - force: TRUE
[16:04:46.004] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:04:46.004] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.004]  - until=6
[16:04:46.004]  - relaying element #4
[16:04:46.004] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:04:46.005] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.005] signalConditionsASAP(NULL, pos=6) ... done
[16:04:46.005]  length: 1 (resolved future 6)
[16:04:46.015] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.016] - Validating connection of MultisessionFuture
[16:04:46.016] - received message: FutureResult
[16:04:46.016] - Received FutureResult
[16:04:46.016] - Erased future from FutureRegistry
[16:04:46.016] result() for ClusterFuture ...
[16:04:46.016] - result already collected: FutureResult
[16:04:46.016] result() for ClusterFuture ... done
[16:04:46.016] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:46.016] Future #4
[16:04:46.017] result() for ClusterFuture ...
[16:04:46.017] - result already collected: FutureResult
[16:04:46.017] result() for ClusterFuture ... done
[16:04:46.017] result() for ClusterFuture ...
[16:04:46.017] - result already collected: FutureResult
[16:04:46.017] result() for ClusterFuture ... done
[16:04:46.017] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:04:46.017] - nx: 6
[16:04:46.017] - relay: TRUE
[16:04:46.017] - stdout: TRUE
[16:04:46.017] - signal: TRUE
[16:04:46.017] - resignal: FALSE
[16:04:46.018] - force: TRUE
[16:04:46.018] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:04:46.018] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.018]  - until=6
[16:04:46.018]  - relaying element #4
[16:04:46.018] result() for ClusterFuture ...
[16:04:46.018] - result already collected: FutureResult
[16:04:46.018] result() for ClusterFuture ... done
[16:04:46.018] result() for ClusterFuture ...
[16:04:46.018] - result already collected: FutureResult
[16:04:46.018] result() for ClusterFuture ... done
[16:04:46.018] result() for ClusterFuture ...
[16:04:46.019] - result already collected: FutureResult
[16:04:46.019] result() for ClusterFuture ... done
[16:04:46.019] result() for ClusterFuture ...
[16:04:46.019] - result already collected: FutureResult
[16:04:46.019] result() for ClusterFuture ... done
[16:04:46.019] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.019] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.019] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:04:46.019]  length: 0 (resolved future 4)
[16:04:46.019] Relaying remaining futures
[16:04:46.020] signalConditionsASAP(NULL, pos=0) ...
[16:04:46.020] - nx: 6
[16:04:46.020] - relay: TRUE
[16:04:46.020] - stdout: TRUE
[16:04:46.020] - signal: TRUE
[16:04:46.020] - resignal: FALSE
[16:04:46.020] - force: TRUE
[16:04:46.020] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.020] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:46.020] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.020] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.021] signalConditionsASAP(NULL, pos=0) ... done
[16:04:46.021] resolve() on list environment ... DONE
[16:04:46.021] result() for ClusterFuture ...
[16:04:46.021] - result already collected: FutureResult
[16:04:46.021] result() for ClusterFuture ... done
[16:04:46.021] result() for ClusterFuture ...
[16:04:46.021] - result already collected: FutureResult
[16:04:46.021] result() for ClusterFuture ... done
[16:04:46.021] result() for ClusterFuture ...
[16:04:46.021] - result already collected: FutureResult
[16:04:46.021] result() for ClusterFuture ... done
[16:04:46.022] result() for ClusterFuture ...
[16:04:46.022] - result already collected: FutureResult
[16:04:46.022] result() for ClusterFuture ... done
[16:04:46.022] result() for ClusterFuture ...
[16:04:46.022] - result already collected: FutureResult
[16:04:46.022] result() for ClusterFuture ... done
[16:04:46.022] result() for ClusterFuture ...
[16:04:46.022] - result already collected: FutureResult
[16:04:46.022] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55874e4ef118> 
Dimensions: c(1, 6)
[16:04:46.023] getGlobalsAndPackages() ...
[16:04:46.023] Searching for globals...
[16:04:46.023] 
[16:04:46.023] Searching for globals ... DONE
[16:04:46.024] - globals: [0] <none>
[16:04:46.024] getGlobalsAndPackages() ... DONE
[16:04:46.024] run() for ‘Future’ ...
[16:04:46.024] - state: ‘created’
[16:04:46.024] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:46.038] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:46.038] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:46.038]   - Field: ‘node’
[16:04:46.038]   - Field: ‘label’
[16:04:46.038]   - Field: ‘local’
[16:04:46.039]   - Field: ‘owner’
[16:04:46.039]   - Field: ‘envir’
[16:04:46.039]   - Field: ‘workers’
[16:04:46.039]   - Field: ‘packages’
[16:04:46.039]   - Field: ‘gc’
[16:04:46.039]   - Field: ‘conditions’
[16:04:46.039]   - Field: ‘persistent’
[16:04:46.039]   - Field: ‘expr’
[16:04:46.039]   - Field: ‘uuid’
[16:04:46.039]   - Field: ‘seed’
[16:04:46.040]   - Field: ‘version’
[16:04:46.040]   - Field: ‘result’
[16:04:46.040]   - Field: ‘asynchronous’
[16:04:46.040]   - Field: ‘calls’
[16:04:46.040]   - Field: ‘globals’
[16:04:46.040]   - Field: ‘stdout’
[16:04:46.040]   - Field: ‘earlySignal’
[16:04:46.040]   - Field: ‘lazy’
[16:04:46.040]   - Field: ‘state’
[16:04:46.040] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:46.040] - Launch lazy future ...
[16:04:46.041] Packages needed by the future expression (n = 0): <none>
[16:04:46.041] Packages needed by future strategies (n = 0): <none>
[16:04:46.041] {
[16:04:46.041]     {
[16:04:46.041]         {
[16:04:46.041]             ...future.startTime <- base::Sys.time()
[16:04:46.041]             {
[16:04:46.041]                 {
[16:04:46.041]                   {
[16:04:46.041]                     {
[16:04:46.041]                       base::local({
[16:04:46.041]                         has_future <- base::requireNamespace("future", 
[16:04:46.041]                           quietly = TRUE)
[16:04:46.041]                         if (has_future) {
[16:04:46.041]                           ns <- base::getNamespace("future")
[16:04:46.041]                           version <- ns[[".package"]][["version"]]
[16:04:46.041]                           if (is.null(version)) 
[16:04:46.041]                             version <- utils::packageVersion("future")
[16:04:46.041]                         }
[16:04:46.041]                         else {
[16:04:46.041]                           version <- NULL
[16:04:46.041]                         }
[16:04:46.041]                         if (!has_future || version < "1.8.0") {
[16:04:46.041]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:46.041]                             "", base::R.version$version.string), 
[16:04:46.041]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:46.041]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:46.041]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:46.041]                               "release", "version")], collapse = " "), 
[16:04:46.041]                             hostname = base::Sys.info()[["nodename"]])
[16:04:46.041]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:46.041]                             info)
[16:04:46.041]                           info <- base::paste(info, collapse = "; ")
[16:04:46.041]                           if (!has_future) {
[16:04:46.041]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:46.041]                               info)
[16:04:46.041]                           }
[16:04:46.041]                           else {
[16:04:46.041]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:46.041]                               info, version)
[16:04:46.041]                           }
[16:04:46.041]                           base::stop(msg)
[16:04:46.041]                         }
[16:04:46.041]                       })
[16:04:46.041]                     }
[16:04:46.041]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:46.041]                     base::options(mc.cores = 1L)
[16:04:46.041]                   }
[16:04:46.041]                   options(future.plan = NULL)
[16:04:46.041]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.041]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:46.041]                 }
[16:04:46.041]                 ...future.workdir <- getwd()
[16:04:46.041]             }
[16:04:46.041]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:46.041]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:46.041]         }
[16:04:46.041]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:46.041]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:46.041]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:46.041]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:46.041]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:46.041]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:46.041]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:46.041]             base::names(...future.oldOptions))
[16:04:46.041]     }
[16:04:46.041]     if (FALSE) {
[16:04:46.041]     }
[16:04:46.041]     else {
[16:04:46.041]         if (TRUE) {
[16:04:46.041]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:46.041]                 open = "w")
[16:04:46.041]         }
[16:04:46.041]         else {
[16:04:46.041]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:46.041]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:46.041]         }
[16:04:46.041]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:46.041]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:46.041]             base::sink(type = "output", split = FALSE)
[16:04:46.041]             base::close(...future.stdout)
[16:04:46.041]         }, add = TRUE)
[16:04:46.041]     }
[16:04:46.041]     ...future.frame <- base::sys.nframe()
[16:04:46.041]     ...future.conditions <- base::list()
[16:04:46.041]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:46.041]     if (FALSE) {
[16:04:46.041]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:46.041]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:46.041]     }
[16:04:46.041]     ...future.result <- base::tryCatch({
[16:04:46.041]         base::withCallingHandlers({
[16:04:46.041]             ...future.value <- base::withVisible(base::local({
[16:04:46.041]                 ...future.makeSendCondition <- base::local({
[16:04:46.041]                   sendCondition <- NULL
[16:04:46.041]                   function(frame = 1L) {
[16:04:46.041]                     if (is.function(sendCondition)) 
[16:04:46.041]                       return(sendCondition)
[16:04:46.041]                     ns <- getNamespace("parallel")
[16:04:46.041]                     if (exists("sendData", mode = "function", 
[16:04:46.041]                       envir = ns)) {
[16:04:46.041]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:46.041]                         envir = ns)
[16:04:46.041]                       envir <- sys.frame(frame)
[16:04:46.041]                       master <- NULL
[16:04:46.041]                       while (!identical(envir, .GlobalEnv) && 
[16:04:46.041]                         !identical(envir, emptyenv())) {
[16:04:46.041]                         if (exists("master", mode = "list", envir = envir, 
[16:04:46.041]                           inherits = FALSE)) {
[16:04:46.041]                           master <- get("master", mode = "list", 
[16:04:46.041]                             envir = envir, inherits = FALSE)
[16:04:46.041]                           if (inherits(master, c("SOCKnode", 
[16:04:46.041]                             "SOCK0node"))) {
[16:04:46.041]                             sendCondition <<- function(cond) {
[16:04:46.041]                               data <- list(type = "VALUE", value = cond, 
[16:04:46.041]                                 success = TRUE)
[16:04:46.041]                               parallel_sendData(master, data)
[16:04:46.041]                             }
[16:04:46.041]                             return(sendCondition)
[16:04:46.041]                           }
[16:04:46.041]                         }
[16:04:46.041]                         frame <- frame + 1L
[16:04:46.041]                         envir <- sys.frame(frame)
[16:04:46.041]                       }
[16:04:46.041]                     }
[16:04:46.041]                     sendCondition <<- function(cond) NULL
[16:04:46.041]                   }
[16:04:46.041]                 })
[16:04:46.041]                 withCallingHandlers({
[16:04:46.041]                   2
[16:04:46.041]                 }, immediateCondition = function(cond) {
[16:04:46.041]                   sendCondition <- ...future.makeSendCondition()
[16:04:46.041]                   sendCondition(cond)
[16:04:46.041]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.041]                   {
[16:04:46.041]                     inherits <- base::inherits
[16:04:46.041]                     invokeRestart <- base::invokeRestart
[16:04:46.041]                     is.null <- base::is.null
[16:04:46.041]                     muffled <- FALSE
[16:04:46.041]                     if (inherits(cond, "message")) {
[16:04:46.041]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:46.041]                       if (muffled) 
[16:04:46.041]                         invokeRestart("muffleMessage")
[16:04:46.041]                     }
[16:04:46.041]                     else if (inherits(cond, "warning")) {
[16:04:46.041]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:46.041]                       if (muffled) 
[16:04:46.041]                         invokeRestart("muffleWarning")
[16:04:46.041]                     }
[16:04:46.041]                     else if (inherits(cond, "condition")) {
[16:04:46.041]                       if (!is.null(pattern)) {
[16:04:46.041]                         computeRestarts <- base::computeRestarts
[16:04:46.041]                         grepl <- base::grepl
[16:04:46.041]                         restarts <- computeRestarts(cond)
[16:04:46.041]                         for (restart in restarts) {
[16:04:46.041]                           name <- restart$name
[16:04:46.041]                           if (is.null(name)) 
[16:04:46.041]                             next
[16:04:46.041]                           if (!grepl(pattern, name)) 
[16:04:46.041]                             next
[16:04:46.041]                           invokeRestart(restart)
[16:04:46.041]                           muffled <- TRUE
[16:04:46.041]                           break
[16:04:46.041]                         }
[16:04:46.041]                       }
[16:04:46.041]                     }
[16:04:46.041]                     invisible(muffled)
[16:04:46.041]                   }
[16:04:46.041]                   muffleCondition(cond)
[16:04:46.041]                 })
[16:04:46.041]             }))
[16:04:46.041]             future::FutureResult(value = ...future.value$value, 
[16:04:46.041]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.041]                   ...future.rng), globalenv = if (FALSE) 
[16:04:46.041]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:46.041]                     ...future.globalenv.names))
[16:04:46.041]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:46.041]         }, condition = base::local({
[16:04:46.041]             c <- base::c
[16:04:46.041]             inherits <- base::inherits
[16:04:46.041]             invokeRestart <- base::invokeRestart
[16:04:46.041]             length <- base::length
[16:04:46.041]             list <- base::list
[16:04:46.041]             seq.int <- base::seq.int
[16:04:46.041]             signalCondition <- base::signalCondition
[16:04:46.041]             sys.calls <- base::sys.calls
[16:04:46.041]             `[[` <- base::`[[`
[16:04:46.041]             `+` <- base::`+`
[16:04:46.041]             `<<-` <- base::`<<-`
[16:04:46.041]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:46.041]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:46.041]                   3L)]
[16:04:46.041]             }
[16:04:46.041]             function(cond) {
[16:04:46.041]                 is_error <- inherits(cond, "error")
[16:04:46.041]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:46.041]                   NULL)
[16:04:46.041]                 if (is_error) {
[16:04:46.041]                   sessionInformation <- function() {
[16:04:46.041]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:46.041]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:46.041]                       search = base::search(), system = base::Sys.info())
[16:04:46.041]                   }
[16:04:46.041]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.041]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:46.041]                     cond$call), session = sessionInformation(), 
[16:04:46.041]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:46.041]                   signalCondition(cond)
[16:04:46.041]                 }
[16:04:46.041]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:46.041]                 "immediateCondition"))) {
[16:04:46.041]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:46.041]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.041]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:46.041]                   if (TRUE && !signal) {
[16:04:46.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.041]                     {
[16:04:46.041]                       inherits <- base::inherits
[16:04:46.041]                       invokeRestart <- base::invokeRestart
[16:04:46.041]                       is.null <- base::is.null
[16:04:46.041]                       muffled <- FALSE
[16:04:46.041]                       if (inherits(cond, "message")) {
[16:04:46.041]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.041]                         if (muffled) 
[16:04:46.041]                           invokeRestart("muffleMessage")
[16:04:46.041]                       }
[16:04:46.041]                       else if (inherits(cond, "warning")) {
[16:04:46.041]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.041]                         if (muffled) 
[16:04:46.041]                           invokeRestart("muffleWarning")
[16:04:46.041]                       }
[16:04:46.041]                       else if (inherits(cond, "condition")) {
[16:04:46.041]                         if (!is.null(pattern)) {
[16:04:46.041]                           computeRestarts <- base::computeRestarts
[16:04:46.041]                           grepl <- base::grepl
[16:04:46.041]                           restarts <- computeRestarts(cond)
[16:04:46.041]                           for (restart in restarts) {
[16:04:46.041]                             name <- restart$name
[16:04:46.041]                             if (is.null(name)) 
[16:04:46.041]                               next
[16:04:46.041]                             if (!grepl(pattern, name)) 
[16:04:46.041]                               next
[16:04:46.041]                             invokeRestart(restart)
[16:04:46.041]                             muffled <- TRUE
[16:04:46.041]                             break
[16:04:46.041]                           }
[16:04:46.041]                         }
[16:04:46.041]                       }
[16:04:46.041]                       invisible(muffled)
[16:04:46.041]                     }
[16:04:46.041]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.041]                   }
[16:04:46.041]                 }
[16:04:46.041]                 else {
[16:04:46.041]                   if (TRUE) {
[16:04:46.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.041]                     {
[16:04:46.041]                       inherits <- base::inherits
[16:04:46.041]                       invokeRestart <- base::invokeRestart
[16:04:46.041]                       is.null <- base::is.null
[16:04:46.041]                       muffled <- FALSE
[16:04:46.041]                       if (inherits(cond, "message")) {
[16:04:46.041]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.041]                         if (muffled) 
[16:04:46.041]                           invokeRestart("muffleMessage")
[16:04:46.041]                       }
[16:04:46.041]                       else if (inherits(cond, "warning")) {
[16:04:46.041]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.041]                         if (muffled) 
[16:04:46.041]                           invokeRestart("muffleWarning")
[16:04:46.041]                       }
[16:04:46.041]                       else if (inherits(cond, "condition")) {
[16:04:46.041]                         if (!is.null(pattern)) {
[16:04:46.041]                           computeRestarts <- base::computeRestarts
[16:04:46.041]                           grepl <- base::grepl
[16:04:46.041]                           restarts <- computeRestarts(cond)
[16:04:46.041]                           for (restart in restarts) {
[16:04:46.041]                             name <- restart$name
[16:04:46.041]                             if (is.null(name)) 
[16:04:46.041]                               next
[16:04:46.041]                             if (!grepl(pattern, name)) 
[16:04:46.041]                               next
[16:04:46.041]                             invokeRestart(restart)
[16:04:46.041]                             muffled <- TRUE
[16:04:46.041]                             break
[16:04:46.041]                           }
[16:04:46.041]                         }
[16:04:46.041]                       }
[16:04:46.041]                       invisible(muffled)
[16:04:46.041]                     }
[16:04:46.041]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.041]                   }
[16:04:46.041]                 }
[16:04:46.041]             }
[16:04:46.041]         }))
[16:04:46.041]     }, error = function(ex) {
[16:04:46.041]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:46.041]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.041]                 ...future.rng), started = ...future.startTime, 
[16:04:46.041]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:46.041]             version = "1.8"), class = "FutureResult")
[16:04:46.041]     }, finally = {
[16:04:46.041]         if (!identical(...future.workdir, getwd())) 
[16:04:46.041]             setwd(...future.workdir)
[16:04:46.041]         {
[16:04:46.041]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:46.041]                 ...future.oldOptions$nwarnings <- NULL
[16:04:46.041]             }
[16:04:46.041]             base::options(...future.oldOptions)
[16:04:46.041]             if (.Platform$OS.type == "windows") {
[16:04:46.041]                 old_names <- names(...future.oldEnvVars)
[16:04:46.041]                 envs <- base::Sys.getenv()
[16:04:46.041]                 names <- names(envs)
[16:04:46.041]                 common <- intersect(names, old_names)
[16:04:46.041]                 added <- setdiff(names, old_names)
[16:04:46.041]                 removed <- setdiff(old_names, names)
[16:04:46.041]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:46.041]                   envs[common]]
[16:04:46.041]                 NAMES <- toupper(changed)
[16:04:46.041]                 args <- list()
[16:04:46.041]                 for (kk in seq_along(NAMES)) {
[16:04:46.041]                   name <- changed[[kk]]
[16:04:46.041]                   NAME <- NAMES[[kk]]
[16:04:46.041]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.041]                     next
[16:04:46.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.041]                 }
[16:04:46.041]                 NAMES <- toupper(added)
[16:04:46.041]                 for (kk in seq_along(NAMES)) {
[16:04:46.041]                   name <- added[[kk]]
[16:04:46.041]                   NAME <- NAMES[[kk]]
[16:04:46.041]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.041]                     next
[16:04:46.041]                   args[[name]] <- ""
[16:04:46.041]                 }
[16:04:46.041]                 NAMES <- toupper(removed)
[16:04:46.041]                 for (kk in seq_along(NAMES)) {
[16:04:46.041]                   name <- removed[[kk]]
[16:04:46.041]                   NAME <- NAMES[[kk]]
[16:04:46.041]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.041]                     next
[16:04:46.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.041]                 }
[16:04:46.041]                 if (length(args) > 0) 
[16:04:46.041]                   base::do.call(base::Sys.setenv, args = args)
[16:04:46.041]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:46.041]             }
[16:04:46.041]             else {
[16:04:46.041]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:46.041]             }
[16:04:46.041]             {
[16:04:46.041]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:46.041]                   0L) {
[16:04:46.041]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:46.041]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:46.041]                   base::options(opts)
[16:04:46.041]                 }
[16:04:46.041]                 {
[16:04:46.041]                   {
[16:04:46.041]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:46.041]                     NULL
[16:04:46.041]                   }
[16:04:46.041]                   options(future.plan = NULL)
[16:04:46.041]                   if (is.na(NA_character_)) 
[16:04:46.041]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.041]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:46.041]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:46.041]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:46.041]                     envir = parent.frame()) 
[16:04:46.041]                   {
[16:04:46.041]                     if (is.function(workers)) 
[16:04:46.041]                       workers <- workers()
[16:04:46.041]                     workers <- structure(as.integer(workers), 
[16:04:46.041]                       class = class(workers))
[16:04:46.041]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:46.041]                       workers >= 1)
[16:04:46.041]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:46.041]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:46.041]                     }
[16:04:46.041]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:46.041]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:46.041]                       envir = envir)
[16:04:46.041]                     if (!future$lazy) 
[16:04:46.041]                       future <- run(future)
[16:04:46.041]                     invisible(future)
[16:04:46.041]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:46.041]                 }
[16:04:46.041]             }
[16:04:46.041]         }
[16:04:46.041]     })
[16:04:46.041]     if (TRUE) {
[16:04:46.041]         base::sink(type = "output", split = FALSE)
[16:04:46.041]         if (TRUE) {
[16:04:46.041]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:46.041]         }
[16:04:46.041]         else {
[16:04:46.041]             ...future.result["stdout"] <- base::list(NULL)
[16:04:46.041]         }
[16:04:46.041]         base::close(...future.stdout)
[16:04:46.041]         ...future.stdout <- NULL
[16:04:46.041]     }
[16:04:46.041]     ...future.result$conditions <- ...future.conditions
[16:04:46.041]     ...future.result$finished <- base::Sys.time()
[16:04:46.041]     ...future.result
[16:04:46.041] }
[16:04:46.045] MultisessionFuture started
[16:04:46.045] - Launch lazy future ... done
[16:04:46.045] run() for ‘MultisessionFuture’ ... done
[16:04:46.045] getGlobalsAndPackages() ...
[16:04:46.045] Searching for globals...
[16:04:46.046] 
[16:04:46.046] Searching for globals ... DONE
[16:04:46.046] - globals: [0] <none>
[16:04:46.046] getGlobalsAndPackages() ... DONE
[16:04:46.046] run() for ‘Future’ ...
[16:04:46.046] - state: ‘created’
[16:04:46.046] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:46.060] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:46.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:46.061]   - Field: ‘node’
[16:04:46.061]   - Field: ‘label’
[16:04:46.061]   - Field: ‘local’
[16:04:46.061]   - Field: ‘owner’
[16:04:46.061]   - Field: ‘envir’
[16:04:46.061]   - Field: ‘workers’
[16:04:46.061]   - Field: ‘packages’
[16:04:46.061]   - Field: ‘gc’
[16:04:46.061]   - Field: ‘conditions’
[16:04:46.062]   - Field: ‘persistent’
[16:04:46.062]   - Field: ‘expr’
[16:04:46.062]   - Field: ‘uuid’
[16:04:46.062]   - Field: ‘seed’
[16:04:46.062]   - Field: ‘version’
[16:04:46.062]   - Field: ‘result’
[16:04:46.062]   - Field: ‘asynchronous’
[16:04:46.062]   - Field: ‘calls’
[16:04:46.062]   - Field: ‘globals’
[16:04:46.062]   - Field: ‘stdout’
[16:04:46.063]   - Field: ‘earlySignal’
[16:04:46.063]   - Field: ‘lazy’
[16:04:46.063]   - Field: ‘state’
[16:04:46.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:46.066] - Launch lazy future ...
[16:04:46.066] Packages needed by the future expression (n = 0): <none>
[16:04:46.066] Packages needed by future strategies (n = 0): <none>
[16:04:46.067] {
[16:04:46.067]     {
[16:04:46.067]         {
[16:04:46.067]             ...future.startTime <- base::Sys.time()
[16:04:46.067]             {
[16:04:46.067]                 {
[16:04:46.067]                   {
[16:04:46.067]                     {
[16:04:46.067]                       base::local({
[16:04:46.067]                         has_future <- base::requireNamespace("future", 
[16:04:46.067]                           quietly = TRUE)
[16:04:46.067]                         if (has_future) {
[16:04:46.067]                           ns <- base::getNamespace("future")
[16:04:46.067]                           version <- ns[[".package"]][["version"]]
[16:04:46.067]                           if (is.null(version)) 
[16:04:46.067]                             version <- utils::packageVersion("future")
[16:04:46.067]                         }
[16:04:46.067]                         else {
[16:04:46.067]                           version <- NULL
[16:04:46.067]                         }
[16:04:46.067]                         if (!has_future || version < "1.8.0") {
[16:04:46.067]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:46.067]                             "", base::R.version$version.string), 
[16:04:46.067]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:46.067]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:46.067]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:46.067]                               "release", "version")], collapse = " "), 
[16:04:46.067]                             hostname = base::Sys.info()[["nodename"]])
[16:04:46.067]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:46.067]                             info)
[16:04:46.067]                           info <- base::paste(info, collapse = "; ")
[16:04:46.067]                           if (!has_future) {
[16:04:46.067]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:46.067]                               info)
[16:04:46.067]                           }
[16:04:46.067]                           else {
[16:04:46.067]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:46.067]                               info, version)
[16:04:46.067]                           }
[16:04:46.067]                           base::stop(msg)
[16:04:46.067]                         }
[16:04:46.067]                       })
[16:04:46.067]                     }
[16:04:46.067]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:46.067]                     base::options(mc.cores = 1L)
[16:04:46.067]                   }
[16:04:46.067]                   options(future.plan = NULL)
[16:04:46.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:46.067]                 }
[16:04:46.067]                 ...future.workdir <- getwd()
[16:04:46.067]             }
[16:04:46.067]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:46.067]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:46.067]         }
[16:04:46.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:46.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:46.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:46.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:46.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:46.067]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:46.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:46.067]             base::names(...future.oldOptions))
[16:04:46.067]     }
[16:04:46.067]     if (FALSE) {
[16:04:46.067]     }
[16:04:46.067]     else {
[16:04:46.067]         if (TRUE) {
[16:04:46.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:46.067]                 open = "w")
[16:04:46.067]         }
[16:04:46.067]         else {
[16:04:46.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:46.067]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:46.067]         }
[16:04:46.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:46.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:46.067]             base::sink(type = "output", split = FALSE)
[16:04:46.067]             base::close(...future.stdout)
[16:04:46.067]         }, add = TRUE)
[16:04:46.067]     }
[16:04:46.067]     ...future.frame <- base::sys.nframe()
[16:04:46.067]     ...future.conditions <- base::list()
[16:04:46.067]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:46.067]     if (FALSE) {
[16:04:46.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:46.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:46.067]     }
[16:04:46.067]     ...future.result <- base::tryCatch({
[16:04:46.067]         base::withCallingHandlers({
[16:04:46.067]             ...future.value <- base::withVisible(base::local({
[16:04:46.067]                 ...future.makeSendCondition <- base::local({
[16:04:46.067]                   sendCondition <- NULL
[16:04:46.067]                   function(frame = 1L) {
[16:04:46.067]                     if (is.function(sendCondition)) 
[16:04:46.067]                       return(sendCondition)
[16:04:46.067]                     ns <- getNamespace("parallel")
[16:04:46.067]                     if (exists("sendData", mode = "function", 
[16:04:46.067]                       envir = ns)) {
[16:04:46.067]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:46.067]                         envir = ns)
[16:04:46.067]                       envir <- sys.frame(frame)
[16:04:46.067]                       master <- NULL
[16:04:46.067]                       while (!identical(envir, .GlobalEnv) && 
[16:04:46.067]                         !identical(envir, emptyenv())) {
[16:04:46.067]                         if (exists("master", mode = "list", envir = envir, 
[16:04:46.067]                           inherits = FALSE)) {
[16:04:46.067]                           master <- get("master", mode = "list", 
[16:04:46.067]                             envir = envir, inherits = FALSE)
[16:04:46.067]                           if (inherits(master, c("SOCKnode", 
[16:04:46.067]                             "SOCK0node"))) {
[16:04:46.067]                             sendCondition <<- function(cond) {
[16:04:46.067]                               data <- list(type = "VALUE", value = cond, 
[16:04:46.067]                                 success = TRUE)
[16:04:46.067]                               parallel_sendData(master, data)
[16:04:46.067]                             }
[16:04:46.067]                             return(sendCondition)
[16:04:46.067]                           }
[16:04:46.067]                         }
[16:04:46.067]                         frame <- frame + 1L
[16:04:46.067]                         envir <- sys.frame(frame)
[16:04:46.067]                       }
[16:04:46.067]                     }
[16:04:46.067]                     sendCondition <<- function(cond) NULL
[16:04:46.067]                   }
[16:04:46.067]                 })
[16:04:46.067]                 withCallingHandlers({
[16:04:46.067]                   NULL
[16:04:46.067]                 }, immediateCondition = function(cond) {
[16:04:46.067]                   sendCondition <- ...future.makeSendCondition()
[16:04:46.067]                   sendCondition(cond)
[16:04:46.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.067]                   {
[16:04:46.067]                     inherits <- base::inherits
[16:04:46.067]                     invokeRestart <- base::invokeRestart
[16:04:46.067]                     is.null <- base::is.null
[16:04:46.067]                     muffled <- FALSE
[16:04:46.067]                     if (inherits(cond, "message")) {
[16:04:46.067]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:46.067]                       if (muffled) 
[16:04:46.067]                         invokeRestart("muffleMessage")
[16:04:46.067]                     }
[16:04:46.067]                     else if (inherits(cond, "warning")) {
[16:04:46.067]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:46.067]                       if (muffled) 
[16:04:46.067]                         invokeRestart("muffleWarning")
[16:04:46.067]                     }
[16:04:46.067]                     else if (inherits(cond, "condition")) {
[16:04:46.067]                       if (!is.null(pattern)) {
[16:04:46.067]                         computeRestarts <- base::computeRestarts
[16:04:46.067]                         grepl <- base::grepl
[16:04:46.067]                         restarts <- computeRestarts(cond)
[16:04:46.067]                         for (restart in restarts) {
[16:04:46.067]                           name <- restart$name
[16:04:46.067]                           if (is.null(name)) 
[16:04:46.067]                             next
[16:04:46.067]                           if (!grepl(pattern, name)) 
[16:04:46.067]                             next
[16:04:46.067]                           invokeRestart(restart)
[16:04:46.067]                           muffled <- TRUE
[16:04:46.067]                           break
[16:04:46.067]                         }
[16:04:46.067]                       }
[16:04:46.067]                     }
[16:04:46.067]                     invisible(muffled)
[16:04:46.067]                   }
[16:04:46.067]                   muffleCondition(cond)
[16:04:46.067]                 })
[16:04:46.067]             }))
[16:04:46.067]             future::FutureResult(value = ...future.value$value, 
[16:04:46.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.067]                   ...future.rng), globalenv = if (FALSE) 
[16:04:46.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:46.067]                     ...future.globalenv.names))
[16:04:46.067]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:46.067]         }, condition = base::local({
[16:04:46.067]             c <- base::c
[16:04:46.067]             inherits <- base::inherits
[16:04:46.067]             invokeRestart <- base::invokeRestart
[16:04:46.067]             length <- base::length
[16:04:46.067]             list <- base::list
[16:04:46.067]             seq.int <- base::seq.int
[16:04:46.067]             signalCondition <- base::signalCondition
[16:04:46.067]             sys.calls <- base::sys.calls
[16:04:46.067]             `[[` <- base::`[[`
[16:04:46.067]             `+` <- base::`+`
[16:04:46.067]             `<<-` <- base::`<<-`
[16:04:46.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:46.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:46.067]                   3L)]
[16:04:46.067]             }
[16:04:46.067]             function(cond) {
[16:04:46.067]                 is_error <- inherits(cond, "error")
[16:04:46.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:46.067]                   NULL)
[16:04:46.067]                 if (is_error) {
[16:04:46.067]                   sessionInformation <- function() {
[16:04:46.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:46.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:46.067]                       search = base::search(), system = base::Sys.info())
[16:04:46.067]                   }
[16:04:46.067]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:46.067]                     cond$call), session = sessionInformation(), 
[16:04:46.067]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:46.067]                   signalCondition(cond)
[16:04:46.067]                 }
[16:04:46.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:46.067]                 "immediateCondition"))) {
[16:04:46.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:46.067]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:46.067]                   if (TRUE && !signal) {
[16:04:46.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.067]                     {
[16:04:46.067]                       inherits <- base::inherits
[16:04:46.067]                       invokeRestart <- base::invokeRestart
[16:04:46.067]                       is.null <- base::is.null
[16:04:46.067]                       muffled <- FALSE
[16:04:46.067]                       if (inherits(cond, "message")) {
[16:04:46.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.067]                         if (muffled) 
[16:04:46.067]                           invokeRestart("muffleMessage")
[16:04:46.067]                       }
[16:04:46.067]                       else if (inherits(cond, "warning")) {
[16:04:46.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.067]                         if (muffled) 
[16:04:46.067]                           invokeRestart("muffleWarning")
[16:04:46.067]                       }
[16:04:46.067]                       else if (inherits(cond, "condition")) {
[16:04:46.067]                         if (!is.null(pattern)) {
[16:04:46.067]                           computeRestarts <- base::computeRestarts
[16:04:46.067]                           grepl <- base::grepl
[16:04:46.067]                           restarts <- computeRestarts(cond)
[16:04:46.067]                           for (restart in restarts) {
[16:04:46.067]                             name <- restart$name
[16:04:46.067]                             if (is.null(name)) 
[16:04:46.067]                               next
[16:04:46.067]                             if (!grepl(pattern, name)) 
[16:04:46.067]                               next
[16:04:46.067]                             invokeRestart(restart)
[16:04:46.067]                             muffled <- TRUE
[16:04:46.067]                             break
[16:04:46.067]                           }
[16:04:46.067]                         }
[16:04:46.067]                       }
[16:04:46.067]                       invisible(muffled)
[16:04:46.067]                     }
[16:04:46.067]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.067]                   }
[16:04:46.067]                 }
[16:04:46.067]                 else {
[16:04:46.067]                   if (TRUE) {
[16:04:46.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.067]                     {
[16:04:46.067]                       inherits <- base::inherits
[16:04:46.067]                       invokeRestart <- base::invokeRestart
[16:04:46.067]                       is.null <- base::is.null
[16:04:46.067]                       muffled <- FALSE
[16:04:46.067]                       if (inherits(cond, "message")) {
[16:04:46.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.067]                         if (muffled) 
[16:04:46.067]                           invokeRestart("muffleMessage")
[16:04:46.067]                       }
[16:04:46.067]                       else if (inherits(cond, "warning")) {
[16:04:46.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.067]                         if (muffled) 
[16:04:46.067]                           invokeRestart("muffleWarning")
[16:04:46.067]                       }
[16:04:46.067]                       else if (inherits(cond, "condition")) {
[16:04:46.067]                         if (!is.null(pattern)) {
[16:04:46.067]                           computeRestarts <- base::computeRestarts
[16:04:46.067]                           grepl <- base::grepl
[16:04:46.067]                           restarts <- computeRestarts(cond)
[16:04:46.067]                           for (restart in restarts) {
[16:04:46.067]                             name <- restart$name
[16:04:46.067]                             if (is.null(name)) 
[16:04:46.067]                               next
[16:04:46.067]                             if (!grepl(pattern, name)) 
[16:04:46.067]                               next
[16:04:46.067]                             invokeRestart(restart)
[16:04:46.067]                             muffled <- TRUE
[16:04:46.067]                             break
[16:04:46.067]                           }
[16:04:46.067]                         }
[16:04:46.067]                       }
[16:04:46.067]                       invisible(muffled)
[16:04:46.067]                     }
[16:04:46.067]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.067]                   }
[16:04:46.067]                 }
[16:04:46.067]             }
[16:04:46.067]         }))
[16:04:46.067]     }, error = function(ex) {
[16:04:46.067]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:46.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.067]                 ...future.rng), started = ...future.startTime, 
[16:04:46.067]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:46.067]             version = "1.8"), class = "FutureResult")
[16:04:46.067]     }, finally = {
[16:04:46.067]         if (!identical(...future.workdir, getwd())) 
[16:04:46.067]             setwd(...future.workdir)
[16:04:46.067]         {
[16:04:46.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:46.067]                 ...future.oldOptions$nwarnings <- NULL
[16:04:46.067]             }
[16:04:46.067]             base::options(...future.oldOptions)
[16:04:46.067]             if (.Platform$OS.type == "windows") {
[16:04:46.067]                 old_names <- names(...future.oldEnvVars)
[16:04:46.067]                 envs <- base::Sys.getenv()
[16:04:46.067]                 names <- names(envs)
[16:04:46.067]                 common <- intersect(names, old_names)
[16:04:46.067]                 added <- setdiff(names, old_names)
[16:04:46.067]                 removed <- setdiff(old_names, names)
[16:04:46.067]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:46.067]                   envs[common]]
[16:04:46.067]                 NAMES <- toupper(changed)
[16:04:46.067]                 args <- list()
[16:04:46.067]                 for (kk in seq_along(NAMES)) {
[16:04:46.067]                   name <- changed[[kk]]
[16:04:46.067]                   NAME <- NAMES[[kk]]
[16:04:46.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.067]                     next
[16:04:46.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.067]                 }
[16:04:46.067]                 NAMES <- toupper(added)
[16:04:46.067]                 for (kk in seq_along(NAMES)) {
[16:04:46.067]                   name <- added[[kk]]
[16:04:46.067]                   NAME <- NAMES[[kk]]
[16:04:46.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.067]                     next
[16:04:46.067]                   args[[name]] <- ""
[16:04:46.067]                 }
[16:04:46.067]                 NAMES <- toupper(removed)
[16:04:46.067]                 for (kk in seq_along(NAMES)) {
[16:04:46.067]                   name <- removed[[kk]]
[16:04:46.067]                   NAME <- NAMES[[kk]]
[16:04:46.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.067]                     next
[16:04:46.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.067]                 }
[16:04:46.067]                 if (length(args) > 0) 
[16:04:46.067]                   base::do.call(base::Sys.setenv, args = args)
[16:04:46.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:46.067]             }
[16:04:46.067]             else {
[16:04:46.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:46.067]             }
[16:04:46.067]             {
[16:04:46.067]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:46.067]                   0L) {
[16:04:46.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:46.067]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:46.067]                   base::options(opts)
[16:04:46.067]                 }
[16:04:46.067]                 {
[16:04:46.067]                   {
[16:04:46.067]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:46.067]                     NULL
[16:04:46.067]                   }
[16:04:46.067]                   options(future.plan = NULL)
[16:04:46.067]                   if (is.na(NA_character_)) 
[16:04:46.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:46.067]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:46.067]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:46.067]                     envir = parent.frame()) 
[16:04:46.067]                   {
[16:04:46.067]                     if (is.function(workers)) 
[16:04:46.067]                       workers <- workers()
[16:04:46.067]                     workers <- structure(as.integer(workers), 
[16:04:46.067]                       class = class(workers))
[16:04:46.067]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:46.067]                       workers >= 1)
[16:04:46.067]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:46.067]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:46.067]                     }
[16:04:46.067]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:46.067]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:46.067]                       envir = envir)
[16:04:46.067]                     if (!future$lazy) 
[16:04:46.067]                       future <- run(future)
[16:04:46.067]                     invisible(future)
[16:04:46.067]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:46.067]                 }
[16:04:46.067]             }
[16:04:46.067]         }
[16:04:46.067]     })
[16:04:46.067]     if (TRUE) {
[16:04:46.067]         base::sink(type = "output", split = FALSE)
[16:04:46.067]         if (TRUE) {
[16:04:46.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:46.067]         }
[16:04:46.067]         else {
[16:04:46.067]             ...future.result["stdout"] <- base::list(NULL)
[16:04:46.067]         }
[16:04:46.067]         base::close(...future.stdout)
[16:04:46.067]         ...future.stdout <- NULL
[16:04:46.067]     }
[16:04:46.067]     ...future.result$conditions <- ...future.conditions
[16:04:46.067]     ...future.result$finished <- base::Sys.time()
[16:04:46.067]     ...future.result
[16:04:46.067] }
[16:04:46.070] MultisessionFuture started
[16:04:46.070] - Launch lazy future ... done
[16:04:46.070] run() for ‘MultisessionFuture’ ... done
[16:04:46.070] getGlobalsAndPackages() ...
[16:04:46.071] Searching for globals...
[16:04:46.071] - globals found: [1] ‘{’
[16:04:46.071] Searching for globals ... DONE
[16:04:46.071] Resolving globals: FALSE
[16:04:46.072] 
[16:04:46.072] 
[16:04:46.072] getGlobalsAndPackages() ... DONE
[16:04:46.072] run() for ‘Future’ ...
[16:04:46.072] - state: ‘created’
[16:04:46.072] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:46.086] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:46.086] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:46.086]   - Field: ‘node’
[16:04:46.087]   - Field: ‘label’
[16:04:46.087]   - Field: ‘local’
[16:04:46.087]   - Field: ‘owner’
[16:04:46.087]   - Field: ‘envir’
[16:04:46.087]   - Field: ‘workers’
[16:04:46.087]   - Field: ‘packages’
[16:04:46.087]   - Field: ‘gc’
[16:04:46.087]   - Field: ‘conditions’
[16:04:46.087]   - Field: ‘persistent’
[16:04:46.087]   - Field: ‘expr’
[16:04:46.088]   - Field: ‘uuid’
[16:04:46.088]   - Field: ‘seed’
[16:04:46.088]   - Field: ‘version’
[16:04:46.088]   - Field: ‘result’
[16:04:46.088]   - Field: ‘asynchronous’
[16:04:46.088]   - Field: ‘calls’
[16:04:46.088]   - Field: ‘globals’
[16:04:46.088]   - Field: ‘stdout’
[16:04:46.088]   - Field: ‘earlySignal’
[16:04:46.088]   - Field: ‘lazy’
[16:04:46.088]   - Field: ‘state’
[16:04:46.089] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:46.089] - Launch lazy future ...
[16:04:46.089] Packages needed by the future expression (n = 0): <none>
[16:04:46.089] Packages needed by future strategies (n = 0): <none>
[16:04:46.089] {
[16:04:46.089]     {
[16:04:46.089]         {
[16:04:46.089]             ...future.startTime <- base::Sys.time()
[16:04:46.089]             {
[16:04:46.089]                 {
[16:04:46.089]                   {
[16:04:46.089]                     {
[16:04:46.089]                       base::local({
[16:04:46.089]                         has_future <- base::requireNamespace("future", 
[16:04:46.089]                           quietly = TRUE)
[16:04:46.089]                         if (has_future) {
[16:04:46.089]                           ns <- base::getNamespace("future")
[16:04:46.089]                           version <- ns[[".package"]][["version"]]
[16:04:46.089]                           if (is.null(version)) 
[16:04:46.089]                             version <- utils::packageVersion("future")
[16:04:46.089]                         }
[16:04:46.089]                         else {
[16:04:46.089]                           version <- NULL
[16:04:46.089]                         }
[16:04:46.089]                         if (!has_future || version < "1.8.0") {
[16:04:46.089]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:46.089]                             "", base::R.version$version.string), 
[16:04:46.089]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:46.089]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:46.089]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:46.089]                               "release", "version")], collapse = " "), 
[16:04:46.089]                             hostname = base::Sys.info()[["nodename"]])
[16:04:46.089]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:46.089]                             info)
[16:04:46.089]                           info <- base::paste(info, collapse = "; ")
[16:04:46.089]                           if (!has_future) {
[16:04:46.089]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:46.089]                               info)
[16:04:46.089]                           }
[16:04:46.089]                           else {
[16:04:46.089]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:46.089]                               info, version)
[16:04:46.089]                           }
[16:04:46.089]                           base::stop(msg)
[16:04:46.089]                         }
[16:04:46.089]                       })
[16:04:46.089]                     }
[16:04:46.089]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:46.089]                     base::options(mc.cores = 1L)
[16:04:46.089]                   }
[16:04:46.089]                   options(future.plan = NULL)
[16:04:46.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:46.089]                 }
[16:04:46.089]                 ...future.workdir <- getwd()
[16:04:46.089]             }
[16:04:46.089]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:46.089]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:46.089]         }
[16:04:46.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:46.089]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:46.089]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:46.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:46.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:46.089]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:46.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:46.089]             base::names(...future.oldOptions))
[16:04:46.089]     }
[16:04:46.089]     if (FALSE) {
[16:04:46.089]     }
[16:04:46.089]     else {
[16:04:46.089]         if (TRUE) {
[16:04:46.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:46.089]                 open = "w")
[16:04:46.089]         }
[16:04:46.089]         else {
[16:04:46.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:46.089]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:46.089]         }
[16:04:46.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:46.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:46.089]             base::sink(type = "output", split = FALSE)
[16:04:46.089]             base::close(...future.stdout)
[16:04:46.089]         }, add = TRUE)
[16:04:46.089]     }
[16:04:46.089]     ...future.frame <- base::sys.nframe()
[16:04:46.089]     ...future.conditions <- base::list()
[16:04:46.089]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:46.089]     if (FALSE) {
[16:04:46.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:46.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:46.089]     }
[16:04:46.089]     ...future.result <- base::tryCatch({
[16:04:46.089]         base::withCallingHandlers({
[16:04:46.089]             ...future.value <- base::withVisible(base::local({
[16:04:46.089]                 ...future.makeSendCondition <- base::local({
[16:04:46.089]                   sendCondition <- NULL
[16:04:46.089]                   function(frame = 1L) {
[16:04:46.089]                     if (is.function(sendCondition)) 
[16:04:46.089]                       return(sendCondition)
[16:04:46.089]                     ns <- getNamespace("parallel")
[16:04:46.089]                     if (exists("sendData", mode = "function", 
[16:04:46.089]                       envir = ns)) {
[16:04:46.089]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:46.089]                         envir = ns)
[16:04:46.089]                       envir <- sys.frame(frame)
[16:04:46.089]                       master <- NULL
[16:04:46.089]                       while (!identical(envir, .GlobalEnv) && 
[16:04:46.089]                         !identical(envir, emptyenv())) {
[16:04:46.089]                         if (exists("master", mode = "list", envir = envir, 
[16:04:46.089]                           inherits = FALSE)) {
[16:04:46.089]                           master <- get("master", mode = "list", 
[16:04:46.089]                             envir = envir, inherits = FALSE)
[16:04:46.089]                           if (inherits(master, c("SOCKnode", 
[16:04:46.089]                             "SOCK0node"))) {
[16:04:46.089]                             sendCondition <<- function(cond) {
[16:04:46.089]                               data <- list(type = "VALUE", value = cond, 
[16:04:46.089]                                 success = TRUE)
[16:04:46.089]                               parallel_sendData(master, data)
[16:04:46.089]                             }
[16:04:46.089]                             return(sendCondition)
[16:04:46.089]                           }
[16:04:46.089]                         }
[16:04:46.089]                         frame <- frame + 1L
[16:04:46.089]                         envir <- sys.frame(frame)
[16:04:46.089]                       }
[16:04:46.089]                     }
[16:04:46.089]                     sendCondition <<- function(cond) NULL
[16:04:46.089]                   }
[16:04:46.089]                 })
[16:04:46.089]                 withCallingHandlers({
[16:04:46.089]                   {
[16:04:46.089]                     4
[16:04:46.089]                   }
[16:04:46.089]                 }, immediateCondition = function(cond) {
[16:04:46.089]                   sendCondition <- ...future.makeSendCondition()
[16:04:46.089]                   sendCondition(cond)
[16:04:46.089]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.089]                   {
[16:04:46.089]                     inherits <- base::inherits
[16:04:46.089]                     invokeRestart <- base::invokeRestart
[16:04:46.089]                     is.null <- base::is.null
[16:04:46.089]                     muffled <- FALSE
[16:04:46.089]                     if (inherits(cond, "message")) {
[16:04:46.089]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:46.089]                       if (muffled) 
[16:04:46.089]                         invokeRestart("muffleMessage")
[16:04:46.089]                     }
[16:04:46.089]                     else if (inherits(cond, "warning")) {
[16:04:46.089]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:46.089]                       if (muffled) 
[16:04:46.089]                         invokeRestart("muffleWarning")
[16:04:46.089]                     }
[16:04:46.089]                     else if (inherits(cond, "condition")) {
[16:04:46.089]                       if (!is.null(pattern)) {
[16:04:46.089]                         computeRestarts <- base::computeRestarts
[16:04:46.089]                         grepl <- base::grepl
[16:04:46.089]                         restarts <- computeRestarts(cond)
[16:04:46.089]                         for (restart in restarts) {
[16:04:46.089]                           name <- restart$name
[16:04:46.089]                           if (is.null(name)) 
[16:04:46.089]                             next
[16:04:46.089]                           if (!grepl(pattern, name)) 
[16:04:46.089]                             next
[16:04:46.089]                           invokeRestart(restart)
[16:04:46.089]                           muffled <- TRUE
[16:04:46.089]                           break
[16:04:46.089]                         }
[16:04:46.089]                       }
[16:04:46.089]                     }
[16:04:46.089]                     invisible(muffled)
[16:04:46.089]                   }
[16:04:46.089]                   muffleCondition(cond)
[16:04:46.089]                 })
[16:04:46.089]             }))
[16:04:46.089]             future::FutureResult(value = ...future.value$value, 
[16:04:46.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.089]                   ...future.rng), globalenv = if (FALSE) 
[16:04:46.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:46.089]                     ...future.globalenv.names))
[16:04:46.089]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:46.089]         }, condition = base::local({
[16:04:46.089]             c <- base::c
[16:04:46.089]             inherits <- base::inherits
[16:04:46.089]             invokeRestart <- base::invokeRestart
[16:04:46.089]             length <- base::length
[16:04:46.089]             list <- base::list
[16:04:46.089]             seq.int <- base::seq.int
[16:04:46.089]             signalCondition <- base::signalCondition
[16:04:46.089]             sys.calls <- base::sys.calls
[16:04:46.089]             `[[` <- base::`[[`
[16:04:46.089]             `+` <- base::`+`
[16:04:46.089]             `<<-` <- base::`<<-`
[16:04:46.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:46.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:46.089]                   3L)]
[16:04:46.089]             }
[16:04:46.089]             function(cond) {
[16:04:46.089]                 is_error <- inherits(cond, "error")
[16:04:46.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:46.089]                   NULL)
[16:04:46.089]                 if (is_error) {
[16:04:46.089]                   sessionInformation <- function() {
[16:04:46.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:46.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:46.089]                       search = base::search(), system = base::Sys.info())
[16:04:46.089]                   }
[16:04:46.089]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:46.089]                     cond$call), session = sessionInformation(), 
[16:04:46.089]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:46.089]                   signalCondition(cond)
[16:04:46.089]                 }
[16:04:46.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:46.089]                 "immediateCondition"))) {
[16:04:46.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:46.089]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:46.089]                   if (TRUE && !signal) {
[16:04:46.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.089]                     {
[16:04:46.089]                       inherits <- base::inherits
[16:04:46.089]                       invokeRestart <- base::invokeRestart
[16:04:46.089]                       is.null <- base::is.null
[16:04:46.089]                       muffled <- FALSE
[16:04:46.089]                       if (inherits(cond, "message")) {
[16:04:46.089]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.089]                         if (muffled) 
[16:04:46.089]                           invokeRestart("muffleMessage")
[16:04:46.089]                       }
[16:04:46.089]                       else if (inherits(cond, "warning")) {
[16:04:46.089]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.089]                         if (muffled) 
[16:04:46.089]                           invokeRestart("muffleWarning")
[16:04:46.089]                       }
[16:04:46.089]                       else if (inherits(cond, "condition")) {
[16:04:46.089]                         if (!is.null(pattern)) {
[16:04:46.089]                           computeRestarts <- base::computeRestarts
[16:04:46.089]                           grepl <- base::grepl
[16:04:46.089]                           restarts <- computeRestarts(cond)
[16:04:46.089]                           for (restart in restarts) {
[16:04:46.089]                             name <- restart$name
[16:04:46.089]                             if (is.null(name)) 
[16:04:46.089]                               next
[16:04:46.089]                             if (!grepl(pattern, name)) 
[16:04:46.089]                               next
[16:04:46.089]                             invokeRestart(restart)
[16:04:46.089]                             muffled <- TRUE
[16:04:46.089]                             break
[16:04:46.089]                           }
[16:04:46.089]                         }
[16:04:46.089]                       }
[16:04:46.089]                       invisible(muffled)
[16:04:46.089]                     }
[16:04:46.089]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.089]                   }
[16:04:46.089]                 }
[16:04:46.089]                 else {
[16:04:46.089]                   if (TRUE) {
[16:04:46.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.089]                     {
[16:04:46.089]                       inherits <- base::inherits
[16:04:46.089]                       invokeRestart <- base::invokeRestart
[16:04:46.089]                       is.null <- base::is.null
[16:04:46.089]                       muffled <- FALSE
[16:04:46.089]                       if (inherits(cond, "message")) {
[16:04:46.089]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.089]                         if (muffled) 
[16:04:46.089]                           invokeRestart("muffleMessage")
[16:04:46.089]                       }
[16:04:46.089]                       else if (inherits(cond, "warning")) {
[16:04:46.089]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.089]                         if (muffled) 
[16:04:46.089]                           invokeRestart("muffleWarning")
[16:04:46.089]                       }
[16:04:46.089]                       else if (inherits(cond, "condition")) {
[16:04:46.089]                         if (!is.null(pattern)) {
[16:04:46.089]                           computeRestarts <- base::computeRestarts
[16:04:46.089]                           grepl <- base::grepl
[16:04:46.089]                           restarts <- computeRestarts(cond)
[16:04:46.089]                           for (restart in restarts) {
[16:04:46.089]                             name <- restart$name
[16:04:46.089]                             if (is.null(name)) 
[16:04:46.089]                               next
[16:04:46.089]                             if (!grepl(pattern, name)) 
[16:04:46.089]                               next
[16:04:46.089]                             invokeRestart(restart)
[16:04:46.089]                             muffled <- TRUE
[16:04:46.089]                             break
[16:04:46.089]                           }
[16:04:46.089]                         }
[16:04:46.089]                       }
[16:04:46.089]                       invisible(muffled)
[16:04:46.089]                     }
[16:04:46.089]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.089]                   }
[16:04:46.089]                 }
[16:04:46.089]             }
[16:04:46.089]         }))
[16:04:46.089]     }, error = function(ex) {
[16:04:46.089]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:46.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.089]                 ...future.rng), started = ...future.startTime, 
[16:04:46.089]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:46.089]             version = "1.8"), class = "FutureResult")
[16:04:46.089]     }, finally = {
[16:04:46.089]         if (!identical(...future.workdir, getwd())) 
[16:04:46.089]             setwd(...future.workdir)
[16:04:46.089]         {
[16:04:46.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:46.089]                 ...future.oldOptions$nwarnings <- NULL
[16:04:46.089]             }
[16:04:46.089]             base::options(...future.oldOptions)
[16:04:46.089]             if (.Platform$OS.type == "windows") {
[16:04:46.089]                 old_names <- names(...future.oldEnvVars)
[16:04:46.089]                 envs <- base::Sys.getenv()
[16:04:46.089]                 names <- names(envs)
[16:04:46.089]                 common <- intersect(names, old_names)
[16:04:46.089]                 added <- setdiff(names, old_names)
[16:04:46.089]                 removed <- setdiff(old_names, names)
[16:04:46.089]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:46.089]                   envs[common]]
[16:04:46.089]                 NAMES <- toupper(changed)
[16:04:46.089]                 args <- list()
[16:04:46.089]                 for (kk in seq_along(NAMES)) {
[16:04:46.089]                   name <- changed[[kk]]
[16:04:46.089]                   NAME <- NAMES[[kk]]
[16:04:46.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.089]                     next
[16:04:46.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.089]                 }
[16:04:46.089]                 NAMES <- toupper(added)
[16:04:46.089]                 for (kk in seq_along(NAMES)) {
[16:04:46.089]                   name <- added[[kk]]
[16:04:46.089]                   NAME <- NAMES[[kk]]
[16:04:46.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.089]                     next
[16:04:46.089]                   args[[name]] <- ""
[16:04:46.089]                 }
[16:04:46.089]                 NAMES <- toupper(removed)
[16:04:46.089]                 for (kk in seq_along(NAMES)) {
[16:04:46.089]                   name <- removed[[kk]]
[16:04:46.089]                   NAME <- NAMES[[kk]]
[16:04:46.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.089]                     next
[16:04:46.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.089]                 }
[16:04:46.089]                 if (length(args) > 0) 
[16:04:46.089]                   base::do.call(base::Sys.setenv, args = args)
[16:04:46.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:46.089]             }
[16:04:46.089]             else {
[16:04:46.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:46.089]             }
[16:04:46.089]             {
[16:04:46.089]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:46.089]                   0L) {
[16:04:46.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:46.089]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:46.089]                   base::options(opts)
[16:04:46.089]                 }
[16:04:46.089]                 {
[16:04:46.089]                   {
[16:04:46.089]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:46.089]                     NULL
[16:04:46.089]                   }
[16:04:46.089]                   options(future.plan = NULL)
[16:04:46.089]                   if (is.na(NA_character_)) 
[16:04:46.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:46.089]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:46.089]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:46.089]                     envir = parent.frame()) 
[16:04:46.089]                   {
[16:04:46.089]                     if (is.function(workers)) 
[16:04:46.089]                       workers <- workers()
[16:04:46.089]                     workers <- structure(as.integer(workers), 
[16:04:46.089]                       class = class(workers))
[16:04:46.089]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:46.089]                       workers >= 1)
[16:04:46.089]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:46.089]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:46.089]                     }
[16:04:46.089]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:46.089]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:46.089]                       envir = envir)
[16:04:46.089]                     if (!future$lazy) 
[16:04:46.089]                       future <- run(future)
[16:04:46.089]                     invisible(future)
[16:04:46.089]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:46.089]                 }
[16:04:46.089]             }
[16:04:46.089]         }
[16:04:46.089]     })
[16:04:46.089]     if (TRUE) {
[16:04:46.089]         base::sink(type = "output", split = FALSE)
[16:04:46.089]         if (TRUE) {
[16:04:46.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:46.089]         }
[16:04:46.089]         else {
[16:04:46.089]             ...future.result["stdout"] <- base::list(NULL)
[16:04:46.089]         }
[16:04:46.089]         base::close(...future.stdout)
[16:04:46.089]         ...future.stdout <- NULL
[16:04:46.089]     }
[16:04:46.089]     ...future.result$conditions <- ...future.conditions
[16:04:46.089]     ...future.result$finished <- base::Sys.time()
[16:04:46.089]     ...future.result
[16:04:46.089] }
[16:04:46.092] Poll #1 (0): usedNodes() = 2, workers = 2
[16:04:46.102] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.103] - Validating connection of MultisessionFuture
[16:04:46.103] - received message: FutureResult
[16:04:46.103] - Received FutureResult
[16:04:46.103] - Erased future from FutureRegistry
[16:04:46.103] result() for ClusterFuture ...
[16:04:46.103] - result already collected: FutureResult
[16:04:46.103] result() for ClusterFuture ... done
[16:04:46.103] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:46.103] result() for ClusterFuture ...
[16:04:46.104] - result already collected: FutureResult
[16:04:46.104] result() for ClusterFuture ... done
[16:04:46.104] result() for ClusterFuture ...
[16:04:46.104] - result already collected: FutureResult
[16:04:46.104] result() for ClusterFuture ... done
[16:04:46.105] MultisessionFuture started
[16:04:46.105] - Launch lazy future ... done
[16:04:46.105] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55874f56ada8> 
Classes 'listenv', 'environment' <environment: 0x55874da1b558> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:04:46.116] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.116] - Validating connection of MultisessionFuture
[16:04:46.116] - received message: FutureResult
[16:04:46.116] - Received FutureResult
[16:04:46.116] - Erased future from FutureRegistry
[16:04:46.116] result() for ClusterFuture ...
[16:04:46.116] - result already collected: FutureResult
[16:04:46.116] result() for ClusterFuture ... done
[16:04:46.116] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:46.129] resolve() on list environment ...
[16:04:46.129]  recursive: 0
[16:04:46.130]  length: 6
[16:04:46.131]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:46.131] signalConditionsASAP(numeric, pos=1) ...
[16:04:46.131] - nx: 6
[16:04:46.131] - relay: TRUE
[16:04:46.131] - stdout: TRUE
[16:04:46.131] - signal: TRUE
[16:04:46.131] - resignal: FALSE
[16:04:46.131] - force: TRUE
[16:04:46.131] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.131] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.131]  - until=2
[16:04:46.132]  - relaying element #2
[16:04:46.132] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.132] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.132] signalConditionsASAP(NULL, pos=1) ... done
[16:04:46.132]  length: 5 (resolved future 1)
[16:04:46.132] Future #2
[16:04:46.132] result() for ClusterFuture ...
[16:04:46.132] - result already collected: FutureResult
[16:04:46.132] result() for ClusterFuture ... done
[16:04:46.132] result() for ClusterFuture ...
[16:04:46.133] - result already collected: FutureResult
[16:04:46.133] result() for ClusterFuture ... done
[16:04:46.133] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:46.133] - nx: 6
[16:04:46.133] - relay: TRUE
[16:04:46.133] - stdout: TRUE
[16:04:46.133] - signal: TRUE
[16:04:46.133] - resignal: FALSE
[16:04:46.133] - force: TRUE
[16:04:46.133] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.133] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.133]  - until=2
[16:04:46.134]  - relaying element #2
[16:04:46.134] result() for ClusterFuture ...
[16:04:46.134] - result already collected: FutureResult
[16:04:46.134] result() for ClusterFuture ... done
[16:04:46.134] result() for ClusterFuture ...
[16:04:46.134] - result already collected: FutureResult
[16:04:46.134] result() for ClusterFuture ... done
[16:04:46.134] result() for ClusterFuture ...
[16:04:46.134] - result already collected: FutureResult
[16:04:46.134] result() for ClusterFuture ... done
[16:04:46.134] result() for ClusterFuture ...
[16:04:46.135] - result already collected: FutureResult
[16:04:46.135] result() for ClusterFuture ... done
[16:04:46.135] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.135] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.135] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:46.135]  length: 4 (resolved future 2)
[16:04:46.135] Future #3
[16:04:46.135] result() for ClusterFuture ...
[16:04:46.135] - result already collected: FutureResult
[16:04:46.135] result() for ClusterFuture ... done
[16:04:46.136] result() for ClusterFuture ...
[16:04:46.136] - result already collected: FutureResult
[16:04:46.136] result() for ClusterFuture ... done
[16:04:46.136] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:46.136] - nx: 6
[16:04:46.136] - relay: TRUE
[16:04:46.136] - stdout: TRUE
[16:04:46.136] - signal: TRUE
[16:04:46.136] - resignal: FALSE
[16:04:46.136] - force: TRUE
[16:04:46.136] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.136] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.137]  - until=3
[16:04:46.137]  - relaying element #3
[16:04:46.137] result() for ClusterFuture ...
[16:04:46.137] - result already collected: FutureResult
[16:04:46.137] result() for ClusterFuture ... done
[16:04:46.137] result() for ClusterFuture ...
[16:04:46.137] - result already collected: FutureResult
[16:04:46.137] result() for ClusterFuture ... done
[16:04:46.137] result() for ClusterFuture ...
[16:04:46.137] - result already collected: FutureResult
[16:04:46.137] result() for ClusterFuture ... done
[16:04:46.138] result() for ClusterFuture ...
[16:04:46.138] - result already collected: FutureResult
[16:04:46.138] result() for ClusterFuture ... done
[16:04:46.138] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.138] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.138] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:46.138]  length: 3 (resolved future 3)
[16:04:46.149] signalConditionsASAP(NULL, pos=5) ...
[16:04:46.149] - nx: 6
[16:04:46.149] - relay: TRUE
[16:04:46.149] - stdout: TRUE
[16:04:46.149] - signal: TRUE
[16:04:46.149] - resignal: FALSE
[16:04:46.149] - force: TRUE
[16:04:46.149] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.149] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.149]  - until=6
[16:04:46.150]  - relaying element #4
[16:04:46.150]  - relaying element #6
[16:04:46.150] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:04:46.150] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.150] signalConditionsASAP(NULL, pos=5) ... done
[16:04:46.150]  length: 2 (resolved future 5)
[16:04:46.150] signalConditionsASAP(numeric, pos=6) ...
[16:04:46.150] - nx: 6
[16:04:46.150] - relay: TRUE
[16:04:46.150] - stdout: TRUE
[16:04:46.150] - signal: TRUE
[16:04:46.151] - resignal: FALSE
[16:04:46.151] - force: TRUE
[16:04:46.151] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:04:46.151] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.151]  - until=6
[16:04:46.151]  - relaying element #4
[16:04:46.151] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:04:46.151] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.151] signalConditionsASAP(NULL, pos=6) ... done
[16:04:46.151]  length: 1 (resolved future 6)
[16:04:46.162] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.162] - Validating connection of MultisessionFuture
[16:04:46.162] - received message: FutureResult
[16:04:46.163] - Received FutureResult
[16:04:46.163] - Erased future from FutureRegistry
[16:04:46.163] result() for ClusterFuture ...
[16:04:46.163] - result already collected: FutureResult
[16:04:46.163] result() for ClusterFuture ... done
[16:04:46.163] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:46.163] Future #4
[16:04:46.163] result() for ClusterFuture ...
[16:04:46.163] - result already collected: FutureResult
[16:04:46.163] result() for ClusterFuture ... done
[16:04:46.164] result() for ClusterFuture ...
[16:04:46.164] - result already collected: FutureResult
[16:04:46.164] result() for ClusterFuture ... done
[16:04:46.164] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:04:46.164] - nx: 6
[16:04:46.164] - relay: TRUE
[16:04:46.164] - stdout: TRUE
[16:04:46.164] - signal: TRUE
[16:04:46.164] - resignal: FALSE
[16:04:46.164] - force: TRUE
[16:04:46.164] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:04:46.164] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.165]  - until=6
[16:04:46.165]  - relaying element #4
[16:04:46.165] result() for ClusterFuture ...
[16:04:46.165] - result already collected: FutureResult
[16:04:46.165] result() for ClusterFuture ... done
[16:04:46.165] result() for ClusterFuture ...
[16:04:46.165] - result already collected: FutureResult
[16:04:46.165] result() for ClusterFuture ... done
[16:04:46.165] result() for ClusterFuture ...
[16:04:46.165] - result already collected: FutureResult
[16:04:46.165] result() for ClusterFuture ... done
[16:04:46.165] result() for ClusterFuture ...
[16:04:46.166] - result already collected: FutureResult
[16:04:46.166] result() for ClusterFuture ... done
[16:04:46.166] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.166] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.166] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:04:46.166]  length: 0 (resolved future 4)
[16:04:46.166] Relaying remaining futures
[16:04:46.166] signalConditionsASAP(NULL, pos=0) ...
[16:04:46.166] - nx: 6
[16:04:46.166] - relay: TRUE
[16:04:46.166] - stdout: TRUE
[16:04:46.167] - signal: TRUE
[16:04:46.167] - resignal: FALSE
[16:04:46.167] - force: TRUE
[16:04:46.167] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.167] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:46.167] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.167] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.167] signalConditionsASAP(NULL, pos=0) ... done
[16:04:46.167] resolve() on list environment ... DONE
[16:04:46.167] result() for ClusterFuture ...
[16:04:46.168] - result already collected: FutureResult
[16:04:46.168] result() for ClusterFuture ... done
[16:04:46.168] result() for ClusterFuture ...
[16:04:46.168] - result already collected: FutureResult
[16:04:46.168] result() for ClusterFuture ... done
[16:04:46.168] result() for ClusterFuture ...
[16:04:46.168] - result already collected: FutureResult
[16:04:46.168] result() for ClusterFuture ... done
[16:04:46.168] result() for ClusterFuture ...
[16:04:46.168] - result already collected: FutureResult
[16:04:46.168] result() for ClusterFuture ... done
[16:04:46.169] result() for ClusterFuture ...
[16:04:46.169] - result already collected: FutureResult
[16:04:46.169] result() for ClusterFuture ... done
[16:04:46.169] result() for ClusterFuture ...
[16:04:46.169] - result already collected: FutureResult
[16:04:46.169] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55874bc31020> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:04:46.171] getGlobalsAndPackages() ...
[16:04:46.171] Searching for globals...
[16:04:46.171] 
[16:04:46.171] Searching for globals ... DONE
[16:04:46.171] - globals: [0] <none>
[16:04:46.171] getGlobalsAndPackages() ... DONE
[16:04:46.172] run() for ‘Future’ ...
[16:04:46.172] - state: ‘created’
[16:04:46.172] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:46.186] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:46.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:46.186]   - Field: ‘node’
[16:04:46.186]   - Field: ‘label’
[16:04:46.186]   - Field: ‘local’
[16:04:46.186]   - Field: ‘owner’
[16:04:46.186]   - Field: ‘envir’
[16:04:46.186]   - Field: ‘workers’
[16:04:46.186]   - Field: ‘packages’
[16:04:46.186]   - Field: ‘gc’
[16:04:46.187]   - Field: ‘conditions’
[16:04:46.187]   - Field: ‘persistent’
[16:04:46.187]   - Field: ‘expr’
[16:04:46.187]   - Field: ‘uuid’
[16:04:46.187]   - Field: ‘seed’
[16:04:46.187]   - Field: ‘version’
[16:04:46.187]   - Field: ‘result’
[16:04:46.187]   - Field: ‘asynchronous’
[16:04:46.187]   - Field: ‘calls’
[16:04:46.187]   - Field: ‘globals’
[16:04:46.187]   - Field: ‘stdout’
[16:04:46.188]   - Field: ‘earlySignal’
[16:04:46.188]   - Field: ‘lazy’
[16:04:46.188]   - Field: ‘state’
[16:04:46.188] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:46.188] - Launch lazy future ...
[16:04:46.188] Packages needed by the future expression (n = 0): <none>
[16:04:46.188] Packages needed by future strategies (n = 0): <none>
[16:04:46.189] {
[16:04:46.189]     {
[16:04:46.189]         {
[16:04:46.189]             ...future.startTime <- base::Sys.time()
[16:04:46.189]             {
[16:04:46.189]                 {
[16:04:46.189]                   {
[16:04:46.189]                     {
[16:04:46.189]                       base::local({
[16:04:46.189]                         has_future <- base::requireNamespace("future", 
[16:04:46.189]                           quietly = TRUE)
[16:04:46.189]                         if (has_future) {
[16:04:46.189]                           ns <- base::getNamespace("future")
[16:04:46.189]                           version <- ns[[".package"]][["version"]]
[16:04:46.189]                           if (is.null(version)) 
[16:04:46.189]                             version <- utils::packageVersion("future")
[16:04:46.189]                         }
[16:04:46.189]                         else {
[16:04:46.189]                           version <- NULL
[16:04:46.189]                         }
[16:04:46.189]                         if (!has_future || version < "1.8.0") {
[16:04:46.189]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:46.189]                             "", base::R.version$version.string), 
[16:04:46.189]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:46.189]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:46.189]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:46.189]                               "release", "version")], collapse = " "), 
[16:04:46.189]                             hostname = base::Sys.info()[["nodename"]])
[16:04:46.189]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:46.189]                             info)
[16:04:46.189]                           info <- base::paste(info, collapse = "; ")
[16:04:46.189]                           if (!has_future) {
[16:04:46.189]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:46.189]                               info)
[16:04:46.189]                           }
[16:04:46.189]                           else {
[16:04:46.189]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:46.189]                               info, version)
[16:04:46.189]                           }
[16:04:46.189]                           base::stop(msg)
[16:04:46.189]                         }
[16:04:46.189]                       })
[16:04:46.189]                     }
[16:04:46.189]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:46.189]                     base::options(mc.cores = 1L)
[16:04:46.189]                   }
[16:04:46.189]                   options(future.plan = NULL)
[16:04:46.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:46.189]                 }
[16:04:46.189]                 ...future.workdir <- getwd()
[16:04:46.189]             }
[16:04:46.189]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:46.189]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:46.189]         }
[16:04:46.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:46.189]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:46.189]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:46.189]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:46.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:46.189]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:46.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:46.189]             base::names(...future.oldOptions))
[16:04:46.189]     }
[16:04:46.189]     if (FALSE) {
[16:04:46.189]     }
[16:04:46.189]     else {
[16:04:46.189]         if (TRUE) {
[16:04:46.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:46.189]                 open = "w")
[16:04:46.189]         }
[16:04:46.189]         else {
[16:04:46.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:46.189]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:46.189]         }
[16:04:46.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:46.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:46.189]             base::sink(type = "output", split = FALSE)
[16:04:46.189]             base::close(...future.stdout)
[16:04:46.189]         }, add = TRUE)
[16:04:46.189]     }
[16:04:46.189]     ...future.frame <- base::sys.nframe()
[16:04:46.189]     ...future.conditions <- base::list()
[16:04:46.189]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:46.189]     if (FALSE) {
[16:04:46.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:46.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:46.189]     }
[16:04:46.189]     ...future.result <- base::tryCatch({
[16:04:46.189]         base::withCallingHandlers({
[16:04:46.189]             ...future.value <- base::withVisible(base::local({
[16:04:46.189]                 ...future.makeSendCondition <- base::local({
[16:04:46.189]                   sendCondition <- NULL
[16:04:46.189]                   function(frame = 1L) {
[16:04:46.189]                     if (is.function(sendCondition)) 
[16:04:46.189]                       return(sendCondition)
[16:04:46.189]                     ns <- getNamespace("parallel")
[16:04:46.189]                     if (exists("sendData", mode = "function", 
[16:04:46.189]                       envir = ns)) {
[16:04:46.189]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:46.189]                         envir = ns)
[16:04:46.189]                       envir <- sys.frame(frame)
[16:04:46.189]                       master <- NULL
[16:04:46.189]                       while (!identical(envir, .GlobalEnv) && 
[16:04:46.189]                         !identical(envir, emptyenv())) {
[16:04:46.189]                         if (exists("master", mode = "list", envir = envir, 
[16:04:46.189]                           inherits = FALSE)) {
[16:04:46.189]                           master <- get("master", mode = "list", 
[16:04:46.189]                             envir = envir, inherits = FALSE)
[16:04:46.189]                           if (inherits(master, c("SOCKnode", 
[16:04:46.189]                             "SOCK0node"))) {
[16:04:46.189]                             sendCondition <<- function(cond) {
[16:04:46.189]                               data <- list(type = "VALUE", value = cond, 
[16:04:46.189]                                 success = TRUE)
[16:04:46.189]                               parallel_sendData(master, data)
[16:04:46.189]                             }
[16:04:46.189]                             return(sendCondition)
[16:04:46.189]                           }
[16:04:46.189]                         }
[16:04:46.189]                         frame <- frame + 1L
[16:04:46.189]                         envir <- sys.frame(frame)
[16:04:46.189]                       }
[16:04:46.189]                     }
[16:04:46.189]                     sendCondition <<- function(cond) NULL
[16:04:46.189]                   }
[16:04:46.189]                 })
[16:04:46.189]                 withCallingHandlers({
[16:04:46.189]                   2
[16:04:46.189]                 }, immediateCondition = function(cond) {
[16:04:46.189]                   sendCondition <- ...future.makeSendCondition()
[16:04:46.189]                   sendCondition(cond)
[16:04:46.189]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.189]                   {
[16:04:46.189]                     inherits <- base::inherits
[16:04:46.189]                     invokeRestart <- base::invokeRestart
[16:04:46.189]                     is.null <- base::is.null
[16:04:46.189]                     muffled <- FALSE
[16:04:46.189]                     if (inherits(cond, "message")) {
[16:04:46.189]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:46.189]                       if (muffled) 
[16:04:46.189]                         invokeRestart("muffleMessage")
[16:04:46.189]                     }
[16:04:46.189]                     else if (inherits(cond, "warning")) {
[16:04:46.189]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:46.189]                       if (muffled) 
[16:04:46.189]                         invokeRestart("muffleWarning")
[16:04:46.189]                     }
[16:04:46.189]                     else if (inherits(cond, "condition")) {
[16:04:46.189]                       if (!is.null(pattern)) {
[16:04:46.189]                         computeRestarts <- base::computeRestarts
[16:04:46.189]                         grepl <- base::grepl
[16:04:46.189]                         restarts <- computeRestarts(cond)
[16:04:46.189]                         for (restart in restarts) {
[16:04:46.189]                           name <- restart$name
[16:04:46.189]                           if (is.null(name)) 
[16:04:46.189]                             next
[16:04:46.189]                           if (!grepl(pattern, name)) 
[16:04:46.189]                             next
[16:04:46.189]                           invokeRestart(restart)
[16:04:46.189]                           muffled <- TRUE
[16:04:46.189]                           break
[16:04:46.189]                         }
[16:04:46.189]                       }
[16:04:46.189]                     }
[16:04:46.189]                     invisible(muffled)
[16:04:46.189]                   }
[16:04:46.189]                   muffleCondition(cond)
[16:04:46.189]                 })
[16:04:46.189]             }))
[16:04:46.189]             future::FutureResult(value = ...future.value$value, 
[16:04:46.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.189]                   ...future.rng), globalenv = if (FALSE) 
[16:04:46.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:46.189]                     ...future.globalenv.names))
[16:04:46.189]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:46.189]         }, condition = base::local({
[16:04:46.189]             c <- base::c
[16:04:46.189]             inherits <- base::inherits
[16:04:46.189]             invokeRestart <- base::invokeRestart
[16:04:46.189]             length <- base::length
[16:04:46.189]             list <- base::list
[16:04:46.189]             seq.int <- base::seq.int
[16:04:46.189]             signalCondition <- base::signalCondition
[16:04:46.189]             sys.calls <- base::sys.calls
[16:04:46.189]             `[[` <- base::`[[`
[16:04:46.189]             `+` <- base::`+`
[16:04:46.189]             `<<-` <- base::`<<-`
[16:04:46.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:46.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:46.189]                   3L)]
[16:04:46.189]             }
[16:04:46.189]             function(cond) {
[16:04:46.189]                 is_error <- inherits(cond, "error")
[16:04:46.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:46.189]                   NULL)
[16:04:46.189]                 if (is_error) {
[16:04:46.189]                   sessionInformation <- function() {
[16:04:46.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:46.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:46.189]                       search = base::search(), system = base::Sys.info())
[16:04:46.189]                   }
[16:04:46.189]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:46.189]                     cond$call), session = sessionInformation(), 
[16:04:46.189]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:46.189]                   signalCondition(cond)
[16:04:46.189]                 }
[16:04:46.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:46.189]                 "immediateCondition"))) {
[16:04:46.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:46.189]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:46.189]                   if (TRUE && !signal) {
[16:04:46.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.189]                     {
[16:04:46.189]                       inherits <- base::inherits
[16:04:46.189]                       invokeRestart <- base::invokeRestart
[16:04:46.189]                       is.null <- base::is.null
[16:04:46.189]                       muffled <- FALSE
[16:04:46.189]                       if (inherits(cond, "message")) {
[16:04:46.189]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.189]                         if (muffled) 
[16:04:46.189]                           invokeRestart("muffleMessage")
[16:04:46.189]                       }
[16:04:46.189]                       else if (inherits(cond, "warning")) {
[16:04:46.189]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.189]                         if (muffled) 
[16:04:46.189]                           invokeRestart("muffleWarning")
[16:04:46.189]                       }
[16:04:46.189]                       else if (inherits(cond, "condition")) {
[16:04:46.189]                         if (!is.null(pattern)) {
[16:04:46.189]                           computeRestarts <- base::computeRestarts
[16:04:46.189]                           grepl <- base::grepl
[16:04:46.189]                           restarts <- computeRestarts(cond)
[16:04:46.189]                           for (restart in restarts) {
[16:04:46.189]                             name <- restart$name
[16:04:46.189]                             if (is.null(name)) 
[16:04:46.189]                               next
[16:04:46.189]                             if (!grepl(pattern, name)) 
[16:04:46.189]                               next
[16:04:46.189]                             invokeRestart(restart)
[16:04:46.189]                             muffled <- TRUE
[16:04:46.189]                             break
[16:04:46.189]                           }
[16:04:46.189]                         }
[16:04:46.189]                       }
[16:04:46.189]                       invisible(muffled)
[16:04:46.189]                     }
[16:04:46.189]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.189]                   }
[16:04:46.189]                 }
[16:04:46.189]                 else {
[16:04:46.189]                   if (TRUE) {
[16:04:46.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.189]                     {
[16:04:46.189]                       inherits <- base::inherits
[16:04:46.189]                       invokeRestart <- base::invokeRestart
[16:04:46.189]                       is.null <- base::is.null
[16:04:46.189]                       muffled <- FALSE
[16:04:46.189]                       if (inherits(cond, "message")) {
[16:04:46.189]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.189]                         if (muffled) 
[16:04:46.189]                           invokeRestart("muffleMessage")
[16:04:46.189]                       }
[16:04:46.189]                       else if (inherits(cond, "warning")) {
[16:04:46.189]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.189]                         if (muffled) 
[16:04:46.189]                           invokeRestart("muffleWarning")
[16:04:46.189]                       }
[16:04:46.189]                       else if (inherits(cond, "condition")) {
[16:04:46.189]                         if (!is.null(pattern)) {
[16:04:46.189]                           computeRestarts <- base::computeRestarts
[16:04:46.189]                           grepl <- base::grepl
[16:04:46.189]                           restarts <- computeRestarts(cond)
[16:04:46.189]                           for (restart in restarts) {
[16:04:46.189]                             name <- restart$name
[16:04:46.189]                             if (is.null(name)) 
[16:04:46.189]                               next
[16:04:46.189]                             if (!grepl(pattern, name)) 
[16:04:46.189]                               next
[16:04:46.189]                             invokeRestart(restart)
[16:04:46.189]                             muffled <- TRUE
[16:04:46.189]                             break
[16:04:46.189]                           }
[16:04:46.189]                         }
[16:04:46.189]                       }
[16:04:46.189]                       invisible(muffled)
[16:04:46.189]                     }
[16:04:46.189]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.189]                   }
[16:04:46.189]                 }
[16:04:46.189]             }
[16:04:46.189]         }))
[16:04:46.189]     }, error = function(ex) {
[16:04:46.189]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:46.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.189]                 ...future.rng), started = ...future.startTime, 
[16:04:46.189]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:46.189]             version = "1.8"), class = "FutureResult")
[16:04:46.189]     }, finally = {
[16:04:46.189]         if (!identical(...future.workdir, getwd())) 
[16:04:46.189]             setwd(...future.workdir)
[16:04:46.189]         {
[16:04:46.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:46.189]                 ...future.oldOptions$nwarnings <- NULL
[16:04:46.189]             }
[16:04:46.189]             base::options(...future.oldOptions)
[16:04:46.189]             if (.Platform$OS.type == "windows") {
[16:04:46.189]                 old_names <- names(...future.oldEnvVars)
[16:04:46.189]                 envs <- base::Sys.getenv()
[16:04:46.189]                 names <- names(envs)
[16:04:46.189]                 common <- intersect(names, old_names)
[16:04:46.189]                 added <- setdiff(names, old_names)
[16:04:46.189]                 removed <- setdiff(old_names, names)
[16:04:46.189]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:46.189]                   envs[common]]
[16:04:46.189]                 NAMES <- toupper(changed)
[16:04:46.189]                 args <- list()
[16:04:46.189]                 for (kk in seq_along(NAMES)) {
[16:04:46.189]                   name <- changed[[kk]]
[16:04:46.189]                   NAME <- NAMES[[kk]]
[16:04:46.189]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.189]                     next
[16:04:46.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.189]                 }
[16:04:46.189]                 NAMES <- toupper(added)
[16:04:46.189]                 for (kk in seq_along(NAMES)) {
[16:04:46.189]                   name <- added[[kk]]
[16:04:46.189]                   NAME <- NAMES[[kk]]
[16:04:46.189]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.189]                     next
[16:04:46.189]                   args[[name]] <- ""
[16:04:46.189]                 }
[16:04:46.189]                 NAMES <- toupper(removed)
[16:04:46.189]                 for (kk in seq_along(NAMES)) {
[16:04:46.189]                   name <- removed[[kk]]
[16:04:46.189]                   NAME <- NAMES[[kk]]
[16:04:46.189]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.189]                     next
[16:04:46.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.189]                 }
[16:04:46.189]                 if (length(args) > 0) 
[16:04:46.189]                   base::do.call(base::Sys.setenv, args = args)
[16:04:46.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:46.189]             }
[16:04:46.189]             else {
[16:04:46.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:46.189]             }
[16:04:46.189]             {
[16:04:46.189]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:46.189]                   0L) {
[16:04:46.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:46.189]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:46.189]                   base::options(opts)
[16:04:46.189]                 }
[16:04:46.189]                 {
[16:04:46.189]                   {
[16:04:46.189]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:46.189]                     NULL
[16:04:46.189]                   }
[16:04:46.189]                   options(future.plan = NULL)
[16:04:46.189]                   if (is.na(NA_character_)) 
[16:04:46.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:46.189]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:46.189]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:46.189]                     envir = parent.frame()) 
[16:04:46.189]                   {
[16:04:46.189]                     if (is.function(workers)) 
[16:04:46.189]                       workers <- workers()
[16:04:46.189]                     workers <- structure(as.integer(workers), 
[16:04:46.189]                       class = class(workers))
[16:04:46.189]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:46.189]                       workers >= 1)
[16:04:46.189]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:46.189]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:46.189]                     }
[16:04:46.189]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:46.189]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:46.189]                       envir = envir)
[16:04:46.189]                     if (!future$lazy) 
[16:04:46.189]                       future <- run(future)
[16:04:46.189]                     invisible(future)
[16:04:46.189]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:46.189]                 }
[16:04:46.189]             }
[16:04:46.189]         }
[16:04:46.189]     })
[16:04:46.189]     if (TRUE) {
[16:04:46.189]         base::sink(type = "output", split = FALSE)
[16:04:46.189]         if (TRUE) {
[16:04:46.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:46.189]         }
[16:04:46.189]         else {
[16:04:46.189]             ...future.result["stdout"] <- base::list(NULL)
[16:04:46.189]         }
[16:04:46.189]         base::close(...future.stdout)
[16:04:46.189]         ...future.stdout <- NULL
[16:04:46.189]     }
[16:04:46.189]     ...future.result$conditions <- ...future.conditions
[16:04:46.189]     ...future.result$finished <- base::Sys.time()
[16:04:46.189]     ...future.result
[16:04:46.189] }
[16:04:46.192] MultisessionFuture started
[16:04:46.192] - Launch lazy future ... done
[16:04:46.192] run() for ‘MultisessionFuture’ ... done
[16:04:46.192] getGlobalsAndPackages() ...
[16:04:46.192] Searching for globals...
[16:04:46.193] 
[16:04:46.193] Searching for globals ... DONE
[16:04:46.193] - globals: [0] <none>
[16:04:46.193] getGlobalsAndPackages() ... DONE
[16:04:46.193] run() for ‘Future’ ...
[16:04:46.193] - state: ‘created’
[16:04:46.193] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:46.207] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:46.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:46.207]   - Field: ‘node’
[16:04:46.207]   - Field: ‘label’
[16:04:46.207]   - Field: ‘local’
[16:04:46.207]   - Field: ‘owner’
[16:04:46.207]   - Field: ‘envir’
[16:04:46.207]   - Field: ‘workers’
[16:04:46.207]   - Field: ‘packages’
[16:04:46.208]   - Field: ‘gc’
[16:04:46.208]   - Field: ‘conditions’
[16:04:46.208]   - Field: ‘persistent’
[16:04:46.208]   - Field: ‘expr’
[16:04:46.208]   - Field: ‘uuid’
[16:04:46.208]   - Field: ‘seed’
[16:04:46.208]   - Field: ‘version’
[16:04:46.208]   - Field: ‘result’
[16:04:46.208]   - Field: ‘asynchronous’
[16:04:46.208]   - Field: ‘calls’
[16:04:46.208]   - Field: ‘globals’
[16:04:46.209]   - Field: ‘stdout’
[16:04:46.209]   - Field: ‘earlySignal’
[16:04:46.209]   - Field: ‘lazy’
[16:04:46.209]   - Field: ‘state’
[16:04:46.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:46.209] - Launch lazy future ...
[16:04:46.209] Packages needed by the future expression (n = 0): <none>
[16:04:46.209] Packages needed by future strategies (n = 0): <none>
[16:04:46.210] {
[16:04:46.210]     {
[16:04:46.210]         {
[16:04:46.210]             ...future.startTime <- base::Sys.time()
[16:04:46.210]             {
[16:04:46.210]                 {
[16:04:46.210]                   {
[16:04:46.210]                     {
[16:04:46.210]                       base::local({
[16:04:46.210]                         has_future <- base::requireNamespace("future", 
[16:04:46.210]                           quietly = TRUE)
[16:04:46.210]                         if (has_future) {
[16:04:46.210]                           ns <- base::getNamespace("future")
[16:04:46.210]                           version <- ns[[".package"]][["version"]]
[16:04:46.210]                           if (is.null(version)) 
[16:04:46.210]                             version <- utils::packageVersion("future")
[16:04:46.210]                         }
[16:04:46.210]                         else {
[16:04:46.210]                           version <- NULL
[16:04:46.210]                         }
[16:04:46.210]                         if (!has_future || version < "1.8.0") {
[16:04:46.210]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:46.210]                             "", base::R.version$version.string), 
[16:04:46.210]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:46.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:46.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:46.210]                               "release", "version")], collapse = " "), 
[16:04:46.210]                             hostname = base::Sys.info()[["nodename"]])
[16:04:46.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:46.210]                             info)
[16:04:46.210]                           info <- base::paste(info, collapse = "; ")
[16:04:46.210]                           if (!has_future) {
[16:04:46.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:46.210]                               info)
[16:04:46.210]                           }
[16:04:46.210]                           else {
[16:04:46.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:46.210]                               info, version)
[16:04:46.210]                           }
[16:04:46.210]                           base::stop(msg)
[16:04:46.210]                         }
[16:04:46.210]                       })
[16:04:46.210]                     }
[16:04:46.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:46.210]                     base::options(mc.cores = 1L)
[16:04:46.210]                   }
[16:04:46.210]                   options(future.plan = NULL)
[16:04:46.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:46.210]                 }
[16:04:46.210]                 ...future.workdir <- getwd()
[16:04:46.210]             }
[16:04:46.210]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:46.210]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:46.210]         }
[16:04:46.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:46.210]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:46.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:46.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:46.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:46.210]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:46.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:46.210]             base::names(...future.oldOptions))
[16:04:46.210]     }
[16:04:46.210]     if (FALSE) {
[16:04:46.210]     }
[16:04:46.210]     else {
[16:04:46.210]         if (TRUE) {
[16:04:46.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:46.210]                 open = "w")
[16:04:46.210]         }
[16:04:46.210]         else {
[16:04:46.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:46.210]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:46.210]         }
[16:04:46.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:46.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:46.210]             base::sink(type = "output", split = FALSE)
[16:04:46.210]             base::close(...future.stdout)
[16:04:46.210]         }, add = TRUE)
[16:04:46.210]     }
[16:04:46.210]     ...future.frame <- base::sys.nframe()
[16:04:46.210]     ...future.conditions <- base::list()
[16:04:46.210]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:46.210]     if (FALSE) {
[16:04:46.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:46.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:46.210]     }
[16:04:46.210]     ...future.result <- base::tryCatch({
[16:04:46.210]         base::withCallingHandlers({
[16:04:46.210]             ...future.value <- base::withVisible(base::local({
[16:04:46.210]                 ...future.makeSendCondition <- base::local({
[16:04:46.210]                   sendCondition <- NULL
[16:04:46.210]                   function(frame = 1L) {
[16:04:46.210]                     if (is.function(sendCondition)) 
[16:04:46.210]                       return(sendCondition)
[16:04:46.210]                     ns <- getNamespace("parallel")
[16:04:46.210]                     if (exists("sendData", mode = "function", 
[16:04:46.210]                       envir = ns)) {
[16:04:46.210]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:46.210]                         envir = ns)
[16:04:46.210]                       envir <- sys.frame(frame)
[16:04:46.210]                       master <- NULL
[16:04:46.210]                       while (!identical(envir, .GlobalEnv) && 
[16:04:46.210]                         !identical(envir, emptyenv())) {
[16:04:46.210]                         if (exists("master", mode = "list", envir = envir, 
[16:04:46.210]                           inherits = FALSE)) {
[16:04:46.210]                           master <- get("master", mode = "list", 
[16:04:46.210]                             envir = envir, inherits = FALSE)
[16:04:46.210]                           if (inherits(master, c("SOCKnode", 
[16:04:46.210]                             "SOCK0node"))) {
[16:04:46.210]                             sendCondition <<- function(cond) {
[16:04:46.210]                               data <- list(type = "VALUE", value = cond, 
[16:04:46.210]                                 success = TRUE)
[16:04:46.210]                               parallel_sendData(master, data)
[16:04:46.210]                             }
[16:04:46.210]                             return(sendCondition)
[16:04:46.210]                           }
[16:04:46.210]                         }
[16:04:46.210]                         frame <- frame + 1L
[16:04:46.210]                         envir <- sys.frame(frame)
[16:04:46.210]                       }
[16:04:46.210]                     }
[16:04:46.210]                     sendCondition <<- function(cond) NULL
[16:04:46.210]                   }
[16:04:46.210]                 })
[16:04:46.210]                 withCallingHandlers({
[16:04:46.210]                   NULL
[16:04:46.210]                 }, immediateCondition = function(cond) {
[16:04:46.210]                   sendCondition <- ...future.makeSendCondition()
[16:04:46.210]                   sendCondition(cond)
[16:04:46.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.210]                   {
[16:04:46.210]                     inherits <- base::inherits
[16:04:46.210]                     invokeRestart <- base::invokeRestart
[16:04:46.210]                     is.null <- base::is.null
[16:04:46.210]                     muffled <- FALSE
[16:04:46.210]                     if (inherits(cond, "message")) {
[16:04:46.210]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:46.210]                       if (muffled) 
[16:04:46.210]                         invokeRestart("muffleMessage")
[16:04:46.210]                     }
[16:04:46.210]                     else if (inherits(cond, "warning")) {
[16:04:46.210]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:46.210]                       if (muffled) 
[16:04:46.210]                         invokeRestart("muffleWarning")
[16:04:46.210]                     }
[16:04:46.210]                     else if (inherits(cond, "condition")) {
[16:04:46.210]                       if (!is.null(pattern)) {
[16:04:46.210]                         computeRestarts <- base::computeRestarts
[16:04:46.210]                         grepl <- base::grepl
[16:04:46.210]                         restarts <- computeRestarts(cond)
[16:04:46.210]                         for (restart in restarts) {
[16:04:46.210]                           name <- restart$name
[16:04:46.210]                           if (is.null(name)) 
[16:04:46.210]                             next
[16:04:46.210]                           if (!grepl(pattern, name)) 
[16:04:46.210]                             next
[16:04:46.210]                           invokeRestart(restart)
[16:04:46.210]                           muffled <- TRUE
[16:04:46.210]                           break
[16:04:46.210]                         }
[16:04:46.210]                       }
[16:04:46.210]                     }
[16:04:46.210]                     invisible(muffled)
[16:04:46.210]                   }
[16:04:46.210]                   muffleCondition(cond)
[16:04:46.210]                 })
[16:04:46.210]             }))
[16:04:46.210]             future::FutureResult(value = ...future.value$value, 
[16:04:46.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.210]                   ...future.rng), globalenv = if (FALSE) 
[16:04:46.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:46.210]                     ...future.globalenv.names))
[16:04:46.210]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:46.210]         }, condition = base::local({
[16:04:46.210]             c <- base::c
[16:04:46.210]             inherits <- base::inherits
[16:04:46.210]             invokeRestart <- base::invokeRestart
[16:04:46.210]             length <- base::length
[16:04:46.210]             list <- base::list
[16:04:46.210]             seq.int <- base::seq.int
[16:04:46.210]             signalCondition <- base::signalCondition
[16:04:46.210]             sys.calls <- base::sys.calls
[16:04:46.210]             `[[` <- base::`[[`
[16:04:46.210]             `+` <- base::`+`
[16:04:46.210]             `<<-` <- base::`<<-`
[16:04:46.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:46.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:46.210]                   3L)]
[16:04:46.210]             }
[16:04:46.210]             function(cond) {
[16:04:46.210]                 is_error <- inherits(cond, "error")
[16:04:46.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:46.210]                   NULL)
[16:04:46.210]                 if (is_error) {
[16:04:46.210]                   sessionInformation <- function() {
[16:04:46.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:46.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:46.210]                       search = base::search(), system = base::Sys.info())
[16:04:46.210]                   }
[16:04:46.210]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:46.210]                     cond$call), session = sessionInformation(), 
[16:04:46.210]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:46.210]                   signalCondition(cond)
[16:04:46.210]                 }
[16:04:46.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:46.210]                 "immediateCondition"))) {
[16:04:46.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:46.210]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:46.210]                   if (TRUE && !signal) {
[16:04:46.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.210]                     {
[16:04:46.210]                       inherits <- base::inherits
[16:04:46.210]                       invokeRestart <- base::invokeRestart
[16:04:46.210]                       is.null <- base::is.null
[16:04:46.210]                       muffled <- FALSE
[16:04:46.210]                       if (inherits(cond, "message")) {
[16:04:46.210]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.210]                         if (muffled) 
[16:04:46.210]                           invokeRestart("muffleMessage")
[16:04:46.210]                       }
[16:04:46.210]                       else if (inherits(cond, "warning")) {
[16:04:46.210]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.210]                         if (muffled) 
[16:04:46.210]                           invokeRestart("muffleWarning")
[16:04:46.210]                       }
[16:04:46.210]                       else if (inherits(cond, "condition")) {
[16:04:46.210]                         if (!is.null(pattern)) {
[16:04:46.210]                           computeRestarts <- base::computeRestarts
[16:04:46.210]                           grepl <- base::grepl
[16:04:46.210]                           restarts <- computeRestarts(cond)
[16:04:46.210]                           for (restart in restarts) {
[16:04:46.210]                             name <- restart$name
[16:04:46.210]                             if (is.null(name)) 
[16:04:46.210]                               next
[16:04:46.210]                             if (!grepl(pattern, name)) 
[16:04:46.210]                               next
[16:04:46.210]                             invokeRestart(restart)
[16:04:46.210]                             muffled <- TRUE
[16:04:46.210]                             break
[16:04:46.210]                           }
[16:04:46.210]                         }
[16:04:46.210]                       }
[16:04:46.210]                       invisible(muffled)
[16:04:46.210]                     }
[16:04:46.210]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.210]                   }
[16:04:46.210]                 }
[16:04:46.210]                 else {
[16:04:46.210]                   if (TRUE) {
[16:04:46.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.210]                     {
[16:04:46.210]                       inherits <- base::inherits
[16:04:46.210]                       invokeRestart <- base::invokeRestart
[16:04:46.210]                       is.null <- base::is.null
[16:04:46.210]                       muffled <- FALSE
[16:04:46.210]                       if (inherits(cond, "message")) {
[16:04:46.210]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.210]                         if (muffled) 
[16:04:46.210]                           invokeRestart("muffleMessage")
[16:04:46.210]                       }
[16:04:46.210]                       else if (inherits(cond, "warning")) {
[16:04:46.210]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.210]                         if (muffled) 
[16:04:46.210]                           invokeRestart("muffleWarning")
[16:04:46.210]                       }
[16:04:46.210]                       else if (inherits(cond, "condition")) {
[16:04:46.210]                         if (!is.null(pattern)) {
[16:04:46.210]                           computeRestarts <- base::computeRestarts
[16:04:46.210]                           grepl <- base::grepl
[16:04:46.210]                           restarts <- computeRestarts(cond)
[16:04:46.210]                           for (restart in restarts) {
[16:04:46.210]                             name <- restart$name
[16:04:46.210]                             if (is.null(name)) 
[16:04:46.210]                               next
[16:04:46.210]                             if (!grepl(pattern, name)) 
[16:04:46.210]                               next
[16:04:46.210]                             invokeRestart(restart)
[16:04:46.210]                             muffled <- TRUE
[16:04:46.210]                             break
[16:04:46.210]                           }
[16:04:46.210]                         }
[16:04:46.210]                       }
[16:04:46.210]                       invisible(muffled)
[16:04:46.210]                     }
[16:04:46.210]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.210]                   }
[16:04:46.210]                 }
[16:04:46.210]             }
[16:04:46.210]         }))
[16:04:46.210]     }, error = function(ex) {
[16:04:46.210]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:46.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.210]                 ...future.rng), started = ...future.startTime, 
[16:04:46.210]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:46.210]             version = "1.8"), class = "FutureResult")
[16:04:46.210]     }, finally = {
[16:04:46.210]         if (!identical(...future.workdir, getwd())) 
[16:04:46.210]             setwd(...future.workdir)
[16:04:46.210]         {
[16:04:46.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:46.210]                 ...future.oldOptions$nwarnings <- NULL
[16:04:46.210]             }
[16:04:46.210]             base::options(...future.oldOptions)
[16:04:46.210]             if (.Platform$OS.type == "windows") {
[16:04:46.210]                 old_names <- names(...future.oldEnvVars)
[16:04:46.210]                 envs <- base::Sys.getenv()
[16:04:46.210]                 names <- names(envs)
[16:04:46.210]                 common <- intersect(names, old_names)
[16:04:46.210]                 added <- setdiff(names, old_names)
[16:04:46.210]                 removed <- setdiff(old_names, names)
[16:04:46.210]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:46.210]                   envs[common]]
[16:04:46.210]                 NAMES <- toupper(changed)
[16:04:46.210]                 args <- list()
[16:04:46.210]                 for (kk in seq_along(NAMES)) {
[16:04:46.210]                   name <- changed[[kk]]
[16:04:46.210]                   NAME <- NAMES[[kk]]
[16:04:46.210]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.210]                     next
[16:04:46.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.210]                 }
[16:04:46.210]                 NAMES <- toupper(added)
[16:04:46.210]                 for (kk in seq_along(NAMES)) {
[16:04:46.210]                   name <- added[[kk]]
[16:04:46.210]                   NAME <- NAMES[[kk]]
[16:04:46.210]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.210]                     next
[16:04:46.210]                   args[[name]] <- ""
[16:04:46.210]                 }
[16:04:46.210]                 NAMES <- toupper(removed)
[16:04:46.210]                 for (kk in seq_along(NAMES)) {
[16:04:46.210]                   name <- removed[[kk]]
[16:04:46.210]                   NAME <- NAMES[[kk]]
[16:04:46.210]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.210]                     next
[16:04:46.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.210]                 }
[16:04:46.210]                 if (length(args) > 0) 
[16:04:46.210]                   base::do.call(base::Sys.setenv, args = args)
[16:04:46.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:46.210]             }
[16:04:46.210]             else {
[16:04:46.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:46.210]             }
[16:04:46.210]             {
[16:04:46.210]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:46.210]                   0L) {
[16:04:46.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:46.210]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:46.210]                   base::options(opts)
[16:04:46.210]                 }
[16:04:46.210]                 {
[16:04:46.210]                   {
[16:04:46.210]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:46.210]                     NULL
[16:04:46.210]                   }
[16:04:46.210]                   options(future.plan = NULL)
[16:04:46.210]                   if (is.na(NA_character_)) 
[16:04:46.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:46.210]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:46.210]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:46.210]                     envir = parent.frame()) 
[16:04:46.210]                   {
[16:04:46.210]                     if (is.function(workers)) 
[16:04:46.210]                       workers <- workers()
[16:04:46.210]                     workers <- structure(as.integer(workers), 
[16:04:46.210]                       class = class(workers))
[16:04:46.210]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:46.210]                       workers >= 1)
[16:04:46.210]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:46.210]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:46.210]                     }
[16:04:46.210]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:46.210]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:46.210]                       envir = envir)
[16:04:46.210]                     if (!future$lazy) 
[16:04:46.210]                       future <- run(future)
[16:04:46.210]                     invisible(future)
[16:04:46.210]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:46.210]                 }
[16:04:46.210]             }
[16:04:46.210]         }
[16:04:46.210]     })
[16:04:46.210]     if (TRUE) {
[16:04:46.210]         base::sink(type = "output", split = FALSE)
[16:04:46.210]         if (TRUE) {
[16:04:46.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:46.210]         }
[16:04:46.210]         else {
[16:04:46.210]             ...future.result["stdout"] <- base::list(NULL)
[16:04:46.210]         }
[16:04:46.210]         base::close(...future.stdout)
[16:04:46.210]         ...future.stdout <- NULL
[16:04:46.210]     }
[16:04:46.210]     ...future.result$conditions <- ...future.conditions
[16:04:46.210]     ...future.result$finished <- base::Sys.time()
[16:04:46.210]     ...future.result
[16:04:46.210] }
[16:04:46.213] MultisessionFuture started
[16:04:46.213] - Launch lazy future ... done
[16:04:46.213] run() for ‘MultisessionFuture’ ... done
[16:04:46.213] getGlobalsAndPackages() ...
[16:04:46.214] Searching for globals...
[16:04:46.214] - globals found: [1] ‘{’
[16:04:46.214] Searching for globals ... DONE
[16:04:46.214] Resolving globals: FALSE
[16:04:46.215] 
[16:04:46.215] 
[16:04:46.215] getGlobalsAndPackages() ... DONE
[16:04:46.215] run() for ‘Future’ ...
[16:04:46.215] - state: ‘created’
[16:04:46.215] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:46.229] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:46.229] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:46.229]   - Field: ‘node’
[16:04:46.229]   - Field: ‘label’
[16:04:46.232]   - Field: ‘local’
[16:04:46.232]   - Field: ‘owner’
[16:04:46.232]   - Field: ‘envir’
[16:04:46.232]   - Field: ‘workers’
[16:04:46.232]   - Field: ‘packages’
[16:04:46.232]   - Field: ‘gc’
[16:04:46.233]   - Field: ‘conditions’
[16:04:46.233]   - Field: ‘persistent’
[16:04:46.233]   - Field: ‘expr’
[16:04:46.233]   - Field: ‘uuid’
[16:04:46.233]   - Field: ‘seed’
[16:04:46.233]   - Field: ‘version’
[16:04:46.233]   - Field: ‘result’
[16:04:46.233]   - Field: ‘asynchronous’
[16:04:46.233]   - Field: ‘calls’
[16:04:46.233]   - Field: ‘globals’
[16:04:46.233]   - Field: ‘stdout’
[16:04:46.234]   - Field: ‘earlySignal’
[16:04:46.234]   - Field: ‘lazy’
[16:04:46.234]   - Field: ‘state’
[16:04:46.234] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:46.234] - Launch lazy future ...
[16:04:46.234] Packages needed by the future expression (n = 0): <none>
[16:04:46.234] Packages needed by future strategies (n = 0): <none>
[16:04:46.235] {
[16:04:46.235]     {
[16:04:46.235]         {
[16:04:46.235]             ...future.startTime <- base::Sys.time()
[16:04:46.235]             {
[16:04:46.235]                 {
[16:04:46.235]                   {
[16:04:46.235]                     {
[16:04:46.235]                       base::local({
[16:04:46.235]                         has_future <- base::requireNamespace("future", 
[16:04:46.235]                           quietly = TRUE)
[16:04:46.235]                         if (has_future) {
[16:04:46.235]                           ns <- base::getNamespace("future")
[16:04:46.235]                           version <- ns[[".package"]][["version"]]
[16:04:46.235]                           if (is.null(version)) 
[16:04:46.235]                             version <- utils::packageVersion("future")
[16:04:46.235]                         }
[16:04:46.235]                         else {
[16:04:46.235]                           version <- NULL
[16:04:46.235]                         }
[16:04:46.235]                         if (!has_future || version < "1.8.0") {
[16:04:46.235]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:46.235]                             "", base::R.version$version.string), 
[16:04:46.235]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:46.235]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:46.235]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:46.235]                               "release", "version")], collapse = " "), 
[16:04:46.235]                             hostname = base::Sys.info()[["nodename"]])
[16:04:46.235]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:46.235]                             info)
[16:04:46.235]                           info <- base::paste(info, collapse = "; ")
[16:04:46.235]                           if (!has_future) {
[16:04:46.235]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:46.235]                               info)
[16:04:46.235]                           }
[16:04:46.235]                           else {
[16:04:46.235]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:46.235]                               info, version)
[16:04:46.235]                           }
[16:04:46.235]                           base::stop(msg)
[16:04:46.235]                         }
[16:04:46.235]                       })
[16:04:46.235]                     }
[16:04:46.235]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:46.235]                     base::options(mc.cores = 1L)
[16:04:46.235]                   }
[16:04:46.235]                   options(future.plan = NULL)
[16:04:46.235]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.235]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:46.235]                 }
[16:04:46.235]                 ...future.workdir <- getwd()
[16:04:46.235]             }
[16:04:46.235]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:46.235]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:46.235]         }
[16:04:46.235]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:46.235]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:46.235]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:46.235]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:46.235]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:46.235]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:46.235]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:46.235]             base::names(...future.oldOptions))
[16:04:46.235]     }
[16:04:46.235]     if (FALSE) {
[16:04:46.235]     }
[16:04:46.235]     else {
[16:04:46.235]         if (TRUE) {
[16:04:46.235]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:46.235]                 open = "w")
[16:04:46.235]         }
[16:04:46.235]         else {
[16:04:46.235]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:46.235]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:46.235]         }
[16:04:46.235]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:46.235]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:46.235]             base::sink(type = "output", split = FALSE)
[16:04:46.235]             base::close(...future.stdout)
[16:04:46.235]         }, add = TRUE)
[16:04:46.235]     }
[16:04:46.235]     ...future.frame <- base::sys.nframe()
[16:04:46.235]     ...future.conditions <- base::list()
[16:04:46.235]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:46.235]     if (FALSE) {
[16:04:46.235]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:46.235]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:46.235]     }
[16:04:46.235]     ...future.result <- base::tryCatch({
[16:04:46.235]         base::withCallingHandlers({
[16:04:46.235]             ...future.value <- base::withVisible(base::local({
[16:04:46.235]                 ...future.makeSendCondition <- base::local({
[16:04:46.235]                   sendCondition <- NULL
[16:04:46.235]                   function(frame = 1L) {
[16:04:46.235]                     if (is.function(sendCondition)) 
[16:04:46.235]                       return(sendCondition)
[16:04:46.235]                     ns <- getNamespace("parallel")
[16:04:46.235]                     if (exists("sendData", mode = "function", 
[16:04:46.235]                       envir = ns)) {
[16:04:46.235]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:46.235]                         envir = ns)
[16:04:46.235]                       envir <- sys.frame(frame)
[16:04:46.235]                       master <- NULL
[16:04:46.235]                       while (!identical(envir, .GlobalEnv) && 
[16:04:46.235]                         !identical(envir, emptyenv())) {
[16:04:46.235]                         if (exists("master", mode = "list", envir = envir, 
[16:04:46.235]                           inherits = FALSE)) {
[16:04:46.235]                           master <- get("master", mode = "list", 
[16:04:46.235]                             envir = envir, inherits = FALSE)
[16:04:46.235]                           if (inherits(master, c("SOCKnode", 
[16:04:46.235]                             "SOCK0node"))) {
[16:04:46.235]                             sendCondition <<- function(cond) {
[16:04:46.235]                               data <- list(type = "VALUE", value = cond, 
[16:04:46.235]                                 success = TRUE)
[16:04:46.235]                               parallel_sendData(master, data)
[16:04:46.235]                             }
[16:04:46.235]                             return(sendCondition)
[16:04:46.235]                           }
[16:04:46.235]                         }
[16:04:46.235]                         frame <- frame + 1L
[16:04:46.235]                         envir <- sys.frame(frame)
[16:04:46.235]                       }
[16:04:46.235]                     }
[16:04:46.235]                     sendCondition <<- function(cond) NULL
[16:04:46.235]                   }
[16:04:46.235]                 })
[16:04:46.235]                 withCallingHandlers({
[16:04:46.235]                   {
[16:04:46.235]                     4
[16:04:46.235]                   }
[16:04:46.235]                 }, immediateCondition = function(cond) {
[16:04:46.235]                   sendCondition <- ...future.makeSendCondition()
[16:04:46.235]                   sendCondition(cond)
[16:04:46.235]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.235]                   {
[16:04:46.235]                     inherits <- base::inherits
[16:04:46.235]                     invokeRestart <- base::invokeRestart
[16:04:46.235]                     is.null <- base::is.null
[16:04:46.235]                     muffled <- FALSE
[16:04:46.235]                     if (inherits(cond, "message")) {
[16:04:46.235]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:46.235]                       if (muffled) 
[16:04:46.235]                         invokeRestart("muffleMessage")
[16:04:46.235]                     }
[16:04:46.235]                     else if (inherits(cond, "warning")) {
[16:04:46.235]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:46.235]                       if (muffled) 
[16:04:46.235]                         invokeRestart("muffleWarning")
[16:04:46.235]                     }
[16:04:46.235]                     else if (inherits(cond, "condition")) {
[16:04:46.235]                       if (!is.null(pattern)) {
[16:04:46.235]                         computeRestarts <- base::computeRestarts
[16:04:46.235]                         grepl <- base::grepl
[16:04:46.235]                         restarts <- computeRestarts(cond)
[16:04:46.235]                         for (restart in restarts) {
[16:04:46.235]                           name <- restart$name
[16:04:46.235]                           if (is.null(name)) 
[16:04:46.235]                             next
[16:04:46.235]                           if (!grepl(pattern, name)) 
[16:04:46.235]                             next
[16:04:46.235]                           invokeRestart(restart)
[16:04:46.235]                           muffled <- TRUE
[16:04:46.235]                           break
[16:04:46.235]                         }
[16:04:46.235]                       }
[16:04:46.235]                     }
[16:04:46.235]                     invisible(muffled)
[16:04:46.235]                   }
[16:04:46.235]                   muffleCondition(cond)
[16:04:46.235]                 })
[16:04:46.235]             }))
[16:04:46.235]             future::FutureResult(value = ...future.value$value, 
[16:04:46.235]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.235]                   ...future.rng), globalenv = if (FALSE) 
[16:04:46.235]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:46.235]                     ...future.globalenv.names))
[16:04:46.235]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:46.235]         }, condition = base::local({
[16:04:46.235]             c <- base::c
[16:04:46.235]             inherits <- base::inherits
[16:04:46.235]             invokeRestart <- base::invokeRestart
[16:04:46.235]             length <- base::length
[16:04:46.235]             list <- base::list
[16:04:46.235]             seq.int <- base::seq.int
[16:04:46.235]             signalCondition <- base::signalCondition
[16:04:46.235]             sys.calls <- base::sys.calls
[16:04:46.235]             `[[` <- base::`[[`
[16:04:46.235]             `+` <- base::`+`
[16:04:46.235]             `<<-` <- base::`<<-`
[16:04:46.235]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:46.235]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:46.235]                   3L)]
[16:04:46.235]             }
[16:04:46.235]             function(cond) {
[16:04:46.235]                 is_error <- inherits(cond, "error")
[16:04:46.235]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:46.235]                   NULL)
[16:04:46.235]                 if (is_error) {
[16:04:46.235]                   sessionInformation <- function() {
[16:04:46.235]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:46.235]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:46.235]                       search = base::search(), system = base::Sys.info())
[16:04:46.235]                   }
[16:04:46.235]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.235]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:46.235]                     cond$call), session = sessionInformation(), 
[16:04:46.235]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:46.235]                   signalCondition(cond)
[16:04:46.235]                 }
[16:04:46.235]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:46.235]                 "immediateCondition"))) {
[16:04:46.235]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:46.235]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.235]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:46.235]                   if (TRUE && !signal) {
[16:04:46.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.235]                     {
[16:04:46.235]                       inherits <- base::inherits
[16:04:46.235]                       invokeRestart <- base::invokeRestart
[16:04:46.235]                       is.null <- base::is.null
[16:04:46.235]                       muffled <- FALSE
[16:04:46.235]                       if (inherits(cond, "message")) {
[16:04:46.235]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.235]                         if (muffled) 
[16:04:46.235]                           invokeRestart("muffleMessage")
[16:04:46.235]                       }
[16:04:46.235]                       else if (inherits(cond, "warning")) {
[16:04:46.235]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.235]                         if (muffled) 
[16:04:46.235]                           invokeRestart("muffleWarning")
[16:04:46.235]                       }
[16:04:46.235]                       else if (inherits(cond, "condition")) {
[16:04:46.235]                         if (!is.null(pattern)) {
[16:04:46.235]                           computeRestarts <- base::computeRestarts
[16:04:46.235]                           grepl <- base::grepl
[16:04:46.235]                           restarts <- computeRestarts(cond)
[16:04:46.235]                           for (restart in restarts) {
[16:04:46.235]                             name <- restart$name
[16:04:46.235]                             if (is.null(name)) 
[16:04:46.235]                               next
[16:04:46.235]                             if (!grepl(pattern, name)) 
[16:04:46.235]                               next
[16:04:46.235]                             invokeRestart(restart)
[16:04:46.235]                             muffled <- TRUE
[16:04:46.235]                             break
[16:04:46.235]                           }
[16:04:46.235]                         }
[16:04:46.235]                       }
[16:04:46.235]                       invisible(muffled)
[16:04:46.235]                     }
[16:04:46.235]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.235]                   }
[16:04:46.235]                 }
[16:04:46.235]                 else {
[16:04:46.235]                   if (TRUE) {
[16:04:46.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.235]                     {
[16:04:46.235]                       inherits <- base::inherits
[16:04:46.235]                       invokeRestart <- base::invokeRestart
[16:04:46.235]                       is.null <- base::is.null
[16:04:46.235]                       muffled <- FALSE
[16:04:46.235]                       if (inherits(cond, "message")) {
[16:04:46.235]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.235]                         if (muffled) 
[16:04:46.235]                           invokeRestart("muffleMessage")
[16:04:46.235]                       }
[16:04:46.235]                       else if (inherits(cond, "warning")) {
[16:04:46.235]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.235]                         if (muffled) 
[16:04:46.235]                           invokeRestart("muffleWarning")
[16:04:46.235]                       }
[16:04:46.235]                       else if (inherits(cond, "condition")) {
[16:04:46.235]                         if (!is.null(pattern)) {
[16:04:46.235]                           computeRestarts <- base::computeRestarts
[16:04:46.235]                           grepl <- base::grepl
[16:04:46.235]                           restarts <- computeRestarts(cond)
[16:04:46.235]                           for (restart in restarts) {
[16:04:46.235]                             name <- restart$name
[16:04:46.235]                             if (is.null(name)) 
[16:04:46.235]                               next
[16:04:46.235]                             if (!grepl(pattern, name)) 
[16:04:46.235]                               next
[16:04:46.235]                             invokeRestart(restart)
[16:04:46.235]                             muffled <- TRUE
[16:04:46.235]                             break
[16:04:46.235]                           }
[16:04:46.235]                         }
[16:04:46.235]                       }
[16:04:46.235]                       invisible(muffled)
[16:04:46.235]                     }
[16:04:46.235]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.235]                   }
[16:04:46.235]                 }
[16:04:46.235]             }
[16:04:46.235]         }))
[16:04:46.235]     }, error = function(ex) {
[16:04:46.235]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:46.235]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.235]                 ...future.rng), started = ...future.startTime, 
[16:04:46.235]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:46.235]             version = "1.8"), class = "FutureResult")
[16:04:46.235]     }, finally = {
[16:04:46.235]         if (!identical(...future.workdir, getwd())) 
[16:04:46.235]             setwd(...future.workdir)
[16:04:46.235]         {
[16:04:46.235]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:46.235]                 ...future.oldOptions$nwarnings <- NULL
[16:04:46.235]             }
[16:04:46.235]             base::options(...future.oldOptions)
[16:04:46.235]             if (.Platform$OS.type == "windows") {
[16:04:46.235]                 old_names <- names(...future.oldEnvVars)
[16:04:46.235]                 envs <- base::Sys.getenv()
[16:04:46.235]                 names <- names(envs)
[16:04:46.235]                 common <- intersect(names, old_names)
[16:04:46.235]                 added <- setdiff(names, old_names)
[16:04:46.235]                 removed <- setdiff(old_names, names)
[16:04:46.235]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:46.235]                   envs[common]]
[16:04:46.235]                 NAMES <- toupper(changed)
[16:04:46.235]                 args <- list()
[16:04:46.235]                 for (kk in seq_along(NAMES)) {
[16:04:46.235]                   name <- changed[[kk]]
[16:04:46.235]                   NAME <- NAMES[[kk]]
[16:04:46.235]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.235]                     next
[16:04:46.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.235]                 }
[16:04:46.235]                 NAMES <- toupper(added)
[16:04:46.235]                 for (kk in seq_along(NAMES)) {
[16:04:46.235]                   name <- added[[kk]]
[16:04:46.235]                   NAME <- NAMES[[kk]]
[16:04:46.235]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.235]                     next
[16:04:46.235]                   args[[name]] <- ""
[16:04:46.235]                 }
[16:04:46.235]                 NAMES <- toupper(removed)
[16:04:46.235]                 for (kk in seq_along(NAMES)) {
[16:04:46.235]                   name <- removed[[kk]]
[16:04:46.235]                   NAME <- NAMES[[kk]]
[16:04:46.235]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.235]                     next
[16:04:46.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.235]                 }
[16:04:46.235]                 if (length(args) > 0) 
[16:04:46.235]                   base::do.call(base::Sys.setenv, args = args)
[16:04:46.235]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:46.235]             }
[16:04:46.235]             else {
[16:04:46.235]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:46.235]             }
[16:04:46.235]             {
[16:04:46.235]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:46.235]                   0L) {
[16:04:46.235]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:46.235]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:46.235]                   base::options(opts)
[16:04:46.235]                 }
[16:04:46.235]                 {
[16:04:46.235]                   {
[16:04:46.235]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:46.235]                     NULL
[16:04:46.235]                   }
[16:04:46.235]                   options(future.plan = NULL)
[16:04:46.235]                   if (is.na(NA_character_)) 
[16:04:46.235]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.235]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:46.235]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:46.235]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:46.235]                     envir = parent.frame()) 
[16:04:46.235]                   {
[16:04:46.235]                     if (is.function(workers)) 
[16:04:46.235]                       workers <- workers()
[16:04:46.235]                     workers <- structure(as.integer(workers), 
[16:04:46.235]                       class = class(workers))
[16:04:46.235]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:46.235]                       workers >= 1)
[16:04:46.235]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:46.235]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:46.235]                     }
[16:04:46.235]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:46.235]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:46.235]                       envir = envir)
[16:04:46.235]                     if (!future$lazy) 
[16:04:46.235]                       future <- run(future)
[16:04:46.235]                     invisible(future)
[16:04:46.235]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:46.235]                 }
[16:04:46.235]             }
[16:04:46.235]         }
[16:04:46.235]     })
[16:04:46.235]     if (TRUE) {
[16:04:46.235]         base::sink(type = "output", split = FALSE)
[16:04:46.235]         if (TRUE) {
[16:04:46.235]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:46.235]         }
[16:04:46.235]         else {
[16:04:46.235]             ...future.result["stdout"] <- base::list(NULL)
[16:04:46.235]         }
[16:04:46.235]         base::close(...future.stdout)
[16:04:46.235]         ...future.stdout <- NULL
[16:04:46.235]     }
[16:04:46.235]     ...future.result$conditions <- ...future.conditions
[16:04:46.235]     ...future.result$finished <- base::Sys.time()
[16:04:46.235]     ...future.result
[16:04:46.235] }
[16:04:46.237] Poll #1 (0): usedNodes() = 2, workers = 2
[16:04:46.248] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.248] - Validating connection of MultisessionFuture
[16:04:46.248] - received message: FutureResult
[16:04:46.248] - Received FutureResult
[16:04:46.248] - Erased future from FutureRegistry
[16:04:46.248] result() for ClusterFuture ...
[16:04:46.248] - result already collected: FutureResult
[16:04:46.249] result() for ClusterFuture ... done
[16:04:46.249] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:46.249] result() for ClusterFuture ...
[16:04:46.249] - result already collected: FutureResult
[16:04:46.249] result() for ClusterFuture ... done
[16:04:46.249] result() for ClusterFuture ...
[16:04:46.249] - result already collected: FutureResult
[16:04:46.249] result() for ClusterFuture ... done
[16:04:46.250] MultisessionFuture started
[16:04:46.250] - Launch lazy future ... done
[16:04:46.250] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55874f13e260> 
Classes 'listenv', 'environment' <environment: 0x55874df3f090> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:04:46.259] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.260] - Validating connection of MultisessionFuture
[16:04:46.260] - received message: FutureResult
[16:04:46.260] - Received FutureResult
[16:04:46.260] - Erased future from FutureRegistry
[16:04:46.260] result() for ClusterFuture ...
[16:04:46.260] - result already collected: FutureResult
[16:04:46.260] result() for ClusterFuture ... done
[16:04:46.260] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:46.273] resolve() on list environment ...
[16:04:46.273]  recursive: 0
[16:04:46.274]  length: 6
[16:04:46.274]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:46.274] signalConditionsASAP(numeric, pos=1) ...
[16:04:46.275] - nx: 6
[16:04:46.275] - relay: TRUE
[16:04:46.275] - stdout: TRUE
[16:04:46.275] - signal: TRUE
[16:04:46.275] - resignal: FALSE
[16:04:46.275] - force: TRUE
[16:04:46.275] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.275] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.275]  - until=2
[16:04:46.275]  - relaying element #2
[16:04:46.275] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.276] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.276] signalConditionsASAP(NULL, pos=1) ... done
[16:04:46.276]  length: 5 (resolved future 1)
[16:04:46.276] Future #2
[16:04:46.276] result() for ClusterFuture ...
[16:04:46.276] - result already collected: FutureResult
[16:04:46.276] result() for ClusterFuture ... done
[16:04:46.276] result() for ClusterFuture ...
[16:04:46.276] - result already collected: FutureResult
[16:04:46.276] result() for ClusterFuture ... done
[16:04:46.276] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:46.277] - nx: 6
[16:04:46.277] - relay: TRUE
[16:04:46.277] - stdout: TRUE
[16:04:46.277] - signal: TRUE
[16:04:46.277] - resignal: FALSE
[16:04:46.277] - force: TRUE
[16:04:46.277] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.277] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.277]  - until=2
[16:04:46.277]  - relaying element #2
[16:04:46.277] result() for ClusterFuture ...
[16:04:46.277] - result already collected: FutureResult
[16:04:46.278] result() for ClusterFuture ... done
[16:04:46.278] result() for ClusterFuture ...
[16:04:46.278] - result already collected: FutureResult
[16:04:46.278] result() for ClusterFuture ... done
[16:04:46.278] result() for ClusterFuture ...
[16:04:46.278] - result already collected: FutureResult
[16:04:46.278] result() for ClusterFuture ... done
[16:04:46.278] result() for ClusterFuture ...
[16:04:46.278] - result already collected: FutureResult
[16:04:46.278] result() for ClusterFuture ... done
[16:04:46.278] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.279] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.279] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:46.279]  length: 4 (resolved future 2)
[16:04:46.279] Future #3
[16:04:46.279] result() for ClusterFuture ...
[16:04:46.279] - result already collected: FutureResult
[16:04:46.279] result() for ClusterFuture ... done
[16:04:46.279] result() for ClusterFuture ...
[16:04:46.279] - result already collected: FutureResult
[16:04:46.279] result() for ClusterFuture ... done
[16:04:46.280] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:46.280] - nx: 6
[16:04:46.280] - relay: TRUE
[16:04:46.280] - stdout: TRUE
[16:04:46.280] - signal: TRUE
[16:04:46.280] - resignal: FALSE
[16:04:46.280] - force: TRUE
[16:04:46.280] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.280] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.280]  - until=3
[16:04:46.280]  - relaying element #3
[16:04:46.280] result() for ClusterFuture ...
[16:04:46.281] - result already collected: FutureResult
[16:04:46.281] result() for ClusterFuture ... done
[16:04:46.281] result() for ClusterFuture ...
[16:04:46.281] - result already collected: FutureResult
[16:04:46.281] result() for ClusterFuture ... done
[16:04:46.281] result() for ClusterFuture ...
[16:04:46.281] - result already collected: FutureResult
[16:04:46.281] result() for ClusterFuture ... done
[16:04:46.281] result() for ClusterFuture ...
[16:04:46.281] - result already collected: FutureResult
[16:04:46.281] result() for ClusterFuture ... done
[16:04:46.282] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.282] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.282] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:46.282]  length: 3 (resolved future 3)
[16:04:46.292] signalConditionsASAP(NULL, pos=5) ...
[16:04:46.292] - nx: 6
[16:04:46.293] - relay: TRUE
[16:04:46.293] - stdout: TRUE
[16:04:46.293] - signal: TRUE
[16:04:46.293] - resignal: FALSE
[16:04:46.293] - force: TRUE
[16:04:46.293] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.293] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.293]  - until=6
[16:04:46.293]  - relaying element #4
[16:04:46.293]  - relaying element #6
[16:04:46.294] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:04:46.294] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.294] signalConditionsASAP(NULL, pos=5) ... done
[16:04:46.294]  length: 2 (resolved future 5)
[16:04:46.294] signalConditionsASAP(numeric, pos=6) ...
[16:04:46.294] - nx: 6
[16:04:46.294] - relay: TRUE
[16:04:46.294] - stdout: TRUE
[16:04:46.294] - signal: TRUE
[16:04:46.294] - resignal: FALSE
[16:04:46.294] - force: TRUE
[16:04:46.295] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:04:46.295] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.295]  - until=6
[16:04:46.295]  - relaying element #4
[16:04:46.295] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:04:46.295] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.295] signalConditionsASAP(NULL, pos=6) ... done
[16:04:46.295]  length: 1 (resolved future 6)
[16:04:46.306] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.306] - Validating connection of MultisessionFuture
[16:04:46.306] - received message: FutureResult
[16:04:46.306] - Received FutureResult
[16:04:46.306] - Erased future from FutureRegistry
[16:04:46.307] result() for ClusterFuture ...
[16:04:46.307] - result already collected: FutureResult
[16:04:46.307] result() for ClusterFuture ... done
[16:04:46.307] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:46.307] Future #4
[16:04:46.307] result() for ClusterFuture ...
[16:04:46.307] - result already collected: FutureResult
[16:04:46.307] result() for ClusterFuture ... done
[16:04:46.307] result() for ClusterFuture ...
[16:04:46.307] - result already collected: FutureResult
[16:04:46.307] result() for ClusterFuture ... done
[16:04:46.308] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:04:46.308] - nx: 6
[16:04:46.308] - relay: TRUE
[16:04:46.308] - stdout: TRUE
[16:04:46.308] - signal: TRUE
[16:04:46.308] - resignal: FALSE
[16:04:46.308] - force: TRUE
[16:04:46.308] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:04:46.308] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.308]  - until=6
[16:04:46.308]  - relaying element #4
[16:04:46.308] result() for ClusterFuture ...
[16:04:46.309] - result already collected: FutureResult
[16:04:46.309] result() for ClusterFuture ... done
[16:04:46.309] result() for ClusterFuture ...
[16:04:46.309] - result already collected: FutureResult
[16:04:46.309] result() for ClusterFuture ... done
[16:04:46.309] result() for ClusterFuture ...
[16:04:46.309] - result already collected: FutureResult
[16:04:46.309] result() for ClusterFuture ... done
[16:04:46.309] result() for ClusterFuture ...
[16:04:46.309] - result already collected: FutureResult
[16:04:46.309] result() for ClusterFuture ... done
[16:04:46.309] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.310] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.310] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:04:46.310]  length: 0 (resolved future 4)
[16:04:46.310] Relaying remaining futures
[16:04:46.310] signalConditionsASAP(NULL, pos=0) ...
[16:04:46.310] - nx: 6
[16:04:46.310] - relay: TRUE
[16:04:46.310] - stdout: TRUE
[16:04:46.310] - signal: TRUE
[16:04:46.310] - resignal: FALSE
[16:04:46.310] - force: TRUE
[16:04:46.310] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.311] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:46.311] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.311] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.311] signalConditionsASAP(NULL, pos=0) ... done
[16:04:46.311] resolve() on list environment ... DONE
[16:04:46.311] result() for ClusterFuture ...
[16:04:46.311] - result already collected: FutureResult
[16:04:46.311] result() for ClusterFuture ... done
[16:04:46.311] result() for ClusterFuture ...
[16:04:46.311] - result already collected: FutureResult
[16:04:46.312] result() for ClusterFuture ... done
[16:04:46.312] result() for ClusterFuture ...
[16:04:46.312] - result already collected: FutureResult
[16:04:46.312] result() for ClusterFuture ... done
[16:04:46.312] result() for ClusterFuture ...
[16:04:46.312] - result already collected: FutureResult
[16:04:46.312] result() for ClusterFuture ... done
[16:04:46.312] result() for ClusterFuture ...
[16:04:46.312] - result already collected: FutureResult
[16:04:46.312] result() for ClusterFuture ... done
[16:04:46.313] result() for ClusterFuture ...
[16:04:46.313] - result already collected: FutureResult
[16:04:46.313] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55874da12cb0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:04:46.314] getGlobalsAndPackages() ...
[16:04:46.314] Searching for globals...
[16:04:46.315] 
[16:04:46.315] Searching for globals ... DONE
[16:04:46.315] - globals: [0] <none>
[16:04:46.315] getGlobalsAndPackages() ... DONE
[16:04:46.315] run() for ‘Future’ ...
[16:04:46.315] - state: ‘created’
[16:04:46.316] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:46.329] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:46.329] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:46.329]   - Field: ‘node’
[16:04:46.329]   - Field: ‘label’
[16:04:46.329]   - Field: ‘local’
[16:04:46.329]   - Field: ‘owner’
[16:04:46.330]   - Field: ‘envir’
[16:04:46.330]   - Field: ‘workers’
[16:04:46.330]   - Field: ‘packages’
[16:04:46.330]   - Field: ‘gc’
[16:04:46.330]   - Field: ‘conditions’
[16:04:46.330]   - Field: ‘persistent’
[16:04:46.330]   - Field: ‘expr’
[16:04:46.330]   - Field: ‘uuid’
[16:04:46.330]   - Field: ‘seed’
[16:04:46.330]   - Field: ‘version’
[16:04:46.330]   - Field: ‘result’
[16:04:46.330]   - Field: ‘asynchronous’
[16:04:46.331]   - Field: ‘calls’
[16:04:46.331]   - Field: ‘globals’
[16:04:46.331]   - Field: ‘stdout’
[16:04:46.331]   - Field: ‘earlySignal’
[16:04:46.331]   - Field: ‘lazy’
[16:04:46.331]   - Field: ‘state’
[16:04:46.331] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:46.331] - Launch lazy future ...
[16:04:46.332] Packages needed by the future expression (n = 0): <none>
[16:04:46.332] Packages needed by future strategies (n = 0): <none>
[16:04:46.332] {
[16:04:46.332]     {
[16:04:46.332]         {
[16:04:46.332]             ...future.startTime <- base::Sys.time()
[16:04:46.332]             {
[16:04:46.332]                 {
[16:04:46.332]                   {
[16:04:46.332]                     {
[16:04:46.332]                       base::local({
[16:04:46.332]                         has_future <- base::requireNamespace("future", 
[16:04:46.332]                           quietly = TRUE)
[16:04:46.332]                         if (has_future) {
[16:04:46.332]                           ns <- base::getNamespace("future")
[16:04:46.332]                           version <- ns[[".package"]][["version"]]
[16:04:46.332]                           if (is.null(version)) 
[16:04:46.332]                             version <- utils::packageVersion("future")
[16:04:46.332]                         }
[16:04:46.332]                         else {
[16:04:46.332]                           version <- NULL
[16:04:46.332]                         }
[16:04:46.332]                         if (!has_future || version < "1.8.0") {
[16:04:46.332]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:46.332]                             "", base::R.version$version.string), 
[16:04:46.332]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:46.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:46.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:46.332]                               "release", "version")], collapse = " "), 
[16:04:46.332]                             hostname = base::Sys.info()[["nodename"]])
[16:04:46.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:46.332]                             info)
[16:04:46.332]                           info <- base::paste(info, collapse = "; ")
[16:04:46.332]                           if (!has_future) {
[16:04:46.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:46.332]                               info)
[16:04:46.332]                           }
[16:04:46.332]                           else {
[16:04:46.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:46.332]                               info, version)
[16:04:46.332]                           }
[16:04:46.332]                           base::stop(msg)
[16:04:46.332]                         }
[16:04:46.332]                       })
[16:04:46.332]                     }
[16:04:46.332]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:46.332]                     base::options(mc.cores = 1L)
[16:04:46.332]                   }
[16:04:46.332]                   options(future.plan = NULL)
[16:04:46.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:46.332]                 }
[16:04:46.332]                 ...future.workdir <- getwd()
[16:04:46.332]             }
[16:04:46.332]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:46.332]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:46.332]         }
[16:04:46.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:46.332]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:46.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:46.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:46.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:46.332]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:46.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:46.332]             base::names(...future.oldOptions))
[16:04:46.332]     }
[16:04:46.332]     if (FALSE) {
[16:04:46.332]     }
[16:04:46.332]     else {
[16:04:46.332]         if (TRUE) {
[16:04:46.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:46.332]                 open = "w")
[16:04:46.332]         }
[16:04:46.332]         else {
[16:04:46.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:46.332]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:46.332]         }
[16:04:46.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:46.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:46.332]             base::sink(type = "output", split = FALSE)
[16:04:46.332]             base::close(...future.stdout)
[16:04:46.332]         }, add = TRUE)
[16:04:46.332]     }
[16:04:46.332]     ...future.frame <- base::sys.nframe()
[16:04:46.332]     ...future.conditions <- base::list()
[16:04:46.332]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:46.332]     if (FALSE) {
[16:04:46.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:46.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:46.332]     }
[16:04:46.332]     ...future.result <- base::tryCatch({
[16:04:46.332]         base::withCallingHandlers({
[16:04:46.332]             ...future.value <- base::withVisible(base::local({
[16:04:46.332]                 ...future.makeSendCondition <- base::local({
[16:04:46.332]                   sendCondition <- NULL
[16:04:46.332]                   function(frame = 1L) {
[16:04:46.332]                     if (is.function(sendCondition)) 
[16:04:46.332]                       return(sendCondition)
[16:04:46.332]                     ns <- getNamespace("parallel")
[16:04:46.332]                     if (exists("sendData", mode = "function", 
[16:04:46.332]                       envir = ns)) {
[16:04:46.332]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:46.332]                         envir = ns)
[16:04:46.332]                       envir <- sys.frame(frame)
[16:04:46.332]                       master <- NULL
[16:04:46.332]                       while (!identical(envir, .GlobalEnv) && 
[16:04:46.332]                         !identical(envir, emptyenv())) {
[16:04:46.332]                         if (exists("master", mode = "list", envir = envir, 
[16:04:46.332]                           inherits = FALSE)) {
[16:04:46.332]                           master <- get("master", mode = "list", 
[16:04:46.332]                             envir = envir, inherits = FALSE)
[16:04:46.332]                           if (inherits(master, c("SOCKnode", 
[16:04:46.332]                             "SOCK0node"))) {
[16:04:46.332]                             sendCondition <<- function(cond) {
[16:04:46.332]                               data <- list(type = "VALUE", value = cond, 
[16:04:46.332]                                 success = TRUE)
[16:04:46.332]                               parallel_sendData(master, data)
[16:04:46.332]                             }
[16:04:46.332]                             return(sendCondition)
[16:04:46.332]                           }
[16:04:46.332]                         }
[16:04:46.332]                         frame <- frame + 1L
[16:04:46.332]                         envir <- sys.frame(frame)
[16:04:46.332]                       }
[16:04:46.332]                     }
[16:04:46.332]                     sendCondition <<- function(cond) NULL
[16:04:46.332]                   }
[16:04:46.332]                 })
[16:04:46.332]                 withCallingHandlers({
[16:04:46.332]                   2
[16:04:46.332]                 }, immediateCondition = function(cond) {
[16:04:46.332]                   sendCondition <- ...future.makeSendCondition()
[16:04:46.332]                   sendCondition(cond)
[16:04:46.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.332]                   {
[16:04:46.332]                     inherits <- base::inherits
[16:04:46.332]                     invokeRestart <- base::invokeRestart
[16:04:46.332]                     is.null <- base::is.null
[16:04:46.332]                     muffled <- FALSE
[16:04:46.332]                     if (inherits(cond, "message")) {
[16:04:46.332]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:46.332]                       if (muffled) 
[16:04:46.332]                         invokeRestart("muffleMessage")
[16:04:46.332]                     }
[16:04:46.332]                     else if (inherits(cond, "warning")) {
[16:04:46.332]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:46.332]                       if (muffled) 
[16:04:46.332]                         invokeRestart("muffleWarning")
[16:04:46.332]                     }
[16:04:46.332]                     else if (inherits(cond, "condition")) {
[16:04:46.332]                       if (!is.null(pattern)) {
[16:04:46.332]                         computeRestarts <- base::computeRestarts
[16:04:46.332]                         grepl <- base::grepl
[16:04:46.332]                         restarts <- computeRestarts(cond)
[16:04:46.332]                         for (restart in restarts) {
[16:04:46.332]                           name <- restart$name
[16:04:46.332]                           if (is.null(name)) 
[16:04:46.332]                             next
[16:04:46.332]                           if (!grepl(pattern, name)) 
[16:04:46.332]                             next
[16:04:46.332]                           invokeRestart(restart)
[16:04:46.332]                           muffled <- TRUE
[16:04:46.332]                           break
[16:04:46.332]                         }
[16:04:46.332]                       }
[16:04:46.332]                     }
[16:04:46.332]                     invisible(muffled)
[16:04:46.332]                   }
[16:04:46.332]                   muffleCondition(cond)
[16:04:46.332]                 })
[16:04:46.332]             }))
[16:04:46.332]             future::FutureResult(value = ...future.value$value, 
[16:04:46.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.332]                   ...future.rng), globalenv = if (FALSE) 
[16:04:46.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:46.332]                     ...future.globalenv.names))
[16:04:46.332]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:46.332]         }, condition = base::local({
[16:04:46.332]             c <- base::c
[16:04:46.332]             inherits <- base::inherits
[16:04:46.332]             invokeRestart <- base::invokeRestart
[16:04:46.332]             length <- base::length
[16:04:46.332]             list <- base::list
[16:04:46.332]             seq.int <- base::seq.int
[16:04:46.332]             signalCondition <- base::signalCondition
[16:04:46.332]             sys.calls <- base::sys.calls
[16:04:46.332]             `[[` <- base::`[[`
[16:04:46.332]             `+` <- base::`+`
[16:04:46.332]             `<<-` <- base::`<<-`
[16:04:46.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:46.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:46.332]                   3L)]
[16:04:46.332]             }
[16:04:46.332]             function(cond) {
[16:04:46.332]                 is_error <- inherits(cond, "error")
[16:04:46.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:46.332]                   NULL)
[16:04:46.332]                 if (is_error) {
[16:04:46.332]                   sessionInformation <- function() {
[16:04:46.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:46.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:46.332]                       search = base::search(), system = base::Sys.info())
[16:04:46.332]                   }
[16:04:46.332]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:46.332]                     cond$call), session = sessionInformation(), 
[16:04:46.332]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:46.332]                   signalCondition(cond)
[16:04:46.332]                 }
[16:04:46.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:46.332]                 "immediateCondition"))) {
[16:04:46.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:46.332]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:46.332]                   if (TRUE && !signal) {
[16:04:46.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.332]                     {
[16:04:46.332]                       inherits <- base::inherits
[16:04:46.332]                       invokeRestart <- base::invokeRestart
[16:04:46.332]                       is.null <- base::is.null
[16:04:46.332]                       muffled <- FALSE
[16:04:46.332]                       if (inherits(cond, "message")) {
[16:04:46.332]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.332]                         if (muffled) 
[16:04:46.332]                           invokeRestart("muffleMessage")
[16:04:46.332]                       }
[16:04:46.332]                       else if (inherits(cond, "warning")) {
[16:04:46.332]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.332]                         if (muffled) 
[16:04:46.332]                           invokeRestart("muffleWarning")
[16:04:46.332]                       }
[16:04:46.332]                       else if (inherits(cond, "condition")) {
[16:04:46.332]                         if (!is.null(pattern)) {
[16:04:46.332]                           computeRestarts <- base::computeRestarts
[16:04:46.332]                           grepl <- base::grepl
[16:04:46.332]                           restarts <- computeRestarts(cond)
[16:04:46.332]                           for (restart in restarts) {
[16:04:46.332]                             name <- restart$name
[16:04:46.332]                             if (is.null(name)) 
[16:04:46.332]                               next
[16:04:46.332]                             if (!grepl(pattern, name)) 
[16:04:46.332]                               next
[16:04:46.332]                             invokeRestart(restart)
[16:04:46.332]                             muffled <- TRUE
[16:04:46.332]                             break
[16:04:46.332]                           }
[16:04:46.332]                         }
[16:04:46.332]                       }
[16:04:46.332]                       invisible(muffled)
[16:04:46.332]                     }
[16:04:46.332]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.332]                   }
[16:04:46.332]                 }
[16:04:46.332]                 else {
[16:04:46.332]                   if (TRUE) {
[16:04:46.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.332]                     {
[16:04:46.332]                       inherits <- base::inherits
[16:04:46.332]                       invokeRestart <- base::invokeRestart
[16:04:46.332]                       is.null <- base::is.null
[16:04:46.332]                       muffled <- FALSE
[16:04:46.332]                       if (inherits(cond, "message")) {
[16:04:46.332]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.332]                         if (muffled) 
[16:04:46.332]                           invokeRestart("muffleMessage")
[16:04:46.332]                       }
[16:04:46.332]                       else if (inherits(cond, "warning")) {
[16:04:46.332]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.332]                         if (muffled) 
[16:04:46.332]                           invokeRestart("muffleWarning")
[16:04:46.332]                       }
[16:04:46.332]                       else if (inherits(cond, "condition")) {
[16:04:46.332]                         if (!is.null(pattern)) {
[16:04:46.332]                           computeRestarts <- base::computeRestarts
[16:04:46.332]                           grepl <- base::grepl
[16:04:46.332]                           restarts <- computeRestarts(cond)
[16:04:46.332]                           for (restart in restarts) {
[16:04:46.332]                             name <- restart$name
[16:04:46.332]                             if (is.null(name)) 
[16:04:46.332]                               next
[16:04:46.332]                             if (!grepl(pattern, name)) 
[16:04:46.332]                               next
[16:04:46.332]                             invokeRestart(restart)
[16:04:46.332]                             muffled <- TRUE
[16:04:46.332]                             break
[16:04:46.332]                           }
[16:04:46.332]                         }
[16:04:46.332]                       }
[16:04:46.332]                       invisible(muffled)
[16:04:46.332]                     }
[16:04:46.332]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.332]                   }
[16:04:46.332]                 }
[16:04:46.332]             }
[16:04:46.332]         }))
[16:04:46.332]     }, error = function(ex) {
[16:04:46.332]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:46.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.332]                 ...future.rng), started = ...future.startTime, 
[16:04:46.332]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:46.332]             version = "1.8"), class = "FutureResult")
[16:04:46.332]     }, finally = {
[16:04:46.332]         if (!identical(...future.workdir, getwd())) 
[16:04:46.332]             setwd(...future.workdir)
[16:04:46.332]         {
[16:04:46.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:46.332]                 ...future.oldOptions$nwarnings <- NULL
[16:04:46.332]             }
[16:04:46.332]             base::options(...future.oldOptions)
[16:04:46.332]             if (.Platform$OS.type == "windows") {
[16:04:46.332]                 old_names <- names(...future.oldEnvVars)
[16:04:46.332]                 envs <- base::Sys.getenv()
[16:04:46.332]                 names <- names(envs)
[16:04:46.332]                 common <- intersect(names, old_names)
[16:04:46.332]                 added <- setdiff(names, old_names)
[16:04:46.332]                 removed <- setdiff(old_names, names)
[16:04:46.332]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:46.332]                   envs[common]]
[16:04:46.332]                 NAMES <- toupper(changed)
[16:04:46.332]                 args <- list()
[16:04:46.332]                 for (kk in seq_along(NAMES)) {
[16:04:46.332]                   name <- changed[[kk]]
[16:04:46.332]                   NAME <- NAMES[[kk]]
[16:04:46.332]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.332]                     next
[16:04:46.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.332]                 }
[16:04:46.332]                 NAMES <- toupper(added)
[16:04:46.332]                 for (kk in seq_along(NAMES)) {
[16:04:46.332]                   name <- added[[kk]]
[16:04:46.332]                   NAME <- NAMES[[kk]]
[16:04:46.332]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.332]                     next
[16:04:46.332]                   args[[name]] <- ""
[16:04:46.332]                 }
[16:04:46.332]                 NAMES <- toupper(removed)
[16:04:46.332]                 for (kk in seq_along(NAMES)) {
[16:04:46.332]                   name <- removed[[kk]]
[16:04:46.332]                   NAME <- NAMES[[kk]]
[16:04:46.332]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.332]                     next
[16:04:46.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.332]                 }
[16:04:46.332]                 if (length(args) > 0) 
[16:04:46.332]                   base::do.call(base::Sys.setenv, args = args)
[16:04:46.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:46.332]             }
[16:04:46.332]             else {
[16:04:46.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:46.332]             }
[16:04:46.332]             {
[16:04:46.332]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:46.332]                   0L) {
[16:04:46.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:46.332]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:46.332]                   base::options(opts)
[16:04:46.332]                 }
[16:04:46.332]                 {
[16:04:46.332]                   {
[16:04:46.332]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:46.332]                     NULL
[16:04:46.332]                   }
[16:04:46.332]                   options(future.plan = NULL)
[16:04:46.332]                   if (is.na(NA_character_)) 
[16:04:46.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:46.332]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:46.332]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:46.332]                     envir = parent.frame()) 
[16:04:46.332]                   {
[16:04:46.332]                     if (is.function(workers)) 
[16:04:46.332]                       workers <- workers()
[16:04:46.332]                     workers <- structure(as.integer(workers), 
[16:04:46.332]                       class = class(workers))
[16:04:46.332]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:46.332]                       workers >= 1)
[16:04:46.332]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:46.332]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:46.332]                     }
[16:04:46.332]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:46.332]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:46.332]                       envir = envir)
[16:04:46.332]                     if (!future$lazy) 
[16:04:46.332]                       future <- run(future)
[16:04:46.332]                     invisible(future)
[16:04:46.332]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:46.332]                 }
[16:04:46.332]             }
[16:04:46.332]         }
[16:04:46.332]     })
[16:04:46.332]     if (TRUE) {
[16:04:46.332]         base::sink(type = "output", split = FALSE)
[16:04:46.332]         if (TRUE) {
[16:04:46.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:46.332]         }
[16:04:46.332]         else {
[16:04:46.332]             ...future.result["stdout"] <- base::list(NULL)
[16:04:46.332]         }
[16:04:46.332]         base::close(...future.stdout)
[16:04:46.332]         ...future.stdout <- NULL
[16:04:46.332]     }
[16:04:46.332]     ...future.result$conditions <- ...future.conditions
[16:04:46.332]     ...future.result$finished <- base::Sys.time()
[16:04:46.332]     ...future.result
[16:04:46.332] }
[16:04:46.335] MultisessionFuture started
[16:04:46.335] - Launch lazy future ... done
[16:04:46.335] run() for ‘MultisessionFuture’ ... done
[16:04:46.335] getGlobalsAndPackages() ...
[16:04:46.336] Searching for globals...
[16:04:46.336] 
[16:04:46.336] Searching for globals ... DONE
[16:04:46.336] - globals: [0] <none>
[16:04:46.336] getGlobalsAndPackages() ... DONE
[16:04:46.336] run() for ‘Future’ ...
[16:04:46.336] - state: ‘created’
[16:04:46.337] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:46.350] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:46.351] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:46.351]   - Field: ‘node’
[16:04:46.351]   - Field: ‘label’
[16:04:46.351]   - Field: ‘local’
[16:04:46.351]   - Field: ‘owner’
[16:04:46.351]   - Field: ‘envir’
[16:04:46.351]   - Field: ‘workers’
[16:04:46.351]   - Field: ‘packages’
[16:04:46.351]   - Field: ‘gc’
[16:04:46.351]   - Field: ‘conditions’
[16:04:46.352]   - Field: ‘persistent’
[16:04:46.352]   - Field: ‘expr’
[16:04:46.352]   - Field: ‘uuid’
[16:04:46.352]   - Field: ‘seed’
[16:04:46.352]   - Field: ‘version’
[16:04:46.352]   - Field: ‘result’
[16:04:46.352]   - Field: ‘asynchronous’
[16:04:46.352]   - Field: ‘calls’
[16:04:46.352]   - Field: ‘globals’
[16:04:46.352]   - Field: ‘stdout’
[16:04:46.352]   - Field: ‘earlySignal’
[16:04:46.353]   - Field: ‘lazy’
[16:04:46.353]   - Field: ‘state’
[16:04:46.353] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:46.353] - Launch lazy future ...
[16:04:46.353] Packages needed by the future expression (n = 0): <none>
[16:04:46.353] Packages needed by future strategies (n = 0): <none>
[16:04:46.354] {
[16:04:46.354]     {
[16:04:46.354]         {
[16:04:46.354]             ...future.startTime <- base::Sys.time()
[16:04:46.354]             {
[16:04:46.354]                 {
[16:04:46.354]                   {
[16:04:46.354]                     {
[16:04:46.354]                       base::local({
[16:04:46.354]                         has_future <- base::requireNamespace("future", 
[16:04:46.354]                           quietly = TRUE)
[16:04:46.354]                         if (has_future) {
[16:04:46.354]                           ns <- base::getNamespace("future")
[16:04:46.354]                           version <- ns[[".package"]][["version"]]
[16:04:46.354]                           if (is.null(version)) 
[16:04:46.354]                             version <- utils::packageVersion("future")
[16:04:46.354]                         }
[16:04:46.354]                         else {
[16:04:46.354]                           version <- NULL
[16:04:46.354]                         }
[16:04:46.354]                         if (!has_future || version < "1.8.0") {
[16:04:46.354]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:46.354]                             "", base::R.version$version.string), 
[16:04:46.354]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:46.354]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:46.354]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:46.354]                               "release", "version")], collapse = " "), 
[16:04:46.354]                             hostname = base::Sys.info()[["nodename"]])
[16:04:46.354]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:46.354]                             info)
[16:04:46.354]                           info <- base::paste(info, collapse = "; ")
[16:04:46.354]                           if (!has_future) {
[16:04:46.354]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:46.354]                               info)
[16:04:46.354]                           }
[16:04:46.354]                           else {
[16:04:46.354]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:46.354]                               info, version)
[16:04:46.354]                           }
[16:04:46.354]                           base::stop(msg)
[16:04:46.354]                         }
[16:04:46.354]                       })
[16:04:46.354]                     }
[16:04:46.354]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:46.354]                     base::options(mc.cores = 1L)
[16:04:46.354]                   }
[16:04:46.354]                   options(future.plan = NULL)
[16:04:46.354]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.354]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:46.354]                 }
[16:04:46.354]                 ...future.workdir <- getwd()
[16:04:46.354]             }
[16:04:46.354]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:46.354]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:46.354]         }
[16:04:46.354]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:46.354]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:46.354]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:46.354]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:46.354]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:46.354]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:46.354]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:46.354]             base::names(...future.oldOptions))
[16:04:46.354]     }
[16:04:46.354]     if (FALSE) {
[16:04:46.354]     }
[16:04:46.354]     else {
[16:04:46.354]         if (TRUE) {
[16:04:46.354]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:46.354]                 open = "w")
[16:04:46.354]         }
[16:04:46.354]         else {
[16:04:46.354]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:46.354]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:46.354]         }
[16:04:46.354]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:46.354]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:46.354]             base::sink(type = "output", split = FALSE)
[16:04:46.354]             base::close(...future.stdout)
[16:04:46.354]         }, add = TRUE)
[16:04:46.354]     }
[16:04:46.354]     ...future.frame <- base::sys.nframe()
[16:04:46.354]     ...future.conditions <- base::list()
[16:04:46.354]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:46.354]     if (FALSE) {
[16:04:46.354]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:46.354]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:46.354]     }
[16:04:46.354]     ...future.result <- base::tryCatch({
[16:04:46.354]         base::withCallingHandlers({
[16:04:46.354]             ...future.value <- base::withVisible(base::local({
[16:04:46.354]                 ...future.makeSendCondition <- base::local({
[16:04:46.354]                   sendCondition <- NULL
[16:04:46.354]                   function(frame = 1L) {
[16:04:46.354]                     if (is.function(sendCondition)) 
[16:04:46.354]                       return(sendCondition)
[16:04:46.354]                     ns <- getNamespace("parallel")
[16:04:46.354]                     if (exists("sendData", mode = "function", 
[16:04:46.354]                       envir = ns)) {
[16:04:46.354]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:46.354]                         envir = ns)
[16:04:46.354]                       envir <- sys.frame(frame)
[16:04:46.354]                       master <- NULL
[16:04:46.354]                       while (!identical(envir, .GlobalEnv) && 
[16:04:46.354]                         !identical(envir, emptyenv())) {
[16:04:46.354]                         if (exists("master", mode = "list", envir = envir, 
[16:04:46.354]                           inherits = FALSE)) {
[16:04:46.354]                           master <- get("master", mode = "list", 
[16:04:46.354]                             envir = envir, inherits = FALSE)
[16:04:46.354]                           if (inherits(master, c("SOCKnode", 
[16:04:46.354]                             "SOCK0node"))) {
[16:04:46.354]                             sendCondition <<- function(cond) {
[16:04:46.354]                               data <- list(type = "VALUE", value = cond, 
[16:04:46.354]                                 success = TRUE)
[16:04:46.354]                               parallel_sendData(master, data)
[16:04:46.354]                             }
[16:04:46.354]                             return(sendCondition)
[16:04:46.354]                           }
[16:04:46.354]                         }
[16:04:46.354]                         frame <- frame + 1L
[16:04:46.354]                         envir <- sys.frame(frame)
[16:04:46.354]                       }
[16:04:46.354]                     }
[16:04:46.354]                     sendCondition <<- function(cond) NULL
[16:04:46.354]                   }
[16:04:46.354]                 })
[16:04:46.354]                 withCallingHandlers({
[16:04:46.354]                   NULL
[16:04:46.354]                 }, immediateCondition = function(cond) {
[16:04:46.354]                   sendCondition <- ...future.makeSendCondition()
[16:04:46.354]                   sendCondition(cond)
[16:04:46.354]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.354]                   {
[16:04:46.354]                     inherits <- base::inherits
[16:04:46.354]                     invokeRestart <- base::invokeRestart
[16:04:46.354]                     is.null <- base::is.null
[16:04:46.354]                     muffled <- FALSE
[16:04:46.354]                     if (inherits(cond, "message")) {
[16:04:46.354]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:46.354]                       if (muffled) 
[16:04:46.354]                         invokeRestart("muffleMessage")
[16:04:46.354]                     }
[16:04:46.354]                     else if (inherits(cond, "warning")) {
[16:04:46.354]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:46.354]                       if (muffled) 
[16:04:46.354]                         invokeRestart("muffleWarning")
[16:04:46.354]                     }
[16:04:46.354]                     else if (inherits(cond, "condition")) {
[16:04:46.354]                       if (!is.null(pattern)) {
[16:04:46.354]                         computeRestarts <- base::computeRestarts
[16:04:46.354]                         grepl <- base::grepl
[16:04:46.354]                         restarts <- computeRestarts(cond)
[16:04:46.354]                         for (restart in restarts) {
[16:04:46.354]                           name <- restart$name
[16:04:46.354]                           if (is.null(name)) 
[16:04:46.354]                             next
[16:04:46.354]                           if (!grepl(pattern, name)) 
[16:04:46.354]                             next
[16:04:46.354]                           invokeRestart(restart)
[16:04:46.354]                           muffled <- TRUE
[16:04:46.354]                           break
[16:04:46.354]                         }
[16:04:46.354]                       }
[16:04:46.354]                     }
[16:04:46.354]                     invisible(muffled)
[16:04:46.354]                   }
[16:04:46.354]                   muffleCondition(cond)
[16:04:46.354]                 })
[16:04:46.354]             }))
[16:04:46.354]             future::FutureResult(value = ...future.value$value, 
[16:04:46.354]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.354]                   ...future.rng), globalenv = if (FALSE) 
[16:04:46.354]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:46.354]                     ...future.globalenv.names))
[16:04:46.354]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:46.354]         }, condition = base::local({
[16:04:46.354]             c <- base::c
[16:04:46.354]             inherits <- base::inherits
[16:04:46.354]             invokeRestart <- base::invokeRestart
[16:04:46.354]             length <- base::length
[16:04:46.354]             list <- base::list
[16:04:46.354]             seq.int <- base::seq.int
[16:04:46.354]             signalCondition <- base::signalCondition
[16:04:46.354]             sys.calls <- base::sys.calls
[16:04:46.354]             `[[` <- base::`[[`
[16:04:46.354]             `+` <- base::`+`
[16:04:46.354]             `<<-` <- base::`<<-`
[16:04:46.354]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:46.354]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:46.354]                   3L)]
[16:04:46.354]             }
[16:04:46.354]             function(cond) {
[16:04:46.354]                 is_error <- inherits(cond, "error")
[16:04:46.354]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:46.354]                   NULL)
[16:04:46.354]                 if (is_error) {
[16:04:46.354]                   sessionInformation <- function() {
[16:04:46.354]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:46.354]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:46.354]                       search = base::search(), system = base::Sys.info())
[16:04:46.354]                   }
[16:04:46.354]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.354]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:46.354]                     cond$call), session = sessionInformation(), 
[16:04:46.354]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:46.354]                   signalCondition(cond)
[16:04:46.354]                 }
[16:04:46.354]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:46.354]                 "immediateCondition"))) {
[16:04:46.354]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:46.354]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.354]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:46.354]                   if (TRUE && !signal) {
[16:04:46.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.354]                     {
[16:04:46.354]                       inherits <- base::inherits
[16:04:46.354]                       invokeRestart <- base::invokeRestart
[16:04:46.354]                       is.null <- base::is.null
[16:04:46.354]                       muffled <- FALSE
[16:04:46.354]                       if (inherits(cond, "message")) {
[16:04:46.354]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.354]                         if (muffled) 
[16:04:46.354]                           invokeRestart("muffleMessage")
[16:04:46.354]                       }
[16:04:46.354]                       else if (inherits(cond, "warning")) {
[16:04:46.354]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.354]                         if (muffled) 
[16:04:46.354]                           invokeRestart("muffleWarning")
[16:04:46.354]                       }
[16:04:46.354]                       else if (inherits(cond, "condition")) {
[16:04:46.354]                         if (!is.null(pattern)) {
[16:04:46.354]                           computeRestarts <- base::computeRestarts
[16:04:46.354]                           grepl <- base::grepl
[16:04:46.354]                           restarts <- computeRestarts(cond)
[16:04:46.354]                           for (restart in restarts) {
[16:04:46.354]                             name <- restart$name
[16:04:46.354]                             if (is.null(name)) 
[16:04:46.354]                               next
[16:04:46.354]                             if (!grepl(pattern, name)) 
[16:04:46.354]                               next
[16:04:46.354]                             invokeRestart(restart)
[16:04:46.354]                             muffled <- TRUE
[16:04:46.354]                             break
[16:04:46.354]                           }
[16:04:46.354]                         }
[16:04:46.354]                       }
[16:04:46.354]                       invisible(muffled)
[16:04:46.354]                     }
[16:04:46.354]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.354]                   }
[16:04:46.354]                 }
[16:04:46.354]                 else {
[16:04:46.354]                   if (TRUE) {
[16:04:46.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.354]                     {
[16:04:46.354]                       inherits <- base::inherits
[16:04:46.354]                       invokeRestart <- base::invokeRestart
[16:04:46.354]                       is.null <- base::is.null
[16:04:46.354]                       muffled <- FALSE
[16:04:46.354]                       if (inherits(cond, "message")) {
[16:04:46.354]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.354]                         if (muffled) 
[16:04:46.354]                           invokeRestart("muffleMessage")
[16:04:46.354]                       }
[16:04:46.354]                       else if (inherits(cond, "warning")) {
[16:04:46.354]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.354]                         if (muffled) 
[16:04:46.354]                           invokeRestart("muffleWarning")
[16:04:46.354]                       }
[16:04:46.354]                       else if (inherits(cond, "condition")) {
[16:04:46.354]                         if (!is.null(pattern)) {
[16:04:46.354]                           computeRestarts <- base::computeRestarts
[16:04:46.354]                           grepl <- base::grepl
[16:04:46.354]                           restarts <- computeRestarts(cond)
[16:04:46.354]                           for (restart in restarts) {
[16:04:46.354]                             name <- restart$name
[16:04:46.354]                             if (is.null(name)) 
[16:04:46.354]                               next
[16:04:46.354]                             if (!grepl(pattern, name)) 
[16:04:46.354]                               next
[16:04:46.354]                             invokeRestart(restart)
[16:04:46.354]                             muffled <- TRUE
[16:04:46.354]                             break
[16:04:46.354]                           }
[16:04:46.354]                         }
[16:04:46.354]                       }
[16:04:46.354]                       invisible(muffled)
[16:04:46.354]                     }
[16:04:46.354]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.354]                   }
[16:04:46.354]                 }
[16:04:46.354]             }
[16:04:46.354]         }))
[16:04:46.354]     }, error = function(ex) {
[16:04:46.354]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:46.354]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.354]                 ...future.rng), started = ...future.startTime, 
[16:04:46.354]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:46.354]             version = "1.8"), class = "FutureResult")
[16:04:46.354]     }, finally = {
[16:04:46.354]         if (!identical(...future.workdir, getwd())) 
[16:04:46.354]             setwd(...future.workdir)
[16:04:46.354]         {
[16:04:46.354]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:46.354]                 ...future.oldOptions$nwarnings <- NULL
[16:04:46.354]             }
[16:04:46.354]             base::options(...future.oldOptions)
[16:04:46.354]             if (.Platform$OS.type == "windows") {
[16:04:46.354]                 old_names <- names(...future.oldEnvVars)
[16:04:46.354]                 envs <- base::Sys.getenv()
[16:04:46.354]                 names <- names(envs)
[16:04:46.354]                 common <- intersect(names, old_names)
[16:04:46.354]                 added <- setdiff(names, old_names)
[16:04:46.354]                 removed <- setdiff(old_names, names)
[16:04:46.354]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:46.354]                   envs[common]]
[16:04:46.354]                 NAMES <- toupper(changed)
[16:04:46.354]                 args <- list()
[16:04:46.354]                 for (kk in seq_along(NAMES)) {
[16:04:46.354]                   name <- changed[[kk]]
[16:04:46.354]                   NAME <- NAMES[[kk]]
[16:04:46.354]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.354]                     next
[16:04:46.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.354]                 }
[16:04:46.354]                 NAMES <- toupper(added)
[16:04:46.354]                 for (kk in seq_along(NAMES)) {
[16:04:46.354]                   name <- added[[kk]]
[16:04:46.354]                   NAME <- NAMES[[kk]]
[16:04:46.354]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.354]                     next
[16:04:46.354]                   args[[name]] <- ""
[16:04:46.354]                 }
[16:04:46.354]                 NAMES <- toupper(removed)
[16:04:46.354]                 for (kk in seq_along(NAMES)) {
[16:04:46.354]                   name <- removed[[kk]]
[16:04:46.354]                   NAME <- NAMES[[kk]]
[16:04:46.354]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.354]                     next
[16:04:46.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.354]                 }
[16:04:46.354]                 if (length(args) > 0) 
[16:04:46.354]                   base::do.call(base::Sys.setenv, args = args)
[16:04:46.354]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:46.354]             }
[16:04:46.354]             else {
[16:04:46.354]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:46.354]             }
[16:04:46.354]             {
[16:04:46.354]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:46.354]                   0L) {
[16:04:46.354]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:46.354]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:46.354]                   base::options(opts)
[16:04:46.354]                 }
[16:04:46.354]                 {
[16:04:46.354]                   {
[16:04:46.354]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:46.354]                     NULL
[16:04:46.354]                   }
[16:04:46.354]                   options(future.plan = NULL)
[16:04:46.354]                   if (is.na(NA_character_)) 
[16:04:46.354]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.354]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:46.354]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:46.354]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:46.354]                     envir = parent.frame()) 
[16:04:46.354]                   {
[16:04:46.354]                     if (is.function(workers)) 
[16:04:46.354]                       workers <- workers()
[16:04:46.354]                     workers <- structure(as.integer(workers), 
[16:04:46.354]                       class = class(workers))
[16:04:46.354]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:46.354]                       workers >= 1)
[16:04:46.354]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:46.354]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:46.354]                     }
[16:04:46.354]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:46.354]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:46.354]                       envir = envir)
[16:04:46.354]                     if (!future$lazy) 
[16:04:46.354]                       future <- run(future)
[16:04:46.354]                     invisible(future)
[16:04:46.354]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:46.354]                 }
[16:04:46.354]             }
[16:04:46.354]         }
[16:04:46.354]     })
[16:04:46.354]     if (TRUE) {
[16:04:46.354]         base::sink(type = "output", split = FALSE)
[16:04:46.354]         if (TRUE) {
[16:04:46.354]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:46.354]         }
[16:04:46.354]         else {
[16:04:46.354]             ...future.result["stdout"] <- base::list(NULL)
[16:04:46.354]         }
[16:04:46.354]         base::close(...future.stdout)
[16:04:46.354]         ...future.stdout <- NULL
[16:04:46.354]     }
[16:04:46.354]     ...future.result$conditions <- ...future.conditions
[16:04:46.354]     ...future.result$finished <- base::Sys.time()
[16:04:46.354]     ...future.result
[16:04:46.354] }
[16:04:46.357] MultisessionFuture started
[16:04:46.357] - Launch lazy future ... done
[16:04:46.357] run() for ‘MultisessionFuture’ ... done
[16:04:46.357] getGlobalsAndPackages() ...
[16:04:46.357] Searching for globals...
[16:04:46.358] - globals found: [1] ‘{’
[16:04:46.358] Searching for globals ... DONE
[16:04:46.358] Resolving globals: FALSE
[16:04:46.358] 
[16:04:46.358] 
[16:04:46.359] getGlobalsAndPackages() ... DONE
[16:04:46.359] run() for ‘Future’ ...
[16:04:46.359] - state: ‘created’
[16:04:46.359] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:46.373] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:46.373] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:46.373]   - Field: ‘node’
[16:04:46.373]   - Field: ‘label’
[16:04:46.373]   - Field: ‘local’
[16:04:46.373]   - Field: ‘owner’
[16:04:46.373]   - Field: ‘envir’
[16:04:46.373]   - Field: ‘workers’
[16:04:46.373]   - Field: ‘packages’
[16:04:46.373]   - Field: ‘gc’
[16:04:46.374]   - Field: ‘conditions’
[16:04:46.374]   - Field: ‘persistent’
[16:04:46.374]   - Field: ‘expr’
[16:04:46.374]   - Field: ‘uuid’
[16:04:46.374]   - Field: ‘seed’
[16:04:46.374]   - Field: ‘version’
[16:04:46.374]   - Field: ‘result’
[16:04:46.374]   - Field: ‘asynchronous’
[16:04:46.374]   - Field: ‘calls’
[16:04:46.374]   - Field: ‘globals’
[16:04:46.374]   - Field: ‘stdout’
[16:04:46.375]   - Field: ‘earlySignal’
[16:04:46.375]   - Field: ‘lazy’
[16:04:46.375]   - Field: ‘state’
[16:04:46.375] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:46.375] - Launch lazy future ...
[16:04:46.375] Packages needed by the future expression (n = 0): <none>
[16:04:46.375] Packages needed by future strategies (n = 0): <none>
[16:04:46.376] {
[16:04:46.376]     {
[16:04:46.376]         {
[16:04:46.376]             ...future.startTime <- base::Sys.time()
[16:04:46.376]             {
[16:04:46.376]                 {
[16:04:46.376]                   {
[16:04:46.376]                     {
[16:04:46.376]                       base::local({
[16:04:46.376]                         has_future <- base::requireNamespace("future", 
[16:04:46.376]                           quietly = TRUE)
[16:04:46.376]                         if (has_future) {
[16:04:46.376]                           ns <- base::getNamespace("future")
[16:04:46.376]                           version <- ns[[".package"]][["version"]]
[16:04:46.376]                           if (is.null(version)) 
[16:04:46.376]                             version <- utils::packageVersion("future")
[16:04:46.376]                         }
[16:04:46.376]                         else {
[16:04:46.376]                           version <- NULL
[16:04:46.376]                         }
[16:04:46.376]                         if (!has_future || version < "1.8.0") {
[16:04:46.376]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:46.376]                             "", base::R.version$version.string), 
[16:04:46.376]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:46.376]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:46.376]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:46.376]                               "release", "version")], collapse = " "), 
[16:04:46.376]                             hostname = base::Sys.info()[["nodename"]])
[16:04:46.376]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:46.376]                             info)
[16:04:46.376]                           info <- base::paste(info, collapse = "; ")
[16:04:46.376]                           if (!has_future) {
[16:04:46.376]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:46.376]                               info)
[16:04:46.376]                           }
[16:04:46.376]                           else {
[16:04:46.376]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:46.376]                               info, version)
[16:04:46.376]                           }
[16:04:46.376]                           base::stop(msg)
[16:04:46.376]                         }
[16:04:46.376]                       })
[16:04:46.376]                     }
[16:04:46.376]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:46.376]                     base::options(mc.cores = 1L)
[16:04:46.376]                   }
[16:04:46.376]                   options(future.plan = NULL)
[16:04:46.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:46.376]                 }
[16:04:46.376]                 ...future.workdir <- getwd()
[16:04:46.376]             }
[16:04:46.376]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:46.376]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:46.376]         }
[16:04:46.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:46.376]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:46.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:46.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:46.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:46.376]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:46.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:46.376]             base::names(...future.oldOptions))
[16:04:46.376]     }
[16:04:46.376]     if (FALSE) {
[16:04:46.376]     }
[16:04:46.376]     else {
[16:04:46.376]         if (TRUE) {
[16:04:46.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:46.376]                 open = "w")
[16:04:46.376]         }
[16:04:46.376]         else {
[16:04:46.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:46.376]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:46.376]         }
[16:04:46.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:46.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:46.376]             base::sink(type = "output", split = FALSE)
[16:04:46.376]             base::close(...future.stdout)
[16:04:46.376]         }, add = TRUE)
[16:04:46.376]     }
[16:04:46.376]     ...future.frame <- base::sys.nframe()
[16:04:46.376]     ...future.conditions <- base::list()
[16:04:46.376]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:46.376]     if (FALSE) {
[16:04:46.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:46.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:46.376]     }
[16:04:46.376]     ...future.result <- base::tryCatch({
[16:04:46.376]         base::withCallingHandlers({
[16:04:46.376]             ...future.value <- base::withVisible(base::local({
[16:04:46.376]                 ...future.makeSendCondition <- base::local({
[16:04:46.376]                   sendCondition <- NULL
[16:04:46.376]                   function(frame = 1L) {
[16:04:46.376]                     if (is.function(sendCondition)) 
[16:04:46.376]                       return(sendCondition)
[16:04:46.376]                     ns <- getNamespace("parallel")
[16:04:46.376]                     if (exists("sendData", mode = "function", 
[16:04:46.376]                       envir = ns)) {
[16:04:46.376]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:46.376]                         envir = ns)
[16:04:46.376]                       envir <- sys.frame(frame)
[16:04:46.376]                       master <- NULL
[16:04:46.376]                       while (!identical(envir, .GlobalEnv) && 
[16:04:46.376]                         !identical(envir, emptyenv())) {
[16:04:46.376]                         if (exists("master", mode = "list", envir = envir, 
[16:04:46.376]                           inherits = FALSE)) {
[16:04:46.376]                           master <- get("master", mode = "list", 
[16:04:46.376]                             envir = envir, inherits = FALSE)
[16:04:46.376]                           if (inherits(master, c("SOCKnode", 
[16:04:46.376]                             "SOCK0node"))) {
[16:04:46.376]                             sendCondition <<- function(cond) {
[16:04:46.376]                               data <- list(type = "VALUE", value = cond, 
[16:04:46.376]                                 success = TRUE)
[16:04:46.376]                               parallel_sendData(master, data)
[16:04:46.376]                             }
[16:04:46.376]                             return(sendCondition)
[16:04:46.376]                           }
[16:04:46.376]                         }
[16:04:46.376]                         frame <- frame + 1L
[16:04:46.376]                         envir <- sys.frame(frame)
[16:04:46.376]                       }
[16:04:46.376]                     }
[16:04:46.376]                     sendCondition <<- function(cond) NULL
[16:04:46.376]                   }
[16:04:46.376]                 })
[16:04:46.376]                 withCallingHandlers({
[16:04:46.376]                   {
[16:04:46.376]                     4
[16:04:46.376]                   }
[16:04:46.376]                 }, immediateCondition = function(cond) {
[16:04:46.376]                   sendCondition <- ...future.makeSendCondition()
[16:04:46.376]                   sendCondition(cond)
[16:04:46.376]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.376]                   {
[16:04:46.376]                     inherits <- base::inherits
[16:04:46.376]                     invokeRestart <- base::invokeRestart
[16:04:46.376]                     is.null <- base::is.null
[16:04:46.376]                     muffled <- FALSE
[16:04:46.376]                     if (inherits(cond, "message")) {
[16:04:46.376]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:46.376]                       if (muffled) 
[16:04:46.376]                         invokeRestart("muffleMessage")
[16:04:46.376]                     }
[16:04:46.376]                     else if (inherits(cond, "warning")) {
[16:04:46.376]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:46.376]                       if (muffled) 
[16:04:46.376]                         invokeRestart("muffleWarning")
[16:04:46.376]                     }
[16:04:46.376]                     else if (inherits(cond, "condition")) {
[16:04:46.376]                       if (!is.null(pattern)) {
[16:04:46.376]                         computeRestarts <- base::computeRestarts
[16:04:46.376]                         grepl <- base::grepl
[16:04:46.376]                         restarts <- computeRestarts(cond)
[16:04:46.376]                         for (restart in restarts) {
[16:04:46.376]                           name <- restart$name
[16:04:46.376]                           if (is.null(name)) 
[16:04:46.376]                             next
[16:04:46.376]                           if (!grepl(pattern, name)) 
[16:04:46.376]                             next
[16:04:46.376]                           invokeRestart(restart)
[16:04:46.376]                           muffled <- TRUE
[16:04:46.376]                           break
[16:04:46.376]                         }
[16:04:46.376]                       }
[16:04:46.376]                     }
[16:04:46.376]                     invisible(muffled)
[16:04:46.376]                   }
[16:04:46.376]                   muffleCondition(cond)
[16:04:46.376]                 })
[16:04:46.376]             }))
[16:04:46.376]             future::FutureResult(value = ...future.value$value, 
[16:04:46.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.376]                   ...future.rng), globalenv = if (FALSE) 
[16:04:46.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:46.376]                     ...future.globalenv.names))
[16:04:46.376]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:46.376]         }, condition = base::local({
[16:04:46.376]             c <- base::c
[16:04:46.376]             inherits <- base::inherits
[16:04:46.376]             invokeRestart <- base::invokeRestart
[16:04:46.376]             length <- base::length
[16:04:46.376]             list <- base::list
[16:04:46.376]             seq.int <- base::seq.int
[16:04:46.376]             signalCondition <- base::signalCondition
[16:04:46.376]             sys.calls <- base::sys.calls
[16:04:46.376]             `[[` <- base::`[[`
[16:04:46.376]             `+` <- base::`+`
[16:04:46.376]             `<<-` <- base::`<<-`
[16:04:46.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:46.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:46.376]                   3L)]
[16:04:46.376]             }
[16:04:46.376]             function(cond) {
[16:04:46.376]                 is_error <- inherits(cond, "error")
[16:04:46.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:46.376]                   NULL)
[16:04:46.376]                 if (is_error) {
[16:04:46.376]                   sessionInformation <- function() {
[16:04:46.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:46.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:46.376]                       search = base::search(), system = base::Sys.info())
[16:04:46.376]                   }
[16:04:46.376]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:46.376]                     cond$call), session = sessionInformation(), 
[16:04:46.376]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:46.376]                   signalCondition(cond)
[16:04:46.376]                 }
[16:04:46.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:46.376]                 "immediateCondition"))) {
[16:04:46.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:46.376]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:46.376]                   if (TRUE && !signal) {
[16:04:46.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.376]                     {
[16:04:46.376]                       inherits <- base::inherits
[16:04:46.376]                       invokeRestart <- base::invokeRestart
[16:04:46.376]                       is.null <- base::is.null
[16:04:46.376]                       muffled <- FALSE
[16:04:46.376]                       if (inherits(cond, "message")) {
[16:04:46.376]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.376]                         if (muffled) 
[16:04:46.376]                           invokeRestart("muffleMessage")
[16:04:46.376]                       }
[16:04:46.376]                       else if (inherits(cond, "warning")) {
[16:04:46.376]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.376]                         if (muffled) 
[16:04:46.376]                           invokeRestart("muffleWarning")
[16:04:46.376]                       }
[16:04:46.376]                       else if (inherits(cond, "condition")) {
[16:04:46.376]                         if (!is.null(pattern)) {
[16:04:46.376]                           computeRestarts <- base::computeRestarts
[16:04:46.376]                           grepl <- base::grepl
[16:04:46.376]                           restarts <- computeRestarts(cond)
[16:04:46.376]                           for (restart in restarts) {
[16:04:46.376]                             name <- restart$name
[16:04:46.376]                             if (is.null(name)) 
[16:04:46.376]                               next
[16:04:46.376]                             if (!grepl(pattern, name)) 
[16:04:46.376]                               next
[16:04:46.376]                             invokeRestart(restart)
[16:04:46.376]                             muffled <- TRUE
[16:04:46.376]                             break
[16:04:46.376]                           }
[16:04:46.376]                         }
[16:04:46.376]                       }
[16:04:46.376]                       invisible(muffled)
[16:04:46.376]                     }
[16:04:46.376]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.376]                   }
[16:04:46.376]                 }
[16:04:46.376]                 else {
[16:04:46.376]                   if (TRUE) {
[16:04:46.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.376]                     {
[16:04:46.376]                       inherits <- base::inherits
[16:04:46.376]                       invokeRestart <- base::invokeRestart
[16:04:46.376]                       is.null <- base::is.null
[16:04:46.376]                       muffled <- FALSE
[16:04:46.376]                       if (inherits(cond, "message")) {
[16:04:46.376]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.376]                         if (muffled) 
[16:04:46.376]                           invokeRestart("muffleMessage")
[16:04:46.376]                       }
[16:04:46.376]                       else if (inherits(cond, "warning")) {
[16:04:46.376]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.376]                         if (muffled) 
[16:04:46.376]                           invokeRestart("muffleWarning")
[16:04:46.376]                       }
[16:04:46.376]                       else if (inherits(cond, "condition")) {
[16:04:46.376]                         if (!is.null(pattern)) {
[16:04:46.376]                           computeRestarts <- base::computeRestarts
[16:04:46.376]                           grepl <- base::grepl
[16:04:46.376]                           restarts <- computeRestarts(cond)
[16:04:46.376]                           for (restart in restarts) {
[16:04:46.376]                             name <- restart$name
[16:04:46.376]                             if (is.null(name)) 
[16:04:46.376]                               next
[16:04:46.376]                             if (!grepl(pattern, name)) 
[16:04:46.376]                               next
[16:04:46.376]                             invokeRestart(restart)
[16:04:46.376]                             muffled <- TRUE
[16:04:46.376]                             break
[16:04:46.376]                           }
[16:04:46.376]                         }
[16:04:46.376]                       }
[16:04:46.376]                       invisible(muffled)
[16:04:46.376]                     }
[16:04:46.376]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.376]                   }
[16:04:46.376]                 }
[16:04:46.376]             }
[16:04:46.376]         }))
[16:04:46.376]     }, error = function(ex) {
[16:04:46.376]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:46.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.376]                 ...future.rng), started = ...future.startTime, 
[16:04:46.376]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:46.376]             version = "1.8"), class = "FutureResult")
[16:04:46.376]     }, finally = {
[16:04:46.376]         if (!identical(...future.workdir, getwd())) 
[16:04:46.376]             setwd(...future.workdir)
[16:04:46.376]         {
[16:04:46.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:46.376]                 ...future.oldOptions$nwarnings <- NULL
[16:04:46.376]             }
[16:04:46.376]             base::options(...future.oldOptions)
[16:04:46.376]             if (.Platform$OS.type == "windows") {
[16:04:46.376]                 old_names <- names(...future.oldEnvVars)
[16:04:46.376]                 envs <- base::Sys.getenv()
[16:04:46.376]                 names <- names(envs)
[16:04:46.376]                 common <- intersect(names, old_names)
[16:04:46.376]                 added <- setdiff(names, old_names)
[16:04:46.376]                 removed <- setdiff(old_names, names)
[16:04:46.376]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:46.376]                   envs[common]]
[16:04:46.376]                 NAMES <- toupper(changed)
[16:04:46.376]                 args <- list()
[16:04:46.376]                 for (kk in seq_along(NAMES)) {
[16:04:46.376]                   name <- changed[[kk]]
[16:04:46.376]                   NAME <- NAMES[[kk]]
[16:04:46.376]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.376]                     next
[16:04:46.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.376]                 }
[16:04:46.376]                 NAMES <- toupper(added)
[16:04:46.376]                 for (kk in seq_along(NAMES)) {
[16:04:46.376]                   name <- added[[kk]]
[16:04:46.376]                   NAME <- NAMES[[kk]]
[16:04:46.376]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.376]                     next
[16:04:46.376]                   args[[name]] <- ""
[16:04:46.376]                 }
[16:04:46.376]                 NAMES <- toupper(removed)
[16:04:46.376]                 for (kk in seq_along(NAMES)) {
[16:04:46.376]                   name <- removed[[kk]]
[16:04:46.376]                   NAME <- NAMES[[kk]]
[16:04:46.376]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.376]                     next
[16:04:46.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.376]                 }
[16:04:46.376]                 if (length(args) > 0) 
[16:04:46.376]                   base::do.call(base::Sys.setenv, args = args)
[16:04:46.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:46.376]             }
[16:04:46.376]             else {
[16:04:46.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:46.376]             }
[16:04:46.376]             {
[16:04:46.376]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:46.376]                   0L) {
[16:04:46.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:46.376]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:46.376]                   base::options(opts)
[16:04:46.376]                 }
[16:04:46.376]                 {
[16:04:46.376]                   {
[16:04:46.376]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:46.376]                     NULL
[16:04:46.376]                   }
[16:04:46.376]                   options(future.plan = NULL)
[16:04:46.376]                   if (is.na(NA_character_)) 
[16:04:46.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:46.376]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:46.376]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:46.376]                     envir = parent.frame()) 
[16:04:46.376]                   {
[16:04:46.376]                     if (is.function(workers)) 
[16:04:46.376]                       workers <- workers()
[16:04:46.376]                     workers <- structure(as.integer(workers), 
[16:04:46.376]                       class = class(workers))
[16:04:46.376]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:46.376]                       workers >= 1)
[16:04:46.376]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:46.376]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:46.376]                     }
[16:04:46.376]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:46.376]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:46.376]                       envir = envir)
[16:04:46.376]                     if (!future$lazy) 
[16:04:46.376]                       future <- run(future)
[16:04:46.376]                     invisible(future)
[16:04:46.376]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:46.376]                 }
[16:04:46.376]             }
[16:04:46.376]         }
[16:04:46.376]     })
[16:04:46.376]     if (TRUE) {
[16:04:46.376]         base::sink(type = "output", split = FALSE)
[16:04:46.376]         if (TRUE) {
[16:04:46.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:46.376]         }
[16:04:46.376]         else {
[16:04:46.376]             ...future.result["stdout"] <- base::list(NULL)
[16:04:46.376]         }
[16:04:46.376]         base::close(...future.stdout)
[16:04:46.376]         ...future.stdout <- NULL
[16:04:46.376]     }
[16:04:46.376]     ...future.result$conditions <- ...future.conditions
[16:04:46.376]     ...future.result$finished <- base::Sys.time()
[16:04:46.376]     ...future.result
[16:04:46.376] }
[16:04:46.378] Poll #1 (0): usedNodes() = 2, workers = 2
[16:04:46.389] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.389] - Validating connection of MultisessionFuture
[16:04:46.389] - received message: FutureResult
[16:04:46.389] - Received FutureResult
[16:04:46.389] - Erased future from FutureRegistry
[16:04:46.389] result() for ClusterFuture ...
[16:04:46.389] - result already collected: FutureResult
[16:04:46.389] result() for ClusterFuture ... done
[16:04:46.390] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:46.390] result() for ClusterFuture ...
[16:04:46.390] - result already collected: FutureResult
[16:04:46.390] result() for ClusterFuture ... done
[16:04:46.390] result() for ClusterFuture ...
[16:04:46.390] - result already collected: FutureResult
[16:04:46.390] result() for ClusterFuture ... done
[16:04:46.391] MultisessionFuture started
[16:04:46.391] - Launch lazy future ... done
[16:04:46.391] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55874ed53d90> 
Classes 'listenv', 'environment' <environment: 0x55874e1a6400> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:04:46.403] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.404] - Validating connection of MultisessionFuture
[16:04:46.404] - received message: FutureResult
[16:04:46.404] - Received FutureResult
[16:04:46.404] - Erased future from FutureRegistry
[16:04:46.404] result() for ClusterFuture ...
[16:04:46.404] - result already collected: FutureResult
[16:04:46.404] result() for ClusterFuture ... done
[16:04:46.404] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:46.417] resolve() on list environment ...
[16:04:46.417]  recursive: 0
[16:04:46.418]  length: 6
[16:04:46.418]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:46.419] signalConditionsASAP(numeric, pos=1) ...
[16:04:46.419] - nx: 6
[16:04:46.419] - relay: TRUE
[16:04:46.419] - stdout: TRUE
[16:04:46.419] - signal: TRUE
[16:04:46.419] - resignal: FALSE
[16:04:46.419] - force: TRUE
[16:04:46.419] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.419] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.419]  - until=2
[16:04:46.419]  - relaying element #2
[16:04:46.420] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.420] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.420] signalConditionsASAP(NULL, pos=1) ... done
[16:04:46.420]  length: 5 (resolved future 1)
[16:04:46.420] Future #2
[16:04:46.420] result() for ClusterFuture ...
[16:04:46.420] - result already collected: FutureResult
[16:04:46.420] result() for ClusterFuture ... done
[16:04:46.420] result() for ClusterFuture ...
[16:04:46.420] - result already collected: FutureResult
[16:04:46.420] result() for ClusterFuture ... done
[16:04:46.421] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:46.421] - nx: 6
[16:04:46.421] - relay: TRUE
[16:04:46.421] - stdout: TRUE
[16:04:46.421] - signal: TRUE
[16:04:46.421] - resignal: FALSE
[16:04:46.421] - force: TRUE
[16:04:46.421] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.421] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.421]  - until=2
[16:04:46.421]  - relaying element #2
[16:04:46.421] result() for ClusterFuture ...
[16:04:46.422] - result already collected: FutureResult
[16:04:46.422] result() for ClusterFuture ... done
[16:04:46.422] result() for ClusterFuture ...
[16:04:46.422] - result already collected: FutureResult
[16:04:46.422] result() for ClusterFuture ... done
[16:04:46.422] result() for ClusterFuture ...
[16:04:46.422] - result already collected: FutureResult
[16:04:46.422] result() for ClusterFuture ... done
[16:04:46.422] result() for ClusterFuture ...
[16:04:46.422] - result already collected: FutureResult
[16:04:46.422] result() for ClusterFuture ... done
[16:04:46.423] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.423] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.423] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:46.423]  length: 4 (resolved future 2)
[16:04:46.423] Future #3
[16:04:46.423] result() for ClusterFuture ...
[16:04:46.423] - result already collected: FutureResult
[16:04:46.423] result() for ClusterFuture ... done
[16:04:46.423] result() for ClusterFuture ...
[16:04:46.423] - result already collected: FutureResult
[16:04:46.423] result() for ClusterFuture ... done
[16:04:46.424] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:46.424] - nx: 6
[16:04:46.424] - relay: TRUE
[16:04:46.424] - stdout: TRUE
[16:04:46.424] - signal: TRUE
[16:04:46.424] - resignal: FALSE
[16:04:46.424] - force: TRUE
[16:04:46.424] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.424] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.424]  - until=3
[16:04:46.424]  - relaying element #3
[16:04:46.424] result() for ClusterFuture ...
[16:04:46.425] - result already collected: FutureResult
[16:04:46.425] result() for ClusterFuture ... done
[16:04:46.425] result() for ClusterFuture ...
[16:04:46.425] - result already collected: FutureResult
[16:04:46.425] result() for ClusterFuture ... done
[16:04:46.425] result() for ClusterFuture ...
[16:04:46.425] - result already collected: FutureResult
[16:04:46.425] result() for ClusterFuture ... done
[16:04:46.425] result() for ClusterFuture ...
[16:04:46.425] - result already collected: FutureResult
[16:04:46.425] result() for ClusterFuture ... done
[16:04:46.425] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.426] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.426] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:46.426]  length: 3 (resolved future 3)
[16:04:46.436] signalConditionsASAP(NULL, pos=5) ...
[16:04:46.436] - nx: 6
[16:04:46.436] - relay: TRUE
[16:04:46.437] - stdout: TRUE
[16:04:46.437] - signal: TRUE
[16:04:46.437] - resignal: FALSE
[16:04:46.437] - force: TRUE
[16:04:46.437] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.437] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.437]  - until=6
[16:04:46.437]  - relaying element #4
[16:04:46.437]  - relaying element #6
[16:04:46.438] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:04:46.438] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.438] signalConditionsASAP(NULL, pos=5) ... done
[16:04:46.438]  length: 2 (resolved future 5)
[16:04:46.438] signalConditionsASAP(numeric, pos=6) ...
[16:04:46.438] - nx: 6
[16:04:46.438] - relay: TRUE
[16:04:46.438] - stdout: TRUE
[16:04:46.438] - signal: TRUE
[16:04:46.438] - resignal: FALSE
[16:04:46.438] - force: TRUE
[16:04:46.439] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:04:46.439] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.439]  - until=6
[16:04:46.439]  - relaying element #4
[16:04:46.439] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:04:46.439] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.439] signalConditionsASAP(NULL, pos=6) ... done
[16:04:46.439]  length: 1 (resolved future 6)
[16:04:46.450] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.450] - Validating connection of MultisessionFuture
[16:04:46.450] - received message: FutureResult
[16:04:46.450] - Received FutureResult
[16:04:46.451] - Erased future from FutureRegistry
[16:04:46.451] result() for ClusterFuture ...
[16:04:46.451] - result already collected: FutureResult
[16:04:46.451] result() for ClusterFuture ... done
[16:04:46.451] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:46.451] Future #4
[16:04:46.451] result() for ClusterFuture ...
[16:04:46.451] - result already collected: FutureResult
[16:04:46.451] result() for ClusterFuture ... done
[16:04:46.451] result() for ClusterFuture ...
[16:04:46.451] - result already collected: FutureResult
[16:04:46.452] result() for ClusterFuture ... done
[16:04:46.452] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:04:46.452] - nx: 6
[16:04:46.452] - relay: TRUE
[16:04:46.452] - stdout: TRUE
[16:04:46.452] - signal: TRUE
[16:04:46.452] - resignal: FALSE
[16:04:46.452] - force: TRUE
[16:04:46.452] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:04:46.452] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.452]  - until=6
[16:04:46.453]  - relaying element #4
[16:04:46.453] result() for ClusterFuture ...
[16:04:46.453] - result already collected: FutureResult
[16:04:46.453] result() for ClusterFuture ... done
[16:04:46.453] result() for ClusterFuture ...
[16:04:46.453] - result already collected: FutureResult
[16:04:46.453] result() for ClusterFuture ... done
[16:04:46.453] result() for ClusterFuture ...
[16:04:46.453] - result already collected: FutureResult
[16:04:46.453] result() for ClusterFuture ... done
[16:04:46.453] result() for ClusterFuture ...
[16:04:46.453] - result already collected: FutureResult
[16:04:46.454] result() for ClusterFuture ... done
[16:04:46.454] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.454] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.454] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:04:46.454]  length: 0 (resolved future 4)
[16:04:46.454] Relaying remaining futures
[16:04:46.454] signalConditionsASAP(NULL, pos=0) ...
[16:04:46.454] - nx: 6
[16:04:46.454] - relay: TRUE
[16:04:46.454] - stdout: TRUE
[16:04:46.454] - signal: TRUE
[16:04:46.455] - resignal: FALSE
[16:04:46.455] - force: TRUE
[16:04:46.455] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.455] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:46.455] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.455] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.455] signalConditionsASAP(NULL, pos=0) ... done
[16:04:46.455] resolve() on list environment ... DONE
[16:04:46.455] result() for ClusterFuture ...
[16:04:46.455] - result already collected: FutureResult
[16:04:46.456] result() for ClusterFuture ... done
[16:04:46.456] result() for ClusterFuture ...
[16:04:46.456] - result already collected: FutureResult
[16:04:46.456] result() for ClusterFuture ... done
[16:04:46.456] result() for ClusterFuture ...
[16:04:46.456] - result already collected: FutureResult
[16:04:46.456] result() for ClusterFuture ... done
[16:04:46.456] result() for ClusterFuture ...
[16:04:46.456] - result already collected: FutureResult
[16:04:46.456] result() for ClusterFuture ... done
[16:04:46.457] result() for ClusterFuture ...
[16:04:46.457] - result already collected: FutureResult
[16:04:46.457] result() for ClusterFuture ... done
[16:04:46.457] result() for ClusterFuture ...
[16:04:46.457] - result already collected: FutureResult
[16:04:46.457] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55874de34808> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:04:46.459] getGlobalsAndPackages() ...
[16:04:46.459] Searching for globals...
[16:04:46.459] 
[16:04:46.459] Searching for globals ... DONE
[16:04:46.460] - globals: [0] <none>
[16:04:46.460] getGlobalsAndPackages() ... DONE
[16:04:46.460] run() for ‘Future’ ...
[16:04:46.460] - state: ‘created’
[16:04:46.460] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:46.474] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:46.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:46.474]   - Field: ‘node’
[16:04:46.474]   - Field: ‘label’
[16:04:46.474]   - Field: ‘local’
[16:04:46.474]   - Field: ‘owner’
[16:04:46.474]   - Field: ‘envir’
[16:04:46.474]   - Field: ‘workers’
[16:04:46.474]   - Field: ‘packages’
[16:04:46.475]   - Field: ‘gc’
[16:04:46.475]   - Field: ‘conditions’
[16:04:46.475]   - Field: ‘persistent’
[16:04:46.475]   - Field: ‘expr’
[16:04:46.475]   - Field: ‘uuid’
[16:04:46.475]   - Field: ‘seed’
[16:04:46.475]   - Field: ‘version’
[16:04:46.475]   - Field: ‘result’
[16:04:46.475]   - Field: ‘asynchronous’
[16:04:46.475]   - Field: ‘calls’
[16:04:46.476]   - Field: ‘globals’
[16:04:46.476]   - Field: ‘stdout’
[16:04:46.476]   - Field: ‘earlySignal’
[16:04:46.476]   - Field: ‘lazy’
[16:04:46.476]   - Field: ‘state’
[16:04:46.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:46.476] - Launch lazy future ...
[16:04:46.476] Packages needed by the future expression (n = 0): <none>
[16:04:46.476] Packages needed by future strategies (n = 0): <none>
[16:04:46.477] {
[16:04:46.477]     {
[16:04:46.477]         {
[16:04:46.477]             ...future.startTime <- base::Sys.time()
[16:04:46.477]             {
[16:04:46.477]                 {
[16:04:46.477]                   {
[16:04:46.477]                     {
[16:04:46.477]                       base::local({
[16:04:46.477]                         has_future <- base::requireNamespace("future", 
[16:04:46.477]                           quietly = TRUE)
[16:04:46.477]                         if (has_future) {
[16:04:46.477]                           ns <- base::getNamespace("future")
[16:04:46.477]                           version <- ns[[".package"]][["version"]]
[16:04:46.477]                           if (is.null(version)) 
[16:04:46.477]                             version <- utils::packageVersion("future")
[16:04:46.477]                         }
[16:04:46.477]                         else {
[16:04:46.477]                           version <- NULL
[16:04:46.477]                         }
[16:04:46.477]                         if (!has_future || version < "1.8.0") {
[16:04:46.477]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:46.477]                             "", base::R.version$version.string), 
[16:04:46.477]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:46.477]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:46.477]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:46.477]                               "release", "version")], collapse = " "), 
[16:04:46.477]                             hostname = base::Sys.info()[["nodename"]])
[16:04:46.477]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:46.477]                             info)
[16:04:46.477]                           info <- base::paste(info, collapse = "; ")
[16:04:46.477]                           if (!has_future) {
[16:04:46.477]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:46.477]                               info)
[16:04:46.477]                           }
[16:04:46.477]                           else {
[16:04:46.477]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:46.477]                               info, version)
[16:04:46.477]                           }
[16:04:46.477]                           base::stop(msg)
[16:04:46.477]                         }
[16:04:46.477]                       })
[16:04:46.477]                     }
[16:04:46.477]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:46.477]                     base::options(mc.cores = 1L)
[16:04:46.477]                   }
[16:04:46.477]                   options(future.plan = NULL)
[16:04:46.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:46.477]                 }
[16:04:46.477]                 ...future.workdir <- getwd()
[16:04:46.477]             }
[16:04:46.477]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:46.477]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:46.477]         }
[16:04:46.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:46.477]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:46.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:46.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:46.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:46.477]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:46.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:46.477]             base::names(...future.oldOptions))
[16:04:46.477]     }
[16:04:46.477]     if (FALSE) {
[16:04:46.477]     }
[16:04:46.477]     else {
[16:04:46.477]         if (TRUE) {
[16:04:46.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:46.477]                 open = "w")
[16:04:46.477]         }
[16:04:46.477]         else {
[16:04:46.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:46.477]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:46.477]         }
[16:04:46.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:46.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:46.477]             base::sink(type = "output", split = FALSE)
[16:04:46.477]             base::close(...future.stdout)
[16:04:46.477]         }, add = TRUE)
[16:04:46.477]     }
[16:04:46.477]     ...future.frame <- base::sys.nframe()
[16:04:46.477]     ...future.conditions <- base::list()
[16:04:46.477]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:46.477]     if (FALSE) {
[16:04:46.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:46.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:46.477]     }
[16:04:46.477]     ...future.result <- base::tryCatch({
[16:04:46.477]         base::withCallingHandlers({
[16:04:46.477]             ...future.value <- base::withVisible(base::local({
[16:04:46.477]                 ...future.makeSendCondition <- base::local({
[16:04:46.477]                   sendCondition <- NULL
[16:04:46.477]                   function(frame = 1L) {
[16:04:46.477]                     if (is.function(sendCondition)) 
[16:04:46.477]                       return(sendCondition)
[16:04:46.477]                     ns <- getNamespace("parallel")
[16:04:46.477]                     if (exists("sendData", mode = "function", 
[16:04:46.477]                       envir = ns)) {
[16:04:46.477]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:46.477]                         envir = ns)
[16:04:46.477]                       envir <- sys.frame(frame)
[16:04:46.477]                       master <- NULL
[16:04:46.477]                       while (!identical(envir, .GlobalEnv) && 
[16:04:46.477]                         !identical(envir, emptyenv())) {
[16:04:46.477]                         if (exists("master", mode = "list", envir = envir, 
[16:04:46.477]                           inherits = FALSE)) {
[16:04:46.477]                           master <- get("master", mode = "list", 
[16:04:46.477]                             envir = envir, inherits = FALSE)
[16:04:46.477]                           if (inherits(master, c("SOCKnode", 
[16:04:46.477]                             "SOCK0node"))) {
[16:04:46.477]                             sendCondition <<- function(cond) {
[16:04:46.477]                               data <- list(type = "VALUE", value = cond, 
[16:04:46.477]                                 success = TRUE)
[16:04:46.477]                               parallel_sendData(master, data)
[16:04:46.477]                             }
[16:04:46.477]                             return(sendCondition)
[16:04:46.477]                           }
[16:04:46.477]                         }
[16:04:46.477]                         frame <- frame + 1L
[16:04:46.477]                         envir <- sys.frame(frame)
[16:04:46.477]                       }
[16:04:46.477]                     }
[16:04:46.477]                     sendCondition <<- function(cond) NULL
[16:04:46.477]                   }
[16:04:46.477]                 })
[16:04:46.477]                 withCallingHandlers({
[16:04:46.477]                   2
[16:04:46.477]                 }, immediateCondition = function(cond) {
[16:04:46.477]                   sendCondition <- ...future.makeSendCondition()
[16:04:46.477]                   sendCondition(cond)
[16:04:46.477]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.477]                   {
[16:04:46.477]                     inherits <- base::inherits
[16:04:46.477]                     invokeRestart <- base::invokeRestart
[16:04:46.477]                     is.null <- base::is.null
[16:04:46.477]                     muffled <- FALSE
[16:04:46.477]                     if (inherits(cond, "message")) {
[16:04:46.477]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:46.477]                       if (muffled) 
[16:04:46.477]                         invokeRestart("muffleMessage")
[16:04:46.477]                     }
[16:04:46.477]                     else if (inherits(cond, "warning")) {
[16:04:46.477]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:46.477]                       if (muffled) 
[16:04:46.477]                         invokeRestart("muffleWarning")
[16:04:46.477]                     }
[16:04:46.477]                     else if (inherits(cond, "condition")) {
[16:04:46.477]                       if (!is.null(pattern)) {
[16:04:46.477]                         computeRestarts <- base::computeRestarts
[16:04:46.477]                         grepl <- base::grepl
[16:04:46.477]                         restarts <- computeRestarts(cond)
[16:04:46.477]                         for (restart in restarts) {
[16:04:46.477]                           name <- restart$name
[16:04:46.477]                           if (is.null(name)) 
[16:04:46.477]                             next
[16:04:46.477]                           if (!grepl(pattern, name)) 
[16:04:46.477]                             next
[16:04:46.477]                           invokeRestart(restart)
[16:04:46.477]                           muffled <- TRUE
[16:04:46.477]                           break
[16:04:46.477]                         }
[16:04:46.477]                       }
[16:04:46.477]                     }
[16:04:46.477]                     invisible(muffled)
[16:04:46.477]                   }
[16:04:46.477]                   muffleCondition(cond)
[16:04:46.477]                 })
[16:04:46.477]             }))
[16:04:46.477]             future::FutureResult(value = ...future.value$value, 
[16:04:46.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.477]                   ...future.rng), globalenv = if (FALSE) 
[16:04:46.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:46.477]                     ...future.globalenv.names))
[16:04:46.477]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:46.477]         }, condition = base::local({
[16:04:46.477]             c <- base::c
[16:04:46.477]             inherits <- base::inherits
[16:04:46.477]             invokeRestart <- base::invokeRestart
[16:04:46.477]             length <- base::length
[16:04:46.477]             list <- base::list
[16:04:46.477]             seq.int <- base::seq.int
[16:04:46.477]             signalCondition <- base::signalCondition
[16:04:46.477]             sys.calls <- base::sys.calls
[16:04:46.477]             `[[` <- base::`[[`
[16:04:46.477]             `+` <- base::`+`
[16:04:46.477]             `<<-` <- base::`<<-`
[16:04:46.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:46.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:46.477]                   3L)]
[16:04:46.477]             }
[16:04:46.477]             function(cond) {
[16:04:46.477]                 is_error <- inherits(cond, "error")
[16:04:46.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:46.477]                   NULL)
[16:04:46.477]                 if (is_error) {
[16:04:46.477]                   sessionInformation <- function() {
[16:04:46.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:46.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:46.477]                       search = base::search(), system = base::Sys.info())
[16:04:46.477]                   }
[16:04:46.477]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:46.477]                     cond$call), session = sessionInformation(), 
[16:04:46.477]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:46.477]                   signalCondition(cond)
[16:04:46.477]                 }
[16:04:46.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:46.477]                 "immediateCondition"))) {
[16:04:46.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:46.477]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:46.477]                   if (TRUE && !signal) {
[16:04:46.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.477]                     {
[16:04:46.477]                       inherits <- base::inherits
[16:04:46.477]                       invokeRestart <- base::invokeRestart
[16:04:46.477]                       is.null <- base::is.null
[16:04:46.477]                       muffled <- FALSE
[16:04:46.477]                       if (inherits(cond, "message")) {
[16:04:46.477]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.477]                         if (muffled) 
[16:04:46.477]                           invokeRestart("muffleMessage")
[16:04:46.477]                       }
[16:04:46.477]                       else if (inherits(cond, "warning")) {
[16:04:46.477]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.477]                         if (muffled) 
[16:04:46.477]                           invokeRestart("muffleWarning")
[16:04:46.477]                       }
[16:04:46.477]                       else if (inherits(cond, "condition")) {
[16:04:46.477]                         if (!is.null(pattern)) {
[16:04:46.477]                           computeRestarts <- base::computeRestarts
[16:04:46.477]                           grepl <- base::grepl
[16:04:46.477]                           restarts <- computeRestarts(cond)
[16:04:46.477]                           for (restart in restarts) {
[16:04:46.477]                             name <- restart$name
[16:04:46.477]                             if (is.null(name)) 
[16:04:46.477]                               next
[16:04:46.477]                             if (!grepl(pattern, name)) 
[16:04:46.477]                               next
[16:04:46.477]                             invokeRestart(restart)
[16:04:46.477]                             muffled <- TRUE
[16:04:46.477]                             break
[16:04:46.477]                           }
[16:04:46.477]                         }
[16:04:46.477]                       }
[16:04:46.477]                       invisible(muffled)
[16:04:46.477]                     }
[16:04:46.477]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.477]                   }
[16:04:46.477]                 }
[16:04:46.477]                 else {
[16:04:46.477]                   if (TRUE) {
[16:04:46.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.477]                     {
[16:04:46.477]                       inherits <- base::inherits
[16:04:46.477]                       invokeRestart <- base::invokeRestart
[16:04:46.477]                       is.null <- base::is.null
[16:04:46.477]                       muffled <- FALSE
[16:04:46.477]                       if (inherits(cond, "message")) {
[16:04:46.477]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.477]                         if (muffled) 
[16:04:46.477]                           invokeRestart("muffleMessage")
[16:04:46.477]                       }
[16:04:46.477]                       else if (inherits(cond, "warning")) {
[16:04:46.477]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.477]                         if (muffled) 
[16:04:46.477]                           invokeRestart("muffleWarning")
[16:04:46.477]                       }
[16:04:46.477]                       else if (inherits(cond, "condition")) {
[16:04:46.477]                         if (!is.null(pattern)) {
[16:04:46.477]                           computeRestarts <- base::computeRestarts
[16:04:46.477]                           grepl <- base::grepl
[16:04:46.477]                           restarts <- computeRestarts(cond)
[16:04:46.477]                           for (restart in restarts) {
[16:04:46.477]                             name <- restart$name
[16:04:46.477]                             if (is.null(name)) 
[16:04:46.477]                               next
[16:04:46.477]                             if (!grepl(pattern, name)) 
[16:04:46.477]                               next
[16:04:46.477]                             invokeRestart(restart)
[16:04:46.477]                             muffled <- TRUE
[16:04:46.477]                             break
[16:04:46.477]                           }
[16:04:46.477]                         }
[16:04:46.477]                       }
[16:04:46.477]                       invisible(muffled)
[16:04:46.477]                     }
[16:04:46.477]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.477]                   }
[16:04:46.477]                 }
[16:04:46.477]             }
[16:04:46.477]         }))
[16:04:46.477]     }, error = function(ex) {
[16:04:46.477]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:46.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.477]                 ...future.rng), started = ...future.startTime, 
[16:04:46.477]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:46.477]             version = "1.8"), class = "FutureResult")
[16:04:46.477]     }, finally = {
[16:04:46.477]         if (!identical(...future.workdir, getwd())) 
[16:04:46.477]             setwd(...future.workdir)
[16:04:46.477]         {
[16:04:46.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:46.477]                 ...future.oldOptions$nwarnings <- NULL
[16:04:46.477]             }
[16:04:46.477]             base::options(...future.oldOptions)
[16:04:46.477]             if (.Platform$OS.type == "windows") {
[16:04:46.477]                 old_names <- names(...future.oldEnvVars)
[16:04:46.477]                 envs <- base::Sys.getenv()
[16:04:46.477]                 names <- names(envs)
[16:04:46.477]                 common <- intersect(names, old_names)
[16:04:46.477]                 added <- setdiff(names, old_names)
[16:04:46.477]                 removed <- setdiff(old_names, names)
[16:04:46.477]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:46.477]                   envs[common]]
[16:04:46.477]                 NAMES <- toupper(changed)
[16:04:46.477]                 args <- list()
[16:04:46.477]                 for (kk in seq_along(NAMES)) {
[16:04:46.477]                   name <- changed[[kk]]
[16:04:46.477]                   NAME <- NAMES[[kk]]
[16:04:46.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.477]                     next
[16:04:46.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.477]                 }
[16:04:46.477]                 NAMES <- toupper(added)
[16:04:46.477]                 for (kk in seq_along(NAMES)) {
[16:04:46.477]                   name <- added[[kk]]
[16:04:46.477]                   NAME <- NAMES[[kk]]
[16:04:46.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.477]                     next
[16:04:46.477]                   args[[name]] <- ""
[16:04:46.477]                 }
[16:04:46.477]                 NAMES <- toupper(removed)
[16:04:46.477]                 for (kk in seq_along(NAMES)) {
[16:04:46.477]                   name <- removed[[kk]]
[16:04:46.477]                   NAME <- NAMES[[kk]]
[16:04:46.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.477]                     next
[16:04:46.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.477]                 }
[16:04:46.477]                 if (length(args) > 0) 
[16:04:46.477]                   base::do.call(base::Sys.setenv, args = args)
[16:04:46.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:46.477]             }
[16:04:46.477]             else {
[16:04:46.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:46.477]             }
[16:04:46.477]             {
[16:04:46.477]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:46.477]                   0L) {
[16:04:46.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:46.477]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:46.477]                   base::options(opts)
[16:04:46.477]                 }
[16:04:46.477]                 {
[16:04:46.477]                   {
[16:04:46.477]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:46.477]                     NULL
[16:04:46.477]                   }
[16:04:46.477]                   options(future.plan = NULL)
[16:04:46.477]                   if (is.na(NA_character_)) 
[16:04:46.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:46.477]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:46.477]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:46.477]                     envir = parent.frame()) 
[16:04:46.477]                   {
[16:04:46.477]                     if (is.function(workers)) 
[16:04:46.477]                       workers <- workers()
[16:04:46.477]                     workers <- structure(as.integer(workers), 
[16:04:46.477]                       class = class(workers))
[16:04:46.477]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:46.477]                       workers >= 1)
[16:04:46.477]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:46.477]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:46.477]                     }
[16:04:46.477]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:46.477]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:46.477]                       envir = envir)
[16:04:46.477]                     if (!future$lazy) 
[16:04:46.477]                       future <- run(future)
[16:04:46.477]                     invisible(future)
[16:04:46.477]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:46.477]                 }
[16:04:46.477]             }
[16:04:46.477]         }
[16:04:46.477]     })
[16:04:46.477]     if (TRUE) {
[16:04:46.477]         base::sink(type = "output", split = FALSE)
[16:04:46.477]         if (TRUE) {
[16:04:46.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:46.477]         }
[16:04:46.477]         else {
[16:04:46.477]             ...future.result["stdout"] <- base::list(NULL)
[16:04:46.477]         }
[16:04:46.477]         base::close(...future.stdout)
[16:04:46.477]         ...future.stdout <- NULL
[16:04:46.477]     }
[16:04:46.477]     ...future.result$conditions <- ...future.conditions
[16:04:46.477]     ...future.result$finished <- base::Sys.time()
[16:04:46.477]     ...future.result
[16:04:46.477] }
[16:04:46.480] MultisessionFuture started
[16:04:46.480] - Launch lazy future ... done
[16:04:46.480] run() for ‘MultisessionFuture’ ... done
[16:04:46.480] getGlobalsAndPackages() ...
[16:04:46.480] Searching for globals...
[16:04:46.481] 
[16:04:46.481] Searching for globals ... DONE
[16:04:46.481] - globals: [0] <none>
[16:04:46.481] getGlobalsAndPackages() ... DONE
[16:04:46.481] run() for ‘Future’ ...
[16:04:46.481] - state: ‘created’
[16:04:46.481] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:46.495] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:46.495] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:46.495]   - Field: ‘node’
[16:04:46.495]   - Field: ‘label’
[16:04:46.495]   - Field: ‘local’
[16:04:46.495]   - Field: ‘owner’
[16:04:46.495]   - Field: ‘envir’
[16:04:46.495]   - Field: ‘workers’
[16:04:46.495]   - Field: ‘packages’
[16:04:46.496]   - Field: ‘gc’
[16:04:46.496]   - Field: ‘conditions’
[16:04:46.496]   - Field: ‘persistent’
[16:04:46.496]   - Field: ‘expr’
[16:04:46.496]   - Field: ‘uuid’
[16:04:46.496]   - Field: ‘seed’
[16:04:46.496]   - Field: ‘version’
[16:04:46.496]   - Field: ‘result’
[16:04:46.496]   - Field: ‘asynchronous’
[16:04:46.496]   - Field: ‘calls’
[16:04:46.496]   - Field: ‘globals’
[16:04:46.497]   - Field: ‘stdout’
[16:04:46.497]   - Field: ‘earlySignal’
[16:04:46.497]   - Field: ‘lazy’
[16:04:46.497]   - Field: ‘state’
[16:04:46.497] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:46.497] - Launch lazy future ...
[16:04:46.497] Packages needed by the future expression (n = 0): <none>
[16:04:46.497] Packages needed by future strategies (n = 0): <none>
[16:04:46.498] {
[16:04:46.498]     {
[16:04:46.498]         {
[16:04:46.498]             ...future.startTime <- base::Sys.time()
[16:04:46.498]             {
[16:04:46.498]                 {
[16:04:46.498]                   {
[16:04:46.498]                     {
[16:04:46.498]                       base::local({
[16:04:46.498]                         has_future <- base::requireNamespace("future", 
[16:04:46.498]                           quietly = TRUE)
[16:04:46.498]                         if (has_future) {
[16:04:46.498]                           ns <- base::getNamespace("future")
[16:04:46.498]                           version <- ns[[".package"]][["version"]]
[16:04:46.498]                           if (is.null(version)) 
[16:04:46.498]                             version <- utils::packageVersion("future")
[16:04:46.498]                         }
[16:04:46.498]                         else {
[16:04:46.498]                           version <- NULL
[16:04:46.498]                         }
[16:04:46.498]                         if (!has_future || version < "1.8.0") {
[16:04:46.498]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:46.498]                             "", base::R.version$version.string), 
[16:04:46.498]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:46.498]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:46.498]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:46.498]                               "release", "version")], collapse = " "), 
[16:04:46.498]                             hostname = base::Sys.info()[["nodename"]])
[16:04:46.498]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:46.498]                             info)
[16:04:46.498]                           info <- base::paste(info, collapse = "; ")
[16:04:46.498]                           if (!has_future) {
[16:04:46.498]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:46.498]                               info)
[16:04:46.498]                           }
[16:04:46.498]                           else {
[16:04:46.498]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:46.498]                               info, version)
[16:04:46.498]                           }
[16:04:46.498]                           base::stop(msg)
[16:04:46.498]                         }
[16:04:46.498]                       })
[16:04:46.498]                     }
[16:04:46.498]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:46.498]                     base::options(mc.cores = 1L)
[16:04:46.498]                   }
[16:04:46.498]                   options(future.plan = NULL)
[16:04:46.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:46.498]                 }
[16:04:46.498]                 ...future.workdir <- getwd()
[16:04:46.498]             }
[16:04:46.498]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:46.498]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:46.498]         }
[16:04:46.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:46.498]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:46.498]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:46.498]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:46.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:46.498]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:46.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:46.498]             base::names(...future.oldOptions))
[16:04:46.498]     }
[16:04:46.498]     if (FALSE) {
[16:04:46.498]     }
[16:04:46.498]     else {
[16:04:46.498]         if (TRUE) {
[16:04:46.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:46.498]                 open = "w")
[16:04:46.498]         }
[16:04:46.498]         else {
[16:04:46.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:46.498]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:46.498]         }
[16:04:46.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:46.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:46.498]             base::sink(type = "output", split = FALSE)
[16:04:46.498]             base::close(...future.stdout)
[16:04:46.498]         }, add = TRUE)
[16:04:46.498]     }
[16:04:46.498]     ...future.frame <- base::sys.nframe()
[16:04:46.498]     ...future.conditions <- base::list()
[16:04:46.498]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:46.498]     if (FALSE) {
[16:04:46.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:46.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:46.498]     }
[16:04:46.498]     ...future.result <- base::tryCatch({
[16:04:46.498]         base::withCallingHandlers({
[16:04:46.498]             ...future.value <- base::withVisible(base::local({
[16:04:46.498]                 ...future.makeSendCondition <- base::local({
[16:04:46.498]                   sendCondition <- NULL
[16:04:46.498]                   function(frame = 1L) {
[16:04:46.498]                     if (is.function(sendCondition)) 
[16:04:46.498]                       return(sendCondition)
[16:04:46.498]                     ns <- getNamespace("parallel")
[16:04:46.498]                     if (exists("sendData", mode = "function", 
[16:04:46.498]                       envir = ns)) {
[16:04:46.498]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:46.498]                         envir = ns)
[16:04:46.498]                       envir <- sys.frame(frame)
[16:04:46.498]                       master <- NULL
[16:04:46.498]                       while (!identical(envir, .GlobalEnv) && 
[16:04:46.498]                         !identical(envir, emptyenv())) {
[16:04:46.498]                         if (exists("master", mode = "list", envir = envir, 
[16:04:46.498]                           inherits = FALSE)) {
[16:04:46.498]                           master <- get("master", mode = "list", 
[16:04:46.498]                             envir = envir, inherits = FALSE)
[16:04:46.498]                           if (inherits(master, c("SOCKnode", 
[16:04:46.498]                             "SOCK0node"))) {
[16:04:46.498]                             sendCondition <<- function(cond) {
[16:04:46.498]                               data <- list(type = "VALUE", value = cond, 
[16:04:46.498]                                 success = TRUE)
[16:04:46.498]                               parallel_sendData(master, data)
[16:04:46.498]                             }
[16:04:46.498]                             return(sendCondition)
[16:04:46.498]                           }
[16:04:46.498]                         }
[16:04:46.498]                         frame <- frame + 1L
[16:04:46.498]                         envir <- sys.frame(frame)
[16:04:46.498]                       }
[16:04:46.498]                     }
[16:04:46.498]                     sendCondition <<- function(cond) NULL
[16:04:46.498]                   }
[16:04:46.498]                 })
[16:04:46.498]                 withCallingHandlers({
[16:04:46.498]                   NULL
[16:04:46.498]                 }, immediateCondition = function(cond) {
[16:04:46.498]                   sendCondition <- ...future.makeSendCondition()
[16:04:46.498]                   sendCondition(cond)
[16:04:46.498]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.498]                   {
[16:04:46.498]                     inherits <- base::inherits
[16:04:46.498]                     invokeRestart <- base::invokeRestart
[16:04:46.498]                     is.null <- base::is.null
[16:04:46.498]                     muffled <- FALSE
[16:04:46.498]                     if (inherits(cond, "message")) {
[16:04:46.498]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:46.498]                       if (muffled) 
[16:04:46.498]                         invokeRestart("muffleMessage")
[16:04:46.498]                     }
[16:04:46.498]                     else if (inherits(cond, "warning")) {
[16:04:46.498]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:46.498]                       if (muffled) 
[16:04:46.498]                         invokeRestart("muffleWarning")
[16:04:46.498]                     }
[16:04:46.498]                     else if (inherits(cond, "condition")) {
[16:04:46.498]                       if (!is.null(pattern)) {
[16:04:46.498]                         computeRestarts <- base::computeRestarts
[16:04:46.498]                         grepl <- base::grepl
[16:04:46.498]                         restarts <- computeRestarts(cond)
[16:04:46.498]                         for (restart in restarts) {
[16:04:46.498]                           name <- restart$name
[16:04:46.498]                           if (is.null(name)) 
[16:04:46.498]                             next
[16:04:46.498]                           if (!grepl(pattern, name)) 
[16:04:46.498]                             next
[16:04:46.498]                           invokeRestart(restart)
[16:04:46.498]                           muffled <- TRUE
[16:04:46.498]                           break
[16:04:46.498]                         }
[16:04:46.498]                       }
[16:04:46.498]                     }
[16:04:46.498]                     invisible(muffled)
[16:04:46.498]                   }
[16:04:46.498]                   muffleCondition(cond)
[16:04:46.498]                 })
[16:04:46.498]             }))
[16:04:46.498]             future::FutureResult(value = ...future.value$value, 
[16:04:46.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.498]                   ...future.rng), globalenv = if (FALSE) 
[16:04:46.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:46.498]                     ...future.globalenv.names))
[16:04:46.498]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:46.498]         }, condition = base::local({
[16:04:46.498]             c <- base::c
[16:04:46.498]             inherits <- base::inherits
[16:04:46.498]             invokeRestart <- base::invokeRestart
[16:04:46.498]             length <- base::length
[16:04:46.498]             list <- base::list
[16:04:46.498]             seq.int <- base::seq.int
[16:04:46.498]             signalCondition <- base::signalCondition
[16:04:46.498]             sys.calls <- base::sys.calls
[16:04:46.498]             `[[` <- base::`[[`
[16:04:46.498]             `+` <- base::`+`
[16:04:46.498]             `<<-` <- base::`<<-`
[16:04:46.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:46.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:46.498]                   3L)]
[16:04:46.498]             }
[16:04:46.498]             function(cond) {
[16:04:46.498]                 is_error <- inherits(cond, "error")
[16:04:46.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:46.498]                   NULL)
[16:04:46.498]                 if (is_error) {
[16:04:46.498]                   sessionInformation <- function() {
[16:04:46.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:46.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:46.498]                       search = base::search(), system = base::Sys.info())
[16:04:46.498]                   }
[16:04:46.498]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:46.498]                     cond$call), session = sessionInformation(), 
[16:04:46.498]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:46.498]                   signalCondition(cond)
[16:04:46.498]                 }
[16:04:46.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:46.498]                 "immediateCondition"))) {
[16:04:46.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:46.498]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:46.498]                   if (TRUE && !signal) {
[16:04:46.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.498]                     {
[16:04:46.498]                       inherits <- base::inherits
[16:04:46.498]                       invokeRestart <- base::invokeRestart
[16:04:46.498]                       is.null <- base::is.null
[16:04:46.498]                       muffled <- FALSE
[16:04:46.498]                       if (inherits(cond, "message")) {
[16:04:46.498]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.498]                         if (muffled) 
[16:04:46.498]                           invokeRestart("muffleMessage")
[16:04:46.498]                       }
[16:04:46.498]                       else if (inherits(cond, "warning")) {
[16:04:46.498]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.498]                         if (muffled) 
[16:04:46.498]                           invokeRestart("muffleWarning")
[16:04:46.498]                       }
[16:04:46.498]                       else if (inherits(cond, "condition")) {
[16:04:46.498]                         if (!is.null(pattern)) {
[16:04:46.498]                           computeRestarts <- base::computeRestarts
[16:04:46.498]                           grepl <- base::grepl
[16:04:46.498]                           restarts <- computeRestarts(cond)
[16:04:46.498]                           for (restart in restarts) {
[16:04:46.498]                             name <- restart$name
[16:04:46.498]                             if (is.null(name)) 
[16:04:46.498]                               next
[16:04:46.498]                             if (!grepl(pattern, name)) 
[16:04:46.498]                               next
[16:04:46.498]                             invokeRestart(restart)
[16:04:46.498]                             muffled <- TRUE
[16:04:46.498]                             break
[16:04:46.498]                           }
[16:04:46.498]                         }
[16:04:46.498]                       }
[16:04:46.498]                       invisible(muffled)
[16:04:46.498]                     }
[16:04:46.498]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.498]                   }
[16:04:46.498]                 }
[16:04:46.498]                 else {
[16:04:46.498]                   if (TRUE) {
[16:04:46.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.498]                     {
[16:04:46.498]                       inherits <- base::inherits
[16:04:46.498]                       invokeRestart <- base::invokeRestart
[16:04:46.498]                       is.null <- base::is.null
[16:04:46.498]                       muffled <- FALSE
[16:04:46.498]                       if (inherits(cond, "message")) {
[16:04:46.498]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.498]                         if (muffled) 
[16:04:46.498]                           invokeRestart("muffleMessage")
[16:04:46.498]                       }
[16:04:46.498]                       else if (inherits(cond, "warning")) {
[16:04:46.498]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.498]                         if (muffled) 
[16:04:46.498]                           invokeRestart("muffleWarning")
[16:04:46.498]                       }
[16:04:46.498]                       else if (inherits(cond, "condition")) {
[16:04:46.498]                         if (!is.null(pattern)) {
[16:04:46.498]                           computeRestarts <- base::computeRestarts
[16:04:46.498]                           grepl <- base::grepl
[16:04:46.498]                           restarts <- computeRestarts(cond)
[16:04:46.498]                           for (restart in restarts) {
[16:04:46.498]                             name <- restart$name
[16:04:46.498]                             if (is.null(name)) 
[16:04:46.498]                               next
[16:04:46.498]                             if (!grepl(pattern, name)) 
[16:04:46.498]                               next
[16:04:46.498]                             invokeRestart(restart)
[16:04:46.498]                             muffled <- TRUE
[16:04:46.498]                             break
[16:04:46.498]                           }
[16:04:46.498]                         }
[16:04:46.498]                       }
[16:04:46.498]                       invisible(muffled)
[16:04:46.498]                     }
[16:04:46.498]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.498]                   }
[16:04:46.498]                 }
[16:04:46.498]             }
[16:04:46.498]         }))
[16:04:46.498]     }, error = function(ex) {
[16:04:46.498]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:46.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.498]                 ...future.rng), started = ...future.startTime, 
[16:04:46.498]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:46.498]             version = "1.8"), class = "FutureResult")
[16:04:46.498]     }, finally = {
[16:04:46.498]         if (!identical(...future.workdir, getwd())) 
[16:04:46.498]             setwd(...future.workdir)
[16:04:46.498]         {
[16:04:46.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:46.498]                 ...future.oldOptions$nwarnings <- NULL
[16:04:46.498]             }
[16:04:46.498]             base::options(...future.oldOptions)
[16:04:46.498]             if (.Platform$OS.type == "windows") {
[16:04:46.498]                 old_names <- names(...future.oldEnvVars)
[16:04:46.498]                 envs <- base::Sys.getenv()
[16:04:46.498]                 names <- names(envs)
[16:04:46.498]                 common <- intersect(names, old_names)
[16:04:46.498]                 added <- setdiff(names, old_names)
[16:04:46.498]                 removed <- setdiff(old_names, names)
[16:04:46.498]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:46.498]                   envs[common]]
[16:04:46.498]                 NAMES <- toupper(changed)
[16:04:46.498]                 args <- list()
[16:04:46.498]                 for (kk in seq_along(NAMES)) {
[16:04:46.498]                   name <- changed[[kk]]
[16:04:46.498]                   NAME <- NAMES[[kk]]
[16:04:46.498]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.498]                     next
[16:04:46.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.498]                 }
[16:04:46.498]                 NAMES <- toupper(added)
[16:04:46.498]                 for (kk in seq_along(NAMES)) {
[16:04:46.498]                   name <- added[[kk]]
[16:04:46.498]                   NAME <- NAMES[[kk]]
[16:04:46.498]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.498]                     next
[16:04:46.498]                   args[[name]] <- ""
[16:04:46.498]                 }
[16:04:46.498]                 NAMES <- toupper(removed)
[16:04:46.498]                 for (kk in seq_along(NAMES)) {
[16:04:46.498]                   name <- removed[[kk]]
[16:04:46.498]                   NAME <- NAMES[[kk]]
[16:04:46.498]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.498]                     next
[16:04:46.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.498]                 }
[16:04:46.498]                 if (length(args) > 0) 
[16:04:46.498]                   base::do.call(base::Sys.setenv, args = args)
[16:04:46.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:46.498]             }
[16:04:46.498]             else {
[16:04:46.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:46.498]             }
[16:04:46.498]             {
[16:04:46.498]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:46.498]                   0L) {
[16:04:46.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:46.498]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:46.498]                   base::options(opts)
[16:04:46.498]                 }
[16:04:46.498]                 {
[16:04:46.498]                   {
[16:04:46.498]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:46.498]                     NULL
[16:04:46.498]                   }
[16:04:46.498]                   options(future.plan = NULL)
[16:04:46.498]                   if (is.na(NA_character_)) 
[16:04:46.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:46.498]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:46.498]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:46.498]                     envir = parent.frame()) 
[16:04:46.498]                   {
[16:04:46.498]                     if (is.function(workers)) 
[16:04:46.498]                       workers <- workers()
[16:04:46.498]                     workers <- structure(as.integer(workers), 
[16:04:46.498]                       class = class(workers))
[16:04:46.498]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:46.498]                       workers >= 1)
[16:04:46.498]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:46.498]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:46.498]                     }
[16:04:46.498]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:46.498]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:46.498]                       envir = envir)
[16:04:46.498]                     if (!future$lazy) 
[16:04:46.498]                       future <- run(future)
[16:04:46.498]                     invisible(future)
[16:04:46.498]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:46.498]                 }
[16:04:46.498]             }
[16:04:46.498]         }
[16:04:46.498]     })
[16:04:46.498]     if (TRUE) {
[16:04:46.498]         base::sink(type = "output", split = FALSE)
[16:04:46.498]         if (TRUE) {
[16:04:46.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:46.498]         }
[16:04:46.498]         else {
[16:04:46.498]             ...future.result["stdout"] <- base::list(NULL)
[16:04:46.498]         }
[16:04:46.498]         base::close(...future.stdout)
[16:04:46.498]         ...future.stdout <- NULL
[16:04:46.498]     }
[16:04:46.498]     ...future.result$conditions <- ...future.conditions
[16:04:46.498]     ...future.result$finished <- base::Sys.time()
[16:04:46.498]     ...future.result
[16:04:46.498] }
[16:04:46.501] MultisessionFuture started
[16:04:46.501] - Launch lazy future ... done
[16:04:46.501] run() for ‘MultisessionFuture’ ... done
[16:04:46.501] getGlobalsAndPackages() ...
[16:04:46.501] Searching for globals...
[16:04:46.502] - globals found: [1] ‘{’
[16:04:46.502] Searching for globals ... DONE
[16:04:46.502] Resolving globals: FALSE
[16:04:46.503] 
[16:04:46.503] 
[16:04:46.503] getGlobalsAndPackages() ... DONE
[16:04:46.503] run() for ‘Future’ ...
[16:04:46.503] - state: ‘created’
[16:04:46.503] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:46.516] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:46.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:46.517]   - Field: ‘node’
[16:04:46.517]   - Field: ‘label’
[16:04:46.517]   - Field: ‘local’
[16:04:46.517]   - Field: ‘owner’
[16:04:46.517]   - Field: ‘envir’
[16:04:46.517]   - Field: ‘workers’
[16:04:46.517]   - Field: ‘packages’
[16:04:46.517]   - Field: ‘gc’
[16:04:46.517]   - Field: ‘conditions’
[16:04:46.517]   - Field: ‘persistent’
[16:04:46.517]   - Field: ‘expr’
[16:04:46.518]   - Field: ‘uuid’
[16:04:46.518]   - Field: ‘seed’
[16:04:46.518]   - Field: ‘version’
[16:04:46.518]   - Field: ‘result’
[16:04:46.518]   - Field: ‘asynchronous’
[16:04:46.518]   - Field: ‘calls’
[16:04:46.518]   - Field: ‘globals’
[16:04:46.518]   - Field: ‘stdout’
[16:04:46.518]   - Field: ‘earlySignal’
[16:04:46.518]   - Field: ‘lazy’
[16:04:46.518]   - Field: ‘state’
[16:04:46.519] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:46.519] - Launch lazy future ...
[16:04:46.519] Packages needed by the future expression (n = 0): <none>
[16:04:46.519] Packages needed by future strategies (n = 0): <none>
[16:04:46.519] {
[16:04:46.519]     {
[16:04:46.519]         {
[16:04:46.519]             ...future.startTime <- base::Sys.time()
[16:04:46.519]             {
[16:04:46.519]                 {
[16:04:46.519]                   {
[16:04:46.519]                     {
[16:04:46.519]                       base::local({
[16:04:46.519]                         has_future <- base::requireNamespace("future", 
[16:04:46.519]                           quietly = TRUE)
[16:04:46.519]                         if (has_future) {
[16:04:46.519]                           ns <- base::getNamespace("future")
[16:04:46.519]                           version <- ns[[".package"]][["version"]]
[16:04:46.519]                           if (is.null(version)) 
[16:04:46.519]                             version <- utils::packageVersion("future")
[16:04:46.519]                         }
[16:04:46.519]                         else {
[16:04:46.519]                           version <- NULL
[16:04:46.519]                         }
[16:04:46.519]                         if (!has_future || version < "1.8.0") {
[16:04:46.519]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:46.519]                             "", base::R.version$version.string), 
[16:04:46.519]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:46.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:46.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:46.519]                               "release", "version")], collapse = " "), 
[16:04:46.519]                             hostname = base::Sys.info()[["nodename"]])
[16:04:46.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:46.519]                             info)
[16:04:46.519]                           info <- base::paste(info, collapse = "; ")
[16:04:46.519]                           if (!has_future) {
[16:04:46.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:46.519]                               info)
[16:04:46.519]                           }
[16:04:46.519]                           else {
[16:04:46.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:46.519]                               info, version)
[16:04:46.519]                           }
[16:04:46.519]                           base::stop(msg)
[16:04:46.519]                         }
[16:04:46.519]                       })
[16:04:46.519]                     }
[16:04:46.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:46.519]                     base::options(mc.cores = 1L)
[16:04:46.519]                   }
[16:04:46.519]                   options(future.plan = NULL)
[16:04:46.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:46.519]                 }
[16:04:46.519]                 ...future.workdir <- getwd()
[16:04:46.519]             }
[16:04:46.519]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:46.519]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:46.519]         }
[16:04:46.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:46.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:46.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:46.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:46.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:46.519]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:46.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:46.519]             base::names(...future.oldOptions))
[16:04:46.519]     }
[16:04:46.519]     if (FALSE) {
[16:04:46.519]     }
[16:04:46.519]     else {
[16:04:46.519]         if (TRUE) {
[16:04:46.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:46.519]                 open = "w")
[16:04:46.519]         }
[16:04:46.519]         else {
[16:04:46.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:46.519]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:46.519]         }
[16:04:46.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:46.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:46.519]             base::sink(type = "output", split = FALSE)
[16:04:46.519]             base::close(...future.stdout)
[16:04:46.519]         }, add = TRUE)
[16:04:46.519]     }
[16:04:46.519]     ...future.frame <- base::sys.nframe()
[16:04:46.519]     ...future.conditions <- base::list()
[16:04:46.519]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:46.519]     if (FALSE) {
[16:04:46.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:46.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:46.519]     }
[16:04:46.519]     ...future.result <- base::tryCatch({
[16:04:46.519]         base::withCallingHandlers({
[16:04:46.519]             ...future.value <- base::withVisible(base::local({
[16:04:46.519]                 ...future.makeSendCondition <- base::local({
[16:04:46.519]                   sendCondition <- NULL
[16:04:46.519]                   function(frame = 1L) {
[16:04:46.519]                     if (is.function(sendCondition)) 
[16:04:46.519]                       return(sendCondition)
[16:04:46.519]                     ns <- getNamespace("parallel")
[16:04:46.519]                     if (exists("sendData", mode = "function", 
[16:04:46.519]                       envir = ns)) {
[16:04:46.519]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:46.519]                         envir = ns)
[16:04:46.519]                       envir <- sys.frame(frame)
[16:04:46.519]                       master <- NULL
[16:04:46.519]                       while (!identical(envir, .GlobalEnv) && 
[16:04:46.519]                         !identical(envir, emptyenv())) {
[16:04:46.519]                         if (exists("master", mode = "list", envir = envir, 
[16:04:46.519]                           inherits = FALSE)) {
[16:04:46.519]                           master <- get("master", mode = "list", 
[16:04:46.519]                             envir = envir, inherits = FALSE)
[16:04:46.519]                           if (inherits(master, c("SOCKnode", 
[16:04:46.519]                             "SOCK0node"))) {
[16:04:46.519]                             sendCondition <<- function(cond) {
[16:04:46.519]                               data <- list(type = "VALUE", value = cond, 
[16:04:46.519]                                 success = TRUE)
[16:04:46.519]                               parallel_sendData(master, data)
[16:04:46.519]                             }
[16:04:46.519]                             return(sendCondition)
[16:04:46.519]                           }
[16:04:46.519]                         }
[16:04:46.519]                         frame <- frame + 1L
[16:04:46.519]                         envir <- sys.frame(frame)
[16:04:46.519]                       }
[16:04:46.519]                     }
[16:04:46.519]                     sendCondition <<- function(cond) NULL
[16:04:46.519]                   }
[16:04:46.519]                 })
[16:04:46.519]                 withCallingHandlers({
[16:04:46.519]                   {
[16:04:46.519]                     4
[16:04:46.519]                   }
[16:04:46.519]                 }, immediateCondition = function(cond) {
[16:04:46.519]                   sendCondition <- ...future.makeSendCondition()
[16:04:46.519]                   sendCondition(cond)
[16:04:46.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.519]                   {
[16:04:46.519]                     inherits <- base::inherits
[16:04:46.519]                     invokeRestart <- base::invokeRestart
[16:04:46.519]                     is.null <- base::is.null
[16:04:46.519]                     muffled <- FALSE
[16:04:46.519]                     if (inherits(cond, "message")) {
[16:04:46.519]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:46.519]                       if (muffled) 
[16:04:46.519]                         invokeRestart("muffleMessage")
[16:04:46.519]                     }
[16:04:46.519]                     else if (inherits(cond, "warning")) {
[16:04:46.519]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:46.519]                       if (muffled) 
[16:04:46.519]                         invokeRestart("muffleWarning")
[16:04:46.519]                     }
[16:04:46.519]                     else if (inherits(cond, "condition")) {
[16:04:46.519]                       if (!is.null(pattern)) {
[16:04:46.519]                         computeRestarts <- base::computeRestarts
[16:04:46.519]                         grepl <- base::grepl
[16:04:46.519]                         restarts <- computeRestarts(cond)
[16:04:46.519]                         for (restart in restarts) {
[16:04:46.519]                           name <- restart$name
[16:04:46.519]                           if (is.null(name)) 
[16:04:46.519]                             next
[16:04:46.519]                           if (!grepl(pattern, name)) 
[16:04:46.519]                             next
[16:04:46.519]                           invokeRestart(restart)
[16:04:46.519]                           muffled <- TRUE
[16:04:46.519]                           break
[16:04:46.519]                         }
[16:04:46.519]                       }
[16:04:46.519]                     }
[16:04:46.519]                     invisible(muffled)
[16:04:46.519]                   }
[16:04:46.519]                   muffleCondition(cond)
[16:04:46.519]                 })
[16:04:46.519]             }))
[16:04:46.519]             future::FutureResult(value = ...future.value$value, 
[16:04:46.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.519]                   ...future.rng), globalenv = if (FALSE) 
[16:04:46.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:46.519]                     ...future.globalenv.names))
[16:04:46.519]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:46.519]         }, condition = base::local({
[16:04:46.519]             c <- base::c
[16:04:46.519]             inherits <- base::inherits
[16:04:46.519]             invokeRestart <- base::invokeRestart
[16:04:46.519]             length <- base::length
[16:04:46.519]             list <- base::list
[16:04:46.519]             seq.int <- base::seq.int
[16:04:46.519]             signalCondition <- base::signalCondition
[16:04:46.519]             sys.calls <- base::sys.calls
[16:04:46.519]             `[[` <- base::`[[`
[16:04:46.519]             `+` <- base::`+`
[16:04:46.519]             `<<-` <- base::`<<-`
[16:04:46.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:46.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:46.519]                   3L)]
[16:04:46.519]             }
[16:04:46.519]             function(cond) {
[16:04:46.519]                 is_error <- inherits(cond, "error")
[16:04:46.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:46.519]                   NULL)
[16:04:46.519]                 if (is_error) {
[16:04:46.519]                   sessionInformation <- function() {
[16:04:46.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:46.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:46.519]                       search = base::search(), system = base::Sys.info())
[16:04:46.519]                   }
[16:04:46.519]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:46.519]                     cond$call), session = sessionInformation(), 
[16:04:46.519]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:46.519]                   signalCondition(cond)
[16:04:46.519]                 }
[16:04:46.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:46.519]                 "immediateCondition"))) {
[16:04:46.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:46.519]                   ...future.conditions[[length(...future.conditions) + 
[16:04:46.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:46.519]                   if (TRUE && !signal) {
[16:04:46.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.519]                     {
[16:04:46.519]                       inherits <- base::inherits
[16:04:46.519]                       invokeRestart <- base::invokeRestart
[16:04:46.519]                       is.null <- base::is.null
[16:04:46.519]                       muffled <- FALSE
[16:04:46.519]                       if (inherits(cond, "message")) {
[16:04:46.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.519]                         if (muffled) 
[16:04:46.519]                           invokeRestart("muffleMessage")
[16:04:46.519]                       }
[16:04:46.519]                       else if (inherits(cond, "warning")) {
[16:04:46.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.519]                         if (muffled) 
[16:04:46.519]                           invokeRestart("muffleWarning")
[16:04:46.519]                       }
[16:04:46.519]                       else if (inherits(cond, "condition")) {
[16:04:46.519]                         if (!is.null(pattern)) {
[16:04:46.519]                           computeRestarts <- base::computeRestarts
[16:04:46.519]                           grepl <- base::grepl
[16:04:46.519]                           restarts <- computeRestarts(cond)
[16:04:46.519]                           for (restart in restarts) {
[16:04:46.519]                             name <- restart$name
[16:04:46.519]                             if (is.null(name)) 
[16:04:46.519]                               next
[16:04:46.519]                             if (!grepl(pattern, name)) 
[16:04:46.519]                               next
[16:04:46.519]                             invokeRestart(restart)
[16:04:46.519]                             muffled <- TRUE
[16:04:46.519]                             break
[16:04:46.519]                           }
[16:04:46.519]                         }
[16:04:46.519]                       }
[16:04:46.519]                       invisible(muffled)
[16:04:46.519]                     }
[16:04:46.519]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.519]                   }
[16:04:46.519]                 }
[16:04:46.519]                 else {
[16:04:46.519]                   if (TRUE) {
[16:04:46.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:46.519]                     {
[16:04:46.519]                       inherits <- base::inherits
[16:04:46.519]                       invokeRestart <- base::invokeRestart
[16:04:46.519]                       is.null <- base::is.null
[16:04:46.519]                       muffled <- FALSE
[16:04:46.519]                       if (inherits(cond, "message")) {
[16:04:46.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:46.519]                         if (muffled) 
[16:04:46.519]                           invokeRestart("muffleMessage")
[16:04:46.519]                       }
[16:04:46.519]                       else if (inherits(cond, "warning")) {
[16:04:46.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:46.519]                         if (muffled) 
[16:04:46.519]                           invokeRestart("muffleWarning")
[16:04:46.519]                       }
[16:04:46.519]                       else if (inherits(cond, "condition")) {
[16:04:46.519]                         if (!is.null(pattern)) {
[16:04:46.519]                           computeRestarts <- base::computeRestarts
[16:04:46.519]                           grepl <- base::grepl
[16:04:46.519]                           restarts <- computeRestarts(cond)
[16:04:46.519]                           for (restart in restarts) {
[16:04:46.519]                             name <- restart$name
[16:04:46.519]                             if (is.null(name)) 
[16:04:46.519]                               next
[16:04:46.519]                             if (!grepl(pattern, name)) 
[16:04:46.519]                               next
[16:04:46.519]                             invokeRestart(restart)
[16:04:46.519]                             muffled <- TRUE
[16:04:46.519]                             break
[16:04:46.519]                           }
[16:04:46.519]                         }
[16:04:46.519]                       }
[16:04:46.519]                       invisible(muffled)
[16:04:46.519]                     }
[16:04:46.519]                     muffleCondition(cond, pattern = "^muffle")
[16:04:46.519]                   }
[16:04:46.519]                 }
[16:04:46.519]             }
[16:04:46.519]         }))
[16:04:46.519]     }, error = function(ex) {
[16:04:46.519]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:46.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:46.519]                 ...future.rng), started = ...future.startTime, 
[16:04:46.519]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:46.519]             version = "1.8"), class = "FutureResult")
[16:04:46.519]     }, finally = {
[16:04:46.519]         if (!identical(...future.workdir, getwd())) 
[16:04:46.519]             setwd(...future.workdir)
[16:04:46.519]         {
[16:04:46.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:46.519]                 ...future.oldOptions$nwarnings <- NULL
[16:04:46.519]             }
[16:04:46.519]             base::options(...future.oldOptions)
[16:04:46.519]             if (.Platform$OS.type == "windows") {
[16:04:46.519]                 old_names <- names(...future.oldEnvVars)
[16:04:46.519]                 envs <- base::Sys.getenv()
[16:04:46.519]                 names <- names(envs)
[16:04:46.519]                 common <- intersect(names, old_names)
[16:04:46.519]                 added <- setdiff(names, old_names)
[16:04:46.519]                 removed <- setdiff(old_names, names)
[16:04:46.519]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:46.519]                   envs[common]]
[16:04:46.519]                 NAMES <- toupper(changed)
[16:04:46.519]                 args <- list()
[16:04:46.519]                 for (kk in seq_along(NAMES)) {
[16:04:46.519]                   name <- changed[[kk]]
[16:04:46.519]                   NAME <- NAMES[[kk]]
[16:04:46.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.519]                     next
[16:04:46.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.519]                 }
[16:04:46.519]                 NAMES <- toupper(added)
[16:04:46.519]                 for (kk in seq_along(NAMES)) {
[16:04:46.519]                   name <- added[[kk]]
[16:04:46.519]                   NAME <- NAMES[[kk]]
[16:04:46.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.519]                     next
[16:04:46.519]                   args[[name]] <- ""
[16:04:46.519]                 }
[16:04:46.519]                 NAMES <- toupper(removed)
[16:04:46.519]                 for (kk in seq_along(NAMES)) {
[16:04:46.519]                   name <- removed[[kk]]
[16:04:46.519]                   NAME <- NAMES[[kk]]
[16:04:46.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:46.519]                     next
[16:04:46.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:46.519]                 }
[16:04:46.519]                 if (length(args) > 0) 
[16:04:46.519]                   base::do.call(base::Sys.setenv, args = args)
[16:04:46.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:46.519]             }
[16:04:46.519]             else {
[16:04:46.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:46.519]             }
[16:04:46.519]             {
[16:04:46.519]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:46.519]                   0L) {
[16:04:46.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:46.519]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:46.519]                   base::options(opts)
[16:04:46.519]                 }
[16:04:46.519]                 {
[16:04:46.519]                   {
[16:04:46.519]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:46.519]                     NULL
[16:04:46.519]                   }
[16:04:46.519]                   options(future.plan = NULL)
[16:04:46.519]                   if (is.na(NA_character_)) 
[16:04:46.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:46.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:46.519]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:46.519]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:46.519]                     envir = parent.frame()) 
[16:04:46.519]                   {
[16:04:46.519]                     if (is.function(workers)) 
[16:04:46.519]                       workers <- workers()
[16:04:46.519]                     workers <- structure(as.integer(workers), 
[16:04:46.519]                       class = class(workers))
[16:04:46.519]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:46.519]                       workers >= 1)
[16:04:46.519]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:46.519]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:46.519]                     }
[16:04:46.519]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:46.519]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:46.519]                       envir = envir)
[16:04:46.519]                     if (!future$lazy) 
[16:04:46.519]                       future <- run(future)
[16:04:46.519]                     invisible(future)
[16:04:46.519]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:46.519]                 }
[16:04:46.519]             }
[16:04:46.519]         }
[16:04:46.519]     })
[16:04:46.519]     if (TRUE) {
[16:04:46.519]         base::sink(type = "output", split = FALSE)
[16:04:46.519]         if (TRUE) {
[16:04:46.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:46.519]         }
[16:04:46.519]         else {
[16:04:46.519]             ...future.result["stdout"] <- base::list(NULL)
[16:04:46.519]         }
[16:04:46.519]         base::close(...future.stdout)
[16:04:46.519]         ...future.stdout <- NULL
[16:04:46.519]     }
[16:04:46.519]     ...future.result$conditions <- ...future.conditions
[16:04:46.519]     ...future.result$finished <- base::Sys.time()
[16:04:46.519]     ...future.result
[16:04:46.519] }
[16:04:46.522] Poll #1 (0): usedNodes() = 2, workers = 2
[16:04:46.532] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.532] - Validating connection of MultisessionFuture
[16:04:46.533] - received message: FutureResult
[16:04:46.533] - Received FutureResult
[16:04:46.533] - Erased future from FutureRegistry
[16:04:46.533] result() for ClusterFuture ...
[16:04:46.533] - result already collected: FutureResult
[16:04:46.533] result() for ClusterFuture ... done
[16:04:46.533] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:46.533] result() for ClusterFuture ...
[16:04:46.533] - result already collected: FutureResult
[16:04:46.533] result() for ClusterFuture ... done
[16:04:46.534] result() for ClusterFuture ...
[16:04:46.534] - result already collected: FutureResult
[16:04:46.534] result() for ClusterFuture ... done
[16:04:46.535] MultisessionFuture started
[16:04:46.535] - Launch lazy future ... done
[16:04:46.535] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55874eab22b8> 
Classes 'listenv', 'environment' <environment: 0x55874f942c40> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:04:46.547] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.548] - Validating connection of MultisessionFuture
[16:04:46.548] - received message: FutureResult
[16:04:46.548] - Received FutureResult
[16:04:46.548] - Erased future from FutureRegistry
[16:04:46.548] result() for ClusterFuture ...
[16:04:46.548] - result already collected: FutureResult
[16:04:46.548] result() for ClusterFuture ... done
[16:04:46.548] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:04:46.565] resolve() on list environment ...
[16:04:46.565]  recursive: 0
[16:04:46.566]  length: 6
[16:04:46.566]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:04:46.566] signalConditionsASAP(numeric, pos=1) ...
[16:04:46.566] - nx: 6
[16:04:46.566] - relay: TRUE
[16:04:46.566] - stdout: TRUE
[16:04:46.566] - signal: TRUE
[16:04:46.566] - resignal: FALSE
[16:04:46.566] - force: TRUE
[16:04:46.566] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.567] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.567]  - until=2
[16:04:46.567]  - relaying element #2
[16:04:46.567] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.567] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.567] signalConditionsASAP(NULL, pos=1) ... done
[16:04:46.567]  length: 5 (resolved future 1)
[16:04:46.567] Future #2
[16:04:46.567] result() for ClusterFuture ...
[16:04:46.567] - result already collected: FutureResult
[16:04:46.568] result() for ClusterFuture ... done
[16:04:46.568] result() for ClusterFuture ...
[16:04:46.568] - result already collected: FutureResult
[16:04:46.568] result() for ClusterFuture ... done
[16:04:46.568] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:04:46.568] - nx: 6
[16:04:46.568] - relay: TRUE
[16:04:46.568] - stdout: TRUE
[16:04:46.568] - signal: TRUE
[16:04:46.568] - resignal: FALSE
[16:04:46.568] - force: TRUE
[16:04:46.568] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.569] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:04:46.569]  - until=2
[16:04:46.569]  - relaying element #2
[16:04:46.569] result() for ClusterFuture ...
[16:04:46.569] - result already collected: FutureResult
[16:04:46.569] result() for ClusterFuture ... done
[16:04:46.569] result() for ClusterFuture ...
[16:04:46.569] - result already collected: FutureResult
[16:04:46.569] result() for ClusterFuture ... done
[16:04:46.569] result() for ClusterFuture ...
[16:04:46.569] - result already collected: FutureResult
[16:04:46.570] result() for ClusterFuture ... done
[16:04:46.570] result() for ClusterFuture ...
[16:04:46.570] - result already collected: FutureResult
[16:04:46.570] result() for ClusterFuture ... done
[16:04:46.570] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.570] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.570] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:04:46.570]  length: 4 (resolved future 2)
[16:04:46.570] Future #3
[16:04:46.570] result() for ClusterFuture ...
[16:04:46.570] - result already collected: FutureResult
[16:04:46.571] result() for ClusterFuture ... done
[16:04:46.571] result() for ClusterFuture ...
[16:04:46.571] - result already collected: FutureResult
[16:04:46.571] result() for ClusterFuture ... done
[16:04:46.571] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:04:46.571] - nx: 6
[16:04:46.571] - relay: TRUE
[16:04:46.571] - stdout: TRUE
[16:04:46.571] - signal: TRUE
[16:04:46.571] - resignal: FALSE
[16:04:46.571] - force: TRUE
[16:04:46.571] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.572] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:04:46.572]  - until=3
[16:04:46.572]  - relaying element #3
[16:04:46.572] result() for ClusterFuture ...
[16:04:46.572] - result already collected: FutureResult
[16:04:46.572] result() for ClusterFuture ... done
[16:04:46.572] result() for ClusterFuture ...
[16:04:46.572] - result already collected: FutureResult
[16:04:46.572] result() for ClusterFuture ... done
[16:04:46.572] result() for ClusterFuture ...
[16:04:46.572] - result already collected: FutureResult
[16:04:46.573] result() for ClusterFuture ... done
[16:04:46.573] result() for ClusterFuture ...
[16:04:46.573] - result already collected: FutureResult
[16:04:46.573] result() for ClusterFuture ... done
[16:04:46.573] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.573] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.573] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:04:46.573]  length: 3 (resolved future 3)
[16:04:46.579] receiveMessageFromWorker() for ClusterFuture ...
[16:04:46.580] - Validating connection of MultisessionFuture
[16:04:46.580] - received message: FutureResult
[16:04:46.580] - Received FutureResult
[16:04:46.580] - Erased future from FutureRegistry
[16:04:46.580] result() for ClusterFuture ...
[16:04:46.580] - result already collected: FutureResult
[16:04:46.580] result() for ClusterFuture ... done
[16:04:46.580] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:46.581] Future #4
[16:04:46.581] result() for ClusterFuture ...
[16:04:46.581] - result already collected: FutureResult
[16:04:46.581] result() for ClusterFuture ... done
[16:04:46.581] result() for ClusterFuture ...
[16:04:46.581] - result already collected: FutureResult
[16:04:46.581] result() for ClusterFuture ... done
[16:04:46.581] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:04:46.581] - nx: 6
[16:04:46.581] - relay: TRUE
[16:04:46.581] - stdout: TRUE
[16:04:46.581] - signal: TRUE
[16:04:46.582] - resignal: FALSE
[16:04:46.582] - force: TRUE
[16:04:46.582] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.582] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:04:46.582]  - until=4
[16:04:46.582]  - relaying element #4
[16:04:46.582] result() for ClusterFuture ...
[16:04:46.582] - result already collected: FutureResult
[16:04:46.582] result() for ClusterFuture ... done
[16:04:46.582] result() for ClusterFuture ...
[16:04:46.582] - result already collected: FutureResult
[16:04:46.582] result() for ClusterFuture ... done
[16:04:46.583] result() for ClusterFuture ...
[16:04:46.583] - result already collected: FutureResult
[16:04:46.583] result() for ClusterFuture ... done
[16:04:46.583] result() for ClusterFuture ...
[16:04:46.583] - result already collected: FutureResult
[16:04:46.583] result() for ClusterFuture ... done
[16:04:46.583] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.583] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.583] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:04:46.583]  length: 2 (resolved future 4)
[16:04:46.584] signalConditionsASAP(NULL, pos=5) ...
[16:04:46.584] - nx: 6
[16:04:46.584] - relay: TRUE
[16:04:46.584] - stdout: TRUE
[16:04:46.584] - signal: TRUE
[16:04:46.584] - resignal: FALSE
[16:04:46.584] - force: TRUE
[16:04:46.584] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.584] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.584]  - until=6
[16:04:46.584]  - relaying element #6
[16:04:46.584] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:46.585] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.585] signalConditionsASAP(NULL, pos=5) ... done
[16:04:46.585]  length: 1 (resolved future 5)
[16:04:46.585] signalConditionsASAP(numeric, pos=6) ...
[16:04:46.585] - nx: 6
[16:04:46.585] - relay: TRUE
[16:04:46.585] - stdout: TRUE
[16:04:46.585] - signal: TRUE
[16:04:46.585] - resignal: FALSE
[16:04:46.585] - force: TRUE
[16:04:46.585] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:04:46.585] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.586]  - until=6
[16:04:46.586] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.586] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.586] signalConditionsASAP(numeric, pos=6) ... done
[16:04:46.586]  length: 0 (resolved future 6)
[16:04:46.586] Relaying remaining futures
[16:04:46.586] signalConditionsASAP(NULL, pos=0) ...
[16:04:46.586] - nx: 6
[16:04:46.586] - relay: TRUE
[16:04:46.586] - stdout: TRUE
[16:04:46.586] - signal: TRUE
[16:04:46.586] - resignal: FALSE
[16:04:46.587] - force: TRUE
[16:04:46.587] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.587] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:04:46.587] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:04:46.587] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:04:46.587] signalConditionsASAP(NULL, pos=0) ... done
[16:04:46.587] resolve() on list environment ... DONE
[16:04:46.587] result() for ClusterFuture ...
[16:04:46.587] - result already collected: FutureResult
[16:04:46.587] result() for ClusterFuture ... done
[16:04:46.588] result() for ClusterFuture ...
[16:04:46.588] - result already collected: FutureResult
[16:04:46.588] result() for ClusterFuture ... done
[16:04:46.588] result() for ClusterFuture ...
[16:04:46.588] - result already collected: FutureResult
[16:04:46.588] result() for ClusterFuture ... done
[16:04:46.588] result() for ClusterFuture ...
[16:04:46.588] - result already collected: FutureResult
[16:04:46.588] result() for ClusterFuture ... done
[16:04:46.589] result() for ClusterFuture ...
[16:04:46.589] - result already collected: FutureResult
[16:04:46.589] result() for ClusterFuture ... done
[16:04:46.589] result() for ClusterFuture ...
[16:04:46.589] - result already collected: FutureResult
[16:04:46.589] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55874e2882c0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[16:04:46.592] plan(): Setting new future strategy stack:
[16:04:46.592] List of future strategies:
[16:04:46.592] 1. FutureStrategy:
[16:04:46.592]    - args: function (..., envir = parent.frame())
[16:04:46.592]    - tweaked: FALSE
[16:04:46.592]    - call: future::plan(oplan)
[16:04:46.592] plan(): nbrOfWorkers() = 1
> 
