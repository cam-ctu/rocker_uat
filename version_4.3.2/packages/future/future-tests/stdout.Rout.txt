
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:06:43.802] plan(): Setting new future strategy stack:
[16:06:43.803] List of future strategies:
[16:06:43.803] 1. sequential:
[16:06:43.803]    - args: function (..., envir = parent.frame())
[16:06:43.803]    - tweaked: FALSE
[16:06:43.803]    - call: future::plan("sequential")
[16:06:43.817] plan(): nbrOfWorkers() = 1
> 
> message("*** Standard output ...")
*** Standard output ...
> 
> truth_rows <- utils::capture.output({
+   print(1:50)
+   str(1:50)
+   cat(letters, sep = "-")
+   cat(1:6, collapse = "\n")
+   write.table(datasets::iris[1:10,], sep = "\t")
+ })
> truth <- paste0(paste(truth_rows, collapse = "\n"), "\n")
> print(truth)
[1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n int [1:50] 1 2 3 4 5 6 7 8 9 10 ...\na-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 \n\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\"\n\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\"\n\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\"\n\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\"\n\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\"\n\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\"\n\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\"\n\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\"\n\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\"\n\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\"\n\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\"\n"
> 
> for (cores in seq_len(min(2L, availCores))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("%s ...", strategy))
+     plan(strategy)
+ 
+     for (stdout in c(TRUE, FALSE, NA)) {
+       message(sprintf("- stdout = %s", stdout))
+ 
+       f <- future({
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       }, stdout = stdout)
+       r <- result(f)
+       str(r)
+       stopifnot(value(f) == 42L)
+       if (is.na(stdout)) {
+         stopifnot(is.null(r$stdout) || r$stdout == "")
+       } else if (stdout) {
+         print(r)
+         stopifnot(identical(r$stdout, truth))
+       } else {
+         stopifnot(is.null(r$stdout))
+       }
+ 
+       v %<-% {
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       } %stdout% stdout
+       out <- utils::capture.output(y <- v)
+       stopifnot(y == 42L)
+       if (is.na(stdout)) {
+         ## Single-core multisession => sequential
+         if (cores > 1L || strategy != "multisession") {
+           stopifnot(out == "")
+         }
+       } else if (stdout) {
+         print(out)
+         stopifnot(identical(out, truth_rows))
+       } else {
+         stopifnot(out == "")
+       }
+ 
+       message("- stdout = structure(TRUE, drop = TRUE)")
+       f <- future(print(42), stdout = structure(TRUE, drop = TRUE))
+       r <- result(f)
+       stopifnot(inherits(r$stdout, "character"))
+       v <- value(f)
+       r <- result(f)
+       stopifnot(is.null(r$stdout))
+     } ## for (stdout ...)
+ 
+     message(sprintf("%s ... done", strategy))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... done", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
sequential ...
[16:06:43.862] plan(): Setting new future strategy stack:
[16:06:43.862] List of future strategies:
[16:06:43.862] 1. sequential:
[16:06:43.862]    - args: function (..., envir = parent.frame())
[16:06:43.862]    - tweaked: FALSE
[16:06:43.862]    - call: plan(strategy)
[16:06:43.872] plan(): nbrOfWorkers() = 1
- stdout = TRUE
[16:06:43.873] getGlobalsAndPackages() ...
[16:06:43.873] Searching for globals...
[16:06:43.882] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:43.882] Searching for globals ... DONE
[16:06:43.882] Resolving globals: FALSE
[16:06:43.883] 
[16:06:43.883] - packages: [1] ‘utils’
[16:06:43.883] getGlobalsAndPackages() ... DONE
[16:06:43.884] run() for ‘Future’ ...
[16:06:43.884] - state: ‘created’
[16:06:43.884] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:06:43.884] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:06:43.885] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:06:43.885]   - Field: ‘label’
[16:06:43.885]   - Field: ‘local’
[16:06:43.885]   - Field: ‘owner’
[16:06:43.885]   - Field: ‘envir’
[16:06:43.885]   - Field: ‘packages’
[16:06:43.885]   - Field: ‘gc’
[16:06:43.885]   - Field: ‘conditions’
[16:06:43.885]   - Field: ‘expr’
[16:06:43.885]   - Field: ‘uuid’
[16:06:43.885]   - Field: ‘seed’
[16:06:43.886]   - Field: ‘version’
[16:06:43.886]   - Field: ‘result’
[16:06:43.886]   - Field: ‘asynchronous’
[16:06:43.886]   - Field: ‘calls’
[16:06:43.886]   - Field: ‘globals’
[16:06:43.886]   - Field: ‘stdout’
[16:06:43.886]   - Field: ‘earlySignal’
[16:06:43.886]   - Field: ‘lazy’
[16:06:43.886]   - Field: ‘state’
[16:06:43.886] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:06:43.886] - Launch lazy future ...
[16:06:43.887] Packages needed by the future expression (n = 1): ‘utils’
[16:06:43.887] Packages needed by future strategies (n = 0): <none>
[16:06:43.888] {
[16:06:43.888]     {
[16:06:43.888]         {
[16:06:43.888]             ...future.startTime <- base::Sys.time()
[16:06:43.888]             {
[16:06:43.888]                 {
[16:06:43.888]                   {
[16:06:43.888]                     {
[16:06:43.888]                       base::local({
[16:06:43.888]                         has_future <- base::requireNamespace("future", 
[16:06:43.888]                           quietly = TRUE)
[16:06:43.888]                         if (has_future) {
[16:06:43.888]                           ns <- base::getNamespace("future")
[16:06:43.888]                           version <- ns[[".package"]][["version"]]
[16:06:43.888]                           if (is.null(version)) 
[16:06:43.888]                             version <- utils::packageVersion("future")
[16:06:43.888]                         }
[16:06:43.888]                         else {
[16:06:43.888]                           version <- NULL
[16:06:43.888]                         }
[16:06:43.888]                         if (!has_future || version < "1.8.0") {
[16:06:43.888]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:43.888]                             "", base::R.version$version.string), 
[16:06:43.888]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:43.888]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:43.888]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:43.888]                               "release", "version")], collapse = " "), 
[16:06:43.888]                             hostname = base::Sys.info()[["nodename"]])
[16:06:43.888]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:43.888]                             info)
[16:06:43.888]                           info <- base::paste(info, collapse = "; ")
[16:06:43.888]                           if (!has_future) {
[16:06:43.888]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:43.888]                               info)
[16:06:43.888]                           }
[16:06:43.888]                           else {
[16:06:43.888]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:43.888]                               info, version)
[16:06:43.888]                           }
[16:06:43.888]                           base::stop(msg)
[16:06:43.888]                         }
[16:06:43.888]                       })
[16:06:43.888]                     }
[16:06:43.888]                     base::local({
[16:06:43.888]                       for (pkg in "utils") {
[16:06:43.888]                         base::loadNamespace(pkg)
[16:06:43.888]                         base::library(pkg, character.only = TRUE)
[16:06:43.888]                       }
[16:06:43.888]                     })
[16:06:43.888]                   }
[16:06:43.888]                   options(future.plan = NULL)
[16:06:43.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:43.888]                 }
[16:06:43.888]                 ...future.workdir <- getwd()
[16:06:43.888]             }
[16:06:43.888]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:43.888]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:43.888]         }
[16:06:43.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:43.888]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:43.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:43.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:43.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:43.888]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:43.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:43.888]             base::names(...future.oldOptions))
[16:06:43.888]     }
[16:06:43.888]     if (FALSE) {
[16:06:43.888]     }
[16:06:43.888]     else {
[16:06:43.888]         if (TRUE) {
[16:06:43.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:43.888]                 open = "w")
[16:06:43.888]         }
[16:06:43.888]         else {
[16:06:43.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:43.888]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:43.888]         }
[16:06:43.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:43.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:43.888]             base::sink(type = "output", split = FALSE)
[16:06:43.888]             base::close(...future.stdout)
[16:06:43.888]         }, add = TRUE)
[16:06:43.888]     }
[16:06:43.888]     ...future.frame <- base::sys.nframe()
[16:06:43.888]     ...future.conditions <- base::list()
[16:06:43.888]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:43.888]     if (FALSE) {
[16:06:43.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:43.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:43.888]     }
[16:06:43.888]     ...future.result <- base::tryCatch({
[16:06:43.888]         base::withCallingHandlers({
[16:06:43.888]             ...future.value <- base::withVisible(base::local({
[16:06:43.888]                 print(1:50)
[16:06:43.888]                 str(1:50)
[16:06:43.888]                 cat(letters, sep = "-")
[16:06:43.888]                 cat(1:6, collapse = "\n")
[16:06:43.888]                 write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:43.888]                 42L
[16:06:43.888]             }))
[16:06:43.888]             future::FutureResult(value = ...future.value$value, 
[16:06:43.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.888]                   ...future.rng), globalenv = if (FALSE) 
[16:06:43.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:43.888]                     ...future.globalenv.names))
[16:06:43.888]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:43.888]         }, condition = base::local({
[16:06:43.888]             c <- base::c
[16:06:43.888]             inherits <- base::inherits
[16:06:43.888]             invokeRestart <- base::invokeRestart
[16:06:43.888]             length <- base::length
[16:06:43.888]             list <- base::list
[16:06:43.888]             seq.int <- base::seq.int
[16:06:43.888]             signalCondition <- base::signalCondition
[16:06:43.888]             sys.calls <- base::sys.calls
[16:06:43.888]             `[[` <- base::`[[`
[16:06:43.888]             `+` <- base::`+`
[16:06:43.888]             `<<-` <- base::`<<-`
[16:06:43.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:43.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:43.888]                   3L)]
[16:06:43.888]             }
[16:06:43.888]             function(cond) {
[16:06:43.888]                 is_error <- inherits(cond, "error")
[16:06:43.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:43.888]                   NULL)
[16:06:43.888]                 if (is_error) {
[16:06:43.888]                   sessionInformation <- function() {
[16:06:43.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:43.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:43.888]                       search = base::search(), system = base::Sys.info())
[16:06:43.888]                   }
[16:06:43.888]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:43.888]                     cond$call), session = sessionInformation(), 
[16:06:43.888]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:43.888]                   signalCondition(cond)
[16:06:43.888]                 }
[16:06:43.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:43.888]                 "immediateCondition"))) {
[16:06:43.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:43.888]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:43.888]                   if (TRUE && !signal) {
[16:06:43.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.888]                     {
[16:06:43.888]                       inherits <- base::inherits
[16:06:43.888]                       invokeRestart <- base::invokeRestart
[16:06:43.888]                       is.null <- base::is.null
[16:06:43.888]                       muffled <- FALSE
[16:06:43.888]                       if (inherits(cond, "message")) {
[16:06:43.888]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.888]                         if (muffled) 
[16:06:43.888]                           invokeRestart("muffleMessage")
[16:06:43.888]                       }
[16:06:43.888]                       else if (inherits(cond, "warning")) {
[16:06:43.888]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.888]                         if (muffled) 
[16:06:43.888]                           invokeRestart("muffleWarning")
[16:06:43.888]                       }
[16:06:43.888]                       else if (inherits(cond, "condition")) {
[16:06:43.888]                         if (!is.null(pattern)) {
[16:06:43.888]                           computeRestarts <- base::computeRestarts
[16:06:43.888]                           grepl <- base::grepl
[16:06:43.888]                           restarts <- computeRestarts(cond)
[16:06:43.888]                           for (restart in restarts) {
[16:06:43.888]                             name <- restart$name
[16:06:43.888]                             if (is.null(name)) 
[16:06:43.888]                               next
[16:06:43.888]                             if (!grepl(pattern, name)) 
[16:06:43.888]                               next
[16:06:43.888]                             invokeRestart(restart)
[16:06:43.888]                             muffled <- TRUE
[16:06:43.888]                             break
[16:06:43.888]                           }
[16:06:43.888]                         }
[16:06:43.888]                       }
[16:06:43.888]                       invisible(muffled)
[16:06:43.888]                     }
[16:06:43.888]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.888]                   }
[16:06:43.888]                 }
[16:06:43.888]                 else {
[16:06:43.888]                   if (TRUE) {
[16:06:43.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.888]                     {
[16:06:43.888]                       inherits <- base::inherits
[16:06:43.888]                       invokeRestart <- base::invokeRestart
[16:06:43.888]                       is.null <- base::is.null
[16:06:43.888]                       muffled <- FALSE
[16:06:43.888]                       if (inherits(cond, "message")) {
[16:06:43.888]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.888]                         if (muffled) 
[16:06:43.888]                           invokeRestart("muffleMessage")
[16:06:43.888]                       }
[16:06:43.888]                       else if (inherits(cond, "warning")) {
[16:06:43.888]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.888]                         if (muffled) 
[16:06:43.888]                           invokeRestart("muffleWarning")
[16:06:43.888]                       }
[16:06:43.888]                       else if (inherits(cond, "condition")) {
[16:06:43.888]                         if (!is.null(pattern)) {
[16:06:43.888]                           computeRestarts <- base::computeRestarts
[16:06:43.888]                           grepl <- base::grepl
[16:06:43.888]                           restarts <- computeRestarts(cond)
[16:06:43.888]                           for (restart in restarts) {
[16:06:43.888]                             name <- restart$name
[16:06:43.888]                             if (is.null(name)) 
[16:06:43.888]                               next
[16:06:43.888]                             if (!grepl(pattern, name)) 
[16:06:43.888]                               next
[16:06:43.888]                             invokeRestart(restart)
[16:06:43.888]                             muffled <- TRUE
[16:06:43.888]                             break
[16:06:43.888]                           }
[16:06:43.888]                         }
[16:06:43.888]                       }
[16:06:43.888]                       invisible(muffled)
[16:06:43.888]                     }
[16:06:43.888]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.888]                   }
[16:06:43.888]                 }
[16:06:43.888]             }
[16:06:43.888]         }))
[16:06:43.888]     }, error = function(ex) {
[16:06:43.888]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:43.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.888]                 ...future.rng), started = ...future.startTime, 
[16:06:43.888]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:43.888]             version = "1.8"), class = "FutureResult")
[16:06:43.888]     }, finally = {
[16:06:43.888]         if (!identical(...future.workdir, getwd())) 
[16:06:43.888]             setwd(...future.workdir)
[16:06:43.888]         {
[16:06:43.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:43.888]                 ...future.oldOptions$nwarnings <- NULL
[16:06:43.888]             }
[16:06:43.888]             base::options(...future.oldOptions)
[16:06:43.888]             if (.Platform$OS.type == "windows") {
[16:06:43.888]                 old_names <- names(...future.oldEnvVars)
[16:06:43.888]                 envs <- base::Sys.getenv()
[16:06:43.888]                 names <- names(envs)
[16:06:43.888]                 common <- intersect(names, old_names)
[16:06:43.888]                 added <- setdiff(names, old_names)
[16:06:43.888]                 removed <- setdiff(old_names, names)
[16:06:43.888]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:43.888]                   envs[common]]
[16:06:43.888]                 NAMES <- toupper(changed)
[16:06:43.888]                 args <- list()
[16:06:43.888]                 for (kk in seq_along(NAMES)) {
[16:06:43.888]                   name <- changed[[kk]]
[16:06:43.888]                   NAME <- NAMES[[kk]]
[16:06:43.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.888]                     next
[16:06:43.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.888]                 }
[16:06:43.888]                 NAMES <- toupper(added)
[16:06:43.888]                 for (kk in seq_along(NAMES)) {
[16:06:43.888]                   name <- added[[kk]]
[16:06:43.888]                   NAME <- NAMES[[kk]]
[16:06:43.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.888]                     next
[16:06:43.888]                   args[[name]] <- ""
[16:06:43.888]                 }
[16:06:43.888]                 NAMES <- toupper(removed)
[16:06:43.888]                 for (kk in seq_along(NAMES)) {
[16:06:43.888]                   name <- removed[[kk]]
[16:06:43.888]                   NAME <- NAMES[[kk]]
[16:06:43.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.888]                     next
[16:06:43.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.888]                 }
[16:06:43.888]                 if (length(args) > 0) 
[16:06:43.888]                   base::do.call(base::Sys.setenv, args = args)
[16:06:43.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:43.888]             }
[16:06:43.888]             else {
[16:06:43.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:43.888]             }
[16:06:43.888]             {
[16:06:43.888]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:43.888]                   0L) {
[16:06:43.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:43.888]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:43.888]                   base::options(opts)
[16:06:43.888]                 }
[16:06:43.888]                 {
[16:06:43.888]                   {
[16:06:43.888]                     NULL
[16:06:43.888]                     RNGkind("Mersenne-Twister")
[16:06:43.888]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:06:43.888]                       inherits = FALSE)
[16:06:43.888]                   }
[16:06:43.888]                   options(future.plan = NULL)
[16:06:43.888]                   if (is.na(NA_character_)) 
[16:06:43.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:43.888]                   future::plan(list(function (..., envir = parent.frame()) 
[16:06:43.888]                   {
[16:06:43.888]                     future <- SequentialFuture(..., envir = envir)
[16:06:43.888]                     if (!future$lazy) 
[16:06:43.888]                       future <- run(future)
[16:06:43.888]                     invisible(future)
[16:06:43.888]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:43.888]                 }
[16:06:43.888]             }
[16:06:43.888]         }
[16:06:43.888]     })
[16:06:43.888]     if (TRUE) {
[16:06:43.888]         base::sink(type = "output", split = FALSE)
[16:06:43.888]         if (TRUE) {
[16:06:43.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:43.888]         }
[16:06:43.888]         else {
[16:06:43.888]             ...future.result["stdout"] <- base::list(NULL)
[16:06:43.888]         }
[16:06:43.888]         base::close(...future.stdout)
[16:06:43.888]         ...future.stdout <- NULL
[16:06:43.888]     }
[16:06:43.888]     ...future.result$conditions <- ...future.conditions
[16:06:43.888]     ...future.result$finished <- base::Sys.time()
[16:06:43.888]     ...future.result
[16:06:43.888] }
[16:06:43.890] plan(): Setting new future strategy stack:
[16:06:43.890] List of future strategies:
[16:06:43.890] 1. sequential:
[16:06:43.890]    - args: function (..., envir = parent.frame())
[16:06:43.890]    - tweaked: FALSE
[16:06:43.890]    - call: NULL
[16:06:43.891] plan(): nbrOfWorkers() = 1
[16:06:43.892] plan(): Setting new future strategy stack:
[16:06:43.892] List of future strategies:
[16:06:43.892] 1. sequential:
[16:06:43.892]    - args: function (..., envir = parent.frame())
[16:06:43.892]    - tweaked: FALSE
[16:06:43.892]    - call: plan(strategy)
[16:06:43.893] plan(): nbrOfWorkers() = 1
[16:06:43.893] SequentialFuture started (and completed)
[16:06:43.893] - Launch lazy future ... done
[16:06:43.893] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:06:43"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:06:43"
 $ session_uuid: chr "cab75349-fe0c-9b79-5578-a576251b9035"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "11666ca4073c"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92386
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:06:43"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.002967119 secs (started 2025-01-06 16:06:43.890368)
version: 1.8
[16:06:43.903] getGlobalsAndPackages() ...
[16:06:43.903] Searching for globals...
[16:06:43.907] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:43.907] Searching for globals ... DONE
[16:06:43.908] Resolving globals: FALSE
[16:06:43.908] 
[16:06:43.908] - packages: [1] ‘utils’
[16:06:43.908] getGlobalsAndPackages() ... DONE
[16:06:43.908] run() for ‘Future’ ...
[16:06:43.909] - state: ‘created’
[16:06:43.909] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:06:43.909] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:06:43.909] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:06:43.909]   - Field: ‘label’
[16:06:43.909]   - Field: ‘local’
[16:06:43.909]   - Field: ‘owner’
[16:06:43.909]   - Field: ‘envir’
[16:06:43.910]   - Field: ‘packages’
[16:06:43.910]   - Field: ‘gc’
[16:06:43.910]   - Field: ‘conditions’
[16:06:43.910]   - Field: ‘expr’
[16:06:43.910]   - Field: ‘uuid’
[16:06:43.910]   - Field: ‘seed’
[16:06:43.910]   - Field: ‘version’
[16:06:43.910]   - Field: ‘result’
[16:06:43.910]   - Field: ‘asynchronous’
[16:06:43.910]   - Field: ‘calls’
[16:06:43.910]   - Field: ‘globals’
[16:06:43.910]   - Field: ‘stdout’
[16:06:43.911]   - Field: ‘earlySignal’
[16:06:43.911]   - Field: ‘lazy’
[16:06:43.911]   - Field: ‘state’
[16:06:43.911] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:06:43.911] - Launch lazy future ...
[16:06:43.911] Packages needed by the future expression (n = 1): ‘utils’
[16:06:43.911] Packages needed by future strategies (n = 0): <none>
[16:06:43.912] {
[16:06:43.912]     {
[16:06:43.912]         {
[16:06:43.912]             ...future.startTime <- base::Sys.time()
[16:06:43.912]             {
[16:06:43.912]                 {
[16:06:43.912]                   {
[16:06:43.912]                     {
[16:06:43.912]                       base::local({
[16:06:43.912]                         has_future <- base::requireNamespace("future", 
[16:06:43.912]                           quietly = TRUE)
[16:06:43.912]                         if (has_future) {
[16:06:43.912]                           ns <- base::getNamespace("future")
[16:06:43.912]                           version <- ns[[".package"]][["version"]]
[16:06:43.912]                           if (is.null(version)) 
[16:06:43.912]                             version <- utils::packageVersion("future")
[16:06:43.912]                         }
[16:06:43.912]                         else {
[16:06:43.912]                           version <- NULL
[16:06:43.912]                         }
[16:06:43.912]                         if (!has_future || version < "1.8.0") {
[16:06:43.912]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:43.912]                             "", base::R.version$version.string), 
[16:06:43.912]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:43.912]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:43.912]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:43.912]                               "release", "version")], collapse = " "), 
[16:06:43.912]                             hostname = base::Sys.info()[["nodename"]])
[16:06:43.912]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:43.912]                             info)
[16:06:43.912]                           info <- base::paste(info, collapse = "; ")
[16:06:43.912]                           if (!has_future) {
[16:06:43.912]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:43.912]                               info)
[16:06:43.912]                           }
[16:06:43.912]                           else {
[16:06:43.912]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:43.912]                               info, version)
[16:06:43.912]                           }
[16:06:43.912]                           base::stop(msg)
[16:06:43.912]                         }
[16:06:43.912]                       })
[16:06:43.912]                     }
[16:06:43.912]                     base::local({
[16:06:43.912]                       for (pkg in "utils") {
[16:06:43.912]                         base::loadNamespace(pkg)
[16:06:43.912]                         base::library(pkg, character.only = TRUE)
[16:06:43.912]                       }
[16:06:43.912]                     })
[16:06:43.912]                   }
[16:06:43.912]                   options(future.plan = NULL)
[16:06:43.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:43.912]                 }
[16:06:43.912]                 ...future.workdir <- getwd()
[16:06:43.912]             }
[16:06:43.912]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:43.912]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:43.912]         }
[16:06:43.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:43.912]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:43.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:43.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:43.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:43.912]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:43.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:43.912]             base::names(...future.oldOptions))
[16:06:43.912]     }
[16:06:43.912]     if (FALSE) {
[16:06:43.912]     }
[16:06:43.912]     else {
[16:06:43.912]         if (TRUE) {
[16:06:43.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:43.912]                 open = "w")
[16:06:43.912]         }
[16:06:43.912]         else {
[16:06:43.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:43.912]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:43.912]         }
[16:06:43.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:43.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:43.912]             base::sink(type = "output", split = FALSE)
[16:06:43.912]             base::close(...future.stdout)
[16:06:43.912]         }, add = TRUE)
[16:06:43.912]     }
[16:06:43.912]     ...future.frame <- base::sys.nframe()
[16:06:43.912]     ...future.conditions <- base::list()
[16:06:43.912]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:43.912]     if (FALSE) {
[16:06:43.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:43.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:43.912]     }
[16:06:43.912]     ...future.result <- base::tryCatch({
[16:06:43.912]         base::withCallingHandlers({
[16:06:43.912]             ...future.value <- base::withVisible(base::local({
[16:06:43.912]                 print(1:50)
[16:06:43.912]                 str(1:50)
[16:06:43.912]                 cat(letters, sep = "-")
[16:06:43.912]                 cat(1:6, collapse = "\n")
[16:06:43.912]                 write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:43.912]                 42L
[16:06:43.912]             }))
[16:06:43.912]             future::FutureResult(value = ...future.value$value, 
[16:06:43.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.912]                   ...future.rng), globalenv = if (FALSE) 
[16:06:43.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:43.912]                     ...future.globalenv.names))
[16:06:43.912]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:43.912]         }, condition = base::local({
[16:06:43.912]             c <- base::c
[16:06:43.912]             inherits <- base::inherits
[16:06:43.912]             invokeRestart <- base::invokeRestart
[16:06:43.912]             length <- base::length
[16:06:43.912]             list <- base::list
[16:06:43.912]             seq.int <- base::seq.int
[16:06:43.912]             signalCondition <- base::signalCondition
[16:06:43.912]             sys.calls <- base::sys.calls
[16:06:43.912]             `[[` <- base::`[[`
[16:06:43.912]             `+` <- base::`+`
[16:06:43.912]             `<<-` <- base::`<<-`
[16:06:43.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:43.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:43.912]                   3L)]
[16:06:43.912]             }
[16:06:43.912]             function(cond) {
[16:06:43.912]                 is_error <- inherits(cond, "error")
[16:06:43.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:43.912]                   NULL)
[16:06:43.912]                 if (is_error) {
[16:06:43.912]                   sessionInformation <- function() {
[16:06:43.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:43.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:43.912]                       search = base::search(), system = base::Sys.info())
[16:06:43.912]                   }
[16:06:43.912]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:43.912]                     cond$call), session = sessionInformation(), 
[16:06:43.912]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:43.912]                   signalCondition(cond)
[16:06:43.912]                 }
[16:06:43.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:43.912]                 "immediateCondition"))) {
[16:06:43.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:43.912]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:43.912]                   if (TRUE && !signal) {
[16:06:43.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.912]                     {
[16:06:43.912]                       inherits <- base::inherits
[16:06:43.912]                       invokeRestart <- base::invokeRestart
[16:06:43.912]                       is.null <- base::is.null
[16:06:43.912]                       muffled <- FALSE
[16:06:43.912]                       if (inherits(cond, "message")) {
[16:06:43.912]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.912]                         if (muffled) 
[16:06:43.912]                           invokeRestart("muffleMessage")
[16:06:43.912]                       }
[16:06:43.912]                       else if (inherits(cond, "warning")) {
[16:06:43.912]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.912]                         if (muffled) 
[16:06:43.912]                           invokeRestart("muffleWarning")
[16:06:43.912]                       }
[16:06:43.912]                       else if (inherits(cond, "condition")) {
[16:06:43.912]                         if (!is.null(pattern)) {
[16:06:43.912]                           computeRestarts <- base::computeRestarts
[16:06:43.912]                           grepl <- base::grepl
[16:06:43.912]                           restarts <- computeRestarts(cond)
[16:06:43.912]                           for (restart in restarts) {
[16:06:43.912]                             name <- restart$name
[16:06:43.912]                             if (is.null(name)) 
[16:06:43.912]                               next
[16:06:43.912]                             if (!grepl(pattern, name)) 
[16:06:43.912]                               next
[16:06:43.912]                             invokeRestart(restart)
[16:06:43.912]                             muffled <- TRUE
[16:06:43.912]                             break
[16:06:43.912]                           }
[16:06:43.912]                         }
[16:06:43.912]                       }
[16:06:43.912]                       invisible(muffled)
[16:06:43.912]                     }
[16:06:43.912]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.912]                   }
[16:06:43.912]                 }
[16:06:43.912]                 else {
[16:06:43.912]                   if (TRUE) {
[16:06:43.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.912]                     {
[16:06:43.912]                       inherits <- base::inherits
[16:06:43.912]                       invokeRestart <- base::invokeRestart
[16:06:43.912]                       is.null <- base::is.null
[16:06:43.912]                       muffled <- FALSE
[16:06:43.912]                       if (inherits(cond, "message")) {
[16:06:43.912]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.912]                         if (muffled) 
[16:06:43.912]                           invokeRestart("muffleMessage")
[16:06:43.912]                       }
[16:06:43.912]                       else if (inherits(cond, "warning")) {
[16:06:43.912]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.912]                         if (muffled) 
[16:06:43.912]                           invokeRestart("muffleWarning")
[16:06:43.912]                       }
[16:06:43.912]                       else if (inherits(cond, "condition")) {
[16:06:43.912]                         if (!is.null(pattern)) {
[16:06:43.912]                           computeRestarts <- base::computeRestarts
[16:06:43.912]                           grepl <- base::grepl
[16:06:43.912]                           restarts <- computeRestarts(cond)
[16:06:43.912]                           for (restart in restarts) {
[16:06:43.912]                             name <- restart$name
[16:06:43.912]                             if (is.null(name)) 
[16:06:43.912]                               next
[16:06:43.912]                             if (!grepl(pattern, name)) 
[16:06:43.912]                               next
[16:06:43.912]                             invokeRestart(restart)
[16:06:43.912]                             muffled <- TRUE
[16:06:43.912]                             break
[16:06:43.912]                           }
[16:06:43.912]                         }
[16:06:43.912]                       }
[16:06:43.912]                       invisible(muffled)
[16:06:43.912]                     }
[16:06:43.912]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.912]                   }
[16:06:43.912]                 }
[16:06:43.912]             }
[16:06:43.912]         }))
[16:06:43.912]     }, error = function(ex) {
[16:06:43.912]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:43.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.912]                 ...future.rng), started = ...future.startTime, 
[16:06:43.912]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:43.912]             version = "1.8"), class = "FutureResult")
[16:06:43.912]     }, finally = {
[16:06:43.912]         if (!identical(...future.workdir, getwd())) 
[16:06:43.912]             setwd(...future.workdir)
[16:06:43.912]         {
[16:06:43.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:43.912]                 ...future.oldOptions$nwarnings <- NULL
[16:06:43.912]             }
[16:06:43.912]             base::options(...future.oldOptions)
[16:06:43.912]             if (.Platform$OS.type == "windows") {
[16:06:43.912]                 old_names <- names(...future.oldEnvVars)
[16:06:43.912]                 envs <- base::Sys.getenv()
[16:06:43.912]                 names <- names(envs)
[16:06:43.912]                 common <- intersect(names, old_names)
[16:06:43.912]                 added <- setdiff(names, old_names)
[16:06:43.912]                 removed <- setdiff(old_names, names)
[16:06:43.912]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:43.912]                   envs[common]]
[16:06:43.912]                 NAMES <- toupper(changed)
[16:06:43.912]                 args <- list()
[16:06:43.912]                 for (kk in seq_along(NAMES)) {
[16:06:43.912]                   name <- changed[[kk]]
[16:06:43.912]                   NAME <- NAMES[[kk]]
[16:06:43.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.912]                     next
[16:06:43.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.912]                 }
[16:06:43.912]                 NAMES <- toupper(added)
[16:06:43.912]                 for (kk in seq_along(NAMES)) {
[16:06:43.912]                   name <- added[[kk]]
[16:06:43.912]                   NAME <- NAMES[[kk]]
[16:06:43.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.912]                     next
[16:06:43.912]                   args[[name]] <- ""
[16:06:43.912]                 }
[16:06:43.912]                 NAMES <- toupper(removed)
[16:06:43.912]                 for (kk in seq_along(NAMES)) {
[16:06:43.912]                   name <- removed[[kk]]
[16:06:43.912]                   NAME <- NAMES[[kk]]
[16:06:43.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.912]                     next
[16:06:43.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.912]                 }
[16:06:43.912]                 if (length(args) > 0) 
[16:06:43.912]                   base::do.call(base::Sys.setenv, args = args)
[16:06:43.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:43.912]             }
[16:06:43.912]             else {
[16:06:43.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:43.912]             }
[16:06:43.912]             {
[16:06:43.912]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:43.912]                   0L) {
[16:06:43.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:43.912]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:43.912]                   base::options(opts)
[16:06:43.912]                 }
[16:06:43.912]                 {
[16:06:43.912]                   {
[16:06:43.912]                     NULL
[16:06:43.912]                     RNGkind("Mersenne-Twister")
[16:06:43.912]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:06:43.912]                       inherits = FALSE)
[16:06:43.912]                   }
[16:06:43.912]                   options(future.plan = NULL)
[16:06:43.912]                   if (is.na(NA_character_)) 
[16:06:43.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:43.912]                   future::plan(list(function (..., envir = parent.frame()) 
[16:06:43.912]                   {
[16:06:43.912]                     future <- SequentialFuture(..., envir = envir)
[16:06:43.912]                     if (!future$lazy) 
[16:06:43.912]                       future <- run(future)
[16:06:43.912]                     invisible(future)
[16:06:43.912]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:43.912]                 }
[16:06:43.912]             }
[16:06:43.912]         }
[16:06:43.912]     })
[16:06:43.912]     if (TRUE) {
[16:06:43.912]         base::sink(type = "output", split = FALSE)
[16:06:43.912]         if (TRUE) {
[16:06:43.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:43.912]         }
[16:06:43.912]         else {
[16:06:43.912]             ...future.result["stdout"] <- base::list(NULL)
[16:06:43.912]         }
[16:06:43.912]         base::close(...future.stdout)
[16:06:43.912]         ...future.stdout <- NULL
[16:06:43.912]     }
[16:06:43.912]     ...future.result$conditions <- ...future.conditions
[16:06:43.912]     ...future.result$finished <- base::Sys.time()
[16:06:43.912]     ...future.result
[16:06:43.912] }
[16:06:43.914] plan(): Setting new future strategy stack:
[16:06:43.914] List of future strategies:
[16:06:43.914] 1. sequential:
[16:06:43.914]    - args: function (..., envir = parent.frame())
[16:06:43.914]    - tweaked: FALSE
[16:06:43.914]    - call: NULL
[16:06:43.914] plan(): nbrOfWorkers() = 1
[16:06:43.915] plan(): Setting new future strategy stack:
[16:06:43.915] List of future strategies:
[16:06:43.915] 1. sequential:
[16:06:43.915]    - args: function (..., envir = parent.frame())
[16:06:43.915]    - tweaked: FALSE
[16:06:43.915]    - call: plan(strategy)
[16:06:43.916] plan(): nbrOfWorkers() = 1
[16:06:43.916] SequentialFuture started (and completed)
[16:06:43.916] - Launch lazy future ... done
[16:06:43.916] run() for ‘SequentialFuture’ ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[16:06:43.917] getGlobalsAndPackages() ...
[16:06:43.917] Searching for globals...
[16:06:43.917] - globals found: [1] ‘print’
[16:06:43.917] Searching for globals ... DONE
[16:06:43.917] Resolving globals: FALSE
[16:06:43.918] 
[16:06:43.918] 
[16:06:43.918] getGlobalsAndPackages() ... DONE
[16:06:43.918] run() for ‘Future’ ...
[16:06:43.918] - state: ‘created’
[16:06:43.918] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:06:43.918] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:06:43.918] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:06:43.919]   - Field: ‘label’
[16:06:43.919]   - Field: ‘local’
[16:06:43.919]   - Field: ‘owner’
[16:06:43.919]   - Field: ‘envir’
[16:06:43.919]   - Field: ‘packages’
[16:06:43.919]   - Field: ‘gc’
[16:06:43.919]   - Field: ‘conditions’
[16:06:43.919]   - Field: ‘expr’
[16:06:43.919]   - Field: ‘uuid’
[16:06:43.919]   - Field: ‘seed’
[16:06:43.919]   - Field: ‘version’
[16:06:43.920]   - Field: ‘result’
[16:06:43.920]   - Field: ‘asynchronous’
[16:06:43.920]   - Field: ‘calls’
[16:06:43.920]   - Field: ‘globals’
[16:06:43.920]   - Field: ‘stdout’
[16:06:43.920]   - Field: ‘earlySignal’
[16:06:43.920]   - Field: ‘lazy’
[16:06:43.920]   - Field: ‘state’
[16:06:43.920] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:06:43.920] - Launch lazy future ...
[16:06:43.920] Packages needed by the future expression (n = 0): <none>
[16:06:43.921] Packages needed by future strategies (n = 0): <none>
[16:06:43.921] {
[16:06:43.921]     {
[16:06:43.921]         {
[16:06:43.921]             ...future.startTime <- base::Sys.time()
[16:06:43.921]             {
[16:06:43.921]                 {
[16:06:43.921]                   {
[16:06:43.921]                     base::local({
[16:06:43.921]                       has_future <- base::requireNamespace("future", 
[16:06:43.921]                         quietly = TRUE)
[16:06:43.921]                       if (has_future) {
[16:06:43.921]                         ns <- base::getNamespace("future")
[16:06:43.921]                         version <- ns[[".package"]][["version"]]
[16:06:43.921]                         if (is.null(version)) 
[16:06:43.921]                           version <- utils::packageVersion("future")
[16:06:43.921]                       }
[16:06:43.921]                       else {
[16:06:43.921]                         version <- NULL
[16:06:43.921]                       }
[16:06:43.921]                       if (!has_future || version < "1.8.0") {
[16:06:43.921]                         info <- base::c(r_version = base::gsub("R version ", 
[16:06:43.921]                           "", base::R.version$version.string), 
[16:06:43.921]                           platform = base::sprintf("%s (%s-bit)", 
[16:06:43.921]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:43.921]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:43.921]                             "release", "version")], collapse = " "), 
[16:06:43.921]                           hostname = base::Sys.info()[["nodename"]])
[16:06:43.921]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:06:43.921]                           info)
[16:06:43.921]                         info <- base::paste(info, collapse = "; ")
[16:06:43.921]                         if (!has_future) {
[16:06:43.921]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:43.921]                             info)
[16:06:43.921]                         }
[16:06:43.921]                         else {
[16:06:43.921]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:43.921]                             info, version)
[16:06:43.921]                         }
[16:06:43.921]                         base::stop(msg)
[16:06:43.921]                       }
[16:06:43.921]                     })
[16:06:43.921]                   }
[16:06:43.921]                   options(future.plan = NULL)
[16:06:43.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:43.921]                 }
[16:06:43.921]                 ...future.workdir <- getwd()
[16:06:43.921]             }
[16:06:43.921]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:43.921]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:43.921]         }
[16:06:43.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:43.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:43.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:43.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:43.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:43.921]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:43.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:43.921]             base::names(...future.oldOptions))
[16:06:43.921]     }
[16:06:43.921]     if (FALSE) {
[16:06:43.921]     }
[16:06:43.921]     else {
[16:06:43.921]         if (TRUE) {
[16:06:43.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:43.921]                 open = "w")
[16:06:43.921]         }
[16:06:43.921]         else {
[16:06:43.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:43.921]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:43.921]         }
[16:06:43.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:43.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:43.921]             base::sink(type = "output", split = FALSE)
[16:06:43.921]             base::close(...future.stdout)
[16:06:43.921]         }, add = TRUE)
[16:06:43.921]     }
[16:06:43.921]     ...future.frame <- base::sys.nframe()
[16:06:43.921]     ...future.conditions <- base::list()
[16:06:43.921]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:43.921]     if (FALSE) {
[16:06:43.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:43.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:43.921]     }
[16:06:43.921]     ...future.result <- base::tryCatch({
[16:06:43.921]         base::withCallingHandlers({
[16:06:43.921]             ...future.value <- base::withVisible(base::local(print(42)))
[16:06:43.921]             future::FutureResult(value = ...future.value$value, 
[16:06:43.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.921]                   ...future.rng), globalenv = if (FALSE) 
[16:06:43.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:43.921]                     ...future.globalenv.names))
[16:06:43.921]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:43.921]         }, condition = base::local({
[16:06:43.921]             c <- base::c
[16:06:43.921]             inherits <- base::inherits
[16:06:43.921]             invokeRestart <- base::invokeRestart
[16:06:43.921]             length <- base::length
[16:06:43.921]             list <- base::list
[16:06:43.921]             seq.int <- base::seq.int
[16:06:43.921]             signalCondition <- base::signalCondition
[16:06:43.921]             sys.calls <- base::sys.calls
[16:06:43.921]             `[[` <- base::`[[`
[16:06:43.921]             `+` <- base::`+`
[16:06:43.921]             `<<-` <- base::`<<-`
[16:06:43.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:43.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:43.921]                   3L)]
[16:06:43.921]             }
[16:06:43.921]             function(cond) {
[16:06:43.921]                 is_error <- inherits(cond, "error")
[16:06:43.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:43.921]                   NULL)
[16:06:43.921]                 if (is_error) {
[16:06:43.921]                   sessionInformation <- function() {
[16:06:43.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:43.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:43.921]                       search = base::search(), system = base::Sys.info())
[16:06:43.921]                   }
[16:06:43.921]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:43.921]                     cond$call), session = sessionInformation(), 
[16:06:43.921]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:43.921]                   signalCondition(cond)
[16:06:43.921]                 }
[16:06:43.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:43.921]                 "immediateCondition"))) {
[16:06:43.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:43.921]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:43.921]                   if (TRUE && !signal) {
[16:06:43.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.921]                     {
[16:06:43.921]                       inherits <- base::inherits
[16:06:43.921]                       invokeRestart <- base::invokeRestart
[16:06:43.921]                       is.null <- base::is.null
[16:06:43.921]                       muffled <- FALSE
[16:06:43.921]                       if (inherits(cond, "message")) {
[16:06:43.921]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.921]                         if (muffled) 
[16:06:43.921]                           invokeRestart("muffleMessage")
[16:06:43.921]                       }
[16:06:43.921]                       else if (inherits(cond, "warning")) {
[16:06:43.921]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.921]                         if (muffled) 
[16:06:43.921]                           invokeRestart("muffleWarning")
[16:06:43.921]                       }
[16:06:43.921]                       else if (inherits(cond, "condition")) {
[16:06:43.921]                         if (!is.null(pattern)) {
[16:06:43.921]                           computeRestarts <- base::computeRestarts
[16:06:43.921]                           grepl <- base::grepl
[16:06:43.921]                           restarts <- computeRestarts(cond)
[16:06:43.921]                           for (restart in restarts) {
[16:06:43.921]                             name <- restart$name
[16:06:43.921]                             if (is.null(name)) 
[16:06:43.921]                               next
[16:06:43.921]                             if (!grepl(pattern, name)) 
[16:06:43.921]                               next
[16:06:43.921]                             invokeRestart(restart)
[16:06:43.921]                             muffled <- TRUE
[16:06:43.921]                             break
[16:06:43.921]                           }
[16:06:43.921]                         }
[16:06:43.921]                       }
[16:06:43.921]                       invisible(muffled)
[16:06:43.921]                     }
[16:06:43.921]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.921]                   }
[16:06:43.921]                 }
[16:06:43.921]                 else {
[16:06:43.921]                   if (TRUE) {
[16:06:43.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.921]                     {
[16:06:43.921]                       inherits <- base::inherits
[16:06:43.921]                       invokeRestart <- base::invokeRestart
[16:06:43.921]                       is.null <- base::is.null
[16:06:43.921]                       muffled <- FALSE
[16:06:43.921]                       if (inherits(cond, "message")) {
[16:06:43.921]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.921]                         if (muffled) 
[16:06:43.921]                           invokeRestart("muffleMessage")
[16:06:43.921]                       }
[16:06:43.921]                       else if (inherits(cond, "warning")) {
[16:06:43.921]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.921]                         if (muffled) 
[16:06:43.921]                           invokeRestart("muffleWarning")
[16:06:43.921]                       }
[16:06:43.921]                       else if (inherits(cond, "condition")) {
[16:06:43.921]                         if (!is.null(pattern)) {
[16:06:43.921]                           computeRestarts <- base::computeRestarts
[16:06:43.921]                           grepl <- base::grepl
[16:06:43.921]                           restarts <- computeRestarts(cond)
[16:06:43.921]                           for (restart in restarts) {
[16:06:43.921]                             name <- restart$name
[16:06:43.921]                             if (is.null(name)) 
[16:06:43.921]                               next
[16:06:43.921]                             if (!grepl(pattern, name)) 
[16:06:43.921]                               next
[16:06:43.921]                             invokeRestart(restart)
[16:06:43.921]                             muffled <- TRUE
[16:06:43.921]                             break
[16:06:43.921]                           }
[16:06:43.921]                         }
[16:06:43.921]                       }
[16:06:43.921]                       invisible(muffled)
[16:06:43.921]                     }
[16:06:43.921]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.921]                   }
[16:06:43.921]                 }
[16:06:43.921]             }
[16:06:43.921]         }))
[16:06:43.921]     }, error = function(ex) {
[16:06:43.921]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:43.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.921]                 ...future.rng), started = ...future.startTime, 
[16:06:43.921]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:43.921]             version = "1.8"), class = "FutureResult")
[16:06:43.921]     }, finally = {
[16:06:43.921]         if (!identical(...future.workdir, getwd())) 
[16:06:43.921]             setwd(...future.workdir)
[16:06:43.921]         {
[16:06:43.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:43.921]                 ...future.oldOptions$nwarnings <- NULL
[16:06:43.921]             }
[16:06:43.921]             base::options(...future.oldOptions)
[16:06:43.921]             if (.Platform$OS.type == "windows") {
[16:06:43.921]                 old_names <- names(...future.oldEnvVars)
[16:06:43.921]                 envs <- base::Sys.getenv()
[16:06:43.921]                 names <- names(envs)
[16:06:43.921]                 common <- intersect(names, old_names)
[16:06:43.921]                 added <- setdiff(names, old_names)
[16:06:43.921]                 removed <- setdiff(old_names, names)
[16:06:43.921]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:43.921]                   envs[common]]
[16:06:43.921]                 NAMES <- toupper(changed)
[16:06:43.921]                 args <- list()
[16:06:43.921]                 for (kk in seq_along(NAMES)) {
[16:06:43.921]                   name <- changed[[kk]]
[16:06:43.921]                   NAME <- NAMES[[kk]]
[16:06:43.921]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.921]                     next
[16:06:43.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.921]                 }
[16:06:43.921]                 NAMES <- toupper(added)
[16:06:43.921]                 for (kk in seq_along(NAMES)) {
[16:06:43.921]                   name <- added[[kk]]
[16:06:43.921]                   NAME <- NAMES[[kk]]
[16:06:43.921]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.921]                     next
[16:06:43.921]                   args[[name]] <- ""
[16:06:43.921]                 }
[16:06:43.921]                 NAMES <- toupper(removed)
[16:06:43.921]                 for (kk in seq_along(NAMES)) {
[16:06:43.921]                   name <- removed[[kk]]
[16:06:43.921]                   NAME <- NAMES[[kk]]
[16:06:43.921]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.921]                     next
[16:06:43.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.921]                 }
[16:06:43.921]                 if (length(args) > 0) 
[16:06:43.921]                   base::do.call(base::Sys.setenv, args = args)
[16:06:43.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:43.921]             }
[16:06:43.921]             else {
[16:06:43.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:43.921]             }
[16:06:43.921]             {
[16:06:43.921]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:43.921]                   0L) {
[16:06:43.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:43.921]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:43.921]                   base::options(opts)
[16:06:43.921]                 }
[16:06:43.921]                 {
[16:06:43.921]                   {
[16:06:43.921]                     NULL
[16:06:43.921]                     RNGkind("Mersenne-Twister")
[16:06:43.921]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:06:43.921]                       inherits = FALSE)
[16:06:43.921]                   }
[16:06:43.921]                   options(future.plan = NULL)
[16:06:43.921]                   if (is.na(NA_character_)) 
[16:06:43.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:43.921]                   future::plan(list(function (..., envir = parent.frame()) 
[16:06:43.921]                   {
[16:06:43.921]                     future <- SequentialFuture(..., envir = envir)
[16:06:43.921]                     if (!future$lazy) 
[16:06:43.921]                       future <- run(future)
[16:06:43.921]                     invisible(future)
[16:06:43.921]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:43.921]                 }
[16:06:43.921]             }
[16:06:43.921]         }
[16:06:43.921]     })
[16:06:43.921]     if (TRUE) {
[16:06:43.921]         base::sink(type = "output", split = FALSE)
[16:06:43.921]         if (TRUE) {
[16:06:43.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:43.921]         }
[16:06:43.921]         else {
[16:06:43.921]             ...future.result["stdout"] <- base::list(NULL)
[16:06:43.921]         }
[16:06:43.921]         base::close(...future.stdout)
[16:06:43.921]         ...future.stdout <- NULL
[16:06:43.921]     }
[16:06:43.921]     ...future.result$conditions <- ...future.conditions
[16:06:43.921]     ...future.result$finished <- base::Sys.time()
[16:06:43.921]     ...future.result
[16:06:43.921] }
[16:06:43.923] plan(): Setting new future strategy stack:
[16:06:43.923] List of future strategies:
[16:06:43.923] 1. sequential:
[16:06:43.923]    - args: function (..., envir = parent.frame())
[16:06:43.923]    - tweaked: FALSE
[16:06:43.923]    - call: NULL
[16:06:43.923] plan(): nbrOfWorkers() = 1
[16:06:43.924] plan(): Setting new future strategy stack:
[16:06:43.924] List of future strategies:
[16:06:43.924] 1. sequential:
[16:06:43.924]    - args: function (..., envir = parent.frame())
[16:06:43.924]    - tweaked: FALSE
[16:06:43.924]    - call: plan(strategy)
[16:06:43.924] plan(): nbrOfWorkers() = 1
[16:06:43.924] SequentialFuture started (and completed)
[16:06:43.924] - Launch lazy future ... done
[16:06:43.925] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = FALSE
[16:06:43.925] getGlobalsAndPackages() ...
[16:06:43.925] Searching for globals...
[16:06:43.928] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:43.928] Searching for globals ... DONE
[16:06:43.928] Resolving globals: FALSE
[16:06:43.928] 
[16:06:43.928] - packages: [1] ‘utils’
[16:06:43.928] getGlobalsAndPackages() ... DONE
[16:06:43.929] run() for ‘Future’ ...
[16:06:43.929] - state: ‘created’
[16:06:43.929] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:06:43.929] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:06:43.929] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:06:43.929]   - Field: ‘label’
[16:06:43.929]   - Field: ‘local’
[16:06:43.929]   - Field: ‘owner’
[16:06:43.930]   - Field: ‘envir’
[16:06:43.930]   - Field: ‘packages’
[16:06:43.930]   - Field: ‘gc’
[16:06:43.930]   - Field: ‘conditions’
[16:06:43.930]   - Field: ‘expr’
[16:06:43.930]   - Field: ‘uuid’
[16:06:43.930]   - Field: ‘seed’
[16:06:43.930]   - Field: ‘version’
[16:06:43.930]   - Field: ‘result’
[16:06:43.930]   - Field: ‘asynchronous’
[16:06:43.930]   - Field: ‘calls’
[16:06:43.930]   - Field: ‘globals’
[16:06:43.931]   - Field: ‘stdout’
[16:06:43.931]   - Field: ‘earlySignal’
[16:06:43.931]   - Field: ‘lazy’
[16:06:43.931]   - Field: ‘state’
[16:06:43.931] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:06:43.931] - Launch lazy future ...
[16:06:43.931] Packages needed by the future expression (n = 1): ‘utils’
[16:06:43.931] Packages needed by future strategies (n = 0): <none>
[16:06:43.933] {
[16:06:43.933]     {
[16:06:43.933]         {
[16:06:43.933]             ...future.startTime <- base::Sys.time()
[16:06:43.933]             {
[16:06:43.933]                 {
[16:06:43.933]                   {
[16:06:43.933]                     {
[16:06:43.933]                       base::local({
[16:06:43.933]                         has_future <- base::requireNamespace("future", 
[16:06:43.933]                           quietly = TRUE)
[16:06:43.933]                         if (has_future) {
[16:06:43.933]                           ns <- base::getNamespace("future")
[16:06:43.933]                           version <- ns[[".package"]][["version"]]
[16:06:43.933]                           if (is.null(version)) 
[16:06:43.933]                             version <- utils::packageVersion("future")
[16:06:43.933]                         }
[16:06:43.933]                         else {
[16:06:43.933]                           version <- NULL
[16:06:43.933]                         }
[16:06:43.933]                         if (!has_future || version < "1.8.0") {
[16:06:43.933]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:43.933]                             "", base::R.version$version.string), 
[16:06:43.933]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:43.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:43.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:43.933]                               "release", "version")], collapse = " "), 
[16:06:43.933]                             hostname = base::Sys.info()[["nodename"]])
[16:06:43.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:43.933]                             info)
[16:06:43.933]                           info <- base::paste(info, collapse = "; ")
[16:06:43.933]                           if (!has_future) {
[16:06:43.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:43.933]                               info)
[16:06:43.933]                           }
[16:06:43.933]                           else {
[16:06:43.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:43.933]                               info, version)
[16:06:43.933]                           }
[16:06:43.933]                           base::stop(msg)
[16:06:43.933]                         }
[16:06:43.933]                       })
[16:06:43.933]                     }
[16:06:43.933]                     base::local({
[16:06:43.933]                       for (pkg in "utils") {
[16:06:43.933]                         base::loadNamespace(pkg)
[16:06:43.933]                         base::library(pkg, character.only = TRUE)
[16:06:43.933]                       }
[16:06:43.933]                     })
[16:06:43.933]                   }
[16:06:43.933]                   options(future.plan = NULL)
[16:06:43.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:43.933]                 }
[16:06:43.933]                 ...future.workdir <- getwd()
[16:06:43.933]             }
[16:06:43.933]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:43.933]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:43.933]         }
[16:06:43.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:43.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:43.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:43.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:43.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:43.933]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:43.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:43.933]             base::names(...future.oldOptions))
[16:06:43.933]     }
[16:06:43.933]     if (FALSE) {
[16:06:43.933]     }
[16:06:43.933]     else {
[16:06:43.933]         if (FALSE) {
[16:06:43.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:43.933]                 open = "w")
[16:06:43.933]         }
[16:06:43.933]         else {
[16:06:43.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:43.933]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:43.933]         }
[16:06:43.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:43.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:43.933]             base::sink(type = "output", split = FALSE)
[16:06:43.933]             base::close(...future.stdout)
[16:06:43.933]         }, add = TRUE)
[16:06:43.933]     }
[16:06:43.933]     ...future.frame <- base::sys.nframe()
[16:06:43.933]     ...future.conditions <- base::list()
[16:06:43.933]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:43.933]     if (FALSE) {
[16:06:43.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:43.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:43.933]     }
[16:06:43.933]     ...future.result <- base::tryCatch({
[16:06:43.933]         base::withCallingHandlers({
[16:06:43.933]             ...future.value <- base::withVisible(base::local({
[16:06:43.933]                 print(1:50)
[16:06:43.933]                 str(1:50)
[16:06:43.933]                 cat(letters, sep = "-")
[16:06:43.933]                 cat(1:6, collapse = "\n")
[16:06:43.933]                 write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:43.933]                 42L
[16:06:43.933]             }))
[16:06:43.933]             future::FutureResult(value = ...future.value$value, 
[16:06:43.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.933]                   ...future.rng), globalenv = if (FALSE) 
[16:06:43.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:43.933]                     ...future.globalenv.names))
[16:06:43.933]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:43.933]         }, condition = base::local({
[16:06:43.933]             c <- base::c
[16:06:43.933]             inherits <- base::inherits
[16:06:43.933]             invokeRestart <- base::invokeRestart
[16:06:43.933]             length <- base::length
[16:06:43.933]             list <- base::list
[16:06:43.933]             seq.int <- base::seq.int
[16:06:43.933]             signalCondition <- base::signalCondition
[16:06:43.933]             sys.calls <- base::sys.calls
[16:06:43.933]             `[[` <- base::`[[`
[16:06:43.933]             `+` <- base::`+`
[16:06:43.933]             `<<-` <- base::`<<-`
[16:06:43.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:43.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:43.933]                   3L)]
[16:06:43.933]             }
[16:06:43.933]             function(cond) {
[16:06:43.933]                 is_error <- inherits(cond, "error")
[16:06:43.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:43.933]                   NULL)
[16:06:43.933]                 if (is_error) {
[16:06:43.933]                   sessionInformation <- function() {
[16:06:43.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:43.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:43.933]                       search = base::search(), system = base::Sys.info())
[16:06:43.933]                   }
[16:06:43.933]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:43.933]                     cond$call), session = sessionInformation(), 
[16:06:43.933]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:43.933]                   signalCondition(cond)
[16:06:43.933]                 }
[16:06:43.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:43.933]                 "immediateCondition"))) {
[16:06:43.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:43.933]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:43.933]                   if (TRUE && !signal) {
[16:06:43.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.933]                     {
[16:06:43.933]                       inherits <- base::inherits
[16:06:43.933]                       invokeRestart <- base::invokeRestart
[16:06:43.933]                       is.null <- base::is.null
[16:06:43.933]                       muffled <- FALSE
[16:06:43.933]                       if (inherits(cond, "message")) {
[16:06:43.933]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.933]                         if (muffled) 
[16:06:43.933]                           invokeRestart("muffleMessage")
[16:06:43.933]                       }
[16:06:43.933]                       else if (inherits(cond, "warning")) {
[16:06:43.933]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.933]                         if (muffled) 
[16:06:43.933]                           invokeRestart("muffleWarning")
[16:06:43.933]                       }
[16:06:43.933]                       else if (inherits(cond, "condition")) {
[16:06:43.933]                         if (!is.null(pattern)) {
[16:06:43.933]                           computeRestarts <- base::computeRestarts
[16:06:43.933]                           grepl <- base::grepl
[16:06:43.933]                           restarts <- computeRestarts(cond)
[16:06:43.933]                           for (restart in restarts) {
[16:06:43.933]                             name <- restart$name
[16:06:43.933]                             if (is.null(name)) 
[16:06:43.933]                               next
[16:06:43.933]                             if (!grepl(pattern, name)) 
[16:06:43.933]                               next
[16:06:43.933]                             invokeRestart(restart)
[16:06:43.933]                             muffled <- TRUE
[16:06:43.933]                             break
[16:06:43.933]                           }
[16:06:43.933]                         }
[16:06:43.933]                       }
[16:06:43.933]                       invisible(muffled)
[16:06:43.933]                     }
[16:06:43.933]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.933]                   }
[16:06:43.933]                 }
[16:06:43.933]                 else {
[16:06:43.933]                   if (TRUE) {
[16:06:43.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.933]                     {
[16:06:43.933]                       inherits <- base::inherits
[16:06:43.933]                       invokeRestart <- base::invokeRestart
[16:06:43.933]                       is.null <- base::is.null
[16:06:43.933]                       muffled <- FALSE
[16:06:43.933]                       if (inherits(cond, "message")) {
[16:06:43.933]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.933]                         if (muffled) 
[16:06:43.933]                           invokeRestart("muffleMessage")
[16:06:43.933]                       }
[16:06:43.933]                       else if (inherits(cond, "warning")) {
[16:06:43.933]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.933]                         if (muffled) 
[16:06:43.933]                           invokeRestart("muffleWarning")
[16:06:43.933]                       }
[16:06:43.933]                       else if (inherits(cond, "condition")) {
[16:06:43.933]                         if (!is.null(pattern)) {
[16:06:43.933]                           computeRestarts <- base::computeRestarts
[16:06:43.933]                           grepl <- base::grepl
[16:06:43.933]                           restarts <- computeRestarts(cond)
[16:06:43.933]                           for (restart in restarts) {
[16:06:43.933]                             name <- restart$name
[16:06:43.933]                             if (is.null(name)) 
[16:06:43.933]                               next
[16:06:43.933]                             if (!grepl(pattern, name)) 
[16:06:43.933]                               next
[16:06:43.933]                             invokeRestart(restart)
[16:06:43.933]                             muffled <- TRUE
[16:06:43.933]                             break
[16:06:43.933]                           }
[16:06:43.933]                         }
[16:06:43.933]                       }
[16:06:43.933]                       invisible(muffled)
[16:06:43.933]                     }
[16:06:43.933]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.933]                   }
[16:06:43.933]                 }
[16:06:43.933]             }
[16:06:43.933]         }))
[16:06:43.933]     }, error = function(ex) {
[16:06:43.933]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:43.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.933]                 ...future.rng), started = ...future.startTime, 
[16:06:43.933]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:43.933]             version = "1.8"), class = "FutureResult")
[16:06:43.933]     }, finally = {
[16:06:43.933]         if (!identical(...future.workdir, getwd())) 
[16:06:43.933]             setwd(...future.workdir)
[16:06:43.933]         {
[16:06:43.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:43.933]                 ...future.oldOptions$nwarnings <- NULL
[16:06:43.933]             }
[16:06:43.933]             base::options(...future.oldOptions)
[16:06:43.933]             if (.Platform$OS.type == "windows") {
[16:06:43.933]                 old_names <- names(...future.oldEnvVars)
[16:06:43.933]                 envs <- base::Sys.getenv()
[16:06:43.933]                 names <- names(envs)
[16:06:43.933]                 common <- intersect(names, old_names)
[16:06:43.933]                 added <- setdiff(names, old_names)
[16:06:43.933]                 removed <- setdiff(old_names, names)
[16:06:43.933]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:43.933]                   envs[common]]
[16:06:43.933]                 NAMES <- toupper(changed)
[16:06:43.933]                 args <- list()
[16:06:43.933]                 for (kk in seq_along(NAMES)) {
[16:06:43.933]                   name <- changed[[kk]]
[16:06:43.933]                   NAME <- NAMES[[kk]]
[16:06:43.933]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.933]                     next
[16:06:43.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.933]                 }
[16:06:43.933]                 NAMES <- toupper(added)
[16:06:43.933]                 for (kk in seq_along(NAMES)) {
[16:06:43.933]                   name <- added[[kk]]
[16:06:43.933]                   NAME <- NAMES[[kk]]
[16:06:43.933]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.933]                     next
[16:06:43.933]                   args[[name]] <- ""
[16:06:43.933]                 }
[16:06:43.933]                 NAMES <- toupper(removed)
[16:06:43.933]                 for (kk in seq_along(NAMES)) {
[16:06:43.933]                   name <- removed[[kk]]
[16:06:43.933]                   NAME <- NAMES[[kk]]
[16:06:43.933]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.933]                     next
[16:06:43.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.933]                 }
[16:06:43.933]                 if (length(args) > 0) 
[16:06:43.933]                   base::do.call(base::Sys.setenv, args = args)
[16:06:43.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:43.933]             }
[16:06:43.933]             else {
[16:06:43.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:43.933]             }
[16:06:43.933]             {
[16:06:43.933]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:43.933]                   0L) {
[16:06:43.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:43.933]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:43.933]                   base::options(opts)
[16:06:43.933]                 }
[16:06:43.933]                 {
[16:06:43.933]                   {
[16:06:43.933]                     NULL
[16:06:43.933]                     RNGkind("Mersenne-Twister")
[16:06:43.933]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:06:43.933]                       inherits = FALSE)
[16:06:43.933]                   }
[16:06:43.933]                   options(future.plan = NULL)
[16:06:43.933]                   if (is.na(NA_character_)) 
[16:06:43.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:43.933]                   future::plan(list(function (..., envir = parent.frame()) 
[16:06:43.933]                   {
[16:06:43.933]                     future <- SequentialFuture(..., envir = envir)
[16:06:43.933]                     if (!future$lazy) 
[16:06:43.933]                       future <- run(future)
[16:06:43.933]                     invisible(future)
[16:06:43.933]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:43.933]                 }
[16:06:43.933]             }
[16:06:43.933]         }
[16:06:43.933]     })
[16:06:43.933]     if (TRUE) {
[16:06:43.933]         base::sink(type = "output", split = FALSE)
[16:06:43.933]         if (FALSE) {
[16:06:43.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:43.933]         }
[16:06:43.933]         else {
[16:06:43.933]             ...future.result["stdout"] <- base::list(NULL)
[16:06:43.933]         }
[16:06:43.933]         base::close(...future.stdout)
[16:06:43.933]         ...future.stdout <- NULL
[16:06:43.933]     }
[16:06:43.933]     ...future.result$conditions <- ...future.conditions
[16:06:43.933]     ...future.result$finished <- base::Sys.time()
[16:06:43.933]     ...future.result
[16:06:43.933] }
[16:06:43.934] plan(): Setting new future strategy stack:
[16:06:43.935] List of future strategies:
[16:06:43.935] 1. sequential:
[16:06:43.935]    - args: function (..., envir = parent.frame())
[16:06:43.935]    - tweaked: FALSE
[16:06:43.935]    - call: NULL
[16:06:43.935] plan(): nbrOfWorkers() = 1
[16:06:43.936] plan(): Setting new future strategy stack:
[16:06:43.936] List of future strategies:
[16:06:43.936] 1. sequential:
[16:06:43.936]    - args: function (..., envir = parent.frame())
[16:06:43.936]    - tweaked: FALSE
[16:06:43.936]    - call: plan(strategy)
[16:06:43.937] plan(): nbrOfWorkers() = 1
[16:06:43.937] SequentialFuture started (and completed)
[16:06:43.937] - Launch lazy future ... done
[16:06:43.937] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:06:43"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:06:43"
 $ session_uuid: chr "cab75349-fe0c-9b79-5578-a576251b9035"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "11666ca4073c"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92386
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:06:43"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:06:43.944] getGlobalsAndPackages() ...
[16:06:43.944] Searching for globals...
[16:06:43.947] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:43.947] Searching for globals ... DONE
[16:06:43.947] Resolving globals: FALSE
[16:06:43.948] 
[16:06:43.948] - packages: [1] ‘utils’
[16:06:43.948] getGlobalsAndPackages() ... DONE
[16:06:43.948] run() for ‘Future’ ...
[16:06:43.948] - state: ‘created’
[16:06:43.948] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:06:43.949] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:06:43.949] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:06:43.949]   - Field: ‘label’
[16:06:43.949]   - Field: ‘local’
[16:06:43.949]   - Field: ‘owner’
[16:06:43.949]   - Field: ‘envir’
[16:06:43.949]   - Field: ‘packages’
[16:06:43.949]   - Field: ‘gc’
[16:06:43.949]   - Field: ‘conditions’
[16:06:43.949]   - Field: ‘expr’
[16:06:43.950]   - Field: ‘uuid’
[16:06:43.950]   - Field: ‘seed’
[16:06:43.950]   - Field: ‘version’
[16:06:43.950]   - Field: ‘result’
[16:06:43.950]   - Field: ‘asynchronous’
[16:06:43.950]   - Field: ‘calls’
[16:06:43.950]   - Field: ‘globals’
[16:06:43.950]   - Field: ‘stdout’
[16:06:43.950]   - Field: ‘earlySignal’
[16:06:43.950]   - Field: ‘lazy’
[16:06:43.950]   - Field: ‘state’
[16:06:43.950] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:06:43.951] - Launch lazy future ...
[16:06:43.951] Packages needed by the future expression (n = 1): ‘utils’
[16:06:43.951] Packages needed by future strategies (n = 0): <none>
[16:06:43.951] {
[16:06:43.951]     {
[16:06:43.951]         {
[16:06:43.951]             ...future.startTime <- base::Sys.time()
[16:06:43.951]             {
[16:06:43.951]                 {
[16:06:43.951]                   {
[16:06:43.951]                     {
[16:06:43.951]                       base::local({
[16:06:43.951]                         has_future <- base::requireNamespace("future", 
[16:06:43.951]                           quietly = TRUE)
[16:06:43.951]                         if (has_future) {
[16:06:43.951]                           ns <- base::getNamespace("future")
[16:06:43.951]                           version <- ns[[".package"]][["version"]]
[16:06:43.951]                           if (is.null(version)) 
[16:06:43.951]                             version <- utils::packageVersion("future")
[16:06:43.951]                         }
[16:06:43.951]                         else {
[16:06:43.951]                           version <- NULL
[16:06:43.951]                         }
[16:06:43.951]                         if (!has_future || version < "1.8.0") {
[16:06:43.951]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:43.951]                             "", base::R.version$version.string), 
[16:06:43.951]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:43.951]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:43.951]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:43.951]                               "release", "version")], collapse = " "), 
[16:06:43.951]                             hostname = base::Sys.info()[["nodename"]])
[16:06:43.951]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:43.951]                             info)
[16:06:43.951]                           info <- base::paste(info, collapse = "; ")
[16:06:43.951]                           if (!has_future) {
[16:06:43.951]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:43.951]                               info)
[16:06:43.951]                           }
[16:06:43.951]                           else {
[16:06:43.951]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:43.951]                               info, version)
[16:06:43.951]                           }
[16:06:43.951]                           base::stop(msg)
[16:06:43.951]                         }
[16:06:43.951]                       })
[16:06:43.951]                     }
[16:06:43.951]                     base::local({
[16:06:43.951]                       for (pkg in "utils") {
[16:06:43.951]                         base::loadNamespace(pkg)
[16:06:43.951]                         base::library(pkg, character.only = TRUE)
[16:06:43.951]                       }
[16:06:43.951]                     })
[16:06:43.951]                   }
[16:06:43.951]                   options(future.plan = NULL)
[16:06:43.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:43.951]                 }
[16:06:43.951]                 ...future.workdir <- getwd()
[16:06:43.951]             }
[16:06:43.951]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:43.951]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:43.951]         }
[16:06:43.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:43.951]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:43.951]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:43.951]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:43.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:43.951]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:43.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:43.951]             base::names(...future.oldOptions))
[16:06:43.951]     }
[16:06:43.951]     if (FALSE) {
[16:06:43.951]     }
[16:06:43.951]     else {
[16:06:43.951]         if (FALSE) {
[16:06:43.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:43.951]                 open = "w")
[16:06:43.951]         }
[16:06:43.951]         else {
[16:06:43.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:43.951]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:43.951]         }
[16:06:43.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:43.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:43.951]             base::sink(type = "output", split = FALSE)
[16:06:43.951]             base::close(...future.stdout)
[16:06:43.951]         }, add = TRUE)
[16:06:43.951]     }
[16:06:43.951]     ...future.frame <- base::sys.nframe()
[16:06:43.951]     ...future.conditions <- base::list()
[16:06:43.951]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:43.951]     if (FALSE) {
[16:06:43.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:43.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:43.951]     }
[16:06:43.951]     ...future.result <- base::tryCatch({
[16:06:43.951]         base::withCallingHandlers({
[16:06:43.951]             ...future.value <- base::withVisible(base::local({
[16:06:43.951]                 print(1:50)
[16:06:43.951]                 str(1:50)
[16:06:43.951]                 cat(letters, sep = "-")
[16:06:43.951]                 cat(1:6, collapse = "\n")
[16:06:43.951]                 write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:43.951]                 42L
[16:06:43.951]             }))
[16:06:43.951]             future::FutureResult(value = ...future.value$value, 
[16:06:43.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.951]                   ...future.rng), globalenv = if (FALSE) 
[16:06:43.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:43.951]                     ...future.globalenv.names))
[16:06:43.951]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:43.951]         }, condition = base::local({
[16:06:43.951]             c <- base::c
[16:06:43.951]             inherits <- base::inherits
[16:06:43.951]             invokeRestart <- base::invokeRestart
[16:06:43.951]             length <- base::length
[16:06:43.951]             list <- base::list
[16:06:43.951]             seq.int <- base::seq.int
[16:06:43.951]             signalCondition <- base::signalCondition
[16:06:43.951]             sys.calls <- base::sys.calls
[16:06:43.951]             `[[` <- base::`[[`
[16:06:43.951]             `+` <- base::`+`
[16:06:43.951]             `<<-` <- base::`<<-`
[16:06:43.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:43.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:43.951]                   3L)]
[16:06:43.951]             }
[16:06:43.951]             function(cond) {
[16:06:43.951]                 is_error <- inherits(cond, "error")
[16:06:43.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:43.951]                   NULL)
[16:06:43.951]                 if (is_error) {
[16:06:43.951]                   sessionInformation <- function() {
[16:06:43.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:43.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:43.951]                       search = base::search(), system = base::Sys.info())
[16:06:43.951]                   }
[16:06:43.951]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:43.951]                     cond$call), session = sessionInformation(), 
[16:06:43.951]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:43.951]                   signalCondition(cond)
[16:06:43.951]                 }
[16:06:43.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:43.951]                 "immediateCondition"))) {
[16:06:43.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:43.951]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:43.951]                   if (TRUE && !signal) {
[16:06:43.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.951]                     {
[16:06:43.951]                       inherits <- base::inherits
[16:06:43.951]                       invokeRestart <- base::invokeRestart
[16:06:43.951]                       is.null <- base::is.null
[16:06:43.951]                       muffled <- FALSE
[16:06:43.951]                       if (inherits(cond, "message")) {
[16:06:43.951]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.951]                         if (muffled) 
[16:06:43.951]                           invokeRestart("muffleMessage")
[16:06:43.951]                       }
[16:06:43.951]                       else if (inherits(cond, "warning")) {
[16:06:43.951]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.951]                         if (muffled) 
[16:06:43.951]                           invokeRestart("muffleWarning")
[16:06:43.951]                       }
[16:06:43.951]                       else if (inherits(cond, "condition")) {
[16:06:43.951]                         if (!is.null(pattern)) {
[16:06:43.951]                           computeRestarts <- base::computeRestarts
[16:06:43.951]                           grepl <- base::grepl
[16:06:43.951]                           restarts <- computeRestarts(cond)
[16:06:43.951]                           for (restart in restarts) {
[16:06:43.951]                             name <- restart$name
[16:06:43.951]                             if (is.null(name)) 
[16:06:43.951]                               next
[16:06:43.951]                             if (!grepl(pattern, name)) 
[16:06:43.951]                               next
[16:06:43.951]                             invokeRestart(restart)
[16:06:43.951]                             muffled <- TRUE
[16:06:43.951]                             break
[16:06:43.951]                           }
[16:06:43.951]                         }
[16:06:43.951]                       }
[16:06:43.951]                       invisible(muffled)
[16:06:43.951]                     }
[16:06:43.951]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.951]                   }
[16:06:43.951]                 }
[16:06:43.951]                 else {
[16:06:43.951]                   if (TRUE) {
[16:06:43.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.951]                     {
[16:06:43.951]                       inherits <- base::inherits
[16:06:43.951]                       invokeRestart <- base::invokeRestart
[16:06:43.951]                       is.null <- base::is.null
[16:06:43.951]                       muffled <- FALSE
[16:06:43.951]                       if (inherits(cond, "message")) {
[16:06:43.951]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.951]                         if (muffled) 
[16:06:43.951]                           invokeRestart("muffleMessage")
[16:06:43.951]                       }
[16:06:43.951]                       else if (inherits(cond, "warning")) {
[16:06:43.951]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.951]                         if (muffled) 
[16:06:43.951]                           invokeRestart("muffleWarning")
[16:06:43.951]                       }
[16:06:43.951]                       else if (inherits(cond, "condition")) {
[16:06:43.951]                         if (!is.null(pattern)) {
[16:06:43.951]                           computeRestarts <- base::computeRestarts
[16:06:43.951]                           grepl <- base::grepl
[16:06:43.951]                           restarts <- computeRestarts(cond)
[16:06:43.951]                           for (restart in restarts) {
[16:06:43.951]                             name <- restart$name
[16:06:43.951]                             if (is.null(name)) 
[16:06:43.951]                               next
[16:06:43.951]                             if (!grepl(pattern, name)) 
[16:06:43.951]                               next
[16:06:43.951]                             invokeRestart(restart)
[16:06:43.951]                             muffled <- TRUE
[16:06:43.951]                             break
[16:06:43.951]                           }
[16:06:43.951]                         }
[16:06:43.951]                       }
[16:06:43.951]                       invisible(muffled)
[16:06:43.951]                     }
[16:06:43.951]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.951]                   }
[16:06:43.951]                 }
[16:06:43.951]             }
[16:06:43.951]         }))
[16:06:43.951]     }, error = function(ex) {
[16:06:43.951]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:43.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.951]                 ...future.rng), started = ...future.startTime, 
[16:06:43.951]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:43.951]             version = "1.8"), class = "FutureResult")
[16:06:43.951]     }, finally = {
[16:06:43.951]         if (!identical(...future.workdir, getwd())) 
[16:06:43.951]             setwd(...future.workdir)
[16:06:43.951]         {
[16:06:43.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:43.951]                 ...future.oldOptions$nwarnings <- NULL
[16:06:43.951]             }
[16:06:43.951]             base::options(...future.oldOptions)
[16:06:43.951]             if (.Platform$OS.type == "windows") {
[16:06:43.951]                 old_names <- names(...future.oldEnvVars)
[16:06:43.951]                 envs <- base::Sys.getenv()
[16:06:43.951]                 names <- names(envs)
[16:06:43.951]                 common <- intersect(names, old_names)
[16:06:43.951]                 added <- setdiff(names, old_names)
[16:06:43.951]                 removed <- setdiff(old_names, names)
[16:06:43.951]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:43.951]                   envs[common]]
[16:06:43.951]                 NAMES <- toupper(changed)
[16:06:43.951]                 args <- list()
[16:06:43.951]                 for (kk in seq_along(NAMES)) {
[16:06:43.951]                   name <- changed[[kk]]
[16:06:43.951]                   NAME <- NAMES[[kk]]
[16:06:43.951]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.951]                     next
[16:06:43.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.951]                 }
[16:06:43.951]                 NAMES <- toupper(added)
[16:06:43.951]                 for (kk in seq_along(NAMES)) {
[16:06:43.951]                   name <- added[[kk]]
[16:06:43.951]                   NAME <- NAMES[[kk]]
[16:06:43.951]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.951]                     next
[16:06:43.951]                   args[[name]] <- ""
[16:06:43.951]                 }
[16:06:43.951]                 NAMES <- toupper(removed)
[16:06:43.951]                 for (kk in seq_along(NAMES)) {
[16:06:43.951]                   name <- removed[[kk]]
[16:06:43.951]                   NAME <- NAMES[[kk]]
[16:06:43.951]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.951]                     next
[16:06:43.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.951]                 }
[16:06:43.951]                 if (length(args) > 0) 
[16:06:43.951]                   base::do.call(base::Sys.setenv, args = args)
[16:06:43.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:43.951]             }
[16:06:43.951]             else {
[16:06:43.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:43.951]             }
[16:06:43.951]             {
[16:06:43.951]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:43.951]                   0L) {
[16:06:43.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:43.951]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:43.951]                   base::options(opts)
[16:06:43.951]                 }
[16:06:43.951]                 {
[16:06:43.951]                   {
[16:06:43.951]                     NULL
[16:06:43.951]                     RNGkind("Mersenne-Twister")
[16:06:43.951]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:06:43.951]                       inherits = FALSE)
[16:06:43.951]                   }
[16:06:43.951]                   options(future.plan = NULL)
[16:06:43.951]                   if (is.na(NA_character_)) 
[16:06:43.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:43.951]                   future::plan(list(function (..., envir = parent.frame()) 
[16:06:43.951]                   {
[16:06:43.951]                     future <- SequentialFuture(..., envir = envir)
[16:06:43.951]                     if (!future$lazy) 
[16:06:43.951]                       future <- run(future)
[16:06:43.951]                     invisible(future)
[16:06:43.951]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:43.951]                 }
[16:06:43.951]             }
[16:06:43.951]         }
[16:06:43.951]     })
[16:06:43.951]     if (TRUE) {
[16:06:43.951]         base::sink(type = "output", split = FALSE)
[16:06:43.951]         if (FALSE) {
[16:06:43.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:43.951]         }
[16:06:43.951]         else {
[16:06:43.951]             ...future.result["stdout"] <- base::list(NULL)
[16:06:43.951]         }
[16:06:43.951]         base::close(...future.stdout)
[16:06:43.951]         ...future.stdout <- NULL
[16:06:43.951]     }
[16:06:43.951]     ...future.result$conditions <- ...future.conditions
[16:06:43.951]     ...future.result$finished <- base::Sys.time()
[16:06:43.951]     ...future.result
[16:06:43.951] }
[16:06:43.953] plan(): Setting new future strategy stack:
[16:06:43.953] List of future strategies:
[16:06:43.953] 1. sequential:
[16:06:43.953]    - args: function (..., envir = parent.frame())
[16:06:43.953]    - tweaked: FALSE
[16:06:43.953]    - call: NULL
[16:06:43.954] plan(): nbrOfWorkers() = 1
[16:06:43.955] plan(): Setting new future strategy stack:
[16:06:43.955] List of future strategies:
[16:06:43.955] 1. sequential:
[16:06:43.955]    - args: function (..., envir = parent.frame())
[16:06:43.955]    - tweaked: FALSE
[16:06:43.955]    - call: plan(strategy)
[16:06:43.955] plan(): nbrOfWorkers() = 1
[16:06:43.955] SequentialFuture started (and completed)
[16:06:43.956] - Launch lazy future ... done
[16:06:43.956] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[16:06:43.956] getGlobalsAndPackages() ...
[16:06:43.956] Searching for globals...
[16:06:43.956] - globals found: [1] ‘print’
[16:06:43.957] Searching for globals ... DONE
[16:06:43.957] Resolving globals: FALSE
[16:06:43.957] 
[16:06:43.957] 
[16:06:43.957] getGlobalsAndPackages() ... DONE
[16:06:43.957] run() for ‘Future’ ...
[16:06:43.957] - state: ‘created’
[16:06:43.958] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:06:43.959] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:06:43.959] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:06:43.959]   - Field: ‘label’
[16:06:43.959]   - Field: ‘local’
[16:06:43.959]   - Field: ‘owner’
[16:06:43.959]   - Field: ‘envir’
[16:06:43.959]   - Field: ‘packages’
[16:06:43.959]   - Field: ‘gc’
[16:06:43.959]   - Field: ‘conditions’
[16:06:43.960]   - Field: ‘expr’
[16:06:43.960]   - Field: ‘uuid’
[16:06:43.960]   - Field: ‘seed’
[16:06:43.960]   - Field: ‘version’
[16:06:43.960]   - Field: ‘result’
[16:06:43.960]   - Field: ‘asynchronous’
[16:06:43.960]   - Field: ‘calls’
[16:06:43.960]   - Field: ‘globals’
[16:06:43.960]   - Field: ‘stdout’
[16:06:43.960]   - Field: ‘earlySignal’
[16:06:43.960]   - Field: ‘lazy’
[16:06:43.960]   - Field: ‘state’
[16:06:43.961] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:06:43.961] - Launch lazy future ...
[16:06:43.961] Packages needed by the future expression (n = 0): <none>
[16:06:43.961] Packages needed by future strategies (n = 0): <none>
[16:06:43.961] {
[16:06:43.961]     {
[16:06:43.961]         {
[16:06:43.961]             ...future.startTime <- base::Sys.time()
[16:06:43.961]             {
[16:06:43.961]                 {
[16:06:43.961]                   {
[16:06:43.961]                     base::local({
[16:06:43.961]                       has_future <- base::requireNamespace("future", 
[16:06:43.961]                         quietly = TRUE)
[16:06:43.961]                       if (has_future) {
[16:06:43.961]                         ns <- base::getNamespace("future")
[16:06:43.961]                         version <- ns[[".package"]][["version"]]
[16:06:43.961]                         if (is.null(version)) 
[16:06:43.961]                           version <- utils::packageVersion("future")
[16:06:43.961]                       }
[16:06:43.961]                       else {
[16:06:43.961]                         version <- NULL
[16:06:43.961]                       }
[16:06:43.961]                       if (!has_future || version < "1.8.0") {
[16:06:43.961]                         info <- base::c(r_version = base::gsub("R version ", 
[16:06:43.961]                           "", base::R.version$version.string), 
[16:06:43.961]                           platform = base::sprintf("%s (%s-bit)", 
[16:06:43.961]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:43.961]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:43.961]                             "release", "version")], collapse = " "), 
[16:06:43.961]                           hostname = base::Sys.info()[["nodename"]])
[16:06:43.961]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:06:43.961]                           info)
[16:06:43.961]                         info <- base::paste(info, collapse = "; ")
[16:06:43.961]                         if (!has_future) {
[16:06:43.961]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:43.961]                             info)
[16:06:43.961]                         }
[16:06:43.961]                         else {
[16:06:43.961]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:43.961]                             info, version)
[16:06:43.961]                         }
[16:06:43.961]                         base::stop(msg)
[16:06:43.961]                       }
[16:06:43.961]                     })
[16:06:43.961]                   }
[16:06:43.961]                   options(future.plan = NULL)
[16:06:43.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:43.961]                 }
[16:06:43.961]                 ...future.workdir <- getwd()
[16:06:43.961]             }
[16:06:43.961]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:43.961]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:43.961]         }
[16:06:43.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:43.961]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:43.961]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:43.961]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:43.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:43.961]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:43.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:43.961]             base::names(...future.oldOptions))
[16:06:43.961]     }
[16:06:43.961]     if (FALSE) {
[16:06:43.961]     }
[16:06:43.961]     else {
[16:06:43.961]         if (TRUE) {
[16:06:43.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:43.961]                 open = "w")
[16:06:43.961]         }
[16:06:43.961]         else {
[16:06:43.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:43.961]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:43.961]         }
[16:06:43.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:43.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:43.961]             base::sink(type = "output", split = FALSE)
[16:06:43.961]             base::close(...future.stdout)
[16:06:43.961]         }, add = TRUE)
[16:06:43.961]     }
[16:06:43.961]     ...future.frame <- base::sys.nframe()
[16:06:43.961]     ...future.conditions <- base::list()
[16:06:43.961]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:43.961]     if (FALSE) {
[16:06:43.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:43.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:43.961]     }
[16:06:43.961]     ...future.result <- base::tryCatch({
[16:06:43.961]         base::withCallingHandlers({
[16:06:43.961]             ...future.value <- base::withVisible(base::local(print(42)))
[16:06:43.961]             future::FutureResult(value = ...future.value$value, 
[16:06:43.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.961]                   ...future.rng), globalenv = if (FALSE) 
[16:06:43.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:43.961]                     ...future.globalenv.names))
[16:06:43.961]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:43.961]         }, condition = base::local({
[16:06:43.961]             c <- base::c
[16:06:43.961]             inherits <- base::inherits
[16:06:43.961]             invokeRestart <- base::invokeRestart
[16:06:43.961]             length <- base::length
[16:06:43.961]             list <- base::list
[16:06:43.961]             seq.int <- base::seq.int
[16:06:43.961]             signalCondition <- base::signalCondition
[16:06:43.961]             sys.calls <- base::sys.calls
[16:06:43.961]             `[[` <- base::`[[`
[16:06:43.961]             `+` <- base::`+`
[16:06:43.961]             `<<-` <- base::`<<-`
[16:06:43.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:43.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:43.961]                   3L)]
[16:06:43.961]             }
[16:06:43.961]             function(cond) {
[16:06:43.961]                 is_error <- inherits(cond, "error")
[16:06:43.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:43.961]                   NULL)
[16:06:43.961]                 if (is_error) {
[16:06:43.961]                   sessionInformation <- function() {
[16:06:43.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:43.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:43.961]                       search = base::search(), system = base::Sys.info())
[16:06:43.961]                   }
[16:06:43.961]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:43.961]                     cond$call), session = sessionInformation(), 
[16:06:43.961]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:43.961]                   signalCondition(cond)
[16:06:43.961]                 }
[16:06:43.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:43.961]                 "immediateCondition"))) {
[16:06:43.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:43.961]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:43.961]                   if (TRUE && !signal) {
[16:06:43.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.961]                     {
[16:06:43.961]                       inherits <- base::inherits
[16:06:43.961]                       invokeRestart <- base::invokeRestart
[16:06:43.961]                       is.null <- base::is.null
[16:06:43.961]                       muffled <- FALSE
[16:06:43.961]                       if (inherits(cond, "message")) {
[16:06:43.961]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.961]                         if (muffled) 
[16:06:43.961]                           invokeRestart("muffleMessage")
[16:06:43.961]                       }
[16:06:43.961]                       else if (inherits(cond, "warning")) {
[16:06:43.961]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.961]                         if (muffled) 
[16:06:43.961]                           invokeRestart("muffleWarning")
[16:06:43.961]                       }
[16:06:43.961]                       else if (inherits(cond, "condition")) {
[16:06:43.961]                         if (!is.null(pattern)) {
[16:06:43.961]                           computeRestarts <- base::computeRestarts
[16:06:43.961]                           grepl <- base::grepl
[16:06:43.961]                           restarts <- computeRestarts(cond)
[16:06:43.961]                           for (restart in restarts) {
[16:06:43.961]                             name <- restart$name
[16:06:43.961]                             if (is.null(name)) 
[16:06:43.961]                               next
[16:06:43.961]                             if (!grepl(pattern, name)) 
[16:06:43.961]                               next
[16:06:43.961]                             invokeRestart(restart)
[16:06:43.961]                             muffled <- TRUE
[16:06:43.961]                             break
[16:06:43.961]                           }
[16:06:43.961]                         }
[16:06:43.961]                       }
[16:06:43.961]                       invisible(muffled)
[16:06:43.961]                     }
[16:06:43.961]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.961]                   }
[16:06:43.961]                 }
[16:06:43.961]                 else {
[16:06:43.961]                   if (TRUE) {
[16:06:43.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.961]                     {
[16:06:43.961]                       inherits <- base::inherits
[16:06:43.961]                       invokeRestart <- base::invokeRestart
[16:06:43.961]                       is.null <- base::is.null
[16:06:43.961]                       muffled <- FALSE
[16:06:43.961]                       if (inherits(cond, "message")) {
[16:06:43.961]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.961]                         if (muffled) 
[16:06:43.961]                           invokeRestart("muffleMessage")
[16:06:43.961]                       }
[16:06:43.961]                       else if (inherits(cond, "warning")) {
[16:06:43.961]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.961]                         if (muffled) 
[16:06:43.961]                           invokeRestart("muffleWarning")
[16:06:43.961]                       }
[16:06:43.961]                       else if (inherits(cond, "condition")) {
[16:06:43.961]                         if (!is.null(pattern)) {
[16:06:43.961]                           computeRestarts <- base::computeRestarts
[16:06:43.961]                           grepl <- base::grepl
[16:06:43.961]                           restarts <- computeRestarts(cond)
[16:06:43.961]                           for (restart in restarts) {
[16:06:43.961]                             name <- restart$name
[16:06:43.961]                             if (is.null(name)) 
[16:06:43.961]                               next
[16:06:43.961]                             if (!grepl(pattern, name)) 
[16:06:43.961]                               next
[16:06:43.961]                             invokeRestart(restart)
[16:06:43.961]                             muffled <- TRUE
[16:06:43.961]                             break
[16:06:43.961]                           }
[16:06:43.961]                         }
[16:06:43.961]                       }
[16:06:43.961]                       invisible(muffled)
[16:06:43.961]                     }
[16:06:43.961]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.961]                   }
[16:06:43.961]                 }
[16:06:43.961]             }
[16:06:43.961]         }))
[16:06:43.961]     }, error = function(ex) {
[16:06:43.961]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:43.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.961]                 ...future.rng), started = ...future.startTime, 
[16:06:43.961]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:43.961]             version = "1.8"), class = "FutureResult")
[16:06:43.961]     }, finally = {
[16:06:43.961]         if (!identical(...future.workdir, getwd())) 
[16:06:43.961]             setwd(...future.workdir)
[16:06:43.961]         {
[16:06:43.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:43.961]                 ...future.oldOptions$nwarnings <- NULL
[16:06:43.961]             }
[16:06:43.961]             base::options(...future.oldOptions)
[16:06:43.961]             if (.Platform$OS.type == "windows") {
[16:06:43.961]                 old_names <- names(...future.oldEnvVars)
[16:06:43.961]                 envs <- base::Sys.getenv()
[16:06:43.961]                 names <- names(envs)
[16:06:43.961]                 common <- intersect(names, old_names)
[16:06:43.961]                 added <- setdiff(names, old_names)
[16:06:43.961]                 removed <- setdiff(old_names, names)
[16:06:43.961]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:43.961]                   envs[common]]
[16:06:43.961]                 NAMES <- toupper(changed)
[16:06:43.961]                 args <- list()
[16:06:43.961]                 for (kk in seq_along(NAMES)) {
[16:06:43.961]                   name <- changed[[kk]]
[16:06:43.961]                   NAME <- NAMES[[kk]]
[16:06:43.961]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.961]                     next
[16:06:43.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.961]                 }
[16:06:43.961]                 NAMES <- toupper(added)
[16:06:43.961]                 for (kk in seq_along(NAMES)) {
[16:06:43.961]                   name <- added[[kk]]
[16:06:43.961]                   NAME <- NAMES[[kk]]
[16:06:43.961]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.961]                     next
[16:06:43.961]                   args[[name]] <- ""
[16:06:43.961]                 }
[16:06:43.961]                 NAMES <- toupper(removed)
[16:06:43.961]                 for (kk in seq_along(NAMES)) {
[16:06:43.961]                   name <- removed[[kk]]
[16:06:43.961]                   NAME <- NAMES[[kk]]
[16:06:43.961]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.961]                     next
[16:06:43.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.961]                 }
[16:06:43.961]                 if (length(args) > 0) 
[16:06:43.961]                   base::do.call(base::Sys.setenv, args = args)
[16:06:43.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:43.961]             }
[16:06:43.961]             else {
[16:06:43.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:43.961]             }
[16:06:43.961]             {
[16:06:43.961]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:43.961]                   0L) {
[16:06:43.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:43.961]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:43.961]                   base::options(opts)
[16:06:43.961]                 }
[16:06:43.961]                 {
[16:06:43.961]                   {
[16:06:43.961]                     NULL
[16:06:43.961]                     RNGkind("Mersenne-Twister")
[16:06:43.961]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:06:43.961]                       inherits = FALSE)
[16:06:43.961]                   }
[16:06:43.961]                   options(future.plan = NULL)
[16:06:43.961]                   if (is.na(NA_character_)) 
[16:06:43.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:43.961]                   future::plan(list(function (..., envir = parent.frame()) 
[16:06:43.961]                   {
[16:06:43.961]                     future <- SequentialFuture(..., envir = envir)
[16:06:43.961]                     if (!future$lazy) 
[16:06:43.961]                       future <- run(future)
[16:06:43.961]                     invisible(future)
[16:06:43.961]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:43.961]                 }
[16:06:43.961]             }
[16:06:43.961]         }
[16:06:43.961]     })
[16:06:43.961]     if (TRUE) {
[16:06:43.961]         base::sink(type = "output", split = FALSE)
[16:06:43.961]         if (TRUE) {
[16:06:43.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:43.961]         }
[16:06:43.961]         else {
[16:06:43.961]             ...future.result["stdout"] <- base::list(NULL)
[16:06:43.961]         }
[16:06:43.961]         base::close(...future.stdout)
[16:06:43.961]         ...future.stdout <- NULL
[16:06:43.961]     }
[16:06:43.961]     ...future.result$conditions <- ...future.conditions
[16:06:43.961]     ...future.result$finished <- base::Sys.time()
[16:06:43.961]     ...future.result
[16:06:43.961] }
[16:06:43.963] plan(): Setting new future strategy stack:
[16:06:43.963] List of future strategies:
[16:06:43.963] 1. sequential:
[16:06:43.963]    - args: function (..., envir = parent.frame())
[16:06:43.963]    - tweaked: FALSE
[16:06:43.963]    - call: NULL
[16:06:43.963] plan(): nbrOfWorkers() = 1
[16:06:43.964] plan(): Setting new future strategy stack:
[16:06:43.964] List of future strategies:
[16:06:43.964] 1. sequential:
[16:06:43.964]    - args: function (..., envir = parent.frame())
[16:06:43.964]    - tweaked: FALSE
[16:06:43.964]    - call: plan(strategy)
[16:06:43.964] plan(): nbrOfWorkers() = 1
[16:06:43.965] SequentialFuture started (and completed)
[16:06:43.965] - Launch lazy future ... done
[16:06:43.965] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = NA
[16:06:43.965] getGlobalsAndPackages() ...
[16:06:43.965] Searching for globals...
[16:06:43.968] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:43.968] Searching for globals ... DONE
[16:06:43.968] Resolving globals: FALSE
[16:06:43.969] 
[16:06:43.969] - packages: [1] ‘utils’
[16:06:43.969] getGlobalsAndPackages() ... DONE
[16:06:43.969] run() for ‘Future’ ...
[16:06:43.969] - state: ‘created’
[16:06:43.969] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:06:43.969] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:06:43.970] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:06:43.970]   - Field: ‘label’
[16:06:43.970]   - Field: ‘local’
[16:06:43.970]   - Field: ‘owner’
[16:06:43.970]   - Field: ‘envir’
[16:06:43.970]   - Field: ‘packages’
[16:06:43.970]   - Field: ‘gc’
[16:06:43.970]   - Field: ‘conditions’
[16:06:43.970]   - Field: ‘expr’
[16:06:43.971]   - Field: ‘uuid’
[16:06:43.971]   - Field: ‘seed’
[16:06:43.971]   - Field: ‘version’
[16:06:43.971]   - Field: ‘result’
[16:06:43.971]   - Field: ‘asynchronous’
[16:06:43.971]   - Field: ‘calls’
[16:06:43.971]   - Field: ‘globals’
[16:06:43.971]   - Field: ‘stdout’
[16:06:43.971]   - Field: ‘earlySignal’
[16:06:43.971]   - Field: ‘lazy’
[16:06:43.971]   - Field: ‘state’
[16:06:43.972] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:06:43.972] - Launch lazy future ...
[16:06:43.972] Packages needed by the future expression (n = 1): ‘utils’
[16:06:43.972] Packages needed by future strategies (n = 0): <none>
[16:06:43.972] {
[16:06:43.972]     {
[16:06:43.972]         {
[16:06:43.972]             ...future.startTime <- base::Sys.time()
[16:06:43.972]             {
[16:06:43.972]                 {
[16:06:43.972]                   {
[16:06:43.972]                     {
[16:06:43.972]                       base::local({
[16:06:43.972]                         has_future <- base::requireNamespace("future", 
[16:06:43.972]                           quietly = TRUE)
[16:06:43.972]                         if (has_future) {
[16:06:43.972]                           ns <- base::getNamespace("future")
[16:06:43.972]                           version <- ns[[".package"]][["version"]]
[16:06:43.972]                           if (is.null(version)) 
[16:06:43.972]                             version <- utils::packageVersion("future")
[16:06:43.972]                         }
[16:06:43.972]                         else {
[16:06:43.972]                           version <- NULL
[16:06:43.972]                         }
[16:06:43.972]                         if (!has_future || version < "1.8.0") {
[16:06:43.972]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:43.972]                             "", base::R.version$version.string), 
[16:06:43.972]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:43.972]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:43.972]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:43.972]                               "release", "version")], collapse = " "), 
[16:06:43.972]                             hostname = base::Sys.info()[["nodename"]])
[16:06:43.972]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:43.972]                             info)
[16:06:43.972]                           info <- base::paste(info, collapse = "; ")
[16:06:43.972]                           if (!has_future) {
[16:06:43.972]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:43.972]                               info)
[16:06:43.972]                           }
[16:06:43.972]                           else {
[16:06:43.972]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:43.972]                               info, version)
[16:06:43.972]                           }
[16:06:43.972]                           base::stop(msg)
[16:06:43.972]                         }
[16:06:43.972]                       })
[16:06:43.972]                     }
[16:06:43.972]                     base::local({
[16:06:43.972]                       for (pkg in "utils") {
[16:06:43.972]                         base::loadNamespace(pkg)
[16:06:43.972]                         base::library(pkg, character.only = TRUE)
[16:06:43.972]                       }
[16:06:43.972]                     })
[16:06:43.972]                   }
[16:06:43.972]                   options(future.plan = NULL)
[16:06:43.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:43.972]                 }
[16:06:43.972]                 ...future.workdir <- getwd()
[16:06:43.972]             }
[16:06:43.972]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:43.972]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:43.972]         }
[16:06:43.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:43.972]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:43.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:43.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:43.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:43.972]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:43.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:43.972]             base::names(...future.oldOptions))
[16:06:43.972]     }
[16:06:43.972]     if (TRUE) {
[16:06:43.972]     }
[16:06:43.972]     else {
[16:06:43.972]         if (NA) {
[16:06:43.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:43.972]                 open = "w")
[16:06:43.972]         }
[16:06:43.972]         else {
[16:06:43.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:43.972]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:43.972]         }
[16:06:43.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:43.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:43.972]             base::sink(type = "output", split = FALSE)
[16:06:43.972]             base::close(...future.stdout)
[16:06:43.972]         }, add = TRUE)
[16:06:43.972]     }
[16:06:43.972]     ...future.frame <- base::sys.nframe()
[16:06:43.972]     ...future.conditions <- base::list()
[16:06:43.972]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:43.972]     if (FALSE) {
[16:06:43.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:43.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:43.972]     }
[16:06:43.972]     ...future.result <- base::tryCatch({
[16:06:43.972]         base::withCallingHandlers({
[16:06:43.972]             ...future.value <- base::withVisible(base::local({
[16:06:43.972]                 print(1:50)
[16:06:43.972]                 str(1:50)
[16:06:43.972]                 cat(letters, sep = "-")
[16:06:43.972]                 cat(1:6, collapse = "\n")
[16:06:43.972]                 write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:43.972]                 42L
[16:06:43.972]             }))
[16:06:43.972]             future::FutureResult(value = ...future.value$value, 
[16:06:43.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.972]                   ...future.rng), globalenv = if (FALSE) 
[16:06:43.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:43.972]                     ...future.globalenv.names))
[16:06:43.972]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:43.972]         }, condition = base::local({
[16:06:43.972]             c <- base::c
[16:06:43.972]             inherits <- base::inherits
[16:06:43.972]             invokeRestart <- base::invokeRestart
[16:06:43.972]             length <- base::length
[16:06:43.972]             list <- base::list
[16:06:43.972]             seq.int <- base::seq.int
[16:06:43.972]             signalCondition <- base::signalCondition
[16:06:43.972]             sys.calls <- base::sys.calls
[16:06:43.972]             `[[` <- base::`[[`
[16:06:43.972]             `+` <- base::`+`
[16:06:43.972]             `<<-` <- base::`<<-`
[16:06:43.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:43.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:43.972]                   3L)]
[16:06:43.972]             }
[16:06:43.972]             function(cond) {
[16:06:43.972]                 is_error <- inherits(cond, "error")
[16:06:43.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:43.972]                   NULL)
[16:06:43.972]                 if (is_error) {
[16:06:43.972]                   sessionInformation <- function() {
[16:06:43.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:43.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:43.972]                       search = base::search(), system = base::Sys.info())
[16:06:43.972]                   }
[16:06:43.972]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:43.972]                     cond$call), session = sessionInformation(), 
[16:06:43.972]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:43.972]                   signalCondition(cond)
[16:06:43.972]                 }
[16:06:43.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:43.972]                 "immediateCondition"))) {
[16:06:43.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:43.972]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:43.972]                   if (TRUE && !signal) {
[16:06:43.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.972]                     {
[16:06:43.972]                       inherits <- base::inherits
[16:06:43.972]                       invokeRestart <- base::invokeRestart
[16:06:43.972]                       is.null <- base::is.null
[16:06:43.972]                       muffled <- FALSE
[16:06:43.972]                       if (inherits(cond, "message")) {
[16:06:43.972]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.972]                         if (muffled) 
[16:06:43.972]                           invokeRestart("muffleMessage")
[16:06:43.972]                       }
[16:06:43.972]                       else if (inherits(cond, "warning")) {
[16:06:43.972]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.972]                         if (muffled) 
[16:06:43.972]                           invokeRestart("muffleWarning")
[16:06:43.972]                       }
[16:06:43.972]                       else if (inherits(cond, "condition")) {
[16:06:43.972]                         if (!is.null(pattern)) {
[16:06:43.972]                           computeRestarts <- base::computeRestarts
[16:06:43.972]                           grepl <- base::grepl
[16:06:43.972]                           restarts <- computeRestarts(cond)
[16:06:43.972]                           for (restart in restarts) {
[16:06:43.972]                             name <- restart$name
[16:06:43.972]                             if (is.null(name)) 
[16:06:43.972]                               next
[16:06:43.972]                             if (!grepl(pattern, name)) 
[16:06:43.972]                               next
[16:06:43.972]                             invokeRestart(restart)
[16:06:43.972]                             muffled <- TRUE
[16:06:43.972]                             break
[16:06:43.972]                           }
[16:06:43.972]                         }
[16:06:43.972]                       }
[16:06:43.972]                       invisible(muffled)
[16:06:43.972]                     }
[16:06:43.972]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.972]                   }
[16:06:43.972]                 }
[16:06:43.972]                 else {
[16:06:43.972]                   if (TRUE) {
[16:06:43.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.972]                     {
[16:06:43.972]                       inherits <- base::inherits
[16:06:43.972]                       invokeRestart <- base::invokeRestart
[16:06:43.972]                       is.null <- base::is.null
[16:06:43.972]                       muffled <- FALSE
[16:06:43.972]                       if (inherits(cond, "message")) {
[16:06:43.972]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.972]                         if (muffled) 
[16:06:43.972]                           invokeRestart("muffleMessage")
[16:06:43.972]                       }
[16:06:43.972]                       else if (inherits(cond, "warning")) {
[16:06:43.972]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.972]                         if (muffled) 
[16:06:43.972]                           invokeRestart("muffleWarning")
[16:06:43.972]                       }
[16:06:43.972]                       else if (inherits(cond, "condition")) {
[16:06:43.972]                         if (!is.null(pattern)) {
[16:06:43.972]                           computeRestarts <- base::computeRestarts
[16:06:43.972]                           grepl <- base::grepl
[16:06:43.972]                           restarts <- computeRestarts(cond)
[16:06:43.972]                           for (restart in restarts) {
[16:06:43.972]                             name <- restart$name
[16:06:43.972]                             if (is.null(name)) 
[16:06:43.972]                               next
[16:06:43.972]                             if (!grepl(pattern, name)) 
[16:06:43.972]                               next
[16:06:43.972]                             invokeRestart(restart)
[16:06:43.972]                             muffled <- TRUE
[16:06:43.972]                             break
[16:06:43.972]                           }
[16:06:43.972]                         }
[16:06:43.972]                       }
[16:06:43.972]                       invisible(muffled)
[16:06:43.972]                     }
[16:06:43.972]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.972]                   }
[16:06:43.972]                 }
[16:06:43.972]             }
[16:06:43.972]         }))
[16:06:43.972]     }, error = function(ex) {
[16:06:43.972]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:43.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.972]                 ...future.rng), started = ...future.startTime, 
[16:06:43.972]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:43.972]             version = "1.8"), class = "FutureResult")
[16:06:43.972]     }, finally = {
[16:06:43.972]         if (!identical(...future.workdir, getwd())) 
[16:06:43.972]             setwd(...future.workdir)
[16:06:43.972]         {
[16:06:43.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:43.972]                 ...future.oldOptions$nwarnings <- NULL
[16:06:43.972]             }
[16:06:43.972]             base::options(...future.oldOptions)
[16:06:43.972]             if (.Platform$OS.type == "windows") {
[16:06:43.972]                 old_names <- names(...future.oldEnvVars)
[16:06:43.972]                 envs <- base::Sys.getenv()
[16:06:43.972]                 names <- names(envs)
[16:06:43.972]                 common <- intersect(names, old_names)
[16:06:43.972]                 added <- setdiff(names, old_names)
[16:06:43.972]                 removed <- setdiff(old_names, names)
[16:06:43.972]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:43.972]                   envs[common]]
[16:06:43.972]                 NAMES <- toupper(changed)
[16:06:43.972]                 args <- list()
[16:06:43.972]                 for (kk in seq_along(NAMES)) {
[16:06:43.972]                   name <- changed[[kk]]
[16:06:43.972]                   NAME <- NAMES[[kk]]
[16:06:43.972]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.972]                     next
[16:06:43.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.972]                 }
[16:06:43.972]                 NAMES <- toupper(added)
[16:06:43.972]                 for (kk in seq_along(NAMES)) {
[16:06:43.972]                   name <- added[[kk]]
[16:06:43.972]                   NAME <- NAMES[[kk]]
[16:06:43.972]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.972]                     next
[16:06:43.972]                   args[[name]] <- ""
[16:06:43.972]                 }
[16:06:43.972]                 NAMES <- toupper(removed)
[16:06:43.972]                 for (kk in seq_along(NAMES)) {
[16:06:43.972]                   name <- removed[[kk]]
[16:06:43.972]                   NAME <- NAMES[[kk]]
[16:06:43.972]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.972]                     next
[16:06:43.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.972]                 }
[16:06:43.972]                 if (length(args) > 0) 
[16:06:43.972]                   base::do.call(base::Sys.setenv, args = args)
[16:06:43.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:43.972]             }
[16:06:43.972]             else {
[16:06:43.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:43.972]             }
[16:06:43.972]             {
[16:06:43.972]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:43.972]                   0L) {
[16:06:43.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:43.972]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:43.972]                   base::options(opts)
[16:06:43.972]                 }
[16:06:43.972]                 {
[16:06:43.972]                   {
[16:06:43.972]                     NULL
[16:06:43.972]                     RNGkind("Mersenne-Twister")
[16:06:43.972]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:06:43.972]                       inherits = FALSE)
[16:06:43.972]                   }
[16:06:43.972]                   options(future.plan = NULL)
[16:06:43.972]                   if (is.na(NA_character_)) 
[16:06:43.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:43.972]                   future::plan(list(function (..., envir = parent.frame()) 
[16:06:43.972]                   {
[16:06:43.972]                     future <- SequentialFuture(..., envir = envir)
[16:06:43.972]                     if (!future$lazy) 
[16:06:43.972]                       future <- run(future)
[16:06:43.972]                     invisible(future)
[16:06:43.972]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:43.972]                 }
[16:06:43.972]             }
[16:06:43.972]         }
[16:06:43.972]     })
[16:06:43.972]     if (FALSE) {
[16:06:43.972]         base::sink(type = "output", split = FALSE)
[16:06:43.972]         if (NA) {
[16:06:43.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:43.972]         }
[16:06:43.972]         else {
[16:06:43.972]             ...future.result["stdout"] <- base::list(NULL)
[16:06:43.972]         }
[16:06:43.972]         base::close(...future.stdout)
[16:06:43.972]         ...future.stdout <- NULL
[16:06:43.972]     }
[16:06:43.972]     ...future.result$conditions <- ...future.conditions
[16:06:43.972]     ...future.result$finished <- base::Sys.time()
[16:06:43.972]     ...future.result
[16:06:43.972] }
[16:06:43.974] plan(): Setting new future strategy stack:
[16:06:43.974] List of future strategies:
[16:06:43.974] 1. sequential:
[16:06:43.974]    - args: function (..., envir = parent.frame())
[16:06:43.974]    - tweaked: FALSE
[16:06:43.974]    - call: NULL
[16:06:43.975] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[16:06:43.976] plan(): Setting new future strategy stack:
[16:06:43.976] List of future strategies:
[16:06:43.976] 1. sequential:
[16:06:43.976]    - args: function (..., envir = parent.frame())
[16:06:43.976]    - tweaked: FALSE
[16:06:43.976]    - call: plan(strategy)
[16:06:43.977] plan(): nbrOfWorkers() = 1
[16:06:43.977] SequentialFuture started (and completed)
[16:06:43.977] - Launch lazy future ... done
[16:06:43.977] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:06:43"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:06:43"
 $ session_uuid: chr "cab75349-fe0c-9b79-5578-a576251b9035"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "11666ca4073c"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92386
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:06:43"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:06:43.985] getGlobalsAndPackages() ...
[16:06:43.985] Searching for globals...
[16:06:43.988] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:43.988] Searching for globals ... DONE
[16:06:43.988] Resolving globals: FALSE
[16:06:43.988] 
[16:06:43.989] - packages: [1] ‘utils’
[16:06:43.989] getGlobalsAndPackages() ... DONE
[16:06:43.989] run() for ‘Future’ ...
[16:06:43.989] - state: ‘created’
[16:06:43.989] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:06:43.989] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:06:43.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:06:43.990]   - Field: ‘label’
[16:06:43.990]   - Field: ‘local’
[16:06:43.990]   - Field: ‘owner’
[16:06:43.990]   - Field: ‘envir’
[16:06:43.990]   - Field: ‘packages’
[16:06:43.990]   - Field: ‘gc’
[16:06:43.990]   - Field: ‘conditions’
[16:06:43.990]   - Field: ‘expr’
[16:06:43.990]   - Field: ‘uuid’
[16:06:43.990]   - Field: ‘seed’
[16:06:43.990]   - Field: ‘version’
[16:06:43.991]   - Field: ‘result’
[16:06:43.991]   - Field: ‘asynchronous’
[16:06:43.991]   - Field: ‘calls’
[16:06:43.991]   - Field: ‘globals’
[16:06:43.991]   - Field: ‘stdout’
[16:06:43.991]   - Field: ‘earlySignal’
[16:06:43.991]   - Field: ‘lazy’
[16:06:43.991]   - Field: ‘state’
[16:06:43.991] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:06:43.991] - Launch lazy future ...
[16:06:43.991] Packages needed by the future expression (n = 1): ‘utils’
[16:06:43.992] Packages needed by future strategies (n = 0): <none>
[16:06:43.992] {
[16:06:43.992]     {
[16:06:43.992]         {
[16:06:43.992]             ...future.startTime <- base::Sys.time()
[16:06:43.992]             {
[16:06:43.992]                 {
[16:06:43.992]                   {
[16:06:43.992]                     {
[16:06:43.992]                       base::local({
[16:06:43.992]                         has_future <- base::requireNamespace("future", 
[16:06:43.992]                           quietly = TRUE)
[16:06:43.992]                         if (has_future) {
[16:06:43.992]                           ns <- base::getNamespace("future")
[16:06:43.992]                           version <- ns[[".package"]][["version"]]
[16:06:43.992]                           if (is.null(version)) 
[16:06:43.992]                             version <- utils::packageVersion("future")
[16:06:43.992]                         }
[16:06:43.992]                         else {
[16:06:43.992]                           version <- NULL
[16:06:43.992]                         }
[16:06:43.992]                         if (!has_future || version < "1.8.0") {
[16:06:43.992]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:43.992]                             "", base::R.version$version.string), 
[16:06:43.992]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:43.992]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:43.992]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:43.992]                               "release", "version")], collapse = " "), 
[16:06:43.992]                             hostname = base::Sys.info()[["nodename"]])
[16:06:43.992]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:43.992]                             info)
[16:06:43.992]                           info <- base::paste(info, collapse = "; ")
[16:06:43.992]                           if (!has_future) {
[16:06:43.992]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:43.992]                               info)
[16:06:43.992]                           }
[16:06:43.992]                           else {
[16:06:43.992]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:43.992]                               info, version)
[16:06:43.992]                           }
[16:06:43.992]                           base::stop(msg)
[16:06:43.992]                         }
[16:06:43.992]                       })
[16:06:43.992]                     }
[16:06:43.992]                     base::local({
[16:06:43.992]                       for (pkg in "utils") {
[16:06:43.992]                         base::loadNamespace(pkg)
[16:06:43.992]                         base::library(pkg, character.only = TRUE)
[16:06:43.992]                       }
[16:06:43.992]                     })
[16:06:43.992]                   }
[16:06:43.992]                   options(future.plan = NULL)
[16:06:43.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:43.992]                 }
[16:06:43.992]                 ...future.workdir <- getwd()
[16:06:43.992]             }
[16:06:43.992]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:43.992]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:43.992]         }
[16:06:43.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:43.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:43.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:43.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:43.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:43.992]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:43.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:43.992]             base::names(...future.oldOptions))
[16:06:43.992]     }
[16:06:43.992]     if (TRUE) {
[16:06:43.992]     }
[16:06:43.992]     else {
[16:06:43.992]         if (NA) {
[16:06:43.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:43.992]                 open = "w")
[16:06:43.992]         }
[16:06:43.992]         else {
[16:06:43.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:43.992]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:43.992]         }
[16:06:43.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:43.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:43.992]             base::sink(type = "output", split = FALSE)
[16:06:43.992]             base::close(...future.stdout)
[16:06:43.992]         }, add = TRUE)
[16:06:43.992]     }
[16:06:43.992]     ...future.frame <- base::sys.nframe()
[16:06:43.992]     ...future.conditions <- base::list()
[16:06:43.992]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:43.992]     if (FALSE) {
[16:06:43.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:43.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:43.992]     }
[16:06:43.992]     ...future.result <- base::tryCatch({
[16:06:43.992]         base::withCallingHandlers({
[16:06:43.992]             ...future.value <- base::withVisible(base::local({
[16:06:43.992]                 print(1:50)
[16:06:43.992]                 str(1:50)
[16:06:43.992]                 cat(letters, sep = "-")
[16:06:43.992]                 cat(1:6, collapse = "\n")
[16:06:43.992]                 write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:43.992]                 42L
[16:06:43.992]             }))
[16:06:43.992]             future::FutureResult(value = ...future.value$value, 
[16:06:43.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.992]                   ...future.rng), globalenv = if (FALSE) 
[16:06:43.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:43.992]                     ...future.globalenv.names))
[16:06:43.992]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:43.992]         }, condition = base::local({
[16:06:43.992]             c <- base::c
[16:06:43.992]             inherits <- base::inherits
[16:06:43.992]             invokeRestart <- base::invokeRestart
[16:06:43.992]             length <- base::length
[16:06:43.992]             list <- base::list
[16:06:43.992]             seq.int <- base::seq.int
[16:06:43.992]             signalCondition <- base::signalCondition
[16:06:43.992]             sys.calls <- base::sys.calls
[16:06:43.992]             `[[` <- base::`[[`
[16:06:43.992]             `+` <- base::`+`
[16:06:43.992]             `<<-` <- base::`<<-`
[16:06:43.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:43.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:43.992]                   3L)]
[16:06:43.992]             }
[16:06:43.992]             function(cond) {
[16:06:43.992]                 is_error <- inherits(cond, "error")
[16:06:43.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:43.992]                   NULL)
[16:06:43.992]                 if (is_error) {
[16:06:43.992]                   sessionInformation <- function() {
[16:06:43.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:43.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:43.992]                       search = base::search(), system = base::Sys.info())
[16:06:43.992]                   }
[16:06:43.992]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:43.992]                     cond$call), session = sessionInformation(), 
[16:06:43.992]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:43.992]                   signalCondition(cond)
[16:06:43.992]                 }
[16:06:43.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:43.992]                 "immediateCondition"))) {
[16:06:43.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:43.992]                   ...future.conditions[[length(...future.conditions) + 
[16:06:43.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:43.992]                   if (TRUE && !signal) {
[16:06:43.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.992]                     {
[16:06:43.992]                       inherits <- base::inherits
[16:06:43.992]                       invokeRestart <- base::invokeRestart
[16:06:43.992]                       is.null <- base::is.null
[16:06:43.992]                       muffled <- FALSE
[16:06:43.992]                       if (inherits(cond, "message")) {
[16:06:43.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.992]                         if (muffled) 
[16:06:43.992]                           invokeRestart("muffleMessage")
[16:06:43.992]                       }
[16:06:43.992]                       else if (inherits(cond, "warning")) {
[16:06:43.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.992]                         if (muffled) 
[16:06:43.992]                           invokeRestart("muffleWarning")
[16:06:43.992]                       }
[16:06:43.992]                       else if (inherits(cond, "condition")) {
[16:06:43.992]                         if (!is.null(pattern)) {
[16:06:43.992]                           computeRestarts <- base::computeRestarts
[16:06:43.992]                           grepl <- base::grepl
[16:06:43.992]                           restarts <- computeRestarts(cond)
[16:06:43.992]                           for (restart in restarts) {
[16:06:43.992]                             name <- restart$name
[16:06:43.992]                             if (is.null(name)) 
[16:06:43.992]                               next
[16:06:43.992]                             if (!grepl(pattern, name)) 
[16:06:43.992]                               next
[16:06:43.992]                             invokeRestart(restart)
[16:06:43.992]                             muffled <- TRUE
[16:06:43.992]                             break
[16:06:43.992]                           }
[16:06:43.992]                         }
[16:06:43.992]                       }
[16:06:43.992]                       invisible(muffled)
[16:06:43.992]                     }
[16:06:43.992]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.992]                   }
[16:06:43.992]                 }
[16:06:43.992]                 else {
[16:06:43.992]                   if (TRUE) {
[16:06:43.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:43.992]                     {
[16:06:43.992]                       inherits <- base::inherits
[16:06:43.992]                       invokeRestart <- base::invokeRestart
[16:06:43.992]                       is.null <- base::is.null
[16:06:43.992]                       muffled <- FALSE
[16:06:43.992]                       if (inherits(cond, "message")) {
[16:06:43.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:43.992]                         if (muffled) 
[16:06:43.992]                           invokeRestart("muffleMessage")
[16:06:43.992]                       }
[16:06:43.992]                       else if (inherits(cond, "warning")) {
[16:06:43.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:43.992]                         if (muffled) 
[16:06:43.992]                           invokeRestart("muffleWarning")
[16:06:43.992]                       }
[16:06:43.992]                       else if (inherits(cond, "condition")) {
[16:06:43.992]                         if (!is.null(pattern)) {
[16:06:43.992]                           computeRestarts <- base::computeRestarts
[16:06:43.992]                           grepl <- base::grepl
[16:06:43.992]                           restarts <- computeRestarts(cond)
[16:06:43.992]                           for (restart in restarts) {
[16:06:43.992]                             name <- restart$name
[16:06:43.992]                             if (is.null(name)) 
[16:06:43.992]                               next
[16:06:43.992]                             if (!grepl(pattern, name)) 
[16:06:43.992]                               next
[16:06:43.992]                             invokeRestart(restart)
[16:06:43.992]                             muffled <- TRUE
[16:06:43.992]                             break
[16:06:43.992]                           }
[16:06:43.992]                         }
[16:06:43.992]                       }
[16:06:43.992]                       invisible(muffled)
[16:06:43.992]                     }
[16:06:43.992]                     muffleCondition(cond, pattern = "^muffle")
[16:06:43.992]                   }
[16:06:43.992]                 }
[16:06:43.992]             }
[16:06:43.992]         }))
[16:06:43.992]     }, error = function(ex) {
[16:06:43.992]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:43.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:43.992]                 ...future.rng), started = ...future.startTime, 
[16:06:43.992]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:43.992]             version = "1.8"), class = "FutureResult")
[16:06:43.992]     }, finally = {
[16:06:43.992]         if (!identical(...future.workdir, getwd())) 
[16:06:43.992]             setwd(...future.workdir)
[16:06:43.992]         {
[16:06:43.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:43.992]                 ...future.oldOptions$nwarnings <- NULL
[16:06:43.992]             }
[16:06:43.992]             base::options(...future.oldOptions)
[16:06:43.992]             if (.Platform$OS.type == "windows") {
[16:06:43.992]                 old_names <- names(...future.oldEnvVars)
[16:06:43.992]                 envs <- base::Sys.getenv()
[16:06:43.992]                 names <- names(envs)
[16:06:43.992]                 common <- intersect(names, old_names)
[16:06:43.992]                 added <- setdiff(names, old_names)
[16:06:43.992]                 removed <- setdiff(old_names, names)
[16:06:43.992]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:43.992]                   envs[common]]
[16:06:43.992]                 NAMES <- toupper(changed)
[16:06:43.992]                 args <- list()
[16:06:43.992]                 for (kk in seq_along(NAMES)) {
[16:06:43.992]                   name <- changed[[kk]]
[16:06:43.992]                   NAME <- NAMES[[kk]]
[16:06:43.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.992]                     next
[16:06:43.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.992]                 }
[16:06:43.992]                 NAMES <- toupper(added)
[16:06:43.992]                 for (kk in seq_along(NAMES)) {
[16:06:43.992]                   name <- added[[kk]]
[16:06:43.992]                   NAME <- NAMES[[kk]]
[16:06:43.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.992]                     next
[16:06:43.992]                   args[[name]] <- ""
[16:06:43.992]                 }
[16:06:43.992]                 NAMES <- toupper(removed)
[16:06:43.992]                 for (kk in seq_along(NAMES)) {
[16:06:43.992]                   name <- removed[[kk]]
[16:06:43.992]                   NAME <- NAMES[[kk]]
[16:06:43.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:43.992]                     next
[16:06:43.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:43.992]                 }
[16:06:43.992]                 if (length(args) > 0) 
[16:06:43.992]                   base::do.call(base::Sys.setenv, args = args)
[16:06:43.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:43.992]             }
[16:06:43.992]             else {
[16:06:43.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:43.992]             }
[16:06:43.992]             {
[16:06:43.992]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:43.992]                   0L) {
[16:06:43.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:43.992]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:43.992]                   base::options(opts)
[16:06:43.992]                 }
[16:06:43.992]                 {
[16:06:43.992]                   {
[16:06:43.992]                     NULL
[16:06:43.992]                     RNGkind("Mersenne-Twister")
[16:06:43.992]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:06:43.992]                       inherits = FALSE)
[16:06:43.992]                   }
[16:06:43.992]                   options(future.plan = NULL)
[16:06:43.992]                   if (is.na(NA_character_)) 
[16:06:43.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:43.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:43.992]                   future::plan(list(function (..., envir = parent.frame()) 
[16:06:43.992]                   {
[16:06:43.992]                     future <- SequentialFuture(..., envir = envir)
[16:06:43.992]                     if (!future$lazy) 
[16:06:43.992]                       future <- run(future)
[16:06:43.992]                     invisible(future)
[16:06:43.992]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:43.992]                 }
[16:06:43.992]             }
[16:06:43.992]         }
[16:06:43.992]     })
[16:06:43.992]     if (FALSE) {
[16:06:43.992]         base::sink(type = "output", split = FALSE)
[16:06:43.992]         if (NA) {
[16:06:43.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:43.992]         }
[16:06:43.992]         else {
[16:06:43.992]             ...future.result["stdout"] <- base::list(NULL)
[16:06:43.992]         }
[16:06:43.992]         base::close(...future.stdout)
[16:06:43.992]         ...future.stdout <- NULL
[16:06:43.992]     }
[16:06:43.992]     ...future.result$conditions <- ...future.conditions
[16:06:43.992]     ...future.result$finished <- base::Sys.time()
[16:06:43.992]     ...future.result
[16:06:43.992] }
[16:06:43.994] plan(): Setting new future strategy stack:
[16:06:43.994] List of future strategies:
[16:06:43.994] 1. sequential:
[16:06:43.994]    - args: function (..., envir = parent.frame())
[16:06:43.994]    - tweaked: FALSE
[16:06:43.994]    - call: NULL
[16:06:43.994] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[16:06:43.996] plan(): Setting new future strategy stack:
[16:06:43.996] List of future strategies:
[16:06:43.996] 1. sequential:
[16:06:43.996]    - args: function (..., envir = parent.frame())
[16:06:43.996]    - tweaked: FALSE
[16:06:43.996]    - call: plan(strategy)
[16:06:43.996] plan(): nbrOfWorkers() = 1
[16:06:43.996] SequentialFuture started (and completed)
[16:06:43.997] - Launch lazy future ... done
[16:06:43.997] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[16:06:43.997] getGlobalsAndPackages() ...
[16:06:43.997] Searching for globals...
[16:06:43.998] - globals found: [1] ‘print’
[16:06:43.998] Searching for globals ... DONE
[16:06:43.998] Resolving globals: FALSE
[16:06:43.998] 
[16:06:43.998] 
[16:06:43.998] getGlobalsAndPackages() ... DONE
[16:06:43.998] run() for ‘Future’ ...
[16:06:43.998] - state: ‘created’
[16:06:43.999] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:06:43.999] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:06:43.999] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:06:43.999]   - Field: ‘label’
[16:06:43.999]   - Field: ‘local’
[16:06:43.999]   - Field: ‘owner’
[16:06:43.999]   - Field: ‘envir’
[16:06:43.999]   - Field: ‘packages’
[16:06:43.999]   - Field: ‘gc’
[16:06:44.000]   - Field: ‘conditions’
[16:06:44.000]   - Field: ‘expr’
[16:06:44.000]   - Field: ‘uuid’
[16:06:44.000]   - Field: ‘seed’
[16:06:44.000]   - Field: ‘version’
[16:06:44.000]   - Field: ‘result’
[16:06:44.000]   - Field: ‘asynchronous’
[16:06:44.000]   - Field: ‘calls’
[16:06:44.000]   - Field: ‘globals’
[16:06:44.000]   - Field: ‘stdout’
[16:06:44.000]   - Field: ‘earlySignal’
[16:06:44.000]   - Field: ‘lazy’
[16:06:44.001]   - Field: ‘state’
[16:06:44.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:06:44.001] - Launch lazy future ...
[16:06:44.001] Packages needed by the future expression (n = 0): <none>
[16:06:44.001] Packages needed by future strategies (n = 0): <none>
[16:06:44.001] {
[16:06:44.001]     {
[16:06:44.001]         {
[16:06:44.001]             ...future.startTime <- base::Sys.time()
[16:06:44.001]             {
[16:06:44.001]                 {
[16:06:44.001]                   {
[16:06:44.001]                     base::local({
[16:06:44.001]                       has_future <- base::requireNamespace("future", 
[16:06:44.001]                         quietly = TRUE)
[16:06:44.001]                       if (has_future) {
[16:06:44.001]                         ns <- base::getNamespace("future")
[16:06:44.001]                         version <- ns[[".package"]][["version"]]
[16:06:44.001]                         if (is.null(version)) 
[16:06:44.001]                           version <- utils::packageVersion("future")
[16:06:44.001]                       }
[16:06:44.001]                       else {
[16:06:44.001]                         version <- NULL
[16:06:44.001]                       }
[16:06:44.001]                       if (!has_future || version < "1.8.0") {
[16:06:44.001]                         info <- base::c(r_version = base::gsub("R version ", 
[16:06:44.001]                           "", base::R.version$version.string), 
[16:06:44.001]                           platform = base::sprintf("%s (%s-bit)", 
[16:06:44.001]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:44.001]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:44.001]                             "release", "version")], collapse = " "), 
[16:06:44.001]                           hostname = base::Sys.info()[["nodename"]])
[16:06:44.001]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:06:44.001]                           info)
[16:06:44.001]                         info <- base::paste(info, collapse = "; ")
[16:06:44.001]                         if (!has_future) {
[16:06:44.001]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:44.001]                             info)
[16:06:44.001]                         }
[16:06:44.001]                         else {
[16:06:44.001]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:44.001]                             info, version)
[16:06:44.001]                         }
[16:06:44.001]                         base::stop(msg)
[16:06:44.001]                       }
[16:06:44.001]                     })
[16:06:44.001]                   }
[16:06:44.001]                   options(future.plan = NULL)
[16:06:44.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:44.001]                 }
[16:06:44.001]                 ...future.workdir <- getwd()
[16:06:44.001]             }
[16:06:44.001]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:44.001]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:44.001]         }
[16:06:44.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:44.001]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:44.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:44.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:44.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:44.001]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:44.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:44.001]             base::names(...future.oldOptions))
[16:06:44.001]     }
[16:06:44.001]     if (FALSE) {
[16:06:44.001]     }
[16:06:44.001]     else {
[16:06:44.001]         if (TRUE) {
[16:06:44.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:44.001]                 open = "w")
[16:06:44.001]         }
[16:06:44.001]         else {
[16:06:44.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:44.001]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:44.001]         }
[16:06:44.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:44.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:44.001]             base::sink(type = "output", split = FALSE)
[16:06:44.001]             base::close(...future.stdout)
[16:06:44.001]         }, add = TRUE)
[16:06:44.001]     }
[16:06:44.001]     ...future.frame <- base::sys.nframe()
[16:06:44.001]     ...future.conditions <- base::list()
[16:06:44.001]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:44.001]     if (FALSE) {
[16:06:44.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:44.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:44.001]     }
[16:06:44.001]     ...future.result <- base::tryCatch({
[16:06:44.001]         base::withCallingHandlers({
[16:06:44.001]             ...future.value <- base::withVisible(base::local(print(42)))
[16:06:44.001]             future::FutureResult(value = ...future.value$value, 
[16:06:44.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.001]                   ...future.rng), globalenv = if (FALSE) 
[16:06:44.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:44.001]                     ...future.globalenv.names))
[16:06:44.001]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:44.001]         }, condition = base::local({
[16:06:44.001]             c <- base::c
[16:06:44.001]             inherits <- base::inherits
[16:06:44.001]             invokeRestart <- base::invokeRestart
[16:06:44.001]             length <- base::length
[16:06:44.001]             list <- base::list
[16:06:44.001]             seq.int <- base::seq.int
[16:06:44.001]             signalCondition <- base::signalCondition
[16:06:44.001]             sys.calls <- base::sys.calls
[16:06:44.001]             `[[` <- base::`[[`
[16:06:44.001]             `+` <- base::`+`
[16:06:44.001]             `<<-` <- base::`<<-`
[16:06:44.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:44.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:44.001]                   3L)]
[16:06:44.001]             }
[16:06:44.001]             function(cond) {
[16:06:44.001]                 is_error <- inherits(cond, "error")
[16:06:44.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:44.001]                   NULL)
[16:06:44.001]                 if (is_error) {
[16:06:44.001]                   sessionInformation <- function() {
[16:06:44.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:44.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:44.001]                       search = base::search(), system = base::Sys.info())
[16:06:44.001]                   }
[16:06:44.001]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:44.001]                     cond$call), session = sessionInformation(), 
[16:06:44.001]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:44.001]                   signalCondition(cond)
[16:06:44.001]                 }
[16:06:44.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:44.001]                 "immediateCondition"))) {
[16:06:44.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:44.001]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:44.001]                   if (TRUE && !signal) {
[16:06:44.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.001]                     {
[16:06:44.001]                       inherits <- base::inherits
[16:06:44.001]                       invokeRestart <- base::invokeRestart
[16:06:44.001]                       is.null <- base::is.null
[16:06:44.001]                       muffled <- FALSE
[16:06:44.001]                       if (inherits(cond, "message")) {
[16:06:44.001]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.001]                         if (muffled) 
[16:06:44.001]                           invokeRestart("muffleMessage")
[16:06:44.001]                       }
[16:06:44.001]                       else if (inherits(cond, "warning")) {
[16:06:44.001]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.001]                         if (muffled) 
[16:06:44.001]                           invokeRestart("muffleWarning")
[16:06:44.001]                       }
[16:06:44.001]                       else if (inherits(cond, "condition")) {
[16:06:44.001]                         if (!is.null(pattern)) {
[16:06:44.001]                           computeRestarts <- base::computeRestarts
[16:06:44.001]                           grepl <- base::grepl
[16:06:44.001]                           restarts <- computeRestarts(cond)
[16:06:44.001]                           for (restart in restarts) {
[16:06:44.001]                             name <- restart$name
[16:06:44.001]                             if (is.null(name)) 
[16:06:44.001]                               next
[16:06:44.001]                             if (!grepl(pattern, name)) 
[16:06:44.001]                               next
[16:06:44.001]                             invokeRestart(restart)
[16:06:44.001]                             muffled <- TRUE
[16:06:44.001]                             break
[16:06:44.001]                           }
[16:06:44.001]                         }
[16:06:44.001]                       }
[16:06:44.001]                       invisible(muffled)
[16:06:44.001]                     }
[16:06:44.001]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.001]                   }
[16:06:44.001]                 }
[16:06:44.001]                 else {
[16:06:44.001]                   if (TRUE) {
[16:06:44.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.001]                     {
[16:06:44.001]                       inherits <- base::inherits
[16:06:44.001]                       invokeRestart <- base::invokeRestart
[16:06:44.001]                       is.null <- base::is.null
[16:06:44.001]                       muffled <- FALSE
[16:06:44.001]                       if (inherits(cond, "message")) {
[16:06:44.001]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.001]                         if (muffled) 
[16:06:44.001]                           invokeRestart("muffleMessage")
[16:06:44.001]                       }
[16:06:44.001]                       else if (inherits(cond, "warning")) {
[16:06:44.001]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.001]                         if (muffled) 
[16:06:44.001]                           invokeRestart("muffleWarning")
[16:06:44.001]                       }
[16:06:44.001]                       else if (inherits(cond, "condition")) {
[16:06:44.001]                         if (!is.null(pattern)) {
[16:06:44.001]                           computeRestarts <- base::computeRestarts
[16:06:44.001]                           grepl <- base::grepl
[16:06:44.001]                           restarts <- computeRestarts(cond)
[16:06:44.001]                           for (restart in restarts) {
[16:06:44.001]                             name <- restart$name
[16:06:44.001]                             if (is.null(name)) 
[16:06:44.001]                               next
[16:06:44.001]                             if (!grepl(pattern, name)) 
[16:06:44.001]                               next
[16:06:44.001]                             invokeRestart(restart)
[16:06:44.001]                             muffled <- TRUE
[16:06:44.001]                             break
[16:06:44.001]                           }
[16:06:44.001]                         }
[16:06:44.001]                       }
[16:06:44.001]                       invisible(muffled)
[16:06:44.001]                     }
[16:06:44.001]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.001]                   }
[16:06:44.001]                 }
[16:06:44.001]             }
[16:06:44.001]         }))
[16:06:44.001]     }, error = function(ex) {
[16:06:44.001]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:44.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.001]                 ...future.rng), started = ...future.startTime, 
[16:06:44.001]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:44.001]             version = "1.8"), class = "FutureResult")
[16:06:44.001]     }, finally = {
[16:06:44.001]         if (!identical(...future.workdir, getwd())) 
[16:06:44.001]             setwd(...future.workdir)
[16:06:44.001]         {
[16:06:44.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:44.001]                 ...future.oldOptions$nwarnings <- NULL
[16:06:44.001]             }
[16:06:44.001]             base::options(...future.oldOptions)
[16:06:44.001]             if (.Platform$OS.type == "windows") {
[16:06:44.001]                 old_names <- names(...future.oldEnvVars)
[16:06:44.001]                 envs <- base::Sys.getenv()
[16:06:44.001]                 names <- names(envs)
[16:06:44.001]                 common <- intersect(names, old_names)
[16:06:44.001]                 added <- setdiff(names, old_names)
[16:06:44.001]                 removed <- setdiff(old_names, names)
[16:06:44.001]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:44.001]                   envs[common]]
[16:06:44.001]                 NAMES <- toupper(changed)
[16:06:44.001]                 args <- list()
[16:06:44.001]                 for (kk in seq_along(NAMES)) {
[16:06:44.001]                   name <- changed[[kk]]
[16:06:44.001]                   NAME <- NAMES[[kk]]
[16:06:44.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.001]                     next
[16:06:44.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.001]                 }
[16:06:44.001]                 NAMES <- toupper(added)
[16:06:44.001]                 for (kk in seq_along(NAMES)) {
[16:06:44.001]                   name <- added[[kk]]
[16:06:44.001]                   NAME <- NAMES[[kk]]
[16:06:44.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.001]                     next
[16:06:44.001]                   args[[name]] <- ""
[16:06:44.001]                 }
[16:06:44.001]                 NAMES <- toupper(removed)
[16:06:44.001]                 for (kk in seq_along(NAMES)) {
[16:06:44.001]                   name <- removed[[kk]]
[16:06:44.001]                   NAME <- NAMES[[kk]]
[16:06:44.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.001]                     next
[16:06:44.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.001]                 }
[16:06:44.001]                 if (length(args) > 0) 
[16:06:44.001]                   base::do.call(base::Sys.setenv, args = args)
[16:06:44.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:44.001]             }
[16:06:44.001]             else {
[16:06:44.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:44.001]             }
[16:06:44.001]             {
[16:06:44.001]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:44.001]                   0L) {
[16:06:44.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:44.001]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:44.001]                   base::options(opts)
[16:06:44.001]                 }
[16:06:44.001]                 {
[16:06:44.001]                   {
[16:06:44.001]                     NULL
[16:06:44.001]                     RNGkind("Mersenne-Twister")
[16:06:44.001]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:06:44.001]                       inherits = FALSE)
[16:06:44.001]                   }
[16:06:44.001]                   options(future.plan = NULL)
[16:06:44.001]                   if (is.na(NA_character_)) 
[16:06:44.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:44.001]                   future::plan(list(function (..., envir = parent.frame()) 
[16:06:44.001]                   {
[16:06:44.001]                     future <- SequentialFuture(..., envir = envir)
[16:06:44.001]                     if (!future$lazy) 
[16:06:44.001]                       future <- run(future)
[16:06:44.001]                     invisible(future)
[16:06:44.001]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:44.001]                 }
[16:06:44.001]             }
[16:06:44.001]         }
[16:06:44.001]     })
[16:06:44.001]     if (TRUE) {
[16:06:44.001]         base::sink(type = "output", split = FALSE)
[16:06:44.001]         if (TRUE) {
[16:06:44.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:44.001]         }
[16:06:44.001]         else {
[16:06:44.001]             ...future.result["stdout"] <- base::list(NULL)
[16:06:44.001]         }
[16:06:44.001]         base::close(...future.stdout)
[16:06:44.001]         ...future.stdout <- NULL
[16:06:44.001]     }
[16:06:44.001]     ...future.result$conditions <- ...future.conditions
[16:06:44.001]     ...future.result$finished <- base::Sys.time()
[16:06:44.001]     ...future.result
[16:06:44.001] }
[16:06:44.003] plan(): Setting new future strategy stack:
[16:06:44.003] List of future strategies:
[16:06:44.003] 1. sequential:
[16:06:44.003]    - args: function (..., envir = parent.frame())
[16:06:44.003]    - tweaked: FALSE
[16:06:44.003]    - call: NULL
[16:06:44.003] plan(): nbrOfWorkers() = 1
[16:06:44.004] plan(): Setting new future strategy stack:
[16:06:44.004] List of future strategies:
[16:06:44.004] 1. sequential:
[16:06:44.004]    - args: function (..., envir = parent.frame())
[16:06:44.004]    - tweaked: FALSE
[16:06:44.004]    - call: plan(strategy)
[16:06:44.005] plan(): nbrOfWorkers() = 1
[16:06:44.005] SequentialFuture started (and completed)
[16:06:44.005] - Launch lazy future ... done
[16:06:44.005] run() for ‘SequentialFuture’ ... done
[1] 42
sequential ... done
Testing with 1 cores ... done
Testing with 2 cores ...
multicore ...
[16:06:44.011] plan(): Setting new future strategy stack:
[16:06:44.011] List of future strategies:
[16:06:44.011] 1. multicore:
[16:06:44.011]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:06:44.011]    - tweaked: FALSE
[16:06:44.011]    - call: plan(strategy)
[16:06:44.015] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[16:06:44.015] getGlobalsAndPackages() ...
[16:06:44.015] Searching for globals...
[16:06:44.018] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:44.018] Searching for globals ... DONE
[16:06:44.018] Resolving globals: FALSE
[16:06:44.019] 
[16:06:44.019] - packages: [1] ‘utils’
[16:06:44.019] getGlobalsAndPackages() ... DONE
[16:06:44.019] run() for ‘Future’ ...
[16:06:44.019] - state: ‘created’
[16:06:44.019] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:06:44.023] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:44.023] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:06:44.023]   - Field: ‘label’
[16:06:44.023]   - Field: ‘local’
[16:06:44.023]   - Field: ‘owner’
[16:06:44.023]   - Field: ‘envir’
[16:06:44.023]   - Field: ‘workers’
[16:06:44.023]   - Field: ‘packages’
[16:06:44.024]   - Field: ‘gc’
[16:06:44.024]   - Field: ‘job’
[16:06:44.024]   - Field: ‘conditions’
[16:06:44.024]   - Field: ‘expr’
[16:06:44.024]   - Field: ‘uuid’
[16:06:44.024]   - Field: ‘seed’
[16:06:44.024]   - Field: ‘version’
[16:06:44.024]   - Field: ‘result’
[16:06:44.024]   - Field: ‘asynchronous’
[16:06:44.024]   - Field: ‘calls’
[16:06:44.024]   - Field: ‘globals’
[16:06:44.024]   - Field: ‘stdout’
[16:06:44.025]   - Field: ‘earlySignal’
[16:06:44.025]   - Field: ‘lazy’
[16:06:44.025]   - Field: ‘state’
[16:06:44.025] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:06:44.025] - Launch lazy future ...
[16:06:44.026] Packages needed by the future expression (n = 1): ‘utils’
[16:06:44.026] Packages needed by future strategies (n = 0): <none>
[16:06:44.026] {
[16:06:44.026]     {
[16:06:44.026]         {
[16:06:44.026]             ...future.startTime <- base::Sys.time()
[16:06:44.026]             {
[16:06:44.026]                 {
[16:06:44.026]                   {
[16:06:44.026]                     {
[16:06:44.026]                       {
[16:06:44.026]                         base::local({
[16:06:44.026]                           has_future <- base::requireNamespace("future", 
[16:06:44.026]                             quietly = TRUE)
[16:06:44.026]                           if (has_future) {
[16:06:44.026]                             ns <- base::getNamespace("future")
[16:06:44.026]                             version <- ns[[".package"]][["version"]]
[16:06:44.026]                             if (is.null(version)) 
[16:06:44.026]                               version <- utils::packageVersion("future")
[16:06:44.026]                           }
[16:06:44.026]                           else {
[16:06:44.026]                             version <- NULL
[16:06:44.026]                           }
[16:06:44.026]                           if (!has_future || version < "1.8.0") {
[16:06:44.026]                             info <- base::c(r_version = base::gsub("R version ", 
[16:06:44.026]                               "", base::R.version$version.string), 
[16:06:44.026]                               platform = base::sprintf("%s (%s-bit)", 
[16:06:44.026]                                 base::R.version$platform, 8 * 
[16:06:44.026]                                   base::.Machine$sizeof.pointer), 
[16:06:44.026]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:44.026]                                 "release", "version")], collapse = " "), 
[16:06:44.026]                               hostname = base::Sys.info()[["nodename"]])
[16:06:44.026]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:06:44.026]                               info)
[16:06:44.026]                             info <- base::paste(info, collapse = "; ")
[16:06:44.026]                             if (!has_future) {
[16:06:44.026]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:44.026]                                 info)
[16:06:44.026]                             }
[16:06:44.026]                             else {
[16:06:44.026]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:44.026]                                 info, version)
[16:06:44.026]                             }
[16:06:44.026]                             base::stop(msg)
[16:06:44.026]                           }
[16:06:44.026]                         })
[16:06:44.026]                       }
[16:06:44.026]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:44.026]                       base::options(mc.cores = 1L)
[16:06:44.026]                     }
[16:06:44.026]                     base::local({
[16:06:44.026]                       for (pkg in "utils") {
[16:06:44.026]                         base::loadNamespace(pkg)
[16:06:44.026]                         base::library(pkg, character.only = TRUE)
[16:06:44.026]                       }
[16:06:44.026]                     })
[16:06:44.026]                   }
[16:06:44.026]                   options(future.plan = NULL)
[16:06:44.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:44.026]                 }
[16:06:44.026]                 ...future.workdir <- getwd()
[16:06:44.026]             }
[16:06:44.026]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:44.026]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:44.026]         }
[16:06:44.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:44.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:44.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:44.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:44.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:44.026]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:44.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:44.026]             base::names(...future.oldOptions))
[16:06:44.026]     }
[16:06:44.026]     if (FALSE) {
[16:06:44.026]     }
[16:06:44.026]     else {
[16:06:44.026]         if (TRUE) {
[16:06:44.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:44.026]                 open = "w")
[16:06:44.026]         }
[16:06:44.026]         else {
[16:06:44.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:44.026]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:44.026]         }
[16:06:44.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:44.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:44.026]             base::sink(type = "output", split = FALSE)
[16:06:44.026]             base::close(...future.stdout)
[16:06:44.026]         }, add = TRUE)
[16:06:44.026]     }
[16:06:44.026]     ...future.frame <- base::sys.nframe()
[16:06:44.026]     ...future.conditions <- base::list()
[16:06:44.026]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:44.026]     if (FALSE) {
[16:06:44.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:44.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:44.026]     }
[16:06:44.026]     ...future.result <- base::tryCatch({
[16:06:44.026]         base::withCallingHandlers({
[16:06:44.026]             ...future.value <- base::withVisible(base::local({
[16:06:44.026]                 withCallingHandlers({
[16:06:44.026]                   {
[16:06:44.026]                     print(1:50)
[16:06:44.026]                     str(1:50)
[16:06:44.026]                     cat(letters, sep = "-")
[16:06:44.026]                     cat(1:6, collapse = "\n")
[16:06:44.026]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:44.026]                     42L
[16:06:44.026]                   }
[16:06:44.026]                 }, immediateCondition = function(cond) {
[16:06:44.026]                   save_rds <- function (object, pathname, ...) 
[16:06:44.026]                   {
[16:06:44.026]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:06:44.026]                     if (file_test("-f", pathname_tmp)) {
[16:06:44.026]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.026]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:06:44.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.026]                         fi_tmp[["mtime"]])
[16:06:44.026]                     }
[16:06:44.026]                     tryCatch({
[16:06:44.026]                       saveRDS(object, file = pathname_tmp, ...)
[16:06:44.026]                     }, error = function(ex) {
[16:06:44.026]                       msg <- conditionMessage(ex)
[16:06:44.026]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.026]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:06:44.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.026]                         fi_tmp[["mtime"]], msg)
[16:06:44.026]                       ex$message <- msg
[16:06:44.026]                       stop(ex)
[16:06:44.026]                     })
[16:06:44.026]                     stopifnot(file_test("-f", pathname_tmp))
[16:06:44.026]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:06:44.026]                     if (!res || file_test("-f", pathname_tmp)) {
[16:06:44.026]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.026]                       fi <- file.info(pathname)
[16:06:44.026]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:06:44.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.026]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:06:44.026]                         fi[["size"]], fi[["mtime"]])
[16:06:44.026]                       stop(msg)
[16:06:44.026]                     }
[16:06:44.026]                     invisible(pathname)
[16:06:44.026]                   }
[16:06:44.026]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:06:44.026]                     rootPath = tempdir()) 
[16:06:44.026]                   {
[16:06:44.026]                     obj <- list(time = Sys.time(), condition = cond)
[16:06:44.026]                     file <- tempfile(pattern = class(cond)[1], 
[16:06:44.026]                       tmpdir = path, fileext = ".rds")
[16:06:44.026]                     save_rds(obj, file)
[16:06:44.026]                   }
[16:06:44.026]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6lYtbx/.future/immediateConditions")
[16:06:44.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.026]                   {
[16:06:44.026]                     inherits <- base::inherits
[16:06:44.026]                     invokeRestart <- base::invokeRestart
[16:06:44.026]                     is.null <- base::is.null
[16:06:44.026]                     muffled <- FALSE
[16:06:44.026]                     if (inherits(cond, "message")) {
[16:06:44.026]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:44.026]                       if (muffled) 
[16:06:44.026]                         invokeRestart("muffleMessage")
[16:06:44.026]                     }
[16:06:44.026]                     else if (inherits(cond, "warning")) {
[16:06:44.026]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:44.026]                       if (muffled) 
[16:06:44.026]                         invokeRestart("muffleWarning")
[16:06:44.026]                     }
[16:06:44.026]                     else if (inherits(cond, "condition")) {
[16:06:44.026]                       if (!is.null(pattern)) {
[16:06:44.026]                         computeRestarts <- base::computeRestarts
[16:06:44.026]                         grepl <- base::grepl
[16:06:44.026]                         restarts <- computeRestarts(cond)
[16:06:44.026]                         for (restart in restarts) {
[16:06:44.026]                           name <- restart$name
[16:06:44.026]                           if (is.null(name)) 
[16:06:44.026]                             next
[16:06:44.026]                           if (!grepl(pattern, name)) 
[16:06:44.026]                             next
[16:06:44.026]                           invokeRestart(restart)
[16:06:44.026]                           muffled <- TRUE
[16:06:44.026]                           break
[16:06:44.026]                         }
[16:06:44.026]                       }
[16:06:44.026]                     }
[16:06:44.026]                     invisible(muffled)
[16:06:44.026]                   }
[16:06:44.026]                   muffleCondition(cond)
[16:06:44.026]                 })
[16:06:44.026]             }))
[16:06:44.026]             future::FutureResult(value = ...future.value$value, 
[16:06:44.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.026]                   ...future.rng), globalenv = if (FALSE) 
[16:06:44.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:44.026]                     ...future.globalenv.names))
[16:06:44.026]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:44.026]         }, condition = base::local({
[16:06:44.026]             c <- base::c
[16:06:44.026]             inherits <- base::inherits
[16:06:44.026]             invokeRestart <- base::invokeRestart
[16:06:44.026]             length <- base::length
[16:06:44.026]             list <- base::list
[16:06:44.026]             seq.int <- base::seq.int
[16:06:44.026]             signalCondition <- base::signalCondition
[16:06:44.026]             sys.calls <- base::sys.calls
[16:06:44.026]             `[[` <- base::`[[`
[16:06:44.026]             `+` <- base::`+`
[16:06:44.026]             `<<-` <- base::`<<-`
[16:06:44.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:44.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:44.026]                   3L)]
[16:06:44.026]             }
[16:06:44.026]             function(cond) {
[16:06:44.026]                 is_error <- inherits(cond, "error")
[16:06:44.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:44.026]                   NULL)
[16:06:44.026]                 if (is_error) {
[16:06:44.026]                   sessionInformation <- function() {
[16:06:44.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:44.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:44.026]                       search = base::search(), system = base::Sys.info())
[16:06:44.026]                   }
[16:06:44.026]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:44.026]                     cond$call), session = sessionInformation(), 
[16:06:44.026]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:44.026]                   signalCondition(cond)
[16:06:44.026]                 }
[16:06:44.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:44.026]                 "immediateCondition"))) {
[16:06:44.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:44.026]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:44.026]                   if (TRUE && !signal) {
[16:06:44.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.026]                     {
[16:06:44.026]                       inherits <- base::inherits
[16:06:44.026]                       invokeRestart <- base::invokeRestart
[16:06:44.026]                       is.null <- base::is.null
[16:06:44.026]                       muffled <- FALSE
[16:06:44.026]                       if (inherits(cond, "message")) {
[16:06:44.026]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.026]                         if (muffled) 
[16:06:44.026]                           invokeRestart("muffleMessage")
[16:06:44.026]                       }
[16:06:44.026]                       else if (inherits(cond, "warning")) {
[16:06:44.026]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.026]                         if (muffled) 
[16:06:44.026]                           invokeRestart("muffleWarning")
[16:06:44.026]                       }
[16:06:44.026]                       else if (inherits(cond, "condition")) {
[16:06:44.026]                         if (!is.null(pattern)) {
[16:06:44.026]                           computeRestarts <- base::computeRestarts
[16:06:44.026]                           grepl <- base::grepl
[16:06:44.026]                           restarts <- computeRestarts(cond)
[16:06:44.026]                           for (restart in restarts) {
[16:06:44.026]                             name <- restart$name
[16:06:44.026]                             if (is.null(name)) 
[16:06:44.026]                               next
[16:06:44.026]                             if (!grepl(pattern, name)) 
[16:06:44.026]                               next
[16:06:44.026]                             invokeRestart(restart)
[16:06:44.026]                             muffled <- TRUE
[16:06:44.026]                             break
[16:06:44.026]                           }
[16:06:44.026]                         }
[16:06:44.026]                       }
[16:06:44.026]                       invisible(muffled)
[16:06:44.026]                     }
[16:06:44.026]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.026]                   }
[16:06:44.026]                 }
[16:06:44.026]                 else {
[16:06:44.026]                   if (TRUE) {
[16:06:44.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.026]                     {
[16:06:44.026]                       inherits <- base::inherits
[16:06:44.026]                       invokeRestart <- base::invokeRestart
[16:06:44.026]                       is.null <- base::is.null
[16:06:44.026]                       muffled <- FALSE
[16:06:44.026]                       if (inherits(cond, "message")) {
[16:06:44.026]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.026]                         if (muffled) 
[16:06:44.026]                           invokeRestart("muffleMessage")
[16:06:44.026]                       }
[16:06:44.026]                       else if (inherits(cond, "warning")) {
[16:06:44.026]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.026]                         if (muffled) 
[16:06:44.026]                           invokeRestart("muffleWarning")
[16:06:44.026]                       }
[16:06:44.026]                       else if (inherits(cond, "condition")) {
[16:06:44.026]                         if (!is.null(pattern)) {
[16:06:44.026]                           computeRestarts <- base::computeRestarts
[16:06:44.026]                           grepl <- base::grepl
[16:06:44.026]                           restarts <- computeRestarts(cond)
[16:06:44.026]                           for (restart in restarts) {
[16:06:44.026]                             name <- restart$name
[16:06:44.026]                             if (is.null(name)) 
[16:06:44.026]                               next
[16:06:44.026]                             if (!grepl(pattern, name)) 
[16:06:44.026]                               next
[16:06:44.026]                             invokeRestart(restart)
[16:06:44.026]                             muffled <- TRUE
[16:06:44.026]                             break
[16:06:44.026]                           }
[16:06:44.026]                         }
[16:06:44.026]                       }
[16:06:44.026]                       invisible(muffled)
[16:06:44.026]                     }
[16:06:44.026]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.026]                   }
[16:06:44.026]                 }
[16:06:44.026]             }
[16:06:44.026]         }))
[16:06:44.026]     }, error = function(ex) {
[16:06:44.026]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:44.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.026]                 ...future.rng), started = ...future.startTime, 
[16:06:44.026]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:44.026]             version = "1.8"), class = "FutureResult")
[16:06:44.026]     }, finally = {
[16:06:44.026]         if (!identical(...future.workdir, getwd())) 
[16:06:44.026]             setwd(...future.workdir)
[16:06:44.026]         {
[16:06:44.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:44.026]                 ...future.oldOptions$nwarnings <- NULL
[16:06:44.026]             }
[16:06:44.026]             base::options(...future.oldOptions)
[16:06:44.026]             if (.Platform$OS.type == "windows") {
[16:06:44.026]                 old_names <- names(...future.oldEnvVars)
[16:06:44.026]                 envs <- base::Sys.getenv()
[16:06:44.026]                 names <- names(envs)
[16:06:44.026]                 common <- intersect(names, old_names)
[16:06:44.026]                 added <- setdiff(names, old_names)
[16:06:44.026]                 removed <- setdiff(old_names, names)
[16:06:44.026]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:44.026]                   envs[common]]
[16:06:44.026]                 NAMES <- toupper(changed)
[16:06:44.026]                 args <- list()
[16:06:44.026]                 for (kk in seq_along(NAMES)) {
[16:06:44.026]                   name <- changed[[kk]]
[16:06:44.026]                   NAME <- NAMES[[kk]]
[16:06:44.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.026]                     next
[16:06:44.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.026]                 }
[16:06:44.026]                 NAMES <- toupper(added)
[16:06:44.026]                 for (kk in seq_along(NAMES)) {
[16:06:44.026]                   name <- added[[kk]]
[16:06:44.026]                   NAME <- NAMES[[kk]]
[16:06:44.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.026]                     next
[16:06:44.026]                   args[[name]] <- ""
[16:06:44.026]                 }
[16:06:44.026]                 NAMES <- toupper(removed)
[16:06:44.026]                 for (kk in seq_along(NAMES)) {
[16:06:44.026]                   name <- removed[[kk]]
[16:06:44.026]                   NAME <- NAMES[[kk]]
[16:06:44.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.026]                     next
[16:06:44.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.026]                 }
[16:06:44.026]                 if (length(args) > 0) 
[16:06:44.026]                   base::do.call(base::Sys.setenv, args = args)
[16:06:44.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:44.026]             }
[16:06:44.026]             else {
[16:06:44.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:44.026]             }
[16:06:44.026]             {
[16:06:44.026]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:44.026]                   0L) {
[16:06:44.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:44.026]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:44.026]                   base::options(opts)
[16:06:44.026]                 }
[16:06:44.026]                 {
[16:06:44.026]                   {
[16:06:44.026]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:44.026]                     NULL
[16:06:44.026]                   }
[16:06:44.026]                   options(future.plan = NULL)
[16:06:44.026]                   if (is.na(NA_character_)) 
[16:06:44.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:44.026]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:06:44.026]                     envir = parent.frame()) 
[16:06:44.026]                   {
[16:06:44.026]                     default_workers <- missing(workers)
[16:06:44.026]                     if (is.function(workers)) 
[16:06:44.026]                       workers <- workers()
[16:06:44.026]                     workers <- structure(as.integer(workers), 
[16:06:44.026]                       class = class(workers))
[16:06:44.026]                     stop_if_not(is.finite(workers), workers >= 
[16:06:44.026]                       1L)
[16:06:44.026]                     if ((workers == 1L && !inherits(workers, 
[16:06:44.026]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:06:44.026]                       if (default_workers) 
[16:06:44.026]                         supportsMulticore(warn = TRUE)
[16:06:44.026]                       return(sequential(..., envir = envir))
[16:06:44.026]                     }
[16:06:44.026]                     oopts <- options(mc.cores = workers)
[16:06:44.026]                     on.exit(options(oopts))
[16:06:44.026]                     future <- MulticoreFuture(..., workers = workers, 
[16:06:44.026]                       envir = envir)
[16:06:44.026]                     if (!future$lazy) 
[16:06:44.026]                       future <- run(future)
[16:06:44.026]                     invisible(future)
[16:06:44.026]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:44.026]                 }
[16:06:44.026]             }
[16:06:44.026]         }
[16:06:44.026]     })
[16:06:44.026]     if (TRUE) {
[16:06:44.026]         base::sink(type = "output", split = FALSE)
[16:06:44.026]         if (TRUE) {
[16:06:44.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:44.026]         }
[16:06:44.026]         else {
[16:06:44.026]             ...future.result["stdout"] <- base::list(NULL)
[16:06:44.026]         }
[16:06:44.026]         base::close(...future.stdout)
[16:06:44.026]         ...future.stdout <- NULL
[16:06:44.026]     }
[16:06:44.026]     ...future.result$conditions <- ...future.conditions
[16:06:44.026]     ...future.result$finished <- base::Sys.time()
[16:06:44.026]     ...future.result
[16:06:44.026] }
[16:06:44.029] requestCore(): workers = 2
[16:06:44.032] MulticoreFuture started
[16:06:44.032] - Launch lazy future ... done
[16:06:44.032] run() for ‘MulticoreFuture’ ... done
[16:06:44.033] plan(): Setting new future strategy stack:
[16:06:44.034] result() for MulticoreFuture ...
[16:06:44.033] List of future strategies:
[16:06:44.033] 1. sequential:
[16:06:44.033]    - args: function (..., envir = parent.frame())
[16:06:44.033]    - tweaked: FALSE
[16:06:44.033]    - call: NULL
[16:06:44.034] plan(): nbrOfWorkers() = 1
[16:06:44.037] plan(): Setting new future strategy stack:
[16:06:44.037] List of future strategies:
[16:06:44.037] 1. multicore:
[16:06:44.037]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:06:44.037]    - tweaked: FALSE
[16:06:44.037]    - call: plan(strategy)
[16:06:44.042] plan(): nbrOfWorkers() = 2
[16:06:44.046] result() for MulticoreFuture ...
[16:06:44.047] result() for MulticoreFuture ... done
[16:06:44.047] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:06:44"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:06:44"
 $ session_uuid: chr "14bb3ca8-2fe9-2908-7adc-db94d2805eed"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "11666ca4073c"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92410
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:06:44"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:06:44.059] result() for MulticoreFuture ...
[16:06:44.059] result() for MulticoreFuture ... done
[16:06:44.059] result() for MulticoreFuture ...
[16:06:44.059] result() for MulticoreFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.01036501 secs (started 2025-01-06 16:06:44.032356)
version: 1.8
[16:06:44.060] getGlobalsAndPackages() ...
[16:06:44.060] Searching for globals...
[16:06:44.064] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:44.064] Searching for globals ... DONE
[16:06:44.064] Resolving globals: FALSE
[16:06:44.065] 
[16:06:44.065] - packages: [1] ‘utils’
[16:06:44.065] getGlobalsAndPackages() ... DONE
[16:06:44.065] run() for ‘Future’ ...
[16:06:44.065] - state: ‘created’
[16:06:44.066] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:06:44.069] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:44.069] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:06:44.070]   - Field: ‘label’
[16:06:44.070]   - Field: ‘local’
[16:06:44.070]   - Field: ‘owner’
[16:06:44.070]   - Field: ‘envir’
[16:06:44.070]   - Field: ‘workers’
[16:06:44.070]   - Field: ‘packages’
[16:06:44.070]   - Field: ‘gc’
[16:06:44.070]   - Field: ‘job’
[16:06:44.070]   - Field: ‘conditions’
[16:06:44.071]   - Field: ‘expr’
[16:06:44.071]   - Field: ‘uuid’
[16:06:44.071]   - Field: ‘seed’
[16:06:44.071]   - Field: ‘version’
[16:06:44.071]   - Field: ‘result’
[16:06:44.071]   - Field: ‘asynchronous’
[16:06:44.071]   - Field: ‘calls’
[16:06:44.071]   - Field: ‘globals’
[16:06:44.071]   - Field: ‘stdout’
[16:06:44.072]   - Field: ‘earlySignal’
[16:06:44.072]   - Field: ‘lazy’
[16:06:44.072]   - Field: ‘state’
[16:06:44.072] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:06:44.072] - Launch lazy future ...
[16:06:44.072] Packages needed by the future expression (n = 1): ‘utils’
[16:06:44.072] Packages needed by future strategies (n = 0): <none>
[16:06:44.073] {
[16:06:44.073]     {
[16:06:44.073]         {
[16:06:44.073]             ...future.startTime <- base::Sys.time()
[16:06:44.073]             {
[16:06:44.073]                 {
[16:06:44.073]                   {
[16:06:44.073]                     {
[16:06:44.073]                       {
[16:06:44.073]                         base::local({
[16:06:44.073]                           has_future <- base::requireNamespace("future", 
[16:06:44.073]                             quietly = TRUE)
[16:06:44.073]                           if (has_future) {
[16:06:44.073]                             ns <- base::getNamespace("future")
[16:06:44.073]                             version <- ns[[".package"]][["version"]]
[16:06:44.073]                             if (is.null(version)) 
[16:06:44.073]                               version <- utils::packageVersion("future")
[16:06:44.073]                           }
[16:06:44.073]                           else {
[16:06:44.073]                             version <- NULL
[16:06:44.073]                           }
[16:06:44.073]                           if (!has_future || version < "1.8.0") {
[16:06:44.073]                             info <- base::c(r_version = base::gsub("R version ", 
[16:06:44.073]                               "", base::R.version$version.string), 
[16:06:44.073]                               platform = base::sprintf("%s (%s-bit)", 
[16:06:44.073]                                 base::R.version$platform, 8 * 
[16:06:44.073]                                   base::.Machine$sizeof.pointer), 
[16:06:44.073]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:44.073]                                 "release", "version")], collapse = " "), 
[16:06:44.073]                               hostname = base::Sys.info()[["nodename"]])
[16:06:44.073]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:06:44.073]                               info)
[16:06:44.073]                             info <- base::paste(info, collapse = "; ")
[16:06:44.073]                             if (!has_future) {
[16:06:44.073]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:44.073]                                 info)
[16:06:44.073]                             }
[16:06:44.073]                             else {
[16:06:44.073]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:44.073]                                 info, version)
[16:06:44.073]                             }
[16:06:44.073]                             base::stop(msg)
[16:06:44.073]                           }
[16:06:44.073]                         })
[16:06:44.073]                       }
[16:06:44.073]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:44.073]                       base::options(mc.cores = 1L)
[16:06:44.073]                     }
[16:06:44.073]                     base::local({
[16:06:44.073]                       for (pkg in "utils") {
[16:06:44.073]                         base::loadNamespace(pkg)
[16:06:44.073]                         base::library(pkg, character.only = TRUE)
[16:06:44.073]                       }
[16:06:44.073]                     })
[16:06:44.073]                   }
[16:06:44.073]                   options(future.plan = NULL)
[16:06:44.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:44.073]                 }
[16:06:44.073]                 ...future.workdir <- getwd()
[16:06:44.073]             }
[16:06:44.073]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:44.073]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:44.073]         }
[16:06:44.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:44.073]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:44.073]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:44.073]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:44.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:44.073]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:44.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:44.073]             base::names(...future.oldOptions))
[16:06:44.073]     }
[16:06:44.073]     if (FALSE) {
[16:06:44.073]     }
[16:06:44.073]     else {
[16:06:44.073]         if (TRUE) {
[16:06:44.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:44.073]                 open = "w")
[16:06:44.073]         }
[16:06:44.073]         else {
[16:06:44.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:44.073]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:44.073]         }
[16:06:44.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:44.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:44.073]             base::sink(type = "output", split = FALSE)
[16:06:44.073]             base::close(...future.stdout)
[16:06:44.073]         }, add = TRUE)
[16:06:44.073]     }
[16:06:44.073]     ...future.frame <- base::sys.nframe()
[16:06:44.073]     ...future.conditions <- base::list()
[16:06:44.073]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:44.073]     if (FALSE) {
[16:06:44.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:44.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:44.073]     }
[16:06:44.073]     ...future.result <- base::tryCatch({
[16:06:44.073]         base::withCallingHandlers({
[16:06:44.073]             ...future.value <- base::withVisible(base::local({
[16:06:44.073]                 withCallingHandlers({
[16:06:44.073]                   {
[16:06:44.073]                     print(1:50)
[16:06:44.073]                     str(1:50)
[16:06:44.073]                     cat(letters, sep = "-")
[16:06:44.073]                     cat(1:6, collapse = "\n")
[16:06:44.073]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:44.073]                     42L
[16:06:44.073]                   }
[16:06:44.073]                 }, immediateCondition = function(cond) {
[16:06:44.073]                   save_rds <- function (object, pathname, ...) 
[16:06:44.073]                   {
[16:06:44.073]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:06:44.073]                     if (file_test("-f", pathname_tmp)) {
[16:06:44.073]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.073]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:06:44.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.073]                         fi_tmp[["mtime"]])
[16:06:44.073]                     }
[16:06:44.073]                     tryCatch({
[16:06:44.073]                       saveRDS(object, file = pathname_tmp, ...)
[16:06:44.073]                     }, error = function(ex) {
[16:06:44.073]                       msg <- conditionMessage(ex)
[16:06:44.073]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.073]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:06:44.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.073]                         fi_tmp[["mtime"]], msg)
[16:06:44.073]                       ex$message <- msg
[16:06:44.073]                       stop(ex)
[16:06:44.073]                     })
[16:06:44.073]                     stopifnot(file_test("-f", pathname_tmp))
[16:06:44.073]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:06:44.073]                     if (!res || file_test("-f", pathname_tmp)) {
[16:06:44.073]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.073]                       fi <- file.info(pathname)
[16:06:44.073]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:06:44.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.073]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:06:44.073]                         fi[["size"]], fi[["mtime"]])
[16:06:44.073]                       stop(msg)
[16:06:44.073]                     }
[16:06:44.073]                     invisible(pathname)
[16:06:44.073]                   }
[16:06:44.073]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:06:44.073]                     rootPath = tempdir()) 
[16:06:44.073]                   {
[16:06:44.073]                     obj <- list(time = Sys.time(), condition = cond)
[16:06:44.073]                     file <- tempfile(pattern = class(cond)[1], 
[16:06:44.073]                       tmpdir = path, fileext = ".rds")
[16:06:44.073]                     save_rds(obj, file)
[16:06:44.073]                   }
[16:06:44.073]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6lYtbx/.future/immediateConditions")
[16:06:44.073]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.073]                   {
[16:06:44.073]                     inherits <- base::inherits
[16:06:44.073]                     invokeRestart <- base::invokeRestart
[16:06:44.073]                     is.null <- base::is.null
[16:06:44.073]                     muffled <- FALSE
[16:06:44.073]                     if (inherits(cond, "message")) {
[16:06:44.073]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:44.073]                       if (muffled) 
[16:06:44.073]                         invokeRestart("muffleMessage")
[16:06:44.073]                     }
[16:06:44.073]                     else if (inherits(cond, "warning")) {
[16:06:44.073]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:44.073]                       if (muffled) 
[16:06:44.073]                         invokeRestart("muffleWarning")
[16:06:44.073]                     }
[16:06:44.073]                     else if (inherits(cond, "condition")) {
[16:06:44.073]                       if (!is.null(pattern)) {
[16:06:44.073]                         computeRestarts <- base::computeRestarts
[16:06:44.073]                         grepl <- base::grepl
[16:06:44.073]                         restarts <- computeRestarts(cond)
[16:06:44.073]                         for (restart in restarts) {
[16:06:44.073]                           name <- restart$name
[16:06:44.073]                           if (is.null(name)) 
[16:06:44.073]                             next
[16:06:44.073]                           if (!grepl(pattern, name)) 
[16:06:44.073]                             next
[16:06:44.073]                           invokeRestart(restart)
[16:06:44.073]                           muffled <- TRUE
[16:06:44.073]                           break
[16:06:44.073]                         }
[16:06:44.073]                       }
[16:06:44.073]                     }
[16:06:44.073]                     invisible(muffled)
[16:06:44.073]                   }
[16:06:44.073]                   muffleCondition(cond)
[16:06:44.073]                 })
[16:06:44.073]             }))
[16:06:44.073]             future::FutureResult(value = ...future.value$value, 
[16:06:44.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.073]                   ...future.rng), globalenv = if (FALSE) 
[16:06:44.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:44.073]                     ...future.globalenv.names))
[16:06:44.073]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:44.073]         }, condition = base::local({
[16:06:44.073]             c <- base::c
[16:06:44.073]             inherits <- base::inherits
[16:06:44.073]             invokeRestart <- base::invokeRestart
[16:06:44.073]             length <- base::length
[16:06:44.073]             list <- base::list
[16:06:44.073]             seq.int <- base::seq.int
[16:06:44.073]             signalCondition <- base::signalCondition
[16:06:44.073]             sys.calls <- base::sys.calls
[16:06:44.073]             `[[` <- base::`[[`
[16:06:44.073]             `+` <- base::`+`
[16:06:44.073]             `<<-` <- base::`<<-`
[16:06:44.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:44.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:44.073]                   3L)]
[16:06:44.073]             }
[16:06:44.073]             function(cond) {
[16:06:44.073]                 is_error <- inherits(cond, "error")
[16:06:44.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:44.073]                   NULL)
[16:06:44.073]                 if (is_error) {
[16:06:44.073]                   sessionInformation <- function() {
[16:06:44.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:44.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:44.073]                       search = base::search(), system = base::Sys.info())
[16:06:44.073]                   }
[16:06:44.073]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:44.073]                     cond$call), session = sessionInformation(), 
[16:06:44.073]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:44.073]                   signalCondition(cond)
[16:06:44.073]                 }
[16:06:44.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:44.073]                 "immediateCondition"))) {
[16:06:44.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:44.073]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:44.073]                   if (TRUE && !signal) {
[16:06:44.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.073]                     {
[16:06:44.073]                       inherits <- base::inherits
[16:06:44.073]                       invokeRestart <- base::invokeRestart
[16:06:44.073]                       is.null <- base::is.null
[16:06:44.073]                       muffled <- FALSE
[16:06:44.073]                       if (inherits(cond, "message")) {
[16:06:44.073]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.073]                         if (muffled) 
[16:06:44.073]                           invokeRestart("muffleMessage")
[16:06:44.073]                       }
[16:06:44.073]                       else if (inherits(cond, "warning")) {
[16:06:44.073]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.073]                         if (muffled) 
[16:06:44.073]                           invokeRestart("muffleWarning")
[16:06:44.073]                       }
[16:06:44.073]                       else if (inherits(cond, "condition")) {
[16:06:44.073]                         if (!is.null(pattern)) {
[16:06:44.073]                           computeRestarts <- base::computeRestarts
[16:06:44.073]                           grepl <- base::grepl
[16:06:44.073]                           restarts <- computeRestarts(cond)
[16:06:44.073]                           for (restart in restarts) {
[16:06:44.073]                             name <- restart$name
[16:06:44.073]                             if (is.null(name)) 
[16:06:44.073]                               next
[16:06:44.073]                             if (!grepl(pattern, name)) 
[16:06:44.073]                               next
[16:06:44.073]                             invokeRestart(restart)
[16:06:44.073]                             muffled <- TRUE
[16:06:44.073]                             break
[16:06:44.073]                           }
[16:06:44.073]                         }
[16:06:44.073]                       }
[16:06:44.073]                       invisible(muffled)
[16:06:44.073]                     }
[16:06:44.073]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.073]                   }
[16:06:44.073]                 }
[16:06:44.073]                 else {
[16:06:44.073]                   if (TRUE) {
[16:06:44.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.073]                     {
[16:06:44.073]                       inherits <- base::inherits
[16:06:44.073]                       invokeRestart <- base::invokeRestart
[16:06:44.073]                       is.null <- base::is.null
[16:06:44.073]                       muffled <- FALSE
[16:06:44.073]                       if (inherits(cond, "message")) {
[16:06:44.073]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.073]                         if (muffled) 
[16:06:44.073]                           invokeRestart("muffleMessage")
[16:06:44.073]                       }
[16:06:44.073]                       else if (inherits(cond, "warning")) {
[16:06:44.073]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.073]                         if (muffled) 
[16:06:44.073]                           invokeRestart("muffleWarning")
[16:06:44.073]                       }
[16:06:44.073]                       else if (inherits(cond, "condition")) {
[16:06:44.073]                         if (!is.null(pattern)) {
[16:06:44.073]                           computeRestarts <- base::computeRestarts
[16:06:44.073]                           grepl <- base::grepl
[16:06:44.073]                           restarts <- computeRestarts(cond)
[16:06:44.073]                           for (restart in restarts) {
[16:06:44.073]                             name <- restart$name
[16:06:44.073]                             if (is.null(name)) 
[16:06:44.073]                               next
[16:06:44.073]                             if (!grepl(pattern, name)) 
[16:06:44.073]                               next
[16:06:44.073]                             invokeRestart(restart)
[16:06:44.073]                             muffled <- TRUE
[16:06:44.073]                             break
[16:06:44.073]                           }
[16:06:44.073]                         }
[16:06:44.073]                       }
[16:06:44.073]                       invisible(muffled)
[16:06:44.073]                     }
[16:06:44.073]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.073]                   }
[16:06:44.073]                 }
[16:06:44.073]             }
[16:06:44.073]         }))
[16:06:44.073]     }, error = function(ex) {
[16:06:44.073]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:44.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.073]                 ...future.rng), started = ...future.startTime, 
[16:06:44.073]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:44.073]             version = "1.8"), class = "FutureResult")
[16:06:44.073]     }, finally = {
[16:06:44.073]         if (!identical(...future.workdir, getwd())) 
[16:06:44.073]             setwd(...future.workdir)
[16:06:44.073]         {
[16:06:44.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:44.073]                 ...future.oldOptions$nwarnings <- NULL
[16:06:44.073]             }
[16:06:44.073]             base::options(...future.oldOptions)
[16:06:44.073]             if (.Platform$OS.type == "windows") {
[16:06:44.073]                 old_names <- names(...future.oldEnvVars)
[16:06:44.073]                 envs <- base::Sys.getenv()
[16:06:44.073]                 names <- names(envs)
[16:06:44.073]                 common <- intersect(names, old_names)
[16:06:44.073]                 added <- setdiff(names, old_names)
[16:06:44.073]                 removed <- setdiff(old_names, names)
[16:06:44.073]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:44.073]                   envs[common]]
[16:06:44.073]                 NAMES <- toupper(changed)
[16:06:44.073]                 args <- list()
[16:06:44.073]                 for (kk in seq_along(NAMES)) {
[16:06:44.073]                   name <- changed[[kk]]
[16:06:44.073]                   NAME <- NAMES[[kk]]
[16:06:44.073]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.073]                     next
[16:06:44.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.073]                 }
[16:06:44.073]                 NAMES <- toupper(added)
[16:06:44.073]                 for (kk in seq_along(NAMES)) {
[16:06:44.073]                   name <- added[[kk]]
[16:06:44.073]                   NAME <- NAMES[[kk]]
[16:06:44.073]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.073]                     next
[16:06:44.073]                   args[[name]] <- ""
[16:06:44.073]                 }
[16:06:44.073]                 NAMES <- toupper(removed)
[16:06:44.073]                 for (kk in seq_along(NAMES)) {
[16:06:44.073]                   name <- removed[[kk]]
[16:06:44.073]                   NAME <- NAMES[[kk]]
[16:06:44.073]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.073]                     next
[16:06:44.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.073]                 }
[16:06:44.073]                 if (length(args) > 0) 
[16:06:44.073]                   base::do.call(base::Sys.setenv, args = args)
[16:06:44.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:44.073]             }
[16:06:44.073]             else {
[16:06:44.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:44.073]             }
[16:06:44.073]             {
[16:06:44.073]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:44.073]                   0L) {
[16:06:44.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:44.073]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:44.073]                   base::options(opts)
[16:06:44.073]                 }
[16:06:44.073]                 {
[16:06:44.073]                   {
[16:06:44.073]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:44.073]                     NULL
[16:06:44.073]                   }
[16:06:44.073]                   options(future.plan = NULL)
[16:06:44.073]                   if (is.na(NA_character_)) 
[16:06:44.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:44.073]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:06:44.073]                     envir = parent.frame()) 
[16:06:44.073]                   {
[16:06:44.073]                     default_workers <- missing(workers)
[16:06:44.073]                     if (is.function(workers)) 
[16:06:44.073]                       workers <- workers()
[16:06:44.073]                     workers <- structure(as.integer(workers), 
[16:06:44.073]                       class = class(workers))
[16:06:44.073]                     stop_if_not(is.finite(workers), workers >= 
[16:06:44.073]                       1L)
[16:06:44.073]                     if ((workers == 1L && !inherits(workers, 
[16:06:44.073]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:06:44.073]                       if (default_workers) 
[16:06:44.073]                         supportsMulticore(warn = TRUE)
[16:06:44.073]                       return(sequential(..., envir = envir))
[16:06:44.073]                     }
[16:06:44.073]                     oopts <- options(mc.cores = workers)
[16:06:44.073]                     on.exit(options(oopts))
[16:06:44.073]                     future <- MulticoreFuture(..., workers = workers, 
[16:06:44.073]                       envir = envir)
[16:06:44.073]                     if (!future$lazy) 
[16:06:44.073]                       future <- run(future)
[16:06:44.073]                     invisible(future)
[16:06:44.073]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:44.073]                 }
[16:06:44.073]             }
[16:06:44.073]         }
[16:06:44.073]     })
[16:06:44.073]     if (TRUE) {
[16:06:44.073]         base::sink(type = "output", split = FALSE)
[16:06:44.073]         if (TRUE) {
[16:06:44.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:44.073]         }
[16:06:44.073]         else {
[16:06:44.073]             ...future.result["stdout"] <- base::list(NULL)
[16:06:44.073]         }
[16:06:44.073]         base::close(...future.stdout)
[16:06:44.073]         ...future.stdout <- NULL
[16:06:44.073]     }
[16:06:44.073]     ...future.result$conditions <- ...future.conditions
[16:06:44.073]     ...future.result$finished <- base::Sys.time()
[16:06:44.073]     ...future.result
[16:06:44.073] }
[16:06:44.075] requestCore(): workers = 2
[16:06:44.077] MulticoreFuture started
[16:06:44.077] - Launch lazy future ... done
[16:06:44.078] run() for ‘MulticoreFuture’ ... done
[16:06:44.078] result() for MulticoreFuture ...
[16:06:44.078] plan(): Setting new future strategy stack:
[16:06:44.079] List of future strategies:
[16:06:44.079] 1. sequential:
[16:06:44.079]    - args: function (..., envir = parent.frame())
[16:06:44.079]    - tweaked: FALSE
[16:06:44.079]    - call: NULL
[16:06:44.079] plan(): nbrOfWorkers() = 1
[16:06:44.083] plan(): Setting new future strategy stack:
[16:06:44.083] List of future strategies:
[16:06:44.083] 1. multicore:
[16:06:44.083]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:06:44.083]    - tweaked: FALSE
[16:06:44.083]    - call: plan(strategy)
[16:06:44.088] plan(): nbrOfWorkers() = 2
[16:06:44.088] result() for MulticoreFuture ...
[16:06:44.088] result() for MulticoreFuture ... done
[16:06:44.089] result() for MulticoreFuture ... done
[16:06:44.089] result() for MulticoreFuture ...
[16:06:44.089] result() for MulticoreFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[16:06:44.089] getGlobalsAndPackages() ...
[16:06:44.090] Searching for globals...
[16:06:44.090] - globals found: [1] ‘print’
[16:06:44.090] Searching for globals ... DONE
[16:06:44.091] Resolving globals: FALSE
[16:06:44.091] 
[16:06:44.091] 
[16:06:44.091] getGlobalsAndPackages() ... DONE
[16:06:44.092] run() for ‘Future’ ...
[16:06:44.092] - state: ‘created’
[16:06:44.092] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:06:44.096] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:44.096] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:06:44.096]   - Field: ‘label’
[16:06:44.096]   - Field: ‘local’
[16:06:44.096]   - Field: ‘owner’
[16:06:44.097]   - Field: ‘envir’
[16:06:44.097]   - Field: ‘workers’
[16:06:44.097]   - Field: ‘packages’
[16:06:44.097]   - Field: ‘gc’
[16:06:44.097]   - Field: ‘job’
[16:06:44.097]   - Field: ‘conditions’
[16:06:44.097]   - Field: ‘expr’
[16:06:44.097]   - Field: ‘uuid’
[16:06:44.097]   - Field: ‘seed’
[16:06:44.098]   - Field: ‘version’
[16:06:44.098]   - Field: ‘result’
[16:06:44.098]   - Field: ‘asynchronous’
[16:06:44.098]   - Field: ‘calls’
[16:06:44.098]   - Field: ‘globals’
[16:06:44.098]   - Field: ‘stdout’
[16:06:44.098]   - Field: ‘earlySignal’
[16:06:44.098]   - Field: ‘lazy’
[16:06:44.098]   - Field: ‘state’
[16:06:44.099] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:06:44.099] - Launch lazy future ...
[16:06:44.099] Packages needed by the future expression (n = 0): <none>
[16:06:44.099] Packages needed by future strategies (n = 0): <none>
[16:06:44.100] {
[16:06:44.100]     {
[16:06:44.100]         {
[16:06:44.100]             ...future.startTime <- base::Sys.time()
[16:06:44.100]             {
[16:06:44.100]                 {
[16:06:44.100]                   {
[16:06:44.100]                     {
[16:06:44.100]                       base::local({
[16:06:44.100]                         has_future <- base::requireNamespace("future", 
[16:06:44.100]                           quietly = TRUE)
[16:06:44.100]                         if (has_future) {
[16:06:44.100]                           ns <- base::getNamespace("future")
[16:06:44.100]                           version <- ns[[".package"]][["version"]]
[16:06:44.100]                           if (is.null(version)) 
[16:06:44.100]                             version <- utils::packageVersion("future")
[16:06:44.100]                         }
[16:06:44.100]                         else {
[16:06:44.100]                           version <- NULL
[16:06:44.100]                         }
[16:06:44.100]                         if (!has_future || version < "1.8.0") {
[16:06:44.100]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:44.100]                             "", base::R.version$version.string), 
[16:06:44.100]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:44.100]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:44.100]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:44.100]                               "release", "version")], collapse = " "), 
[16:06:44.100]                             hostname = base::Sys.info()[["nodename"]])
[16:06:44.100]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:44.100]                             info)
[16:06:44.100]                           info <- base::paste(info, collapse = "; ")
[16:06:44.100]                           if (!has_future) {
[16:06:44.100]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:44.100]                               info)
[16:06:44.100]                           }
[16:06:44.100]                           else {
[16:06:44.100]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:44.100]                               info, version)
[16:06:44.100]                           }
[16:06:44.100]                           base::stop(msg)
[16:06:44.100]                         }
[16:06:44.100]                       })
[16:06:44.100]                     }
[16:06:44.100]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:44.100]                     base::options(mc.cores = 1L)
[16:06:44.100]                   }
[16:06:44.100]                   options(future.plan = NULL)
[16:06:44.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.100]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:44.100]                 }
[16:06:44.100]                 ...future.workdir <- getwd()
[16:06:44.100]             }
[16:06:44.100]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:44.100]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:44.100]         }
[16:06:44.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:44.100]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:44.100]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:44.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:44.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:44.100]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:44.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:44.100]             base::names(...future.oldOptions))
[16:06:44.100]     }
[16:06:44.100]     if (FALSE) {
[16:06:44.100]     }
[16:06:44.100]     else {
[16:06:44.100]         if (TRUE) {
[16:06:44.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:44.100]                 open = "w")
[16:06:44.100]         }
[16:06:44.100]         else {
[16:06:44.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:44.100]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:44.100]         }
[16:06:44.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:44.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:44.100]             base::sink(type = "output", split = FALSE)
[16:06:44.100]             base::close(...future.stdout)
[16:06:44.100]         }, add = TRUE)
[16:06:44.100]     }
[16:06:44.100]     ...future.frame <- base::sys.nframe()
[16:06:44.100]     ...future.conditions <- base::list()
[16:06:44.100]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:44.100]     if (FALSE) {
[16:06:44.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:44.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:44.100]     }
[16:06:44.100]     ...future.result <- base::tryCatch({
[16:06:44.100]         base::withCallingHandlers({
[16:06:44.100]             ...future.value <- base::withVisible(base::local({
[16:06:44.100]                 withCallingHandlers({
[16:06:44.100]                   print(42)
[16:06:44.100]                 }, immediateCondition = function(cond) {
[16:06:44.100]                   save_rds <- function (object, pathname, ...) 
[16:06:44.100]                   {
[16:06:44.100]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:06:44.100]                     if (file_test("-f", pathname_tmp)) {
[16:06:44.100]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.100]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:06:44.100]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.100]                         fi_tmp[["mtime"]])
[16:06:44.100]                     }
[16:06:44.100]                     tryCatch({
[16:06:44.100]                       saveRDS(object, file = pathname_tmp, ...)
[16:06:44.100]                     }, error = function(ex) {
[16:06:44.100]                       msg <- conditionMessage(ex)
[16:06:44.100]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.100]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:06:44.100]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.100]                         fi_tmp[["mtime"]], msg)
[16:06:44.100]                       ex$message <- msg
[16:06:44.100]                       stop(ex)
[16:06:44.100]                     })
[16:06:44.100]                     stopifnot(file_test("-f", pathname_tmp))
[16:06:44.100]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:06:44.100]                     if (!res || file_test("-f", pathname_tmp)) {
[16:06:44.100]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.100]                       fi <- file.info(pathname)
[16:06:44.100]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:06:44.100]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.100]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:06:44.100]                         fi[["size"]], fi[["mtime"]])
[16:06:44.100]                       stop(msg)
[16:06:44.100]                     }
[16:06:44.100]                     invisible(pathname)
[16:06:44.100]                   }
[16:06:44.100]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:06:44.100]                     rootPath = tempdir()) 
[16:06:44.100]                   {
[16:06:44.100]                     obj <- list(time = Sys.time(), condition = cond)
[16:06:44.100]                     file <- tempfile(pattern = class(cond)[1], 
[16:06:44.100]                       tmpdir = path, fileext = ".rds")
[16:06:44.100]                     save_rds(obj, file)
[16:06:44.100]                   }
[16:06:44.100]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6lYtbx/.future/immediateConditions")
[16:06:44.100]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.100]                   {
[16:06:44.100]                     inherits <- base::inherits
[16:06:44.100]                     invokeRestart <- base::invokeRestart
[16:06:44.100]                     is.null <- base::is.null
[16:06:44.100]                     muffled <- FALSE
[16:06:44.100]                     if (inherits(cond, "message")) {
[16:06:44.100]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:44.100]                       if (muffled) 
[16:06:44.100]                         invokeRestart("muffleMessage")
[16:06:44.100]                     }
[16:06:44.100]                     else if (inherits(cond, "warning")) {
[16:06:44.100]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:44.100]                       if (muffled) 
[16:06:44.100]                         invokeRestart("muffleWarning")
[16:06:44.100]                     }
[16:06:44.100]                     else if (inherits(cond, "condition")) {
[16:06:44.100]                       if (!is.null(pattern)) {
[16:06:44.100]                         computeRestarts <- base::computeRestarts
[16:06:44.100]                         grepl <- base::grepl
[16:06:44.100]                         restarts <- computeRestarts(cond)
[16:06:44.100]                         for (restart in restarts) {
[16:06:44.100]                           name <- restart$name
[16:06:44.100]                           if (is.null(name)) 
[16:06:44.100]                             next
[16:06:44.100]                           if (!grepl(pattern, name)) 
[16:06:44.100]                             next
[16:06:44.100]                           invokeRestart(restart)
[16:06:44.100]                           muffled <- TRUE
[16:06:44.100]                           break
[16:06:44.100]                         }
[16:06:44.100]                       }
[16:06:44.100]                     }
[16:06:44.100]                     invisible(muffled)
[16:06:44.100]                   }
[16:06:44.100]                   muffleCondition(cond)
[16:06:44.100]                 })
[16:06:44.100]             }))
[16:06:44.100]             future::FutureResult(value = ...future.value$value, 
[16:06:44.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.100]                   ...future.rng), globalenv = if (FALSE) 
[16:06:44.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:44.100]                     ...future.globalenv.names))
[16:06:44.100]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:44.100]         }, condition = base::local({
[16:06:44.100]             c <- base::c
[16:06:44.100]             inherits <- base::inherits
[16:06:44.100]             invokeRestart <- base::invokeRestart
[16:06:44.100]             length <- base::length
[16:06:44.100]             list <- base::list
[16:06:44.100]             seq.int <- base::seq.int
[16:06:44.100]             signalCondition <- base::signalCondition
[16:06:44.100]             sys.calls <- base::sys.calls
[16:06:44.100]             `[[` <- base::`[[`
[16:06:44.100]             `+` <- base::`+`
[16:06:44.100]             `<<-` <- base::`<<-`
[16:06:44.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:44.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:44.100]                   3L)]
[16:06:44.100]             }
[16:06:44.100]             function(cond) {
[16:06:44.100]                 is_error <- inherits(cond, "error")
[16:06:44.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:44.100]                   NULL)
[16:06:44.100]                 if (is_error) {
[16:06:44.100]                   sessionInformation <- function() {
[16:06:44.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:44.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:44.100]                       search = base::search(), system = base::Sys.info())
[16:06:44.100]                   }
[16:06:44.100]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:44.100]                     cond$call), session = sessionInformation(), 
[16:06:44.100]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:44.100]                   signalCondition(cond)
[16:06:44.100]                 }
[16:06:44.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:44.100]                 "immediateCondition"))) {
[16:06:44.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:44.100]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:44.100]                   if (TRUE && !signal) {
[16:06:44.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.100]                     {
[16:06:44.100]                       inherits <- base::inherits
[16:06:44.100]                       invokeRestart <- base::invokeRestart
[16:06:44.100]                       is.null <- base::is.null
[16:06:44.100]                       muffled <- FALSE
[16:06:44.100]                       if (inherits(cond, "message")) {
[16:06:44.100]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.100]                         if (muffled) 
[16:06:44.100]                           invokeRestart("muffleMessage")
[16:06:44.100]                       }
[16:06:44.100]                       else if (inherits(cond, "warning")) {
[16:06:44.100]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.100]                         if (muffled) 
[16:06:44.100]                           invokeRestart("muffleWarning")
[16:06:44.100]                       }
[16:06:44.100]                       else if (inherits(cond, "condition")) {
[16:06:44.100]                         if (!is.null(pattern)) {
[16:06:44.100]                           computeRestarts <- base::computeRestarts
[16:06:44.100]                           grepl <- base::grepl
[16:06:44.100]                           restarts <- computeRestarts(cond)
[16:06:44.100]                           for (restart in restarts) {
[16:06:44.100]                             name <- restart$name
[16:06:44.100]                             if (is.null(name)) 
[16:06:44.100]                               next
[16:06:44.100]                             if (!grepl(pattern, name)) 
[16:06:44.100]                               next
[16:06:44.100]                             invokeRestart(restart)
[16:06:44.100]                             muffled <- TRUE
[16:06:44.100]                             break
[16:06:44.100]                           }
[16:06:44.100]                         }
[16:06:44.100]                       }
[16:06:44.100]                       invisible(muffled)
[16:06:44.100]                     }
[16:06:44.100]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.100]                   }
[16:06:44.100]                 }
[16:06:44.100]                 else {
[16:06:44.100]                   if (TRUE) {
[16:06:44.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.100]                     {
[16:06:44.100]                       inherits <- base::inherits
[16:06:44.100]                       invokeRestart <- base::invokeRestart
[16:06:44.100]                       is.null <- base::is.null
[16:06:44.100]                       muffled <- FALSE
[16:06:44.100]                       if (inherits(cond, "message")) {
[16:06:44.100]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.100]                         if (muffled) 
[16:06:44.100]                           invokeRestart("muffleMessage")
[16:06:44.100]                       }
[16:06:44.100]                       else if (inherits(cond, "warning")) {
[16:06:44.100]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.100]                         if (muffled) 
[16:06:44.100]                           invokeRestart("muffleWarning")
[16:06:44.100]                       }
[16:06:44.100]                       else if (inherits(cond, "condition")) {
[16:06:44.100]                         if (!is.null(pattern)) {
[16:06:44.100]                           computeRestarts <- base::computeRestarts
[16:06:44.100]                           grepl <- base::grepl
[16:06:44.100]                           restarts <- computeRestarts(cond)
[16:06:44.100]                           for (restart in restarts) {
[16:06:44.100]                             name <- restart$name
[16:06:44.100]                             if (is.null(name)) 
[16:06:44.100]                               next
[16:06:44.100]                             if (!grepl(pattern, name)) 
[16:06:44.100]                               next
[16:06:44.100]                             invokeRestart(restart)
[16:06:44.100]                             muffled <- TRUE
[16:06:44.100]                             break
[16:06:44.100]                           }
[16:06:44.100]                         }
[16:06:44.100]                       }
[16:06:44.100]                       invisible(muffled)
[16:06:44.100]                     }
[16:06:44.100]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.100]                   }
[16:06:44.100]                 }
[16:06:44.100]             }
[16:06:44.100]         }))
[16:06:44.100]     }, error = function(ex) {
[16:06:44.100]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:44.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.100]                 ...future.rng), started = ...future.startTime, 
[16:06:44.100]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:44.100]             version = "1.8"), class = "FutureResult")
[16:06:44.100]     }, finally = {
[16:06:44.100]         if (!identical(...future.workdir, getwd())) 
[16:06:44.100]             setwd(...future.workdir)
[16:06:44.100]         {
[16:06:44.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:44.100]                 ...future.oldOptions$nwarnings <- NULL
[16:06:44.100]             }
[16:06:44.100]             base::options(...future.oldOptions)
[16:06:44.100]             if (.Platform$OS.type == "windows") {
[16:06:44.100]                 old_names <- names(...future.oldEnvVars)
[16:06:44.100]                 envs <- base::Sys.getenv()
[16:06:44.100]                 names <- names(envs)
[16:06:44.100]                 common <- intersect(names, old_names)
[16:06:44.100]                 added <- setdiff(names, old_names)
[16:06:44.100]                 removed <- setdiff(old_names, names)
[16:06:44.100]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:44.100]                   envs[common]]
[16:06:44.100]                 NAMES <- toupper(changed)
[16:06:44.100]                 args <- list()
[16:06:44.100]                 for (kk in seq_along(NAMES)) {
[16:06:44.100]                   name <- changed[[kk]]
[16:06:44.100]                   NAME <- NAMES[[kk]]
[16:06:44.100]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.100]                     next
[16:06:44.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.100]                 }
[16:06:44.100]                 NAMES <- toupper(added)
[16:06:44.100]                 for (kk in seq_along(NAMES)) {
[16:06:44.100]                   name <- added[[kk]]
[16:06:44.100]                   NAME <- NAMES[[kk]]
[16:06:44.100]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.100]                     next
[16:06:44.100]                   args[[name]] <- ""
[16:06:44.100]                 }
[16:06:44.100]                 NAMES <- toupper(removed)
[16:06:44.100]                 for (kk in seq_along(NAMES)) {
[16:06:44.100]                   name <- removed[[kk]]
[16:06:44.100]                   NAME <- NAMES[[kk]]
[16:06:44.100]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.100]                     next
[16:06:44.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.100]                 }
[16:06:44.100]                 if (length(args) > 0) 
[16:06:44.100]                   base::do.call(base::Sys.setenv, args = args)
[16:06:44.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:44.100]             }
[16:06:44.100]             else {
[16:06:44.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:44.100]             }
[16:06:44.100]             {
[16:06:44.100]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:44.100]                   0L) {
[16:06:44.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:44.100]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:44.100]                   base::options(opts)
[16:06:44.100]                 }
[16:06:44.100]                 {
[16:06:44.100]                   {
[16:06:44.100]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:44.100]                     NULL
[16:06:44.100]                   }
[16:06:44.100]                   options(future.plan = NULL)
[16:06:44.100]                   if (is.na(NA_character_)) 
[16:06:44.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:44.100]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:06:44.100]                     envir = parent.frame()) 
[16:06:44.100]                   {
[16:06:44.100]                     default_workers <- missing(workers)
[16:06:44.100]                     if (is.function(workers)) 
[16:06:44.100]                       workers <- workers()
[16:06:44.100]                     workers <- structure(as.integer(workers), 
[16:06:44.100]                       class = class(workers))
[16:06:44.100]                     stop_if_not(is.finite(workers), workers >= 
[16:06:44.100]                       1L)
[16:06:44.100]                     if ((workers == 1L && !inherits(workers, 
[16:06:44.100]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:06:44.100]                       if (default_workers) 
[16:06:44.100]                         supportsMulticore(warn = TRUE)
[16:06:44.100]                       return(sequential(..., envir = envir))
[16:06:44.100]                     }
[16:06:44.100]                     oopts <- options(mc.cores = workers)
[16:06:44.100]                     on.exit(options(oopts))
[16:06:44.100]                     future <- MulticoreFuture(..., workers = workers, 
[16:06:44.100]                       envir = envir)
[16:06:44.100]                     if (!future$lazy) 
[16:06:44.100]                       future <- run(future)
[16:06:44.100]                     invisible(future)
[16:06:44.100]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:44.100]                 }
[16:06:44.100]             }
[16:06:44.100]         }
[16:06:44.100]     })
[16:06:44.100]     if (TRUE) {
[16:06:44.100]         base::sink(type = "output", split = FALSE)
[16:06:44.100]         if (TRUE) {
[16:06:44.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:44.100]         }
[16:06:44.100]         else {
[16:06:44.100]             ...future.result["stdout"] <- base::list(NULL)
[16:06:44.100]         }
[16:06:44.100]         base::close(...future.stdout)
[16:06:44.100]         ...future.stdout <- NULL
[16:06:44.100]     }
[16:06:44.100]     ...future.result$conditions <- ...future.conditions
[16:06:44.100]     ...future.result$finished <- base::Sys.time()
[16:06:44.100]     ...future.result
[16:06:44.100] }
[16:06:44.102] requestCore(): workers = 2
[16:06:44.104] MulticoreFuture started
[16:06:44.104] - Launch lazy future ... done
[16:06:44.105] run() for ‘MulticoreFuture’ ... done
[16:06:44.105] result() for MulticoreFuture ...
[16:06:44.105] plan(): Setting new future strategy stack:
[16:06:44.105] List of future strategies:
[16:06:44.105] 1. sequential:
[16:06:44.105]    - args: function (..., envir = parent.frame())
[16:06:44.105]    - tweaked: FALSE
[16:06:44.105]    - call: NULL
[16:06:44.106] plan(): nbrOfWorkers() = 1
[16:06:44.113] plan(): Setting new future strategy stack:
[16:06:44.113] List of future strategies:
[16:06:44.113] 1. multicore:
[16:06:44.113]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:06:44.113]    - tweaked: FALSE
[16:06:44.113]    - call: plan(strategy)
[16:06:44.118] plan(): nbrOfWorkers() = 2
[16:06:44.121] result() for MulticoreFuture ...
[16:06:44.121] result() for MulticoreFuture ... done
[16:06:44.121] result() for MulticoreFuture ... done
[16:06:44.122] result() for MulticoreFuture ...
[16:06:44.122] result() for MulticoreFuture ... done
[16:06:44.122] result() for MulticoreFuture ...
[16:06:44.122] result() for MulticoreFuture ... done
[1] 42
[16:06:44.122] result() for MulticoreFuture ...
[16:06:44.122] result() for MulticoreFuture ... done
- stdout = FALSE
[16:06:44.123] getGlobalsAndPackages() ...
[16:06:44.123] Searching for globals...
[16:06:44.127] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:44.127] Searching for globals ... DONE
[16:06:44.127] Resolving globals: FALSE
[16:06:44.128] 
[16:06:44.128] - packages: [1] ‘utils’
[16:06:44.128] getGlobalsAndPackages() ... DONE
[16:06:44.128] run() for ‘Future’ ...
[16:06:44.128] - state: ‘created’
[16:06:44.129] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:06:44.132] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:44.133] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:06:44.133]   - Field: ‘label’
[16:06:44.133]   - Field: ‘local’
[16:06:44.133]   - Field: ‘owner’
[16:06:44.133]   - Field: ‘envir’
[16:06:44.133]   - Field: ‘workers’
[16:06:44.133]   - Field: ‘packages’
[16:06:44.133]   - Field: ‘gc’
[16:06:44.134]   - Field: ‘job’
[16:06:44.134]   - Field: ‘conditions’
[16:06:44.134]   - Field: ‘expr’
[16:06:44.134]   - Field: ‘uuid’
[16:06:44.134]   - Field: ‘seed’
[16:06:44.134]   - Field: ‘version’
[16:06:44.134]   - Field: ‘result’
[16:06:44.134]   - Field: ‘asynchronous’
[16:06:44.134]   - Field: ‘calls’
[16:06:44.135]   - Field: ‘globals’
[16:06:44.135]   - Field: ‘stdout’
[16:06:44.135]   - Field: ‘earlySignal’
[16:06:44.135]   - Field: ‘lazy’
[16:06:44.135]   - Field: ‘state’
[16:06:44.135] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:06:44.135] - Launch lazy future ...
[16:06:44.136] Packages needed by the future expression (n = 1): ‘utils’
[16:06:44.136] Packages needed by future strategies (n = 0): <none>
[16:06:44.136] {
[16:06:44.136]     {
[16:06:44.136]         {
[16:06:44.136]             ...future.startTime <- base::Sys.time()
[16:06:44.136]             {
[16:06:44.136]                 {
[16:06:44.136]                   {
[16:06:44.136]                     {
[16:06:44.136]                       {
[16:06:44.136]                         base::local({
[16:06:44.136]                           has_future <- base::requireNamespace("future", 
[16:06:44.136]                             quietly = TRUE)
[16:06:44.136]                           if (has_future) {
[16:06:44.136]                             ns <- base::getNamespace("future")
[16:06:44.136]                             version <- ns[[".package"]][["version"]]
[16:06:44.136]                             if (is.null(version)) 
[16:06:44.136]                               version <- utils::packageVersion("future")
[16:06:44.136]                           }
[16:06:44.136]                           else {
[16:06:44.136]                             version <- NULL
[16:06:44.136]                           }
[16:06:44.136]                           if (!has_future || version < "1.8.0") {
[16:06:44.136]                             info <- base::c(r_version = base::gsub("R version ", 
[16:06:44.136]                               "", base::R.version$version.string), 
[16:06:44.136]                               platform = base::sprintf("%s (%s-bit)", 
[16:06:44.136]                                 base::R.version$platform, 8 * 
[16:06:44.136]                                   base::.Machine$sizeof.pointer), 
[16:06:44.136]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:44.136]                                 "release", "version")], collapse = " "), 
[16:06:44.136]                               hostname = base::Sys.info()[["nodename"]])
[16:06:44.136]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:06:44.136]                               info)
[16:06:44.136]                             info <- base::paste(info, collapse = "; ")
[16:06:44.136]                             if (!has_future) {
[16:06:44.136]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:44.136]                                 info)
[16:06:44.136]                             }
[16:06:44.136]                             else {
[16:06:44.136]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:44.136]                                 info, version)
[16:06:44.136]                             }
[16:06:44.136]                             base::stop(msg)
[16:06:44.136]                           }
[16:06:44.136]                         })
[16:06:44.136]                       }
[16:06:44.136]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:44.136]                       base::options(mc.cores = 1L)
[16:06:44.136]                     }
[16:06:44.136]                     base::local({
[16:06:44.136]                       for (pkg in "utils") {
[16:06:44.136]                         base::loadNamespace(pkg)
[16:06:44.136]                         base::library(pkg, character.only = TRUE)
[16:06:44.136]                       }
[16:06:44.136]                     })
[16:06:44.136]                   }
[16:06:44.136]                   options(future.plan = NULL)
[16:06:44.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:44.136]                 }
[16:06:44.136]                 ...future.workdir <- getwd()
[16:06:44.136]             }
[16:06:44.136]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:44.136]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:44.136]         }
[16:06:44.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:44.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:44.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:44.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:44.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:44.136]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:44.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:44.136]             base::names(...future.oldOptions))
[16:06:44.136]     }
[16:06:44.136]     if (FALSE) {
[16:06:44.136]     }
[16:06:44.136]     else {
[16:06:44.136]         if (FALSE) {
[16:06:44.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:44.136]                 open = "w")
[16:06:44.136]         }
[16:06:44.136]         else {
[16:06:44.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:44.136]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:44.136]         }
[16:06:44.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:44.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:44.136]             base::sink(type = "output", split = FALSE)
[16:06:44.136]             base::close(...future.stdout)
[16:06:44.136]         }, add = TRUE)
[16:06:44.136]     }
[16:06:44.136]     ...future.frame <- base::sys.nframe()
[16:06:44.136]     ...future.conditions <- base::list()
[16:06:44.136]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:44.136]     if (FALSE) {
[16:06:44.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:44.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:44.136]     }
[16:06:44.136]     ...future.result <- base::tryCatch({
[16:06:44.136]         base::withCallingHandlers({
[16:06:44.136]             ...future.value <- base::withVisible(base::local({
[16:06:44.136]                 withCallingHandlers({
[16:06:44.136]                   {
[16:06:44.136]                     print(1:50)
[16:06:44.136]                     str(1:50)
[16:06:44.136]                     cat(letters, sep = "-")
[16:06:44.136]                     cat(1:6, collapse = "\n")
[16:06:44.136]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:44.136]                     42L
[16:06:44.136]                   }
[16:06:44.136]                 }, immediateCondition = function(cond) {
[16:06:44.136]                   save_rds <- function (object, pathname, ...) 
[16:06:44.136]                   {
[16:06:44.136]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:06:44.136]                     if (file_test("-f", pathname_tmp)) {
[16:06:44.136]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.136]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:06:44.136]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.136]                         fi_tmp[["mtime"]])
[16:06:44.136]                     }
[16:06:44.136]                     tryCatch({
[16:06:44.136]                       saveRDS(object, file = pathname_tmp, ...)
[16:06:44.136]                     }, error = function(ex) {
[16:06:44.136]                       msg <- conditionMessage(ex)
[16:06:44.136]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.136]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:06:44.136]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.136]                         fi_tmp[["mtime"]], msg)
[16:06:44.136]                       ex$message <- msg
[16:06:44.136]                       stop(ex)
[16:06:44.136]                     })
[16:06:44.136]                     stopifnot(file_test("-f", pathname_tmp))
[16:06:44.136]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:06:44.136]                     if (!res || file_test("-f", pathname_tmp)) {
[16:06:44.136]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.136]                       fi <- file.info(pathname)
[16:06:44.136]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:06:44.136]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.136]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:06:44.136]                         fi[["size"]], fi[["mtime"]])
[16:06:44.136]                       stop(msg)
[16:06:44.136]                     }
[16:06:44.136]                     invisible(pathname)
[16:06:44.136]                   }
[16:06:44.136]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:06:44.136]                     rootPath = tempdir()) 
[16:06:44.136]                   {
[16:06:44.136]                     obj <- list(time = Sys.time(), condition = cond)
[16:06:44.136]                     file <- tempfile(pattern = class(cond)[1], 
[16:06:44.136]                       tmpdir = path, fileext = ".rds")
[16:06:44.136]                     save_rds(obj, file)
[16:06:44.136]                   }
[16:06:44.136]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6lYtbx/.future/immediateConditions")
[16:06:44.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.136]                   {
[16:06:44.136]                     inherits <- base::inherits
[16:06:44.136]                     invokeRestart <- base::invokeRestart
[16:06:44.136]                     is.null <- base::is.null
[16:06:44.136]                     muffled <- FALSE
[16:06:44.136]                     if (inherits(cond, "message")) {
[16:06:44.136]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:44.136]                       if (muffled) 
[16:06:44.136]                         invokeRestart("muffleMessage")
[16:06:44.136]                     }
[16:06:44.136]                     else if (inherits(cond, "warning")) {
[16:06:44.136]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:44.136]                       if (muffled) 
[16:06:44.136]                         invokeRestart("muffleWarning")
[16:06:44.136]                     }
[16:06:44.136]                     else if (inherits(cond, "condition")) {
[16:06:44.136]                       if (!is.null(pattern)) {
[16:06:44.136]                         computeRestarts <- base::computeRestarts
[16:06:44.136]                         grepl <- base::grepl
[16:06:44.136]                         restarts <- computeRestarts(cond)
[16:06:44.136]                         for (restart in restarts) {
[16:06:44.136]                           name <- restart$name
[16:06:44.136]                           if (is.null(name)) 
[16:06:44.136]                             next
[16:06:44.136]                           if (!grepl(pattern, name)) 
[16:06:44.136]                             next
[16:06:44.136]                           invokeRestart(restart)
[16:06:44.136]                           muffled <- TRUE
[16:06:44.136]                           break
[16:06:44.136]                         }
[16:06:44.136]                       }
[16:06:44.136]                     }
[16:06:44.136]                     invisible(muffled)
[16:06:44.136]                   }
[16:06:44.136]                   muffleCondition(cond)
[16:06:44.136]                 })
[16:06:44.136]             }))
[16:06:44.136]             future::FutureResult(value = ...future.value$value, 
[16:06:44.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.136]                   ...future.rng), globalenv = if (FALSE) 
[16:06:44.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:44.136]                     ...future.globalenv.names))
[16:06:44.136]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:44.136]         }, condition = base::local({
[16:06:44.136]             c <- base::c
[16:06:44.136]             inherits <- base::inherits
[16:06:44.136]             invokeRestart <- base::invokeRestart
[16:06:44.136]             length <- base::length
[16:06:44.136]             list <- base::list
[16:06:44.136]             seq.int <- base::seq.int
[16:06:44.136]             signalCondition <- base::signalCondition
[16:06:44.136]             sys.calls <- base::sys.calls
[16:06:44.136]             `[[` <- base::`[[`
[16:06:44.136]             `+` <- base::`+`
[16:06:44.136]             `<<-` <- base::`<<-`
[16:06:44.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:44.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:44.136]                   3L)]
[16:06:44.136]             }
[16:06:44.136]             function(cond) {
[16:06:44.136]                 is_error <- inherits(cond, "error")
[16:06:44.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:44.136]                   NULL)
[16:06:44.136]                 if (is_error) {
[16:06:44.136]                   sessionInformation <- function() {
[16:06:44.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:44.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:44.136]                       search = base::search(), system = base::Sys.info())
[16:06:44.136]                   }
[16:06:44.136]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:44.136]                     cond$call), session = sessionInformation(), 
[16:06:44.136]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:44.136]                   signalCondition(cond)
[16:06:44.136]                 }
[16:06:44.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:44.136]                 "immediateCondition"))) {
[16:06:44.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:44.136]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:44.136]                   if (TRUE && !signal) {
[16:06:44.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.136]                     {
[16:06:44.136]                       inherits <- base::inherits
[16:06:44.136]                       invokeRestart <- base::invokeRestart
[16:06:44.136]                       is.null <- base::is.null
[16:06:44.136]                       muffled <- FALSE
[16:06:44.136]                       if (inherits(cond, "message")) {
[16:06:44.136]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.136]                         if (muffled) 
[16:06:44.136]                           invokeRestart("muffleMessage")
[16:06:44.136]                       }
[16:06:44.136]                       else if (inherits(cond, "warning")) {
[16:06:44.136]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.136]                         if (muffled) 
[16:06:44.136]                           invokeRestart("muffleWarning")
[16:06:44.136]                       }
[16:06:44.136]                       else if (inherits(cond, "condition")) {
[16:06:44.136]                         if (!is.null(pattern)) {
[16:06:44.136]                           computeRestarts <- base::computeRestarts
[16:06:44.136]                           grepl <- base::grepl
[16:06:44.136]                           restarts <- computeRestarts(cond)
[16:06:44.136]                           for (restart in restarts) {
[16:06:44.136]                             name <- restart$name
[16:06:44.136]                             if (is.null(name)) 
[16:06:44.136]                               next
[16:06:44.136]                             if (!grepl(pattern, name)) 
[16:06:44.136]                               next
[16:06:44.136]                             invokeRestart(restart)
[16:06:44.136]                             muffled <- TRUE
[16:06:44.136]                             break
[16:06:44.136]                           }
[16:06:44.136]                         }
[16:06:44.136]                       }
[16:06:44.136]                       invisible(muffled)
[16:06:44.136]                     }
[16:06:44.136]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.136]                   }
[16:06:44.136]                 }
[16:06:44.136]                 else {
[16:06:44.136]                   if (TRUE) {
[16:06:44.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.136]                     {
[16:06:44.136]                       inherits <- base::inherits
[16:06:44.136]                       invokeRestart <- base::invokeRestart
[16:06:44.136]                       is.null <- base::is.null
[16:06:44.136]                       muffled <- FALSE
[16:06:44.136]                       if (inherits(cond, "message")) {
[16:06:44.136]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.136]                         if (muffled) 
[16:06:44.136]                           invokeRestart("muffleMessage")
[16:06:44.136]                       }
[16:06:44.136]                       else if (inherits(cond, "warning")) {
[16:06:44.136]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.136]                         if (muffled) 
[16:06:44.136]                           invokeRestart("muffleWarning")
[16:06:44.136]                       }
[16:06:44.136]                       else if (inherits(cond, "condition")) {
[16:06:44.136]                         if (!is.null(pattern)) {
[16:06:44.136]                           computeRestarts <- base::computeRestarts
[16:06:44.136]                           grepl <- base::grepl
[16:06:44.136]                           restarts <- computeRestarts(cond)
[16:06:44.136]                           for (restart in restarts) {
[16:06:44.136]                             name <- restart$name
[16:06:44.136]                             if (is.null(name)) 
[16:06:44.136]                               next
[16:06:44.136]                             if (!grepl(pattern, name)) 
[16:06:44.136]                               next
[16:06:44.136]                             invokeRestart(restart)
[16:06:44.136]                             muffled <- TRUE
[16:06:44.136]                             break
[16:06:44.136]                           }
[16:06:44.136]                         }
[16:06:44.136]                       }
[16:06:44.136]                       invisible(muffled)
[16:06:44.136]                     }
[16:06:44.136]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.136]                   }
[16:06:44.136]                 }
[16:06:44.136]             }
[16:06:44.136]         }))
[16:06:44.136]     }, error = function(ex) {
[16:06:44.136]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:44.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.136]                 ...future.rng), started = ...future.startTime, 
[16:06:44.136]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:44.136]             version = "1.8"), class = "FutureResult")
[16:06:44.136]     }, finally = {
[16:06:44.136]         if (!identical(...future.workdir, getwd())) 
[16:06:44.136]             setwd(...future.workdir)
[16:06:44.136]         {
[16:06:44.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:44.136]                 ...future.oldOptions$nwarnings <- NULL
[16:06:44.136]             }
[16:06:44.136]             base::options(...future.oldOptions)
[16:06:44.136]             if (.Platform$OS.type == "windows") {
[16:06:44.136]                 old_names <- names(...future.oldEnvVars)
[16:06:44.136]                 envs <- base::Sys.getenv()
[16:06:44.136]                 names <- names(envs)
[16:06:44.136]                 common <- intersect(names, old_names)
[16:06:44.136]                 added <- setdiff(names, old_names)
[16:06:44.136]                 removed <- setdiff(old_names, names)
[16:06:44.136]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:44.136]                   envs[common]]
[16:06:44.136]                 NAMES <- toupper(changed)
[16:06:44.136]                 args <- list()
[16:06:44.136]                 for (kk in seq_along(NAMES)) {
[16:06:44.136]                   name <- changed[[kk]]
[16:06:44.136]                   NAME <- NAMES[[kk]]
[16:06:44.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.136]                     next
[16:06:44.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.136]                 }
[16:06:44.136]                 NAMES <- toupper(added)
[16:06:44.136]                 for (kk in seq_along(NAMES)) {
[16:06:44.136]                   name <- added[[kk]]
[16:06:44.136]                   NAME <- NAMES[[kk]]
[16:06:44.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.136]                     next
[16:06:44.136]                   args[[name]] <- ""
[16:06:44.136]                 }
[16:06:44.136]                 NAMES <- toupper(removed)
[16:06:44.136]                 for (kk in seq_along(NAMES)) {
[16:06:44.136]                   name <- removed[[kk]]
[16:06:44.136]                   NAME <- NAMES[[kk]]
[16:06:44.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.136]                     next
[16:06:44.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.136]                 }
[16:06:44.136]                 if (length(args) > 0) 
[16:06:44.136]                   base::do.call(base::Sys.setenv, args = args)
[16:06:44.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:44.136]             }
[16:06:44.136]             else {
[16:06:44.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:44.136]             }
[16:06:44.136]             {
[16:06:44.136]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:44.136]                   0L) {
[16:06:44.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:44.136]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:44.136]                   base::options(opts)
[16:06:44.136]                 }
[16:06:44.136]                 {
[16:06:44.136]                   {
[16:06:44.136]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:44.136]                     NULL
[16:06:44.136]                   }
[16:06:44.136]                   options(future.plan = NULL)
[16:06:44.136]                   if (is.na(NA_character_)) 
[16:06:44.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:44.136]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:06:44.136]                     envir = parent.frame()) 
[16:06:44.136]                   {
[16:06:44.136]                     default_workers <- missing(workers)
[16:06:44.136]                     if (is.function(workers)) 
[16:06:44.136]                       workers <- workers()
[16:06:44.136]                     workers <- structure(as.integer(workers), 
[16:06:44.136]                       class = class(workers))
[16:06:44.136]                     stop_if_not(is.finite(workers), workers >= 
[16:06:44.136]                       1L)
[16:06:44.136]                     if ((workers == 1L && !inherits(workers, 
[16:06:44.136]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:06:44.136]                       if (default_workers) 
[16:06:44.136]                         supportsMulticore(warn = TRUE)
[16:06:44.136]                       return(sequential(..., envir = envir))
[16:06:44.136]                     }
[16:06:44.136]                     oopts <- options(mc.cores = workers)
[16:06:44.136]                     on.exit(options(oopts))
[16:06:44.136]                     future <- MulticoreFuture(..., workers = workers, 
[16:06:44.136]                       envir = envir)
[16:06:44.136]                     if (!future$lazy) 
[16:06:44.136]                       future <- run(future)
[16:06:44.136]                     invisible(future)
[16:06:44.136]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:44.136]                 }
[16:06:44.136]             }
[16:06:44.136]         }
[16:06:44.136]     })
[16:06:44.136]     if (TRUE) {
[16:06:44.136]         base::sink(type = "output", split = FALSE)
[16:06:44.136]         if (FALSE) {
[16:06:44.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:44.136]         }
[16:06:44.136]         else {
[16:06:44.136]             ...future.result["stdout"] <- base::list(NULL)
[16:06:44.136]         }
[16:06:44.136]         base::close(...future.stdout)
[16:06:44.136]         ...future.stdout <- NULL
[16:06:44.136]     }
[16:06:44.136]     ...future.result$conditions <- ...future.conditions
[16:06:44.136]     ...future.result$finished <- base::Sys.time()
[16:06:44.136]     ...future.result
[16:06:44.136] }
[16:06:44.139] requestCore(): workers = 2
[16:06:44.140] MulticoreFuture started
[16:06:44.141] - Launch lazy future ... done
[16:06:44.141] run() for ‘MulticoreFuture’ ... done
[16:06:44.141] result() for MulticoreFuture ...
[16:06:44.142] plan(): Setting new future strategy stack:
[16:06:44.142] List of future strategies:
[16:06:44.142] 1. sequential:
[16:06:44.142]    - args: function (..., envir = parent.frame())
[16:06:44.142]    - tweaked: FALSE
[16:06:44.142]    - call: NULL
[16:06:44.143] plan(): nbrOfWorkers() = 1
[16:06:44.146] plan(): Setting new future strategy stack:
[16:06:44.146] List of future strategies:
[16:06:44.146] 1. multicore:
[16:06:44.146]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:06:44.146]    - tweaked: FALSE
[16:06:44.146]    - call: plan(strategy)
[16:06:44.151] plan(): nbrOfWorkers() = 2
[16:06:44.152] result() for MulticoreFuture ...
[16:06:44.152] result() for MulticoreFuture ... done
[16:06:44.152] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:06:44"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:06:44"
 $ session_uuid: chr "5d2516f1-54fc-1569-da94-29c4b06335da"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "11666ca4073c"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92425
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:06:44"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:06:44.162] result() for MulticoreFuture ...
[16:06:44.162] result() for MulticoreFuture ... done
[16:06:44.162] result() for MulticoreFuture ...
[16:06:44.162] result() for MulticoreFuture ... done
[16:06:44.162] getGlobalsAndPackages() ...
[16:06:44.162] Searching for globals...
[16:06:44.169] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:44.169] Searching for globals ... DONE
[16:06:44.169] Resolving globals: FALSE
[16:06:44.170] 
[16:06:44.170] - packages: [1] ‘utils’
[16:06:44.170] getGlobalsAndPackages() ... DONE
[16:06:44.170] run() for ‘Future’ ...
[16:06:44.170] - state: ‘created’
[16:06:44.171] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:06:44.174] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:44.174] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:06:44.175]   - Field: ‘label’
[16:06:44.175]   - Field: ‘local’
[16:06:44.175]   - Field: ‘owner’
[16:06:44.175]   - Field: ‘envir’
[16:06:44.175]   - Field: ‘workers’
[16:06:44.175]   - Field: ‘packages’
[16:06:44.175]   - Field: ‘gc’
[16:06:44.175]   - Field: ‘job’
[16:06:44.176]   - Field: ‘conditions’
[16:06:44.176]   - Field: ‘expr’
[16:06:44.176]   - Field: ‘uuid’
[16:06:44.176]   - Field: ‘seed’
[16:06:44.176]   - Field: ‘version’
[16:06:44.176]   - Field: ‘result’
[16:06:44.176]   - Field: ‘asynchronous’
[16:06:44.176]   - Field: ‘calls’
[16:06:44.176]   - Field: ‘globals’
[16:06:44.177]   - Field: ‘stdout’
[16:06:44.177]   - Field: ‘earlySignal’
[16:06:44.177]   - Field: ‘lazy’
[16:06:44.177]   - Field: ‘state’
[16:06:44.177] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:06:44.177] - Launch lazy future ...
[16:06:44.177] Packages needed by the future expression (n = 1): ‘utils’
[16:06:44.178] Packages needed by future strategies (n = 0): <none>
[16:06:44.178] {
[16:06:44.178]     {
[16:06:44.178]         {
[16:06:44.178]             ...future.startTime <- base::Sys.time()
[16:06:44.178]             {
[16:06:44.178]                 {
[16:06:44.178]                   {
[16:06:44.178]                     {
[16:06:44.178]                       {
[16:06:44.178]                         base::local({
[16:06:44.178]                           has_future <- base::requireNamespace("future", 
[16:06:44.178]                             quietly = TRUE)
[16:06:44.178]                           if (has_future) {
[16:06:44.178]                             ns <- base::getNamespace("future")
[16:06:44.178]                             version <- ns[[".package"]][["version"]]
[16:06:44.178]                             if (is.null(version)) 
[16:06:44.178]                               version <- utils::packageVersion("future")
[16:06:44.178]                           }
[16:06:44.178]                           else {
[16:06:44.178]                             version <- NULL
[16:06:44.178]                           }
[16:06:44.178]                           if (!has_future || version < "1.8.0") {
[16:06:44.178]                             info <- base::c(r_version = base::gsub("R version ", 
[16:06:44.178]                               "", base::R.version$version.string), 
[16:06:44.178]                               platform = base::sprintf("%s (%s-bit)", 
[16:06:44.178]                                 base::R.version$platform, 8 * 
[16:06:44.178]                                   base::.Machine$sizeof.pointer), 
[16:06:44.178]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:44.178]                                 "release", "version")], collapse = " "), 
[16:06:44.178]                               hostname = base::Sys.info()[["nodename"]])
[16:06:44.178]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:06:44.178]                               info)
[16:06:44.178]                             info <- base::paste(info, collapse = "; ")
[16:06:44.178]                             if (!has_future) {
[16:06:44.178]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:44.178]                                 info)
[16:06:44.178]                             }
[16:06:44.178]                             else {
[16:06:44.178]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:44.178]                                 info, version)
[16:06:44.178]                             }
[16:06:44.178]                             base::stop(msg)
[16:06:44.178]                           }
[16:06:44.178]                         })
[16:06:44.178]                       }
[16:06:44.178]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:44.178]                       base::options(mc.cores = 1L)
[16:06:44.178]                     }
[16:06:44.178]                     base::local({
[16:06:44.178]                       for (pkg in "utils") {
[16:06:44.178]                         base::loadNamespace(pkg)
[16:06:44.178]                         base::library(pkg, character.only = TRUE)
[16:06:44.178]                       }
[16:06:44.178]                     })
[16:06:44.178]                   }
[16:06:44.178]                   options(future.plan = NULL)
[16:06:44.178]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.178]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:44.178]                 }
[16:06:44.178]                 ...future.workdir <- getwd()
[16:06:44.178]             }
[16:06:44.178]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:44.178]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:44.178]         }
[16:06:44.178]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:44.178]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:44.178]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:44.178]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:44.178]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:44.178]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:44.178]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:44.178]             base::names(...future.oldOptions))
[16:06:44.178]     }
[16:06:44.178]     if (FALSE) {
[16:06:44.178]     }
[16:06:44.178]     else {
[16:06:44.178]         if (FALSE) {
[16:06:44.178]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:44.178]                 open = "w")
[16:06:44.178]         }
[16:06:44.178]         else {
[16:06:44.178]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:44.178]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:44.178]         }
[16:06:44.178]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:44.178]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:44.178]             base::sink(type = "output", split = FALSE)
[16:06:44.178]             base::close(...future.stdout)
[16:06:44.178]         }, add = TRUE)
[16:06:44.178]     }
[16:06:44.178]     ...future.frame <- base::sys.nframe()
[16:06:44.178]     ...future.conditions <- base::list()
[16:06:44.178]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:44.178]     if (FALSE) {
[16:06:44.178]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:44.178]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:44.178]     }
[16:06:44.178]     ...future.result <- base::tryCatch({
[16:06:44.178]         base::withCallingHandlers({
[16:06:44.178]             ...future.value <- base::withVisible(base::local({
[16:06:44.178]                 withCallingHandlers({
[16:06:44.178]                   {
[16:06:44.178]                     print(1:50)
[16:06:44.178]                     str(1:50)
[16:06:44.178]                     cat(letters, sep = "-")
[16:06:44.178]                     cat(1:6, collapse = "\n")
[16:06:44.178]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:44.178]                     42L
[16:06:44.178]                   }
[16:06:44.178]                 }, immediateCondition = function(cond) {
[16:06:44.178]                   save_rds <- function (object, pathname, ...) 
[16:06:44.178]                   {
[16:06:44.178]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:06:44.178]                     if (file_test("-f", pathname_tmp)) {
[16:06:44.178]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.178]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:06:44.178]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.178]                         fi_tmp[["mtime"]])
[16:06:44.178]                     }
[16:06:44.178]                     tryCatch({
[16:06:44.178]                       saveRDS(object, file = pathname_tmp, ...)
[16:06:44.178]                     }, error = function(ex) {
[16:06:44.178]                       msg <- conditionMessage(ex)
[16:06:44.178]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.178]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:06:44.178]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.178]                         fi_tmp[["mtime"]], msg)
[16:06:44.178]                       ex$message <- msg
[16:06:44.178]                       stop(ex)
[16:06:44.178]                     })
[16:06:44.178]                     stopifnot(file_test("-f", pathname_tmp))
[16:06:44.178]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:06:44.178]                     if (!res || file_test("-f", pathname_tmp)) {
[16:06:44.178]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.178]                       fi <- file.info(pathname)
[16:06:44.178]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:06:44.178]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.178]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:06:44.178]                         fi[["size"]], fi[["mtime"]])
[16:06:44.178]                       stop(msg)
[16:06:44.178]                     }
[16:06:44.178]                     invisible(pathname)
[16:06:44.178]                   }
[16:06:44.178]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:06:44.178]                     rootPath = tempdir()) 
[16:06:44.178]                   {
[16:06:44.178]                     obj <- list(time = Sys.time(), condition = cond)
[16:06:44.178]                     file <- tempfile(pattern = class(cond)[1], 
[16:06:44.178]                       tmpdir = path, fileext = ".rds")
[16:06:44.178]                     save_rds(obj, file)
[16:06:44.178]                   }
[16:06:44.178]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6lYtbx/.future/immediateConditions")
[16:06:44.178]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.178]                   {
[16:06:44.178]                     inherits <- base::inherits
[16:06:44.178]                     invokeRestart <- base::invokeRestart
[16:06:44.178]                     is.null <- base::is.null
[16:06:44.178]                     muffled <- FALSE
[16:06:44.178]                     if (inherits(cond, "message")) {
[16:06:44.178]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:44.178]                       if (muffled) 
[16:06:44.178]                         invokeRestart("muffleMessage")
[16:06:44.178]                     }
[16:06:44.178]                     else if (inherits(cond, "warning")) {
[16:06:44.178]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:44.178]                       if (muffled) 
[16:06:44.178]                         invokeRestart("muffleWarning")
[16:06:44.178]                     }
[16:06:44.178]                     else if (inherits(cond, "condition")) {
[16:06:44.178]                       if (!is.null(pattern)) {
[16:06:44.178]                         computeRestarts <- base::computeRestarts
[16:06:44.178]                         grepl <- base::grepl
[16:06:44.178]                         restarts <- computeRestarts(cond)
[16:06:44.178]                         for (restart in restarts) {
[16:06:44.178]                           name <- restart$name
[16:06:44.178]                           if (is.null(name)) 
[16:06:44.178]                             next
[16:06:44.178]                           if (!grepl(pattern, name)) 
[16:06:44.178]                             next
[16:06:44.178]                           invokeRestart(restart)
[16:06:44.178]                           muffled <- TRUE
[16:06:44.178]                           break
[16:06:44.178]                         }
[16:06:44.178]                       }
[16:06:44.178]                     }
[16:06:44.178]                     invisible(muffled)
[16:06:44.178]                   }
[16:06:44.178]                   muffleCondition(cond)
[16:06:44.178]                 })
[16:06:44.178]             }))
[16:06:44.178]             future::FutureResult(value = ...future.value$value, 
[16:06:44.178]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.178]                   ...future.rng), globalenv = if (FALSE) 
[16:06:44.178]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:44.178]                     ...future.globalenv.names))
[16:06:44.178]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:44.178]         }, condition = base::local({
[16:06:44.178]             c <- base::c
[16:06:44.178]             inherits <- base::inherits
[16:06:44.178]             invokeRestart <- base::invokeRestart
[16:06:44.178]             length <- base::length
[16:06:44.178]             list <- base::list
[16:06:44.178]             seq.int <- base::seq.int
[16:06:44.178]             signalCondition <- base::signalCondition
[16:06:44.178]             sys.calls <- base::sys.calls
[16:06:44.178]             `[[` <- base::`[[`
[16:06:44.178]             `+` <- base::`+`
[16:06:44.178]             `<<-` <- base::`<<-`
[16:06:44.178]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:44.178]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:44.178]                   3L)]
[16:06:44.178]             }
[16:06:44.178]             function(cond) {
[16:06:44.178]                 is_error <- inherits(cond, "error")
[16:06:44.178]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:44.178]                   NULL)
[16:06:44.178]                 if (is_error) {
[16:06:44.178]                   sessionInformation <- function() {
[16:06:44.178]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:44.178]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:44.178]                       search = base::search(), system = base::Sys.info())
[16:06:44.178]                   }
[16:06:44.178]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.178]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:44.178]                     cond$call), session = sessionInformation(), 
[16:06:44.178]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:44.178]                   signalCondition(cond)
[16:06:44.178]                 }
[16:06:44.178]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:44.178]                 "immediateCondition"))) {
[16:06:44.178]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:44.178]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.178]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:44.178]                   if (TRUE && !signal) {
[16:06:44.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.178]                     {
[16:06:44.178]                       inherits <- base::inherits
[16:06:44.178]                       invokeRestart <- base::invokeRestart
[16:06:44.178]                       is.null <- base::is.null
[16:06:44.178]                       muffled <- FALSE
[16:06:44.178]                       if (inherits(cond, "message")) {
[16:06:44.178]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.178]                         if (muffled) 
[16:06:44.178]                           invokeRestart("muffleMessage")
[16:06:44.178]                       }
[16:06:44.178]                       else if (inherits(cond, "warning")) {
[16:06:44.178]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.178]                         if (muffled) 
[16:06:44.178]                           invokeRestart("muffleWarning")
[16:06:44.178]                       }
[16:06:44.178]                       else if (inherits(cond, "condition")) {
[16:06:44.178]                         if (!is.null(pattern)) {
[16:06:44.178]                           computeRestarts <- base::computeRestarts
[16:06:44.178]                           grepl <- base::grepl
[16:06:44.178]                           restarts <- computeRestarts(cond)
[16:06:44.178]                           for (restart in restarts) {
[16:06:44.178]                             name <- restart$name
[16:06:44.178]                             if (is.null(name)) 
[16:06:44.178]                               next
[16:06:44.178]                             if (!grepl(pattern, name)) 
[16:06:44.178]                               next
[16:06:44.178]                             invokeRestart(restart)
[16:06:44.178]                             muffled <- TRUE
[16:06:44.178]                             break
[16:06:44.178]                           }
[16:06:44.178]                         }
[16:06:44.178]                       }
[16:06:44.178]                       invisible(muffled)
[16:06:44.178]                     }
[16:06:44.178]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.178]                   }
[16:06:44.178]                 }
[16:06:44.178]                 else {
[16:06:44.178]                   if (TRUE) {
[16:06:44.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.178]                     {
[16:06:44.178]                       inherits <- base::inherits
[16:06:44.178]                       invokeRestart <- base::invokeRestart
[16:06:44.178]                       is.null <- base::is.null
[16:06:44.178]                       muffled <- FALSE
[16:06:44.178]                       if (inherits(cond, "message")) {
[16:06:44.178]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.178]                         if (muffled) 
[16:06:44.178]                           invokeRestart("muffleMessage")
[16:06:44.178]                       }
[16:06:44.178]                       else if (inherits(cond, "warning")) {
[16:06:44.178]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.178]                         if (muffled) 
[16:06:44.178]                           invokeRestart("muffleWarning")
[16:06:44.178]                       }
[16:06:44.178]                       else if (inherits(cond, "condition")) {
[16:06:44.178]                         if (!is.null(pattern)) {
[16:06:44.178]                           computeRestarts <- base::computeRestarts
[16:06:44.178]                           grepl <- base::grepl
[16:06:44.178]                           restarts <- computeRestarts(cond)
[16:06:44.178]                           for (restart in restarts) {
[16:06:44.178]                             name <- restart$name
[16:06:44.178]                             if (is.null(name)) 
[16:06:44.178]                               next
[16:06:44.178]                             if (!grepl(pattern, name)) 
[16:06:44.178]                               next
[16:06:44.178]                             invokeRestart(restart)
[16:06:44.178]                             muffled <- TRUE
[16:06:44.178]                             break
[16:06:44.178]                           }
[16:06:44.178]                         }
[16:06:44.178]                       }
[16:06:44.178]                       invisible(muffled)
[16:06:44.178]                     }
[16:06:44.178]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.178]                   }
[16:06:44.178]                 }
[16:06:44.178]             }
[16:06:44.178]         }))
[16:06:44.178]     }, error = function(ex) {
[16:06:44.178]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:44.178]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.178]                 ...future.rng), started = ...future.startTime, 
[16:06:44.178]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:44.178]             version = "1.8"), class = "FutureResult")
[16:06:44.178]     }, finally = {
[16:06:44.178]         if (!identical(...future.workdir, getwd())) 
[16:06:44.178]             setwd(...future.workdir)
[16:06:44.178]         {
[16:06:44.178]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:44.178]                 ...future.oldOptions$nwarnings <- NULL
[16:06:44.178]             }
[16:06:44.178]             base::options(...future.oldOptions)
[16:06:44.178]             if (.Platform$OS.type == "windows") {
[16:06:44.178]                 old_names <- names(...future.oldEnvVars)
[16:06:44.178]                 envs <- base::Sys.getenv()
[16:06:44.178]                 names <- names(envs)
[16:06:44.178]                 common <- intersect(names, old_names)
[16:06:44.178]                 added <- setdiff(names, old_names)
[16:06:44.178]                 removed <- setdiff(old_names, names)
[16:06:44.178]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:44.178]                   envs[common]]
[16:06:44.178]                 NAMES <- toupper(changed)
[16:06:44.178]                 args <- list()
[16:06:44.178]                 for (kk in seq_along(NAMES)) {
[16:06:44.178]                   name <- changed[[kk]]
[16:06:44.178]                   NAME <- NAMES[[kk]]
[16:06:44.178]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.178]                     next
[16:06:44.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.178]                 }
[16:06:44.178]                 NAMES <- toupper(added)
[16:06:44.178]                 for (kk in seq_along(NAMES)) {
[16:06:44.178]                   name <- added[[kk]]
[16:06:44.178]                   NAME <- NAMES[[kk]]
[16:06:44.178]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.178]                     next
[16:06:44.178]                   args[[name]] <- ""
[16:06:44.178]                 }
[16:06:44.178]                 NAMES <- toupper(removed)
[16:06:44.178]                 for (kk in seq_along(NAMES)) {
[16:06:44.178]                   name <- removed[[kk]]
[16:06:44.178]                   NAME <- NAMES[[kk]]
[16:06:44.178]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.178]                     next
[16:06:44.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.178]                 }
[16:06:44.178]                 if (length(args) > 0) 
[16:06:44.178]                   base::do.call(base::Sys.setenv, args = args)
[16:06:44.178]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:44.178]             }
[16:06:44.178]             else {
[16:06:44.178]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:44.178]             }
[16:06:44.178]             {
[16:06:44.178]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:44.178]                   0L) {
[16:06:44.178]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:44.178]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:44.178]                   base::options(opts)
[16:06:44.178]                 }
[16:06:44.178]                 {
[16:06:44.178]                   {
[16:06:44.178]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:44.178]                     NULL
[16:06:44.178]                   }
[16:06:44.178]                   options(future.plan = NULL)
[16:06:44.178]                   if (is.na(NA_character_)) 
[16:06:44.178]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.178]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:44.178]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:06:44.178]                     envir = parent.frame()) 
[16:06:44.178]                   {
[16:06:44.178]                     default_workers <- missing(workers)
[16:06:44.178]                     if (is.function(workers)) 
[16:06:44.178]                       workers <- workers()
[16:06:44.178]                     workers <- structure(as.integer(workers), 
[16:06:44.178]                       class = class(workers))
[16:06:44.178]                     stop_if_not(is.finite(workers), workers >= 
[16:06:44.178]                       1L)
[16:06:44.178]                     if ((workers == 1L && !inherits(workers, 
[16:06:44.178]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:06:44.178]                       if (default_workers) 
[16:06:44.178]                         supportsMulticore(warn = TRUE)
[16:06:44.178]                       return(sequential(..., envir = envir))
[16:06:44.178]                     }
[16:06:44.178]                     oopts <- options(mc.cores = workers)
[16:06:44.178]                     on.exit(options(oopts))
[16:06:44.178]                     future <- MulticoreFuture(..., workers = workers, 
[16:06:44.178]                       envir = envir)
[16:06:44.178]                     if (!future$lazy) 
[16:06:44.178]                       future <- run(future)
[16:06:44.178]                     invisible(future)
[16:06:44.178]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:44.178]                 }
[16:06:44.178]             }
[16:06:44.178]         }
[16:06:44.178]     })
[16:06:44.178]     if (TRUE) {
[16:06:44.178]         base::sink(type = "output", split = FALSE)
[16:06:44.178]         if (FALSE) {
[16:06:44.178]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:44.178]         }
[16:06:44.178]         else {
[16:06:44.178]             ...future.result["stdout"] <- base::list(NULL)
[16:06:44.178]         }
[16:06:44.178]         base::close(...future.stdout)
[16:06:44.178]         ...future.stdout <- NULL
[16:06:44.178]     }
[16:06:44.178]     ...future.result$conditions <- ...future.conditions
[16:06:44.178]     ...future.result$finished <- base::Sys.time()
[16:06:44.178]     ...future.result
[16:06:44.178] }
[16:06:44.181] requestCore(): workers = 2
[16:06:44.182] MulticoreFuture started
[16:06:44.183] - Launch lazy future ... done
[16:06:44.183] run() for ‘MulticoreFuture’ ... done
[16:06:44.184] result() for MulticoreFuture ...
[16:06:44.184] plan(): Setting new future strategy stack:
[16:06:44.184] List of future strategies:
[16:06:44.184] 1. sequential:
[16:06:44.184]    - args: function (..., envir = parent.frame())
[16:06:44.184]    - tweaked: FALSE
[16:06:44.184]    - call: NULL
[16:06:44.185] plan(): nbrOfWorkers() = 1
[16:06:44.188] plan(): Setting new future strategy stack:
[16:06:44.188] List of future strategies:
[16:06:44.188] 1. multicore:
[16:06:44.188]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:06:44.188]    - tweaked: FALSE
[16:06:44.188]    - call: plan(strategy)
[16:06:44.193] plan(): nbrOfWorkers() = 2
[16:06:44.194] result() for MulticoreFuture ...
[16:06:44.194] result() for MulticoreFuture ... done
[16:06:44.194] result() for MulticoreFuture ... done
[16:06:44.194] result() for MulticoreFuture ...
[16:06:44.194] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[16:06:44.195] getGlobalsAndPackages() ...
[16:06:44.195] Searching for globals...
[16:06:44.196] - globals found: [1] ‘print’
[16:06:44.196] Searching for globals ... DONE
[16:06:44.196] Resolving globals: FALSE
[16:06:44.196] 
[16:06:44.196] 
[16:06:44.196] getGlobalsAndPackages() ... DONE
[16:06:44.197] run() for ‘Future’ ...
[16:06:44.197] - state: ‘created’
[16:06:44.197] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:06:44.201] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:44.201] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:06:44.201]   - Field: ‘label’
[16:06:44.202]   - Field: ‘local’
[16:06:44.202]   - Field: ‘owner’
[16:06:44.202]   - Field: ‘envir’
[16:06:44.202]   - Field: ‘workers’
[16:06:44.202]   - Field: ‘packages’
[16:06:44.202]   - Field: ‘gc’
[16:06:44.202]   - Field: ‘job’
[16:06:44.202]   - Field: ‘conditions’
[16:06:44.203]   - Field: ‘expr’
[16:06:44.203]   - Field: ‘uuid’
[16:06:44.203]   - Field: ‘seed’
[16:06:44.203]   - Field: ‘version’
[16:06:44.203]   - Field: ‘result’
[16:06:44.203]   - Field: ‘asynchronous’
[16:06:44.203]   - Field: ‘calls’
[16:06:44.203]   - Field: ‘globals’
[16:06:44.203]   - Field: ‘stdout’
[16:06:44.204]   - Field: ‘earlySignal’
[16:06:44.204]   - Field: ‘lazy’
[16:06:44.204]   - Field: ‘state’
[16:06:44.204] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:06:44.204] - Launch lazy future ...
[16:06:44.204] Packages needed by the future expression (n = 0): <none>
[16:06:44.204] Packages needed by future strategies (n = 0): <none>
[16:06:44.205] {
[16:06:44.205]     {
[16:06:44.205]         {
[16:06:44.205]             ...future.startTime <- base::Sys.time()
[16:06:44.205]             {
[16:06:44.205]                 {
[16:06:44.205]                   {
[16:06:44.205]                     {
[16:06:44.205]                       base::local({
[16:06:44.205]                         has_future <- base::requireNamespace("future", 
[16:06:44.205]                           quietly = TRUE)
[16:06:44.205]                         if (has_future) {
[16:06:44.205]                           ns <- base::getNamespace("future")
[16:06:44.205]                           version <- ns[[".package"]][["version"]]
[16:06:44.205]                           if (is.null(version)) 
[16:06:44.205]                             version <- utils::packageVersion("future")
[16:06:44.205]                         }
[16:06:44.205]                         else {
[16:06:44.205]                           version <- NULL
[16:06:44.205]                         }
[16:06:44.205]                         if (!has_future || version < "1.8.0") {
[16:06:44.205]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:44.205]                             "", base::R.version$version.string), 
[16:06:44.205]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:44.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:44.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:44.205]                               "release", "version")], collapse = " "), 
[16:06:44.205]                             hostname = base::Sys.info()[["nodename"]])
[16:06:44.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:44.205]                             info)
[16:06:44.205]                           info <- base::paste(info, collapse = "; ")
[16:06:44.205]                           if (!has_future) {
[16:06:44.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:44.205]                               info)
[16:06:44.205]                           }
[16:06:44.205]                           else {
[16:06:44.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:44.205]                               info, version)
[16:06:44.205]                           }
[16:06:44.205]                           base::stop(msg)
[16:06:44.205]                         }
[16:06:44.205]                       })
[16:06:44.205]                     }
[16:06:44.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:44.205]                     base::options(mc.cores = 1L)
[16:06:44.205]                   }
[16:06:44.205]                   options(future.plan = NULL)
[16:06:44.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:44.205]                 }
[16:06:44.205]                 ...future.workdir <- getwd()
[16:06:44.205]             }
[16:06:44.205]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:44.205]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:44.205]         }
[16:06:44.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:44.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:44.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:44.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:44.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:44.205]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:44.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:44.205]             base::names(...future.oldOptions))
[16:06:44.205]     }
[16:06:44.205]     if (FALSE) {
[16:06:44.205]     }
[16:06:44.205]     else {
[16:06:44.205]         if (TRUE) {
[16:06:44.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:44.205]                 open = "w")
[16:06:44.205]         }
[16:06:44.205]         else {
[16:06:44.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:44.205]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:44.205]         }
[16:06:44.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:44.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:44.205]             base::sink(type = "output", split = FALSE)
[16:06:44.205]             base::close(...future.stdout)
[16:06:44.205]         }, add = TRUE)
[16:06:44.205]     }
[16:06:44.205]     ...future.frame <- base::sys.nframe()
[16:06:44.205]     ...future.conditions <- base::list()
[16:06:44.205]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:44.205]     if (FALSE) {
[16:06:44.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:44.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:44.205]     }
[16:06:44.205]     ...future.result <- base::tryCatch({
[16:06:44.205]         base::withCallingHandlers({
[16:06:44.205]             ...future.value <- base::withVisible(base::local({
[16:06:44.205]                 withCallingHandlers({
[16:06:44.205]                   print(42)
[16:06:44.205]                 }, immediateCondition = function(cond) {
[16:06:44.205]                   save_rds <- function (object, pathname, ...) 
[16:06:44.205]                   {
[16:06:44.205]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:06:44.205]                     if (file_test("-f", pathname_tmp)) {
[16:06:44.205]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.205]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:06:44.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.205]                         fi_tmp[["mtime"]])
[16:06:44.205]                     }
[16:06:44.205]                     tryCatch({
[16:06:44.205]                       saveRDS(object, file = pathname_tmp, ...)
[16:06:44.205]                     }, error = function(ex) {
[16:06:44.205]                       msg <- conditionMessage(ex)
[16:06:44.205]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.205]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:06:44.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.205]                         fi_tmp[["mtime"]], msg)
[16:06:44.205]                       ex$message <- msg
[16:06:44.205]                       stop(ex)
[16:06:44.205]                     })
[16:06:44.205]                     stopifnot(file_test("-f", pathname_tmp))
[16:06:44.205]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:06:44.205]                     if (!res || file_test("-f", pathname_tmp)) {
[16:06:44.205]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.205]                       fi <- file.info(pathname)
[16:06:44.205]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:06:44.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.205]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:06:44.205]                         fi[["size"]], fi[["mtime"]])
[16:06:44.205]                       stop(msg)
[16:06:44.205]                     }
[16:06:44.205]                     invisible(pathname)
[16:06:44.205]                   }
[16:06:44.205]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:06:44.205]                     rootPath = tempdir()) 
[16:06:44.205]                   {
[16:06:44.205]                     obj <- list(time = Sys.time(), condition = cond)
[16:06:44.205]                     file <- tempfile(pattern = class(cond)[1], 
[16:06:44.205]                       tmpdir = path, fileext = ".rds")
[16:06:44.205]                     save_rds(obj, file)
[16:06:44.205]                   }
[16:06:44.205]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6lYtbx/.future/immediateConditions")
[16:06:44.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.205]                   {
[16:06:44.205]                     inherits <- base::inherits
[16:06:44.205]                     invokeRestart <- base::invokeRestart
[16:06:44.205]                     is.null <- base::is.null
[16:06:44.205]                     muffled <- FALSE
[16:06:44.205]                     if (inherits(cond, "message")) {
[16:06:44.205]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:44.205]                       if (muffled) 
[16:06:44.205]                         invokeRestart("muffleMessage")
[16:06:44.205]                     }
[16:06:44.205]                     else if (inherits(cond, "warning")) {
[16:06:44.205]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:44.205]                       if (muffled) 
[16:06:44.205]                         invokeRestart("muffleWarning")
[16:06:44.205]                     }
[16:06:44.205]                     else if (inherits(cond, "condition")) {
[16:06:44.205]                       if (!is.null(pattern)) {
[16:06:44.205]                         computeRestarts <- base::computeRestarts
[16:06:44.205]                         grepl <- base::grepl
[16:06:44.205]                         restarts <- computeRestarts(cond)
[16:06:44.205]                         for (restart in restarts) {
[16:06:44.205]                           name <- restart$name
[16:06:44.205]                           if (is.null(name)) 
[16:06:44.205]                             next
[16:06:44.205]                           if (!grepl(pattern, name)) 
[16:06:44.205]                             next
[16:06:44.205]                           invokeRestart(restart)
[16:06:44.205]                           muffled <- TRUE
[16:06:44.205]                           break
[16:06:44.205]                         }
[16:06:44.205]                       }
[16:06:44.205]                     }
[16:06:44.205]                     invisible(muffled)
[16:06:44.205]                   }
[16:06:44.205]                   muffleCondition(cond)
[16:06:44.205]                 })
[16:06:44.205]             }))
[16:06:44.205]             future::FutureResult(value = ...future.value$value, 
[16:06:44.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.205]                   ...future.rng), globalenv = if (FALSE) 
[16:06:44.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:44.205]                     ...future.globalenv.names))
[16:06:44.205]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:44.205]         }, condition = base::local({
[16:06:44.205]             c <- base::c
[16:06:44.205]             inherits <- base::inherits
[16:06:44.205]             invokeRestart <- base::invokeRestart
[16:06:44.205]             length <- base::length
[16:06:44.205]             list <- base::list
[16:06:44.205]             seq.int <- base::seq.int
[16:06:44.205]             signalCondition <- base::signalCondition
[16:06:44.205]             sys.calls <- base::sys.calls
[16:06:44.205]             `[[` <- base::`[[`
[16:06:44.205]             `+` <- base::`+`
[16:06:44.205]             `<<-` <- base::`<<-`
[16:06:44.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:44.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:44.205]                   3L)]
[16:06:44.205]             }
[16:06:44.205]             function(cond) {
[16:06:44.205]                 is_error <- inherits(cond, "error")
[16:06:44.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:44.205]                   NULL)
[16:06:44.205]                 if (is_error) {
[16:06:44.205]                   sessionInformation <- function() {
[16:06:44.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:44.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:44.205]                       search = base::search(), system = base::Sys.info())
[16:06:44.205]                   }
[16:06:44.205]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:44.205]                     cond$call), session = sessionInformation(), 
[16:06:44.205]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:44.205]                   signalCondition(cond)
[16:06:44.205]                 }
[16:06:44.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:44.205]                 "immediateCondition"))) {
[16:06:44.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:44.205]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:44.205]                   if (TRUE && !signal) {
[16:06:44.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.205]                     {
[16:06:44.205]                       inherits <- base::inherits
[16:06:44.205]                       invokeRestart <- base::invokeRestart
[16:06:44.205]                       is.null <- base::is.null
[16:06:44.205]                       muffled <- FALSE
[16:06:44.205]                       if (inherits(cond, "message")) {
[16:06:44.205]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.205]                         if (muffled) 
[16:06:44.205]                           invokeRestart("muffleMessage")
[16:06:44.205]                       }
[16:06:44.205]                       else if (inherits(cond, "warning")) {
[16:06:44.205]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.205]                         if (muffled) 
[16:06:44.205]                           invokeRestart("muffleWarning")
[16:06:44.205]                       }
[16:06:44.205]                       else if (inherits(cond, "condition")) {
[16:06:44.205]                         if (!is.null(pattern)) {
[16:06:44.205]                           computeRestarts <- base::computeRestarts
[16:06:44.205]                           grepl <- base::grepl
[16:06:44.205]                           restarts <- computeRestarts(cond)
[16:06:44.205]                           for (restart in restarts) {
[16:06:44.205]                             name <- restart$name
[16:06:44.205]                             if (is.null(name)) 
[16:06:44.205]                               next
[16:06:44.205]                             if (!grepl(pattern, name)) 
[16:06:44.205]                               next
[16:06:44.205]                             invokeRestart(restart)
[16:06:44.205]                             muffled <- TRUE
[16:06:44.205]                             break
[16:06:44.205]                           }
[16:06:44.205]                         }
[16:06:44.205]                       }
[16:06:44.205]                       invisible(muffled)
[16:06:44.205]                     }
[16:06:44.205]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.205]                   }
[16:06:44.205]                 }
[16:06:44.205]                 else {
[16:06:44.205]                   if (TRUE) {
[16:06:44.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.205]                     {
[16:06:44.205]                       inherits <- base::inherits
[16:06:44.205]                       invokeRestart <- base::invokeRestart
[16:06:44.205]                       is.null <- base::is.null
[16:06:44.205]                       muffled <- FALSE
[16:06:44.205]                       if (inherits(cond, "message")) {
[16:06:44.205]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.205]                         if (muffled) 
[16:06:44.205]                           invokeRestart("muffleMessage")
[16:06:44.205]                       }
[16:06:44.205]                       else if (inherits(cond, "warning")) {
[16:06:44.205]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.205]                         if (muffled) 
[16:06:44.205]                           invokeRestart("muffleWarning")
[16:06:44.205]                       }
[16:06:44.205]                       else if (inherits(cond, "condition")) {
[16:06:44.205]                         if (!is.null(pattern)) {
[16:06:44.205]                           computeRestarts <- base::computeRestarts
[16:06:44.205]                           grepl <- base::grepl
[16:06:44.205]                           restarts <- computeRestarts(cond)
[16:06:44.205]                           for (restart in restarts) {
[16:06:44.205]                             name <- restart$name
[16:06:44.205]                             if (is.null(name)) 
[16:06:44.205]                               next
[16:06:44.205]                             if (!grepl(pattern, name)) 
[16:06:44.205]                               next
[16:06:44.205]                             invokeRestart(restart)
[16:06:44.205]                             muffled <- TRUE
[16:06:44.205]                             break
[16:06:44.205]                           }
[16:06:44.205]                         }
[16:06:44.205]                       }
[16:06:44.205]                       invisible(muffled)
[16:06:44.205]                     }
[16:06:44.205]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.205]                   }
[16:06:44.205]                 }
[16:06:44.205]             }
[16:06:44.205]         }))
[16:06:44.205]     }, error = function(ex) {
[16:06:44.205]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:44.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.205]                 ...future.rng), started = ...future.startTime, 
[16:06:44.205]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:44.205]             version = "1.8"), class = "FutureResult")
[16:06:44.205]     }, finally = {
[16:06:44.205]         if (!identical(...future.workdir, getwd())) 
[16:06:44.205]             setwd(...future.workdir)
[16:06:44.205]         {
[16:06:44.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:44.205]                 ...future.oldOptions$nwarnings <- NULL
[16:06:44.205]             }
[16:06:44.205]             base::options(...future.oldOptions)
[16:06:44.205]             if (.Platform$OS.type == "windows") {
[16:06:44.205]                 old_names <- names(...future.oldEnvVars)
[16:06:44.205]                 envs <- base::Sys.getenv()
[16:06:44.205]                 names <- names(envs)
[16:06:44.205]                 common <- intersect(names, old_names)
[16:06:44.205]                 added <- setdiff(names, old_names)
[16:06:44.205]                 removed <- setdiff(old_names, names)
[16:06:44.205]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:44.205]                   envs[common]]
[16:06:44.205]                 NAMES <- toupper(changed)
[16:06:44.205]                 args <- list()
[16:06:44.205]                 for (kk in seq_along(NAMES)) {
[16:06:44.205]                   name <- changed[[kk]]
[16:06:44.205]                   NAME <- NAMES[[kk]]
[16:06:44.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.205]                     next
[16:06:44.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.205]                 }
[16:06:44.205]                 NAMES <- toupper(added)
[16:06:44.205]                 for (kk in seq_along(NAMES)) {
[16:06:44.205]                   name <- added[[kk]]
[16:06:44.205]                   NAME <- NAMES[[kk]]
[16:06:44.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.205]                     next
[16:06:44.205]                   args[[name]] <- ""
[16:06:44.205]                 }
[16:06:44.205]                 NAMES <- toupper(removed)
[16:06:44.205]                 for (kk in seq_along(NAMES)) {
[16:06:44.205]                   name <- removed[[kk]]
[16:06:44.205]                   NAME <- NAMES[[kk]]
[16:06:44.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.205]                     next
[16:06:44.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.205]                 }
[16:06:44.205]                 if (length(args) > 0) 
[16:06:44.205]                   base::do.call(base::Sys.setenv, args = args)
[16:06:44.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:44.205]             }
[16:06:44.205]             else {
[16:06:44.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:44.205]             }
[16:06:44.205]             {
[16:06:44.205]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:44.205]                   0L) {
[16:06:44.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:44.205]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:44.205]                   base::options(opts)
[16:06:44.205]                 }
[16:06:44.205]                 {
[16:06:44.205]                   {
[16:06:44.205]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:44.205]                     NULL
[16:06:44.205]                   }
[16:06:44.205]                   options(future.plan = NULL)
[16:06:44.205]                   if (is.na(NA_character_)) 
[16:06:44.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:44.205]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:06:44.205]                     envir = parent.frame()) 
[16:06:44.205]                   {
[16:06:44.205]                     default_workers <- missing(workers)
[16:06:44.205]                     if (is.function(workers)) 
[16:06:44.205]                       workers <- workers()
[16:06:44.205]                     workers <- structure(as.integer(workers), 
[16:06:44.205]                       class = class(workers))
[16:06:44.205]                     stop_if_not(is.finite(workers), workers >= 
[16:06:44.205]                       1L)
[16:06:44.205]                     if ((workers == 1L && !inherits(workers, 
[16:06:44.205]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:06:44.205]                       if (default_workers) 
[16:06:44.205]                         supportsMulticore(warn = TRUE)
[16:06:44.205]                       return(sequential(..., envir = envir))
[16:06:44.205]                     }
[16:06:44.205]                     oopts <- options(mc.cores = workers)
[16:06:44.205]                     on.exit(options(oopts))
[16:06:44.205]                     future <- MulticoreFuture(..., workers = workers, 
[16:06:44.205]                       envir = envir)
[16:06:44.205]                     if (!future$lazy) 
[16:06:44.205]                       future <- run(future)
[16:06:44.205]                     invisible(future)
[16:06:44.205]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:44.205]                 }
[16:06:44.205]             }
[16:06:44.205]         }
[16:06:44.205]     })
[16:06:44.205]     if (TRUE) {
[16:06:44.205]         base::sink(type = "output", split = FALSE)
[16:06:44.205]         if (TRUE) {
[16:06:44.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:44.205]         }
[16:06:44.205]         else {
[16:06:44.205]             ...future.result["stdout"] <- base::list(NULL)
[16:06:44.205]         }
[16:06:44.205]         base::close(...future.stdout)
[16:06:44.205]         ...future.stdout <- NULL
[16:06:44.205]     }
[16:06:44.205]     ...future.result$conditions <- ...future.conditions
[16:06:44.205]     ...future.result$finished <- base::Sys.time()
[16:06:44.205]     ...future.result
[16:06:44.205] }
[16:06:44.208] requestCore(): workers = 2
[16:06:44.209] MulticoreFuture started
[16:06:44.210] - Launch lazy future ... done
[16:06:44.210] run() for ‘MulticoreFuture’ ... done
[16:06:44.210] result() for MulticoreFuture ...
[16:06:44.210] plan(): Setting new future strategy stack:
[16:06:44.211] List of future strategies:
[16:06:44.211] 1. sequential:
[16:06:44.211]    - args: function (..., envir = parent.frame())
[16:06:44.211]    - tweaked: FALSE
[16:06:44.211]    - call: NULL
[16:06:44.212] plan(): nbrOfWorkers() = 1
[16:06:44.213] plan(): Setting new future strategy stack:
[16:06:44.214] List of future strategies:
[16:06:44.214] 1. multicore:
[16:06:44.214]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:06:44.214]    - tweaked: FALSE
[16:06:44.214]    - call: plan(strategy)
[16:06:44.218] plan(): nbrOfWorkers() = 2
[16:06:44.219] result() for MulticoreFuture ...
[16:06:44.219] result() for MulticoreFuture ... done
[16:06:44.220] result() for MulticoreFuture ... done
[16:06:44.220] result() for MulticoreFuture ...
[16:06:44.220] result() for MulticoreFuture ... done
[16:06:44.220] result() for MulticoreFuture ...
[16:06:44.220] result() for MulticoreFuture ... done
[1] 42
[16:06:44.221] result() for MulticoreFuture ...
[16:06:44.221] result() for MulticoreFuture ... done
- stdout = NA
[16:06:44.221] getGlobalsAndPackages() ...
[16:06:44.221] Searching for globals...
[16:06:44.228] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:44.228] Searching for globals ... DONE
[16:06:44.228] Resolving globals: FALSE
[16:06:44.229] 
[16:06:44.229] - packages: [1] ‘utils’
[16:06:44.229] getGlobalsAndPackages() ... DONE
[16:06:44.230] run() for ‘Future’ ...
[16:06:44.230] - state: ‘created’
[16:06:44.230] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:06:44.234] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:44.234] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:06:44.234]   - Field: ‘label’
[16:06:44.234]   - Field: ‘local’
[16:06:44.234]   - Field: ‘owner’
[16:06:44.234]   - Field: ‘envir’
[16:06:44.235]   - Field: ‘workers’
[16:06:44.235]   - Field: ‘packages’
[16:06:44.235]   - Field: ‘gc’
[16:06:44.235]   - Field: ‘job’
[16:06:44.235]   - Field: ‘conditions’
[16:06:44.235]   - Field: ‘expr’
[16:06:44.235]   - Field: ‘uuid’
[16:06:44.235]   - Field: ‘seed’
[16:06:44.236]   - Field: ‘version’
[16:06:44.236]   - Field: ‘result’
[16:06:44.236]   - Field: ‘asynchronous’
[16:06:44.236]   - Field: ‘calls’
[16:06:44.236]   - Field: ‘globals’
[16:06:44.236]   - Field: ‘stdout’
[16:06:44.236]   - Field: ‘earlySignal’
[16:06:44.236]   - Field: ‘lazy’
[16:06:44.236]   - Field: ‘state’
[16:06:44.237] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:06:44.237] - Launch lazy future ...
[16:06:44.237] Packages needed by the future expression (n = 1): ‘utils’
[16:06:44.237] Packages needed by future strategies (n = 0): <none>
[16:06:44.238] {
[16:06:44.238]     {
[16:06:44.238]         {
[16:06:44.238]             ...future.startTime <- base::Sys.time()
[16:06:44.238]             {
[16:06:44.238]                 {
[16:06:44.238]                   {
[16:06:44.238]                     {
[16:06:44.238]                       {
[16:06:44.238]                         base::local({
[16:06:44.238]                           has_future <- base::requireNamespace("future", 
[16:06:44.238]                             quietly = TRUE)
[16:06:44.238]                           if (has_future) {
[16:06:44.238]                             ns <- base::getNamespace("future")
[16:06:44.238]                             version <- ns[[".package"]][["version"]]
[16:06:44.238]                             if (is.null(version)) 
[16:06:44.238]                               version <- utils::packageVersion("future")
[16:06:44.238]                           }
[16:06:44.238]                           else {
[16:06:44.238]                             version <- NULL
[16:06:44.238]                           }
[16:06:44.238]                           if (!has_future || version < "1.8.0") {
[16:06:44.238]                             info <- base::c(r_version = base::gsub("R version ", 
[16:06:44.238]                               "", base::R.version$version.string), 
[16:06:44.238]                               platform = base::sprintf("%s (%s-bit)", 
[16:06:44.238]                                 base::R.version$platform, 8 * 
[16:06:44.238]                                   base::.Machine$sizeof.pointer), 
[16:06:44.238]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:44.238]                                 "release", "version")], collapse = " "), 
[16:06:44.238]                               hostname = base::Sys.info()[["nodename"]])
[16:06:44.238]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:06:44.238]                               info)
[16:06:44.238]                             info <- base::paste(info, collapse = "; ")
[16:06:44.238]                             if (!has_future) {
[16:06:44.238]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:44.238]                                 info)
[16:06:44.238]                             }
[16:06:44.238]                             else {
[16:06:44.238]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:44.238]                                 info, version)
[16:06:44.238]                             }
[16:06:44.238]                             base::stop(msg)
[16:06:44.238]                           }
[16:06:44.238]                         })
[16:06:44.238]                       }
[16:06:44.238]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:44.238]                       base::options(mc.cores = 1L)
[16:06:44.238]                     }
[16:06:44.238]                     base::local({
[16:06:44.238]                       for (pkg in "utils") {
[16:06:44.238]                         base::loadNamespace(pkg)
[16:06:44.238]                         base::library(pkg, character.only = TRUE)
[16:06:44.238]                       }
[16:06:44.238]                     })
[16:06:44.238]                   }
[16:06:44.238]                   options(future.plan = NULL)
[16:06:44.238]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.238]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:44.238]                 }
[16:06:44.238]                 ...future.workdir <- getwd()
[16:06:44.238]             }
[16:06:44.238]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:44.238]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:44.238]         }
[16:06:44.238]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:44.238]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:44.238]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:44.238]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:44.238]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:44.238]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:44.238]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:44.238]             base::names(...future.oldOptions))
[16:06:44.238]     }
[16:06:44.238]     if (TRUE) {
[16:06:44.238]     }
[16:06:44.238]     else {
[16:06:44.238]         if (NA) {
[16:06:44.238]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:44.238]                 open = "w")
[16:06:44.238]         }
[16:06:44.238]         else {
[16:06:44.238]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:44.238]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:44.238]         }
[16:06:44.238]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:44.238]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:44.238]             base::sink(type = "output", split = FALSE)
[16:06:44.238]             base::close(...future.stdout)
[16:06:44.238]         }, add = TRUE)
[16:06:44.238]     }
[16:06:44.238]     ...future.frame <- base::sys.nframe()
[16:06:44.238]     ...future.conditions <- base::list()
[16:06:44.238]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:44.238]     if (FALSE) {
[16:06:44.238]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:44.238]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:44.238]     }
[16:06:44.238]     ...future.result <- base::tryCatch({
[16:06:44.238]         base::withCallingHandlers({
[16:06:44.238]             ...future.value <- base::withVisible(base::local({
[16:06:44.238]                 withCallingHandlers({
[16:06:44.238]                   {
[16:06:44.238]                     print(1:50)
[16:06:44.238]                     str(1:50)
[16:06:44.238]                     cat(letters, sep = "-")
[16:06:44.238]                     cat(1:6, collapse = "\n")
[16:06:44.238]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:44.238]                     42L
[16:06:44.238]                   }
[16:06:44.238]                 }, immediateCondition = function(cond) {
[16:06:44.238]                   save_rds <- function (object, pathname, ...) 
[16:06:44.238]                   {
[16:06:44.238]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:06:44.238]                     if (file_test("-f", pathname_tmp)) {
[16:06:44.238]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.238]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:06:44.238]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.238]                         fi_tmp[["mtime"]])
[16:06:44.238]                     }
[16:06:44.238]                     tryCatch({
[16:06:44.238]                       saveRDS(object, file = pathname_tmp, ...)
[16:06:44.238]                     }, error = function(ex) {
[16:06:44.238]                       msg <- conditionMessage(ex)
[16:06:44.238]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.238]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:06:44.238]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.238]                         fi_tmp[["mtime"]], msg)
[16:06:44.238]                       ex$message <- msg
[16:06:44.238]                       stop(ex)
[16:06:44.238]                     })
[16:06:44.238]                     stopifnot(file_test("-f", pathname_tmp))
[16:06:44.238]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:06:44.238]                     if (!res || file_test("-f", pathname_tmp)) {
[16:06:44.238]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.238]                       fi <- file.info(pathname)
[16:06:44.238]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:06:44.238]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.238]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:06:44.238]                         fi[["size"]], fi[["mtime"]])
[16:06:44.238]                       stop(msg)
[16:06:44.238]                     }
[16:06:44.238]                     invisible(pathname)
[16:06:44.238]                   }
[16:06:44.238]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:06:44.238]                     rootPath = tempdir()) 
[16:06:44.238]                   {
[16:06:44.238]                     obj <- list(time = Sys.time(), condition = cond)
[16:06:44.238]                     file <- tempfile(pattern = class(cond)[1], 
[16:06:44.238]                       tmpdir = path, fileext = ".rds")
[16:06:44.238]                     save_rds(obj, file)
[16:06:44.238]                   }
[16:06:44.238]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6lYtbx/.future/immediateConditions")
[16:06:44.238]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.238]                   {
[16:06:44.238]                     inherits <- base::inherits
[16:06:44.238]                     invokeRestart <- base::invokeRestart
[16:06:44.238]                     is.null <- base::is.null
[16:06:44.238]                     muffled <- FALSE
[16:06:44.238]                     if (inherits(cond, "message")) {
[16:06:44.238]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:44.238]                       if (muffled) 
[16:06:44.238]                         invokeRestart("muffleMessage")
[16:06:44.238]                     }
[16:06:44.238]                     else if (inherits(cond, "warning")) {
[16:06:44.238]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:44.238]                       if (muffled) 
[16:06:44.238]                         invokeRestart("muffleWarning")
[16:06:44.238]                     }
[16:06:44.238]                     else if (inherits(cond, "condition")) {
[16:06:44.238]                       if (!is.null(pattern)) {
[16:06:44.238]                         computeRestarts <- base::computeRestarts
[16:06:44.238]                         grepl <- base::grepl
[16:06:44.238]                         restarts <- computeRestarts(cond)
[16:06:44.238]                         for (restart in restarts) {
[16:06:44.238]                           name <- restart$name
[16:06:44.238]                           if (is.null(name)) 
[16:06:44.238]                             next
[16:06:44.238]                           if (!grepl(pattern, name)) 
[16:06:44.238]                             next
[16:06:44.238]                           invokeRestart(restart)
[16:06:44.238]                           muffled <- TRUE
[16:06:44.238]                           break
[16:06:44.238]                         }
[16:06:44.238]                       }
[16:06:44.238]                     }
[16:06:44.238]                     invisible(muffled)
[16:06:44.238]                   }
[16:06:44.238]                   muffleCondition(cond)
[16:06:44.238]                 })
[16:06:44.238]             }))
[16:06:44.238]             future::FutureResult(value = ...future.value$value, 
[16:06:44.238]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.238]                   ...future.rng), globalenv = if (FALSE) 
[16:06:44.238]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:44.238]                     ...future.globalenv.names))
[16:06:44.238]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:44.238]         }, condition = base::local({
[16:06:44.238]             c <- base::c
[16:06:44.238]             inherits <- base::inherits
[16:06:44.238]             invokeRestart <- base::invokeRestart
[16:06:44.238]             length <- base::length
[16:06:44.238]             list <- base::list
[16:06:44.238]             seq.int <- base::seq.int
[16:06:44.238]             signalCondition <- base::signalCondition
[16:06:44.238]             sys.calls <- base::sys.calls
[16:06:44.238]             `[[` <- base::`[[`
[16:06:44.238]             `+` <- base::`+`
[16:06:44.238]             `<<-` <- base::`<<-`
[16:06:44.238]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:44.238]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:44.238]                   3L)]
[16:06:44.238]             }
[16:06:44.238]             function(cond) {
[16:06:44.238]                 is_error <- inherits(cond, "error")
[16:06:44.238]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:44.238]                   NULL)
[16:06:44.238]                 if (is_error) {
[16:06:44.238]                   sessionInformation <- function() {
[16:06:44.238]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:44.238]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:44.238]                       search = base::search(), system = base::Sys.info())
[16:06:44.238]                   }
[16:06:44.238]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.238]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:44.238]                     cond$call), session = sessionInformation(), 
[16:06:44.238]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:44.238]                   signalCondition(cond)
[16:06:44.238]                 }
[16:06:44.238]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:44.238]                 "immediateCondition"))) {
[16:06:44.238]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:44.238]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.238]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:44.238]                   if (TRUE && !signal) {
[16:06:44.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.238]                     {
[16:06:44.238]                       inherits <- base::inherits
[16:06:44.238]                       invokeRestart <- base::invokeRestart
[16:06:44.238]                       is.null <- base::is.null
[16:06:44.238]                       muffled <- FALSE
[16:06:44.238]                       if (inherits(cond, "message")) {
[16:06:44.238]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.238]                         if (muffled) 
[16:06:44.238]                           invokeRestart("muffleMessage")
[16:06:44.238]                       }
[16:06:44.238]                       else if (inherits(cond, "warning")) {
[16:06:44.238]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.238]                         if (muffled) 
[16:06:44.238]                           invokeRestart("muffleWarning")
[16:06:44.238]                       }
[16:06:44.238]                       else if (inherits(cond, "condition")) {
[16:06:44.238]                         if (!is.null(pattern)) {
[16:06:44.238]                           computeRestarts <- base::computeRestarts
[16:06:44.238]                           grepl <- base::grepl
[16:06:44.238]                           restarts <- computeRestarts(cond)
[16:06:44.238]                           for (restart in restarts) {
[16:06:44.238]                             name <- restart$name
[16:06:44.238]                             if (is.null(name)) 
[16:06:44.238]                               next
[16:06:44.238]                             if (!grepl(pattern, name)) 
[16:06:44.238]                               next
[16:06:44.238]                             invokeRestart(restart)
[16:06:44.238]                             muffled <- TRUE
[16:06:44.238]                             break
[16:06:44.238]                           }
[16:06:44.238]                         }
[16:06:44.238]                       }
[16:06:44.238]                       invisible(muffled)
[16:06:44.238]                     }
[16:06:44.238]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.238]                   }
[16:06:44.238]                 }
[16:06:44.238]                 else {
[16:06:44.238]                   if (TRUE) {
[16:06:44.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.238]                     {
[16:06:44.238]                       inherits <- base::inherits
[16:06:44.238]                       invokeRestart <- base::invokeRestart
[16:06:44.238]                       is.null <- base::is.null
[16:06:44.238]                       muffled <- FALSE
[16:06:44.238]                       if (inherits(cond, "message")) {
[16:06:44.238]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.238]                         if (muffled) 
[16:06:44.238]                           invokeRestart("muffleMessage")
[16:06:44.238]                       }
[16:06:44.238]                       else if (inherits(cond, "warning")) {
[16:06:44.238]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.238]                         if (muffled) 
[16:06:44.238]                           invokeRestart("muffleWarning")
[16:06:44.238]                       }
[16:06:44.238]                       else if (inherits(cond, "condition")) {
[16:06:44.238]                         if (!is.null(pattern)) {
[16:06:44.238]                           computeRestarts <- base::computeRestarts
[16:06:44.238]                           grepl <- base::grepl
[16:06:44.238]                           restarts <- computeRestarts(cond)
[16:06:44.238]                           for (restart in restarts) {
[16:06:44.238]                             name <- restart$name
[16:06:44.238]                             if (is.null(name)) 
[16:06:44.238]                               next
[16:06:44.238]                             if (!grepl(pattern, name)) 
[16:06:44.238]                               next
[16:06:44.238]                             invokeRestart(restart)
[16:06:44.238]                             muffled <- TRUE
[16:06:44.238]                             break
[16:06:44.238]                           }
[16:06:44.238]                         }
[16:06:44.238]                       }
[16:06:44.238]                       invisible(muffled)
[16:06:44.238]                     }
[16:06:44.238]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.238]                   }
[16:06:44.238]                 }
[16:06:44.238]             }
[16:06:44.238]         }))
[16:06:44.238]     }, error = function(ex) {
[16:06:44.238]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:44.238]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.238]                 ...future.rng), started = ...future.startTime, 
[16:06:44.238]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:44.238]             version = "1.8"), class = "FutureResult")
[16:06:44.238]     }, finally = {
[16:06:44.238]         if (!identical(...future.workdir, getwd())) 
[16:06:44.238]             setwd(...future.workdir)
[16:06:44.238]         {
[16:06:44.238]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:44.238]                 ...future.oldOptions$nwarnings <- NULL
[16:06:44.238]             }
[16:06:44.238]             base::options(...future.oldOptions)
[16:06:44.238]             if (.Platform$OS.type == "windows") {
[16:06:44.238]                 old_names <- names(...future.oldEnvVars)
[16:06:44.238]                 envs <- base::Sys.getenv()
[16:06:44.238]                 names <- names(envs)
[16:06:44.238]                 common <- intersect(names, old_names)
[16:06:44.238]                 added <- setdiff(names, old_names)
[16:06:44.238]                 removed <- setdiff(old_names, names)
[16:06:44.238]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:44.238]                   envs[common]]
[16:06:44.238]                 NAMES <- toupper(changed)
[16:06:44.238]                 args <- list()
[16:06:44.238]                 for (kk in seq_along(NAMES)) {
[16:06:44.238]                   name <- changed[[kk]]
[16:06:44.238]                   NAME <- NAMES[[kk]]
[16:06:44.238]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.238]                     next
[16:06:44.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.238]                 }
[16:06:44.238]                 NAMES <- toupper(added)
[16:06:44.238]                 for (kk in seq_along(NAMES)) {
[16:06:44.238]                   name <- added[[kk]]
[16:06:44.238]                   NAME <- NAMES[[kk]]
[16:06:44.238]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.238]                     next
[16:06:44.238]                   args[[name]] <- ""
[16:06:44.238]                 }
[16:06:44.238]                 NAMES <- toupper(removed)
[16:06:44.238]                 for (kk in seq_along(NAMES)) {
[16:06:44.238]                   name <- removed[[kk]]
[16:06:44.238]                   NAME <- NAMES[[kk]]
[16:06:44.238]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.238]                     next
[16:06:44.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.238]                 }
[16:06:44.238]                 if (length(args) > 0) 
[16:06:44.238]                   base::do.call(base::Sys.setenv, args = args)
[16:06:44.238]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:44.238]             }
[16:06:44.238]             else {
[16:06:44.238]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:44.238]             }
[16:06:44.238]             {
[16:06:44.238]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:44.238]                   0L) {
[16:06:44.238]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:44.238]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:44.238]                   base::options(opts)
[16:06:44.238]                 }
[16:06:44.238]                 {
[16:06:44.238]                   {
[16:06:44.238]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:44.238]                     NULL
[16:06:44.238]                   }
[16:06:44.238]                   options(future.plan = NULL)
[16:06:44.238]                   if (is.na(NA_character_)) 
[16:06:44.238]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.238]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:44.238]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:06:44.238]                     envir = parent.frame()) 
[16:06:44.238]                   {
[16:06:44.238]                     default_workers <- missing(workers)
[16:06:44.238]                     if (is.function(workers)) 
[16:06:44.238]                       workers <- workers()
[16:06:44.238]                     workers <- structure(as.integer(workers), 
[16:06:44.238]                       class = class(workers))
[16:06:44.238]                     stop_if_not(is.finite(workers), workers >= 
[16:06:44.238]                       1L)
[16:06:44.238]                     if ((workers == 1L && !inherits(workers, 
[16:06:44.238]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:06:44.238]                       if (default_workers) 
[16:06:44.238]                         supportsMulticore(warn = TRUE)
[16:06:44.238]                       return(sequential(..., envir = envir))
[16:06:44.238]                     }
[16:06:44.238]                     oopts <- options(mc.cores = workers)
[16:06:44.238]                     on.exit(options(oopts))
[16:06:44.238]                     future <- MulticoreFuture(..., workers = workers, 
[16:06:44.238]                       envir = envir)
[16:06:44.238]                     if (!future$lazy) 
[16:06:44.238]                       future <- run(future)
[16:06:44.238]                     invisible(future)
[16:06:44.238]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:44.238]                 }
[16:06:44.238]             }
[16:06:44.238]         }
[16:06:44.238]     })
[16:06:44.238]     if (FALSE) {
[16:06:44.238]         base::sink(type = "output", split = FALSE)
[16:06:44.238]         if (NA) {
[16:06:44.238]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:44.238]         }
[16:06:44.238]         else {
[16:06:44.238]             ...future.result["stdout"] <- base::list(NULL)
[16:06:44.238]         }
[16:06:44.238]         base::close(...future.stdout)
[16:06:44.238]         ...future.stdout <- NULL
[16:06:44.238]     }
[16:06:44.238]     ...future.result$conditions <- ...future.conditions
[16:06:44.238]     ...future.result$finished <- base::Sys.time()
[16:06:44.238]     ...future.result
[16:06:44.238] }
[16:06:44.240] requestCore(): workers = 2
[16:06:44.242] MulticoreFuture started
[16:06:44.242] - Launch lazy future ... done
[16:06:44.242] run() for ‘MulticoreFuture’ ... done
[16:06:44.243] result() for MulticoreFuture ...
[16:06:44.243] plan(): Setting new future strategy stack:
[16:06:44.244] List of future strategies:
[16:06:44.244] 1. sequential:
[16:06:44.244]    - args: function (..., envir = parent.frame())
[16:06:44.244]    - tweaked: FALSE
[16:06:44.244]    - call: NULL
[16:06:44.244] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[16:06:44.248] plan(): Setting new future strategy stack:
[16:06:44.248] List of future strategies:
[16:06:44.248] 1. multicore:
[16:06:44.248]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:06:44.248]    - tweaked: FALSE
[16:06:44.248]    - call: plan(strategy)
[16:06:44.253] plan(): nbrOfWorkers() = 2
[16:06:44.254] result() for MulticoreFuture ...
[16:06:44.254] result() for MulticoreFuture ... done
[16:06:44.254] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:06:44"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:06:44"
 $ session_uuid: chr "f1d97265-e713-8b20-3054-beca782eec78"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "11666ca4073c"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92440
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:06:44"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:06:44.264] result() for MulticoreFuture ...
[16:06:44.264] result() for MulticoreFuture ... done
[16:06:44.264] result() for MulticoreFuture ...
[16:06:44.264] result() for MulticoreFuture ... done
[16:06:44.265] getGlobalsAndPackages() ...
[16:06:44.265] Searching for globals...
[16:06:44.268] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:44.269] Searching for globals ... DONE
[16:06:44.269] Resolving globals: FALSE
[16:06:44.269] 
[16:06:44.269] - packages: [1] ‘utils’
[16:06:44.270] getGlobalsAndPackages() ... DONE
[16:06:44.270] run() for ‘Future’ ...
[16:06:44.270] - state: ‘created’
[16:06:44.270] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:06:44.276] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:44.276] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:06:44.277]   - Field: ‘label’
[16:06:44.277]   - Field: ‘local’
[16:06:44.277]   - Field: ‘owner’
[16:06:44.277]   - Field: ‘envir’
[16:06:44.277]   - Field: ‘workers’
[16:06:44.277]   - Field: ‘packages’
[16:06:44.277]   - Field: ‘gc’
[16:06:44.278]   - Field: ‘job’
[16:06:44.278]   - Field: ‘conditions’
[16:06:44.278]   - Field: ‘expr’
[16:06:44.278]   - Field: ‘uuid’
[16:06:44.278]   - Field: ‘seed’
[16:06:44.278]   - Field: ‘version’
[16:06:44.278]   - Field: ‘result’
[16:06:44.278]   - Field: ‘asynchronous’
[16:06:44.278]   - Field: ‘calls’
[16:06:44.279]   - Field: ‘globals’
[16:06:44.279]   - Field: ‘stdout’
[16:06:44.279]   - Field: ‘earlySignal’
[16:06:44.279]   - Field: ‘lazy’
[16:06:44.279]   - Field: ‘state’
[16:06:44.279] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:06:44.279] - Launch lazy future ...
[16:06:44.280] Packages needed by the future expression (n = 1): ‘utils’
[16:06:44.280] Packages needed by future strategies (n = 0): <none>
[16:06:44.280] {
[16:06:44.280]     {
[16:06:44.280]         {
[16:06:44.280]             ...future.startTime <- base::Sys.time()
[16:06:44.280]             {
[16:06:44.280]                 {
[16:06:44.280]                   {
[16:06:44.280]                     {
[16:06:44.280]                       {
[16:06:44.280]                         base::local({
[16:06:44.280]                           has_future <- base::requireNamespace("future", 
[16:06:44.280]                             quietly = TRUE)
[16:06:44.280]                           if (has_future) {
[16:06:44.280]                             ns <- base::getNamespace("future")
[16:06:44.280]                             version <- ns[[".package"]][["version"]]
[16:06:44.280]                             if (is.null(version)) 
[16:06:44.280]                               version <- utils::packageVersion("future")
[16:06:44.280]                           }
[16:06:44.280]                           else {
[16:06:44.280]                             version <- NULL
[16:06:44.280]                           }
[16:06:44.280]                           if (!has_future || version < "1.8.0") {
[16:06:44.280]                             info <- base::c(r_version = base::gsub("R version ", 
[16:06:44.280]                               "", base::R.version$version.string), 
[16:06:44.280]                               platform = base::sprintf("%s (%s-bit)", 
[16:06:44.280]                                 base::R.version$platform, 8 * 
[16:06:44.280]                                   base::.Machine$sizeof.pointer), 
[16:06:44.280]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:44.280]                                 "release", "version")], collapse = " "), 
[16:06:44.280]                               hostname = base::Sys.info()[["nodename"]])
[16:06:44.280]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:06:44.280]                               info)
[16:06:44.280]                             info <- base::paste(info, collapse = "; ")
[16:06:44.280]                             if (!has_future) {
[16:06:44.280]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:44.280]                                 info)
[16:06:44.280]                             }
[16:06:44.280]                             else {
[16:06:44.280]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:44.280]                                 info, version)
[16:06:44.280]                             }
[16:06:44.280]                             base::stop(msg)
[16:06:44.280]                           }
[16:06:44.280]                         })
[16:06:44.280]                       }
[16:06:44.280]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:44.280]                       base::options(mc.cores = 1L)
[16:06:44.280]                     }
[16:06:44.280]                     base::local({
[16:06:44.280]                       for (pkg in "utils") {
[16:06:44.280]                         base::loadNamespace(pkg)
[16:06:44.280]                         base::library(pkg, character.only = TRUE)
[16:06:44.280]                       }
[16:06:44.280]                     })
[16:06:44.280]                   }
[16:06:44.280]                   options(future.plan = NULL)
[16:06:44.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:44.280]                 }
[16:06:44.280]                 ...future.workdir <- getwd()
[16:06:44.280]             }
[16:06:44.280]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:44.280]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:44.280]         }
[16:06:44.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:44.280]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:44.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:44.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:44.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:44.280]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:44.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:44.280]             base::names(...future.oldOptions))
[16:06:44.280]     }
[16:06:44.280]     if (TRUE) {
[16:06:44.280]     }
[16:06:44.280]     else {
[16:06:44.280]         if (NA) {
[16:06:44.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:44.280]                 open = "w")
[16:06:44.280]         }
[16:06:44.280]         else {
[16:06:44.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:44.280]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:44.280]         }
[16:06:44.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:44.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:44.280]             base::sink(type = "output", split = FALSE)
[16:06:44.280]             base::close(...future.stdout)
[16:06:44.280]         }, add = TRUE)
[16:06:44.280]     }
[16:06:44.280]     ...future.frame <- base::sys.nframe()
[16:06:44.280]     ...future.conditions <- base::list()
[16:06:44.280]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:44.280]     if (FALSE) {
[16:06:44.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:44.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:44.280]     }
[16:06:44.280]     ...future.result <- base::tryCatch({
[16:06:44.280]         base::withCallingHandlers({
[16:06:44.280]             ...future.value <- base::withVisible(base::local({
[16:06:44.280]                 withCallingHandlers({
[16:06:44.280]                   {
[16:06:44.280]                     print(1:50)
[16:06:44.280]                     str(1:50)
[16:06:44.280]                     cat(letters, sep = "-")
[16:06:44.280]                     cat(1:6, collapse = "\n")
[16:06:44.280]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:44.280]                     42L
[16:06:44.280]                   }
[16:06:44.280]                 }, immediateCondition = function(cond) {
[16:06:44.280]                   save_rds <- function (object, pathname, ...) 
[16:06:44.280]                   {
[16:06:44.280]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:06:44.280]                     if (file_test("-f", pathname_tmp)) {
[16:06:44.280]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.280]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:06:44.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.280]                         fi_tmp[["mtime"]])
[16:06:44.280]                     }
[16:06:44.280]                     tryCatch({
[16:06:44.280]                       saveRDS(object, file = pathname_tmp, ...)
[16:06:44.280]                     }, error = function(ex) {
[16:06:44.280]                       msg <- conditionMessage(ex)
[16:06:44.280]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.280]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:06:44.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.280]                         fi_tmp[["mtime"]], msg)
[16:06:44.280]                       ex$message <- msg
[16:06:44.280]                       stop(ex)
[16:06:44.280]                     })
[16:06:44.280]                     stopifnot(file_test("-f", pathname_tmp))
[16:06:44.280]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:06:44.280]                     if (!res || file_test("-f", pathname_tmp)) {
[16:06:44.280]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.280]                       fi <- file.info(pathname)
[16:06:44.280]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:06:44.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.280]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:06:44.280]                         fi[["size"]], fi[["mtime"]])
[16:06:44.280]                       stop(msg)
[16:06:44.280]                     }
[16:06:44.280]                     invisible(pathname)
[16:06:44.280]                   }
[16:06:44.280]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:06:44.280]                     rootPath = tempdir()) 
[16:06:44.280]                   {
[16:06:44.280]                     obj <- list(time = Sys.time(), condition = cond)
[16:06:44.280]                     file <- tempfile(pattern = class(cond)[1], 
[16:06:44.280]                       tmpdir = path, fileext = ".rds")
[16:06:44.280]                     save_rds(obj, file)
[16:06:44.280]                   }
[16:06:44.280]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6lYtbx/.future/immediateConditions")
[16:06:44.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.280]                   {
[16:06:44.280]                     inherits <- base::inherits
[16:06:44.280]                     invokeRestart <- base::invokeRestart
[16:06:44.280]                     is.null <- base::is.null
[16:06:44.280]                     muffled <- FALSE
[16:06:44.280]                     if (inherits(cond, "message")) {
[16:06:44.280]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:44.280]                       if (muffled) 
[16:06:44.280]                         invokeRestart("muffleMessage")
[16:06:44.280]                     }
[16:06:44.280]                     else if (inherits(cond, "warning")) {
[16:06:44.280]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:44.280]                       if (muffled) 
[16:06:44.280]                         invokeRestart("muffleWarning")
[16:06:44.280]                     }
[16:06:44.280]                     else if (inherits(cond, "condition")) {
[16:06:44.280]                       if (!is.null(pattern)) {
[16:06:44.280]                         computeRestarts <- base::computeRestarts
[16:06:44.280]                         grepl <- base::grepl
[16:06:44.280]                         restarts <- computeRestarts(cond)
[16:06:44.280]                         for (restart in restarts) {
[16:06:44.280]                           name <- restart$name
[16:06:44.280]                           if (is.null(name)) 
[16:06:44.280]                             next
[16:06:44.280]                           if (!grepl(pattern, name)) 
[16:06:44.280]                             next
[16:06:44.280]                           invokeRestart(restart)
[16:06:44.280]                           muffled <- TRUE
[16:06:44.280]                           break
[16:06:44.280]                         }
[16:06:44.280]                       }
[16:06:44.280]                     }
[16:06:44.280]                     invisible(muffled)
[16:06:44.280]                   }
[16:06:44.280]                   muffleCondition(cond)
[16:06:44.280]                 })
[16:06:44.280]             }))
[16:06:44.280]             future::FutureResult(value = ...future.value$value, 
[16:06:44.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.280]                   ...future.rng), globalenv = if (FALSE) 
[16:06:44.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:44.280]                     ...future.globalenv.names))
[16:06:44.280]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:44.280]         }, condition = base::local({
[16:06:44.280]             c <- base::c
[16:06:44.280]             inherits <- base::inherits
[16:06:44.280]             invokeRestart <- base::invokeRestart
[16:06:44.280]             length <- base::length
[16:06:44.280]             list <- base::list
[16:06:44.280]             seq.int <- base::seq.int
[16:06:44.280]             signalCondition <- base::signalCondition
[16:06:44.280]             sys.calls <- base::sys.calls
[16:06:44.280]             `[[` <- base::`[[`
[16:06:44.280]             `+` <- base::`+`
[16:06:44.280]             `<<-` <- base::`<<-`
[16:06:44.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:44.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:44.280]                   3L)]
[16:06:44.280]             }
[16:06:44.280]             function(cond) {
[16:06:44.280]                 is_error <- inherits(cond, "error")
[16:06:44.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:44.280]                   NULL)
[16:06:44.280]                 if (is_error) {
[16:06:44.280]                   sessionInformation <- function() {
[16:06:44.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:44.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:44.280]                       search = base::search(), system = base::Sys.info())
[16:06:44.280]                   }
[16:06:44.280]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:44.280]                     cond$call), session = sessionInformation(), 
[16:06:44.280]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:44.280]                   signalCondition(cond)
[16:06:44.280]                 }
[16:06:44.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:44.280]                 "immediateCondition"))) {
[16:06:44.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:44.280]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:44.280]                   if (TRUE && !signal) {
[16:06:44.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.280]                     {
[16:06:44.280]                       inherits <- base::inherits
[16:06:44.280]                       invokeRestart <- base::invokeRestart
[16:06:44.280]                       is.null <- base::is.null
[16:06:44.280]                       muffled <- FALSE
[16:06:44.280]                       if (inherits(cond, "message")) {
[16:06:44.280]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.280]                         if (muffled) 
[16:06:44.280]                           invokeRestart("muffleMessage")
[16:06:44.280]                       }
[16:06:44.280]                       else if (inherits(cond, "warning")) {
[16:06:44.280]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.280]                         if (muffled) 
[16:06:44.280]                           invokeRestart("muffleWarning")
[16:06:44.280]                       }
[16:06:44.280]                       else if (inherits(cond, "condition")) {
[16:06:44.280]                         if (!is.null(pattern)) {
[16:06:44.280]                           computeRestarts <- base::computeRestarts
[16:06:44.280]                           grepl <- base::grepl
[16:06:44.280]                           restarts <- computeRestarts(cond)
[16:06:44.280]                           for (restart in restarts) {
[16:06:44.280]                             name <- restart$name
[16:06:44.280]                             if (is.null(name)) 
[16:06:44.280]                               next
[16:06:44.280]                             if (!grepl(pattern, name)) 
[16:06:44.280]                               next
[16:06:44.280]                             invokeRestart(restart)
[16:06:44.280]                             muffled <- TRUE
[16:06:44.280]                             break
[16:06:44.280]                           }
[16:06:44.280]                         }
[16:06:44.280]                       }
[16:06:44.280]                       invisible(muffled)
[16:06:44.280]                     }
[16:06:44.280]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.280]                   }
[16:06:44.280]                 }
[16:06:44.280]                 else {
[16:06:44.280]                   if (TRUE) {
[16:06:44.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.280]                     {
[16:06:44.280]                       inherits <- base::inherits
[16:06:44.280]                       invokeRestart <- base::invokeRestart
[16:06:44.280]                       is.null <- base::is.null
[16:06:44.280]                       muffled <- FALSE
[16:06:44.280]                       if (inherits(cond, "message")) {
[16:06:44.280]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.280]                         if (muffled) 
[16:06:44.280]                           invokeRestart("muffleMessage")
[16:06:44.280]                       }
[16:06:44.280]                       else if (inherits(cond, "warning")) {
[16:06:44.280]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.280]                         if (muffled) 
[16:06:44.280]                           invokeRestart("muffleWarning")
[16:06:44.280]                       }
[16:06:44.280]                       else if (inherits(cond, "condition")) {
[16:06:44.280]                         if (!is.null(pattern)) {
[16:06:44.280]                           computeRestarts <- base::computeRestarts
[16:06:44.280]                           grepl <- base::grepl
[16:06:44.280]                           restarts <- computeRestarts(cond)
[16:06:44.280]                           for (restart in restarts) {
[16:06:44.280]                             name <- restart$name
[16:06:44.280]                             if (is.null(name)) 
[16:06:44.280]                               next
[16:06:44.280]                             if (!grepl(pattern, name)) 
[16:06:44.280]                               next
[16:06:44.280]                             invokeRestart(restart)
[16:06:44.280]                             muffled <- TRUE
[16:06:44.280]                             break
[16:06:44.280]                           }
[16:06:44.280]                         }
[16:06:44.280]                       }
[16:06:44.280]                       invisible(muffled)
[16:06:44.280]                     }
[16:06:44.280]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.280]                   }
[16:06:44.280]                 }
[16:06:44.280]             }
[16:06:44.280]         }))
[16:06:44.280]     }, error = function(ex) {
[16:06:44.280]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:44.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.280]                 ...future.rng), started = ...future.startTime, 
[16:06:44.280]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:44.280]             version = "1.8"), class = "FutureResult")
[16:06:44.280]     }, finally = {
[16:06:44.280]         if (!identical(...future.workdir, getwd())) 
[16:06:44.280]             setwd(...future.workdir)
[16:06:44.280]         {
[16:06:44.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:44.280]                 ...future.oldOptions$nwarnings <- NULL
[16:06:44.280]             }
[16:06:44.280]             base::options(...future.oldOptions)
[16:06:44.280]             if (.Platform$OS.type == "windows") {
[16:06:44.280]                 old_names <- names(...future.oldEnvVars)
[16:06:44.280]                 envs <- base::Sys.getenv()
[16:06:44.280]                 names <- names(envs)
[16:06:44.280]                 common <- intersect(names, old_names)
[16:06:44.280]                 added <- setdiff(names, old_names)
[16:06:44.280]                 removed <- setdiff(old_names, names)
[16:06:44.280]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:44.280]                   envs[common]]
[16:06:44.280]                 NAMES <- toupper(changed)
[16:06:44.280]                 args <- list()
[16:06:44.280]                 for (kk in seq_along(NAMES)) {
[16:06:44.280]                   name <- changed[[kk]]
[16:06:44.280]                   NAME <- NAMES[[kk]]
[16:06:44.280]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.280]                     next
[16:06:44.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.280]                 }
[16:06:44.280]                 NAMES <- toupper(added)
[16:06:44.280]                 for (kk in seq_along(NAMES)) {
[16:06:44.280]                   name <- added[[kk]]
[16:06:44.280]                   NAME <- NAMES[[kk]]
[16:06:44.280]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.280]                     next
[16:06:44.280]                   args[[name]] <- ""
[16:06:44.280]                 }
[16:06:44.280]                 NAMES <- toupper(removed)
[16:06:44.280]                 for (kk in seq_along(NAMES)) {
[16:06:44.280]                   name <- removed[[kk]]
[16:06:44.280]                   NAME <- NAMES[[kk]]
[16:06:44.280]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.280]                     next
[16:06:44.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.280]                 }
[16:06:44.280]                 if (length(args) > 0) 
[16:06:44.280]                   base::do.call(base::Sys.setenv, args = args)
[16:06:44.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:44.280]             }
[16:06:44.280]             else {
[16:06:44.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:44.280]             }
[16:06:44.280]             {
[16:06:44.280]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:44.280]                   0L) {
[16:06:44.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:44.280]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:44.280]                   base::options(opts)
[16:06:44.280]                 }
[16:06:44.280]                 {
[16:06:44.280]                   {
[16:06:44.280]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:44.280]                     NULL
[16:06:44.280]                   }
[16:06:44.280]                   options(future.plan = NULL)
[16:06:44.280]                   if (is.na(NA_character_)) 
[16:06:44.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:44.280]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:06:44.280]                     envir = parent.frame()) 
[16:06:44.280]                   {
[16:06:44.280]                     default_workers <- missing(workers)
[16:06:44.280]                     if (is.function(workers)) 
[16:06:44.280]                       workers <- workers()
[16:06:44.280]                     workers <- structure(as.integer(workers), 
[16:06:44.280]                       class = class(workers))
[16:06:44.280]                     stop_if_not(is.finite(workers), workers >= 
[16:06:44.280]                       1L)
[16:06:44.280]                     if ((workers == 1L && !inherits(workers, 
[16:06:44.280]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:06:44.280]                       if (default_workers) 
[16:06:44.280]                         supportsMulticore(warn = TRUE)
[16:06:44.280]                       return(sequential(..., envir = envir))
[16:06:44.280]                     }
[16:06:44.280]                     oopts <- options(mc.cores = workers)
[16:06:44.280]                     on.exit(options(oopts))
[16:06:44.280]                     future <- MulticoreFuture(..., workers = workers, 
[16:06:44.280]                       envir = envir)
[16:06:44.280]                     if (!future$lazy) 
[16:06:44.280]                       future <- run(future)
[16:06:44.280]                     invisible(future)
[16:06:44.280]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:44.280]                 }
[16:06:44.280]             }
[16:06:44.280]         }
[16:06:44.280]     })
[16:06:44.280]     if (FALSE) {
[16:06:44.280]         base::sink(type = "output", split = FALSE)
[16:06:44.280]         if (NA) {
[16:06:44.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:44.280]         }
[16:06:44.280]         else {
[16:06:44.280]             ...future.result["stdout"] <- base::list(NULL)
[16:06:44.280]         }
[16:06:44.280]         base::close(...future.stdout)
[16:06:44.280]         ...future.stdout <- NULL
[16:06:44.280]     }
[16:06:44.280]     ...future.result$conditions <- ...future.conditions
[16:06:44.280]     ...future.result$finished <- base::Sys.time()
[16:06:44.280]     ...future.result
[16:06:44.280] }
[16:06:44.283] requestCore(): workers = 2
[16:06:44.285] MulticoreFuture started
[16:06:44.285] - Launch lazy future ... done
[16:06:44.285] run() for ‘MulticoreFuture’ ... done
[16:06:44.286] result() for MulticoreFuture ...
[16:06:44.286] plan(): Setting new future strategy stack:
[16:06:44.286] List of future strategies:
[16:06:44.286] 1. sequential:
[16:06:44.286]    - args: function (..., envir = parent.frame())
[16:06:44.286]    - tweaked: FALSE
[16:06:44.286]    - call: NULL
[16:06:44.287] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[16:06:44.290] plan(): Setting new future strategy stack:
[16:06:44.291] List of future strategies:
[16:06:44.291] 1. multicore:
[16:06:44.291]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:06:44.291]    - tweaked: FALSE
[16:06:44.291]    - call: plan(strategy)
[16:06:44.296] plan(): nbrOfWorkers() = 2
[16:06:44.296] result() for MulticoreFuture ...
[16:06:44.296] result() for MulticoreFuture ... done
[16:06:44.296] result() for MulticoreFuture ... done
[16:06:44.297] result() for MulticoreFuture ...
[16:06:44.297] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[16:06:44.297] getGlobalsAndPackages() ...
[16:06:44.297] Searching for globals...
[16:06:44.298] - globals found: [1] ‘print’
[16:06:44.298] Searching for globals ... DONE
[16:06:44.298] Resolving globals: FALSE
[16:06:44.299] 
[16:06:44.299] 
[16:06:44.299] getGlobalsAndPackages() ... DONE
[16:06:44.299] run() for ‘Future’ ...
[16:06:44.299] - state: ‘created’
[16:06:44.300] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:06:44.303] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:44.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:06:44.304]   - Field: ‘label’
[16:06:44.304]   - Field: ‘local’
[16:06:44.304]   - Field: ‘owner’
[16:06:44.304]   - Field: ‘envir’
[16:06:44.304]   - Field: ‘workers’
[16:06:44.304]   - Field: ‘packages’
[16:06:44.304]   - Field: ‘gc’
[16:06:44.304]   - Field: ‘job’
[16:06:44.305]   - Field: ‘conditions’
[16:06:44.305]   - Field: ‘expr’
[16:06:44.305]   - Field: ‘uuid’
[16:06:44.305]   - Field: ‘seed’
[16:06:44.305]   - Field: ‘version’
[16:06:44.305]   - Field: ‘result’
[16:06:44.305]   - Field: ‘asynchronous’
[16:06:44.305]   - Field: ‘calls’
[16:06:44.305]   - Field: ‘globals’
[16:06:44.306]   - Field: ‘stdout’
[16:06:44.306]   - Field: ‘earlySignal’
[16:06:44.306]   - Field: ‘lazy’
[16:06:44.306]   - Field: ‘state’
[16:06:44.306] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:06:44.306] - Launch lazy future ...
[16:06:44.306] Packages needed by the future expression (n = 0): <none>
[16:06:44.307] Packages needed by future strategies (n = 0): <none>
[16:06:44.307] {
[16:06:44.307]     {
[16:06:44.307]         {
[16:06:44.307]             ...future.startTime <- base::Sys.time()
[16:06:44.307]             {
[16:06:44.307]                 {
[16:06:44.307]                   {
[16:06:44.307]                     {
[16:06:44.307]                       base::local({
[16:06:44.307]                         has_future <- base::requireNamespace("future", 
[16:06:44.307]                           quietly = TRUE)
[16:06:44.307]                         if (has_future) {
[16:06:44.307]                           ns <- base::getNamespace("future")
[16:06:44.307]                           version <- ns[[".package"]][["version"]]
[16:06:44.307]                           if (is.null(version)) 
[16:06:44.307]                             version <- utils::packageVersion("future")
[16:06:44.307]                         }
[16:06:44.307]                         else {
[16:06:44.307]                           version <- NULL
[16:06:44.307]                         }
[16:06:44.307]                         if (!has_future || version < "1.8.0") {
[16:06:44.307]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:44.307]                             "", base::R.version$version.string), 
[16:06:44.307]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:44.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:44.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:44.307]                               "release", "version")], collapse = " "), 
[16:06:44.307]                             hostname = base::Sys.info()[["nodename"]])
[16:06:44.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:44.307]                             info)
[16:06:44.307]                           info <- base::paste(info, collapse = "; ")
[16:06:44.307]                           if (!has_future) {
[16:06:44.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:44.307]                               info)
[16:06:44.307]                           }
[16:06:44.307]                           else {
[16:06:44.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:44.307]                               info, version)
[16:06:44.307]                           }
[16:06:44.307]                           base::stop(msg)
[16:06:44.307]                         }
[16:06:44.307]                       })
[16:06:44.307]                     }
[16:06:44.307]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:44.307]                     base::options(mc.cores = 1L)
[16:06:44.307]                   }
[16:06:44.307]                   options(future.plan = NULL)
[16:06:44.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:44.307]                 }
[16:06:44.307]                 ...future.workdir <- getwd()
[16:06:44.307]             }
[16:06:44.307]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:44.307]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:44.307]         }
[16:06:44.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:44.307]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:44.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:44.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:44.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:44.307]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:44.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:44.307]             base::names(...future.oldOptions))
[16:06:44.307]     }
[16:06:44.307]     if (FALSE) {
[16:06:44.307]     }
[16:06:44.307]     else {
[16:06:44.307]         if (TRUE) {
[16:06:44.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:44.307]                 open = "w")
[16:06:44.307]         }
[16:06:44.307]         else {
[16:06:44.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:44.307]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:44.307]         }
[16:06:44.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:44.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:44.307]             base::sink(type = "output", split = FALSE)
[16:06:44.307]             base::close(...future.stdout)
[16:06:44.307]         }, add = TRUE)
[16:06:44.307]     }
[16:06:44.307]     ...future.frame <- base::sys.nframe()
[16:06:44.307]     ...future.conditions <- base::list()
[16:06:44.307]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:44.307]     if (FALSE) {
[16:06:44.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:44.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:44.307]     }
[16:06:44.307]     ...future.result <- base::tryCatch({
[16:06:44.307]         base::withCallingHandlers({
[16:06:44.307]             ...future.value <- base::withVisible(base::local({
[16:06:44.307]                 withCallingHandlers({
[16:06:44.307]                   print(42)
[16:06:44.307]                 }, immediateCondition = function(cond) {
[16:06:44.307]                   save_rds <- function (object, pathname, ...) 
[16:06:44.307]                   {
[16:06:44.307]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:06:44.307]                     if (file_test("-f", pathname_tmp)) {
[16:06:44.307]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.307]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:06:44.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.307]                         fi_tmp[["mtime"]])
[16:06:44.307]                     }
[16:06:44.307]                     tryCatch({
[16:06:44.307]                       saveRDS(object, file = pathname_tmp, ...)
[16:06:44.307]                     }, error = function(ex) {
[16:06:44.307]                       msg <- conditionMessage(ex)
[16:06:44.307]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.307]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:06:44.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.307]                         fi_tmp[["mtime"]], msg)
[16:06:44.307]                       ex$message <- msg
[16:06:44.307]                       stop(ex)
[16:06:44.307]                     })
[16:06:44.307]                     stopifnot(file_test("-f", pathname_tmp))
[16:06:44.307]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:06:44.307]                     if (!res || file_test("-f", pathname_tmp)) {
[16:06:44.307]                       fi_tmp <- file.info(pathname_tmp)
[16:06:44.307]                       fi <- file.info(pathname)
[16:06:44.307]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:06:44.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:06:44.307]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:06:44.307]                         fi[["size"]], fi[["mtime"]])
[16:06:44.307]                       stop(msg)
[16:06:44.307]                     }
[16:06:44.307]                     invisible(pathname)
[16:06:44.307]                   }
[16:06:44.307]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:06:44.307]                     rootPath = tempdir()) 
[16:06:44.307]                   {
[16:06:44.307]                     obj <- list(time = Sys.time(), condition = cond)
[16:06:44.307]                     file <- tempfile(pattern = class(cond)[1], 
[16:06:44.307]                       tmpdir = path, fileext = ".rds")
[16:06:44.307]                     save_rds(obj, file)
[16:06:44.307]                   }
[16:06:44.307]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6lYtbx/.future/immediateConditions")
[16:06:44.307]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.307]                   {
[16:06:44.307]                     inherits <- base::inherits
[16:06:44.307]                     invokeRestart <- base::invokeRestart
[16:06:44.307]                     is.null <- base::is.null
[16:06:44.307]                     muffled <- FALSE
[16:06:44.307]                     if (inherits(cond, "message")) {
[16:06:44.307]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:44.307]                       if (muffled) 
[16:06:44.307]                         invokeRestart("muffleMessage")
[16:06:44.307]                     }
[16:06:44.307]                     else if (inherits(cond, "warning")) {
[16:06:44.307]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:44.307]                       if (muffled) 
[16:06:44.307]                         invokeRestart("muffleWarning")
[16:06:44.307]                     }
[16:06:44.307]                     else if (inherits(cond, "condition")) {
[16:06:44.307]                       if (!is.null(pattern)) {
[16:06:44.307]                         computeRestarts <- base::computeRestarts
[16:06:44.307]                         grepl <- base::grepl
[16:06:44.307]                         restarts <- computeRestarts(cond)
[16:06:44.307]                         for (restart in restarts) {
[16:06:44.307]                           name <- restart$name
[16:06:44.307]                           if (is.null(name)) 
[16:06:44.307]                             next
[16:06:44.307]                           if (!grepl(pattern, name)) 
[16:06:44.307]                             next
[16:06:44.307]                           invokeRestart(restart)
[16:06:44.307]                           muffled <- TRUE
[16:06:44.307]                           break
[16:06:44.307]                         }
[16:06:44.307]                       }
[16:06:44.307]                     }
[16:06:44.307]                     invisible(muffled)
[16:06:44.307]                   }
[16:06:44.307]                   muffleCondition(cond)
[16:06:44.307]                 })
[16:06:44.307]             }))
[16:06:44.307]             future::FutureResult(value = ...future.value$value, 
[16:06:44.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.307]                   ...future.rng), globalenv = if (FALSE) 
[16:06:44.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:44.307]                     ...future.globalenv.names))
[16:06:44.307]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:44.307]         }, condition = base::local({
[16:06:44.307]             c <- base::c
[16:06:44.307]             inherits <- base::inherits
[16:06:44.307]             invokeRestart <- base::invokeRestart
[16:06:44.307]             length <- base::length
[16:06:44.307]             list <- base::list
[16:06:44.307]             seq.int <- base::seq.int
[16:06:44.307]             signalCondition <- base::signalCondition
[16:06:44.307]             sys.calls <- base::sys.calls
[16:06:44.307]             `[[` <- base::`[[`
[16:06:44.307]             `+` <- base::`+`
[16:06:44.307]             `<<-` <- base::`<<-`
[16:06:44.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:44.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:44.307]                   3L)]
[16:06:44.307]             }
[16:06:44.307]             function(cond) {
[16:06:44.307]                 is_error <- inherits(cond, "error")
[16:06:44.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:44.307]                   NULL)
[16:06:44.307]                 if (is_error) {
[16:06:44.307]                   sessionInformation <- function() {
[16:06:44.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:44.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:44.307]                       search = base::search(), system = base::Sys.info())
[16:06:44.307]                   }
[16:06:44.307]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:44.307]                     cond$call), session = sessionInformation(), 
[16:06:44.307]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:44.307]                   signalCondition(cond)
[16:06:44.307]                 }
[16:06:44.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:44.307]                 "immediateCondition"))) {
[16:06:44.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:44.307]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:44.307]                   if (TRUE && !signal) {
[16:06:44.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.307]                     {
[16:06:44.307]                       inherits <- base::inherits
[16:06:44.307]                       invokeRestart <- base::invokeRestart
[16:06:44.307]                       is.null <- base::is.null
[16:06:44.307]                       muffled <- FALSE
[16:06:44.307]                       if (inherits(cond, "message")) {
[16:06:44.307]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.307]                         if (muffled) 
[16:06:44.307]                           invokeRestart("muffleMessage")
[16:06:44.307]                       }
[16:06:44.307]                       else if (inherits(cond, "warning")) {
[16:06:44.307]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.307]                         if (muffled) 
[16:06:44.307]                           invokeRestart("muffleWarning")
[16:06:44.307]                       }
[16:06:44.307]                       else if (inherits(cond, "condition")) {
[16:06:44.307]                         if (!is.null(pattern)) {
[16:06:44.307]                           computeRestarts <- base::computeRestarts
[16:06:44.307]                           grepl <- base::grepl
[16:06:44.307]                           restarts <- computeRestarts(cond)
[16:06:44.307]                           for (restart in restarts) {
[16:06:44.307]                             name <- restart$name
[16:06:44.307]                             if (is.null(name)) 
[16:06:44.307]                               next
[16:06:44.307]                             if (!grepl(pattern, name)) 
[16:06:44.307]                               next
[16:06:44.307]                             invokeRestart(restart)
[16:06:44.307]                             muffled <- TRUE
[16:06:44.307]                             break
[16:06:44.307]                           }
[16:06:44.307]                         }
[16:06:44.307]                       }
[16:06:44.307]                       invisible(muffled)
[16:06:44.307]                     }
[16:06:44.307]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.307]                   }
[16:06:44.307]                 }
[16:06:44.307]                 else {
[16:06:44.307]                   if (TRUE) {
[16:06:44.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.307]                     {
[16:06:44.307]                       inherits <- base::inherits
[16:06:44.307]                       invokeRestart <- base::invokeRestart
[16:06:44.307]                       is.null <- base::is.null
[16:06:44.307]                       muffled <- FALSE
[16:06:44.307]                       if (inherits(cond, "message")) {
[16:06:44.307]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.307]                         if (muffled) 
[16:06:44.307]                           invokeRestart("muffleMessage")
[16:06:44.307]                       }
[16:06:44.307]                       else if (inherits(cond, "warning")) {
[16:06:44.307]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.307]                         if (muffled) 
[16:06:44.307]                           invokeRestart("muffleWarning")
[16:06:44.307]                       }
[16:06:44.307]                       else if (inherits(cond, "condition")) {
[16:06:44.307]                         if (!is.null(pattern)) {
[16:06:44.307]                           computeRestarts <- base::computeRestarts
[16:06:44.307]                           grepl <- base::grepl
[16:06:44.307]                           restarts <- computeRestarts(cond)
[16:06:44.307]                           for (restart in restarts) {
[16:06:44.307]                             name <- restart$name
[16:06:44.307]                             if (is.null(name)) 
[16:06:44.307]                               next
[16:06:44.307]                             if (!grepl(pattern, name)) 
[16:06:44.307]                               next
[16:06:44.307]                             invokeRestart(restart)
[16:06:44.307]                             muffled <- TRUE
[16:06:44.307]                             break
[16:06:44.307]                           }
[16:06:44.307]                         }
[16:06:44.307]                       }
[16:06:44.307]                       invisible(muffled)
[16:06:44.307]                     }
[16:06:44.307]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.307]                   }
[16:06:44.307]                 }
[16:06:44.307]             }
[16:06:44.307]         }))
[16:06:44.307]     }, error = function(ex) {
[16:06:44.307]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:44.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.307]                 ...future.rng), started = ...future.startTime, 
[16:06:44.307]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:44.307]             version = "1.8"), class = "FutureResult")
[16:06:44.307]     }, finally = {
[16:06:44.307]         if (!identical(...future.workdir, getwd())) 
[16:06:44.307]             setwd(...future.workdir)
[16:06:44.307]         {
[16:06:44.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:44.307]                 ...future.oldOptions$nwarnings <- NULL
[16:06:44.307]             }
[16:06:44.307]             base::options(...future.oldOptions)
[16:06:44.307]             if (.Platform$OS.type == "windows") {
[16:06:44.307]                 old_names <- names(...future.oldEnvVars)
[16:06:44.307]                 envs <- base::Sys.getenv()
[16:06:44.307]                 names <- names(envs)
[16:06:44.307]                 common <- intersect(names, old_names)
[16:06:44.307]                 added <- setdiff(names, old_names)
[16:06:44.307]                 removed <- setdiff(old_names, names)
[16:06:44.307]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:44.307]                   envs[common]]
[16:06:44.307]                 NAMES <- toupper(changed)
[16:06:44.307]                 args <- list()
[16:06:44.307]                 for (kk in seq_along(NAMES)) {
[16:06:44.307]                   name <- changed[[kk]]
[16:06:44.307]                   NAME <- NAMES[[kk]]
[16:06:44.307]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.307]                     next
[16:06:44.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.307]                 }
[16:06:44.307]                 NAMES <- toupper(added)
[16:06:44.307]                 for (kk in seq_along(NAMES)) {
[16:06:44.307]                   name <- added[[kk]]
[16:06:44.307]                   NAME <- NAMES[[kk]]
[16:06:44.307]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.307]                     next
[16:06:44.307]                   args[[name]] <- ""
[16:06:44.307]                 }
[16:06:44.307]                 NAMES <- toupper(removed)
[16:06:44.307]                 for (kk in seq_along(NAMES)) {
[16:06:44.307]                   name <- removed[[kk]]
[16:06:44.307]                   NAME <- NAMES[[kk]]
[16:06:44.307]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.307]                     next
[16:06:44.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.307]                 }
[16:06:44.307]                 if (length(args) > 0) 
[16:06:44.307]                   base::do.call(base::Sys.setenv, args = args)
[16:06:44.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:44.307]             }
[16:06:44.307]             else {
[16:06:44.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:44.307]             }
[16:06:44.307]             {
[16:06:44.307]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:44.307]                   0L) {
[16:06:44.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:44.307]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:44.307]                   base::options(opts)
[16:06:44.307]                 }
[16:06:44.307]                 {
[16:06:44.307]                   {
[16:06:44.307]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:44.307]                     NULL
[16:06:44.307]                   }
[16:06:44.307]                   options(future.plan = NULL)
[16:06:44.307]                   if (is.na(NA_character_)) 
[16:06:44.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:44.307]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:06:44.307]                     envir = parent.frame()) 
[16:06:44.307]                   {
[16:06:44.307]                     default_workers <- missing(workers)
[16:06:44.307]                     if (is.function(workers)) 
[16:06:44.307]                       workers <- workers()
[16:06:44.307]                     workers <- structure(as.integer(workers), 
[16:06:44.307]                       class = class(workers))
[16:06:44.307]                     stop_if_not(is.finite(workers), workers >= 
[16:06:44.307]                       1L)
[16:06:44.307]                     if ((workers == 1L && !inherits(workers, 
[16:06:44.307]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:06:44.307]                       if (default_workers) 
[16:06:44.307]                         supportsMulticore(warn = TRUE)
[16:06:44.307]                       return(sequential(..., envir = envir))
[16:06:44.307]                     }
[16:06:44.307]                     oopts <- options(mc.cores = workers)
[16:06:44.307]                     on.exit(options(oopts))
[16:06:44.307]                     future <- MulticoreFuture(..., workers = workers, 
[16:06:44.307]                       envir = envir)
[16:06:44.307]                     if (!future$lazy) 
[16:06:44.307]                       future <- run(future)
[16:06:44.307]                     invisible(future)
[16:06:44.307]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:44.307]                 }
[16:06:44.307]             }
[16:06:44.307]         }
[16:06:44.307]     })
[16:06:44.307]     if (TRUE) {
[16:06:44.307]         base::sink(type = "output", split = FALSE)
[16:06:44.307]         if (TRUE) {
[16:06:44.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:44.307]         }
[16:06:44.307]         else {
[16:06:44.307]             ...future.result["stdout"] <- base::list(NULL)
[16:06:44.307]         }
[16:06:44.307]         base::close(...future.stdout)
[16:06:44.307]         ...future.stdout <- NULL
[16:06:44.307]     }
[16:06:44.307]     ...future.result$conditions <- ...future.conditions
[16:06:44.307]     ...future.result$finished <- base::Sys.time()
[16:06:44.307]     ...future.result
[16:06:44.307] }
[16:06:44.310] requestCore(): workers = 2
[16:06:44.312] MulticoreFuture started
[16:06:44.312] - Launch lazy future ... done
[16:06:44.312] run() for ‘MulticoreFuture’ ... done
[16:06:44.312] result() for MulticoreFuture ...
[16:06:44.313] plan(): Setting new future strategy stack:
[16:06:44.313] List of future strategies:
[16:06:44.313] 1. sequential:
[16:06:44.313]    - args: function (..., envir = parent.frame())
[16:06:44.313]    - tweaked: FALSE
[16:06:44.313]    - call: NULL
[16:06:44.313] plan(): nbrOfWorkers() = 1
[16:06:44.315] plan(): Setting new future strategy stack:
[16:06:44.316] List of future strategies:
[16:06:44.316] 1. multicore:
[16:06:44.316]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:06:44.316]    - tweaked: FALSE
[16:06:44.316]    - call: plan(strategy)
[16:06:44.321] plan(): nbrOfWorkers() = 2
[16:06:44.321] result() for MulticoreFuture ...
[16:06:44.322] result() for MulticoreFuture ... done
[16:06:44.322] result() for MulticoreFuture ... done
[16:06:44.322] result() for MulticoreFuture ...
[16:06:44.322] result() for MulticoreFuture ... done
[16:06:44.322] result() for MulticoreFuture ...
[16:06:44.322] result() for MulticoreFuture ... done
[1] 42
[16:06:44.323] result() for MulticoreFuture ...
[16:06:44.323] result() for MulticoreFuture ... done
multicore ... done
multisession ...
[16:06:44.324] plan(): Setting new future strategy stack:
[16:06:44.324] List of future strategies:
[16:06:44.324] 1. multisession:
[16:06:44.324]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:06:44.324]    - tweaked: FALSE
[16:06:44.324]    - call: plan(strategy)
[16:06:44.324] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:06:44.324] multisession:
[16:06:44.324] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:06:44.324] - tweaked: FALSE
[16:06:44.324] - call: plan(strategy)
[16:06:44.331] getGlobalsAndPackages() ...
[16:06:44.331] Not searching for globals
[16:06:44.332] - globals: [0] <none>
[16:06:44.332] getGlobalsAndPackages() ... DONE
[16:06:44.332] [local output] makeClusterPSOCK() ...
[16:06:44.375] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:06:44.376] [local output] Base port: 11578
[16:06:44.376] [local output] Getting setup options for 2 cluster nodes ...
[16:06:44.377] [local output]  - Node 1 of 2 ...
[16:06:44.377] [local output] localMachine=TRUE => revtunnel=FALSE

[16:06:44.378] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6lYtbx/worker.rank=1.parallelly.parent=92386.168e236987bec.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp6lYtbx/worker.rank=1.parallelly.parent=92386.168e236987bec.pid")'’
[16:06:44.563] - Possible to infer worker's PID: TRUE
[16:06:44.564] [local output] Rscript port: 11578

[16:06:44.564] [local output]  - Node 2 of 2 ...
[16:06:44.565] [local output] localMachine=TRUE => revtunnel=FALSE

[16:06:44.565] [local output] Rscript port: 11578

[16:06:44.565] [local output] Getting setup options for 2 cluster nodes ... done
[16:06:44.566] [local output]  - Parallel setup requested for some PSOCK nodes
[16:06:44.566] [local output] Setting up PSOCK nodes in parallel
[16:06:44.566] List of 36
[16:06:44.566]  $ worker          : chr "localhost"
[16:06:44.566]   ..- attr(*, "localhost")= logi TRUE
[16:06:44.566]  $ master          : chr "localhost"
[16:06:44.566]  $ port            : int 11578
[16:06:44.566]  $ connectTimeout  : num 120
[16:06:44.566]  $ timeout         : num 2592000
[16:06:44.566]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:06:44.566]  $ homogeneous     : logi TRUE
[16:06:44.566]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:06:44.566]  $ rscript_envs    : NULL
[16:06:44.566]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:06:44.566]  $ rscript_startup : NULL
[16:06:44.566]  $ rscript_sh      : chr "sh"
[16:06:44.566]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:06:44.566]  $ methods         : logi TRUE
[16:06:44.566]  $ socketOptions   : chr "no-delay"
[16:06:44.566]  $ useXDR          : logi FALSE
[16:06:44.566]  $ outfile         : chr "/dev/null"
[16:06:44.566]  $ renice          : int NA
[16:06:44.566]  $ rshcmd          : NULL
[16:06:44.566]  $ user            : chr(0) 
[16:06:44.566]  $ revtunnel       : logi FALSE
[16:06:44.566]  $ rshlogfile      : NULL
[16:06:44.566]  $ rshopts         : chr(0) 
[16:06:44.566]  $ rank            : int 1
[16:06:44.566]  $ manual          : logi FALSE
[16:06:44.566]  $ dryrun          : logi FALSE
[16:06:44.566]  $ quiet           : logi FALSE
[16:06:44.566]  $ setup_strategy  : chr "parallel"
[16:06:44.566]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:06:44.566]  $ pidfile         : chr "/tmp/Rtmp6lYtbx/worker.rank=1.parallelly.parent=92386.168e236987bec.pid"
[16:06:44.566]  $ rshcmd_label    : NULL
[16:06:44.566]  $ rsh_call        : NULL
[16:06:44.566]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:06:44.566]  $ localMachine    : logi TRUE
[16:06:44.566]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:06:44.566]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:06:44.566]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:06:44.566]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:06:44.566]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:06:44.566]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:06:44.566]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:06:44.566]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:06:44.566]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:06:44.566]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:06:44.566]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:06:44.566]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:06:44.566]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:06:44.566]  $ arguments       :List of 28
[16:06:44.566]   ..$ worker          : chr "localhost"
[16:06:44.566]   ..$ master          : NULL
[16:06:44.566]   ..$ port            : int 11578
[16:06:44.566]   ..$ connectTimeout  : num 120
[16:06:44.566]   ..$ timeout         : num 2592000
[16:06:44.566]   ..$ rscript         : NULL
[16:06:44.566]   ..$ homogeneous     : NULL
[16:06:44.566]   ..$ rscript_args    : NULL
[16:06:44.566]   ..$ rscript_envs    : NULL
[16:06:44.566]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:06:44.566]   ..$ rscript_startup : NULL
[16:06:44.566]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:06:44.566]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:06:44.566]   ..$ methods         : logi TRUE
[16:06:44.566]   ..$ socketOptions   : chr "no-delay"
[16:06:44.566]   ..$ useXDR          : logi FALSE
[16:06:44.566]   ..$ outfile         : chr "/dev/null"
[16:06:44.566]   ..$ renice          : int NA
[16:06:44.566]   ..$ rshcmd          : NULL
[16:06:44.566]   ..$ user            : NULL
[16:06:44.566]   ..$ revtunnel       : logi NA
[16:06:44.566]   ..$ rshlogfile      : NULL
[16:06:44.566]   ..$ rshopts         : NULL
[16:06:44.566]   ..$ rank            : int 1
[16:06:44.566]   ..$ manual          : logi FALSE
[16:06:44.566]   ..$ dryrun          : logi FALSE
[16:06:44.566]   ..$ quiet           : logi FALSE
[16:06:44.566]   ..$ setup_strategy  : chr "parallel"
[16:06:44.566]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:06:44.583] [local output] System call to launch all workers:
[16:06:44.583] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6lYtbx/worker.rank=1.parallelly.parent=92386.168e236987bec.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11578 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:06:44.583] [local output] Starting PSOCK main server
[16:06:44.588] [local output] Workers launched
[16:06:44.588] [local output] Waiting for workers to connect back
[16:06:44.589]  - [local output] 0 workers out of 2 ready
[16:06:44.832]  - [local output] 0 workers out of 2 ready
[16:06:44.833]  - [local output] 1 workers out of 2 ready
[16:06:44.836]  - [local output] 1 workers out of 2 ready
[16:06:44.837]  - [local output] 2 workers out of 2 ready
[16:06:44.837] [local output] Launching of workers completed
[16:06:44.837] [local output] Collecting session information from workers
[16:06:44.838] [local output]  - Worker #1 of 2
[16:06:44.839] [local output]  - Worker #2 of 2
[16:06:44.839] [local output] makeClusterPSOCK() ... done
[16:06:44.850] Packages needed by the future expression (n = 0): <none>
[16:06:44.850] Packages needed by future strategies (n = 0): <none>
[16:06:44.850] {
[16:06:44.850]     {
[16:06:44.850]         {
[16:06:44.850]             ...future.startTime <- base::Sys.time()
[16:06:44.850]             {
[16:06:44.850]                 {
[16:06:44.850]                   {
[16:06:44.850]                     {
[16:06:44.850]                       base::local({
[16:06:44.850]                         has_future <- base::requireNamespace("future", 
[16:06:44.850]                           quietly = TRUE)
[16:06:44.850]                         if (has_future) {
[16:06:44.850]                           ns <- base::getNamespace("future")
[16:06:44.850]                           version <- ns[[".package"]][["version"]]
[16:06:44.850]                           if (is.null(version)) 
[16:06:44.850]                             version <- utils::packageVersion("future")
[16:06:44.850]                         }
[16:06:44.850]                         else {
[16:06:44.850]                           version <- NULL
[16:06:44.850]                         }
[16:06:44.850]                         if (!has_future || version < "1.8.0") {
[16:06:44.850]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:44.850]                             "", base::R.version$version.string), 
[16:06:44.850]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:44.850]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:44.850]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:44.850]                               "release", "version")], collapse = " "), 
[16:06:44.850]                             hostname = base::Sys.info()[["nodename"]])
[16:06:44.850]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:44.850]                             info)
[16:06:44.850]                           info <- base::paste(info, collapse = "; ")
[16:06:44.850]                           if (!has_future) {
[16:06:44.850]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:44.850]                               info)
[16:06:44.850]                           }
[16:06:44.850]                           else {
[16:06:44.850]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:44.850]                               info, version)
[16:06:44.850]                           }
[16:06:44.850]                           base::stop(msg)
[16:06:44.850]                         }
[16:06:44.850]                       })
[16:06:44.850]                     }
[16:06:44.850]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:44.850]                     base::options(mc.cores = 1L)
[16:06:44.850]                   }
[16:06:44.850]                   options(future.plan = NULL)
[16:06:44.850]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.850]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:44.850]                 }
[16:06:44.850]                 ...future.workdir <- getwd()
[16:06:44.850]             }
[16:06:44.850]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:44.850]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:44.850]         }
[16:06:44.850]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:44.850]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:44.850]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:44.850]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:44.850]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:44.850]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:44.850]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:44.850]             base::names(...future.oldOptions))
[16:06:44.850]     }
[16:06:44.850]     if (FALSE) {
[16:06:44.850]     }
[16:06:44.850]     else {
[16:06:44.850]         if (TRUE) {
[16:06:44.850]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:44.850]                 open = "w")
[16:06:44.850]         }
[16:06:44.850]         else {
[16:06:44.850]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:44.850]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:44.850]         }
[16:06:44.850]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:44.850]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:44.850]             base::sink(type = "output", split = FALSE)
[16:06:44.850]             base::close(...future.stdout)
[16:06:44.850]         }, add = TRUE)
[16:06:44.850]     }
[16:06:44.850]     ...future.frame <- base::sys.nframe()
[16:06:44.850]     ...future.conditions <- base::list()
[16:06:44.850]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:44.850]     if (FALSE) {
[16:06:44.850]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:44.850]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:44.850]     }
[16:06:44.850]     ...future.result <- base::tryCatch({
[16:06:44.850]         base::withCallingHandlers({
[16:06:44.850]             ...future.value <- base::withVisible(base::local({
[16:06:44.850]                 ...future.makeSendCondition <- base::local({
[16:06:44.850]                   sendCondition <- NULL
[16:06:44.850]                   function(frame = 1L) {
[16:06:44.850]                     if (is.function(sendCondition)) 
[16:06:44.850]                       return(sendCondition)
[16:06:44.850]                     ns <- getNamespace("parallel")
[16:06:44.850]                     if (exists("sendData", mode = "function", 
[16:06:44.850]                       envir = ns)) {
[16:06:44.850]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:44.850]                         envir = ns)
[16:06:44.850]                       envir <- sys.frame(frame)
[16:06:44.850]                       master <- NULL
[16:06:44.850]                       while (!identical(envir, .GlobalEnv) && 
[16:06:44.850]                         !identical(envir, emptyenv())) {
[16:06:44.850]                         if (exists("master", mode = "list", envir = envir, 
[16:06:44.850]                           inherits = FALSE)) {
[16:06:44.850]                           master <- get("master", mode = "list", 
[16:06:44.850]                             envir = envir, inherits = FALSE)
[16:06:44.850]                           if (inherits(master, c("SOCKnode", 
[16:06:44.850]                             "SOCK0node"))) {
[16:06:44.850]                             sendCondition <<- function(cond) {
[16:06:44.850]                               data <- list(type = "VALUE", value = cond, 
[16:06:44.850]                                 success = TRUE)
[16:06:44.850]                               parallel_sendData(master, data)
[16:06:44.850]                             }
[16:06:44.850]                             return(sendCondition)
[16:06:44.850]                           }
[16:06:44.850]                         }
[16:06:44.850]                         frame <- frame + 1L
[16:06:44.850]                         envir <- sys.frame(frame)
[16:06:44.850]                       }
[16:06:44.850]                     }
[16:06:44.850]                     sendCondition <<- function(cond) NULL
[16:06:44.850]                   }
[16:06:44.850]                 })
[16:06:44.850]                 withCallingHandlers({
[16:06:44.850]                   NA
[16:06:44.850]                 }, immediateCondition = function(cond) {
[16:06:44.850]                   sendCondition <- ...future.makeSendCondition()
[16:06:44.850]                   sendCondition(cond)
[16:06:44.850]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.850]                   {
[16:06:44.850]                     inherits <- base::inherits
[16:06:44.850]                     invokeRestart <- base::invokeRestart
[16:06:44.850]                     is.null <- base::is.null
[16:06:44.850]                     muffled <- FALSE
[16:06:44.850]                     if (inherits(cond, "message")) {
[16:06:44.850]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:44.850]                       if (muffled) 
[16:06:44.850]                         invokeRestart("muffleMessage")
[16:06:44.850]                     }
[16:06:44.850]                     else if (inherits(cond, "warning")) {
[16:06:44.850]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:44.850]                       if (muffled) 
[16:06:44.850]                         invokeRestart("muffleWarning")
[16:06:44.850]                     }
[16:06:44.850]                     else if (inherits(cond, "condition")) {
[16:06:44.850]                       if (!is.null(pattern)) {
[16:06:44.850]                         computeRestarts <- base::computeRestarts
[16:06:44.850]                         grepl <- base::grepl
[16:06:44.850]                         restarts <- computeRestarts(cond)
[16:06:44.850]                         for (restart in restarts) {
[16:06:44.850]                           name <- restart$name
[16:06:44.850]                           if (is.null(name)) 
[16:06:44.850]                             next
[16:06:44.850]                           if (!grepl(pattern, name)) 
[16:06:44.850]                             next
[16:06:44.850]                           invokeRestart(restart)
[16:06:44.850]                           muffled <- TRUE
[16:06:44.850]                           break
[16:06:44.850]                         }
[16:06:44.850]                       }
[16:06:44.850]                     }
[16:06:44.850]                     invisible(muffled)
[16:06:44.850]                   }
[16:06:44.850]                   muffleCondition(cond)
[16:06:44.850]                 })
[16:06:44.850]             }))
[16:06:44.850]             future::FutureResult(value = ...future.value$value, 
[16:06:44.850]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.850]                   ...future.rng), globalenv = if (FALSE) 
[16:06:44.850]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:44.850]                     ...future.globalenv.names))
[16:06:44.850]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:44.850]         }, condition = base::local({
[16:06:44.850]             c <- base::c
[16:06:44.850]             inherits <- base::inherits
[16:06:44.850]             invokeRestart <- base::invokeRestart
[16:06:44.850]             length <- base::length
[16:06:44.850]             list <- base::list
[16:06:44.850]             seq.int <- base::seq.int
[16:06:44.850]             signalCondition <- base::signalCondition
[16:06:44.850]             sys.calls <- base::sys.calls
[16:06:44.850]             `[[` <- base::`[[`
[16:06:44.850]             `+` <- base::`+`
[16:06:44.850]             `<<-` <- base::`<<-`
[16:06:44.850]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:44.850]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:44.850]                   3L)]
[16:06:44.850]             }
[16:06:44.850]             function(cond) {
[16:06:44.850]                 is_error <- inherits(cond, "error")
[16:06:44.850]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:44.850]                   NULL)
[16:06:44.850]                 if (is_error) {
[16:06:44.850]                   sessionInformation <- function() {
[16:06:44.850]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:44.850]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:44.850]                       search = base::search(), system = base::Sys.info())
[16:06:44.850]                   }
[16:06:44.850]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.850]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:44.850]                     cond$call), session = sessionInformation(), 
[16:06:44.850]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:44.850]                   signalCondition(cond)
[16:06:44.850]                 }
[16:06:44.850]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:44.850]                 "immediateCondition"))) {
[16:06:44.850]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:44.850]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.850]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:44.850]                   if (TRUE && !signal) {
[16:06:44.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.850]                     {
[16:06:44.850]                       inherits <- base::inherits
[16:06:44.850]                       invokeRestart <- base::invokeRestart
[16:06:44.850]                       is.null <- base::is.null
[16:06:44.850]                       muffled <- FALSE
[16:06:44.850]                       if (inherits(cond, "message")) {
[16:06:44.850]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.850]                         if (muffled) 
[16:06:44.850]                           invokeRestart("muffleMessage")
[16:06:44.850]                       }
[16:06:44.850]                       else if (inherits(cond, "warning")) {
[16:06:44.850]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.850]                         if (muffled) 
[16:06:44.850]                           invokeRestart("muffleWarning")
[16:06:44.850]                       }
[16:06:44.850]                       else if (inherits(cond, "condition")) {
[16:06:44.850]                         if (!is.null(pattern)) {
[16:06:44.850]                           computeRestarts <- base::computeRestarts
[16:06:44.850]                           grepl <- base::grepl
[16:06:44.850]                           restarts <- computeRestarts(cond)
[16:06:44.850]                           for (restart in restarts) {
[16:06:44.850]                             name <- restart$name
[16:06:44.850]                             if (is.null(name)) 
[16:06:44.850]                               next
[16:06:44.850]                             if (!grepl(pattern, name)) 
[16:06:44.850]                               next
[16:06:44.850]                             invokeRestart(restart)
[16:06:44.850]                             muffled <- TRUE
[16:06:44.850]                             break
[16:06:44.850]                           }
[16:06:44.850]                         }
[16:06:44.850]                       }
[16:06:44.850]                       invisible(muffled)
[16:06:44.850]                     }
[16:06:44.850]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.850]                   }
[16:06:44.850]                 }
[16:06:44.850]                 else {
[16:06:44.850]                   if (TRUE) {
[16:06:44.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.850]                     {
[16:06:44.850]                       inherits <- base::inherits
[16:06:44.850]                       invokeRestart <- base::invokeRestart
[16:06:44.850]                       is.null <- base::is.null
[16:06:44.850]                       muffled <- FALSE
[16:06:44.850]                       if (inherits(cond, "message")) {
[16:06:44.850]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.850]                         if (muffled) 
[16:06:44.850]                           invokeRestart("muffleMessage")
[16:06:44.850]                       }
[16:06:44.850]                       else if (inherits(cond, "warning")) {
[16:06:44.850]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.850]                         if (muffled) 
[16:06:44.850]                           invokeRestart("muffleWarning")
[16:06:44.850]                       }
[16:06:44.850]                       else if (inherits(cond, "condition")) {
[16:06:44.850]                         if (!is.null(pattern)) {
[16:06:44.850]                           computeRestarts <- base::computeRestarts
[16:06:44.850]                           grepl <- base::grepl
[16:06:44.850]                           restarts <- computeRestarts(cond)
[16:06:44.850]                           for (restart in restarts) {
[16:06:44.850]                             name <- restart$name
[16:06:44.850]                             if (is.null(name)) 
[16:06:44.850]                               next
[16:06:44.850]                             if (!grepl(pattern, name)) 
[16:06:44.850]                               next
[16:06:44.850]                             invokeRestart(restart)
[16:06:44.850]                             muffled <- TRUE
[16:06:44.850]                             break
[16:06:44.850]                           }
[16:06:44.850]                         }
[16:06:44.850]                       }
[16:06:44.850]                       invisible(muffled)
[16:06:44.850]                     }
[16:06:44.850]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.850]                   }
[16:06:44.850]                 }
[16:06:44.850]             }
[16:06:44.850]         }))
[16:06:44.850]     }, error = function(ex) {
[16:06:44.850]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:44.850]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.850]                 ...future.rng), started = ...future.startTime, 
[16:06:44.850]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:44.850]             version = "1.8"), class = "FutureResult")
[16:06:44.850]     }, finally = {
[16:06:44.850]         if (!identical(...future.workdir, getwd())) 
[16:06:44.850]             setwd(...future.workdir)
[16:06:44.850]         {
[16:06:44.850]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:44.850]                 ...future.oldOptions$nwarnings <- NULL
[16:06:44.850]             }
[16:06:44.850]             base::options(...future.oldOptions)
[16:06:44.850]             if (.Platform$OS.type == "windows") {
[16:06:44.850]                 old_names <- names(...future.oldEnvVars)
[16:06:44.850]                 envs <- base::Sys.getenv()
[16:06:44.850]                 names <- names(envs)
[16:06:44.850]                 common <- intersect(names, old_names)
[16:06:44.850]                 added <- setdiff(names, old_names)
[16:06:44.850]                 removed <- setdiff(old_names, names)
[16:06:44.850]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:44.850]                   envs[common]]
[16:06:44.850]                 NAMES <- toupper(changed)
[16:06:44.850]                 args <- list()
[16:06:44.850]                 for (kk in seq_along(NAMES)) {
[16:06:44.850]                   name <- changed[[kk]]
[16:06:44.850]                   NAME <- NAMES[[kk]]
[16:06:44.850]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.850]                     next
[16:06:44.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.850]                 }
[16:06:44.850]                 NAMES <- toupper(added)
[16:06:44.850]                 for (kk in seq_along(NAMES)) {
[16:06:44.850]                   name <- added[[kk]]
[16:06:44.850]                   NAME <- NAMES[[kk]]
[16:06:44.850]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.850]                     next
[16:06:44.850]                   args[[name]] <- ""
[16:06:44.850]                 }
[16:06:44.850]                 NAMES <- toupper(removed)
[16:06:44.850]                 for (kk in seq_along(NAMES)) {
[16:06:44.850]                   name <- removed[[kk]]
[16:06:44.850]                   NAME <- NAMES[[kk]]
[16:06:44.850]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.850]                     next
[16:06:44.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.850]                 }
[16:06:44.850]                 if (length(args) > 0) 
[16:06:44.850]                   base::do.call(base::Sys.setenv, args = args)
[16:06:44.850]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:44.850]             }
[16:06:44.850]             else {
[16:06:44.850]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:44.850]             }
[16:06:44.850]             {
[16:06:44.850]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:44.850]                   0L) {
[16:06:44.850]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:44.850]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:44.850]                   base::options(opts)
[16:06:44.850]                 }
[16:06:44.850]                 {
[16:06:44.850]                   {
[16:06:44.850]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:44.850]                     NULL
[16:06:44.850]                   }
[16:06:44.850]                   options(future.plan = NULL)
[16:06:44.850]                   if (is.na(NA_character_)) 
[16:06:44.850]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.850]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:44.850]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:44.850]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:44.850]                     envir = parent.frame()) 
[16:06:44.850]                   {
[16:06:44.850]                     if (is.function(workers)) 
[16:06:44.850]                       workers <- workers()
[16:06:44.850]                     workers <- structure(as.integer(workers), 
[16:06:44.850]                       class = class(workers))
[16:06:44.850]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:44.850]                       workers >= 1)
[16:06:44.850]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:44.850]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:44.850]                     }
[16:06:44.850]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:44.850]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:44.850]                       envir = envir)
[16:06:44.850]                     if (!future$lazy) 
[16:06:44.850]                       future <- run(future)
[16:06:44.850]                     invisible(future)
[16:06:44.850]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:44.850]                 }
[16:06:44.850]             }
[16:06:44.850]         }
[16:06:44.850]     })
[16:06:44.850]     if (TRUE) {
[16:06:44.850]         base::sink(type = "output", split = FALSE)
[16:06:44.850]         if (TRUE) {
[16:06:44.850]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:44.850]         }
[16:06:44.850]         else {
[16:06:44.850]             ...future.result["stdout"] <- base::list(NULL)
[16:06:44.850]         }
[16:06:44.850]         base::close(...future.stdout)
[16:06:44.850]         ...future.stdout <- NULL
[16:06:44.850]     }
[16:06:44.850]     ...future.result$conditions <- ...future.conditions
[16:06:44.850]     ...future.result$finished <- base::Sys.time()
[16:06:44.850]     ...future.result
[16:06:44.850] }
[16:06:44.903] MultisessionFuture started
[16:06:44.903] result() for ClusterFuture ...
[16:06:44.904] receiveMessageFromWorker() for ClusterFuture ...
[16:06:44.904] - Validating connection of MultisessionFuture
[16:06:44.947] - received message: FutureResult
[16:06:44.947] - Received FutureResult
[16:06:44.947] - Erased future from FutureRegistry
[16:06:44.947] result() for ClusterFuture ...
[16:06:44.947] - result already collected: FutureResult
[16:06:44.948] result() for ClusterFuture ... done
[16:06:44.948] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:44.948] result() for ClusterFuture ... done
[16:06:44.948] result() for ClusterFuture ...
[16:06:44.948] - result already collected: FutureResult
[16:06:44.948] result() for ClusterFuture ... done
[16:06:44.948] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:06:44.952] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[16:06:44.952] getGlobalsAndPackages() ...
[16:06:44.952] Searching for globals...
[16:06:44.956] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:44.956] Searching for globals ... DONE
[16:06:44.957] Resolving globals: FALSE
[16:06:44.957] 
[16:06:44.957] - packages: [1] ‘utils’
[16:06:44.957] getGlobalsAndPackages() ... DONE
[16:06:44.958] run() for ‘Future’ ...
[16:06:44.958] - state: ‘created’
[16:06:44.958] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:44.972] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:44.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:44.973]   - Field: ‘node’
[16:06:44.973]   - Field: ‘label’
[16:06:44.973]   - Field: ‘local’
[16:06:44.973]   - Field: ‘owner’
[16:06:44.973]   - Field: ‘envir’
[16:06:44.973]   - Field: ‘workers’
[16:06:44.973]   - Field: ‘packages’
[16:06:44.973]   - Field: ‘gc’
[16:06:44.973]   - Field: ‘conditions’
[16:06:44.973]   - Field: ‘persistent’
[16:06:44.974]   - Field: ‘expr’
[16:06:44.974]   - Field: ‘uuid’
[16:06:44.974]   - Field: ‘seed’
[16:06:44.974]   - Field: ‘version’
[16:06:44.974]   - Field: ‘result’
[16:06:44.974]   - Field: ‘asynchronous’
[16:06:44.974]   - Field: ‘calls’
[16:06:44.974]   - Field: ‘globals’
[16:06:44.974]   - Field: ‘stdout’
[16:06:44.975]   - Field: ‘earlySignal’
[16:06:44.975]   - Field: ‘lazy’
[16:06:44.975]   - Field: ‘state’
[16:06:44.975] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:44.975] - Launch lazy future ...
[16:06:44.975] Packages needed by the future expression (n = 1): ‘utils’
[16:06:44.976] Packages needed by future strategies (n = 0): <none>
[16:06:44.976] {
[16:06:44.976]     {
[16:06:44.976]         {
[16:06:44.976]             ...future.startTime <- base::Sys.time()
[16:06:44.976]             {
[16:06:44.976]                 {
[16:06:44.976]                   {
[16:06:44.976]                     {
[16:06:44.976]                       {
[16:06:44.976]                         base::local({
[16:06:44.976]                           has_future <- base::requireNamespace("future", 
[16:06:44.976]                             quietly = TRUE)
[16:06:44.976]                           if (has_future) {
[16:06:44.976]                             ns <- base::getNamespace("future")
[16:06:44.976]                             version <- ns[[".package"]][["version"]]
[16:06:44.976]                             if (is.null(version)) 
[16:06:44.976]                               version <- utils::packageVersion("future")
[16:06:44.976]                           }
[16:06:44.976]                           else {
[16:06:44.976]                             version <- NULL
[16:06:44.976]                           }
[16:06:44.976]                           if (!has_future || version < "1.8.0") {
[16:06:44.976]                             info <- base::c(r_version = base::gsub("R version ", 
[16:06:44.976]                               "", base::R.version$version.string), 
[16:06:44.976]                               platform = base::sprintf("%s (%s-bit)", 
[16:06:44.976]                                 base::R.version$platform, 8 * 
[16:06:44.976]                                   base::.Machine$sizeof.pointer), 
[16:06:44.976]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:44.976]                                 "release", "version")], collapse = " "), 
[16:06:44.976]                               hostname = base::Sys.info()[["nodename"]])
[16:06:44.976]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:06:44.976]                               info)
[16:06:44.976]                             info <- base::paste(info, collapse = "; ")
[16:06:44.976]                             if (!has_future) {
[16:06:44.976]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:44.976]                                 info)
[16:06:44.976]                             }
[16:06:44.976]                             else {
[16:06:44.976]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:44.976]                                 info, version)
[16:06:44.976]                             }
[16:06:44.976]                             base::stop(msg)
[16:06:44.976]                           }
[16:06:44.976]                         })
[16:06:44.976]                       }
[16:06:44.976]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:44.976]                       base::options(mc.cores = 1L)
[16:06:44.976]                     }
[16:06:44.976]                     base::local({
[16:06:44.976]                       for (pkg in "utils") {
[16:06:44.976]                         base::loadNamespace(pkg)
[16:06:44.976]                         base::library(pkg, character.only = TRUE)
[16:06:44.976]                       }
[16:06:44.976]                     })
[16:06:44.976]                   }
[16:06:44.976]                   options(future.plan = NULL)
[16:06:44.976]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.976]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:44.976]                 }
[16:06:44.976]                 ...future.workdir <- getwd()
[16:06:44.976]             }
[16:06:44.976]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:44.976]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:44.976]         }
[16:06:44.976]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:44.976]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:44.976]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:44.976]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:44.976]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:44.976]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:44.976]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:44.976]             base::names(...future.oldOptions))
[16:06:44.976]     }
[16:06:44.976]     if (FALSE) {
[16:06:44.976]     }
[16:06:44.976]     else {
[16:06:44.976]         if (TRUE) {
[16:06:44.976]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:44.976]                 open = "w")
[16:06:44.976]         }
[16:06:44.976]         else {
[16:06:44.976]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:44.976]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:44.976]         }
[16:06:44.976]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:44.976]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:44.976]             base::sink(type = "output", split = FALSE)
[16:06:44.976]             base::close(...future.stdout)
[16:06:44.976]         }, add = TRUE)
[16:06:44.976]     }
[16:06:44.976]     ...future.frame <- base::sys.nframe()
[16:06:44.976]     ...future.conditions <- base::list()
[16:06:44.976]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:44.976]     if (FALSE) {
[16:06:44.976]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:44.976]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:44.976]     }
[16:06:44.976]     ...future.result <- base::tryCatch({
[16:06:44.976]         base::withCallingHandlers({
[16:06:44.976]             ...future.value <- base::withVisible(base::local({
[16:06:44.976]                 ...future.makeSendCondition <- base::local({
[16:06:44.976]                   sendCondition <- NULL
[16:06:44.976]                   function(frame = 1L) {
[16:06:44.976]                     if (is.function(sendCondition)) 
[16:06:44.976]                       return(sendCondition)
[16:06:44.976]                     ns <- getNamespace("parallel")
[16:06:44.976]                     if (exists("sendData", mode = "function", 
[16:06:44.976]                       envir = ns)) {
[16:06:44.976]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:44.976]                         envir = ns)
[16:06:44.976]                       envir <- sys.frame(frame)
[16:06:44.976]                       master <- NULL
[16:06:44.976]                       while (!identical(envir, .GlobalEnv) && 
[16:06:44.976]                         !identical(envir, emptyenv())) {
[16:06:44.976]                         if (exists("master", mode = "list", envir = envir, 
[16:06:44.976]                           inherits = FALSE)) {
[16:06:44.976]                           master <- get("master", mode = "list", 
[16:06:44.976]                             envir = envir, inherits = FALSE)
[16:06:44.976]                           if (inherits(master, c("SOCKnode", 
[16:06:44.976]                             "SOCK0node"))) {
[16:06:44.976]                             sendCondition <<- function(cond) {
[16:06:44.976]                               data <- list(type = "VALUE", value = cond, 
[16:06:44.976]                                 success = TRUE)
[16:06:44.976]                               parallel_sendData(master, data)
[16:06:44.976]                             }
[16:06:44.976]                             return(sendCondition)
[16:06:44.976]                           }
[16:06:44.976]                         }
[16:06:44.976]                         frame <- frame + 1L
[16:06:44.976]                         envir <- sys.frame(frame)
[16:06:44.976]                       }
[16:06:44.976]                     }
[16:06:44.976]                     sendCondition <<- function(cond) NULL
[16:06:44.976]                   }
[16:06:44.976]                 })
[16:06:44.976]                 withCallingHandlers({
[16:06:44.976]                   {
[16:06:44.976]                     print(1:50)
[16:06:44.976]                     str(1:50)
[16:06:44.976]                     cat(letters, sep = "-")
[16:06:44.976]                     cat(1:6, collapse = "\n")
[16:06:44.976]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:44.976]                     42L
[16:06:44.976]                   }
[16:06:44.976]                 }, immediateCondition = function(cond) {
[16:06:44.976]                   sendCondition <- ...future.makeSendCondition()
[16:06:44.976]                   sendCondition(cond)
[16:06:44.976]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.976]                   {
[16:06:44.976]                     inherits <- base::inherits
[16:06:44.976]                     invokeRestart <- base::invokeRestart
[16:06:44.976]                     is.null <- base::is.null
[16:06:44.976]                     muffled <- FALSE
[16:06:44.976]                     if (inherits(cond, "message")) {
[16:06:44.976]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:44.976]                       if (muffled) 
[16:06:44.976]                         invokeRestart("muffleMessage")
[16:06:44.976]                     }
[16:06:44.976]                     else if (inherits(cond, "warning")) {
[16:06:44.976]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:44.976]                       if (muffled) 
[16:06:44.976]                         invokeRestart("muffleWarning")
[16:06:44.976]                     }
[16:06:44.976]                     else if (inherits(cond, "condition")) {
[16:06:44.976]                       if (!is.null(pattern)) {
[16:06:44.976]                         computeRestarts <- base::computeRestarts
[16:06:44.976]                         grepl <- base::grepl
[16:06:44.976]                         restarts <- computeRestarts(cond)
[16:06:44.976]                         for (restart in restarts) {
[16:06:44.976]                           name <- restart$name
[16:06:44.976]                           if (is.null(name)) 
[16:06:44.976]                             next
[16:06:44.976]                           if (!grepl(pattern, name)) 
[16:06:44.976]                             next
[16:06:44.976]                           invokeRestart(restart)
[16:06:44.976]                           muffled <- TRUE
[16:06:44.976]                           break
[16:06:44.976]                         }
[16:06:44.976]                       }
[16:06:44.976]                     }
[16:06:44.976]                     invisible(muffled)
[16:06:44.976]                   }
[16:06:44.976]                   muffleCondition(cond)
[16:06:44.976]                 })
[16:06:44.976]             }))
[16:06:44.976]             future::FutureResult(value = ...future.value$value, 
[16:06:44.976]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.976]                   ...future.rng), globalenv = if (FALSE) 
[16:06:44.976]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:44.976]                     ...future.globalenv.names))
[16:06:44.976]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:44.976]         }, condition = base::local({
[16:06:44.976]             c <- base::c
[16:06:44.976]             inherits <- base::inherits
[16:06:44.976]             invokeRestart <- base::invokeRestart
[16:06:44.976]             length <- base::length
[16:06:44.976]             list <- base::list
[16:06:44.976]             seq.int <- base::seq.int
[16:06:44.976]             signalCondition <- base::signalCondition
[16:06:44.976]             sys.calls <- base::sys.calls
[16:06:44.976]             `[[` <- base::`[[`
[16:06:44.976]             `+` <- base::`+`
[16:06:44.976]             `<<-` <- base::`<<-`
[16:06:44.976]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:44.976]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:44.976]                   3L)]
[16:06:44.976]             }
[16:06:44.976]             function(cond) {
[16:06:44.976]                 is_error <- inherits(cond, "error")
[16:06:44.976]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:44.976]                   NULL)
[16:06:44.976]                 if (is_error) {
[16:06:44.976]                   sessionInformation <- function() {
[16:06:44.976]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:44.976]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:44.976]                       search = base::search(), system = base::Sys.info())
[16:06:44.976]                   }
[16:06:44.976]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.976]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:44.976]                     cond$call), session = sessionInformation(), 
[16:06:44.976]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:44.976]                   signalCondition(cond)
[16:06:44.976]                 }
[16:06:44.976]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:44.976]                 "immediateCondition"))) {
[16:06:44.976]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:44.976]                   ...future.conditions[[length(...future.conditions) + 
[16:06:44.976]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:44.976]                   if (TRUE && !signal) {
[16:06:44.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.976]                     {
[16:06:44.976]                       inherits <- base::inherits
[16:06:44.976]                       invokeRestart <- base::invokeRestart
[16:06:44.976]                       is.null <- base::is.null
[16:06:44.976]                       muffled <- FALSE
[16:06:44.976]                       if (inherits(cond, "message")) {
[16:06:44.976]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.976]                         if (muffled) 
[16:06:44.976]                           invokeRestart("muffleMessage")
[16:06:44.976]                       }
[16:06:44.976]                       else if (inherits(cond, "warning")) {
[16:06:44.976]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.976]                         if (muffled) 
[16:06:44.976]                           invokeRestart("muffleWarning")
[16:06:44.976]                       }
[16:06:44.976]                       else if (inherits(cond, "condition")) {
[16:06:44.976]                         if (!is.null(pattern)) {
[16:06:44.976]                           computeRestarts <- base::computeRestarts
[16:06:44.976]                           grepl <- base::grepl
[16:06:44.976]                           restarts <- computeRestarts(cond)
[16:06:44.976]                           for (restart in restarts) {
[16:06:44.976]                             name <- restart$name
[16:06:44.976]                             if (is.null(name)) 
[16:06:44.976]                               next
[16:06:44.976]                             if (!grepl(pattern, name)) 
[16:06:44.976]                               next
[16:06:44.976]                             invokeRestart(restart)
[16:06:44.976]                             muffled <- TRUE
[16:06:44.976]                             break
[16:06:44.976]                           }
[16:06:44.976]                         }
[16:06:44.976]                       }
[16:06:44.976]                       invisible(muffled)
[16:06:44.976]                     }
[16:06:44.976]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.976]                   }
[16:06:44.976]                 }
[16:06:44.976]                 else {
[16:06:44.976]                   if (TRUE) {
[16:06:44.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:44.976]                     {
[16:06:44.976]                       inherits <- base::inherits
[16:06:44.976]                       invokeRestart <- base::invokeRestart
[16:06:44.976]                       is.null <- base::is.null
[16:06:44.976]                       muffled <- FALSE
[16:06:44.976]                       if (inherits(cond, "message")) {
[16:06:44.976]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:44.976]                         if (muffled) 
[16:06:44.976]                           invokeRestart("muffleMessage")
[16:06:44.976]                       }
[16:06:44.976]                       else if (inherits(cond, "warning")) {
[16:06:44.976]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:44.976]                         if (muffled) 
[16:06:44.976]                           invokeRestart("muffleWarning")
[16:06:44.976]                       }
[16:06:44.976]                       else if (inherits(cond, "condition")) {
[16:06:44.976]                         if (!is.null(pattern)) {
[16:06:44.976]                           computeRestarts <- base::computeRestarts
[16:06:44.976]                           grepl <- base::grepl
[16:06:44.976]                           restarts <- computeRestarts(cond)
[16:06:44.976]                           for (restart in restarts) {
[16:06:44.976]                             name <- restart$name
[16:06:44.976]                             if (is.null(name)) 
[16:06:44.976]                               next
[16:06:44.976]                             if (!grepl(pattern, name)) 
[16:06:44.976]                               next
[16:06:44.976]                             invokeRestart(restart)
[16:06:44.976]                             muffled <- TRUE
[16:06:44.976]                             break
[16:06:44.976]                           }
[16:06:44.976]                         }
[16:06:44.976]                       }
[16:06:44.976]                       invisible(muffled)
[16:06:44.976]                     }
[16:06:44.976]                     muffleCondition(cond, pattern = "^muffle")
[16:06:44.976]                   }
[16:06:44.976]                 }
[16:06:44.976]             }
[16:06:44.976]         }))
[16:06:44.976]     }, error = function(ex) {
[16:06:44.976]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:44.976]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:44.976]                 ...future.rng), started = ...future.startTime, 
[16:06:44.976]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:44.976]             version = "1.8"), class = "FutureResult")
[16:06:44.976]     }, finally = {
[16:06:44.976]         if (!identical(...future.workdir, getwd())) 
[16:06:44.976]             setwd(...future.workdir)
[16:06:44.976]         {
[16:06:44.976]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:44.976]                 ...future.oldOptions$nwarnings <- NULL
[16:06:44.976]             }
[16:06:44.976]             base::options(...future.oldOptions)
[16:06:44.976]             if (.Platform$OS.type == "windows") {
[16:06:44.976]                 old_names <- names(...future.oldEnvVars)
[16:06:44.976]                 envs <- base::Sys.getenv()
[16:06:44.976]                 names <- names(envs)
[16:06:44.976]                 common <- intersect(names, old_names)
[16:06:44.976]                 added <- setdiff(names, old_names)
[16:06:44.976]                 removed <- setdiff(old_names, names)
[16:06:44.976]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:44.976]                   envs[common]]
[16:06:44.976]                 NAMES <- toupper(changed)
[16:06:44.976]                 args <- list()
[16:06:44.976]                 for (kk in seq_along(NAMES)) {
[16:06:44.976]                   name <- changed[[kk]]
[16:06:44.976]                   NAME <- NAMES[[kk]]
[16:06:44.976]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.976]                     next
[16:06:44.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.976]                 }
[16:06:44.976]                 NAMES <- toupper(added)
[16:06:44.976]                 for (kk in seq_along(NAMES)) {
[16:06:44.976]                   name <- added[[kk]]
[16:06:44.976]                   NAME <- NAMES[[kk]]
[16:06:44.976]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.976]                     next
[16:06:44.976]                   args[[name]] <- ""
[16:06:44.976]                 }
[16:06:44.976]                 NAMES <- toupper(removed)
[16:06:44.976]                 for (kk in seq_along(NAMES)) {
[16:06:44.976]                   name <- removed[[kk]]
[16:06:44.976]                   NAME <- NAMES[[kk]]
[16:06:44.976]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:44.976]                     next
[16:06:44.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:44.976]                 }
[16:06:44.976]                 if (length(args) > 0) 
[16:06:44.976]                   base::do.call(base::Sys.setenv, args = args)
[16:06:44.976]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:44.976]             }
[16:06:44.976]             else {
[16:06:44.976]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:44.976]             }
[16:06:44.976]             {
[16:06:44.976]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:44.976]                   0L) {
[16:06:44.976]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:44.976]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:44.976]                   base::options(opts)
[16:06:44.976]                 }
[16:06:44.976]                 {
[16:06:44.976]                   {
[16:06:44.976]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:44.976]                     NULL
[16:06:44.976]                   }
[16:06:44.976]                   options(future.plan = NULL)
[16:06:44.976]                   if (is.na(NA_character_)) 
[16:06:44.976]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:44.976]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:44.976]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:44.976]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:44.976]                     envir = parent.frame()) 
[16:06:44.976]                   {
[16:06:44.976]                     if (is.function(workers)) 
[16:06:44.976]                       workers <- workers()
[16:06:44.976]                     workers <- structure(as.integer(workers), 
[16:06:44.976]                       class = class(workers))
[16:06:44.976]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:44.976]                       workers >= 1)
[16:06:44.976]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:44.976]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:44.976]                     }
[16:06:44.976]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:44.976]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:44.976]                       envir = envir)
[16:06:44.976]                     if (!future$lazy) 
[16:06:44.976]                       future <- run(future)
[16:06:44.976]                     invisible(future)
[16:06:44.976]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:44.976]                 }
[16:06:44.976]             }
[16:06:44.976]         }
[16:06:44.976]     })
[16:06:44.976]     if (TRUE) {
[16:06:44.976]         base::sink(type = "output", split = FALSE)
[16:06:44.976]         if (TRUE) {
[16:06:44.976]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:44.976]         }
[16:06:44.976]         else {
[16:06:44.976]             ...future.result["stdout"] <- base::list(NULL)
[16:06:44.976]         }
[16:06:44.976]         base::close(...future.stdout)
[16:06:44.976]         ...future.stdout <- NULL
[16:06:44.976]     }
[16:06:44.976]     ...future.result$conditions <- ...future.conditions
[16:06:44.976]     ...future.result$finished <- base::Sys.time()
[16:06:44.976]     ...future.result
[16:06:44.976] }
[16:06:44.980] MultisessionFuture started
[16:06:44.980] - Launch lazy future ... done
[16:06:44.980] run() for ‘MultisessionFuture’ ... done
[16:06:44.980] result() for ClusterFuture ...
[16:06:44.980] receiveMessageFromWorker() for ClusterFuture ...
[16:06:44.981] - Validating connection of MultisessionFuture
[16:06:45.031] - received message: FutureResult
[16:06:45.031] - Received FutureResult
[16:06:45.031] - Erased future from FutureRegistry
[16:06:45.032] result() for ClusterFuture ...
[16:06:45.032] - result already collected: FutureResult
[16:06:45.032] result() for ClusterFuture ... done
[16:06:45.032] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:45.032] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:06:45"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:06:45"
 $ session_uuid: chr "8a740ab0-1dc6-8e1f-1e6e-7e40ad691e23"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "11666ca4073c"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92488
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:06:44"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:06:45.042] result() for ClusterFuture ...
[16:06:45.042] - result already collected: FutureResult
[16:06:45.042] result() for ClusterFuture ... done
[16:06:45.042] result() for ClusterFuture ...
[16:06:45.042] - result already collected: FutureResult
[16:06:45.042] result() for ClusterFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.007969856 secs (started 2025-01-06 16:06:45.023526)
version: 1.8
[16:06:45.043] getGlobalsAndPackages() ...
[16:06:45.043] Searching for globals...
[16:06:45.047] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:45.047] Searching for globals ... DONE
[16:06:45.047] Resolving globals: FALSE
[16:06:45.048] 
[16:06:45.048] - packages: [1] ‘utils’
[16:06:45.048] getGlobalsAndPackages() ... DONE
[16:06:45.048] run() for ‘Future’ ...
[16:06:45.048] - state: ‘created’
[16:06:45.049] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:45.063] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:45.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:45.063]   - Field: ‘node’
[16:06:45.063]   - Field: ‘label’
[16:06:45.063]   - Field: ‘local’
[16:06:45.063]   - Field: ‘owner’
[16:06:45.063]   - Field: ‘envir’
[16:06:45.063]   - Field: ‘workers’
[16:06:45.064]   - Field: ‘packages’
[16:06:45.064]   - Field: ‘gc’
[16:06:45.064]   - Field: ‘conditions’
[16:06:45.064]   - Field: ‘persistent’
[16:06:45.064]   - Field: ‘expr’
[16:06:45.064]   - Field: ‘uuid’
[16:06:45.064]   - Field: ‘seed’
[16:06:45.064]   - Field: ‘version’
[16:06:45.064]   - Field: ‘result’
[16:06:45.065]   - Field: ‘asynchronous’
[16:06:45.065]   - Field: ‘calls’
[16:06:45.065]   - Field: ‘globals’
[16:06:45.065]   - Field: ‘stdout’
[16:06:45.065]   - Field: ‘earlySignal’
[16:06:45.065]   - Field: ‘lazy’
[16:06:45.065]   - Field: ‘state’
[16:06:45.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:45.065] - Launch lazy future ...
[16:06:45.066] Packages needed by the future expression (n = 1): ‘utils’
[16:06:45.066] Packages needed by future strategies (n = 0): <none>
[16:06:45.067] {
[16:06:45.067]     {
[16:06:45.067]         {
[16:06:45.067]             ...future.startTime <- base::Sys.time()
[16:06:45.067]             {
[16:06:45.067]                 {
[16:06:45.067]                   {
[16:06:45.067]                     {
[16:06:45.067]                       {
[16:06:45.067]                         base::local({
[16:06:45.067]                           has_future <- base::requireNamespace("future", 
[16:06:45.067]                             quietly = TRUE)
[16:06:45.067]                           if (has_future) {
[16:06:45.067]                             ns <- base::getNamespace("future")
[16:06:45.067]                             version <- ns[[".package"]][["version"]]
[16:06:45.067]                             if (is.null(version)) 
[16:06:45.067]                               version <- utils::packageVersion("future")
[16:06:45.067]                           }
[16:06:45.067]                           else {
[16:06:45.067]                             version <- NULL
[16:06:45.067]                           }
[16:06:45.067]                           if (!has_future || version < "1.8.0") {
[16:06:45.067]                             info <- base::c(r_version = base::gsub("R version ", 
[16:06:45.067]                               "", base::R.version$version.string), 
[16:06:45.067]                               platform = base::sprintf("%s (%s-bit)", 
[16:06:45.067]                                 base::R.version$platform, 8 * 
[16:06:45.067]                                   base::.Machine$sizeof.pointer), 
[16:06:45.067]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:45.067]                                 "release", "version")], collapse = " "), 
[16:06:45.067]                               hostname = base::Sys.info()[["nodename"]])
[16:06:45.067]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:06:45.067]                               info)
[16:06:45.067]                             info <- base::paste(info, collapse = "; ")
[16:06:45.067]                             if (!has_future) {
[16:06:45.067]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:45.067]                                 info)
[16:06:45.067]                             }
[16:06:45.067]                             else {
[16:06:45.067]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:45.067]                                 info, version)
[16:06:45.067]                             }
[16:06:45.067]                             base::stop(msg)
[16:06:45.067]                           }
[16:06:45.067]                         })
[16:06:45.067]                       }
[16:06:45.067]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:45.067]                       base::options(mc.cores = 1L)
[16:06:45.067]                     }
[16:06:45.067]                     base::local({
[16:06:45.067]                       for (pkg in "utils") {
[16:06:45.067]                         base::loadNamespace(pkg)
[16:06:45.067]                         base::library(pkg, character.only = TRUE)
[16:06:45.067]                       }
[16:06:45.067]                     })
[16:06:45.067]                   }
[16:06:45.067]                   options(future.plan = NULL)
[16:06:45.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:45.067]                 }
[16:06:45.067]                 ...future.workdir <- getwd()
[16:06:45.067]             }
[16:06:45.067]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:45.067]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:45.067]         }
[16:06:45.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:45.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:45.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:45.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:45.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:45.067]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:45.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:45.067]             base::names(...future.oldOptions))
[16:06:45.067]     }
[16:06:45.067]     if (FALSE) {
[16:06:45.067]     }
[16:06:45.067]     else {
[16:06:45.067]         if (TRUE) {
[16:06:45.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:45.067]                 open = "w")
[16:06:45.067]         }
[16:06:45.067]         else {
[16:06:45.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:45.067]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:45.067]         }
[16:06:45.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:45.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:45.067]             base::sink(type = "output", split = FALSE)
[16:06:45.067]             base::close(...future.stdout)
[16:06:45.067]         }, add = TRUE)
[16:06:45.067]     }
[16:06:45.067]     ...future.frame <- base::sys.nframe()
[16:06:45.067]     ...future.conditions <- base::list()
[16:06:45.067]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:45.067]     if (FALSE) {
[16:06:45.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:45.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:45.067]     }
[16:06:45.067]     ...future.result <- base::tryCatch({
[16:06:45.067]         base::withCallingHandlers({
[16:06:45.067]             ...future.value <- base::withVisible(base::local({
[16:06:45.067]                 ...future.makeSendCondition <- base::local({
[16:06:45.067]                   sendCondition <- NULL
[16:06:45.067]                   function(frame = 1L) {
[16:06:45.067]                     if (is.function(sendCondition)) 
[16:06:45.067]                       return(sendCondition)
[16:06:45.067]                     ns <- getNamespace("parallel")
[16:06:45.067]                     if (exists("sendData", mode = "function", 
[16:06:45.067]                       envir = ns)) {
[16:06:45.067]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:45.067]                         envir = ns)
[16:06:45.067]                       envir <- sys.frame(frame)
[16:06:45.067]                       master <- NULL
[16:06:45.067]                       while (!identical(envir, .GlobalEnv) && 
[16:06:45.067]                         !identical(envir, emptyenv())) {
[16:06:45.067]                         if (exists("master", mode = "list", envir = envir, 
[16:06:45.067]                           inherits = FALSE)) {
[16:06:45.067]                           master <- get("master", mode = "list", 
[16:06:45.067]                             envir = envir, inherits = FALSE)
[16:06:45.067]                           if (inherits(master, c("SOCKnode", 
[16:06:45.067]                             "SOCK0node"))) {
[16:06:45.067]                             sendCondition <<- function(cond) {
[16:06:45.067]                               data <- list(type = "VALUE", value = cond, 
[16:06:45.067]                                 success = TRUE)
[16:06:45.067]                               parallel_sendData(master, data)
[16:06:45.067]                             }
[16:06:45.067]                             return(sendCondition)
[16:06:45.067]                           }
[16:06:45.067]                         }
[16:06:45.067]                         frame <- frame + 1L
[16:06:45.067]                         envir <- sys.frame(frame)
[16:06:45.067]                       }
[16:06:45.067]                     }
[16:06:45.067]                     sendCondition <<- function(cond) NULL
[16:06:45.067]                   }
[16:06:45.067]                 })
[16:06:45.067]                 withCallingHandlers({
[16:06:45.067]                   {
[16:06:45.067]                     print(1:50)
[16:06:45.067]                     str(1:50)
[16:06:45.067]                     cat(letters, sep = "-")
[16:06:45.067]                     cat(1:6, collapse = "\n")
[16:06:45.067]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:45.067]                     42L
[16:06:45.067]                   }
[16:06:45.067]                 }, immediateCondition = function(cond) {
[16:06:45.067]                   sendCondition <- ...future.makeSendCondition()
[16:06:45.067]                   sendCondition(cond)
[16:06:45.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.067]                   {
[16:06:45.067]                     inherits <- base::inherits
[16:06:45.067]                     invokeRestart <- base::invokeRestart
[16:06:45.067]                     is.null <- base::is.null
[16:06:45.067]                     muffled <- FALSE
[16:06:45.067]                     if (inherits(cond, "message")) {
[16:06:45.067]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:45.067]                       if (muffled) 
[16:06:45.067]                         invokeRestart("muffleMessage")
[16:06:45.067]                     }
[16:06:45.067]                     else if (inherits(cond, "warning")) {
[16:06:45.067]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:45.067]                       if (muffled) 
[16:06:45.067]                         invokeRestart("muffleWarning")
[16:06:45.067]                     }
[16:06:45.067]                     else if (inherits(cond, "condition")) {
[16:06:45.067]                       if (!is.null(pattern)) {
[16:06:45.067]                         computeRestarts <- base::computeRestarts
[16:06:45.067]                         grepl <- base::grepl
[16:06:45.067]                         restarts <- computeRestarts(cond)
[16:06:45.067]                         for (restart in restarts) {
[16:06:45.067]                           name <- restart$name
[16:06:45.067]                           if (is.null(name)) 
[16:06:45.067]                             next
[16:06:45.067]                           if (!grepl(pattern, name)) 
[16:06:45.067]                             next
[16:06:45.067]                           invokeRestart(restart)
[16:06:45.067]                           muffled <- TRUE
[16:06:45.067]                           break
[16:06:45.067]                         }
[16:06:45.067]                       }
[16:06:45.067]                     }
[16:06:45.067]                     invisible(muffled)
[16:06:45.067]                   }
[16:06:45.067]                   muffleCondition(cond)
[16:06:45.067]                 })
[16:06:45.067]             }))
[16:06:45.067]             future::FutureResult(value = ...future.value$value, 
[16:06:45.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.067]                   ...future.rng), globalenv = if (FALSE) 
[16:06:45.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:45.067]                     ...future.globalenv.names))
[16:06:45.067]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:45.067]         }, condition = base::local({
[16:06:45.067]             c <- base::c
[16:06:45.067]             inherits <- base::inherits
[16:06:45.067]             invokeRestart <- base::invokeRestart
[16:06:45.067]             length <- base::length
[16:06:45.067]             list <- base::list
[16:06:45.067]             seq.int <- base::seq.int
[16:06:45.067]             signalCondition <- base::signalCondition
[16:06:45.067]             sys.calls <- base::sys.calls
[16:06:45.067]             `[[` <- base::`[[`
[16:06:45.067]             `+` <- base::`+`
[16:06:45.067]             `<<-` <- base::`<<-`
[16:06:45.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:45.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:45.067]                   3L)]
[16:06:45.067]             }
[16:06:45.067]             function(cond) {
[16:06:45.067]                 is_error <- inherits(cond, "error")
[16:06:45.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:45.067]                   NULL)
[16:06:45.067]                 if (is_error) {
[16:06:45.067]                   sessionInformation <- function() {
[16:06:45.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:45.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:45.067]                       search = base::search(), system = base::Sys.info())
[16:06:45.067]                   }
[16:06:45.067]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:45.067]                     cond$call), session = sessionInformation(), 
[16:06:45.067]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:45.067]                   signalCondition(cond)
[16:06:45.067]                 }
[16:06:45.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:45.067]                 "immediateCondition"))) {
[16:06:45.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:45.067]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:45.067]                   if (TRUE && !signal) {
[16:06:45.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.067]                     {
[16:06:45.067]                       inherits <- base::inherits
[16:06:45.067]                       invokeRestart <- base::invokeRestart
[16:06:45.067]                       is.null <- base::is.null
[16:06:45.067]                       muffled <- FALSE
[16:06:45.067]                       if (inherits(cond, "message")) {
[16:06:45.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.067]                         if (muffled) 
[16:06:45.067]                           invokeRestart("muffleMessage")
[16:06:45.067]                       }
[16:06:45.067]                       else if (inherits(cond, "warning")) {
[16:06:45.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.067]                         if (muffled) 
[16:06:45.067]                           invokeRestart("muffleWarning")
[16:06:45.067]                       }
[16:06:45.067]                       else if (inherits(cond, "condition")) {
[16:06:45.067]                         if (!is.null(pattern)) {
[16:06:45.067]                           computeRestarts <- base::computeRestarts
[16:06:45.067]                           grepl <- base::grepl
[16:06:45.067]                           restarts <- computeRestarts(cond)
[16:06:45.067]                           for (restart in restarts) {
[16:06:45.067]                             name <- restart$name
[16:06:45.067]                             if (is.null(name)) 
[16:06:45.067]                               next
[16:06:45.067]                             if (!grepl(pattern, name)) 
[16:06:45.067]                               next
[16:06:45.067]                             invokeRestart(restart)
[16:06:45.067]                             muffled <- TRUE
[16:06:45.067]                             break
[16:06:45.067]                           }
[16:06:45.067]                         }
[16:06:45.067]                       }
[16:06:45.067]                       invisible(muffled)
[16:06:45.067]                     }
[16:06:45.067]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.067]                   }
[16:06:45.067]                 }
[16:06:45.067]                 else {
[16:06:45.067]                   if (TRUE) {
[16:06:45.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.067]                     {
[16:06:45.067]                       inherits <- base::inherits
[16:06:45.067]                       invokeRestart <- base::invokeRestart
[16:06:45.067]                       is.null <- base::is.null
[16:06:45.067]                       muffled <- FALSE
[16:06:45.067]                       if (inherits(cond, "message")) {
[16:06:45.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.067]                         if (muffled) 
[16:06:45.067]                           invokeRestart("muffleMessage")
[16:06:45.067]                       }
[16:06:45.067]                       else if (inherits(cond, "warning")) {
[16:06:45.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.067]                         if (muffled) 
[16:06:45.067]                           invokeRestart("muffleWarning")
[16:06:45.067]                       }
[16:06:45.067]                       else if (inherits(cond, "condition")) {
[16:06:45.067]                         if (!is.null(pattern)) {
[16:06:45.067]                           computeRestarts <- base::computeRestarts
[16:06:45.067]                           grepl <- base::grepl
[16:06:45.067]                           restarts <- computeRestarts(cond)
[16:06:45.067]                           for (restart in restarts) {
[16:06:45.067]                             name <- restart$name
[16:06:45.067]                             if (is.null(name)) 
[16:06:45.067]                               next
[16:06:45.067]                             if (!grepl(pattern, name)) 
[16:06:45.067]                               next
[16:06:45.067]                             invokeRestart(restart)
[16:06:45.067]                             muffled <- TRUE
[16:06:45.067]                             break
[16:06:45.067]                           }
[16:06:45.067]                         }
[16:06:45.067]                       }
[16:06:45.067]                       invisible(muffled)
[16:06:45.067]                     }
[16:06:45.067]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.067]                   }
[16:06:45.067]                 }
[16:06:45.067]             }
[16:06:45.067]         }))
[16:06:45.067]     }, error = function(ex) {
[16:06:45.067]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:45.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.067]                 ...future.rng), started = ...future.startTime, 
[16:06:45.067]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:45.067]             version = "1.8"), class = "FutureResult")
[16:06:45.067]     }, finally = {
[16:06:45.067]         if (!identical(...future.workdir, getwd())) 
[16:06:45.067]             setwd(...future.workdir)
[16:06:45.067]         {
[16:06:45.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:45.067]                 ...future.oldOptions$nwarnings <- NULL
[16:06:45.067]             }
[16:06:45.067]             base::options(...future.oldOptions)
[16:06:45.067]             if (.Platform$OS.type == "windows") {
[16:06:45.067]                 old_names <- names(...future.oldEnvVars)
[16:06:45.067]                 envs <- base::Sys.getenv()
[16:06:45.067]                 names <- names(envs)
[16:06:45.067]                 common <- intersect(names, old_names)
[16:06:45.067]                 added <- setdiff(names, old_names)
[16:06:45.067]                 removed <- setdiff(old_names, names)
[16:06:45.067]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:45.067]                   envs[common]]
[16:06:45.067]                 NAMES <- toupper(changed)
[16:06:45.067]                 args <- list()
[16:06:45.067]                 for (kk in seq_along(NAMES)) {
[16:06:45.067]                   name <- changed[[kk]]
[16:06:45.067]                   NAME <- NAMES[[kk]]
[16:06:45.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.067]                     next
[16:06:45.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.067]                 }
[16:06:45.067]                 NAMES <- toupper(added)
[16:06:45.067]                 for (kk in seq_along(NAMES)) {
[16:06:45.067]                   name <- added[[kk]]
[16:06:45.067]                   NAME <- NAMES[[kk]]
[16:06:45.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.067]                     next
[16:06:45.067]                   args[[name]] <- ""
[16:06:45.067]                 }
[16:06:45.067]                 NAMES <- toupper(removed)
[16:06:45.067]                 for (kk in seq_along(NAMES)) {
[16:06:45.067]                   name <- removed[[kk]]
[16:06:45.067]                   NAME <- NAMES[[kk]]
[16:06:45.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.067]                     next
[16:06:45.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.067]                 }
[16:06:45.067]                 if (length(args) > 0) 
[16:06:45.067]                   base::do.call(base::Sys.setenv, args = args)
[16:06:45.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:45.067]             }
[16:06:45.067]             else {
[16:06:45.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:45.067]             }
[16:06:45.067]             {
[16:06:45.067]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:45.067]                   0L) {
[16:06:45.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:45.067]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:45.067]                   base::options(opts)
[16:06:45.067]                 }
[16:06:45.067]                 {
[16:06:45.067]                   {
[16:06:45.067]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:45.067]                     NULL
[16:06:45.067]                   }
[16:06:45.067]                   options(future.plan = NULL)
[16:06:45.067]                   if (is.na(NA_character_)) 
[16:06:45.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:45.067]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:45.067]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:45.067]                     envir = parent.frame()) 
[16:06:45.067]                   {
[16:06:45.067]                     if (is.function(workers)) 
[16:06:45.067]                       workers <- workers()
[16:06:45.067]                     workers <- structure(as.integer(workers), 
[16:06:45.067]                       class = class(workers))
[16:06:45.067]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:45.067]                       workers >= 1)
[16:06:45.067]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:45.067]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:45.067]                     }
[16:06:45.067]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:45.067]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:45.067]                       envir = envir)
[16:06:45.067]                     if (!future$lazy) 
[16:06:45.067]                       future <- run(future)
[16:06:45.067]                     invisible(future)
[16:06:45.067]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:45.067]                 }
[16:06:45.067]             }
[16:06:45.067]         }
[16:06:45.067]     })
[16:06:45.067]     if (TRUE) {
[16:06:45.067]         base::sink(type = "output", split = FALSE)
[16:06:45.067]         if (TRUE) {
[16:06:45.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:45.067]         }
[16:06:45.067]         else {
[16:06:45.067]             ...future.result["stdout"] <- base::list(NULL)
[16:06:45.067]         }
[16:06:45.067]         base::close(...future.stdout)
[16:06:45.067]         ...future.stdout <- NULL
[16:06:45.067]     }
[16:06:45.067]     ...future.result$conditions <- ...future.conditions
[16:06:45.067]     ...future.result$finished <- base::Sys.time()
[16:06:45.067]     ...future.result
[16:06:45.067] }
[16:06:45.070] MultisessionFuture started
[16:06:45.070] - Launch lazy future ... done
[16:06:45.070] run() for ‘MultisessionFuture’ ... done
[16:06:45.071] result() for ClusterFuture ...
[16:06:45.071] receiveMessageFromWorker() for ClusterFuture ...
[16:06:45.071] - Validating connection of MultisessionFuture
[16:06:45.118] - received message: FutureResult
[16:06:45.119] - Received FutureResult
[16:06:45.119] - Erased future from FutureRegistry
[16:06:45.119] result() for ClusterFuture ...
[16:06:45.119] - result already collected: FutureResult
[16:06:45.119] result() for ClusterFuture ... done
[16:06:45.119] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:45.119] result() for ClusterFuture ... done
[16:06:45.119] result() for ClusterFuture ...
[16:06:45.119] - result already collected: FutureResult
[16:06:45.119] result() for ClusterFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[16:06:45.120] getGlobalsAndPackages() ...
[16:06:45.120] Searching for globals...
[16:06:45.120] - globals found: [1] ‘print’
[16:06:45.121] Searching for globals ... DONE
[16:06:45.121] Resolving globals: FALSE
[16:06:45.121] 
[16:06:45.121] 
[16:06:45.121] getGlobalsAndPackages() ... DONE
[16:06:45.121] run() for ‘Future’ ...
[16:06:45.121] - state: ‘created’
[16:06:45.122] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:45.135] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:45.135] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:45.136]   - Field: ‘node’
[16:06:45.136]   - Field: ‘label’
[16:06:45.136]   - Field: ‘local’
[16:06:45.136]   - Field: ‘owner’
[16:06:45.136]   - Field: ‘envir’
[16:06:45.136]   - Field: ‘workers’
[16:06:45.136]   - Field: ‘packages’
[16:06:45.136]   - Field: ‘gc’
[16:06:45.136]   - Field: ‘conditions’
[16:06:45.136]   - Field: ‘persistent’
[16:06:45.136]   - Field: ‘expr’
[16:06:45.137]   - Field: ‘uuid’
[16:06:45.137]   - Field: ‘seed’
[16:06:45.137]   - Field: ‘version’
[16:06:45.137]   - Field: ‘result’
[16:06:45.137]   - Field: ‘asynchronous’
[16:06:45.137]   - Field: ‘calls’
[16:06:45.137]   - Field: ‘globals’
[16:06:45.137]   - Field: ‘stdout’
[16:06:45.137]   - Field: ‘earlySignal’
[16:06:45.137]   - Field: ‘lazy’
[16:06:45.137]   - Field: ‘state’
[16:06:45.138] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:45.138] - Launch lazy future ...
[16:06:45.138] Packages needed by the future expression (n = 0): <none>
[16:06:45.138] Packages needed by future strategies (n = 0): <none>
[16:06:45.138] {
[16:06:45.138]     {
[16:06:45.138]         {
[16:06:45.138]             ...future.startTime <- base::Sys.time()
[16:06:45.138]             {
[16:06:45.138]                 {
[16:06:45.138]                   {
[16:06:45.138]                     {
[16:06:45.138]                       base::local({
[16:06:45.138]                         has_future <- base::requireNamespace("future", 
[16:06:45.138]                           quietly = TRUE)
[16:06:45.138]                         if (has_future) {
[16:06:45.138]                           ns <- base::getNamespace("future")
[16:06:45.138]                           version <- ns[[".package"]][["version"]]
[16:06:45.138]                           if (is.null(version)) 
[16:06:45.138]                             version <- utils::packageVersion("future")
[16:06:45.138]                         }
[16:06:45.138]                         else {
[16:06:45.138]                           version <- NULL
[16:06:45.138]                         }
[16:06:45.138]                         if (!has_future || version < "1.8.0") {
[16:06:45.138]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:45.138]                             "", base::R.version$version.string), 
[16:06:45.138]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:45.138]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:45.138]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:45.138]                               "release", "version")], collapse = " "), 
[16:06:45.138]                             hostname = base::Sys.info()[["nodename"]])
[16:06:45.138]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:45.138]                             info)
[16:06:45.138]                           info <- base::paste(info, collapse = "; ")
[16:06:45.138]                           if (!has_future) {
[16:06:45.138]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:45.138]                               info)
[16:06:45.138]                           }
[16:06:45.138]                           else {
[16:06:45.138]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:45.138]                               info, version)
[16:06:45.138]                           }
[16:06:45.138]                           base::stop(msg)
[16:06:45.138]                         }
[16:06:45.138]                       })
[16:06:45.138]                     }
[16:06:45.138]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:45.138]                     base::options(mc.cores = 1L)
[16:06:45.138]                   }
[16:06:45.138]                   options(future.plan = NULL)
[16:06:45.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:45.138]                 }
[16:06:45.138]                 ...future.workdir <- getwd()
[16:06:45.138]             }
[16:06:45.138]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:45.138]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:45.138]         }
[16:06:45.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:45.138]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:45.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:45.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:45.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:45.138]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:45.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:45.138]             base::names(...future.oldOptions))
[16:06:45.138]     }
[16:06:45.138]     if (FALSE) {
[16:06:45.138]     }
[16:06:45.138]     else {
[16:06:45.138]         if (TRUE) {
[16:06:45.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:45.138]                 open = "w")
[16:06:45.138]         }
[16:06:45.138]         else {
[16:06:45.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:45.138]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:45.138]         }
[16:06:45.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:45.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:45.138]             base::sink(type = "output", split = FALSE)
[16:06:45.138]             base::close(...future.stdout)
[16:06:45.138]         }, add = TRUE)
[16:06:45.138]     }
[16:06:45.138]     ...future.frame <- base::sys.nframe()
[16:06:45.138]     ...future.conditions <- base::list()
[16:06:45.138]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:45.138]     if (FALSE) {
[16:06:45.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:45.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:45.138]     }
[16:06:45.138]     ...future.result <- base::tryCatch({
[16:06:45.138]         base::withCallingHandlers({
[16:06:45.138]             ...future.value <- base::withVisible(base::local({
[16:06:45.138]                 ...future.makeSendCondition <- base::local({
[16:06:45.138]                   sendCondition <- NULL
[16:06:45.138]                   function(frame = 1L) {
[16:06:45.138]                     if (is.function(sendCondition)) 
[16:06:45.138]                       return(sendCondition)
[16:06:45.138]                     ns <- getNamespace("parallel")
[16:06:45.138]                     if (exists("sendData", mode = "function", 
[16:06:45.138]                       envir = ns)) {
[16:06:45.138]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:45.138]                         envir = ns)
[16:06:45.138]                       envir <- sys.frame(frame)
[16:06:45.138]                       master <- NULL
[16:06:45.138]                       while (!identical(envir, .GlobalEnv) && 
[16:06:45.138]                         !identical(envir, emptyenv())) {
[16:06:45.138]                         if (exists("master", mode = "list", envir = envir, 
[16:06:45.138]                           inherits = FALSE)) {
[16:06:45.138]                           master <- get("master", mode = "list", 
[16:06:45.138]                             envir = envir, inherits = FALSE)
[16:06:45.138]                           if (inherits(master, c("SOCKnode", 
[16:06:45.138]                             "SOCK0node"))) {
[16:06:45.138]                             sendCondition <<- function(cond) {
[16:06:45.138]                               data <- list(type = "VALUE", value = cond, 
[16:06:45.138]                                 success = TRUE)
[16:06:45.138]                               parallel_sendData(master, data)
[16:06:45.138]                             }
[16:06:45.138]                             return(sendCondition)
[16:06:45.138]                           }
[16:06:45.138]                         }
[16:06:45.138]                         frame <- frame + 1L
[16:06:45.138]                         envir <- sys.frame(frame)
[16:06:45.138]                       }
[16:06:45.138]                     }
[16:06:45.138]                     sendCondition <<- function(cond) NULL
[16:06:45.138]                   }
[16:06:45.138]                 })
[16:06:45.138]                 withCallingHandlers({
[16:06:45.138]                   print(42)
[16:06:45.138]                 }, immediateCondition = function(cond) {
[16:06:45.138]                   sendCondition <- ...future.makeSendCondition()
[16:06:45.138]                   sendCondition(cond)
[16:06:45.138]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.138]                   {
[16:06:45.138]                     inherits <- base::inherits
[16:06:45.138]                     invokeRestart <- base::invokeRestart
[16:06:45.138]                     is.null <- base::is.null
[16:06:45.138]                     muffled <- FALSE
[16:06:45.138]                     if (inherits(cond, "message")) {
[16:06:45.138]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:45.138]                       if (muffled) 
[16:06:45.138]                         invokeRestart("muffleMessage")
[16:06:45.138]                     }
[16:06:45.138]                     else if (inherits(cond, "warning")) {
[16:06:45.138]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:45.138]                       if (muffled) 
[16:06:45.138]                         invokeRestart("muffleWarning")
[16:06:45.138]                     }
[16:06:45.138]                     else if (inherits(cond, "condition")) {
[16:06:45.138]                       if (!is.null(pattern)) {
[16:06:45.138]                         computeRestarts <- base::computeRestarts
[16:06:45.138]                         grepl <- base::grepl
[16:06:45.138]                         restarts <- computeRestarts(cond)
[16:06:45.138]                         for (restart in restarts) {
[16:06:45.138]                           name <- restart$name
[16:06:45.138]                           if (is.null(name)) 
[16:06:45.138]                             next
[16:06:45.138]                           if (!grepl(pattern, name)) 
[16:06:45.138]                             next
[16:06:45.138]                           invokeRestart(restart)
[16:06:45.138]                           muffled <- TRUE
[16:06:45.138]                           break
[16:06:45.138]                         }
[16:06:45.138]                       }
[16:06:45.138]                     }
[16:06:45.138]                     invisible(muffled)
[16:06:45.138]                   }
[16:06:45.138]                   muffleCondition(cond)
[16:06:45.138]                 })
[16:06:45.138]             }))
[16:06:45.138]             future::FutureResult(value = ...future.value$value, 
[16:06:45.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.138]                   ...future.rng), globalenv = if (FALSE) 
[16:06:45.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:45.138]                     ...future.globalenv.names))
[16:06:45.138]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:45.138]         }, condition = base::local({
[16:06:45.138]             c <- base::c
[16:06:45.138]             inherits <- base::inherits
[16:06:45.138]             invokeRestart <- base::invokeRestart
[16:06:45.138]             length <- base::length
[16:06:45.138]             list <- base::list
[16:06:45.138]             seq.int <- base::seq.int
[16:06:45.138]             signalCondition <- base::signalCondition
[16:06:45.138]             sys.calls <- base::sys.calls
[16:06:45.138]             `[[` <- base::`[[`
[16:06:45.138]             `+` <- base::`+`
[16:06:45.138]             `<<-` <- base::`<<-`
[16:06:45.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:45.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:45.138]                   3L)]
[16:06:45.138]             }
[16:06:45.138]             function(cond) {
[16:06:45.138]                 is_error <- inherits(cond, "error")
[16:06:45.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:45.138]                   NULL)
[16:06:45.138]                 if (is_error) {
[16:06:45.138]                   sessionInformation <- function() {
[16:06:45.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:45.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:45.138]                       search = base::search(), system = base::Sys.info())
[16:06:45.138]                   }
[16:06:45.138]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:45.138]                     cond$call), session = sessionInformation(), 
[16:06:45.138]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:45.138]                   signalCondition(cond)
[16:06:45.138]                 }
[16:06:45.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:45.138]                 "immediateCondition"))) {
[16:06:45.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:45.138]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:45.138]                   if (TRUE && !signal) {
[16:06:45.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.138]                     {
[16:06:45.138]                       inherits <- base::inherits
[16:06:45.138]                       invokeRestart <- base::invokeRestart
[16:06:45.138]                       is.null <- base::is.null
[16:06:45.138]                       muffled <- FALSE
[16:06:45.138]                       if (inherits(cond, "message")) {
[16:06:45.138]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.138]                         if (muffled) 
[16:06:45.138]                           invokeRestart("muffleMessage")
[16:06:45.138]                       }
[16:06:45.138]                       else if (inherits(cond, "warning")) {
[16:06:45.138]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.138]                         if (muffled) 
[16:06:45.138]                           invokeRestart("muffleWarning")
[16:06:45.138]                       }
[16:06:45.138]                       else if (inherits(cond, "condition")) {
[16:06:45.138]                         if (!is.null(pattern)) {
[16:06:45.138]                           computeRestarts <- base::computeRestarts
[16:06:45.138]                           grepl <- base::grepl
[16:06:45.138]                           restarts <- computeRestarts(cond)
[16:06:45.138]                           for (restart in restarts) {
[16:06:45.138]                             name <- restart$name
[16:06:45.138]                             if (is.null(name)) 
[16:06:45.138]                               next
[16:06:45.138]                             if (!grepl(pattern, name)) 
[16:06:45.138]                               next
[16:06:45.138]                             invokeRestart(restart)
[16:06:45.138]                             muffled <- TRUE
[16:06:45.138]                             break
[16:06:45.138]                           }
[16:06:45.138]                         }
[16:06:45.138]                       }
[16:06:45.138]                       invisible(muffled)
[16:06:45.138]                     }
[16:06:45.138]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.138]                   }
[16:06:45.138]                 }
[16:06:45.138]                 else {
[16:06:45.138]                   if (TRUE) {
[16:06:45.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.138]                     {
[16:06:45.138]                       inherits <- base::inherits
[16:06:45.138]                       invokeRestart <- base::invokeRestart
[16:06:45.138]                       is.null <- base::is.null
[16:06:45.138]                       muffled <- FALSE
[16:06:45.138]                       if (inherits(cond, "message")) {
[16:06:45.138]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.138]                         if (muffled) 
[16:06:45.138]                           invokeRestart("muffleMessage")
[16:06:45.138]                       }
[16:06:45.138]                       else if (inherits(cond, "warning")) {
[16:06:45.138]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.138]                         if (muffled) 
[16:06:45.138]                           invokeRestart("muffleWarning")
[16:06:45.138]                       }
[16:06:45.138]                       else if (inherits(cond, "condition")) {
[16:06:45.138]                         if (!is.null(pattern)) {
[16:06:45.138]                           computeRestarts <- base::computeRestarts
[16:06:45.138]                           grepl <- base::grepl
[16:06:45.138]                           restarts <- computeRestarts(cond)
[16:06:45.138]                           for (restart in restarts) {
[16:06:45.138]                             name <- restart$name
[16:06:45.138]                             if (is.null(name)) 
[16:06:45.138]                               next
[16:06:45.138]                             if (!grepl(pattern, name)) 
[16:06:45.138]                               next
[16:06:45.138]                             invokeRestart(restart)
[16:06:45.138]                             muffled <- TRUE
[16:06:45.138]                             break
[16:06:45.138]                           }
[16:06:45.138]                         }
[16:06:45.138]                       }
[16:06:45.138]                       invisible(muffled)
[16:06:45.138]                     }
[16:06:45.138]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.138]                   }
[16:06:45.138]                 }
[16:06:45.138]             }
[16:06:45.138]         }))
[16:06:45.138]     }, error = function(ex) {
[16:06:45.138]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:45.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.138]                 ...future.rng), started = ...future.startTime, 
[16:06:45.138]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:45.138]             version = "1.8"), class = "FutureResult")
[16:06:45.138]     }, finally = {
[16:06:45.138]         if (!identical(...future.workdir, getwd())) 
[16:06:45.138]             setwd(...future.workdir)
[16:06:45.138]         {
[16:06:45.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:45.138]                 ...future.oldOptions$nwarnings <- NULL
[16:06:45.138]             }
[16:06:45.138]             base::options(...future.oldOptions)
[16:06:45.138]             if (.Platform$OS.type == "windows") {
[16:06:45.138]                 old_names <- names(...future.oldEnvVars)
[16:06:45.138]                 envs <- base::Sys.getenv()
[16:06:45.138]                 names <- names(envs)
[16:06:45.138]                 common <- intersect(names, old_names)
[16:06:45.138]                 added <- setdiff(names, old_names)
[16:06:45.138]                 removed <- setdiff(old_names, names)
[16:06:45.138]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:45.138]                   envs[common]]
[16:06:45.138]                 NAMES <- toupper(changed)
[16:06:45.138]                 args <- list()
[16:06:45.138]                 for (kk in seq_along(NAMES)) {
[16:06:45.138]                   name <- changed[[kk]]
[16:06:45.138]                   NAME <- NAMES[[kk]]
[16:06:45.138]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.138]                     next
[16:06:45.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.138]                 }
[16:06:45.138]                 NAMES <- toupper(added)
[16:06:45.138]                 for (kk in seq_along(NAMES)) {
[16:06:45.138]                   name <- added[[kk]]
[16:06:45.138]                   NAME <- NAMES[[kk]]
[16:06:45.138]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.138]                     next
[16:06:45.138]                   args[[name]] <- ""
[16:06:45.138]                 }
[16:06:45.138]                 NAMES <- toupper(removed)
[16:06:45.138]                 for (kk in seq_along(NAMES)) {
[16:06:45.138]                   name <- removed[[kk]]
[16:06:45.138]                   NAME <- NAMES[[kk]]
[16:06:45.138]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.138]                     next
[16:06:45.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.138]                 }
[16:06:45.138]                 if (length(args) > 0) 
[16:06:45.138]                   base::do.call(base::Sys.setenv, args = args)
[16:06:45.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:45.138]             }
[16:06:45.138]             else {
[16:06:45.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:45.138]             }
[16:06:45.138]             {
[16:06:45.138]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:45.138]                   0L) {
[16:06:45.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:45.138]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:45.138]                   base::options(opts)
[16:06:45.138]                 }
[16:06:45.138]                 {
[16:06:45.138]                   {
[16:06:45.138]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:45.138]                     NULL
[16:06:45.138]                   }
[16:06:45.138]                   options(future.plan = NULL)
[16:06:45.138]                   if (is.na(NA_character_)) 
[16:06:45.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:45.138]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:45.138]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:45.138]                     envir = parent.frame()) 
[16:06:45.138]                   {
[16:06:45.138]                     if (is.function(workers)) 
[16:06:45.138]                       workers <- workers()
[16:06:45.138]                     workers <- structure(as.integer(workers), 
[16:06:45.138]                       class = class(workers))
[16:06:45.138]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:45.138]                       workers >= 1)
[16:06:45.138]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:45.138]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:45.138]                     }
[16:06:45.138]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:45.138]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:45.138]                       envir = envir)
[16:06:45.138]                     if (!future$lazy) 
[16:06:45.138]                       future <- run(future)
[16:06:45.138]                     invisible(future)
[16:06:45.138]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:45.138]                 }
[16:06:45.138]             }
[16:06:45.138]         }
[16:06:45.138]     })
[16:06:45.138]     if (TRUE) {
[16:06:45.138]         base::sink(type = "output", split = FALSE)
[16:06:45.138]         if (TRUE) {
[16:06:45.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:45.138]         }
[16:06:45.138]         else {
[16:06:45.138]             ...future.result["stdout"] <- base::list(NULL)
[16:06:45.138]         }
[16:06:45.138]         base::close(...future.stdout)
[16:06:45.138]         ...future.stdout <- NULL
[16:06:45.138]     }
[16:06:45.138]     ...future.result$conditions <- ...future.conditions
[16:06:45.138]     ...future.result$finished <- base::Sys.time()
[16:06:45.138]     ...future.result
[16:06:45.138] }
[16:06:45.141] MultisessionFuture started
[16:06:45.142] - Launch lazy future ... done
[16:06:45.142] run() for ‘MultisessionFuture’ ... done
[16:06:45.142] result() for ClusterFuture ...
[16:06:45.142] receiveMessageFromWorker() for ClusterFuture ...
[16:06:45.142] - Validating connection of MultisessionFuture
[16:06:45.191] - received message: FutureResult
[16:06:45.191] - Received FutureResult
[16:06:45.192] - Erased future from FutureRegistry
[16:06:45.192] result() for ClusterFuture ...
[16:06:45.192] - result already collected: FutureResult
[16:06:45.192] result() for ClusterFuture ... done
[16:06:45.192] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:45.192] result() for ClusterFuture ... done
[16:06:45.192] result() for ClusterFuture ...
[16:06:45.192] - result already collected: FutureResult
[16:06:45.192] result() for ClusterFuture ... done
[16:06:45.192] result() for ClusterFuture ...
[16:06:45.193] - result already collected: FutureResult
[16:06:45.193] result() for ClusterFuture ... done
[1] 42
[16:06:45.193] result() for ClusterFuture ...
[16:06:45.193] - result already collected: FutureResult
[16:06:45.193] result() for ClusterFuture ... done
- stdout = FALSE
[16:06:45.193] getGlobalsAndPackages() ...
[16:06:45.193] Searching for globals...
[16:06:45.196] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:45.196] Searching for globals ... DONE
[16:06:45.196] Resolving globals: FALSE
[16:06:45.197] 
[16:06:45.197] - packages: [1] ‘utils’
[16:06:45.197] getGlobalsAndPackages() ... DONE
[16:06:45.197] run() for ‘Future’ ...
[16:06:45.197] - state: ‘created’
[16:06:45.197] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:45.211] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:45.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:45.211]   - Field: ‘node’
[16:06:45.211]   - Field: ‘label’
[16:06:45.211]   - Field: ‘local’
[16:06:45.211]   - Field: ‘owner’
[16:06:45.211]   - Field: ‘envir’
[16:06:45.211]   - Field: ‘workers’
[16:06:45.212]   - Field: ‘packages’
[16:06:45.212]   - Field: ‘gc’
[16:06:45.212]   - Field: ‘conditions’
[16:06:45.212]   - Field: ‘persistent’
[16:06:45.212]   - Field: ‘expr’
[16:06:45.212]   - Field: ‘uuid’
[16:06:45.212]   - Field: ‘seed’
[16:06:45.212]   - Field: ‘version’
[16:06:45.212]   - Field: ‘result’
[16:06:45.212]   - Field: ‘asynchronous’
[16:06:45.212]   - Field: ‘calls’
[16:06:45.213]   - Field: ‘globals’
[16:06:45.213]   - Field: ‘stdout’
[16:06:45.213]   - Field: ‘earlySignal’
[16:06:45.213]   - Field: ‘lazy’
[16:06:45.213]   - Field: ‘state’
[16:06:45.213] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:45.213] - Launch lazy future ...
[16:06:45.213] Packages needed by the future expression (n = 1): ‘utils’
[16:06:45.213] Packages needed by future strategies (n = 0): <none>
[16:06:45.214] {
[16:06:45.214]     {
[16:06:45.214]         {
[16:06:45.214]             ...future.startTime <- base::Sys.time()
[16:06:45.214]             {
[16:06:45.214]                 {
[16:06:45.214]                   {
[16:06:45.214]                     {
[16:06:45.214]                       {
[16:06:45.214]                         base::local({
[16:06:45.214]                           has_future <- base::requireNamespace("future", 
[16:06:45.214]                             quietly = TRUE)
[16:06:45.214]                           if (has_future) {
[16:06:45.214]                             ns <- base::getNamespace("future")
[16:06:45.214]                             version <- ns[[".package"]][["version"]]
[16:06:45.214]                             if (is.null(version)) 
[16:06:45.214]                               version <- utils::packageVersion("future")
[16:06:45.214]                           }
[16:06:45.214]                           else {
[16:06:45.214]                             version <- NULL
[16:06:45.214]                           }
[16:06:45.214]                           if (!has_future || version < "1.8.0") {
[16:06:45.214]                             info <- base::c(r_version = base::gsub("R version ", 
[16:06:45.214]                               "", base::R.version$version.string), 
[16:06:45.214]                               platform = base::sprintf("%s (%s-bit)", 
[16:06:45.214]                                 base::R.version$platform, 8 * 
[16:06:45.214]                                   base::.Machine$sizeof.pointer), 
[16:06:45.214]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:45.214]                                 "release", "version")], collapse = " "), 
[16:06:45.214]                               hostname = base::Sys.info()[["nodename"]])
[16:06:45.214]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:06:45.214]                               info)
[16:06:45.214]                             info <- base::paste(info, collapse = "; ")
[16:06:45.214]                             if (!has_future) {
[16:06:45.214]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:45.214]                                 info)
[16:06:45.214]                             }
[16:06:45.214]                             else {
[16:06:45.214]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:45.214]                                 info, version)
[16:06:45.214]                             }
[16:06:45.214]                             base::stop(msg)
[16:06:45.214]                           }
[16:06:45.214]                         })
[16:06:45.214]                       }
[16:06:45.214]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:45.214]                       base::options(mc.cores = 1L)
[16:06:45.214]                     }
[16:06:45.214]                     base::local({
[16:06:45.214]                       for (pkg in "utils") {
[16:06:45.214]                         base::loadNamespace(pkg)
[16:06:45.214]                         base::library(pkg, character.only = TRUE)
[16:06:45.214]                       }
[16:06:45.214]                     })
[16:06:45.214]                   }
[16:06:45.214]                   options(future.plan = NULL)
[16:06:45.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:45.214]                 }
[16:06:45.214]                 ...future.workdir <- getwd()
[16:06:45.214]             }
[16:06:45.214]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:45.214]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:45.214]         }
[16:06:45.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:45.214]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:45.214]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:45.214]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:45.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:45.214]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:45.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:45.214]             base::names(...future.oldOptions))
[16:06:45.214]     }
[16:06:45.214]     if (FALSE) {
[16:06:45.214]     }
[16:06:45.214]     else {
[16:06:45.214]         if (FALSE) {
[16:06:45.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:45.214]                 open = "w")
[16:06:45.214]         }
[16:06:45.214]         else {
[16:06:45.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:45.214]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:45.214]         }
[16:06:45.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:45.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:45.214]             base::sink(type = "output", split = FALSE)
[16:06:45.214]             base::close(...future.stdout)
[16:06:45.214]         }, add = TRUE)
[16:06:45.214]     }
[16:06:45.214]     ...future.frame <- base::sys.nframe()
[16:06:45.214]     ...future.conditions <- base::list()
[16:06:45.214]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:45.214]     if (FALSE) {
[16:06:45.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:45.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:45.214]     }
[16:06:45.214]     ...future.result <- base::tryCatch({
[16:06:45.214]         base::withCallingHandlers({
[16:06:45.214]             ...future.value <- base::withVisible(base::local({
[16:06:45.214]                 ...future.makeSendCondition <- base::local({
[16:06:45.214]                   sendCondition <- NULL
[16:06:45.214]                   function(frame = 1L) {
[16:06:45.214]                     if (is.function(sendCondition)) 
[16:06:45.214]                       return(sendCondition)
[16:06:45.214]                     ns <- getNamespace("parallel")
[16:06:45.214]                     if (exists("sendData", mode = "function", 
[16:06:45.214]                       envir = ns)) {
[16:06:45.214]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:45.214]                         envir = ns)
[16:06:45.214]                       envir <- sys.frame(frame)
[16:06:45.214]                       master <- NULL
[16:06:45.214]                       while (!identical(envir, .GlobalEnv) && 
[16:06:45.214]                         !identical(envir, emptyenv())) {
[16:06:45.214]                         if (exists("master", mode = "list", envir = envir, 
[16:06:45.214]                           inherits = FALSE)) {
[16:06:45.214]                           master <- get("master", mode = "list", 
[16:06:45.214]                             envir = envir, inherits = FALSE)
[16:06:45.214]                           if (inherits(master, c("SOCKnode", 
[16:06:45.214]                             "SOCK0node"))) {
[16:06:45.214]                             sendCondition <<- function(cond) {
[16:06:45.214]                               data <- list(type = "VALUE", value = cond, 
[16:06:45.214]                                 success = TRUE)
[16:06:45.214]                               parallel_sendData(master, data)
[16:06:45.214]                             }
[16:06:45.214]                             return(sendCondition)
[16:06:45.214]                           }
[16:06:45.214]                         }
[16:06:45.214]                         frame <- frame + 1L
[16:06:45.214]                         envir <- sys.frame(frame)
[16:06:45.214]                       }
[16:06:45.214]                     }
[16:06:45.214]                     sendCondition <<- function(cond) NULL
[16:06:45.214]                   }
[16:06:45.214]                 })
[16:06:45.214]                 withCallingHandlers({
[16:06:45.214]                   {
[16:06:45.214]                     print(1:50)
[16:06:45.214]                     str(1:50)
[16:06:45.214]                     cat(letters, sep = "-")
[16:06:45.214]                     cat(1:6, collapse = "\n")
[16:06:45.214]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:45.214]                     42L
[16:06:45.214]                   }
[16:06:45.214]                 }, immediateCondition = function(cond) {
[16:06:45.214]                   sendCondition <- ...future.makeSendCondition()
[16:06:45.214]                   sendCondition(cond)
[16:06:45.214]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.214]                   {
[16:06:45.214]                     inherits <- base::inherits
[16:06:45.214]                     invokeRestart <- base::invokeRestart
[16:06:45.214]                     is.null <- base::is.null
[16:06:45.214]                     muffled <- FALSE
[16:06:45.214]                     if (inherits(cond, "message")) {
[16:06:45.214]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:45.214]                       if (muffled) 
[16:06:45.214]                         invokeRestart("muffleMessage")
[16:06:45.214]                     }
[16:06:45.214]                     else if (inherits(cond, "warning")) {
[16:06:45.214]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:45.214]                       if (muffled) 
[16:06:45.214]                         invokeRestart("muffleWarning")
[16:06:45.214]                     }
[16:06:45.214]                     else if (inherits(cond, "condition")) {
[16:06:45.214]                       if (!is.null(pattern)) {
[16:06:45.214]                         computeRestarts <- base::computeRestarts
[16:06:45.214]                         grepl <- base::grepl
[16:06:45.214]                         restarts <- computeRestarts(cond)
[16:06:45.214]                         for (restart in restarts) {
[16:06:45.214]                           name <- restart$name
[16:06:45.214]                           if (is.null(name)) 
[16:06:45.214]                             next
[16:06:45.214]                           if (!grepl(pattern, name)) 
[16:06:45.214]                             next
[16:06:45.214]                           invokeRestart(restart)
[16:06:45.214]                           muffled <- TRUE
[16:06:45.214]                           break
[16:06:45.214]                         }
[16:06:45.214]                       }
[16:06:45.214]                     }
[16:06:45.214]                     invisible(muffled)
[16:06:45.214]                   }
[16:06:45.214]                   muffleCondition(cond)
[16:06:45.214]                 })
[16:06:45.214]             }))
[16:06:45.214]             future::FutureResult(value = ...future.value$value, 
[16:06:45.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.214]                   ...future.rng), globalenv = if (FALSE) 
[16:06:45.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:45.214]                     ...future.globalenv.names))
[16:06:45.214]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:45.214]         }, condition = base::local({
[16:06:45.214]             c <- base::c
[16:06:45.214]             inherits <- base::inherits
[16:06:45.214]             invokeRestart <- base::invokeRestart
[16:06:45.214]             length <- base::length
[16:06:45.214]             list <- base::list
[16:06:45.214]             seq.int <- base::seq.int
[16:06:45.214]             signalCondition <- base::signalCondition
[16:06:45.214]             sys.calls <- base::sys.calls
[16:06:45.214]             `[[` <- base::`[[`
[16:06:45.214]             `+` <- base::`+`
[16:06:45.214]             `<<-` <- base::`<<-`
[16:06:45.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:45.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:45.214]                   3L)]
[16:06:45.214]             }
[16:06:45.214]             function(cond) {
[16:06:45.214]                 is_error <- inherits(cond, "error")
[16:06:45.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:45.214]                   NULL)
[16:06:45.214]                 if (is_error) {
[16:06:45.214]                   sessionInformation <- function() {
[16:06:45.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:45.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:45.214]                       search = base::search(), system = base::Sys.info())
[16:06:45.214]                   }
[16:06:45.214]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:45.214]                     cond$call), session = sessionInformation(), 
[16:06:45.214]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:45.214]                   signalCondition(cond)
[16:06:45.214]                 }
[16:06:45.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:45.214]                 "immediateCondition"))) {
[16:06:45.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:45.214]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:45.214]                   if (TRUE && !signal) {
[16:06:45.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.214]                     {
[16:06:45.214]                       inherits <- base::inherits
[16:06:45.214]                       invokeRestart <- base::invokeRestart
[16:06:45.214]                       is.null <- base::is.null
[16:06:45.214]                       muffled <- FALSE
[16:06:45.214]                       if (inherits(cond, "message")) {
[16:06:45.214]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.214]                         if (muffled) 
[16:06:45.214]                           invokeRestart("muffleMessage")
[16:06:45.214]                       }
[16:06:45.214]                       else if (inherits(cond, "warning")) {
[16:06:45.214]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.214]                         if (muffled) 
[16:06:45.214]                           invokeRestart("muffleWarning")
[16:06:45.214]                       }
[16:06:45.214]                       else if (inherits(cond, "condition")) {
[16:06:45.214]                         if (!is.null(pattern)) {
[16:06:45.214]                           computeRestarts <- base::computeRestarts
[16:06:45.214]                           grepl <- base::grepl
[16:06:45.214]                           restarts <- computeRestarts(cond)
[16:06:45.214]                           for (restart in restarts) {
[16:06:45.214]                             name <- restart$name
[16:06:45.214]                             if (is.null(name)) 
[16:06:45.214]                               next
[16:06:45.214]                             if (!grepl(pattern, name)) 
[16:06:45.214]                               next
[16:06:45.214]                             invokeRestart(restart)
[16:06:45.214]                             muffled <- TRUE
[16:06:45.214]                             break
[16:06:45.214]                           }
[16:06:45.214]                         }
[16:06:45.214]                       }
[16:06:45.214]                       invisible(muffled)
[16:06:45.214]                     }
[16:06:45.214]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.214]                   }
[16:06:45.214]                 }
[16:06:45.214]                 else {
[16:06:45.214]                   if (TRUE) {
[16:06:45.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.214]                     {
[16:06:45.214]                       inherits <- base::inherits
[16:06:45.214]                       invokeRestart <- base::invokeRestart
[16:06:45.214]                       is.null <- base::is.null
[16:06:45.214]                       muffled <- FALSE
[16:06:45.214]                       if (inherits(cond, "message")) {
[16:06:45.214]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.214]                         if (muffled) 
[16:06:45.214]                           invokeRestart("muffleMessage")
[16:06:45.214]                       }
[16:06:45.214]                       else if (inherits(cond, "warning")) {
[16:06:45.214]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.214]                         if (muffled) 
[16:06:45.214]                           invokeRestart("muffleWarning")
[16:06:45.214]                       }
[16:06:45.214]                       else if (inherits(cond, "condition")) {
[16:06:45.214]                         if (!is.null(pattern)) {
[16:06:45.214]                           computeRestarts <- base::computeRestarts
[16:06:45.214]                           grepl <- base::grepl
[16:06:45.214]                           restarts <- computeRestarts(cond)
[16:06:45.214]                           for (restart in restarts) {
[16:06:45.214]                             name <- restart$name
[16:06:45.214]                             if (is.null(name)) 
[16:06:45.214]                               next
[16:06:45.214]                             if (!grepl(pattern, name)) 
[16:06:45.214]                               next
[16:06:45.214]                             invokeRestart(restart)
[16:06:45.214]                             muffled <- TRUE
[16:06:45.214]                             break
[16:06:45.214]                           }
[16:06:45.214]                         }
[16:06:45.214]                       }
[16:06:45.214]                       invisible(muffled)
[16:06:45.214]                     }
[16:06:45.214]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.214]                   }
[16:06:45.214]                 }
[16:06:45.214]             }
[16:06:45.214]         }))
[16:06:45.214]     }, error = function(ex) {
[16:06:45.214]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:45.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.214]                 ...future.rng), started = ...future.startTime, 
[16:06:45.214]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:45.214]             version = "1.8"), class = "FutureResult")
[16:06:45.214]     }, finally = {
[16:06:45.214]         if (!identical(...future.workdir, getwd())) 
[16:06:45.214]             setwd(...future.workdir)
[16:06:45.214]         {
[16:06:45.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:45.214]                 ...future.oldOptions$nwarnings <- NULL
[16:06:45.214]             }
[16:06:45.214]             base::options(...future.oldOptions)
[16:06:45.214]             if (.Platform$OS.type == "windows") {
[16:06:45.214]                 old_names <- names(...future.oldEnvVars)
[16:06:45.214]                 envs <- base::Sys.getenv()
[16:06:45.214]                 names <- names(envs)
[16:06:45.214]                 common <- intersect(names, old_names)
[16:06:45.214]                 added <- setdiff(names, old_names)
[16:06:45.214]                 removed <- setdiff(old_names, names)
[16:06:45.214]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:45.214]                   envs[common]]
[16:06:45.214]                 NAMES <- toupper(changed)
[16:06:45.214]                 args <- list()
[16:06:45.214]                 for (kk in seq_along(NAMES)) {
[16:06:45.214]                   name <- changed[[kk]]
[16:06:45.214]                   NAME <- NAMES[[kk]]
[16:06:45.214]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.214]                     next
[16:06:45.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.214]                 }
[16:06:45.214]                 NAMES <- toupper(added)
[16:06:45.214]                 for (kk in seq_along(NAMES)) {
[16:06:45.214]                   name <- added[[kk]]
[16:06:45.214]                   NAME <- NAMES[[kk]]
[16:06:45.214]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.214]                     next
[16:06:45.214]                   args[[name]] <- ""
[16:06:45.214]                 }
[16:06:45.214]                 NAMES <- toupper(removed)
[16:06:45.214]                 for (kk in seq_along(NAMES)) {
[16:06:45.214]                   name <- removed[[kk]]
[16:06:45.214]                   NAME <- NAMES[[kk]]
[16:06:45.214]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.214]                     next
[16:06:45.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.214]                 }
[16:06:45.214]                 if (length(args) > 0) 
[16:06:45.214]                   base::do.call(base::Sys.setenv, args = args)
[16:06:45.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:45.214]             }
[16:06:45.214]             else {
[16:06:45.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:45.214]             }
[16:06:45.214]             {
[16:06:45.214]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:45.214]                   0L) {
[16:06:45.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:45.214]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:45.214]                   base::options(opts)
[16:06:45.214]                 }
[16:06:45.214]                 {
[16:06:45.214]                   {
[16:06:45.214]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:45.214]                     NULL
[16:06:45.214]                   }
[16:06:45.214]                   options(future.plan = NULL)
[16:06:45.214]                   if (is.na(NA_character_)) 
[16:06:45.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:45.214]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:45.214]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:45.214]                     envir = parent.frame()) 
[16:06:45.214]                   {
[16:06:45.214]                     if (is.function(workers)) 
[16:06:45.214]                       workers <- workers()
[16:06:45.214]                     workers <- structure(as.integer(workers), 
[16:06:45.214]                       class = class(workers))
[16:06:45.214]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:45.214]                       workers >= 1)
[16:06:45.214]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:45.214]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:45.214]                     }
[16:06:45.214]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:45.214]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:45.214]                       envir = envir)
[16:06:45.214]                     if (!future$lazy) 
[16:06:45.214]                       future <- run(future)
[16:06:45.214]                     invisible(future)
[16:06:45.214]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:45.214]                 }
[16:06:45.214]             }
[16:06:45.214]         }
[16:06:45.214]     })
[16:06:45.214]     if (TRUE) {
[16:06:45.214]         base::sink(type = "output", split = FALSE)
[16:06:45.214]         if (FALSE) {
[16:06:45.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:45.214]         }
[16:06:45.214]         else {
[16:06:45.214]             ...future.result["stdout"] <- base::list(NULL)
[16:06:45.214]         }
[16:06:45.214]         base::close(...future.stdout)
[16:06:45.214]         ...future.stdout <- NULL
[16:06:45.214]     }
[16:06:45.214]     ...future.result$conditions <- ...future.conditions
[16:06:45.214]     ...future.result$finished <- base::Sys.time()
[16:06:45.214]     ...future.result
[16:06:45.214] }
[16:06:45.217] MultisessionFuture started
[16:06:45.217] - Launch lazy future ... done
[16:06:45.217] run() for ‘MultisessionFuture’ ... done
[16:06:45.218] result() for ClusterFuture ...
[16:06:45.218] receiveMessageFromWorker() for ClusterFuture ...
[16:06:45.218] - Validating connection of MultisessionFuture
[16:06:45.264] - received message: FutureResult
[16:06:45.264] - Received FutureResult
[16:06:45.264] - Erased future from FutureRegistry
[16:06:45.264] result() for ClusterFuture ...
[16:06:45.265] - result already collected: FutureResult
[16:06:45.265] result() for ClusterFuture ... done
[16:06:45.265] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:45.265] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:06:45"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:06:45"
 $ session_uuid: chr "8a740ab0-1dc6-8e1f-1e6e-7e40ad691e23"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "11666ca4073c"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92488
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:06:44"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:06:45.272] result() for ClusterFuture ...
[16:06:45.272] - result already collected: FutureResult
[16:06:45.273] result() for ClusterFuture ... done
[16:06:45.273] result() for ClusterFuture ...
[16:06:45.273] - result already collected: FutureResult
[16:06:45.273] result() for ClusterFuture ... done
[16:06:45.273] getGlobalsAndPackages() ...
[16:06:45.273] Searching for globals...
[16:06:45.276] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:45.276] Searching for globals ... DONE
[16:06:45.276] Resolving globals: FALSE
[16:06:45.277] 
[16:06:45.277] - packages: [1] ‘utils’
[16:06:45.277] getGlobalsAndPackages() ... DONE
[16:06:45.277] run() for ‘Future’ ...
[16:06:45.277] - state: ‘created’
[16:06:45.277] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:45.291] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:45.291] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:45.291]   - Field: ‘node’
[16:06:45.291]   - Field: ‘label’
[16:06:45.291]   - Field: ‘local’
[16:06:45.291]   - Field: ‘owner’
[16:06:45.291]   - Field: ‘envir’
[16:06:45.291]   - Field: ‘workers’
[16:06:45.292]   - Field: ‘packages’
[16:06:45.292]   - Field: ‘gc’
[16:06:45.292]   - Field: ‘conditions’
[16:06:45.292]   - Field: ‘persistent’
[16:06:45.292]   - Field: ‘expr’
[16:06:45.292]   - Field: ‘uuid’
[16:06:45.292]   - Field: ‘seed’
[16:06:45.292]   - Field: ‘version’
[16:06:45.292]   - Field: ‘result’
[16:06:45.292]   - Field: ‘asynchronous’
[16:06:45.292]   - Field: ‘calls’
[16:06:45.293]   - Field: ‘globals’
[16:06:45.293]   - Field: ‘stdout’
[16:06:45.293]   - Field: ‘earlySignal’
[16:06:45.293]   - Field: ‘lazy’
[16:06:45.293]   - Field: ‘state’
[16:06:45.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:45.293] - Launch lazy future ...
[16:06:45.293] Packages needed by the future expression (n = 1): ‘utils’
[16:06:45.293] Packages needed by future strategies (n = 0): <none>
[16:06:45.294] {
[16:06:45.294]     {
[16:06:45.294]         {
[16:06:45.294]             ...future.startTime <- base::Sys.time()
[16:06:45.294]             {
[16:06:45.294]                 {
[16:06:45.294]                   {
[16:06:45.294]                     {
[16:06:45.294]                       {
[16:06:45.294]                         base::local({
[16:06:45.294]                           has_future <- base::requireNamespace("future", 
[16:06:45.294]                             quietly = TRUE)
[16:06:45.294]                           if (has_future) {
[16:06:45.294]                             ns <- base::getNamespace("future")
[16:06:45.294]                             version <- ns[[".package"]][["version"]]
[16:06:45.294]                             if (is.null(version)) 
[16:06:45.294]                               version <- utils::packageVersion("future")
[16:06:45.294]                           }
[16:06:45.294]                           else {
[16:06:45.294]                             version <- NULL
[16:06:45.294]                           }
[16:06:45.294]                           if (!has_future || version < "1.8.0") {
[16:06:45.294]                             info <- base::c(r_version = base::gsub("R version ", 
[16:06:45.294]                               "", base::R.version$version.string), 
[16:06:45.294]                               platform = base::sprintf("%s (%s-bit)", 
[16:06:45.294]                                 base::R.version$platform, 8 * 
[16:06:45.294]                                   base::.Machine$sizeof.pointer), 
[16:06:45.294]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:45.294]                                 "release", "version")], collapse = " "), 
[16:06:45.294]                               hostname = base::Sys.info()[["nodename"]])
[16:06:45.294]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:06:45.294]                               info)
[16:06:45.294]                             info <- base::paste(info, collapse = "; ")
[16:06:45.294]                             if (!has_future) {
[16:06:45.294]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:45.294]                                 info)
[16:06:45.294]                             }
[16:06:45.294]                             else {
[16:06:45.294]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:45.294]                                 info, version)
[16:06:45.294]                             }
[16:06:45.294]                             base::stop(msg)
[16:06:45.294]                           }
[16:06:45.294]                         })
[16:06:45.294]                       }
[16:06:45.294]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:45.294]                       base::options(mc.cores = 1L)
[16:06:45.294]                     }
[16:06:45.294]                     base::local({
[16:06:45.294]                       for (pkg in "utils") {
[16:06:45.294]                         base::loadNamespace(pkg)
[16:06:45.294]                         base::library(pkg, character.only = TRUE)
[16:06:45.294]                       }
[16:06:45.294]                     })
[16:06:45.294]                   }
[16:06:45.294]                   options(future.plan = NULL)
[16:06:45.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:45.294]                 }
[16:06:45.294]                 ...future.workdir <- getwd()
[16:06:45.294]             }
[16:06:45.294]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:45.294]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:45.294]         }
[16:06:45.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:45.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:45.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:45.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:45.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:45.294]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:45.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:45.294]             base::names(...future.oldOptions))
[16:06:45.294]     }
[16:06:45.294]     if (FALSE) {
[16:06:45.294]     }
[16:06:45.294]     else {
[16:06:45.294]         if (FALSE) {
[16:06:45.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:45.294]                 open = "w")
[16:06:45.294]         }
[16:06:45.294]         else {
[16:06:45.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:45.294]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:45.294]         }
[16:06:45.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:45.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:45.294]             base::sink(type = "output", split = FALSE)
[16:06:45.294]             base::close(...future.stdout)
[16:06:45.294]         }, add = TRUE)
[16:06:45.294]     }
[16:06:45.294]     ...future.frame <- base::sys.nframe()
[16:06:45.294]     ...future.conditions <- base::list()
[16:06:45.294]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:45.294]     if (FALSE) {
[16:06:45.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:45.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:45.294]     }
[16:06:45.294]     ...future.result <- base::tryCatch({
[16:06:45.294]         base::withCallingHandlers({
[16:06:45.294]             ...future.value <- base::withVisible(base::local({
[16:06:45.294]                 ...future.makeSendCondition <- base::local({
[16:06:45.294]                   sendCondition <- NULL
[16:06:45.294]                   function(frame = 1L) {
[16:06:45.294]                     if (is.function(sendCondition)) 
[16:06:45.294]                       return(sendCondition)
[16:06:45.294]                     ns <- getNamespace("parallel")
[16:06:45.294]                     if (exists("sendData", mode = "function", 
[16:06:45.294]                       envir = ns)) {
[16:06:45.294]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:45.294]                         envir = ns)
[16:06:45.294]                       envir <- sys.frame(frame)
[16:06:45.294]                       master <- NULL
[16:06:45.294]                       while (!identical(envir, .GlobalEnv) && 
[16:06:45.294]                         !identical(envir, emptyenv())) {
[16:06:45.294]                         if (exists("master", mode = "list", envir = envir, 
[16:06:45.294]                           inherits = FALSE)) {
[16:06:45.294]                           master <- get("master", mode = "list", 
[16:06:45.294]                             envir = envir, inherits = FALSE)
[16:06:45.294]                           if (inherits(master, c("SOCKnode", 
[16:06:45.294]                             "SOCK0node"))) {
[16:06:45.294]                             sendCondition <<- function(cond) {
[16:06:45.294]                               data <- list(type = "VALUE", value = cond, 
[16:06:45.294]                                 success = TRUE)
[16:06:45.294]                               parallel_sendData(master, data)
[16:06:45.294]                             }
[16:06:45.294]                             return(sendCondition)
[16:06:45.294]                           }
[16:06:45.294]                         }
[16:06:45.294]                         frame <- frame + 1L
[16:06:45.294]                         envir <- sys.frame(frame)
[16:06:45.294]                       }
[16:06:45.294]                     }
[16:06:45.294]                     sendCondition <<- function(cond) NULL
[16:06:45.294]                   }
[16:06:45.294]                 })
[16:06:45.294]                 withCallingHandlers({
[16:06:45.294]                   {
[16:06:45.294]                     print(1:50)
[16:06:45.294]                     str(1:50)
[16:06:45.294]                     cat(letters, sep = "-")
[16:06:45.294]                     cat(1:6, collapse = "\n")
[16:06:45.294]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:45.294]                     42L
[16:06:45.294]                   }
[16:06:45.294]                 }, immediateCondition = function(cond) {
[16:06:45.294]                   sendCondition <- ...future.makeSendCondition()
[16:06:45.294]                   sendCondition(cond)
[16:06:45.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.294]                   {
[16:06:45.294]                     inherits <- base::inherits
[16:06:45.294]                     invokeRestart <- base::invokeRestart
[16:06:45.294]                     is.null <- base::is.null
[16:06:45.294]                     muffled <- FALSE
[16:06:45.294]                     if (inherits(cond, "message")) {
[16:06:45.294]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:45.294]                       if (muffled) 
[16:06:45.294]                         invokeRestart("muffleMessage")
[16:06:45.294]                     }
[16:06:45.294]                     else if (inherits(cond, "warning")) {
[16:06:45.294]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:45.294]                       if (muffled) 
[16:06:45.294]                         invokeRestart("muffleWarning")
[16:06:45.294]                     }
[16:06:45.294]                     else if (inherits(cond, "condition")) {
[16:06:45.294]                       if (!is.null(pattern)) {
[16:06:45.294]                         computeRestarts <- base::computeRestarts
[16:06:45.294]                         grepl <- base::grepl
[16:06:45.294]                         restarts <- computeRestarts(cond)
[16:06:45.294]                         for (restart in restarts) {
[16:06:45.294]                           name <- restart$name
[16:06:45.294]                           if (is.null(name)) 
[16:06:45.294]                             next
[16:06:45.294]                           if (!grepl(pattern, name)) 
[16:06:45.294]                             next
[16:06:45.294]                           invokeRestart(restart)
[16:06:45.294]                           muffled <- TRUE
[16:06:45.294]                           break
[16:06:45.294]                         }
[16:06:45.294]                       }
[16:06:45.294]                     }
[16:06:45.294]                     invisible(muffled)
[16:06:45.294]                   }
[16:06:45.294]                   muffleCondition(cond)
[16:06:45.294]                 })
[16:06:45.294]             }))
[16:06:45.294]             future::FutureResult(value = ...future.value$value, 
[16:06:45.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.294]                   ...future.rng), globalenv = if (FALSE) 
[16:06:45.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:45.294]                     ...future.globalenv.names))
[16:06:45.294]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:45.294]         }, condition = base::local({
[16:06:45.294]             c <- base::c
[16:06:45.294]             inherits <- base::inherits
[16:06:45.294]             invokeRestart <- base::invokeRestart
[16:06:45.294]             length <- base::length
[16:06:45.294]             list <- base::list
[16:06:45.294]             seq.int <- base::seq.int
[16:06:45.294]             signalCondition <- base::signalCondition
[16:06:45.294]             sys.calls <- base::sys.calls
[16:06:45.294]             `[[` <- base::`[[`
[16:06:45.294]             `+` <- base::`+`
[16:06:45.294]             `<<-` <- base::`<<-`
[16:06:45.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:45.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:45.294]                   3L)]
[16:06:45.294]             }
[16:06:45.294]             function(cond) {
[16:06:45.294]                 is_error <- inherits(cond, "error")
[16:06:45.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:45.294]                   NULL)
[16:06:45.294]                 if (is_error) {
[16:06:45.294]                   sessionInformation <- function() {
[16:06:45.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:45.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:45.294]                       search = base::search(), system = base::Sys.info())
[16:06:45.294]                   }
[16:06:45.294]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:45.294]                     cond$call), session = sessionInformation(), 
[16:06:45.294]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:45.294]                   signalCondition(cond)
[16:06:45.294]                 }
[16:06:45.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:45.294]                 "immediateCondition"))) {
[16:06:45.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:45.294]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:45.294]                   if (TRUE && !signal) {
[16:06:45.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.294]                     {
[16:06:45.294]                       inherits <- base::inherits
[16:06:45.294]                       invokeRestart <- base::invokeRestart
[16:06:45.294]                       is.null <- base::is.null
[16:06:45.294]                       muffled <- FALSE
[16:06:45.294]                       if (inherits(cond, "message")) {
[16:06:45.294]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.294]                         if (muffled) 
[16:06:45.294]                           invokeRestart("muffleMessage")
[16:06:45.294]                       }
[16:06:45.294]                       else if (inherits(cond, "warning")) {
[16:06:45.294]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.294]                         if (muffled) 
[16:06:45.294]                           invokeRestart("muffleWarning")
[16:06:45.294]                       }
[16:06:45.294]                       else if (inherits(cond, "condition")) {
[16:06:45.294]                         if (!is.null(pattern)) {
[16:06:45.294]                           computeRestarts <- base::computeRestarts
[16:06:45.294]                           grepl <- base::grepl
[16:06:45.294]                           restarts <- computeRestarts(cond)
[16:06:45.294]                           for (restart in restarts) {
[16:06:45.294]                             name <- restart$name
[16:06:45.294]                             if (is.null(name)) 
[16:06:45.294]                               next
[16:06:45.294]                             if (!grepl(pattern, name)) 
[16:06:45.294]                               next
[16:06:45.294]                             invokeRestart(restart)
[16:06:45.294]                             muffled <- TRUE
[16:06:45.294]                             break
[16:06:45.294]                           }
[16:06:45.294]                         }
[16:06:45.294]                       }
[16:06:45.294]                       invisible(muffled)
[16:06:45.294]                     }
[16:06:45.294]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.294]                   }
[16:06:45.294]                 }
[16:06:45.294]                 else {
[16:06:45.294]                   if (TRUE) {
[16:06:45.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.294]                     {
[16:06:45.294]                       inherits <- base::inherits
[16:06:45.294]                       invokeRestart <- base::invokeRestart
[16:06:45.294]                       is.null <- base::is.null
[16:06:45.294]                       muffled <- FALSE
[16:06:45.294]                       if (inherits(cond, "message")) {
[16:06:45.294]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.294]                         if (muffled) 
[16:06:45.294]                           invokeRestart("muffleMessage")
[16:06:45.294]                       }
[16:06:45.294]                       else if (inherits(cond, "warning")) {
[16:06:45.294]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.294]                         if (muffled) 
[16:06:45.294]                           invokeRestart("muffleWarning")
[16:06:45.294]                       }
[16:06:45.294]                       else if (inherits(cond, "condition")) {
[16:06:45.294]                         if (!is.null(pattern)) {
[16:06:45.294]                           computeRestarts <- base::computeRestarts
[16:06:45.294]                           grepl <- base::grepl
[16:06:45.294]                           restarts <- computeRestarts(cond)
[16:06:45.294]                           for (restart in restarts) {
[16:06:45.294]                             name <- restart$name
[16:06:45.294]                             if (is.null(name)) 
[16:06:45.294]                               next
[16:06:45.294]                             if (!grepl(pattern, name)) 
[16:06:45.294]                               next
[16:06:45.294]                             invokeRestart(restart)
[16:06:45.294]                             muffled <- TRUE
[16:06:45.294]                             break
[16:06:45.294]                           }
[16:06:45.294]                         }
[16:06:45.294]                       }
[16:06:45.294]                       invisible(muffled)
[16:06:45.294]                     }
[16:06:45.294]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.294]                   }
[16:06:45.294]                 }
[16:06:45.294]             }
[16:06:45.294]         }))
[16:06:45.294]     }, error = function(ex) {
[16:06:45.294]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:45.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.294]                 ...future.rng), started = ...future.startTime, 
[16:06:45.294]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:45.294]             version = "1.8"), class = "FutureResult")
[16:06:45.294]     }, finally = {
[16:06:45.294]         if (!identical(...future.workdir, getwd())) 
[16:06:45.294]             setwd(...future.workdir)
[16:06:45.294]         {
[16:06:45.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:45.294]                 ...future.oldOptions$nwarnings <- NULL
[16:06:45.294]             }
[16:06:45.294]             base::options(...future.oldOptions)
[16:06:45.294]             if (.Platform$OS.type == "windows") {
[16:06:45.294]                 old_names <- names(...future.oldEnvVars)
[16:06:45.294]                 envs <- base::Sys.getenv()
[16:06:45.294]                 names <- names(envs)
[16:06:45.294]                 common <- intersect(names, old_names)
[16:06:45.294]                 added <- setdiff(names, old_names)
[16:06:45.294]                 removed <- setdiff(old_names, names)
[16:06:45.294]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:45.294]                   envs[common]]
[16:06:45.294]                 NAMES <- toupper(changed)
[16:06:45.294]                 args <- list()
[16:06:45.294]                 for (kk in seq_along(NAMES)) {
[16:06:45.294]                   name <- changed[[kk]]
[16:06:45.294]                   NAME <- NAMES[[kk]]
[16:06:45.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.294]                     next
[16:06:45.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.294]                 }
[16:06:45.294]                 NAMES <- toupper(added)
[16:06:45.294]                 for (kk in seq_along(NAMES)) {
[16:06:45.294]                   name <- added[[kk]]
[16:06:45.294]                   NAME <- NAMES[[kk]]
[16:06:45.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.294]                     next
[16:06:45.294]                   args[[name]] <- ""
[16:06:45.294]                 }
[16:06:45.294]                 NAMES <- toupper(removed)
[16:06:45.294]                 for (kk in seq_along(NAMES)) {
[16:06:45.294]                   name <- removed[[kk]]
[16:06:45.294]                   NAME <- NAMES[[kk]]
[16:06:45.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.294]                     next
[16:06:45.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.294]                 }
[16:06:45.294]                 if (length(args) > 0) 
[16:06:45.294]                   base::do.call(base::Sys.setenv, args = args)
[16:06:45.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:45.294]             }
[16:06:45.294]             else {
[16:06:45.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:45.294]             }
[16:06:45.294]             {
[16:06:45.294]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:45.294]                   0L) {
[16:06:45.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:45.294]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:45.294]                   base::options(opts)
[16:06:45.294]                 }
[16:06:45.294]                 {
[16:06:45.294]                   {
[16:06:45.294]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:45.294]                     NULL
[16:06:45.294]                   }
[16:06:45.294]                   options(future.plan = NULL)
[16:06:45.294]                   if (is.na(NA_character_)) 
[16:06:45.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:45.294]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:45.294]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:45.294]                     envir = parent.frame()) 
[16:06:45.294]                   {
[16:06:45.294]                     if (is.function(workers)) 
[16:06:45.294]                       workers <- workers()
[16:06:45.294]                     workers <- structure(as.integer(workers), 
[16:06:45.294]                       class = class(workers))
[16:06:45.294]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:45.294]                       workers >= 1)
[16:06:45.294]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:45.294]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:45.294]                     }
[16:06:45.294]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:45.294]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:45.294]                       envir = envir)
[16:06:45.294]                     if (!future$lazy) 
[16:06:45.294]                       future <- run(future)
[16:06:45.294]                     invisible(future)
[16:06:45.294]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:45.294]                 }
[16:06:45.294]             }
[16:06:45.294]         }
[16:06:45.294]     })
[16:06:45.294]     if (TRUE) {
[16:06:45.294]         base::sink(type = "output", split = FALSE)
[16:06:45.294]         if (FALSE) {
[16:06:45.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:45.294]         }
[16:06:45.294]         else {
[16:06:45.294]             ...future.result["stdout"] <- base::list(NULL)
[16:06:45.294]         }
[16:06:45.294]         base::close(...future.stdout)
[16:06:45.294]         ...future.stdout <- NULL
[16:06:45.294]     }
[16:06:45.294]     ...future.result$conditions <- ...future.conditions
[16:06:45.294]     ...future.result$finished <- base::Sys.time()
[16:06:45.294]     ...future.result
[16:06:45.294] }
[16:06:45.297] MultisessionFuture started
[16:06:45.297] - Launch lazy future ... done
[16:06:45.297] run() for ‘MultisessionFuture’ ... done
[16:06:45.297] result() for ClusterFuture ...
[16:06:45.298] receiveMessageFromWorker() for ClusterFuture ...
[16:06:45.298] - Validating connection of MultisessionFuture
[16:06:45.344] - received message: FutureResult
[16:06:45.344] - Received FutureResult
[16:06:45.344] - Erased future from FutureRegistry
[16:06:45.345] result() for ClusterFuture ...
[16:06:45.345] - result already collected: FutureResult
[16:06:45.345] result() for ClusterFuture ... done
[16:06:45.345] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:45.345] result() for ClusterFuture ... done
[16:06:45.345] result() for ClusterFuture ...
[16:06:45.345] - result already collected: FutureResult
[16:06:45.345] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[16:06:45.345] getGlobalsAndPackages() ...
[16:06:45.345] Searching for globals...
[16:06:45.346] - globals found: [1] ‘print’
[16:06:45.346] Searching for globals ... DONE
[16:06:45.346] Resolving globals: FALSE
[16:06:45.346] 
[16:06:45.346] 
[16:06:45.347] getGlobalsAndPackages() ... DONE
[16:06:45.347] run() for ‘Future’ ...
[16:06:45.347] - state: ‘created’
[16:06:45.347] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:45.360] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:45.360] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:45.360]   - Field: ‘node’
[16:06:45.361]   - Field: ‘label’
[16:06:45.361]   - Field: ‘local’
[16:06:45.361]   - Field: ‘owner’
[16:06:45.361]   - Field: ‘envir’
[16:06:45.361]   - Field: ‘workers’
[16:06:45.361]   - Field: ‘packages’
[16:06:45.361]   - Field: ‘gc’
[16:06:45.361]   - Field: ‘conditions’
[16:06:45.361]   - Field: ‘persistent’
[16:06:45.361]   - Field: ‘expr’
[16:06:45.361]   - Field: ‘uuid’
[16:06:45.362]   - Field: ‘seed’
[16:06:45.362]   - Field: ‘version’
[16:06:45.362]   - Field: ‘result’
[16:06:45.362]   - Field: ‘asynchronous’
[16:06:45.362]   - Field: ‘calls’
[16:06:45.362]   - Field: ‘globals’
[16:06:45.362]   - Field: ‘stdout’
[16:06:45.362]   - Field: ‘earlySignal’
[16:06:45.362]   - Field: ‘lazy’
[16:06:45.362]   - Field: ‘state’
[16:06:45.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:45.363] - Launch lazy future ...
[16:06:45.363] Packages needed by the future expression (n = 0): <none>
[16:06:45.363] Packages needed by future strategies (n = 0): <none>
[16:06:45.364] {
[16:06:45.364]     {
[16:06:45.364]         {
[16:06:45.364]             ...future.startTime <- base::Sys.time()
[16:06:45.364]             {
[16:06:45.364]                 {
[16:06:45.364]                   {
[16:06:45.364]                     {
[16:06:45.364]                       base::local({
[16:06:45.364]                         has_future <- base::requireNamespace("future", 
[16:06:45.364]                           quietly = TRUE)
[16:06:45.364]                         if (has_future) {
[16:06:45.364]                           ns <- base::getNamespace("future")
[16:06:45.364]                           version <- ns[[".package"]][["version"]]
[16:06:45.364]                           if (is.null(version)) 
[16:06:45.364]                             version <- utils::packageVersion("future")
[16:06:45.364]                         }
[16:06:45.364]                         else {
[16:06:45.364]                           version <- NULL
[16:06:45.364]                         }
[16:06:45.364]                         if (!has_future || version < "1.8.0") {
[16:06:45.364]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:45.364]                             "", base::R.version$version.string), 
[16:06:45.364]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:45.364]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:45.364]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:45.364]                               "release", "version")], collapse = " "), 
[16:06:45.364]                             hostname = base::Sys.info()[["nodename"]])
[16:06:45.364]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:45.364]                             info)
[16:06:45.364]                           info <- base::paste(info, collapse = "; ")
[16:06:45.364]                           if (!has_future) {
[16:06:45.364]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:45.364]                               info)
[16:06:45.364]                           }
[16:06:45.364]                           else {
[16:06:45.364]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:45.364]                               info, version)
[16:06:45.364]                           }
[16:06:45.364]                           base::stop(msg)
[16:06:45.364]                         }
[16:06:45.364]                       })
[16:06:45.364]                     }
[16:06:45.364]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:45.364]                     base::options(mc.cores = 1L)
[16:06:45.364]                   }
[16:06:45.364]                   options(future.plan = NULL)
[16:06:45.364]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.364]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:45.364]                 }
[16:06:45.364]                 ...future.workdir <- getwd()
[16:06:45.364]             }
[16:06:45.364]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:45.364]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:45.364]         }
[16:06:45.364]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:45.364]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:45.364]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:45.364]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:45.364]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:45.364]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:45.364]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:45.364]             base::names(...future.oldOptions))
[16:06:45.364]     }
[16:06:45.364]     if (FALSE) {
[16:06:45.364]     }
[16:06:45.364]     else {
[16:06:45.364]         if (TRUE) {
[16:06:45.364]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:45.364]                 open = "w")
[16:06:45.364]         }
[16:06:45.364]         else {
[16:06:45.364]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:45.364]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:45.364]         }
[16:06:45.364]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:45.364]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:45.364]             base::sink(type = "output", split = FALSE)
[16:06:45.364]             base::close(...future.stdout)
[16:06:45.364]         }, add = TRUE)
[16:06:45.364]     }
[16:06:45.364]     ...future.frame <- base::sys.nframe()
[16:06:45.364]     ...future.conditions <- base::list()
[16:06:45.364]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:45.364]     if (FALSE) {
[16:06:45.364]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:45.364]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:45.364]     }
[16:06:45.364]     ...future.result <- base::tryCatch({
[16:06:45.364]         base::withCallingHandlers({
[16:06:45.364]             ...future.value <- base::withVisible(base::local({
[16:06:45.364]                 ...future.makeSendCondition <- base::local({
[16:06:45.364]                   sendCondition <- NULL
[16:06:45.364]                   function(frame = 1L) {
[16:06:45.364]                     if (is.function(sendCondition)) 
[16:06:45.364]                       return(sendCondition)
[16:06:45.364]                     ns <- getNamespace("parallel")
[16:06:45.364]                     if (exists("sendData", mode = "function", 
[16:06:45.364]                       envir = ns)) {
[16:06:45.364]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:45.364]                         envir = ns)
[16:06:45.364]                       envir <- sys.frame(frame)
[16:06:45.364]                       master <- NULL
[16:06:45.364]                       while (!identical(envir, .GlobalEnv) && 
[16:06:45.364]                         !identical(envir, emptyenv())) {
[16:06:45.364]                         if (exists("master", mode = "list", envir = envir, 
[16:06:45.364]                           inherits = FALSE)) {
[16:06:45.364]                           master <- get("master", mode = "list", 
[16:06:45.364]                             envir = envir, inherits = FALSE)
[16:06:45.364]                           if (inherits(master, c("SOCKnode", 
[16:06:45.364]                             "SOCK0node"))) {
[16:06:45.364]                             sendCondition <<- function(cond) {
[16:06:45.364]                               data <- list(type = "VALUE", value = cond, 
[16:06:45.364]                                 success = TRUE)
[16:06:45.364]                               parallel_sendData(master, data)
[16:06:45.364]                             }
[16:06:45.364]                             return(sendCondition)
[16:06:45.364]                           }
[16:06:45.364]                         }
[16:06:45.364]                         frame <- frame + 1L
[16:06:45.364]                         envir <- sys.frame(frame)
[16:06:45.364]                       }
[16:06:45.364]                     }
[16:06:45.364]                     sendCondition <<- function(cond) NULL
[16:06:45.364]                   }
[16:06:45.364]                 })
[16:06:45.364]                 withCallingHandlers({
[16:06:45.364]                   print(42)
[16:06:45.364]                 }, immediateCondition = function(cond) {
[16:06:45.364]                   sendCondition <- ...future.makeSendCondition()
[16:06:45.364]                   sendCondition(cond)
[16:06:45.364]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.364]                   {
[16:06:45.364]                     inherits <- base::inherits
[16:06:45.364]                     invokeRestart <- base::invokeRestart
[16:06:45.364]                     is.null <- base::is.null
[16:06:45.364]                     muffled <- FALSE
[16:06:45.364]                     if (inherits(cond, "message")) {
[16:06:45.364]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:45.364]                       if (muffled) 
[16:06:45.364]                         invokeRestart("muffleMessage")
[16:06:45.364]                     }
[16:06:45.364]                     else if (inherits(cond, "warning")) {
[16:06:45.364]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:45.364]                       if (muffled) 
[16:06:45.364]                         invokeRestart("muffleWarning")
[16:06:45.364]                     }
[16:06:45.364]                     else if (inherits(cond, "condition")) {
[16:06:45.364]                       if (!is.null(pattern)) {
[16:06:45.364]                         computeRestarts <- base::computeRestarts
[16:06:45.364]                         grepl <- base::grepl
[16:06:45.364]                         restarts <- computeRestarts(cond)
[16:06:45.364]                         for (restart in restarts) {
[16:06:45.364]                           name <- restart$name
[16:06:45.364]                           if (is.null(name)) 
[16:06:45.364]                             next
[16:06:45.364]                           if (!grepl(pattern, name)) 
[16:06:45.364]                             next
[16:06:45.364]                           invokeRestart(restart)
[16:06:45.364]                           muffled <- TRUE
[16:06:45.364]                           break
[16:06:45.364]                         }
[16:06:45.364]                       }
[16:06:45.364]                     }
[16:06:45.364]                     invisible(muffled)
[16:06:45.364]                   }
[16:06:45.364]                   muffleCondition(cond)
[16:06:45.364]                 })
[16:06:45.364]             }))
[16:06:45.364]             future::FutureResult(value = ...future.value$value, 
[16:06:45.364]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.364]                   ...future.rng), globalenv = if (FALSE) 
[16:06:45.364]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:45.364]                     ...future.globalenv.names))
[16:06:45.364]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:45.364]         }, condition = base::local({
[16:06:45.364]             c <- base::c
[16:06:45.364]             inherits <- base::inherits
[16:06:45.364]             invokeRestart <- base::invokeRestart
[16:06:45.364]             length <- base::length
[16:06:45.364]             list <- base::list
[16:06:45.364]             seq.int <- base::seq.int
[16:06:45.364]             signalCondition <- base::signalCondition
[16:06:45.364]             sys.calls <- base::sys.calls
[16:06:45.364]             `[[` <- base::`[[`
[16:06:45.364]             `+` <- base::`+`
[16:06:45.364]             `<<-` <- base::`<<-`
[16:06:45.364]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:45.364]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:45.364]                   3L)]
[16:06:45.364]             }
[16:06:45.364]             function(cond) {
[16:06:45.364]                 is_error <- inherits(cond, "error")
[16:06:45.364]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:45.364]                   NULL)
[16:06:45.364]                 if (is_error) {
[16:06:45.364]                   sessionInformation <- function() {
[16:06:45.364]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:45.364]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:45.364]                       search = base::search(), system = base::Sys.info())
[16:06:45.364]                   }
[16:06:45.364]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.364]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:45.364]                     cond$call), session = sessionInformation(), 
[16:06:45.364]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:45.364]                   signalCondition(cond)
[16:06:45.364]                 }
[16:06:45.364]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:45.364]                 "immediateCondition"))) {
[16:06:45.364]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:45.364]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.364]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:45.364]                   if (TRUE && !signal) {
[16:06:45.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.364]                     {
[16:06:45.364]                       inherits <- base::inherits
[16:06:45.364]                       invokeRestart <- base::invokeRestart
[16:06:45.364]                       is.null <- base::is.null
[16:06:45.364]                       muffled <- FALSE
[16:06:45.364]                       if (inherits(cond, "message")) {
[16:06:45.364]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.364]                         if (muffled) 
[16:06:45.364]                           invokeRestart("muffleMessage")
[16:06:45.364]                       }
[16:06:45.364]                       else if (inherits(cond, "warning")) {
[16:06:45.364]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.364]                         if (muffled) 
[16:06:45.364]                           invokeRestart("muffleWarning")
[16:06:45.364]                       }
[16:06:45.364]                       else if (inherits(cond, "condition")) {
[16:06:45.364]                         if (!is.null(pattern)) {
[16:06:45.364]                           computeRestarts <- base::computeRestarts
[16:06:45.364]                           grepl <- base::grepl
[16:06:45.364]                           restarts <- computeRestarts(cond)
[16:06:45.364]                           for (restart in restarts) {
[16:06:45.364]                             name <- restart$name
[16:06:45.364]                             if (is.null(name)) 
[16:06:45.364]                               next
[16:06:45.364]                             if (!grepl(pattern, name)) 
[16:06:45.364]                               next
[16:06:45.364]                             invokeRestart(restart)
[16:06:45.364]                             muffled <- TRUE
[16:06:45.364]                             break
[16:06:45.364]                           }
[16:06:45.364]                         }
[16:06:45.364]                       }
[16:06:45.364]                       invisible(muffled)
[16:06:45.364]                     }
[16:06:45.364]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.364]                   }
[16:06:45.364]                 }
[16:06:45.364]                 else {
[16:06:45.364]                   if (TRUE) {
[16:06:45.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.364]                     {
[16:06:45.364]                       inherits <- base::inherits
[16:06:45.364]                       invokeRestart <- base::invokeRestart
[16:06:45.364]                       is.null <- base::is.null
[16:06:45.364]                       muffled <- FALSE
[16:06:45.364]                       if (inherits(cond, "message")) {
[16:06:45.364]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.364]                         if (muffled) 
[16:06:45.364]                           invokeRestart("muffleMessage")
[16:06:45.364]                       }
[16:06:45.364]                       else if (inherits(cond, "warning")) {
[16:06:45.364]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.364]                         if (muffled) 
[16:06:45.364]                           invokeRestart("muffleWarning")
[16:06:45.364]                       }
[16:06:45.364]                       else if (inherits(cond, "condition")) {
[16:06:45.364]                         if (!is.null(pattern)) {
[16:06:45.364]                           computeRestarts <- base::computeRestarts
[16:06:45.364]                           grepl <- base::grepl
[16:06:45.364]                           restarts <- computeRestarts(cond)
[16:06:45.364]                           for (restart in restarts) {
[16:06:45.364]                             name <- restart$name
[16:06:45.364]                             if (is.null(name)) 
[16:06:45.364]                               next
[16:06:45.364]                             if (!grepl(pattern, name)) 
[16:06:45.364]                               next
[16:06:45.364]                             invokeRestart(restart)
[16:06:45.364]                             muffled <- TRUE
[16:06:45.364]                             break
[16:06:45.364]                           }
[16:06:45.364]                         }
[16:06:45.364]                       }
[16:06:45.364]                       invisible(muffled)
[16:06:45.364]                     }
[16:06:45.364]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.364]                   }
[16:06:45.364]                 }
[16:06:45.364]             }
[16:06:45.364]         }))
[16:06:45.364]     }, error = function(ex) {
[16:06:45.364]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:45.364]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.364]                 ...future.rng), started = ...future.startTime, 
[16:06:45.364]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:45.364]             version = "1.8"), class = "FutureResult")
[16:06:45.364]     }, finally = {
[16:06:45.364]         if (!identical(...future.workdir, getwd())) 
[16:06:45.364]             setwd(...future.workdir)
[16:06:45.364]         {
[16:06:45.364]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:45.364]                 ...future.oldOptions$nwarnings <- NULL
[16:06:45.364]             }
[16:06:45.364]             base::options(...future.oldOptions)
[16:06:45.364]             if (.Platform$OS.type == "windows") {
[16:06:45.364]                 old_names <- names(...future.oldEnvVars)
[16:06:45.364]                 envs <- base::Sys.getenv()
[16:06:45.364]                 names <- names(envs)
[16:06:45.364]                 common <- intersect(names, old_names)
[16:06:45.364]                 added <- setdiff(names, old_names)
[16:06:45.364]                 removed <- setdiff(old_names, names)
[16:06:45.364]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:45.364]                   envs[common]]
[16:06:45.364]                 NAMES <- toupper(changed)
[16:06:45.364]                 args <- list()
[16:06:45.364]                 for (kk in seq_along(NAMES)) {
[16:06:45.364]                   name <- changed[[kk]]
[16:06:45.364]                   NAME <- NAMES[[kk]]
[16:06:45.364]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.364]                     next
[16:06:45.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.364]                 }
[16:06:45.364]                 NAMES <- toupper(added)
[16:06:45.364]                 for (kk in seq_along(NAMES)) {
[16:06:45.364]                   name <- added[[kk]]
[16:06:45.364]                   NAME <- NAMES[[kk]]
[16:06:45.364]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.364]                     next
[16:06:45.364]                   args[[name]] <- ""
[16:06:45.364]                 }
[16:06:45.364]                 NAMES <- toupper(removed)
[16:06:45.364]                 for (kk in seq_along(NAMES)) {
[16:06:45.364]                   name <- removed[[kk]]
[16:06:45.364]                   NAME <- NAMES[[kk]]
[16:06:45.364]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.364]                     next
[16:06:45.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.364]                 }
[16:06:45.364]                 if (length(args) > 0) 
[16:06:45.364]                   base::do.call(base::Sys.setenv, args = args)
[16:06:45.364]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:45.364]             }
[16:06:45.364]             else {
[16:06:45.364]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:45.364]             }
[16:06:45.364]             {
[16:06:45.364]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:45.364]                   0L) {
[16:06:45.364]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:45.364]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:45.364]                   base::options(opts)
[16:06:45.364]                 }
[16:06:45.364]                 {
[16:06:45.364]                   {
[16:06:45.364]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:45.364]                     NULL
[16:06:45.364]                   }
[16:06:45.364]                   options(future.plan = NULL)
[16:06:45.364]                   if (is.na(NA_character_)) 
[16:06:45.364]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.364]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:45.364]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:45.364]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:45.364]                     envir = parent.frame()) 
[16:06:45.364]                   {
[16:06:45.364]                     if (is.function(workers)) 
[16:06:45.364]                       workers <- workers()
[16:06:45.364]                     workers <- structure(as.integer(workers), 
[16:06:45.364]                       class = class(workers))
[16:06:45.364]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:45.364]                       workers >= 1)
[16:06:45.364]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:45.364]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:45.364]                     }
[16:06:45.364]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:45.364]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:45.364]                       envir = envir)
[16:06:45.364]                     if (!future$lazy) 
[16:06:45.364]                       future <- run(future)
[16:06:45.364]                     invisible(future)
[16:06:45.364]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:45.364]                 }
[16:06:45.364]             }
[16:06:45.364]         }
[16:06:45.364]     })
[16:06:45.364]     if (TRUE) {
[16:06:45.364]         base::sink(type = "output", split = FALSE)
[16:06:45.364]         if (TRUE) {
[16:06:45.364]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:45.364]         }
[16:06:45.364]         else {
[16:06:45.364]             ...future.result["stdout"] <- base::list(NULL)
[16:06:45.364]         }
[16:06:45.364]         base::close(...future.stdout)
[16:06:45.364]         ...future.stdout <- NULL
[16:06:45.364]     }
[16:06:45.364]     ...future.result$conditions <- ...future.conditions
[16:06:45.364]     ...future.result$finished <- base::Sys.time()
[16:06:45.364]     ...future.result
[16:06:45.364] }
[16:06:45.367] MultisessionFuture started
[16:06:45.367] - Launch lazy future ... done
[16:06:45.367] run() for ‘MultisessionFuture’ ... done
[16:06:45.367] result() for ClusterFuture ...
[16:06:45.367] receiveMessageFromWorker() for ClusterFuture ...
[16:06:45.368] - Validating connection of MultisessionFuture
[16:06:45.415] - received message: FutureResult
[16:06:45.415] - Received FutureResult
[16:06:45.415] - Erased future from FutureRegistry
[16:06:45.416] result() for ClusterFuture ...
[16:06:45.416] - result already collected: FutureResult
[16:06:45.416] result() for ClusterFuture ... done
[16:06:45.416] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:45.416] result() for ClusterFuture ... done
[16:06:45.416] result() for ClusterFuture ...
[16:06:45.416] - result already collected: FutureResult
[16:06:45.416] result() for ClusterFuture ... done
[16:06:45.416] result() for ClusterFuture ...
[16:06:45.416] - result already collected: FutureResult
[16:06:45.416] result() for ClusterFuture ... done
[1] 42
[16:06:45.417] result() for ClusterFuture ...
[16:06:45.417] - result already collected: FutureResult
[16:06:45.417] result() for ClusterFuture ... done
- stdout = NA
[16:06:45.417] getGlobalsAndPackages() ...
[16:06:45.417] Searching for globals...
[16:06:45.420] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:45.420] Searching for globals ... DONE
[16:06:45.420] Resolving globals: FALSE
[16:06:45.421] 
[16:06:45.421] - packages: [1] ‘utils’
[16:06:45.421] getGlobalsAndPackages() ... DONE
[16:06:45.421] run() for ‘Future’ ...
[16:06:45.421] - state: ‘created’
[16:06:45.421] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:45.435] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:45.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:45.435]   - Field: ‘node’
[16:06:45.435]   - Field: ‘label’
[16:06:45.436]   - Field: ‘local’
[16:06:45.436]   - Field: ‘owner’
[16:06:45.436]   - Field: ‘envir’
[16:06:45.436]   - Field: ‘workers’
[16:06:45.436]   - Field: ‘packages’
[16:06:45.436]   - Field: ‘gc’
[16:06:45.438]   - Field: ‘conditions’
[16:06:45.438]   - Field: ‘persistent’
[16:06:45.438]   - Field: ‘expr’
[16:06:45.438]   - Field: ‘uuid’
[16:06:45.438]   - Field: ‘seed’
[16:06:45.438]   - Field: ‘version’
[16:06:45.438]   - Field: ‘result’
[16:06:45.438]   - Field: ‘asynchronous’
[16:06:45.438]   - Field: ‘calls’
[16:06:45.438]   - Field: ‘globals’
[16:06:45.439]   - Field: ‘stdout’
[16:06:45.439]   - Field: ‘earlySignal’
[16:06:45.439]   - Field: ‘lazy’
[16:06:45.439]   - Field: ‘state’
[16:06:45.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:45.439] - Launch lazy future ...
[16:06:45.439] Packages needed by the future expression (n = 1): ‘utils’
[16:06:45.439] Packages needed by future strategies (n = 0): <none>
[16:06:45.440] {
[16:06:45.440]     {
[16:06:45.440]         {
[16:06:45.440]             ...future.startTime <- base::Sys.time()
[16:06:45.440]             {
[16:06:45.440]                 {
[16:06:45.440]                   {
[16:06:45.440]                     {
[16:06:45.440]                       {
[16:06:45.440]                         base::local({
[16:06:45.440]                           has_future <- base::requireNamespace("future", 
[16:06:45.440]                             quietly = TRUE)
[16:06:45.440]                           if (has_future) {
[16:06:45.440]                             ns <- base::getNamespace("future")
[16:06:45.440]                             version <- ns[[".package"]][["version"]]
[16:06:45.440]                             if (is.null(version)) 
[16:06:45.440]                               version <- utils::packageVersion("future")
[16:06:45.440]                           }
[16:06:45.440]                           else {
[16:06:45.440]                             version <- NULL
[16:06:45.440]                           }
[16:06:45.440]                           if (!has_future || version < "1.8.0") {
[16:06:45.440]                             info <- base::c(r_version = base::gsub("R version ", 
[16:06:45.440]                               "", base::R.version$version.string), 
[16:06:45.440]                               platform = base::sprintf("%s (%s-bit)", 
[16:06:45.440]                                 base::R.version$platform, 8 * 
[16:06:45.440]                                   base::.Machine$sizeof.pointer), 
[16:06:45.440]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:45.440]                                 "release", "version")], collapse = " "), 
[16:06:45.440]                               hostname = base::Sys.info()[["nodename"]])
[16:06:45.440]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:06:45.440]                               info)
[16:06:45.440]                             info <- base::paste(info, collapse = "; ")
[16:06:45.440]                             if (!has_future) {
[16:06:45.440]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:45.440]                                 info)
[16:06:45.440]                             }
[16:06:45.440]                             else {
[16:06:45.440]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:45.440]                                 info, version)
[16:06:45.440]                             }
[16:06:45.440]                             base::stop(msg)
[16:06:45.440]                           }
[16:06:45.440]                         })
[16:06:45.440]                       }
[16:06:45.440]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:45.440]                       base::options(mc.cores = 1L)
[16:06:45.440]                     }
[16:06:45.440]                     base::local({
[16:06:45.440]                       for (pkg in "utils") {
[16:06:45.440]                         base::loadNamespace(pkg)
[16:06:45.440]                         base::library(pkg, character.only = TRUE)
[16:06:45.440]                       }
[16:06:45.440]                     })
[16:06:45.440]                   }
[16:06:45.440]                   options(future.plan = NULL)
[16:06:45.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:45.440]                 }
[16:06:45.440]                 ...future.workdir <- getwd()
[16:06:45.440]             }
[16:06:45.440]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:45.440]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:45.440]         }
[16:06:45.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:45.440]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:45.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:45.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:45.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:45.440]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:45.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:45.440]             base::names(...future.oldOptions))
[16:06:45.440]     }
[16:06:45.440]     if (TRUE) {
[16:06:45.440]     }
[16:06:45.440]     else {
[16:06:45.440]         if (NA) {
[16:06:45.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:45.440]                 open = "w")
[16:06:45.440]         }
[16:06:45.440]         else {
[16:06:45.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:45.440]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:45.440]         }
[16:06:45.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:45.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:45.440]             base::sink(type = "output", split = FALSE)
[16:06:45.440]             base::close(...future.stdout)
[16:06:45.440]         }, add = TRUE)
[16:06:45.440]     }
[16:06:45.440]     ...future.frame <- base::sys.nframe()
[16:06:45.440]     ...future.conditions <- base::list()
[16:06:45.440]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:45.440]     if (FALSE) {
[16:06:45.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:45.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:45.440]     }
[16:06:45.440]     ...future.result <- base::tryCatch({
[16:06:45.440]         base::withCallingHandlers({
[16:06:45.440]             ...future.value <- base::withVisible(base::local({
[16:06:45.440]                 ...future.makeSendCondition <- base::local({
[16:06:45.440]                   sendCondition <- NULL
[16:06:45.440]                   function(frame = 1L) {
[16:06:45.440]                     if (is.function(sendCondition)) 
[16:06:45.440]                       return(sendCondition)
[16:06:45.440]                     ns <- getNamespace("parallel")
[16:06:45.440]                     if (exists("sendData", mode = "function", 
[16:06:45.440]                       envir = ns)) {
[16:06:45.440]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:45.440]                         envir = ns)
[16:06:45.440]                       envir <- sys.frame(frame)
[16:06:45.440]                       master <- NULL
[16:06:45.440]                       while (!identical(envir, .GlobalEnv) && 
[16:06:45.440]                         !identical(envir, emptyenv())) {
[16:06:45.440]                         if (exists("master", mode = "list", envir = envir, 
[16:06:45.440]                           inherits = FALSE)) {
[16:06:45.440]                           master <- get("master", mode = "list", 
[16:06:45.440]                             envir = envir, inherits = FALSE)
[16:06:45.440]                           if (inherits(master, c("SOCKnode", 
[16:06:45.440]                             "SOCK0node"))) {
[16:06:45.440]                             sendCondition <<- function(cond) {
[16:06:45.440]                               data <- list(type = "VALUE", value = cond, 
[16:06:45.440]                                 success = TRUE)
[16:06:45.440]                               parallel_sendData(master, data)
[16:06:45.440]                             }
[16:06:45.440]                             return(sendCondition)
[16:06:45.440]                           }
[16:06:45.440]                         }
[16:06:45.440]                         frame <- frame + 1L
[16:06:45.440]                         envir <- sys.frame(frame)
[16:06:45.440]                       }
[16:06:45.440]                     }
[16:06:45.440]                     sendCondition <<- function(cond) NULL
[16:06:45.440]                   }
[16:06:45.440]                 })
[16:06:45.440]                 withCallingHandlers({
[16:06:45.440]                   {
[16:06:45.440]                     print(1:50)
[16:06:45.440]                     str(1:50)
[16:06:45.440]                     cat(letters, sep = "-")
[16:06:45.440]                     cat(1:6, collapse = "\n")
[16:06:45.440]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:45.440]                     42L
[16:06:45.440]                   }
[16:06:45.440]                 }, immediateCondition = function(cond) {
[16:06:45.440]                   sendCondition <- ...future.makeSendCondition()
[16:06:45.440]                   sendCondition(cond)
[16:06:45.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.440]                   {
[16:06:45.440]                     inherits <- base::inherits
[16:06:45.440]                     invokeRestart <- base::invokeRestart
[16:06:45.440]                     is.null <- base::is.null
[16:06:45.440]                     muffled <- FALSE
[16:06:45.440]                     if (inherits(cond, "message")) {
[16:06:45.440]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:45.440]                       if (muffled) 
[16:06:45.440]                         invokeRestart("muffleMessage")
[16:06:45.440]                     }
[16:06:45.440]                     else if (inherits(cond, "warning")) {
[16:06:45.440]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:45.440]                       if (muffled) 
[16:06:45.440]                         invokeRestart("muffleWarning")
[16:06:45.440]                     }
[16:06:45.440]                     else if (inherits(cond, "condition")) {
[16:06:45.440]                       if (!is.null(pattern)) {
[16:06:45.440]                         computeRestarts <- base::computeRestarts
[16:06:45.440]                         grepl <- base::grepl
[16:06:45.440]                         restarts <- computeRestarts(cond)
[16:06:45.440]                         for (restart in restarts) {
[16:06:45.440]                           name <- restart$name
[16:06:45.440]                           if (is.null(name)) 
[16:06:45.440]                             next
[16:06:45.440]                           if (!grepl(pattern, name)) 
[16:06:45.440]                             next
[16:06:45.440]                           invokeRestart(restart)
[16:06:45.440]                           muffled <- TRUE
[16:06:45.440]                           break
[16:06:45.440]                         }
[16:06:45.440]                       }
[16:06:45.440]                     }
[16:06:45.440]                     invisible(muffled)
[16:06:45.440]                   }
[16:06:45.440]                   muffleCondition(cond)
[16:06:45.440]                 })
[16:06:45.440]             }))
[16:06:45.440]             future::FutureResult(value = ...future.value$value, 
[16:06:45.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.440]                   ...future.rng), globalenv = if (FALSE) 
[16:06:45.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:45.440]                     ...future.globalenv.names))
[16:06:45.440]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:45.440]         }, condition = base::local({
[16:06:45.440]             c <- base::c
[16:06:45.440]             inherits <- base::inherits
[16:06:45.440]             invokeRestart <- base::invokeRestart
[16:06:45.440]             length <- base::length
[16:06:45.440]             list <- base::list
[16:06:45.440]             seq.int <- base::seq.int
[16:06:45.440]             signalCondition <- base::signalCondition
[16:06:45.440]             sys.calls <- base::sys.calls
[16:06:45.440]             `[[` <- base::`[[`
[16:06:45.440]             `+` <- base::`+`
[16:06:45.440]             `<<-` <- base::`<<-`
[16:06:45.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:45.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:45.440]                   3L)]
[16:06:45.440]             }
[16:06:45.440]             function(cond) {
[16:06:45.440]                 is_error <- inherits(cond, "error")
[16:06:45.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:45.440]                   NULL)
[16:06:45.440]                 if (is_error) {
[16:06:45.440]                   sessionInformation <- function() {
[16:06:45.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:45.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:45.440]                       search = base::search(), system = base::Sys.info())
[16:06:45.440]                   }
[16:06:45.440]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:45.440]                     cond$call), session = sessionInformation(), 
[16:06:45.440]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:45.440]                   signalCondition(cond)
[16:06:45.440]                 }
[16:06:45.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:45.440]                 "immediateCondition"))) {
[16:06:45.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:45.440]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:45.440]                   if (TRUE && !signal) {
[16:06:45.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.440]                     {
[16:06:45.440]                       inherits <- base::inherits
[16:06:45.440]                       invokeRestart <- base::invokeRestart
[16:06:45.440]                       is.null <- base::is.null
[16:06:45.440]                       muffled <- FALSE
[16:06:45.440]                       if (inherits(cond, "message")) {
[16:06:45.440]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.440]                         if (muffled) 
[16:06:45.440]                           invokeRestart("muffleMessage")
[16:06:45.440]                       }
[16:06:45.440]                       else if (inherits(cond, "warning")) {
[16:06:45.440]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.440]                         if (muffled) 
[16:06:45.440]                           invokeRestart("muffleWarning")
[16:06:45.440]                       }
[16:06:45.440]                       else if (inherits(cond, "condition")) {
[16:06:45.440]                         if (!is.null(pattern)) {
[16:06:45.440]                           computeRestarts <- base::computeRestarts
[16:06:45.440]                           grepl <- base::grepl
[16:06:45.440]                           restarts <- computeRestarts(cond)
[16:06:45.440]                           for (restart in restarts) {
[16:06:45.440]                             name <- restart$name
[16:06:45.440]                             if (is.null(name)) 
[16:06:45.440]                               next
[16:06:45.440]                             if (!grepl(pattern, name)) 
[16:06:45.440]                               next
[16:06:45.440]                             invokeRestart(restart)
[16:06:45.440]                             muffled <- TRUE
[16:06:45.440]                             break
[16:06:45.440]                           }
[16:06:45.440]                         }
[16:06:45.440]                       }
[16:06:45.440]                       invisible(muffled)
[16:06:45.440]                     }
[16:06:45.440]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.440]                   }
[16:06:45.440]                 }
[16:06:45.440]                 else {
[16:06:45.440]                   if (TRUE) {
[16:06:45.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.440]                     {
[16:06:45.440]                       inherits <- base::inherits
[16:06:45.440]                       invokeRestart <- base::invokeRestart
[16:06:45.440]                       is.null <- base::is.null
[16:06:45.440]                       muffled <- FALSE
[16:06:45.440]                       if (inherits(cond, "message")) {
[16:06:45.440]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.440]                         if (muffled) 
[16:06:45.440]                           invokeRestart("muffleMessage")
[16:06:45.440]                       }
[16:06:45.440]                       else if (inherits(cond, "warning")) {
[16:06:45.440]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.440]                         if (muffled) 
[16:06:45.440]                           invokeRestart("muffleWarning")
[16:06:45.440]                       }
[16:06:45.440]                       else if (inherits(cond, "condition")) {
[16:06:45.440]                         if (!is.null(pattern)) {
[16:06:45.440]                           computeRestarts <- base::computeRestarts
[16:06:45.440]                           grepl <- base::grepl
[16:06:45.440]                           restarts <- computeRestarts(cond)
[16:06:45.440]                           for (restart in restarts) {
[16:06:45.440]                             name <- restart$name
[16:06:45.440]                             if (is.null(name)) 
[16:06:45.440]                               next
[16:06:45.440]                             if (!grepl(pattern, name)) 
[16:06:45.440]                               next
[16:06:45.440]                             invokeRestart(restart)
[16:06:45.440]                             muffled <- TRUE
[16:06:45.440]                             break
[16:06:45.440]                           }
[16:06:45.440]                         }
[16:06:45.440]                       }
[16:06:45.440]                       invisible(muffled)
[16:06:45.440]                     }
[16:06:45.440]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.440]                   }
[16:06:45.440]                 }
[16:06:45.440]             }
[16:06:45.440]         }))
[16:06:45.440]     }, error = function(ex) {
[16:06:45.440]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:45.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.440]                 ...future.rng), started = ...future.startTime, 
[16:06:45.440]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:45.440]             version = "1.8"), class = "FutureResult")
[16:06:45.440]     }, finally = {
[16:06:45.440]         if (!identical(...future.workdir, getwd())) 
[16:06:45.440]             setwd(...future.workdir)
[16:06:45.440]         {
[16:06:45.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:45.440]                 ...future.oldOptions$nwarnings <- NULL
[16:06:45.440]             }
[16:06:45.440]             base::options(...future.oldOptions)
[16:06:45.440]             if (.Platform$OS.type == "windows") {
[16:06:45.440]                 old_names <- names(...future.oldEnvVars)
[16:06:45.440]                 envs <- base::Sys.getenv()
[16:06:45.440]                 names <- names(envs)
[16:06:45.440]                 common <- intersect(names, old_names)
[16:06:45.440]                 added <- setdiff(names, old_names)
[16:06:45.440]                 removed <- setdiff(old_names, names)
[16:06:45.440]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:45.440]                   envs[common]]
[16:06:45.440]                 NAMES <- toupper(changed)
[16:06:45.440]                 args <- list()
[16:06:45.440]                 for (kk in seq_along(NAMES)) {
[16:06:45.440]                   name <- changed[[kk]]
[16:06:45.440]                   NAME <- NAMES[[kk]]
[16:06:45.440]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.440]                     next
[16:06:45.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.440]                 }
[16:06:45.440]                 NAMES <- toupper(added)
[16:06:45.440]                 for (kk in seq_along(NAMES)) {
[16:06:45.440]                   name <- added[[kk]]
[16:06:45.440]                   NAME <- NAMES[[kk]]
[16:06:45.440]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.440]                     next
[16:06:45.440]                   args[[name]] <- ""
[16:06:45.440]                 }
[16:06:45.440]                 NAMES <- toupper(removed)
[16:06:45.440]                 for (kk in seq_along(NAMES)) {
[16:06:45.440]                   name <- removed[[kk]]
[16:06:45.440]                   NAME <- NAMES[[kk]]
[16:06:45.440]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.440]                     next
[16:06:45.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.440]                 }
[16:06:45.440]                 if (length(args) > 0) 
[16:06:45.440]                   base::do.call(base::Sys.setenv, args = args)
[16:06:45.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:45.440]             }
[16:06:45.440]             else {
[16:06:45.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:45.440]             }
[16:06:45.440]             {
[16:06:45.440]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:45.440]                   0L) {
[16:06:45.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:45.440]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:45.440]                   base::options(opts)
[16:06:45.440]                 }
[16:06:45.440]                 {
[16:06:45.440]                   {
[16:06:45.440]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:45.440]                     NULL
[16:06:45.440]                   }
[16:06:45.440]                   options(future.plan = NULL)
[16:06:45.440]                   if (is.na(NA_character_)) 
[16:06:45.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:45.440]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:45.440]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:45.440]                     envir = parent.frame()) 
[16:06:45.440]                   {
[16:06:45.440]                     if (is.function(workers)) 
[16:06:45.440]                       workers <- workers()
[16:06:45.440]                     workers <- structure(as.integer(workers), 
[16:06:45.440]                       class = class(workers))
[16:06:45.440]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:45.440]                       workers >= 1)
[16:06:45.440]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:45.440]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:45.440]                     }
[16:06:45.440]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:45.440]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:45.440]                       envir = envir)
[16:06:45.440]                     if (!future$lazy) 
[16:06:45.440]                       future <- run(future)
[16:06:45.440]                     invisible(future)
[16:06:45.440]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:45.440]                 }
[16:06:45.440]             }
[16:06:45.440]         }
[16:06:45.440]     })
[16:06:45.440]     if (FALSE) {
[16:06:45.440]         base::sink(type = "output", split = FALSE)
[16:06:45.440]         if (NA) {
[16:06:45.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:45.440]         }
[16:06:45.440]         else {
[16:06:45.440]             ...future.result["stdout"] <- base::list(NULL)
[16:06:45.440]         }
[16:06:45.440]         base::close(...future.stdout)
[16:06:45.440]         ...future.stdout <- NULL
[16:06:45.440]     }
[16:06:45.440]     ...future.result$conditions <- ...future.conditions
[16:06:45.440]     ...future.result$finished <- base::Sys.time()
[16:06:45.440]     ...future.result
[16:06:45.440] }
[16:06:45.443] MultisessionFuture started
[16:06:45.443] - Launch lazy future ... done
[16:06:45.443] run() for ‘MultisessionFuture’ ... done
[16:06:45.443] result() for ClusterFuture ...
[16:06:45.443] receiveMessageFromWorker() for ClusterFuture ...
[16:06:45.443] - Validating connection of MultisessionFuture
[16:06:45.488] - received message: FutureResult
[16:06:45.488] - Received FutureResult
[16:06:45.489] - Erased future from FutureRegistry
[16:06:45.489] result() for ClusterFuture ...
[16:06:45.489] - result already collected: FutureResult
[16:06:45.489] result() for ClusterFuture ... done
[16:06:45.489] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:45.489] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-06 16:06:45"
 $ finished    : POSIXct[1:1], format: "2025-01-06 16:06:45"
 $ session_uuid: chr "8a740ab0-1dc6-8e1f-1e6e-7e40ad691e23"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "11666ca4073c"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92488
  .. ..$ time  : POSIXct[1:1], format: "2025-01-06 16:06:44"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[16:06:45.496] result() for ClusterFuture ...
[16:06:45.497] - result already collected: FutureResult
[16:06:45.497] result() for ClusterFuture ... done
[16:06:45.497] result() for ClusterFuture ...
[16:06:45.497] - result already collected: FutureResult
[16:06:45.497] result() for ClusterFuture ... done
[16:06:45.497] getGlobalsAndPackages() ...
[16:06:45.497] Searching for globals...
[16:06:45.500] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[16:06:45.500] Searching for globals ... DONE
[16:06:45.500] Resolving globals: FALSE
[16:06:45.501] 
[16:06:45.501] - packages: [1] ‘utils’
[16:06:45.501] getGlobalsAndPackages() ... DONE
[16:06:45.501] run() for ‘Future’ ...
[16:06:45.501] - state: ‘created’
[16:06:45.501] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:45.515] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:45.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:45.515]   - Field: ‘node’
[16:06:45.516]   - Field: ‘label’
[16:06:45.516]   - Field: ‘local’
[16:06:45.516]   - Field: ‘owner’
[16:06:45.516]   - Field: ‘envir’
[16:06:45.516]   - Field: ‘workers’
[16:06:45.516]   - Field: ‘packages’
[16:06:45.516]   - Field: ‘gc’
[16:06:45.516]   - Field: ‘conditions’
[16:06:45.516]   - Field: ‘persistent’
[16:06:45.516]   - Field: ‘expr’
[16:06:45.517]   - Field: ‘uuid’
[16:06:45.517]   - Field: ‘seed’
[16:06:45.517]   - Field: ‘version’
[16:06:45.517]   - Field: ‘result’
[16:06:45.517]   - Field: ‘asynchronous’
[16:06:45.517]   - Field: ‘calls’
[16:06:45.517]   - Field: ‘globals’
[16:06:45.517]   - Field: ‘stdout’
[16:06:45.517]   - Field: ‘earlySignal’
[16:06:45.517]   - Field: ‘lazy’
[16:06:45.517]   - Field: ‘state’
[16:06:45.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:45.518] - Launch lazy future ...
[16:06:45.518] Packages needed by the future expression (n = 1): ‘utils’
[16:06:45.518] Packages needed by future strategies (n = 0): <none>
[16:06:45.518] {
[16:06:45.518]     {
[16:06:45.518]         {
[16:06:45.518]             ...future.startTime <- base::Sys.time()
[16:06:45.518]             {
[16:06:45.518]                 {
[16:06:45.518]                   {
[16:06:45.518]                     {
[16:06:45.518]                       {
[16:06:45.518]                         base::local({
[16:06:45.518]                           has_future <- base::requireNamespace("future", 
[16:06:45.518]                             quietly = TRUE)
[16:06:45.518]                           if (has_future) {
[16:06:45.518]                             ns <- base::getNamespace("future")
[16:06:45.518]                             version <- ns[[".package"]][["version"]]
[16:06:45.518]                             if (is.null(version)) 
[16:06:45.518]                               version <- utils::packageVersion("future")
[16:06:45.518]                           }
[16:06:45.518]                           else {
[16:06:45.518]                             version <- NULL
[16:06:45.518]                           }
[16:06:45.518]                           if (!has_future || version < "1.8.0") {
[16:06:45.518]                             info <- base::c(r_version = base::gsub("R version ", 
[16:06:45.518]                               "", base::R.version$version.string), 
[16:06:45.518]                               platform = base::sprintf("%s (%s-bit)", 
[16:06:45.518]                                 base::R.version$platform, 8 * 
[16:06:45.518]                                   base::.Machine$sizeof.pointer), 
[16:06:45.518]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:45.518]                                 "release", "version")], collapse = " "), 
[16:06:45.518]                               hostname = base::Sys.info()[["nodename"]])
[16:06:45.518]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:06:45.518]                               info)
[16:06:45.518]                             info <- base::paste(info, collapse = "; ")
[16:06:45.518]                             if (!has_future) {
[16:06:45.518]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:45.518]                                 info)
[16:06:45.518]                             }
[16:06:45.518]                             else {
[16:06:45.518]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:45.518]                                 info, version)
[16:06:45.518]                             }
[16:06:45.518]                             base::stop(msg)
[16:06:45.518]                           }
[16:06:45.518]                         })
[16:06:45.518]                       }
[16:06:45.518]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:45.518]                       base::options(mc.cores = 1L)
[16:06:45.518]                     }
[16:06:45.518]                     base::local({
[16:06:45.518]                       for (pkg in "utils") {
[16:06:45.518]                         base::loadNamespace(pkg)
[16:06:45.518]                         base::library(pkg, character.only = TRUE)
[16:06:45.518]                       }
[16:06:45.518]                     })
[16:06:45.518]                   }
[16:06:45.518]                   options(future.plan = NULL)
[16:06:45.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:45.518]                 }
[16:06:45.518]                 ...future.workdir <- getwd()
[16:06:45.518]             }
[16:06:45.518]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:45.518]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:45.518]         }
[16:06:45.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:45.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:45.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:45.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:45.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:45.518]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:45.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:45.518]             base::names(...future.oldOptions))
[16:06:45.518]     }
[16:06:45.518]     if (TRUE) {
[16:06:45.518]     }
[16:06:45.518]     else {
[16:06:45.518]         if (NA) {
[16:06:45.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:45.518]                 open = "w")
[16:06:45.518]         }
[16:06:45.518]         else {
[16:06:45.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:45.518]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:45.518]         }
[16:06:45.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:45.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:45.518]             base::sink(type = "output", split = FALSE)
[16:06:45.518]             base::close(...future.stdout)
[16:06:45.518]         }, add = TRUE)
[16:06:45.518]     }
[16:06:45.518]     ...future.frame <- base::sys.nframe()
[16:06:45.518]     ...future.conditions <- base::list()
[16:06:45.518]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:45.518]     if (FALSE) {
[16:06:45.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:45.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:45.518]     }
[16:06:45.518]     ...future.result <- base::tryCatch({
[16:06:45.518]         base::withCallingHandlers({
[16:06:45.518]             ...future.value <- base::withVisible(base::local({
[16:06:45.518]                 ...future.makeSendCondition <- base::local({
[16:06:45.518]                   sendCondition <- NULL
[16:06:45.518]                   function(frame = 1L) {
[16:06:45.518]                     if (is.function(sendCondition)) 
[16:06:45.518]                       return(sendCondition)
[16:06:45.518]                     ns <- getNamespace("parallel")
[16:06:45.518]                     if (exists("sendData", mode = "function", 
[16:06:45.518]                       envir = ns)) {
[16:06:45.518]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:45.518]                         envir = ns)
[16:06:45.518]                       envir <- sys.frame(frame)
[16:06:45.518]                       master <- NULL
[16:06:45.518]                       while (!identical(envir, .GlobalEnv) && 
[16:06:45.518]                         !identical(envir, emptyenv())) {
[16:06:45.518]                         if (exists("master", mode = "list", envir = envir, 
[16:06:45.518]                           inherits = FALSE)) {
[16:06:45.518]                           master <- get("master", mode = "list", 
[16:06:45.518]                             envir = envir, inherits = FALSE)
[16:06:45.518]                           if (inherits(master, c("SOCKnode", 
[16:06:45.518]                             "SOCK0node"))) {
[16:06:45.518]                             sendCondition <<- function(cond) {
[16:06:45.518]                               data <- list(type = "VALUE", value = cond, 
[16:06:45.518]                                 success = TRUE)
[16:06:45.518]                               parallel_sendData(master, data)
[16:06:45.518]                             }
[16:06:45.518]                             return(sendCondition)
[16:06:45.518]                           }
[16:06:45.518]                         }
[16:06:45.518]                         frame <- frame + 1L
[16:06:45.518]                         envir <- sys.frame(frame)
[16:06:45.518]                       }
[16:06:45.518]                     }
[16:06:45.518]                     sendCondition <<- function(cond) NULL
[16:06:45.518]                   }
[16:06:45.518]                 })
[16:06:45.518]                 withCallingHandlers({
[16:06:45.518]                   {
[16:06:45.518]                     print(1:50)
[16:06:45.518]                     str(1:50)
[16:06:45.518]                     cat(letters, sep = "-")
[16:06:45.518]                     cat(1:6, collapse = "\n")
[16:06:45.518]                     write.table(datasets::iris[1:10, ], sep = "\t")
[16:06:45.518]                     42L
[16:06:45.518]                   }
[16:06:45.518]                 }, immediateCondition = function(cond) {
[16:06:45.518]                   sendCondition <- ...future.makeSendCondition()
[16:06:45.518]                   sendCondition(cond)
[16:06:45.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.518]                   {
[16:06:45.518]                     inherits <- base::inherits
[16:06:45.518]                     invokeRestart <- base::invokeRestart
[16:06:45.518]                     is.null <- base::is.null
[16:06:45.518]                     muffled <- FALSE
[16:06:45.518]                     if (inherits(cond, "message")) {
[16:06:45.518]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:45.518]                       if (muffled) 
[16:06:45.518]                         invokeRestart("muffleMessage")
[16:06:45.518]                     }
[16:06:45.518]                     else if (inherits(cond, "warning")) {
[16:06:45.518]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:45.518]                       if (muffled) 
[16:06:45.518]                         invokeRestart("muffleWarning")
[16:06:45.518]                     }
[16:06:45.518]                     else if (inherits(cond, "condition")) {
[16:06:45.518]                       if (!is.null(pattern)) {
[16:06:45.518]                         computeRestarts <- base::computeRestarts
[16:06:45.518]                         grepl <- base::grepl
[16:06:45.518]                         restarts <- computeRestarts(cond)
[16:06:45.518]                         for (restart in restarts) {
[16:06:45.518]                           name <- restart$name
[16:06:45.518]                           if (is.null(name)) 
[16:06:45.518]                             next
[16:06:45.518]                           if (!grepl(pattern, name)) 
[16:06:45.518]                             next
[16:06:45.518]                           invokeRestart(restart)
[16:06:45.518]                           muffled <- TRUE
[16:06:45.518]                           break
[16:06:45.518]                         }
[16:06:45.518]                       }
[16:06:45.518]                     }
[16:06:45.518]                     invisible(muffled)
[16:06:45.518]                   }
[16:06:45.518]                   muffleCondition(cond)
[16:06:45.518]                 })
[16:06:45.518]             }))
[16:06:45.518]             future::FutureResult(value = ...future.value$value, 
[16:06:45.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.518]                   ...future.rng), globalenv = if (FALSE) 
[16:06:45.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:45.518]                     ...future.globalenv.names))
[16:06:45.518]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:45.518]         }, condition = base::local({
[16:06:45.518]             c <- base::c
[16:06:45.518]             inherits <- base::inherits
[16:06:45.518]             invokeRestart <- base::invokeRestart
[16:06:45.518]             length <- base::length
[16:06:45.518]             list <- base::list
[16:06:45.518]             seq.int <- base::seq.int
[16:06:45.518]             signalCondition <- base::signalCondition
[16:06:45.518]             sys.calls <- base::sys.calls
[16:06:45.518]             `[[` <- base::`[[`
[16:06:45.518]             `+` <- base::`+`
[16:06:45.518]             `<<-` <- base::`<<-`
[16:06:45.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:45.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:45.518]                   3L)]
[16:06:45.518]             }
[16:06:45.518]             function(cond) {
[16:06:45.518]                 is_error <- inherits(cond, "error")
[16:06:45.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:45.518]                   NULL)
[16:06:45.518]                 if (is_error) {
[16:06:45.518]                   sessionInformation <- function() {
[16:06:45.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:45.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:45.518]                       search = base::search(), system = base::Sys.info())
[16:06:45.518]                   }
[16:06:45.518]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:45.518]                     cond$call), session = sessionInformation(), 
[16:06:45.518]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:45.518]                   signalCondition(cond)
[16:06:45.518]                 }
[16:06:45.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:45.518]                 "immediateCondition"))) {
[16:06:45.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:45.518]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:45.518]                   if (TRUE && !signal) {
[16:06:45.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.518]                     {
[16:06:45.518]                       inherits <- base::inherits
[16:06:45.518]                       invokeRestart <- base::invokeRestart
[16:06:45.518]                       is.null <- base::is.null
[16:06:45.518]                       muffled <- FALSE
[16:06:45.518]                       if (inherits(cond, "message")) {
[16:06:45.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.518]                         if (muffled) 
[16:06:45.518]                           invokeRestart("muffleMessage")
[16:06:45.518]                       }
[16:06:45.518]                       else if (inherits(cond, "warning")) {
[16:06:45.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.518]                         if (muffled) 
[16:06:45.518]                           invokeRestart("muffleWarning")
[16:06:45.518]                       }
[16:06:45.518]                       else if (inherits(cond, "condition")) {
[16:06:45.518]                         if (!is.null(pattern)) {
[16:06:45.518]                           computeRestarts <- base::computeRestarts
[16:06:45.518]                           grepl <- base::grepl
[16:06:45.518]                           restarts <- computeRestarts(cond)
[16:06:45.518]                           for (restart in restarts) {
[16:06:45.518]                             name <- restart$name
[16:06:45.518]                             if (is.null(name)) 
[16:06:45.518]                               next
[16:06:45.518]                             if (!grepl(pattern, name)) 
[16:06:45.518]                               next
[16:06:45.518]                             invokeRestart(restart)
[16:06:45.518]                             muffled <- TRUE
[16:06:45.518]                             break
[16:06:45.518]                           }
[16:06:45.518]                         }
[16:06:45.518]                       }
[16:06:45.518]                       invisible(muffled)
[16:06:45.518]                     }
[16:06:45.518]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.518]                   }
[16:06:45.518]                 }
[16:06:45.518]                 else {
[16:06:45.518]                   if (TRUE) {
[16:06:45.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.518]                     {
[16:06:45.518]                       inherits <- base::inherits
[16:06:45.518]                       invokeRestart <- base::invokeRestart
[16:06:45.518]                       is.null <- base::is.null
[16:06:45.518]                       muffled <- FALSE
[16:06:45.518]                       if (inherits(cond, "message")) {
[16:06:45.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.518]                         if (muffled) 
[16:06:45.518]                           invokeRestart("muffleMessage")
[16:06:45.518]                       }
[16:06:45.518]                       else if (inherits(cond, "warning")) {
[16:06:45.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.518]                         if (muffled) 
[16:06:45.518]                           invokeRestart("muffleWarning")
[16:06:45.518]                       }
[16:06:45.518]                       else if (inherits(cond, "condition")) {
[16:06:45.518]                         if (!is.null(pattern)) {
[16:06:45.518]                           computeRestarts <- base::computeRestarts
[16:06:45.518]                           grepl <- base::grepl
[16:06:45.518]                           restarts <- computeRestarts(cond)
[16:06:45.518]                           for (restart in restarts) {
[16:06:45.518]                             name <- restart$name
[16:06:45.518]                             if (is.null(name)) 
[16:06:45.518]                               next
[16:06:45.518]                             if (!grepl(pattern, name)) 
[16:06:45.518]                               next
[16:06:45.518]                             invokeRestart(restart)
[16:06:45.518]                             muffled <- TRUE
[16:06:45.518]                             break
[16:06:45.518]                           }
[16:06:45.518]                         }
[16:06:45.518]                       }
[16:06:45.518]                       invisible(muffled)
[16:06:45.518]                     }
[16:06:45.518]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.518]                   }
[16:06:45.518]                 }
[16:06:45.518]             }
[16:06:45.518]         }))
[16:06:45.518]     }, error = function(ex) {
[16:06:45.518]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:45.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.518]                 ...future.rng), started = ...future.startTime, 
[16:06:45.518]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:45.518]             version = "1.8"), class = "FutureResult")
[16:06:45.518]     }, finally = {
[16:06:45.518]         if (!identical(...future.workdir, getwd())) 
[16:06:45.518]             setwd(...future.workdir)
[16:06:45.518]         {
[16:06:45.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:45.518]                 ...future.oldOptions$nwarnings <- NULL
[16:06:45.518]             }
[16:06:45.518]             base::options(...future.oldOptions)
[16:06:45.518]             if (.Platform$OS.type == "windows") {
[16:06:45.518]                 old_names <- names(...future.oldEnvVars)
[16:06:45.518]                 envs <- base::Sys.getenv()
[16:06:45.518]                 names <- names(envs)
[16:06:45.518]                 common <- intersect(names, old_names)
[16:06:45.518]                 added <- setdiff(names, old_names)
[16:06:45.518]                 removed <- setdiff(old_names, names)
[16:06:45.518]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:45.518]                   envs[common]]
[16:06:45.518]                 NAMES <- toupper(changed)
[16:06:45.518]                 args <- list()
[16:06:45.518]                 for (kk in seq_along(NAMES)) {
[16:06:45.518]                   name <- changed[[kk]]
[16:06:45.518]                   NAME <- NAMES[[kk]]
[16:06:45.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.518]                     next
[16:06:45.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.518]                 }
[16:06:45.518]                 NAMES <- toupper(added)
[16:06:45.518]                 for (kk in seq_along(NAMES)) {
[16:06:45.518]                   name <- added[[kk]]
[16:06:45.518]                   NAME <- NAMES[[kk]]
[16:06:45.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.518]                     next
[16:06:45.518]                   args[[name]] <- ""
[16:06:45.518]                 }
[16:06:45.518]                 NAMES <- toupper(removed)
[16:06:45.518]                 for (kk in seq_along(NAMES)) {
[16:06:45.518]                   name <- removed[[kk]]
[16:06:45.518]                   NAME <- NAMES[[kk]]
[16:06:45.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.518]                     next
[16:06:45.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.518]                 }
[16:06:45.518]                 if (length(args) > 0) 
[16:06:45.518]                   base::do.call(base::Sys.setenv, args = args)
[16:06:45.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:45.518]             }
[16:06:45.518]             else {
[16:06:45.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:45.518]             }
[16:06:45.518]             {
[16:06:45.518]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:45.518]                   0L) {
[16:06:45.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:45.518]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:45.518]                   base::options(opts)
[16:06:45.518]                 }
[16:06:45.518]                 {
[16:06:45.518]                   {
[16:06:45.518]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:45.518]                     NULL
[16:06:45.518]                   }
[16:06:45.518]                   options(future.plan = NULL)
[16:06:45.518]                   if (is.na(NA_character_)) 
[16:06:45.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:45.518]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:45.518]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:45.518]                     envir = parent.frame()) 
[16:06:45.518]                   {
[16:06:45.518]                     if (is.function(workers)) 
[16:06:45.518]                       workers <- workers()
[16:06:45.518]                     workers <- structure(as.integer(workers), 
[16:06:45.518]                       class = class(workers))
[16:06:45.518]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:45.518]                       workers >= 1)
[16:06:45.518]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:45.518]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:45.518]                     }
[16:06:45.518]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:45.518]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:45.518]                       envir = envir)
[16:06:45.518]                     if (!future$lazy) 
[16:06:45.518]                       future <- run(future)
[16:06:45.518]                     invisible(future)
[16:06:45.518]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:45.518]                 }
[16:06:45.518]             }
[16:06:45.518]         }
[16:06:45.518]     })
[16:06:45.518]     if (FALSE) {
[16:06:45.518]         base::sink(type = "output", split = FALSE)
[16:06:45.518]         if (NA) {
[16:06:45.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:45.518]         }
[16:06:45.518]         else {
[16:06:45.518]             ...future.result["stdout"] <- base::list(NULL)
[16:06:45.518]         }
[16:06:45.518]         base::close(...future.stdout)
[16:06:45.518]         ...future.stdout <- NULL
[16:06:45.518]     }
[16:06:45.518]     ...future.result$conditions <- ...future.conditions
[16:06:45.518]     ...future.result$finished <- base::Sys.time()
[16:06:45.518]     ...future.result
[16:06:45.518] }
[16:06:45.521] MultisessionFuture started
[16:06:45.522] - Launch lazy future ... done
[16:06:45.522] run() for ‘MultisessionFuture’ ... done
[16:06:45.522] result() for ClusterFuture ...
[16:06:45.522] receiveMessageFromWorker() for ClusterFuture ...
[16:06:45.522] - Validating connection of MultisessionFuture
[16:06:45.568] - received message: FutureResult
[16:06:45.568] - Received FutureResult
[16:06:45.568] - Erased future from FutureRegistry
[16:06:45.568] result() for ClusterFuture ...
[16:06:45.568] - result already collected: FutureResult
[16:06:45.569] result() for ClusterFuture ... done
[16:06:45.569] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:45.569] result() for ClusterFuture ... done
[16:06:45.569] result() for ClusterFuture ...
[16:06:45.569] - result already collected: FutureResult
[16:06:45.569] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[16:06:45.569] getGlobalsAndPackages() ...
[16:06:45.569] Searching for globals...
[16:06:45.570] - globals found: [1] ‘print’
[16:06:45.570] Searching for globals ... DONE
[16:06:45.570] Resolving globals: FALSE
[16:06:45.570] 
[16:06:45.570] 
[16:06:45.570] getGlobalsAndPackages() ... DONE
[16:06:45.571] run() for ‘Future’ ...
[16:06:45.571] - state: ‘created’
[16:06:45.571] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:45.584] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:45.584] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:45.584]   - Field: ‘node’
[16:06:45.584]   - Field: ‘label’
[16:06:45.584]   - Field: ‘local’
[16:06:45.585]   - Field: ‘owner’
[16:06:45.585]   - Field: ‘envir’
[16:06:45.585]   - Field: ‘workers’
[16:06:45.585]   - Field: ‘packages’
[16:06:45.585]   - Field: ‘gc’
[16:06:45.585]   - Field: ‘conditions’
[16:06:45.585]   - Field: ‘persistent’
[16:06:45.585]   - Field: ‘expr’
[16:06:45.585]   - Field: ‘uuid’
[16:06:45.585]   - Field: ‘seed’
[16:06:45.585]   - Field: ‘version’
[16:06:45.586]   - Field: ‘result’
[16:06:45.586]   - Field: ‘asynchronous’
[16:06:45.586]   - Field: ‘calls’
[16:06:45.586]   - Field: ‘globals’
[16:06:45.586]   - Field: ‘stdout’
[16:06:45.586]   - Field: ‘earlySignal’
[16:06:45.586]   - Field: ‘lazy’
[16:06:45.586]   - Field: ‘state’
[16:06:45.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:45.586] - Launch lazy future ...
[16:06:45.587] Packages needed by the future expression (n = 0): <none>
[16:06:45.587] Packages needed by future strategies (n = 0): <none>
[16:06:45.587] {
[16:06:45.587]     {
[16:06:45.587]         {
[16:06:45.587]             ...future.startTime <- base::Sys.time()
[16:06:45.587]             {
[16:06:45.587]                 {
[16:06:45.587]                   {
[16:06:45.587]                     {
[16:06:45.587]                       base::local({
[16:06:45.587]                         has_future <- base::requireNamespace("future", 
[16:06:45.587]                           quietly = TRUE)
[16:06:45.587]                         if (has_future) {
[16:06:45.587]                           ns <- base::getNamespace("future")
[16:06:45.587]                           version <- ns[[".package"]][["version"]]
[16:06:45.587]                           if (is.null(version)) 
[16:06:45.587]                             version <- utils::packageVersion("future")
[16:06:45.587]                         }
[16:06:45.587]                         else {
[16:06:45.587]                           version <- NULL
[16:06:45.587]                         }
[16:06:45.587]                         if (!has_future || version < "1.8.0") {
[16:06:45.587]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:45.587]                             "", base::R.version$version.string), 
[16:06:45.587]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:45.587]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:45.587]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:45.587]                               "release", "version")], collapse = " "), 
[16:06:45.587]                             hostname = base::Sys.info()[["nodename"]])
[16:06:45.587]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:45.587]                             info)
[16:06:45.587]                           info <- base::paste(info, collapse = "; ")
[16:06:45.587]                           if (!has_future) {
[16:06:45.587]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:45.587]                               info)
[16:06:45.587]                           }
[16:06:45.587]                           else {
[16:06:45.587]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:45.587]                               info, version)
[16:06:45.587]                           }
[16:06:45.587]                           base::stop(msg)
[16:06:45.587]                         }
[16:06:45.587]                       })
[16:06:45.587]                     }
[16:06:45.587]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:45.587]                     base::options(mc.cores = 1L)
[16:06:45.587]                   }
[16:06:45.587]                   options(future.plan = NULL)
[16:06:45.587]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.587]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:45.587]                 }
[16:06:45.587]                 ...future.workdir <- getwd()
[16:06:45.587]             }
[16:06:45.587]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:45.587]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:45.587]         }
[16:06:45.587]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:45.587]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:45.587]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:45.587]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:45.587]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:45.587]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:45.587]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:45.587]             base::names(...future.oldOptions))
[16:06:45.587]     }
[16:06:45.587]     if (FALSE) {
[16:06:45.587]     }
[16:06:45.587]     else {
[16:06:45.587]         if (TRUE) {
[16:06:45.587]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:45.587]                 open = "w")
[16:06:45.587]         }
[16:06:45.587]         else {
[16:06:45.587]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:45.587]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:45.587]         }
[16:06:45.587]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:45.587]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:45.587]             base::sink(type = "output", split = FALSE)
[16:06:45.587]             base::close(...future.stdout)
[16:06:45.587]         }, add = TRUE)
[16:06:45.587]     }
[16:06:45.587]     ...future.frame <- base::sys.nframe()
[16:06:45.587]     ...future.conditions <- base::list()
[16:06:45.587]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:45.587]     if (FALSE) {
[16:06:45.587]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:45.587]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:45.587]     }
[16:06:45.587]     ...future.result <- base::tryCatch({
[16:06:45.587]         base::withCallingHandlers({
[16:06:45.587]             ...future.value <- base::withVisible(base::local({
[16:06:45.587]                 ...future.makeSendCondition <- base::local({
[16:06:45.587]                   sendCondition <- NULL
[16:06:45.587]                   function(frame = 1L) {
[16:06:45.587]                     if (is.function(sendCondition)) 
[16:06:45.587]                       return(sendCondition)
[16:06:45.587]                     ns <- getNamespace("parallel")
[16:06:45.587]                     if (exists("sendData", mode = "function", 
[16:06:45.587]                       envir = ns)) {
[16:06:45.587]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:45.587]                         envir = ns)
[16:06:45.587]                       envir <- sys.frame(frame)
[16:06:45.587]                       master <- NULL
[16:06:45.587]                       while (!identical(envir, .GlobalEnv) && 
[16:06:45.587]                         !identical(envir, emptyenv())) {
[16:06:45.587]                         if (exists("master", mode = "list", envir = envir, 
[16:06:45.587]                           inherits = FALSE)) {
[16:06:45.587]                           master <- get("master", mode = "list", 
[16:06:45.587]                             envir = envir, inherits = FALSE)
[16:06:45.587]                           if (inherits(master, c("SOCKnode", 
[16:06:45.587]                             "SOCK0node"))) {
[16:06:45.587]                             sendCondition <<- function(cond) {
[16:06:45.587]                               data <- list(type = "VALUE", value = cond, 
[16:06:45.587]                                 success = TRUE)
[16:06:45.587]                               parallel_sendData(master, data)
[16:06:45.587]                             }
[16:06:45.587]                             return(sendCondition)
[16:06:45.587]                           }
[16:06:45.587]                         }
[16:06:45.587]                         frame <- frame + 1L
[16:06:45.587]                         envir <- sys.frame(frame)
[16:06:45.587]                       }
[16:06:45.587]                     }
[16:06:45.587]                     sendCondition <<- function(cond) NULL
[16:06:45.587]                   }
[16:06:45.587]                 })
[16:06:45.587]                 withCallingHandlers({
[16:06:45.587]                   print(42)
[16:06:45.587]                 }, immediateCondition = function(cond) {
[16:06:45.587]                   sendCondition <- ...future.makeSendCondition()
[16:06:45.587]                   sendCondition(cond)
[16:06:45.587]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.587]                   {
[16:06:45.587]                     inherits <- base::inherits
[16:06:45.587]                     invokeRestart <- base::invokeRestart
[16:06:45.587]                     is.null <- base::is.null
[16:06:45.587]                     muffled <- FALSE
[16:06:45.587]                     if (inherits(cond, "message")) {
[16:06:45.587]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:45.587]                       if (muffled) 
[16:06:45.587]                         invokeRestart("muffleMessage")
[16:06:45.587]                     }
[16:06:45.587]                     else if (inherits(cond, "warning")) {
[16:06:45.587]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:45.587]                       if (muffled) 
[16:06:45.587]                         invokeRestart("muffleWarning")
[16:06:45.587]                     }
[16:06:45.587]                     else if (inherits(cond, "condition")) {
[16:06:45.587]                       if (!is.null(pattern)) {
[16:06:45.587]                         computeRestarts <- base::computeRestarts
[16:06:45.587]                         grepl <- base::grepl
[16:06:45.587]                         restarts <- computeRestarts(cond)
[16:06:45.587]                         for (restart in restarts) {
[16:06:45.587]                           name <- restart$name
[16:06:45.587]                           if (is.null(name)) 
[16:06:45.587]                             next
[16:06:45.587]                           if (!grepl(pattern, name)) 
[16:06:45.587]                             next
[16:06:45.587]                           invokeRestart(restart)
[16:06:45.587]                           muffled <- TRUE
[16:06:45.587]                           break
[16:06:45.587]                         }
[16:06:45.587]                       }
[16:06:45.587]                     }
[16:06:45.587]                     invisible(muffled)
[16:06:45.587]                   }
[16:06:45.587]                   muffleCondition(cond)
[16:06:45.587]                 })
[16:06:45.587]             }))
[16:06:45.587]             future::FutureResult(value = ...future.value$value, 
[16:06:45.587]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.587]                   ...future.rng), globalenv = if (FALSE) 
[16:06:45.587]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:45.587]                     ...future.globalenv.names))
[16:06:45.587]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:45.587]         }, condition = base::local({
[16:06:45.587]             c <- base::c
[16:06:45.587]             inherits <- base::inherits
[16:06:45.587]             invokeRestart <- base::invokeRestart
[16:06:45.587]             length <- base::length
[16:06:45.587]             list <- base::list
[16:06:45.587]             seq.int <- base::seq.int
[16:06:45.587]             signalCondition <- base::signalCondition
[16:06:45.587]             sys.calls <- base::sys.calls
[16:06:45.587]             `[[` <- base::`[[`
[16:06:45.587]             `+` <- base::`+`
[16:06:45.587]             `<<-` <- base::`<<-`
[16:06:45.587]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:45.587]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:45.587]                   3L)]
[16:06:45.587]             }
[16:06:45.587]             function(cond) {
[16:06:45.587]                 is_error <- inherits(cond, "error")
[16:06:45.587]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:45.587]                   NULL)
[16:06:45.587]                 if (is_error) {
[16:06:45.587]                   sessionInformation <- function() {
[16:06:45.587]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:45.587]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:45.587]                       search = base::search(), system = base::Sys.info())
[16:06:45.587]                   }
[16:06:45.587]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.587]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:45.587]                     cond$call), session = sessionInformation(), 
[16:06:45.587]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:45.587]                   signalCondition(cond)
[16:06:45.587]                 }
[16:06:45.587]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:45.587]                 "immediateCondition"))) {
[16:06:45.587]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:45.587]                   ...future.conditions[[length(...future.conditions) + 
[16:06:45.587]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:45.587]                   if (TRUE && !signal) {
[16:06:45.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.587]                     {
[16:06:45.587]                       inherits <- base::inherits
[16:06:45.587]                       invokeRestart <- base::invokeRestart
[16:06:45.587]                       is.null <- base::is.null
[16:06:45.587]                       muffled <- FALSE
[16:06:45.587]                       if (inherits(cond, "message")) {
[16:06:45.587]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.587]                         if (muffled) 
[16:06:45.587]                           invokeRestart("muffleMessage")
[16:06:45.587]                       }
[16:06:45.587]                       else if (inherits(cond, "warning")) {
[16:06:45.587]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.587]                         if (muffled) 
[16:06:45.587]                           invokeRestart("muffleWarning")
[16:06:45.587]                       }
[16:06:45.587]                       else if (inherits(cond, "condition")) {
[16:06:45.587]                         if (!is.null(pattern)) {
[16:06:45.587]                           computeRestarts <- base::computeRestarts
[16:06:45.587]                           grepl <- base::grepl
[16:06:45.587]                           restarts <- computeRestarts(cond)
[16:06:45.587]                           for (restart in restarts) {
[16:06:45.587]                             name <- restart$name
[16:06:45.587]                             if (is.null(name)) 
[16:06:45.587]                               next
[16:06:45.587]                             if (!grepl(pattern, name)) 
[16:06:45.587]                               next
[16:06:45.587]                             invokeRestart(restart)
[16:06:45.587]                             muffled <- TRUE
[16:06:45.587]                             break
[16:06:45.587]                           }
[16:06:45.587]                         }
[16:06:45.587]                       }
[16:06:45.587]                       invisible(muffled)
[16:06:45.587]                     }
[16:06:45.587]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.587]                   }
[16:06:45.587]                 }
[16:06:45.587]                 else {
[16:06:45.587]                   if (TRUE) {
[16:06:45.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:45.587]                     {
[16:06:45.587]                       inherits <- base::inherits
[16:06:45.587]                       invokeRestart <- base::invokeRestart
[16:06:45.587]                       is.null <- base::is.null
[16:06:45.587]                       muffled <- FALSE
[16:06:45.587]                       if (inherits(cond, "message")) {
[16:06:45.587]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:45.587]                         if (muffled) 
[16:06:45.587]                           invokeRestart("muffleMessage")
[16:06:45.587]                       }
[16:06:45.587]                       else if (inherits(cond, "warning")) {
[16:06:45.587]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:45.587]                         if (muffled) 
[16:06:45.587]                           invokeRestart("muffleWarning")
[16:06:45.587]                       }
[16:06:45.587]                       else if (inherits(cond, "condition")) {
[16:06:45.587]                         if (!is.null(pattern)) {
[16:06:45.587]                           computeRestarts <- base::computeRestarts
[16:06:45.587]                           grepl <- base::grepl
[16:06:45.587]                           restarts <- computeRestarts(cond)
[16:06:45.587]                           for (restart in restarts) {
[16:06:45.587]                             name <- restart$name
[16:06:45.587]                             if (is.null(name)) 
[16:06:45.587]                               next
[16:06:45.587]                             if (!grepl(pattern, name)) 
[16:06:45.587]                               next
[16:06:45.587]                             invokeRestart(restart)
[16:06:45.587]                             muffled <- TRUE
[16:06:45.587]                             break
[16:06:45.587]                           }
[16:06:45.587]                         }
[16:06:45.587]                       }
[16:06:45.587]                       invisible(muffled)
[16:06:45.587]                     }
[16:06:45.587]                     muffleCondition(cond, pattern = "^muffle")
[16:06:45.587]                   }
[16:06:45.587]                 }
[16:06:45.587]             }
[16:06:45.587]         }))
[16:06:45.587]     }, error = function(ex) {
[16:06:45.587]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:45.587]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:45.587]                 ...future.rng), started = ...future.startTime, 
[16:06:45.587]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:45.587]             version = "1.8"), class = "FutureResult")
[16:06:45.587]     }, finally = {
[16:06:45.587]         if (!identical(...future.workdir, getwd())) 
[16:06:45.587]             setwd(...future.workdir)
[16:06:45.587]         {
[16:06:45.587]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:45.587]                 ...future.oldOptions$nwarnings <- NULL
[16:06:45.587]             }
[16:06:45.587]             base::options(...future.oldOptions)
[16:06:45.587]             if (.Platform$OS.type == "windows") {
[16:06:45.587]                 old_names <- names(...future.oldEnvVars)
[16:06:45.587]                 envs <- base::Sys.getenv()
[16:06:45.587]                 names <- names(envs)
[16:06:45.587]                 common <- intersect(names, old_names)
[16:06:45.587]                 added <- setdiff(names, old_names)
[16:06:45.587]                 removed <- setdiff(old_names, names)
[16:06:45.587]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:45.587]                   envs[common]]
[16:06:45.587]                 NAMES <- toupper(changed)
[16:06:45.587]                 args <- list()
[16:06:45.587]                 for (kk in seq_along(NAMES)) {
[16:06:45.587]                   name <- changed[[kk]]
[16:06:45.587]                   NAME <- NAMES[[kk]]
[16:06:45.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.587]                     next
[16:06:45.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.587]                 }
[16:06:45.587]                 NAMES <- toupper(added)
[16:06:45.587]                 for (kk in seq_along(NAMES)) {
[16:06:45.587]                   name <- added[[kk]]
[16:06:45.587]                   NAME <- NAMES[[kk]]
[16:06:45.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.587]                     next
[16:06:45.587]                   args[[name]] <- ""
[16:06:45.587]                 }
[16:06:45.587]                 NAMES <- toupper(removed)
[16:06:45.587]                 for (kk in seq_along(NAMES)) {
[16:06:45.587]                   name <- removed[[kk]]
[16:06:45.587]                   NAME <- NAMES[[kk]]
[16:06:45.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:45.587]                     next
[16:06:45.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:45.587]                 }
[16:06:45.587]                 if (length(args) > 0) 
[16:06:45.587]                   base::do.call(base::Sys.setenv, args = args)
[16:06:45.587]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:45.587]             }
[16:06:45.587]             else {
[16:06:45.587]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:45.587]             }
[16:06:45.587]             {
[16:06:45.587]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:45.587]                   0L) {
[16:06:45.587]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:45.587]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:45.587]                   base::options(opts)
[16:06:45.587]                 }
[16:06:45.587]                 {
[16:06:45.587]                   {
[16:06:45.587]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:45.587]                     NULL
[16:06:45.587]                   }
[16:06:45.587]                   options(future.plan = NULL)
[16:06:45.587]                   if (is.na(NA_character_)) 
[16:06:45.587]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:45.587]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:45.587]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:45.587]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:45.587]                     envir = parent.frame()) 
[16:06:45.587]                   {
[16:06:45.587]                     if (is.function(workers)) 
[16:06:45.587]                       workers <- workers()
[16:06:45.587]                     workers <- structure(as.integer(workers), 
[16:06:45.587]                       class = class(workers))
[16:06:45.587]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:45.587]                       workers >= 1)
[16:06:45.587]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:45.587]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:45.587]                     }
[16:06:45.587]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:45.587]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:45.587]                       envir = envir)
[16:06:45.587]                     if (!future$lazy) 
[16:06:45.587]                       future <- run(future)
[16:06:45.587]                     invisible(future)
[16:06:45.587]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:45.587]                 }
[16:06:45.587]             }
[16:06:45.587]         }
[16:06:45.587]     })
[16:06:45.587]     if (TRUE) {
[16:06:45.587]         base::sink(type = "output", split = FALSE)
[16:06:45.587]         if (TRUE) {
[16:06:45.587]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:45.587]         }
[16:06:45.587]         else {
[16:06:45.587]             ...future.result["stdout"] <- base::list(NULL)
[16:06:45.587]         }
[16:06:45.587]         base::close(...future.stdout)
[16:06:45.587]         ...future.stdout <- NULL
[16:06:45.587]     }
[16:06:45.587]     ...future.result$conditions <- ...future.conditions
[16:06:45.587]     ...future.result$finished <- base::Sys.time()
[16:06:45.587]     ...future.result
[16:06:45.587] }
[16:06:45.590] MultisessionFuture started
[16:06:45.590] - Launch lazy future ... done
[16:06:45.590] run() for ‘MultisessionFuture’ ... done
[16:06:45.590] result() for ClusterFuture ...
[16:06:45.590] receiveMessageFromWorker() for ClusterFuture ...
[16:06:45.590] - Validating connection of MultisessionFuture
[16:06:45.635] - received message: FutureResult
[16:06:45.635] - Received FutureResult
[16:06:45.635] - Erased future from FutureRegistry
[16:06:45.636] result() for ClusterFuture ...
[16:06:45.636] - result already collected: FutureResult
[16:06:45.636] result() for ClusterFuture ... done
[16:06:45.636] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:45.636] result() for ClusterFuture ... done
[16:06:45.636] result() for ClusterFuture ...
[16:06:45.636] - result already collected: FutureResult
[16:06:45.636] result() for ClusterFuture ... done
[16:06:45.636] result() for ClusterFuture ...
[16:06:45.636] - result already collected: FutureResult
[16:06:45.636] result() for ClusterFuture ... done
[1] 42
[16:06:45.637] result() for ClusterFuture ...
[16:06:45.637] - result already collected: FutureResult
[16:06:45.637] result() for ClusterFuture ... done
multisession ... done
Testing with 2 cores ... done
> 
> message("*** Standard output ... DONE")
*** Standard output ... DONE
> 
> source("incl/end.R")
[16:06:45.637] plan(): Setting new future strategy stack:
[16:06:45.638] List of future strategies:
[16:06:45.638] 1. FutureStrategy:
[16:06:45.638]    - args: function (..., envir = parent.frame())
[16:06:45.638]    - tweaked: FALSE
[16:06:45.638]    - call: future::plan(oplan)
[16:06:45.638] plan(): nbrOfWorkers() = 1
> 
