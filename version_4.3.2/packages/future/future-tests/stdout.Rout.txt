
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:27:50.759] plan(): Setting new future strategy stack:
[10:27:50.760] List of future strategies:
[10:27:50.760] 1. sequential:
[10:27:50.760]    - args: function (..., envir = parent.frame())
[10:27:50.760]    - tweaked: FALSE
[10:27:50.760]    - call: future::plan("sequential")
[10:27:50.775] plan(): nbrOfWorkers() = 1
> 
> message("*** Standard output ...")
*** Standard output ...
> 
> truth_rows <- utils::capture.output({
+   print(1:50)
+   str(1:50)
+   cat(letters, sep = "-")
+   cat(1:6, collapse = "\n")
+   write.table(datasets::iris[1:10,], sep = "\t")
+ })
> truth <- paste0(paste(truth_rows, collapse = "\n"), "\n")
> print(truth)
[1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n int [1:50] 1 2 3 4 5 6 7 8 9 10 ...\na-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 \n\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\"\n\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\"\n\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\"\n\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\"\n\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\"\n\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\"\n\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\"\n\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\"\n\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\"\n\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\"\n\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\"\n"
> 
> for (cores in seq_len(min(2L, availCores))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("%s ...", strategy))
+     plan(strategy)
+ 
+     for (stdout in c(TRUE, FALSE, NA)) {
+       message(sprintf("- stdout = %s", stdout))
+ 
+       f <- future({
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       }, stdout = stdout)
+       r <- result(f)
+       str(r)
+       stopifnot(value(f) == 42L)
+       if (is.na(stdout)) {
+         stopifnot(is.null(r$stdout) || r$stdout == "")
+       } else if (stdout) {
+         print(r)
+         stopifnot(identical(r$stdout, truth))
+       } else {
+         stopifnot(is.null(r$stdout))
+       }
+ 
+       v %<-% {
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       } %stdout% stdout
+       out <- utils::capture.output(y <- v)
+       stopifnot(y == 42L)
+       if (is.na(stdout)) {
+         ## Single-core multisession => sequential
+         if (cores > 1L || strategy != "multisession") {
+           stopifnot(out == "")
+         }
+       } else if (stdout) {
+         print(out)
+         stopifnot(identical(out, truth_rows))
+       } else {
+         stopifnot(out == "")
+       }
+ 
+       message("- stdout = structure(TRUE, drop = TRUE)")
+       f <- future(print(42), stdout = structure(TRUE, drop = TRUE))
+       r <- result(f)
+       stopifnot(inherits(r$stdout, "character"))
+       v <- value(f)
+       r <- result(f)
+       stopifnot(is.null(r$stdout))
+     } ## for (stdout ...)
+ 
+     message(sprintf("%s ... done", strategy))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... done", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
sequential ...
[10:27:50.824] plan(): Setting new future strategy stack:
[10:27:50.824] List of future strategies:
[10:27:50.824] 1. sequential:
[10:27:50.824]    - args: function (..., envir = parent.frame())
[10:27:50.824]    - tweaked: FALSE
[10:27:50.824]    - call: plan(strategy)
[10:27:50.835] plan(): nbrOfWorkers() = 1
- stdout = TRUE
[10:27:50.836] getGlobalsAndPackages() ...
[10:27:50.836] Searching for globals...
[10:27:50.846] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:50.846] Searching for globals ... DONE
[10:27:50.847] Resolving globals: FALSE
[10:27:50.847] 
[10:27:50.847] - packages: [1] ‘utils’
[10:27:50.847] getGlobalsAndPackages() ... DONE
[10:27:50.848] run() for ‘Future’ ...
[10:27:50.848] - state: ‘created’
[10:27:50.849] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:50.849] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:50.849] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:50.849]   - Field: ‘label’
[10:27:50.849]   - Field: ‘local’
[10:27:50.849]   - Field: ‘owner’
[10:27:50.850]   - Field: ‘envir’
[10:27:50.850]   - Field: ‘packages’
[10:27:50.850]   - Field: ‘gc’
[10:27:50.850]   - Field: ‘conditions’
[10:27:50.850]   - Field: ‘expr’
[10:27:50.850]   - Field: ‘uuid’
[10:27:50.850]   - Field: ‘seed’
[10:27:50.850]   - Field: ‘version’
[10:27:50.850]   - Field: ‘result’
[10:27:50.850]   - Field: ‘asynchronous’
[10:27:50.851]   - Field: ‘calls’
[10:27:50.851]   - Field: ‘globals’
[10:27:50.851]   - Field: ‘stdout’
[10:27:50.851]   - Field: ‘earlySignal’
[10:27:50.851]   - Field: ‘lazy’
[10:27:50.851]   - Field: ‘state’
[10:27:50.851] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:50.851] - Launch lazy future ...
[10:27:50.852] Packages needed by the future expression (n = 1): ‘utils’
[10:27:50.852] Packages needed by future strategies (n = 0): <none>
[10:27:50.853] {
[10:27:50.853]     {
[10:27:50.853]         {
[10:27:50.853]             ...future.startTime <- base::Sys.time()
[10:27:50.853]             {
[10:27:50.853]                 {
[10:27:50.853]                   {
[10:27:50.853]                     {
[10:27:50.853]                       base::local({
[10:27:50.853]                         has_future <- base::requireNamespace("future", 
[10:27:50.853]                           quietly = TRUE)
[10:27:50.853]                         if (has_future) {
[10:27:50.853]                           ns <- base::getNamespace("future")
[10:27:50.853]                           version <- ns[[".package"]][["version"]]
[10:27:50.853]                           if (is.null(version)) 
[10:27:50.853]                             version <- utils::packageVersion("future")
[10:27:50.853]                         }
[10:27:50.853]                         else {
[10:27:50.853]                           version <- NULL
[10:27:50.853]                         }
[10:27:50.853]                         if (!has_future || version < "1.8.0") {
[10:27:50.853]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:50.853]                             "", base::R.version$version.string), 
[10:27:50.853]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:50.853]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:50.853]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:50.853]                               "release", "version")], collapse = " "), 
[10:27:50.853]                             hostname = base::Sys.info()[["nodename"]])
[10:27:50.853]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:50.853]                             info)
[10:27:50.853]                           info <- base::paste(info, collapse = "; ")
[10:27:50.853]                           if (!has_future) {
[10:27:50.853]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:50.853]                               info)
[10:27:50.853]                           }
[10:27:50.853]                           else {
[10:27:50.853]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:50.853]                               info, version)
[10:27:50.853]                           }
[10:27:50.853]                           base::stop(msg)
[10:27:50.853]                         }
[10:27:50.853]                       })
[10:27:50.853]                     }
[10:27:50.853]                     base::local({
[10:27:50.853]                       for (pkg in "utils") {
[10:27:50.853]                         base::loadNamespace(pkg)
[10:27:50.853]                         base::library(pkg, character.only = TRUE)
[10:27:50.853]                       }
[10:27:50.853]                     })
[10:27:50.853]                   }
[10:27:50.853]                   options(future.plan = NULL)
[10:27:50.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:50.853]                 }
[10:27:50.853]                 ...future.workdir <- getwd()
[10:27:50.853]             }
[10:27:50.853]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:50.853]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:50.853]         }
[10:27:50.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:50.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:50.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:50.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:50.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:50.853]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:50.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:50.853]             base::names(...future.oldOptions))
[10:27:50.853]     }
[10:27:50.853]     if (FALSE) {
[10:27:50.853]     }
[10:27:50.853]     else {
[10:27:50.853]         if (TRUE) {
[10:27:50.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:50.853]                 open = "w")
[10:27:50.853]         }
[10:27:50.853]         else {
[10:27:50.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:50.853]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:50.853]         }
[10:27:50.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:50.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:50.853]             base::sink(type = "output", split = FALSE)
[10:27:50.853]             base::close(...future.stdout)
[10:27:50.853]         }, add = TRUE)
[10:27:50.853]     }
[10:27:50.853]     ...future.frame <- base::sys.nframe()
[10:27:50.853]     ...future.conditions <- base::list()
[10:27:50.853]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:50.853]     if (FALSE) {
[10:27:50.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:50.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:50.853]     }
[10:27:50.853]     ...future.result <- base::tryCatch({
[10:27:50.853]         base::withCallingHandlers({
[10:27:50.853]             ...future.value <- base::withVisible(base::local({
[10:27:50.853]                 print(1:50)
[10:27:50.853]                 str(1:50)
[10:27:50.853]                 cat(letters, sep = "-")
[10:27:50.853]                 cat(1:6, collapse = "\n")
[10:27:50.853]                 write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:50.853]                 42L
[10:27:50.853]             }))
[10:27:50.853]             future::FutureResult(value = ...future.value$value, 
[10:27:50.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.853]                   ...future.rng), globalenv = if (FALSE) 
[10:27:50.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:50.853]                     ...future.globalenv.names))
[10:27:50.853]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:50.853]         }, condition = base::local({
[10:27:50.853]             c <- base::c
[10:27:50.853]             inherits <- base::inherits
[10:27:50.853]             invokeRestart <- base::invokeRestart
[10:27:50.853]             length <- base::length
[10:27:50.853]             list <- base::list
[10:27:50.853]             seq.int <- base::seq.int
[10:27:50.853]             signalCondition <- base::signalCondition
[10:27:50.853]             sys.calls <- base::sys.calls
[10:27:50.853]             `[[` <- base::`[[`
[10:27:50.853]             `+` <- base::`+`
[10:27:50.853]             `<<-` <- base::`<<-`
[10:27:50.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:50.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:50.853]                   3L)]
[10:27:50.853]             }
[10:27:50.853]             function(cond) {
[10:27:50.853]                 is_error <- inherits(cond, "error")
[10:27:50.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:50.853]                   NULL)
[10:27:50.853]                 if (is_error) {
[10:27:50.853]                   sessionInformation <- function() {
[10:27:50.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:50.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:50.853]                       search = base::search(), system = base::Sys.info())
[10:27:50.853]                   }
[10:27:50.853]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:50.853]                     cond$call), session = sessionInformation(), 
[10:27:50.853]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:50.853]                   signalCondition(cond)
[10:27:50.853]                 }
[10:27:50.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:50.853]                 "immediateCondition"))) {
[10:27:50.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:50.853]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:50.853]                   if (TRUE && !signal) {
[10:27:50.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.853]                     {
[10:27:50.853]                       inherits <- base::inherits
[10:27:50.853]                       invokeRestart <- base::invokeRestart
[10:27:50.853]                       is.null <- base::is.null
[10:27:50.853]                       muffled <- FALSE
[10:27:50.853]                       if (inherits(cond, "message")) {
[10:27:50.853]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.853]                         if (muffled) 
[10:27:50.853]                           invokeRestart("muffleMessage")
[10:27:50.853]                       }
[10:27:50.853]                       else if (inherits(cond, "warning")) {
[10:27:50.853]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.853]                         if (muffled) 
[10:27:50.853]                           invokeRestart("muffleWarning")
[10:27:50.853]                       }
[10:27:50.853]                       else if (inherits(cond, "condition")) {
[10:27:50.853]                         if (!is.null(pattern)) {
[10:27:50.853]                           computeRestarts <- base::computeRestarts
[10:27:50.853]                           grepl <- base::grepl
[10:27:50.853]                           restarts <- computeRestarts(cond)
[10:27:50.853]                           for (restart in restarts) {
[10:27:50.853]                             name <- restart$name
[10:27:50.853]                             if (is.null(name)) 
[10:27:50.853]                               next
[10:27:50.853]                             if (!grepl(pattern, name)) 
[10:27:50.853]                               next
[10:27:50.853]                             invokeRestart(restart)
[10:27:50.853]                             muffled <- TRUE
[10:27:50.853]                             break
[10:27:50.853]                           }
[10:27:50.853]                         }
[10:27:50.853]                       }
[10:27:50.853]                       invisible(muffled)
[10:27:50.853]                     }
[10:27:50.853]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.853]                   }
[10:27:50.853]                 }
[10:27:50.853]                 else {
[10:27:50.853]                   if (TRUE) {
[10:27:50.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.853]                     {
[10:27:50.853]                       inherits <- base::inherits
[10:27:50.853]                       invokeRestart <- base::invokeRestart
[10:27:50.853]                       is.null <- base::is.null
[10:27:50.853]                       muffled <- FALSE
[10:27:50.853]                       if (inherits(cond, "message")) {
[10:27:50.853]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.853]                         if (muffled) 
[10:27:50.853]                           invokeRestart("muffleMessage")
[10:27:50.853]                       }
[10:27:50.853]                       else if (inherits(cond, "warning")) {
[10:27:50.853]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.853]                         if (muffled) 
[10:27:50.853]                           invokeRestart("muffleWarning")
[10:27:50.853]                       }
[10:27:50.853]                       else if (inherits(cond, "condition")) {
[10:27:50.853]                         if (!is.null(pattern)) {
[10:27:50.853]                           computeRestarts <- base::computeRestarts
[10:27:50.853]                           grepl <- base::grepl
[10:27:50.853]                           restarts <- computeRestarts(cond)
[10:27:50.853]                           for (restart in restarts) {
[10:27:50.853]                             name <- restart$name
[10:27:50.853]                             if (is.null(name)) 
[10:27:50.853]                               next
[10:27:50.853]                             if (!grepl(pattern, name)) 
[10:27:50.853]                               next
[10:27:50.853]                             invokeRestart(restart)
[10:27:50.853]                             muffled <- TRUE
[10:27:50.853]                             break
[10:27:50.853]                           }
[10:27:50.853]                         }
[10:27:50.853]                       }
[10:27:50.853]                       invisible(muffled)
[10:27:50.853]                     }
[10:27:50.853]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.853]                   }
[10:27:50.853]                 }
[10:27:50.853]             }
[10:27:50.853]         }))
[10:27:50.853]     }, error = function(ex) {
[10:27:50.853]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:50.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.853]                 ...future.rng), started = ...future.startTime, 
[10:27:50.853]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:50.853]             version = "1.8"), class = "FutureResult")
[10:27:50.853]     }, finally = {
[10:27:50.853]         if (!identical(...future.workdir, getwd())) 
[10:27:50.853]             setwd(...future.workdir)
[10:27:50.853]         {
[10:27:50.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:50.853]                 ...future.oldOptions$nwarnings <- NULL
[10:27:50.853]             }
[10:27:50.853]             base::options(...future.oldOptions)
[10:27:50.853]             if (.Platform$OS.type == "windows") {
[10:27:50.853]                 old_names <- names(...future.oldEnvVars)
[10:27:50.853]                 envs <- base::Sys.getenv()
[10:27:50.853]                 names <- names(envs)
[10:27:50.853]                 common <- intersect(names, old_names)
[10:27:50.853]                 added <- setdiff(names, old_names)
[10:27:50.853]                 removed <- setdiff(old_names, names)
[10:27:50.853]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:50.853]                   envs[common]]
[10:27:50.853]                 NAMES <- toupper(changed)
[10:27:50.853]                 args <- list()
[10:27:50.853]                 for (kk in seq_along(NAMES)) {
[10:27:50.853]                   name <- changed[[kk]]
[10:27:50.853]                   NAME <- NAMES[[kk]]
[10:27:50.853]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.853]                     next
[10:27:50.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.853]                 }
[10:27:50.853]                 NAMES <- toupper(added)
[10:27:50.853]                 for (kk in seq_along(NAMES)) {
[10:27:50.853]                   name <- added[[kk]]
[10:27:50.853]                   NAME <- NAMES[[kk]]
[10:27:50.853]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.853]                     next
[10:27:50.853]                   args[[name]] <- ""
[10:27:50.853]                 }
[10:27:50.853]                 NAMES <- toupper(removed)
[10:27:50.853]                 for (kk in seq_along(NAMES)) {
[10:27:50.853]                   name <- removed[[kk]]
[10:27:50.853]                   NAME <- NAMES[[kk]]
[10:27:50.853]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.853]                     next
[10:27:50.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.853]                 }
[10:27:50.853]                 if (length(args) > 0) 
[10:27:50.853]                   base::do.call(base::Sys.setenv, args = args)
[10:27:50.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:50.853]             }
[10:27:50.853]             else {
[10:27:50.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:50.853]             }
[10:27:50.853]             {
[10:27:50.853]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:50.853]                   0L) {
[10:27:50.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:50.853]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:50.853]                   base::options(opts)
[10:27:50.853]                 }
[10:27:50.853]                 {
[10:27:50.853]                   {
[10:27:50.853]                     NULL
[10:27:50.853]                     RNGkind("Mersenne-Twister")
[10:27:50.853]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:50.853]                       inherits = FALSE)
[10:27:50.853]                   }
[10:27:50.853]                   options(future.plan = NULL)
[10:27:50.853]                   if (is.na(NA_character_)) 
[10:27:50.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:50.853]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:50.853]                   {
[10:27:50.853]                     future <- SequentialFuture(..., envir = envir)
[10:27:50.853]                     if (!future$lazy) 
[10:27:50.853]                       future <- run(future)
[10:27:50.853]                     invisible(future)
[10:27:50.853]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:50.853]                 }
[10:27:50.853]             }
[10:27:50.853]         }
[10:27:50.853]     })
[10:27:50.853]     if (TRUE) {
[10:27:50.853]         base::sink(type = "output", split = FALSE)
[10:27:50.853]         if (TRUE) {
[10:27:50.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:50.853]         }
[10:27:50.853]         else {
[10:27:50.853]             ...future.result["stdout"] <- base::list(NULL)
[10:27:50.853]         }
[10:27:50.853]         base::close(...future.stdout)
[10:27:50.853]         ...future.stdout <- NULL
[10:27:50.853]     }
[10:27:50.853]     ...future.result$conditions <- ...future.conditions
[10:27:50.853]     ...future.result$finished <- base::Sys.time()
[10:27:50.853]     ...future.result
[10:27:50.853] }
[10:27:50.855] plan(): Setting new future strategy stack:
[10:27:50.855] List of future strategies:
[10:27:50.855] 1. sequential:
[10:27:50.855]    - args: function (..., envir = parent.frame())
[10:27:50.855]    - tweaked: FALSE
[10:27:50.855]    - call: NULL
[10:27:50.856] plan(): nbrOfWorkers() = 1
[10:27:50.858] plan(): Setting new future strategy stack:
[10:27:50.858] List of future strategies:
[10:27:50.858] 1. sequential:
[10:27:50.858]    - args: function (..., envir = parent.frame())
[10:27:50.858]    - tweaked: FALSE
[10:27:50.858]    - call: plan(strategy)
[10:27:50.858] plan(): nbrOfWorkers() = 1
[10:27:50.858] SequentialFuture started (and completed)
[10:27:50.859] - Launch lazy future ... done
[10:27:50.859] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 10:27:50"
 $ finished    : POSIXct[1:1], format: "2025-01-07 10:27:50"
 $ session_uuid: chr "ab9ea6fb-b352-f592-ef73-0faa546d9359"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3e863ac79bce"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92649
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 10:27:50"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.003433228 secs (started 2025-01-07 10:27:50.855436)
version: 1.8
[10:27:50.869] getGlobalsAndPackages() ...
[10:27:50.870] Searching for globals...
[10:27:50.875] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:50.875] Searching for globals ... DONE
[10:27:50.875] Resolving globals: FALSE
[10:27:50.876] 
[10:27:50.876] - packages: [1] ‘utils’
[10:27:50.876] getGlobalsAndPackages() ... DONE
[10:27:50.876] run() for ‘Future’ ...
[10:27:50.876] - state: ‘created’
[10:27:50.877] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:50.877] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:50.877] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:50.877]   - Field: ‘label’
[10:27:50.877]   - Field: ‘local’
[10:27:50.877]   - Field: ‘owner’
[10:27:50.877]   - Field: ‘envir’
[10:27:50.877]   - Field: ‘packages’
[10:27:50.878]   - Field: ‘gc’
[10:27:50.878]   - Field: ‘conditions’
[10:27:50.878]   - Field: ‘expr’
[10:27:50.878]   - Field: ‘uuid’
[10:27:50.878]   - Field: ‘seed’
[10:27:50.878]   - Field: ‘version’
[10:27:50.878]   - Field: ‘result’
[10:27:50.878]   - Field: ‘asynchronous’
[10:27:50.878]   - Field: ‘calls’
[10:27:50.878]   - Field: ‘globals’
[10:27:50.878]   - Field: ‘stdout’
[10:27:50.879]   - Field: ‘earlySignal’
[10:27:50.879]   - Field: ‘lazy’
[10:27:50.879]   - Field: ‘state’
[10:27:50.879] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:50.879] - Launch lazy future ...
[10:27:50.879] Packages needed by the future expression (n = 1): ‘utils’
[10:27:50.879] Packages needed by future strategies (n = 0): <none>
[10:27:50.880] {
[10:27:50.880]     {
[10:27:50.880]         {
[10:27:50.880]             ...future.startTime <- base::Sys.time()
[10:27:50.880]             {
[10:27:50.880]                 {
[10:27:50.880]                   {
[10:27:50.880]                     {
[10:27:50.880]                       base::local({
[10:27:50.880]                         has_future <- base::requireNamespace("future", 
[10:27:50.880]                           quietly = TRUE)
[10:27:50.880]                         if (has_future) {
[10:27:50.880]                           ns <- base::getNamespace("future")
[10:27:50.880]                           version <- ns[[".package"]][["version"]]
[10:27:50.880]                           if (is.null(version)) 
[10:27:50.880]                             version <- utils::packageVersion("future")
[10:27:50.880]                         }
[10:27:50.880]                         else {
[10:27:50.880]                           version <- NULL
[10:27:50.880]                         }
[10:27:50.880]                         if (!has_future || version < "1.8.0") {
[10:27:50.880]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:50.880]                             "", base::R.version$version.string), 
[10:27:50.880]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:50.880]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:50.880]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:50.880]                               "release", "version")], collapse = " "), 
[10:27:50.880]                             hostname = base::Sys.info()[["nodename"]])
[10:27:50.880]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:50.880]                             info)
[10:27:50.880]                           info <- base::paste(info, collapse = "; ")
[10:27:50.880]                           if (!has_future) {
[10:27:50.880]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:50.880]                               info)
[10:27:50.880]                           }
[10:27:50.880]                           else {
[10:27:50.880]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:50.880]                               info, version)
[10:27:50.880]                           }
[10:27:50.880]                           base::stop(msg)
[10:27:50.880]                         }
[10:27:50.880]                       })
[10:27:50.880]                     }
[10:27:50.880]                     base::local({
[10:27:50.880]                       for (pkg in "utils") {
[10:27:50.880]                         base::loadNamespace(pkg)
[10:27:50.880]                         base::library(pkg, character.only = TRUE)
[10:27:50.880]                       }
[10:27:50.880]                     })
[10:27:50.880]                   }
[10:27:50.880]                   options(future.plan = NULL)
[10:27:50.880]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.880]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:50.880]                 }
[10:27:50.880]                 ...future.workdir <- getwd()
[10:27:50.880]             }
[10:27:50.880]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:50.880]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:50.880]         }
[10:27:50.880]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:50.880]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:50.880]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:50.880]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:50.880]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:50.880]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:50.880]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:50.880]             base::names(...future.oldOptions))
[10:27:50.880]     }
[10:27:50.880]     if (FALSE) {
[10:27:50.880]     }
[10:27:50.880]     else {
[10:27:50.880]         if (TRUE) {
[10:27:50.880]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:50.880]                 open = "w")
[10:27:50.880]         }
[10:27:50.880]         else {
[10:27:50.880]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:50.880]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:50.880]         }
[10:27:50.880]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:50.880]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:50.880]             base::sink(type = "output", split = FALSE)
[10:27:50.880]             base::close(...future.stdout)
[10:27:50.880]         }, add = TRUE)
[10:27:50.880]     }
[10:27:50.880]     ...future.frame <- base::sys.nframe()
[10:27:50.880]     ...future.conditions <- base::list()
[10:27:50.880]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:50.880]     if (FALSE) {
[10:27:50.880]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:50.880]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:50.880]     }
[10:27:50.880]     ...future.result <- base::tryCatch({
[10:27:50.880]         base::withCallingHandlers({
[10:27:50.880]             ...future.value <- base::withVisible(base::local({
[10:27:50.880]                 print(1:50)
[10:27:50.880]                 str(1:50)
[10:27:50.880]                 cat(letters, sep = "-")
[10:27:50.880]                 cat(1:6, collapse = "\n")
[10:27:50.880]                 write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:50.880]                 42L
[10:27:50.880]             }))
[10:27:50.880]             future::FutureResult(value = ...future.value$value, 
[10:27:50.880]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.880]                   ...future.rng), globalenv = if (FALSE) 
[10:27:50.880]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:50.880]                     ...future.globalenv.names))
[10:27:50.880]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:50.880]         }, condition = base::local({
[10:27:50.880]             c <- base::c
[10:27:50.880]             inherits <- base::inherits
[10:27:50.880]             invokeRestart <- base::invokeRestart
[10:27:50.880]             length <- base::length
[10:27:50.880]             list <- base::list
[10:27:50.880]             seq.int <- base::seq.int
[10:27:50.880]             signalCondition <- base::signalCondition
[10:27:50.880]             sys.calls <- base::sys.calls
[10:27:50.880]             `[[` <- base::`[[`
[10:27:50.880]             `+` <- base::`+`
[10:27:50.880]             `<<-` <- base::`<<-`
[10:27:50.880]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:50.880]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:50.880]                   3L)]
[10:27:50.880]             }
[10:27:50.880]             function(cond) {
[10:27:50.880]                 is_error <- inherits(cond, "error")
[10:27:50.880]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:50.880]                   NULL)
[10:27:50.880]                 if (is_error) {
[10:27:50.880]                   sessionInformation <- function() {
[10:27:50.880]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:50.880]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:50.880]                       search = base::search(), system = base::Sys.info())
[10:27:50.880]                   }
[10:27:50.880]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.880]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:50.880]                     cond$call), session = sessionInformation(), 
[10:27:50.880]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:50.880]                   signalCondition(cond)
[10:27:50.880]                 }
[10:27:50.880]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:50.880]                 "immediateCondition"))) {
[10:27:50.880]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:50.880]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.880]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:50.880]                   if (TRUE && !signal) {
[10:27:50.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.880]                     {
[10:27:50.880]                       inherits <- base::inherits
[10:27:50.880]                       invokeRestart <- base::invokeRestart
[10:27:50.880]                       is.null <- base::is.null
[10:27:50.880]                       muffled <- FALSE
[10:27:50.880]                       if (inherits(cond, "message")) {
[10:27:50.880]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.880]                         if (muffled) 
[10:27:50.880]                           invokeRestart("muffleMessage")
[10:27:50.880]                       }
[10:27:50.880]                       else if (inherits(cond, "warning")) {
[10:27:50.880]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.880]                         if (muffled) 
[10:27:50.880]                           invokeRestart("muffleWarning")
[10:27:50.880]                       }
[10:27:50.880]                       else if (inherits(cond, "condition")) {
[10:27:50.880]                         if (!is.null(pattern)) {
[10:27:50.880]                           computeRestarts <- base::computeRestarts
[10:27:50.880]                           grepl <- base::grepl
[10:27:50.880]                           restarts <- computeRestarts(cond)
[10:27:50.880]                           for (restart in restarts) {
[10:27:50.880]                             name <- restart$name
[10:27:50.880]                             if (is.null(name)) 
[10:27:50.880]                               next
[10:27:50.880]                             if (!grepl(pattern, name)) 
[10:27:50.880]                               next
[10:27:50.880]                             invokeRestart(restart)
[10:27:50.880]                             muffled <- TRUE
[10:27:50.880]                             break
[10:27:50.880]                           }
[10:27:50.880]                         }
[10:27:50.880]                       }
[10:27:50.880]                       invisible(muffled)
[10:27:50.880]                     }
[10:27:50.880]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.880]                   }
[10:27:50.880]                 }
[10:27:50.880]                 else {
[10:27:50.880]                   if (TRUE) {
[10:27:50.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.880]                     {
[10:27:50.880]                       inherits <- base::inherits
[10:27:50.880]                       invokeRestart <- base::invokeRestart
[10:27:50.880]                       is.null <- base::is.null
[10:27:50.880]                       muffled <- FALSE
[10:27:50.880]                       if (inherits(cond, "message")) {
[10:27:50.880]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.880]                         if (muffled) 
[10:27:50.880]                           invokeRestart("muffleMessage")
[10:27:50.880]                       }
[10:27:50.880]                       else if (inherits(cond, "warning")) {
[10:27:50.880]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.880]                         if (muffled) 
[10:27:50.880]                           invokeRestart("muffleWarning")
[10:27:50.880]                       }
[10:27:50.880]                       else if (inherits(cond, "condition")) {
[10:27:50.880]                         if (!is.null(pattern)) {
[10:27:50.880]                           computeRestarts <- base::computeRestarts
[10:27:50.880]                           grepl <- base::grepl
[10:27:50.880]                           restarts <- computeRestarts(cond)
[10:27:50.880]                           for (restart in restarts) {
[10:27:50.880]                             name <- restart$name
[10:27:50.880]                             if (is.null(name)) 
[10:27:50.880]                               next
[10:27:50.880]                             if (!grepl(pattern, name)) 
[10:27:50.880]                               next
[10:27:50.880]                             invokeRestart(restart)
[10:27:50.880]                             muffled <- TRUE
[10:27:50.880]                             break
[10:27:50.880]                           }
[10:27:50.880]                         }
[10:27:50.880]                       }
[10:27:50.880]                       invisible(muffled)
[10:27:50.880]                     }
[10:27:50.880]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.880]                   }
[10:27:50.880]                 }
[10:27:50.880]             }
[10:27:50.880]         }))
[10:27:50.880]     }, error = function(ex) {
[10:27:50.880]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:50.880]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.880]                 ...future.rng), started = ...future.startTime, 
[10:27:50.880]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:50.880]             version = "1.8"), class = "FutureResult")
[10:27:50.880]     }, finally = {
[10:27:50.880]         if (!identical(...future.workdir, getwd())) 
[10:27:50.880]             setwd(...future.workdir)
[10:27:50.880]         {
[10:27:50.880]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:50.880]                 ...future.oldOptions$nwarnings <- NULL
[10:27:50.880]             }
[10:27:50.880]             base::options(...future.oldOptions)
[10:27:50.880]             if (.Platform$OS.type == "windows") {
[10:27:50.880]                 old_names <- names(...future.oldEnvVars)
[10:27:50.880]                 envs <- base::Sys.getenv()
[10:27:50.880]                 names <- names(envs)
[10:27:50.880]                 common <- intersect(names, old_names)
[10:27:50.880]                 added <- setdiff(names, old_names)
[10:27:50.880]                 removed <- setdiff(old_names, names)
[10:27:50.880]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:50.880]                   envs[common]]
[10:27:50.880]                 NAMES <- toupper(changed)
[10:27:50.880]                 args <- list()
[10:27:50.880]                 for (kk in seq_along(NAMES)) {
[10:27:50.880]                   name <- changed[[kk]]
[10:27:50.880]                   NAME <- NAMES[[kk]]
[10:27:50.880]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.880]                     next
[10:27:50.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.880]                 }
[10:27:50.880]                 NAMES <- toupper(added)
[10:27:50.880]                 for (kk in seq_along(NAMES)) {
[10:27:50.880]                   name <- added[[kk]]
[10:27:50.880]                   NAME <- NAMES[[kk]]
[10:27:50.880]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.880]                     next
[10:27:50.880]                   args[[name]] <- ""
[10:27:50.880]                 }
[10:27:50.880]                 NAMES <- toupper(removed)
[10:27:50.880]                 for (kk in seq_along(NAMES)) {
[10:27:50.880]                   name <- removed[[kk]]
[10:27:50.880]                   NAME <- NAMES[[kk]]
[10:27:50.880]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.880]                     next
[10:27:50.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.880]                 }
[10:27:50.880]                 if (length(args) > 0) 
[10:27:50.880]                   base::do.call(base::Sys.setenv, args = args)
[10:27:50.880]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:50.880]             }
[10:27:50.880]             else {
[10:27:50.880]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:50.880]             }
[10:27:50.880]             {
[10:27:50.880]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:50.880]                   0L) {
[10:27:50.880]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:50.880]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:50.880]                   base::options(opts)
[10:27:50.880]                 }
[10:27:50.880]                 {
[10:27:50.880]                   {
[10:27:50.880]                     NULL
[10:27:50.880]                     RNGkind("Mersenne-Twister")
[10:27:50.880]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:50.880]                       inherits = FALSE)
[10:27:50.880]                   }
[10:27:50.880]                   options(future.plan = NULL)
[10:27:50.880]                   if (is.na(NA_character_)) 
[10:27:50.880]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.880]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:50.880]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:50.880]                   {
[10:27:50.880]                     future <- SequentialFuture(..., envir = envir)
[10:27:50.880]                     if (!future$lazy) 
[10:27:50.880]                       future <- run(future)
[10:27:50.880]                     invisible(future)
[10:27:50.880]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:50.880]                 }
[10:27:50.880]             }
[10:27:50.880]         }
[10:27:50.880]     })
[10:27:50.880]     if (TRUE) {
[10:27:50.880]         base::sink(type = "output", split = FALSE)
[10:27:50.880]         if (TRUE) {
[10:27:50.880]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:50.880]         }
[10:27:50.880]         else {
[10:27:50.880]             ...future.result["stdout"] <- base::list(NULL)
[10:27:50.880]         }
[10:27:50.880]         base::close(...future.stdout)
[10:27:50.880]         ...future.stdout <- NULL
[10:27:50.880]     }
[10:27:50.880]     ...future.result$conditions <- ...future.conditions
[10:27:50.880]     ...future.result$finished <- base::Sys.time()
[10:27:50.880]     ...future.result
[10:27:50.880] }
[10:27:50.882] plan(): Setting new future strategy stack:
[10:27:50.882] List of future strategies:
[10:27:50.882] 1. sequential:
[10:27:50.882]    - args: function (..., envir = parent.frame())
[10:27:50.882]    - tweaked: FALSE
[10:27:50.882]    - call: NULL
[10:27:50.882] plan(): nbrOfWorkers() = 1
[10:27:50.884] plan(): Setting new future strategy stack:
[10:27:50.884] List of future strategies:
[10:27:50.884] 1. sequential:
[10:27:50.884]    - args: function (..., envir = parent.frame())
[10:27:50.884]    - tweaked: FALSE
[10:27:50.884]    - call: plan(strategy)
[10:27:50.884] plan(): nbrOfWorkers() = 1
[10:27:50.884] SequentialFuture started (and completed)
[10:27:50.884] - Launch lazy future ... done
[10:27:50.885] run() for ‘SequentialFuture’ ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[10:27:50.885] getGlobalsAndPackages() ...
[10:27:50.885] Searching for globals...
[10:27:50.886] - globals found: [1] ‘print’
[10:27:50.886] Searching for globals ... DONE
[10:27:50.886] Resolving globals: FALSE
[10:27:50.886] 
[10:27:50.886] 
[10:27:50.886] getGlobalsAndPackages() ... DONE
[10:27:50.887] run() for ‘Future’ ...
[10:27:50.887] - state: ‘created’
[10:27:50.887] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:50.887] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:50.887] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:50.887]   - Field: ‘label’
[10:27:50.887]   - Field: ‘local’
[10:27:50.887]   - Field: ‘owner’
[10:27:50.888]   - Field: ‘envir’
[10:27:50.888]   - Field: ‘packages’
[10:27:50.888]   - Field: ‘gc’
[10:27:50.888]   - Field: ‘conditions’
[10:27:50.888]   - Field: ‘expr’
[10:27:50.888]   - Field: ‘uuid’
[10:27:50.888]   - Field: ‘seed’
[10:27:50.888]   - Field: ‘version’
[10:27:50.888]   - Field: ‘result’
[10:27:50.888]   - Field: ‘asynchronous’
[10:27:50.888]   - Field: ‘calls’
[10:27:50.889]   - Field: ‘globals’
[10:27:50.889]   - Field: ‘stdout’
[10:27:50.889]   - Field: ‘earlySignal’
[10:27:50.889]   - Field: ‘lazy’
[10:27:50.889]   - Field: ‘state’
[10:27:50.889] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:50.889] - Launch lazy future ...
[10:27:50.889] Packages needed by the future expression (n = 0): <none>
[10:27:50.889] Packages needed by future strategies (n = 0): <none>
[10:27:50.890] {
[10:27:50.890]     {
[10:27:50.890]         {
[10:27:50.890]             ...future.startTime <- base::Sys.time()
[10:27:50.890]             {
[10:27:50.890]                 {
[10:27:50.890]                   {
[10:27:50.890]                     base::local({
[10:27:50.890]                       has_future <- base::requireNamespace("future", 
[10:27:50.890]                         quietly = TRUE)
[10:27:50.890]                       if (has_future) {
[10:27:50.890]                         ns <- base::getNamespace("future")
[10:27:50.890]                         version <- ns[[".package"]][["version"]]
[10:27:50.890]                         if (is.null(version)) 
[10:27:50.890]                           version <- utils::packageVersion("future")
[10:27:50.890]                       }
[10:27:50.890]                       else {
[10:27:50.890]                         version <- NULL
[10:27:50.890]                       }
[10:27:50.890]                       if (!has_future || version < "1.8.0") {
[10:27:50.890]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:50.890]                           "", base::R.version$version.string), 
[10:27:50.890]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:50.890]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:50.890]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:50.890]                             "release", "version")], collapse = " "), 
[10:27:50.890]                           hostname = base::Sys.info()[["nodename"]])
[10:27:50.890]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:50.890]                           info)
[10:27:50.890]                         info <- base::paste(info, collapse = "; ")
[10:27:50.890]                         if (!has_future) {
[10:27:50.890]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:50.890]                             info)
[10:27:50.890]                         }
[10:27:50.890]                         else {
[10:27:50.890]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:50.890]                             info, version)
[10:27:50.890]                         }
[10:27:50.890]                         base::stop(msg)
[10:27:50.890]                       }
[10:27:50.890]                     })
[10:27:50.890]                   }
[10:27:50.890]                   options(future.plan = NULL)
[10:27:50.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:50.890]                 }
[10:27:50.890]                 ...future.workdir <- getwd()
[10:27:50.890]             }
[10:27:50.890]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:50.890]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:50.890]         }
[10:27:50.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:50.890]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:50.890]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:50.890]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:50.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:50.890]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:50.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:50.890]             base::names(...future.oldOptions))
[10:27:50.890]     }
[10:27:50.890]     if (FALSE) {
[10:27:50.890]     }
[10:27:50.890]     else {
[10:27:50.890]         if (TRUE) {
[10:27:50.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:50.890]                 open = "w")
[10:27:50.890]         }
[10:27:50.890]         else {
[10:27:50.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:50.890]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:50.890]         }
[10:27:50.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:50.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:50.890]             base::sink(type = "output", split = FALSE)
[10:27:50.890]             base::close(...future.stdout)
[10:27:50.890]         }, add = TRUE)
[10:27:50.890]     }
[10:27:50.890]     ...future.frame <- base::sys.nframe()
[10:27:50.890]     ...future.conditions <- base::list()
[10:27:50.890]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:50.890]     if (FALSE) {
[10:27:50.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:50.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:50.890]     }
[10:27:50.890]     ...future.result <- base::tryCatch({
[10:27:50.890]         base::withCallingHandlers({
[10:27:50.890]             ...future.value <- base::withVisible(base::local(print(42)))
[10:27:50.890]             future::FutureResult(value = ...future.value$value, 
[10:27:50.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.890]                   ...future.rng), globalenv = if (FALSE) 
[10:27:50.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:50.890]                     ...future.globalenv.names))
[10:27:50.890]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:50.890]         }, condition = base::local({
[10:27:50.890]             c <- base::c
[10:27:50.890]             inherits <- base::inherits
[10:27:50.890]             invokeRestart <- base::invokeRestart
[10:27:50.890]             length <- base::length
[10:27:50.890]             list <- base::list
[10:27:50.890]             seq.int <- base::seq.int
[10:27:50.890]             signalCondition <- base::signalCondition
[10:27:50.890]             sys.calls <- base::sys.calls
[10:27:50.890]             `[[` <- base::`[[`
[10:27:50.890]             `+` <- base::`+`
[10:27:50.890]             `<<-` <- base::`<<-`
[10:27:50.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:50.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:50.890]                   3L)]
[10:27:50.890]             }
[10:27:50.890]             function(cond) {
[10:27:50.890]                 is_error <- inherits(cond, "error")
[10:27:50.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:50.890]                   NULL)
[10:27:50.890]                 if (is_error) {
[10:27:50.890]                   sessionInformation <- function() {
[10:27:50.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:50.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:50.890]                       search = base::search(), system = base::Sys.info())
[10:27:50.890]                   }
[10:27:50.890]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:50.890]                     cond$call), session = sessionInformation(), 
[10:27:50.890]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:50.890]                   signalCondition(cond)
[10:27:50.890]                 }
[10:27:50.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:50.890]                 "immediateCondition"))) {
[10:27:50.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:50.890]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:50.890]                   if (TRUE && !signal) {
[10:27:50.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.890]                     {
[10:27:50.890]                       inherits <- base::inherits
[10:27:50.890]                       invokeRestart <- base::invokeRestart
[10:27:50.890]                       is.null <- base::is.null
[10:27:50.890]                       muffled <- FALSE
[10:27:50.890]                       if (inherits(cond, "message")) {
[10:27:50.890]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.890]                         if (muffled) 
[10:27:50.890]                           invokeRestart("muffleMessage")
[10:27:50.890]                       }
[10:27:50.890]                       else if (inherits(cond, "warning")) {
[10:27:50.890]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.890]                         if (muffled) 
[10:27:50.890]                           invokeRestart("muffleWarning")
[10:27:50.890]                       }
[10:27:50.890]                       else if (inherits(cond, "condition")) {
[10:27:50.890]                         if (!is.null(pattern)) {
[10:27:50.890]                           computeRestarts <- base::computeRestarts
[10:27:50.890]                           grepl <- base::grepl
[10:27:50.890]                           restarts <- computeRestarts(cond)
[10:27:50.890]                           for (restart in restarts) {
[10:27:50.890]                             name <- restart$name
[10:27:50.890]                             if (is.null(name)) 
[10:27:50.890]                               next
[10:27:50.890]                             if (!grepl(pattern, name)) 
[10:27:50.890]                               next
[10:27:50.890]                             invokeRestart(restart)
[10:27:50.890]                             muffled <- TRUE
[10:27:50.890]                             break
[10:27:50.890]                           }
[10:27:50.890]                         }
[10:27:50.890]                       }
[10:27:50.890]                       invisible(muffled)
[10:27:50.890]                     }
[10:27:50.890]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.890]                   }
[10:27:50.890]                 }
[10:27:50.890]                 else {
[10:27:50.890]                   if (TRUE) {
[10:27:50.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.890]                     {
[10:27:50.890]                       inherits <- base::inherits
[10:27:50.890]                       invokeRestart <- base::invokeRestart
[10:27:50.890]                       is.null <- base::is.null
[10:27:50.890]                       muffled <- FALSE
[10:27:50.890]                       if (inherits(cond, "message")) {
[10:27:50.890]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.890]                         if (muffled) 
[10:27:50.890]                           invokeRestart("muffleMessage")
[10:27:50.890]                       }
[10:27:50.890]                       else if (inherits(cond, "warning")) {
[10:27:50.890]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.890]                         if (muffled) 
[10:27:50.890]                           invokeRestart("muffleWarning")
[10:27:50.890]                       }
[10:27:50.890]                       else if (inherits(cond, "condition")) {
[10:27:50.890]                         if (!is.null(pattern)) {
[10:27:50.890]                           computeRestarts <- base::computeRestarts
[10:27:50.890]                           grepl <- base::grepl
[10:27:50.890]                           restarts <- computeRestarts(cond)
[10:27:50.890]                           for (restart in restarts) {
[10:27:50.890]                             name <- restart$name
[10:27:50.890]                             if (is.null(name)) 
[10:27:50.890]                               next
[10:27:50.890]                             if (!grepl(pattern, name)) 
[10:27:50.890]                               next
[10:27:50.890]                             invokeRestart(restart)
[10:27:50.890]                             muffled <- TRUE
[10:27:50.890]                             break
[10:27:50.890]                           }
[10:27:50.890]                         }
[10:27:50.890]                       }
[10:27:50.890]                       invisible(muffled)
[10:27:50.890]                     }
[10:27:50.890]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.890]                   }
[10:27:50.890]                 }
[10:27:50.890]             }
[10:27:50.890]         }))
[10:27:50.890]     }, error = function(ex) {
[10:27:50.890]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:50.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.890]                 ...future.rng), started = ...future.startTime, 
[10:27:50.890]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:50.890]             version = "1.8"), class = "FutureResult")
[10:27:50.890]     }, finally = {
[10:27:50.890]         if (!identical(...future.workdir, getwd())) 
[10:27:50.890]             setwd(...future.workdir)
[10:27:50.890]         {
[10:27:50.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:50.890]                 ...future.oldOptions$nwarnings <- NULL
[10:27:50.890]             }
[10:27:50.890]             base::options(...future.oldOptions)
[10:27:50.890]             if (.Platform$OS.type == "windows") {
[10:27:50.890]                 old_names <- names(...future.oldEnvVars)
[10:27:50.890]                 envs <- base::Sys.getenv()
[10:27:50.890]                 names <- names(envs)
[10:27:50.890]                 common <- intersect(names, old_names)
[10:27:50.890]                 added <- setdiff(names, old_names)
[10:27:50.890]                 removed <- setdiff(old_names, names)
[10:27:50.890]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:50.890]                   envs[common]]
[10:27:50.890]                 NAMES <- toupper(changed)
[10:27:50.890]                 args <- list()
[10:27:50.890]                 for (kk in seq_along(NAMES)) {
[10:27:50.890]                   name <- changed[[kk]]
[10:27:50.890]                   NAME <- NAMES[[kk]]
[10:27:50.890]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.890]                     next
[10:27:50.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.890]                 }
[10:27:50.890]                 NAMES <- toupper(added)
[10:27:50.890]                 for (kk in seq_along(NAMES)) {
[10:27:50.890]                   name <- added[[kk]]
[10:27:50.890]                   NAME <- NAMES[[kk]]
[10:27:50.890]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.890]                     next
[10:27:50.890]                   args[[name]] <- ""
[10:27:50.890]                 }
[10:27:50.890]                 NAMES <- toupper(removed)
[10:27:50.890]                 for (kk in seq_along(NAMES)) {
[10:27:50.890]                   name <- removed[[kk]]
[10:27:50.890]                   NAME <- NAMES[[kk]]
[10:27:50.890]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.890]                     next
[10:27:50.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.890]                 }
[10:27:50.890]                 if (length(args) > 0) 
[10:27:50.890]                   base::do.call(base::Sys.setenv, args = args)
[10:27:50.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:50.890]             }
[10:27:50.890]             else {
[10:27:50.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:50.890]             }
[10:27:50.890]             {
[10:27:50.890]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:50.890]                   0L) {
[10:27:50.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:50.890]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:50.890]                   base::options(opts)
[10:27:50.890]                 }
[10:27:50.890]                 {
[10:27:50.890]                   {
[10:27:50.890]                     NULL
[10:27:50.890]                     RNGkind("Mersenne-Twister")
[10:27:50.890]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:50.890]                       inherits = FALSE)
[10:27:50.890]                   }
[10:27:50.890]                   options(future.plan = NULL)
[10:27:50.890]                   if (is.na(NA_character_)) 
[10:27:50.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:50.890]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:50.890]                   {
[10:27:50.890]                     future <- SequentialFuture(..., envir = envir)
[10:27:50.890]                     if (!future$lazy) 
[10:27:50.890]                       future <- run(future)
[10:27:50.890]                     invisible(future)
[10:27:50.890]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:50.890]                 }
[10:27:50.890]             }
[10:27:50.890]         }
[10:27:50.890]     })
[10:27:50.890]     if (TRUE) {
[10:27:50.890]         base::sink(type = "output", split = FALSE)
[10:27:50.890]         if (TRUE) {
[10:27:50.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:50.890]         }
[10:27:50.890]         else {
[10:27:50.890]             ...future.result["stdout"] <- base::list(NULL)
[10:27:50.890]         }
[10:27:50.890]         base::close(...future.stdout)
[10:27:50.890]         ...future.stdout <- NULL
[10:27:50.890]     }
[10:27:50.890]     ...future.result$conditions <- ...future.conditions
[10:27:50.890]     ...future.result$finished <- base::Sys.time()
[10:27:50.890]     ...future.result
[10:27:50.890] }
[10:27:50.892] plan(): Setting new future strategy stack:
[10:27:50.892] List of future strategies:
[10:27:50.892] 1. sequential:
[10:27:50.892]    - args: function (..., envir = parent.frame())
[10:27:50.892]    - tweaked: FALSE
[10:27:50.892]    - call: NULL
[10:27:50.892] plan(): nbrOfWorkers() = 1
[10:27:50.893] plan(): Setting new future strategy stack:
[10:27:50.893] List of future strategies:
[10:27:50.893] 1. sequential:
[10:27:50.893]    - args: function (..., envir = parent.frame())
[10:27:50.893]    - tweaked: FALSE
[10:27:50.893]    - call: plan(strategy)
[10:27:50.893] plan(): nbrOfWorkers() = 1
[10:27:50.893] SequentialFuture started (and completed)
[10:27:50.894] - Launch lazy future ... done
[10:27:50.894] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = FALSE
[10:27:50.894] getGlobalsAndPackages() ...
[10:27:50.894] Searching for globals...
[10:27:50.897] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:50.897] Searching for globals ... DONE
[10:27:50.897] Resolving globals: FALSE
[10:27:50.898] 
[10:27:50.898] - packages: [1] ‘utils’
[10:27:50.898] getGlobalsAndPackages() ... DONE
[10:27:50.898] run() for ‘Future’ ...
[10:27:50.898] - state: ‘created’
[10:27:50.898] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:50.898] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:50.899] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:50.899]   - Field: ‘label’
[10:27:50.899]   - Field: ‘local’
[10:27:50.899]   - Field: ‘owner’
[10:27:50.899]   - Field: ‘envir’
[10:27:50.899]   - Field: ‘packages’
[10:27:50.899]   - Field: ‘gc’
[10:27:50.899]   - Field: ‘conditions’
[10:27:50.899]   - Field: ‘expr’
[10:27:50.899]   - Field: ‘uuid’
[10:27:50.900]   - Field: ‘seed’
[10:27:50.900]   - Field: ‘version’
[10:27:50.900]   - Field: ‘result’
[10:27:50.900]   - Field: ‘asynchronous’
[10:27:50.900]   - Field: ‘calls’
[10:27:50.900]   - Field: ‘globals’
[10:27:50.900]   - Field: ‘stdout’
[10:27:50.900]   - Field: ‘earlySignal’
[10:27:50.900]   - Field: ‘lazy’
[10:27:50.900]   - Field: ‘state’
[10:27:50.900] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:50.901] - Launch lazy future ...
[10:27:50.901] Packages needed by the future expression (n = 1): ‘utils’
[10:27:50.901] Packages needed by future strategies (n = 0): <none>
[10:27:50.903] {
[10:27:50.903]     {
[10:27:50.903]         {
[10:27:50.903]             ...future.startTime <- base::Sys.time()
[10:27:50.903]             {
[10:27:50.903]                 {
[10:27:50.903]                   {
[10:27:50.903]                     {
[10:27:50.903]                       base::local({
[10:27:50.903]                         has_future <- base::requireNamespace("future", 
[10:27:50.903]                           quietly = TRUE)
[10:27:50.903]                         if (has_future) {
[10:27:50.903]                           ns <- base::getNamespace("future")
[10:27:50.903]                           version <- ns[[".package"]][["version"]]
[10:27:50.903]                           if (is.null(version)) 
[10:27:50.903]                             version <- utils::packageVersion("future")
[10:27:50.903]                         }
[10:27:50.903]                         else {
[10:27:50.903]                           version <- NULL
[10:27:50.903]                         }
[10:27:50.903]                         if (!has_future || version < "1.8.0") {
[10:27:50.903]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:50.903]                             "", base::R.version$version.string), 
[10:27:50.903]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:50.903]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:50.903]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:50.903]                               "release", "version")], collapse = " "), 
[10:27:50.903]                             hostname = base::Sys.info()[["nodename"]])
[10:27:50.903]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:50.903]                             info)
[10:27:50.903]                           info <- base::paste(info, collapse = "; ")
[10:27:50.903]                           if (!has_future) {
[10:27:50.903]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:50.903]                               info)
[10:27:50.903]                           }
[10:27:50.903]                           else {
[10:27:50.903]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:50.903]                               info, version)
[10:27:50.903]                           }
[10:27:50.903]                           base::stop(msg)
[10:27:50.903]                         }
[10:27:50.903]                       })
[10:27:50.903]                     }
[10:27:50.903]                     base::local({
[10:27:50.903]                       for (pkg in "utils") {
[10:27:50.903]                         base::loadNamespace(pkg)
[10:27:50.903]                         base::library(pkg, character.only = TRUE)
[10:27:50.903]                       }
[10:27:50.903]                     })
[10:27:50.903]                   }
[10:27:50.903]                   options(future.plan = NULL)
[10:27:50.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:50.903]                 }
[10:27:50.903]                 ...future.workdir <- getwd()
[10:27:50.903]             }
[10:27:50.903]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:50.903]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:50.903]         }
[10:27:50.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:50.903]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:50.903]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:50.903]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:50.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:50.903]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:50.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:50.903]             base::names(...future.oldOptions))
[10:27:50.903]     }
[10:27:50.903]     if (FALSE) {
[10:27:50.903]     }
[10:27:50.903]     else {
[10:27:50.903]         if (FALSE) {
[10:27:50.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:50.903]                 open = "w")
[10:27:50.903]         }
[10:27:50.903]         else {
[10:27:50.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:50.903]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:50.903]         }
[10:27:50.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:50.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:50.903]             base::sink(type = "output", split = FALSE)
[10:27:50.903]             base::close(...future.stdout)
[10:27:50.903]         }, add = TRUE)
[10:27:50.903]     }
[10:27:50.903]     ...future.frame <- base::sys.nframe()
[10:27:50.903]     ...future.conditions <- base::list()
[10:27:50.903]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:50.903]     if (FALSE) {
[10:27:50.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:50.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:50.903]     }
[10:27:50.903]     ...future.result <- base::tryCatch({
[10:27:50.903]         base::withCallingHandlers({
[10:27:50.903]             ...future.value <- base::withVisible(base::local({
[10:27:50.903]                 print(1:50)
[10:27:50.903]                 str(1:50)
[10:27:50.903]                 cat(letters, sep = "-")
[10:27:50.903]                 cat(1:6, collapse = "\n")
[10:27:50.903]                 write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:50.903]                 42L
[10:27:50.903]             }))
[10:27:50.903]             future::FutureResult(value = ...future.value$value, 
[10:27:50.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.903]                   ...future.rng), globalenv = if (FALSE) 
[10:27:50.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:50.903]                     ...future.globalenv.names))
[10:27:50.903]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:50.903]         }, condition = base::local({
[10:27:50.903]             c <- base::c
[10:27:50.903]             inherits <- base::inherits
[10:27:50.903]             invokeRestart <- base::invokeRestart
[10:27:50.903]             length <- base::length
[10:27:50.903]             list <- base::list
[10:27:50.903]             seq.int <- base::seq.int
[10:27:50.903]             signalCondition <- base::signalCondition
[10:27:50.903]             sys.calls <- base::sys.calls
[10:27:50.903]             `[[` <- base::`[[`
[10:27:50.903]             `+` <- base::`+`
[10:27:50.903]             `<<-` <- base::`<<-`
[10:27:50.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:50.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:50.903]                   3L)]
[10:27:50.903]             }
[10:27:50.903]             function(cond) {
[10:27:50.903]                 is_error <- inherits(cond, "error")
[10:27:50.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:50.903]                   NULL)
[10:27:50.903]                 if (is_error) {
[10:27:50.903]                   sessionInformation <- function() {
[10:27:50.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:50.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:50.903]                       search = base::search(), system = base::Sys.info())
[10:27:50.903]                   }
[10:27:50.903]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:50.903]                     cond$call), session = sessionInformation(), 
[10:27:50.903]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:50.903]                   signalCondition(cond)
[10:27:50.903]                 }
[10:27:50.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:50.903]                 "immediateCondition"))) {
[10:27:50.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:50.903]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:50.903]                   if (TRUE && !signal) {
[10:27:50.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.903]                     {
[10:27:50.903]                       inherits <- base::inherits
[10:27:50.903]                       invokeRestart <- base::invokeRestart
[10:27:50.903]                       is.null <- base::is.null
[10:27:50.903]                       muffled <- FALSE
[10:27:50.903]                       if (inherits(cond, "message")) {
[10:27:50.903]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.903]                         if (muffled) 
[10:27:50.903]                           invokeRestart("muffleMessage")
[10:27:50.903]                       }
[10:27:50.903]                       else if (inherits(cond, "warning")) {
[10:27:50.903]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.903]                         if (muffled) 
[10:27:50.903]                           invokeRestart("muffleWarning")
[10:27:50.903]                       }
[10:27:50.903]                       else if (inherits(cond, "condition")) {
[10:27:50.903]                         if (!is.null(pattern)) {
[10:27:50.903]                           computeRestarts <- base::computeRestarts
[10:27:50.903]                           grepl <- base::grepl
[10:27:50.903]                           restarts <- computeRestarts(cond)
[10:27:50.903]                           for (restart in restarts) {
[10:27:50.903]                             name <- restart$name
[10:27:50.903]                             if (is.null(name)) 
[10:27:50.903]                               next
[10:27:50.903]                             if (!grepl(pattern, name)) 
[10:27:50.903]                               next
[10:27:50.903]                             invokeRestart(restart)
[10:27:50.903]                             muffled <- TRUE
[10:27:50.903]                             break
[10:27:50.903]                           }
[10:27:50.903]                         }
[10:27:50.903]                       }
[10:27:50.903]                       invisible(muffled)
[10:27:50.903]                     }
[10:27:50.903]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.903]                   }
[10:27:50.903]                 }
[10:27:50.903]                 else {
[10:27:50.903]                   if (TRUE) {
[10:27:50.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.903]                     {
[10:27:50.903]                       inherits <- base::inherits
[10:27:50.903]                       invokeRestart <- base::invokeRestart
[10:27:50.903]                       is.null <- base::is.null
[10:27:50.903]                       muffled <- FALSE
[10:27:50.903]                       if (inherits(cond, "message")) {
[10:27:50.903]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.903]                         if (muffled) 
[10:27:50.903]                           invokeRestart("muffleMessage")
[10:27:50.903]                       }
[10:27:50.903]                       else if (inherits(cond, "warning")) {
[10:27:50.903]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.903]                         if (muffled) 
[10:27:50.903]                           invokeRestart("muffleWarning")
[10:27:50.903]                       }
[10:27:50.903]                       else if (inherits(cond, "condition")) {
[10:27:50.903]                         if (!is.null(pattern)) {
[10:27:50.903]                           computeRestarts <- base::computeRestarts
[10:27:50.903]                           grepl <- base::grepl
[10:27:50.903]                           restarts <- computeRestarts(cond)
[10:27:50.903]                           for (restart in restarts) {
[10:27:50.903]                             name <- restart$name
[10:27:50.903]                             if (is.null(name)) 
[10:27:50.903]                               next
[10:27:50.903]                             if (!grepl(pattern, name)) 
[10:27:50.903]                               next
[10:27:50.903]                             invokeRestart(restart)
[10:27:50.903]                             muffled <- TRUE
[10:27:50.903]                             break
[10:27:50.903]                           }
[10:27:50.903]                         }
[10:27:50.903]                       }
[10:27:50.903]                       invisible(muffled)
[10:27:50.903]                     }
[10:27:50.903]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.903]                   }
[10:27:50.903]                 }
[10:27:50.903]             }
[10:27:50.903]         }))
[10:27:50.903]     }, error = function(ex) {
[10:27:50.903]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:50.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.903]                 ...future.rng), started = ...future.startTime, 
[10:27:50.903]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:50.903]             version = "1.8"), class = "FutureResult")
[10:27:50.903]     }, finally = {
[10:27:50.903]         if (!identical(...future.workdir, getwd())) 
[10:27:50.903]             setwd(...future.workdir)
[10:27:50.903]         {
[10:27:50.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:50.903]                 ...future.oldOptions$nwarnings <- NULL
[10:27:50.903]             }
[10:27:50.903]             base::options(...future.oldOptions)
[10:27:50.903]             if (.Platform$OS.type == "windows") {
[10:27:50.903]                 old_names <- names(...future.oldEnvVars)
[10:27:50.903]                 envs <- base::Sys.getenv()
[10:27:50.903]                 names <- names(envs)
[10:27:50.903]                 common <- intersect(names, old_names)
[10:27:50.903]                 added <- setdiff(names, old_names)
[10:27:50.903]                 removed <- setdiff(old_names, names)
[10:27:50.903]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:50.903]                   envs[common]]
[10:27:50.903]                 NAMES <- toupper(changed)
[10:27:50.903]                 args <- list()
[10:27:50.903]                 for (kk in seq_along(NAMES)) {
[10:27:50.903]                   name <- changed[[kk]]
[10:27:50.903]                   NAME <- NAMES[[kk]]
[10:27:50.903]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.903]                     next
[10:27:50.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.903]                 }
[10:27:50.903]                 NAMES <- toupper(added)
[10:27:50.903]                 for (kk in seq_along(NAMES)) {
[10:27:50.903]                   name <- added[[kk]]
[10:27:50.903]                   NAME <- NAMES[[kk]]
[10:27:50.903]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.903]                     next
[10:27:50.903]                   args[[name]] <- ""
[10:27:50.903]                 }
[10:27:50.903]                 NAMES <- toupper(removed)
[10:27:50.903]                 for (kk in seq_along(NAMES)) {
[10:27:50.903]                   name <- removed[[kk]]
[10:27:50.903]                   NAME <- NAMES[[kk]]
[10:27:50.903]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.903]                     next
[10:27:50.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.903]                 }
[10:27:50.903]                 if (length(args) > 0) 
[10:27:50.903]                   base::do.call(base::Sys.setenv, args = args)
[10:27:50.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:50.903]             }
[10:27:50.903]             else {
[10:27:50.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:50.903]             }
[10:27:50.903]             {
[10:27:50.903]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:50.903]                   0L) {
[10:27:50.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:50.903]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:50.903]                   base::options(opts)
[10:27:50.903]                 }
[10:27:50.903]                 {
[10:27:50.903]                   {
[10:27:50.903]                     NULL
[10:27:50.903]                     RNGkind("Mersenne-Twister")
[10:27:50.903]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:50.903]                       inherits = FALSE)
[10:27:50.903]                   }
[10:27:50.903]                   options(future.plan = NULL)
[10:27:50.903]                   if (is.na(NA_character_)) 
[10:27:50.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:50.903]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:50.903]                   {
[10:27:50.903]                     future <- SequentialFuture(..., envir = envir)
[10:27:50.903]                     if (!future$lazy) 
[10:27:50.903]                       future <- run(future)
[10:27:50.903]                     invisible(future)
[10:27:50.903]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:50.903]                 }
[10:27:50.903]             }
[10:27:50.903]         }
[10:27:50.903]     })
[10:27:50.903]     if (TRUE) {
[10:27:50.903]         base::sink(type = "output", split = FALSE)
[10:27:50.903]         if (FALSE) {
[10:27:50.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:50.903]         }
[10:27:50.903]         else {
[10:27:50.903]             ...future.result["stdout"] <- base::list(NULL)
[10:27:50.903]         }
[10:27:50.903]         base::close(...future.stdout)
[10:27:50.903]         ...future.stdout <- NULL
[10:27:50.903]     }
[10:27:50.903]     ...future.result$conditions <- ...future.conditions
[10:27:50.903]     ...future.result$finished <- base::Sys.time()
[10:27:50.903]     ...future.result
[10:27:50.903] }
[10:27:50.905] plan(): Setting new future strategy stack:
[10:27:50.905] List of future strategies:
[10:27:50.905] 1. sequential:
[10:27:50.905]    - args: function (..., envir = parent.frame())
[10:27:50.905]    - tweaked: FALSE
[10:27:50.905]    - call: NULL
[10:27:50.905] plan(): nbrOfWorkers() = 1
[10:27:50.907] plan(): Setting new future strategy stack:
[10:27:50.907] List of future strategies:
[10:27:50.907] 1. sequential:
[10:27:50.907]    - args: function (..., envir = parent.frame())
[10:27:50.907]    - tweaked: FALSE
[10:27:50.907]    - call: plan(strategy)
[10:27:50.907] plan(): nbrOfWorkers() = 1
[10:27:50.907] SequentialFuture started (and completed)
[10:27:50.908] - Launch lazy future ... done
[10:27:50.908] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 10:27:50"
 $ finished    : POSIXct[1:1], format: "2025-01-07 10:27:50"
 $ session_uuid: chr "ab9ea6fb-b352-f592-ef73-0faa546d9359"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3e863ac79bce"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92649
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 10:27:50"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:27:50.916] getGlobalsAndPackages() ...
[10:27:50.916] Searching for globals...
[10:27:50.919] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:50.919] Searching for globals ... DONE
[10:27:50.919] Resolving globals: FALSE
[10:27:50.920] 
[10:27:50.920] - packages: [1] ‘utils’
[10:27:50.920] getGlobalsAndPackages() ... DONE
[10:27:50.920] run() for ‘Future’ ...
[10:27:50.920] - state: ‘created’
[10:27:50.920] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:50.921] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:50.921] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:50.921]   - Field: ‘label’
[10:27:50.921]   - Field: ‘local’
[10:27:50.921]   - Field: ‘owner’
[10:27:50.921]   - Field: ‘envir’
[10:27:50.921]   - Field: ‘packages’
[10:27:50.921]   - Field: ‘gc’
[10:27:50.921]   - Field: ‘conditions’
[10:27:50.922]   - Field: ‘expr’
[10:27:50.922]   - Field: ‘uuid’
[10:27:50.922]   - Field: ‘seed’
[10:27:50.922]   - Field: ‘version’
[10:27:50.922]   - Field: ‘result’
[10:27:50.922]   - Field: ‘asynchronous’
[10:27:50.922]   - Field: ‘calls’
[10:27:50.922]   - Field: ‘globals’
[10:27:50.922]   - Field: ‘stdout’
[10:27:50.922]   - Field: ‘earlySignal’
[10:27:50.923]   - Field: ‘lazy’
[10:27:50.923]   - Field: ‘state’
[10:27:50.923] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:50.923] - Launch lazy future ...
[10:27:50.923] Packages needed by the future expression (n = 1): ‘utils’
[10:27:50.923] Packages needed by future strategies (n = 0): <none>
[10:27:50.924] {
[10:27:50.924]     {
[10:27:50.924]         {
[10:27:50.924]             ...future.startTime <- base::Sys.time()
[10:27:50.924]             {
[10:27:50.924]                 {
[10:27:50.924]                   {
[10:27:50.924]                     {
[10:27:50.924]                       base::local({
[10:27:50.924]                         has_future <- base::requireNamespace("future", 
[10:27:50.924]                           quietly = TRUE)
[10:27:50.924]                         if (has_future) {
[10:27:50.924]                           ns <- base::getNamespace("future")
[10:27:50.924]                           version <- ns[[".package"]][["version"]]
[10:27:50.924]                           if (is.null(version)) 
[10:27:50.924]                             version <- utils::packageVersion("future")
[10:27:50.924]                         }
[10:27:50.924]                         else {
[10:27:50.924]                           version <- NULL
[10:27:50.924]                         }
[10:27:50.924]                         if (!has_future || version < "1.8.0") {
[10:27:50.924]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:50.924]                             "", base::R.version$version.string), 
[10:27:50.924]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:50.924]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:50.924]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:50.924]                               "release", "version")], collapse = " "), 
[10:27:50.924]                             hostname = base::Sys.info()[["nodename"]])
[10:27:50.924]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:50.924]                             info)
[10:27:50.924]                           info <- base::paste(info, collapse = "; ")
[10:27:50.924]                           if (!has_future) {
[10:27:50.924]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:50.924]                               info)
[10:27:50.924]                           }
[10:27:50.924]                           else {
[10:27:50.924]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:50.924]                               info, version)
[10:27:50.924]                           }
[10:27:50.924]                           base::stop(msg)
[10:27:50.924]                         }
[10:27:50.924]                       })
[10:27:50.924]                     }
[10:27:50.924]                     base::local({
[10:27:50.924]                       for (pkg in "utils") {
[10:27:50.924]                         base::loadNamespace(pkg)
[10:27:50.924]                         base::library(pkg, character.only = TRUE)
[10:27:50.924]                       }
[10:27:50.924]                     })
[10:27:50.924]                   }
[10:27:50.924]                   options(future.plan = NULL)
[10:27:50.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:50.924]                 }
[10:27:50.924]                 ...future.workdir <- getwd()
[10:27:50.924]             }
[10:27:50.924]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:50.924]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:50.924]         }
[10:27:50.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:50.924]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:50.924]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:50.924]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:50.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:50.924]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:50.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:50.924]             base::names(...future.oldOptions))
[10:27:50.924]     }
[10:27:50.924]     if (FALSE) {
[10:27:50.924]     }
[10:27:50.924]     else {
[10:27:50.924]         if (FALSE) {
[10:27:50.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:50.924]                 open = "w")
[10:27:50.924]         }
[10:27:50.924]         else {
[10:27:50.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:50.924]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:50.924]         }
[10:27:50.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:50.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:50.924]             base::sink(type = "output", split = FALSE)
[10:27:50.924]             base::close(...future.stdout)
[10:27:50.924]         }, add = TRUE)
[10:27:50.924]     }
[10:27:50.924]     ...future.frame <- base::sys.nframe()
[10:27:50.924]     ...future.conditions <- base::list()
[10:27:50.924]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:50.924]     if (FALSE) {
[10:27:50.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:50.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:50.924]     }
[10:27:50.924]     ...future.result <- base::tryCatch({
[10:27:50.924]         base::withCallingHandlers({
[10:27:50.924]             ...future.value <- base::withVisible(base::local({
[10:27:50.924]                 print(1:50)
[10:27:50.924]                 str(1:50)
[10:27:50.924]                 cat(letters, sep = "-")
[10:27:50.924]                 cat(1:6, collapse = "\n")
[10:27:50.924]                 write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:50.924]                 42L
[10:27:50.924]             }))
[10:27:50.924]             future::FutureResult(value = ...future.value$value, 
[10:27:50.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.924]                   ...future.rng), globalenv = if (FALSE) 
[10:27:50.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:50.924]                     ...future.globalenv.names))
[10:27:50.924]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:50.924]         }, condition = base::local({
[10:27:50.924]             c <- base::c
[10:27:50.924]             inherits <- base::inherits
[10:27:50.924]             invokeRestart <- base::invokeRestart
[10:27:50.924]             length <- base::length
[10:27:50.924]             list <- base::list
[10:27:50.924]             seq.int <- base::seq.int
[10:27:50.924]             signalCondition <- base::signalCondition
[10:27:50.924]             sys.calls <- base::sys.calls
[10:27:50.924]             `[[` <- base::`[[`
[10:27:50.924]             `+` <- base::`+`
[10:27:50.924]             `<<-` <- base::`<<-`
[10:27:50.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:50.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:50.924]                   3L)]
[10:27:50.924]             }
[10:27:50.924]             function(cond) {
[10:27:50.924]                 is_error <- inherits(cond, "error")
[10:27:50.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:50.924]                   NULL)
[10:27:50.924]                 if (is_error) {
[10:27:50.924]                   sessionInformation <- function() {
[10:27:50.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:50.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:50.924]                       search = base::search(), system = base::Sys.info())
[10:27:50.924]                   }
[10:27:50.924]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:50.924]                     cond$call), session = sessionInformation(), 
[10:27:50.924]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:50.924]                   signalCondition(cond)
[10:27:50.924]                 }
[10:27:50.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:50.924]                 "immediateCondition"))) {
[10:27:50.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:50.924]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:50.924]                   if (TRUE && !signal) {
[10:27:50.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.924]                     {
[10:27:50.924]                       inherits <- base::inherits
[10:27:50.924]                       invokeRestart <- base::invokeRestart
[10:27:50.924]                       is.null <- base::is.null
[10:27:50.924]                       muffled <- FALSE
[10:27:50.924]                       if (inherits(cond, "message")) {
[10:27:50.924]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.924]                         if (muffled) 
[10:27:50.924]                           invokeRestart("muffleMessage")
[10:27:50.924]                       }
[10:27:50.924]                       else if (inherits(cond, "warning")) {
[10:27:50.924]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.924]                         if (muffled) 
[10:27:50.924]                           invokeRestart("muffleWarning")
[10:27:50.924]                       }
[10:27:50.924]                       else if (inherits(cond, "condition")) {
[10:27:50.924]                         if (!is.null(pattern)) {
[10:27:50.924]                           computeRestarts <- base::computeRestarts
[10:27:50.924]                           grepl <- base::grepl
[10:27:50.924]                           restarts <- computeRestarts(cond)
[10:27:50.924]                           for (restart in restarts) {
[10:27:50.924]                             name <- restart$name
[10:27:50.924]                             if (is.null(name)) 
[10:27:50.924]                               next
[10:27:50.924]                             if (!grepl(pattern, name)) 
[10:27:50.924]                               next
[10:27:50.924]                             invokeRestart(restart)
[10:27:50.924]                             muffled <- TRUE
[10:27:50.924]                             break
[10:27:50.924]                           }
[10:27:50.924]                         }
[10:27:50.924]                       }
[10:27:50.924]                       invisible(muffled)
[10:27:50.924]                     }
[10:27:50.924]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.924]                   }
[10:27:50.924]                 }
[10:27:50.924]                 else {
[10:27:50.924]                   if (TRUE) {
[10:27:50.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.924]                     {
[10:27:50.924]                       inherits <- base::inherits
[10:27:50.924]                       invokeRestart <- base::invokeRestart
[10:27:50.924]                       is.null <- base::is.null
[10:27:50.924]                       muffled <- FALSE
[10:27:50.924]                       if (inherits(cond, "message")) {
[10:27:50.924]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.924]                         if (muffled) 
[10:27:50.924]                           invokeRestart("muffleMessage")
[10:27:50.924]                       }
[10:27:50.924]                       else if (inherits(cond, "warning")) {
[10:27:50.924]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.924]                         if (muffled) 
[10:27:50.924]                           invokeRestart("muffleWarning")
[10:27:50.924]                       }
[10:27:50.924]                       else if (inherits(cond, "condition")) {
[10:27:50.924]                         if (!is.null(pattern)) {
[10:27:50.924]                           computeRestarts <- base::computeRestarts
[10:27:50.924]                           grepl <- base::grepl
[10:27:50.924]                           restarts <- computeRestarts(cond)
[10:27:50.924]                           for (restart in restarts) {
[10:27:50.924]                             name <- restart$name
[10:27:50.924]                             if (is.null(name)) 
[10:27:50.924]                               next
[10:27:50.924]                             if (!grepl(pattern, name)) 
[10:27:50.924]                               next
[10:27:50.924]                             invokeRestart(restart)
[10:27:50.924]                             muffled <- TRUE
[10:27:50.924]                             break
[10:27:50.924]                           }
[10:27:50.924]                         }
[10:27:50.924]                       }
[10:27:50.924]                       invisible(muffled)
[10:27:50.924]                     }
[10:27:50.924]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.924]                   }
[10:27:50.924]                 }
[10:27:50.924]             }
[10:27:50.924]         }))
[10:27:50.924]     }, error = function(ex) {
[10:27:50.924]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:50.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.924]                 ...future.rng), started = ...future.startTime, 
[10:27:50.924]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:50.924]             version = "1.8"), class = "FutureResult")
[10:27:50.924]     }, finally = {
[10:27:50.924]         if (!identical(...future.workdir, getwd())) 
[10:27:50.924]             setwd(...future.workdir)
[10:27:50.924]         {
[10:27:50.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:50.924]                 ...future.oldOptions$nwarnings <- NULL
[10:27:50.924]             }
[10:27:50.924]             base::options(...future.oldOptions)
[10:27:50.924]             if (.Platform$OS.type == "windows") {
[10:27:50.924]                 old_names <- names(...future.oldEnvVars)
[10:27:50.924]                 envs <- base::Sys.getenv()
[10:27:50.924]                 names <- names(envs)
[10:27:50.924]                 common <- intersect(names, old_names)
[10:27:50.924]                 added <- setdiff(names, old_names)
[10:27:50.924]                 removed <- setdiff(old_names, names)
[10:27:50.924]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:50.924]                   envs[common]]
[10:27:50.924]                 NAMES <- toupper(changed)
[10:27:50.924]                 args <- list()
[10:27:50.924]                 for (kk in seq_along(NAMES)) {
[10:27:50.924]                   name <- changed[[kk]]
[10:27:50.924]                   NAME <- NAMES[[kk]]
[10:27:50.924]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.924]                     next
[10:27:50.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.924]                 }
[10:27:50.924]                 NAMES <- toupper(added)
[10:27:50.924]                 for (kk in seq_along(NAMES)) {
[10:27:50.924]                   name <- added[[kk]]
[10:27:50.924]                   NAME <- NAMES[[kk]]
[10:27:50.924]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.924]                     next
[10:27:50.924]                   args[[name]] <- ""
[10:27:50.924]                 }
[10:27:50.924]                 NAMES <- toupper(removed)
[10:27:50.924]                 for (kk in seq_along(NAMES)) {
[10:27:50.924]                   name <- removed[[kk]]
[10:27:50.924]                   NAME <- NAMES[[kk]]
[10:27:50.924]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.924]                     next
[10:27:50.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.924]                 }
[10:27:50.924]                 if (length(args) > 0) 
[10:27:50.924]                   base::do.call(base::Sys.setenv, args = args)
[10:27:50.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:50.924]             }
[10:27:50.924]             else {
[10:27:50.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:50.924]             }
[10:27:50.924]             {
[10:27:50.924]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:50.924]                   0L) {
[10:27:50.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:50.924]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:50.924]                   base::options(opts)
[10:27:50.924]                 }
[10:27:50.924]                 {
[10:27:50.924]                   {
[10:27:50.924]                     NULL
[10:27:50.924]                     RNGkind("Mersenne-Twister")
[10:27:50.924]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:50.924]                       inherits = FALSE)
[10:27:50.924]                   }
[10:27:50.924]                   options(future.plan = NULL)
[10:27:50.924]                   if (is.na(NA_character_)) 
[10:27:50.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:50.924]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:50.924]                   {
[10:27:50.924]                     future <- SequentialFuture(..., envir = envir)
[10:27:50.924]                     if (!future$lazy) 
[10:27:50.924]                       future <- run(future)
[10:27:50.924]                     invisible(future)
[10:27:50.924]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:50.924]                 }
[10:27:50.924]             }
[10:27:50.924]         }
[10:27:50.924]     })
[10:27:50.924]     if (TRUE) {
[10:27:50.924]         base::sink(type = "output", split = FALSE)
[10:27:50.924]         if (FALSE) {
[10:27:50.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:50.924]         }
[10:27:50.924]         else {
[10:27:50.924]             ...future.result["stdout"] <- base::list(NULL)
[10:27:50.924]         }
[10:27:50.924]         base::close(...future.stdout)
[10:27:50.924]         ...future.stdout <- NULL
[10:27:50.924]     }
[10:27:50.924]     ...future.result$conditions <- ...future.conditions
[10:27:50.924]     ...future.result$finished <- base::Sys.time()
[10:27:50.924]     ...future.result
[10:27:50.924] }
[10:27:50.926] plan(): Setting new future strategy stack:
[10:27:50.926] List of future strategies:
[10:27:50.926] 1. sequential:
[10:27:50.926]    - args: function (..., envir = parent.frame())
[10:27:50.926]    - tweaked: FALSE
[10:27:50.926]    - call: NULL
[10:27:50.926] plan(): nbrOfWorkers() = 1
[10:27:50.928] plan(): Setting new future strategy stack:
[10:27:50.928] List of future strategies:
[10:27:50.928] 1. sequential:
[10:27:50.928]    - args: function (..., envir = parent.frame())
[10:27:50.928]    - tweaked: FALSE
[10:27:50.928]    - call: plan(strategy)
[10:27:50.928] plan(): nbrOfWorkers() = 1
[10:27:50.928] SequentialFuture started (and completed)
[10:27:50.928] - Launch lazy future ... done
[10:27:50.929] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[10:27:50.929] getGlobalsAndPackages() ...
[10:27:50.929] Searching for globals...
[10:27:50.930] - globals found: [1] ‘print’
[10:27:50.930] Searching for globals ... DONE
[10:27:50.930] Resolving globals: FALSE
[10:27:50.930] 
[10:27:50.930] 
[10:27:50.930] getGlobalsAndPackages() ... DONE
[10:27:50.930] run() for ‘Future’ ...
[10:27:50.931] - state: ‘created’
[10:27:50.931] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:50.933] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:50.933] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:50.933]   - Field: ‘label’
[10:27:50.933]   - Field: ‘local’
[10:27:50.933]   - Field: ‘owner’
[10:27:50.933]   - Field: ‘envir’
[10:27:50.933]   - Field: ‘packages’
[10:27:50.934]   - Field: ‘gc’
[10:27:50.934]   - Field: ‘conditions’
[10:27:50.934]   - Field: ‘expr’
[10:27:50.934]   - Field: ‘uuid’
[10:27:50.934]   - Field: ‘seed’
[10:27:50.934]   - Field: ‘version’
[10:27:50.934]   - Field: ‘result’
[10:27:50.934]   - Field: ‘asynchronous’
[10:27:50.934]   - Field: ‘calls’
[10:27:50.934]   - Field: ‘globals’
[10:27:50.934]   - Field: ‘stdout’
[10:27:50.935]   - Field: ‘earlySignal’
[10:27:50.935]   - Field: ‘lazy’
[10:27:50.935]   - Field: ‘state’
[10:27:50.935] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:50.935] - Launch lazy future ...
[10:27:50.935] Packages needed by the future expression (n = 0): <none>
[10:27:50.935] Packages needed by future strategies (n = 0): <none>
[10:27:50.936] {
[10:27:50.936]     {
[10:27:50.936]         {
[10:27:50.936]             ...future.startTime <- base::Sys.time()
[10:27:50.936]             {
[10:27:50.936]                 {
[10:27:50.936]                   {
[10:27:50.936]                     base::local({
[10:27:50.936]                       has_future <- base::requireNamespace("future", 
[10:27:50.936]                         quietly = TRUE)
[10:27:50.936]                       if (has_future) {
[10:27:50.936]                         ns <- base::getNamespace("future")
[10:27:50.936]                         version <- ns[[".package"]][["version"]]
[10:27:50.936]                         if (is.null(version)) 
[10:27:50.936]                           version <- utils::packageVersion("future")
[10:27:50.936]                       }
[10:27:50.936]                       else {
[10:27:50.936]                         version <- NULL
[10:27:50.936]                       }
[10:27:50.936]                       if (!has_future || version < "1.8.0") {
[10:27:50.936]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:50.936]                           "", base::R.version$version.string), 
[10:27:50.936]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:50.936]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:50.936]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:50.936]                             "release", "version")], collapse = " "), 
[10:27:50.936]                           hostname = base::Sys.info()[["nodename"]])
[10:27:50.936]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:50.936]                           info)
[10:27:50.936]                         info <- base::paste(info, collapse = "; ")
[10:27:50.936]                         if (!has_future) {
[10:27:50.936]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:50.936]                             info)
[10:27:50.936]                         }
[10:27:50.936]                         else {
[10:27:50.936]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:50.936]                             info, version)
[10:27:50.936]                         }
[10:27:50.936]                         base::stop(msg)
[10:27:50.936]                       }
[10:27:50.936]                     })
[10:27:50.936]                   }
[10:27:50.936]                   options(future.plan = NULL)
[10:27:50.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:50.936]                 }
[10:27:50.936]                 ...future.workdir <- getwd()
[10:27:50.936]             }
[10:27:50.936]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:50.936]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:50.936]         }
[10:27:50.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:50.936]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:50.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:50.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:50.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:50.936]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:50.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:50.936]             base::names(...future.oldOptions))
[10:27:50.936]     }
[10:27:50.936]     if (FALSE) {
[10:27:50.936]     }
[10:27:50.936]     else {
[10:27:50.936]         if (TRUE) {
[10:27:50.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:50.936]                 open = "w")
[10:27:50.936]         }
[10:27:50.936]         else {
[10:27:50.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:50.936]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:50.936]         }
[10:27:50.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:50.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:50.936]             base::sink(type = "output", split = FALSE)
[10:27:50.936]             base::close(...future.stdout)
[10:27:50.936]         }, add = TRUE)
[10:27:50.936]     }
[10:27:50.936]     ...future.frame <- base::sys.nframe()
[10:27:50.936]     ...future.conditions <- base::list()
[10:27:50.936]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:50.936]     if (FALSE) {
[10:27:50.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:50.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:50.936]     }
[10:27:50.936]     ...future.result <- base::tryCatch({
[10:27:50.936]         base::withCallingHandlers({
[10:27:50.936]             ...future.value <- base::withVisible(base::local(print(42)))
[10:27:50.936]             future::FutureResult(value = ...future.value$value, 
[10:27:50.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.936]                   ...future.rng), globalenv = if (FALSE) 
[10:27:50.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:50.936]                     ...future.globalenv.names))
[10:27:50.936]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:50.936]         }, condition = base::local({
[10:27:50.936]             c <- base::c
[10:27:50.936]             inherits <- base::inherits
[10:27:50.936]             invokeRestart <- base::invokeRestart
[10:27:50.936]             length <- base::length
[10:27:50.936]             list <- base::list
[10:27:50.936]             seq.int <- base::seq.int
[10:27:50.936]             signalCondition <- base::signalCondition
[10:27:50.936]             sys.calls <- base::sys.calls
[10:27:50.936]             `[[` <- base::`[[`
[10:27:50.936]             `+` <- base::`+`
[10:27:50.936]             `<<-` <- base::`<<-`
[10:27:50.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:50.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:50.936]                   3L)]
[10:27:50.936]             }
[10:27:50.936]             function(cond) {
[10:27:50.936]                 is_error <- inherits(cond, "error")
[10:27:50.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:50.936]                   NULL)
[10:27:50.936]                 if (is_error) {
[10:27:50.936]                   sessionInformation <- function() {
[10:27:50.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:50.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:50.936]                       search = base::search(), system = base::Sys.info())
[10:27:50.936]                   }
[10:27:50.936]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:50.936]                     cond$call), session = sessionInformation(), 
[10:27:50.936]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:50.936]                   signalCondition(cond)
[10:27:50.936]                 }
[10:27:50.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:50.936]                 "immediateCondition"))) {
[10:27:50.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:50.936]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:50.936]                   if (TRUE && !signal) {
[10:27:50.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.936]                     {
[10:27:50.936]                       inherits <- base::inherits
[10:27:50.936]                       invokeRestart <- base::invokeRestart
[10:27:50.936]                       is.null <- base::is.null
[10:27:50.936]                       muffled <- FALSE
[10:27:50.936]                       if (inherits(cond, "message")) {
[10:27:50.936]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.936]                         if (muffled) 
[10:27:50.936]                           invokeRestart("muffleMessage")
[10:27:50.936]                       }
[10:27:50.936]                       else if (inherits(cond, "warning")) {
[10:27:50.936]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.936]                         if (muffled) 
[10:27:50.936]                           invokeRestart("muffleWarning")
[10:27:50.936]                       }
[10:27:50.936]                       else if (inherits(cond, "condition")) {
[10:27:50.936]                         if (!is.null(pattern)) {
[10:27:50.936]                           computeRestarts <- base::computeRestarts
[10:27:50.936]                           grepl <- base::grepl
[10:27:50.936]                           restarts <- computeRestarts(cond)
[10:27:50.936]                           for (restart in restarts) {
[10:27:50.936]                             name <- restart$name
[10:27:50.936]                             if (is.null(name)) 
[10:27:50.936]                               next
[10:27:50.936]                             if (!grepl(pattern, name)) 
[10:27:50.936]                               next
[10:27:50.936]                             invokeRestart(restart)
[10:27:50.936]                             muffled <- TRUE
[10:27:50.936]                             break
[10:27:50.936]                           }
[10:27:50.936]                         }
[10:27:50.936]                       }
[10:27:50.936]                       invisible(muffled)
[10:27:50.936]                     }
[10:27:50.936]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.936]                   }
[10:27:50.936]                 }
[10:27:50.936]                 else {
[10:27:50.936]                   if (TRUE) {
[10:27:50.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.936]                     {
[10:27:50.936]                       inherits <- base::inherits
[10:27:50.936]                       invokeRestart <- base::invokeRestart
[10:27:50.936]                       is.null <- base::is.null
[10:27:50.936]                       muffled <- FALSE
[10:27:50.936]                       if (inherits(cond, "message")) {
[10:27:50.936]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.936]                         if (muffled) 
[10:27:50.936]                           invokeRestart("muffleMessage")
[10:27:50.936]                       }
[10:27:50.936]                       else if (inherits(cond, "warning")) {
[10:27:50.936]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.936]                         if (muffled) 
[10:27:50.936]                           invokeRestart("muffleWarning")
[10:27:50.936]                       }
[10:27:50.936]                       else if (inherits(cond, "condition")) {
[10:27:50.936]                         if (!is.null(pattern)) {
[10:27:50.936]                           computeRestarts <- base::computeRestarts
[10:27:50.936]                           grepl <- base::grepl
[10:27:50.936]                           restarts <- computeRestarts(cond)
[10:27:50.936]                           for (restart in restarts) {
[10:27:50.936]                             name <- restart$name
[10:27:50.936]                             if (is.null(name)) 
[10:27:50.936]                               next
[10:27:50.936]                             if (!grepl(pattern, name)) 
[10:27:50.936]                               next
[10:27:50.936]                             invokeRestart(restart)
[10:27:50.936]                             muffled <- TRUE
[10:27:50.936]                             break
[10:27:50.936]                           }
[10:27:50.936]                         }
[10:27:50.936]                       }
[10:27:50.936]                       invisible(muffled)
[10:27:50.936]                     }
[10:27:50.936]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.936]                   }
[10:27:50.936]                 }
[10:27:50.936]             }
[10:27:50.936]         }))
[10:27:50.936]     }, error = function(ex) {
[10:27:50.936]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:50.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.936]                 ...future.rng), started = ...future.startTime, 
[10:27:50.936]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:50.936]             version = "1.8"), class = "FutureResult")
[10:27:50.936]     }, finally = {
[10:27:50.936]         if (!identical(...future.workdir, getwd())) 
[10:27:50.936]             setwd(...future.workdir)
[10:27:50.936]         {
[10:27:50.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:50.936]                 ...future.oldOptions$nwarnings <- NULL
[10:27:50.936]             }
[10:27:50.936]             base::options(...future.oldOptions)
[10:27:50.936]             if (.Platform$OS.type == "windows") {
[10:27:50.936]                 old_names <- names(...future.oldEnvVars)
[10:27:50.936]                 envs <- base::Sys.getenv()
[10:27:50.936]                 names <- names(envs)
[10:27:50.936]                 common <- intersect(names, old_names)
[10:27:50.936]                 added <- setdiff(names, old_names)
[10:27:50.936]                 removed <- setdiff(old_names, names)
[10:27:50.936]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:50.936]                   envs[common]]
[10:27:50.936]                 NAMES <- toupper(changed)
[10:27:50.936]                 args <- list()
[10:27:50.936]                 for (kk in seq_along(NAMES)) {
[10:27:50.936]                   name <- changed[[kk]]
[10:27:50.936]                   NAME <- NAMES[[kk]]
[10:27:50.936]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.936]                     next
[10:27:50.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.936]                 }
[10:27:50.936]                 NAMES <- toupper(added)
[10:27:50.936]                 for (kk in seq_along(NAMES)) {
[10:27:50.936]                   name <- added[[kk]]
[10:27:50.936]                   NAME <- NAMES[[kk]]
[10:27:50.936]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.936]                     next
[10:27:50.936]                   args[[name]] <- ""
[10:27:50.936]                 }
[10:27:50.936]                 NAMES <- toupper(removed)
[10:27:50.936]                 for (kk in seq_along(NAMES)) {
[10:27:50.936]                   name <- removed[[kk]]
[10:27:50.936]                   NAME <- NAMES[[kk]]
[10:27:50.936]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.936]                     next
[10:27:50.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.936]                 }
[10:27:50.936]                 if (length(args) > 0) 
[10:27:50.936]                   base::do.call(base::Sys.setenv, args = args)
[10:27:50.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:50.936]             }
[10:27:50.936]             else {
[10:27:50.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:50.936]             }
[10:27:50.936]             {
[10:27:50.936]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:50.936]                   0L) {
[10:27:50.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:50.936]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:50.936]                   base::options(opts)
[10:27:50.936]                 }
[10:27:50.936]                 {
[10:27:50.936]                   {
[10:27:50.936]                     NULL
[10:27:50.936]                     RNGkind("Mersenne-Twister")
[10:27:50.936]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:50.936]                       inherits = FALSE)
[10:27:50.936]                   }
[10:27:50.936]                   options(future.plan = NULL)
[10:27:50.936]                   if (is.na(NA_character_)) 
[10:27:50.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:50.936]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:50.936]                   {
[10:27:50.936]                     future <- SequentialFuture(..., envir = envir)
[10:27:50.936]                     if (!future$lazy) 
[10:27:50.936]                       future <- run(future)
[10:27:50.936]                     invisible(future)
[10:27:50.936]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:50.936]                 }
[10:27:50.936]             }
[10:27:50.936]         }
[10:27:50.936]     })
[10:27:50.936]     if (TRUE) {
[10:27:50.936]         base::sink(type = "output", split = FALSE)
[10:27:50.936]         if (TRUE) {
[10:27:50.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:50.936]         }
[10:27:50.936]         else {
[10:27:50.936]             ...future.result["stdout"] <- base::list(NULL)
[10:27:50.936]         }
[10:27:50.936]         base::close(...future.stdout)
[10:27:50.936]         ...future.stdout <- NULL
[10:27:50.936]     }
[10:27:50.936]     ...future.result$conditions <- ...future.conditions
[10:27:50.936]     ...future.result$finished <- base::Sys.time()
[10:27:50.936]     ...future.result
[10:27:50.936] }
[10:27:50.937] plan(): Setting new future strategy stack:
[10:27:50.938] List of future strategies:
[10:27:50.938] 1. sequential:
[10:27:50.938]    - args: function (..., envir = parent.frame())
[10:27:50.938]    - tweaked: FALSE
[10:27:50.938]    - call: NULL
[10:27:50.938] plan(): nbrOfWorkers() = 1
[10:27:50.939] plan(): Setting new future strategy stack:
[10:27:50.939] List of future strategies:
[10:27:50.939] 1. sequential:
[10:27:50.939]    - args: function (..., envir = parent.frame())
[10:27:50.939]    - tweaked: FALSE
[10:27:50.939]    - call: plan(strategy)
[10:27:50.939] plan(): nbrOfWorkers() = 1
[10:27:50.939] SequentialFuture started (and completed)
[10:27:50.939] - Launch lazy future ... done
[10:27:50.939] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = NA
[10:27:50.940] getGlobalsAndPackages() ...
[10:27:50.940] Searching for globals...
[10:27:50.943] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:50.943] Searching for globals ... DONE
[10:27:50.943] Resolving globals: FALSE
[10:27:50.943] 
[10:27:50.943] - packages: [1] ‘utils’
[10:27:50.944] getGlobalsAndPackages() ... DONE
[10:27:50.944] run() for ‘Future’ ...
[10:27:50.944] - state: ‘created’
[10:27:50.944] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:50.944] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:50.944] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:50.945]   - Field: ‘label’
[10:27:50.945]   - Field: ‘local’
[10:27:50.945]   - Field: ‘owner’
[10:27:50.945]   - Field: ‘envir’
[10:27:50.945]   - Field: ‘packages’
[10:27:50.945]   - Field: ‘gc’
[10:27:50.945]   - Field: ‘conditions’
[10:27:50.945]   - Field: ‘expr’
[10:27:50.945]   - Field: ‘uuid’
[10:27:50.945]   - Field: ‘seed’
[10:27:50.945]   - Field: ‘version’
[10:27:50.946]   - Field: ‘result’
[10:27:50.946]   - Field: ‘asynchronous’
[10:27:50.946]   - Field: ‘calls’
[10:27:50.946]   - Field: ‘globals’
[10:27:50.946]   - Field: ‘stdout’
[10:27:50.946]   - Field: ‘earlySignal’
[10:27:50.946]   - Field: ‘lazy’
[10:27:50.946]   - Field: ‘state’
[10:27:50.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:50.946] - Launch lazy future ...
[10:27:50.947] Packages needed by the future expression (n = 1): ‘utils’
[10:27:50.947] Packages needed by future strategies (n = 0): <none>
[10:27:50.947] {
[10:27:50.947]     {
[10:27:50.947]         {
[10:27:50.947]             ...future.startTime <- base::Sys.time()
[10:27:50.947]             {
[10:27:50.947]                 {
[10:27:50.947]                   {
[10:27:50.947]                     {
[10:27:50.947]                       base::local({
[10:27:50.947]                         has_future <- base::requireNamespace("future", 
[10:27:50.947]                           quietly = TRUE)
[10:27:50.947]                         if (has_future) {
[10:27:50.947]                           ns <- base::getNamespace("future")
[10:27:50.947]                           version <- ns[[".package"]][["version"]]
[10:27:50.947]                           if (is.null(version)) 
[10:27:50.947]                             version <- utils::packageVersion("future")
[10:27:50.947]                         }
[10:27:50.947]                         else {
[10:27:50.947]                           version <- NULL
[10:27:50.947]                         }
[10:27:50.947]                         if (!has_future || version < "1.8.0") {
[10:27:50.947]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:50.947]                             "", base::R.version$version.string), 
[10:27:50.947]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:50.947]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:50.947]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:50.947]                               "release", "version")], collapse = " "), 
[10:27:50.947]                             hostname = base::Sys.info()[["nodename"]])
[10:27:50.947]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:50.947]                             info)
[10:27:50.947]                           info <- base::paste(info, collapse = "; ")
[10:27:50.947]                           if (!has_future) {
[10:27:50.947]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:50.947]                               info)
[10:27:50.947]                           }
[10:27:50.947]                           else {
[10:27:50.947]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:50.947]                               info, version)
[10:27:50.947]                           }
[10:27:50.947]                           base::stop(msg)
[10:27:50.947]                         }
[10:27:50.947]                       })
[10:27:50.947]                     }
[10:27:50.947]                     base::local({
[10:27:50.947]                       for (pkg in "utils") {
[10:27:50.947]                         base::loadNamespace(pkg)
[10:27:50.947]                         base::library(pkg, character.only = TRUE)
[10:27:50.947]                       }
[10:27:50.947]                     })
[10:27:50.947]                   }
[10:27:50.947]                   options(future.plan = NULL)
[10:27:50.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:50.947]                 }
[10:27:50.947]                 ...future.workdir <- getwd()
[10:27:50.947]             }
[10:27:50.947]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:50.947]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:50.947]         }
[10:27:50.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:50.947]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:50.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:50.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:50.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:50.947]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:50.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:50.947]             base::names(...future.oldOptions))
[10:27:50.947]     }
[10:27:50.947]     if (TRUE) {
[10:27:50.947]     }
[10:27:50.947]     else {
[10:27:50.947]         if (NA) {
[10:27:50.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:50.947]                 open = "w")
[10:27:50.947]         }
[10:27:50.947]         else {
[10:27:50.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:50.947]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:50.947]         }
[10:27:50.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:50.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:50.947]             base::sink(type = "output", split = FALSE)
[10:27:50.947]             base::close(...future.stdout)
[10:27:50.947]         }, add = TRUE)
[10:27:50.947]     }
[10:27:50.947]     ...future.frame <- base::sys.nframe()
[10:27:50.947]     ...future.conditions <- base::list()
[10:27:50.947]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:50.947]     if (FALSE) {
[10:27:50.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:50.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:50.947]     }
[10:27:50.947]     ...future.result <- base::tryCatch({
[10:27:50.947]         base::withCallingHandlers({
[10:27:50.947]             ...future.value <- base::withVisible(base::local({
[10:27:50.947]                 print(1:50)
[10:27:50.947]                 str(1:50)
[10:27:50.947]                 cat(letters, sep = "-")
[10:27:50.947]                 cat(1:6, collapse = "\n")
[10:27:50.947]                 write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:50.947]                 42L
[10:27:50.947]             }))
[10:27:50.947]             future::FutureResult(value = ...future.value$value, 
[10:27:50.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.947]                   ...future.rng), globalenv = if (FALSE) 
[10:27:50.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:50.947]                     ...future.globalenv.names))
[10:27:50.947]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:50.947]         }, condition = base::local({
[10:27:50.947]             c <- base::c
[10:27:50.947]             inherits <- base::inherits
[10:27:50.947]             invokeRestart <- base::invokeRestart
[10:27:50.947]             length <- base::length
[10:27:50.947]             list <- base::list
[10:27:50.947]             seq.int <- base::seq.int
[10:27:50.947]             signalCondition <- base::signalCondition
[10:27:50.947]             sys.calls <- base::sys.calls
[10:27:50.947]             `[[` <- base::`[[`
[10:27:50.947]             `+` <- base::`+`
[10:27:50.947]             `<<-` <- base::`<<-`
[10:27:50.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:50.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:50.947]                   3L)]
[10:27:50.947]             }
[10:27:50.947]             function(cond) {
[10:27:50.947]                 is_error <- inherits(cond, "error")
[10:27:50.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:50.947]                   NULL)
[10:27:50.947]                 if (is_error) {
[10:27:50.947]                   sessionInformation <- function() {
[10:27:50.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:50.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:50.947]                       search = base::search(), system = base::Sys.info())
[10:27:50.947]                   }
[10:27:50.947]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:50.947]                     cond$call), session = sessionInformation(), 
[10:27:50.947]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:50.947]                   signalCondition(cond)
[10:27:50.947]                 }
[10:27:50.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:50.947]                 "immediateCondition"))) {
[10:27:50.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:50.947]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:50.947]                   if (TRUE && !signal) {
[10:27:50.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.947]                     {
[10:27:50.947]                       inherits <- base::inherits
[10:27:50.947]                       invokeRestart <- base::invokeRestart
[10:27:50.947]                       is.null <- base::is.null
[10:27:50.947]                       muffled <- FALSE
[10:27:50.947]                       if (inherits(cond, "message")) {
[10:27:50.947]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.947]                         if (muffled) 
[10:27:50.947]                           invokeRestart("muffleMessage")
[10:27:50.947]                       }
[10:27:50.947]                       else if (inherits(cond, "warning")) {
[10:27:50.947]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.947]                         if (muffled) 
[10:27:50.947]                           invokeRestart("muffleWarning")
[10:27:50.947]                       }
[10:27:50.947]                       else if (inherits(cond, "condition")) {
[10:27:50.947]                         if (!is.null(pattern)) {
[10:27:50.947]                           computeRestarts <- base::computeRestarts
[10:27:50.947]                           grepl <- base::grepl
[10:27:50.947]                           restarts <- computeRestarts(cond)
[10:27:50.947]                           for (restart in restarts) {
[10:27:50.947]                             name <- restart$name
[10:27:50.947]                             if (is.null(name)) 
[10:27:50.947]                               next
[10:27:50.947]                             if (!grepl(pattern, name)) 
[10:27:50.947]                               next
[10:27:50.947]                             invokeRestart(restart)
[10:27:50.947]                             muffled <- TRUE
[10:27:50.947]                             break
[10:27:50.947]                           }
[10:27:50.947]                         }
[10:27:50.947]                       }
[10:27:50.947]                       invisible(muffled)
[10:27:50.947]                     }
[10:27:50.947]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.947]                   }
[10:27:50.947]                 }
[10:27:50.947]                 else {
[10:27:50.947]                   if (TRUE) {
[10:27:50.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.947]                     {
[10:27:50.947]                       inherits <- base::inherits
[10:27:50.947]                       invokeRestart <- base::invokeRestart
[10:27:50.947]                       is.null <- base::is.null
[10:27:50.947]                       muffled <- FALSE
[10:27:50.947]                       if (inherits(cond, "message")) {
[10:27:50.947]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.947]                         if (muffled) 
[10:27:50.947]                           invokeRestart("muffleMessage")
[10:27:50.947]                       }
[10:27:50.947]                       else if (inherits(cond, "warning")) {
[10:27:50.947]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.947]                         if (muffled) 
[10:27:50.947]                           invokeRestart("muffleWarning")
[10:27:50.947]                       }
[10:27:50.947]                       else if (inherits(cond, "condition")) {
[10:27:50.947]                         if (!is.null(pattern)) {
[10:27:50.947]                           computeRestarts <- base::computeRestarts
[10:27:50.947]                           grepl <- base::grepl
[10:27:50.947]                           restarts <- computeRestarts(cond)
[10:27:50.947]                           for (restart in restarts) {
[10:27:50.947]                             name <- restart$name
[10:27:50.947]                             if (is.null(name)) 
[10:27:50.947]                               next
[10:27:50.947]                             if (!grepl(pattern, name)) 
[10:27:50.947]                               next
[10:27:50.947]                             invokeRestart(restart)
[10:27:50.947]                             muffled <- TRUE
[10:27:50.947]                             break
[10:27:50.947]                           }
[10:27:50.947]                         }
[10:27:50.947]                       }
[10:27:50.947]                       invisible(muffled)
[10:27:50.947]                     }
[10:27:50.947]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.947]                   }
[10:27:50.947]                 }
[10:27:50.947]             }
[10:27:50.947]         }))
[10:27:50.947]     }, error = function(ex) {
[10:27:50.947]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:50.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.947]                 ...future.rng), started = ...future.startTime, 
[10:27:50.947]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:50.947]             version = "1.8"), class = "FutureResult")
[10:27:50.947]     }, finally = {
[10:27:50.947]         if (!identical(...future.workdir, getwd())) 
[10:27:50.947]             setwd(...future.workdir)
[10:27:50.947]         {
[10:27:50.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:50.947]                 ...future.oldOptions$nwarnings <- NULL
[10:27:50.947]             }
[10:27:50.947]             base::options(...future.oldOptions)
[10:27:50.947]             if (.Platform$OS.type == "windows") {
[10:27:50.947]                 old_names <- names(...future.oldEnvVars)
[10:27:50.947]                 envs <- base::Sys.getenv()
[10:27:50.947]                 names <- names(envs)
[10:27:50.947]                 common <- intersect(names, old_names)
[10:27:50.947]                 added <- setdiff(names, old_names)
[10:27:50.947]                 removed <- setdiff(old_names, names)
[10:27:50.947]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:50.947]                   envs[common]]
[10:27:50.947]                 NAMES <- toupper(changed)
[10:27:50.947]                 args <- list()
[10:27:50.947]                 for (kk in seq_along(NAMES)) {
[10:27:50.947]                   name <- changed[[kk]]
[10:27:50.947]                   NAME <- NAMES[[kk]]
[10:27:50.947]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.947]                     next
[10:27:50.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.947]                 }
[10:27:50.947]                 NAMES <- toupper(added)
[10:27:50.947]                 for (kk in seq_along(NAMES)) {
[10:27:50.947]                   name <- added[[kk]]
[10:27:50.947]                   NAME <- NAMES[[kk]]
[10:27:50.947]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.947]                     next
[10:27:50.947]                   args[[name]] <- ""
[10:27:50.947]                 }
[10:27:50.947]                 NAMES <- toupper(removed)
[10:27:50.947]                 for (kk in seq_along(NAMES)) {
[10:27:50.947]                   name <- removed[[kk]]
[10:27:50.947]                   NAME <- NAMES[[kk]]
[10:27:50.947]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.947]                     next
[10:27:50.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.947]                 }
[10:27:50.947]                 if (length(args) > 0) 
[10:27:50.947]                   base::do.call(base::Sys.setenv, args = args)
[10:27:50.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:50.947]             }
[10:27:50.947]             else {
[10:27:50.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:50.947]             }
[10:27:50.947]             {
[10:27:50.947]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:50.947]                   0L) {
[10:27:50.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:50.947]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:50.947]                   base::options(opts)
[10:27:50.947]                 }
[10:27:50.947]                 {
[10:27:50.947]                   {
[10:27:50.947]                     NULL
[10:27:50.947]                     RNGkind("Mersenne-Twister")
[10:27:50.947]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:50.947]                       inherits = FALSE)
[10:27:50.947]                   }
[10:27:50.947]                   options(future.plan = NULL)
[10:27:50.947]                   if (is.na(NA_character_)) 
[10:27:50.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:50.947]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:50.947]                   {
[10:27:50.947]                     future <- SequentialFuture(..., envir = envir)
[10:27:50.947]                     if (!future$lazy) 
[10:27:50.947]                       future <- run(future)
[10:27:50.947]                     invisible(future)
[10:27:50.947]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:50.947]                 }
[10:27:50.947]             }
[10:27:50.947]         }
[10:27:50.947]     })
[10:27:50.947]     if (FALSE) {
[10:27:50.947]         base::sink(type = "output", split = FALSE)
[10:27:50.947]         if (NA) {
[10:27:50.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:50.947]         }
[10:27:50.947]         else {
[10:27:50.947]             ...future.result["stdout"] <- base::list(NULL)
[10:27:50.947]         }
[10:27:50.947]         base::close(...future.stdout)
[10:27:50.947]         ...future.stdout <- NULL
[10:27:50.947]     }
[10:27:50.947]     ...future.result$conditions <- ...future.conditions
[10:27:50.947]     ...future.result$finished <- base::Sys.time()
[10:27:50.947]     ...future.result
[10:27:50.947] }
[10:27:50.949] plan(): Setting new future strategy stack:
[10:27:50.949] List of future strategies:
[10:27:50.949] 1. sequential:
[10:27:50.949]    - args: function (..., envir = parent.frame())
[10:27:50.949]    - tweaked: FALSE
[10:27:50.949]    - call: NULL
[10:27:50.950] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[10:27:50.951] plan(): Setting new future strategy stack:
[10:27:50.951] List of future strategies:
[10:27:50.951] 1. sequential:
[10:27:50.951]    - args: function (..., envir = parent.frame())
[10:27:50.951]    - tweaked: FALSE
[10:27:50.951]    - call: plan(strategy)
[10:27:50.952] plan(): nbrOfWorkers() = 1
[10:27:50.952] SequentialFuture started (and completed)
[10:27:50.952] - Launch lazy future ... done
[10:27:50.952] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 10:27:50"
 $ finished    : POSIXct[1:1], format: "2025-01-07 10:27:50"
 $ session_uuid: chr "ab9ea6fb-b352-f592-ef73-0faa546d9359"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3e863ac79bce"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92649
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 10:27:50"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:27:50.961] getGlobalsAndPackages() ...
[10:27:50.962] Searching for globals...
[10:27:50.964] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:50.965] Searching for globals ... DONE
[10:27:50.965] Resolving globals: FALSE
[10:27:50.965] 
[10:27:50.965] - packages: [1] ‘utils’
[10:27:50.965] getGlobalsAndPackages() ... DONE
[10:27:50.966] run() for ‘Future’ ...
[10:27:50.966] - state: ‘created’
[10:27:50.966] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:50.966] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:50.966] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:50.966]   - Field: ‘label’
[10:27:50.966]   - Field: ‘local’
[10:27:50.967]   - Field: ‘owner’
[10:27:50.967]   - Field: ‘envir’
[10:27:50.967]   - Field: ‘packages’
[10:27:50.967]   - Field: ‘gc’
[10:27:50.967]   - Field: ‘conditions’
[10:27:50.967]   - Field: ‘expr’
[10:27:50.967]   - Field: ‘uuid’
[10:27:50.967]   - Field: ‘seed’
[10:27:50.967]   - Field: ‘version’
[10:27:50.967]   - Field: ‘result’
[10:27:50.968]   - Field: ‘asynchronous’
[10:27:50.968]   - Field: ‘calls’
[10:27:50.968]   - Field: ‘globals’
[10:27:50.968]   - Field: ‘stdout’
[10:27:50.968]   - Field: ‘earlySignal’
[10:27:50.968]   - Field: ‘lazy’
[10:27:50.968]   - Field: ‘state’
[10:27:50.968] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:50.968] - Launch lazy future ...
[10:27:50.968] Packages needed by the future expression (n = 1): ‘utils’
[10:27:50.969] Packages needed by future strategies (n = 0): <none>
[10:27:50.969] {
[10:27:50.969]     {
[10:27:50.969]         {
[10:27:50.969]             ...future.startTime <- base::Sys.time()
[10:27:50.969]             {
[10:27:50.969]                 {
[10:27:50.969]                   {
[10:27:50.969]                     {
[10:27:50.969]                       base::local({
[10:27:50.969]                         has_future <- base::requireNamespace("future", 
[10:27:50.969]                           quietly = TRUE)
[10:27:50.969]                         if (has_future) {
[10:27:50.969]                           ns <- base::getNamespace("future")
[10:27:50.969]                           version <- ns[[".package"]][["version"]]
[10:27:50.969]                           if (is.null(version)) 
[10:27:50.969]                             version <- utils::packageVersion("future")
[10:27:50.969]                         }
[10:27:50.969]                         else {
[10:27:50.969]                           version <- NULL
[10:27:50.969]                         }
[10:27:50.969]                         if (!has_future || version < "1.8.0") {
[10:27:50.969]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:50.969]                             "", base::R.version$version.string), 
[10:27:50.969]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:50.969]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:50.969]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:50.969]                               "release", "version")], collapse = " "), 
[10:27:50.969]                             hostname = base::Sys.info()[["nodename"]])
[10:27:50.969]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:50.969]                             info)
[10:27:50.969]                           info <- base::paste(info, collapse = "; ")
[10:27:50.969]                           if (!has_future) {
[10:27:50.969]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:50.969]                               info)
[10:27:50.969]                           }
[10:27:50.969]                           else {
[10:27:50.969]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:50.969]                               info, version)
[10:27:50.969]                           }
[10:27:50.969]                           base::stop(msg)
[10:27:50.969]                         }
[10:27:50.969]                       })
[10:27:50.969]                     }
[10:27:50.969]                     base::local({
[10:27:50.969]                       for (pkg in "utils") {
[10:27:50.969]                         base::loadNamespace(pkg)
[10:27:50.969]                         base::library(pkg, character.only = TRUE)
[10:27:50.969]                       }
[10:27:50.969]                     })
[10:27:50.969]                   }
[10:27:50.969]                   options(future.plan = NULL)
[10:27:50.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:50.969]                 }
[10:27:50.969]                 ...future.workdir <- getwd()
[10:27:50.969]             }
[10:27:50.969]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:50.969]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:50.969]         }
[10:27:50.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:50.969]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:50.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:50.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:50.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:50.969]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:50.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:50.969]             base::names(...future.oldOptions))
[10:27:50.969]     }
[10:27:50.969]     if (TRUE) {
[10:27:50.969]     }
[10:27:50.969]     else {
[10:27:50.969]         if (NA) {
[10:27:50.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:50.969]                 open = "w")
[10:27:50.969]         }
[10:27:50.969]         else {
[10:27:50.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:50.969]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:50.969]         }
[10:27:50.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:50.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:50.969]             base::sink(type = "output", split = FALSE)
[10:27:50.969]             base::close(...future.stdout)
[10:27:50.969]         }, add = TRUE)
[10:27:50.969]     }
[10:27:50.969]     ...future.frame <- base::sys.nframe()
[10:27:50.969]     ...future.conditions <- base::list()
[10:27:50.969]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:50.969]     if (FALSE) {
[10:27:50.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:50.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:50.969]     }
[10:27:50.969]     ...future.result <- base::tryCatch({
[10:27:50.969]         base::withCallingHandlers({
[10:27:50.969]             ...future.value <- base::withVisible(base::local({
[10:27:50.969]                 print(1:50)
[10:27:50.969]                 str(1:50)
[10:27:50.969]                 cat(letters, sep = "-")
[10:27:50.969]                 cat(1:6, collapse = "\n")
[10:27:50.969]                 write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:50.969]                 42L
[10:27:50.969]             }))
[10:27:50.969]             future::FutureResult(value = ...future.value$value, 
[10:27:50.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.969]                   ...future.rng), globalenv = if (FALSE) 
[10:27:50.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:50.969]                     ...future.globalenv.names))
[10:27:50.969]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:50.969]         }, condition = base::local({
[10:27:50.969]             c <- base::c
[10:27:50.969]             inherits <- base::inherits
[10:27:50.969]             invokeRestart <- base::invokeRestart
[10:27:50.969]             length <- base::length
[10:27:50.969]             list <- base::list
[10:27:50.969]             seq.int <- base::seq.int
[10:27:50.969]             signalCondition <- base::signalCondition
[10:27:50.969]             sys.calls <- base::sys.calls
[10:27:50.969]             `[[` <- base::`[[`
[10:27:50.969]             `+` <- base::`+`
[10:27:50.969]             `<<-` <- base::`<<-`
[10:27:50.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:50.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:50.969]                   3L)]
[10:27:50.969]             }
[10:27:50.969]             function(cond) {
[10:27:50.969]                 is_error <- inherits(cond, "error")
[10:27:50.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:50.969]                   NULL)
[10:27:50.969]                 if (is_error) {
[10:27:50.969]                   sessionInformation <- function() {
[10:27:50.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:50.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:50.969]                       search = base::search(), system = base::Sys.info())
[10:27:50.969]                   }
[10:27:50.969]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:50.969]                     cond$call), session = sessionInformation(), 
[10:27:50.969]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:50.969]                   signalCondition(cond)
[10:27:50.969]                 }
[10:27:50.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:50.969]                 "immediateCondition"))) {
[10:27:50.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:50.969]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:50.969]                   if (TRUE && !signal) {
[10:27:50.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.969]                     {
[10:27:50.969]                       inherits <- base::inherits
[10:27:50.969]                       invokeRestart <- base::invokeRestart
[10:27:50.969]                       is.null <- base::is.null
[10:27:50.969]                       muffled <- FALSE
[10:27:50.969]                       if (inherits(cond, "message")) {
[10:27:50.969]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.969]                         if (muffled) 
[10:27:50.969]                           invokeRestart("muffleMessage")
[10:27:50.969]                       }
[10:27:50.969]                       else if (inherits(cond, "warning")) {
[10:27:50.969]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.969]                         if (muffled) 
[10:27:50.969]                           invokeRestart("muffleWarning")
[10:27:50.969]                       }
[10:27:50.969]                       else if (inherits(cond, "condition")) {
[10:27:50.969]                         if (!is.null(pattern)) {
[10:27:50.969]                           computeRestarts <- base::computeRestarts
[10:27:50.969]                           grepl <- base::grepl
[10:27:50.969]                           restarts <- computeRestarts(cond)
[10:27:50.969]                           for (restart in restarts) {
[10:27:50.969]                             name <- restart$name
[10:27:50.969]                             if (is.null(name)) 
[10:27:50.969]                               next
[10:27:50.969]                             if (!grepl(pattern, name)) 
[10:27:50.969]                               next
[10:27:50.969]                             invokeRestart(restart)
[10:27:50.969]                             muffled <- TRUE
[10:27:50.969]                             break
[10:27:50.969]                           }
[10:27:50.969]                         }
[10:27:50.969]                       }
[10:27:50.969]                       invisible(muffled)
[10:27:50.969]                     }
[10:27:50.969]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.969]                   }
[10:27:50.969]                 }
[10:27:50.969]                 else {
[10:27:50.969]                   if (TRUE) {
[10:27:50.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.969]                     {
[10:27:50.969]                       inherits <- base::inherits
[10:27:50.969]                       invokeRestart <- base::invokeRestart
[10:27:50.969]                       is.null <- base::is.null
[10:27:50.969]                       muffled <- FALSE
[10:27:50.969]                       if (inherits(cond, "message")) {
[10:27:50.969]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.969]                         if (muffled) 
[10:27:50.969]                           invokeRestart("muffleMessage")
[10:27:50.969]                       }
[10:27:50.969]                       else if (inherits(cond, "warning")) {
[10:27:50.969]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.969]                         if (muffled) 
[10:27:50.969]                           invokeRestart("muffleWarning")
[10:27:50.969]                       }
[10:27:50.969]                       else if (inherits(cond, "condition")) {
[10:27:50.969]                         if (!is.null(pattern)) {
[10:27:50.969]                           computeRestarts <- base::computeRestarts
[10:27:50.969]                           grepl <- base::grepl
[10:27:50.969]                           restarts <- computeRestarts(cond)
[10:27:50.969]                           for (restart in restarts) {
[10:27:50.969]                             name <- restart$name
[10:27:50.969]                             if (is.null(name)) 
[10:27:50.969]                               next
[10:27:50.969]                             if (!grepl(pattern, name)) 
[10:27:50.969]                               next
[10:27:50.969]                             invokeRestart(restart)
[10:27:50.969]                             muffled <- TRUE
[10:27:50.969]                             break
[10:27:50.969]                           }
[10:27:50.969]                         }
[10:27:50.969]                       }
[10:27:50.969]                       invisible(muffled)
[10:27:50.969]                     }
[10:27:50.969]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.969]                   }
[10:27:50.969]                 }
[10:27:50.969]             }
[10:27:50.969]         }))
[10:27:50.969]     }, error = function(ex) {
[10:27:50.969]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:50.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.969]                 ...future.rng), started = ...future.startTime, 
[10:27:50.969]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:50.969]             version = "1.8"), class = "FutureResult")
[10:27:50.969]     }, finally = {
[10:27:50.969]         if (!identical(...future.workdir, getwd())) 
[10:27:50.969]             setwd(...future.workdir)
[10:27:50.969]         {
[10:27:50.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:50.969]                 ...future.oldOptions$nwarnings <- NULL
[10:27:50.969]             }
[10:27:50.969]             base::options(...future.oldOptions)
[10:27:50.969]             if (.Platform$OS.type == "windows") {
[10:27:50.969]                 old_names <- names(...future.oldEnvVars)
[10:27:50.969]                 envs <- base::Sys.getenv()
[10:27:50.969]                 names <- names(envs)
[10:27:50.969]                 common <- intersect(names, old_names)
[10:27:50.969]                 added <- setdiff(names, old_names)
[10:27:50.969]                 removed <- setdiff(old_names, names)
[10:27:50.969]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:50.969]                   envs[common]]
[10:27:50.969]                 NAMES <- toupper(changed)
[10:27:50.969]                 args <- list()
[10:27:50.969]                 for (kk in seq_along(NAMES)) {
[10:27:50.969]                   name <- changed[[kk]]
[10:27:50.969]                   NAME <- NAMES[[kk]]
[10:27:50.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.969]                     next
[10:27:50.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.969]                 }
[10:27:50.969]                 NAMES <- toupper(added)
[10:27:50.969]                 for (kk in seq_along(NAMES)) {
[10:27:50.969]                   name <- added[[kk]]
[10:27:50.969]                   NAME <- NAMES[[kk]]
[10:27:50.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.969]                     next
[10:27:50.969]                   args[[name]] <- ""
[10:27:50.969]                 }
[10:27:50.969]                 NAMES <- toupper(removed)
[10:27:50.969]                 for (kk in seq_along(NAMES)) {
[10:27:50.969]                   name <- removed[[kk]]
[10:27:50.969]                   NAME <- NAMES[[kk]]
[10:27:50.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.969]                     next
[10:27:50.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.969]                 }
[10:27:50.969]                 if (length(args) > 0) 
[10:27:50.969]                   base::do.call(base::Sys.setenv, args = args)
[10:27:50.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:50.969]             }
[10:27:50.969]             else {
[10:27:50.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:50.969]             }
[10:27:50.969]             {
[10:27:50.969]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:50.969]                   0L) {
[10:27:50.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:50.969]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:50.969]                   base::options(opts)
[10:27:50.969]                 }
[10:27:50.969]                 {
[10:27:50.969]                   {
[10:27:50.969]                     NULL
[10:27:50.969]                     RNGkind("Mersenne-Twister")
[10:27:50.969]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:50.969]                       inherits = FALSE)
[10:27:50.969]                   }
[10:27:50.969]                   options(future.plan = NULL)
[10:27:50.969]                   if (is.na(NA_character_)) 
[10:27:50.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:50.969]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:50.969]                   {
[10:27:50.969]                     future <- SequentialFuture(..., envir = envir)
[10:27:50.969]                     if (!future$lazy) 
[10:27:50.969]                       future <- run(future)
[10:27:50.969]                     invisible(future)
[10:27:50.969]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:50.969]                 }
[10:27:50.969]             }
[10:27:50.969]         }
[10:27:50.969]     })
[10:27:50.969]     if (FALSE) {
[10:27:50.969]         base::sink(type = "output", split = FALSE)
[10:27:50.969]         if (NA) {
[10:27:50.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:50.969]         }
[10:27:50.969]         else {
[10:27:50.969]             ...future.result["stdout"] <- base::list(NULL)
[10:27:50.969]         }
[10:27:50.969]         base::close(...future.stdout)
[10:27:50.969]         ...future.stdout <- NULL
[10:27:50.969]     }
[10:27:50.969]     ...future.result$conditions <- ...future.conditions
[10:27:50.969]     ...future.result$finished <- base::Sys.time()
[10:27:50.969]     ...future.result
[10:27:50.969] }
[10:27:50.971] plan(): Setting new future strategy stack:
[10:27:50.971] List of future strategies:
[10:27:50.971] 1. sequential:
[10:27:50.971]    - args: function (..., envir = parent.frame())
[10:27:50.971]    - tweaked: FALSE
[10:27:50.971]    - call: NULL
[10:27:50.972] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[10:27:50.973] plan(): Setting new future strategy stack:
[10:27:50.973] List of future strategies:
[10:27:50.973] 1. sequential:
[10:27:50.973]    - args: function (..., envir = parent.frame())
[10:27:50.973]    - tweaked: FALSE
[10:27:50.973]    - call: plan(strategy)
[10:27:50.974] plan(): nbrOfWorkers() = 1
[10:27:50.974] SequentialFuture started (and completed)
[10:27:50.974] - Launch lazy future ... done
[10:27:50.974] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[10:27:50.975] getGlobalsAndPackages() ...
[10:27:50.975] Searching for globals...
[10:27:50.975] - globals found: [1] ‘print’
[10:27:50.975] Searching for globals ... DONE
[10:27:50.975] Resolving globals: FALSE
[10:27:50.976] 
[10:27:50.976] 
[10:27:50.976] getGlobalsAndPackages() ... DONE
[10:27:50.976] run() for ‘Future’ ...
[10:27:50.976] - state: ‘created’
[10:27:50.976] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:50.977] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:50.977] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:50.977]   - Field: ‘label’
[10:27:50.977]   - Field: ‘local’
[10:27:50.977]   - Field: ‘owner’
[10:27:50.977]   - Field: ‘envir’
[10:27:50.977]   - Field: ‘packages’
[10:27:50.977]   - Field: ‘gc’
[10:27:50.977]   - Field: ‘conditions’
[10:27:50.978]   - Field: ‘expr’
[10:27:50.978]   - Field: ‘uuid’
[10:27:50.978]   - Field: ‘seed’
[10:27:50.978]   - Field: ‘version’
[10:27:50.978]   - Field: ‘result’
[10:27:50.978]   - Field: ‘asynchronous’
[10:27:50.978]   - Field: ‘calls’
[10:27:50.978]   - Field: ‘globals’
[10:27:50.978]   - Field: ‘stdout’
[10:27:50.978]   - Field: ‘earlySignal’
[10:27:50.978]   - Field: ‘lazy’
[10:27:50.979]   - Field: ‘state’
[10:27:50.979] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:50.979] - Launch lazy future ...
[10:27:50.979] Packages needed by the future expression (n = 0): <none>
[10:27:50.979] Packages needed by future strategies (n = 0): <none>
[10:27:50.979] {
[10:27:50.979]     {
[10:27:50.979]         {
[10:27:50.979]             ...future.startTime <- base::Sys.time()
[10:27:50.979]             {
[10:27:50.979]                 {
[10:27:50.979]                   {
[10:27:50.979]                     base::local({
[10:27:50.979]                       has_future <- base::requireNamespace("future", 
[10:27:50.979]                         quietly = TRUE)
[10:27:50.979]                       if (has_future) {
[10:27:50.979]                         ns <- base::getNamespace("future")
[10:27:50.979]                         version <- ns[[".package"]][["version"]]
[10:27:50.979]                         if (is.null(version)) 
[10:27:50.979]                           version <- utils::packageVersion("future")
[10:27:50.979]                       }
[10:27:50.979]                       else {
[10:27:50.979]                         version <- NULL
[10:27:50.979]                       }
[10:27:50.979]                       if (!has_future || version < "1.8.0") {
[10:27:50.979]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:50.979]                           "", base::R.version$version.string), 
[10:27:50.979]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:50.979]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:50.979]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:50.979]                             "release", "version")], collapse = " "), 
[10:27:50.979]                           hostname = base::Sys.info()[["nodename"]])
[10:27:50.979]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:50.979]                           info)
[10:27:50.979]                         info <- base::paste(info, collapse = "; ")
[10:27:50.979]                         if (!has_future) {
[10:27:50.979]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:50.979]                             info)
[10:27:50.979]                         }
[10:27:50.979]                         else {
[10:27:50.979]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:50.979]                             info, version)
[10:27:50.979]                         }
[10:27:50.979]                         base::stop(msg)
[10:27:50.979]                       }
[10:27:50.979]                     })
[10:27:50.979]                   }
[10:27:50.979]                   options(future.plan = NULL)
[10:27:50.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:50.979]                 }
[10:27:50.979]                 ...future.workdir <- getwd()
[10:27:50.979]             }
[10:27:50.979]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:50.979]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:50.979]         }
[10:27:50.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:50.979]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:50.979]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:50.979]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:50.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:50.979]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:50.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:50.979]             base::names(...future.oldOptions))
[10:27:50.979]     }
[10:27:50.979]     if (FALSE) {
[10:27:50.979]     }
[10:27:50.979]     else {
[10:27:50.979]         if (TRUE) {
[10:27:50.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:50.979]                 open = "w")
[10:27:50.979]         }
[10:27:50.979]         else {
[10:27:50.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:50.979]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:50.979]         }
[10:27:50.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:50.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:50.979]             base::sink(type = "output", split = FALSE)
[10:27:50.979]             base::close(...future.stdout)
[10:27:50.979]         }, add = TRUE)
[10:27:50.979]     }
[10:27:50.979]     ...future.frame <- base::sys.nframe()
[10:27:50.979]     ...future.conditions <- base::list()
[10:27:50.979]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:50.979]     if (FALSE) {
[10:27:50.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:50.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:50.979]     }
[10:27:50.979]     ...future.result <- base::tryCatch({
[10:27:50.979]         base::withCallingHandlers({
[10:27:50.979]             ...future.value <- base::withVisible(base::local(print(42)))
[10:27:50.979]             future::FutureResult(value = ...future.value$value, 
[10:27:50.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.979]                   ...future.rng), globalenv = if (FALSE) 
[10:27:50.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:50.979]                     ...future.globalenv.names))
[10:27:50.979]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:50.979]         }, condition = base::local({
[10:27:50.979]             c <- base::c
[10:27:50.979]             inherits <- base::inherits
[10:27:50.979]             invokeRestart <- base::invokeRestart
[10:27:50.979]             length <- base::length
[10:27:50.979]             list <- base::list
[10:27:50.979]             seq.int <- base::seq.int
[10:27:50.979]             signalCondition <- base::signalCondition
[10:27:50.979]             sys.calls <- base::sys.calls
[10:27:50.979]             `[[` <- base::`[[`
[10:27:50.979]             `+` <- base::`+`
[10:27:50.979]             `<<-` <- base::`<<-`
[10:27:50.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:50.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:50.979]                   3L)]
[10:27:50.979]             }
[10:27:50.979]             function(cond) {
[10:27:50.979]                 is_error <- inherits(cond, "error")
[10:27:50.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:50.979]                   NULL)
[10:27:50.979]                 if (is_error) {
[10:27:50.979]                   sessionInformation <- function() {
[10:27:50.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:50.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:50.979]                       search = base::search(), system = base::Sys.info())
[10:27:50.979]                   }
[10:27:50.979]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:50.979]                     cond$call), session = sessionInformation(), 
[10:27:50.979]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:50.979]                   signalCondition(cond)
[10:27:50.979]                 }
[10:27:50.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:50.979]                 "immediateCondition"))) {
[10:27:50.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:50.979]                   ...future.conditions[[length(...future.conditions) + 
[10:27:50.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:50.979]                   if (TRUE && !signal) {
[10:27:50.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.979]                     {
[10:27:50.979]                       inherits <- base::inherits
[10:27:50.979]                       invokeRestart <- base::invokeRestart
[10:27:50.979]                       is.null <- base::is.null
[10:27:50.979]                       muffled <- FALSE
[10:27:50.979]                       if (inherits(cond, "message")) {
[10:27:50.979]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.979]                         if (muffled) 
[10:27:50.979]                           invokeRestart("muffleMessage")
[10:27:50.979]                       }
[10:27:50.979]                       else if (inherits(cond, "warning")) {
[10:27:50.979]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.979]                         if (muffled) 
[10:27:50.979]                           invokeRestart("muffleWarning")
[10:27:50.979]                       }
[10:27:50.979]                       else if (inherits(cond, "condition")) {
[10:27:50.979]                         if (!is.null(pattern)) {
[10:27:50.979]                           computeRestarts <- base::computeRestarts
[10:27:50.979]                           grepl <- base::grepl
[10:27:50.979]                           restarts <- computeRestarts(cond)
[10:27:50.979]                           for (restart in restarts) {
[10:27:50.979]                             name <- restart$name
[10:27:50.979]                             if (is.null(name)) 
[10:27:50.979]                               next
[10:27:50.979]                             if (!grepl(pattern, name)) 
[10:27:50.979]                               next
[10:27:50.979]                             invokeRestart(restart)
[10:27:50.979]                             muffled <- TRUE
[10:27:50.979]                             break
[10:27:50.979]                           }
[10:27:50.979]                         }
[10:27:50.979]                       }
[10:27:50.979]                       invisible(muffled)
[10:27:50.979]                     }
[10:27:50.979]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.979]                   }
[10:27:50.979]                 }
[10:27:50.979]                 else {
[10:27:50.979]                   if (TRUE) {
[10:27:50.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:50.979]                     {
[10:27:50.979]                       inherits <- base::inherits
[10:27:50.979]                       invokeRestart <- base::invokeRestart
[10:27:50.979]                       is.null <- base::is.null
[10:27:50.979]                       muffled <- FALSE
[10:27:50.979]                       if (inherits(cond, "message")) {
[10:27:50.979]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:50.979]                         if (muffled) 
[10:27:50.979]                           invokeRestart("muffleMessage")
[10:27:50.979]                       }
[10:27:50.979]                       else if (inherits(cond, "warning")) {
[10:27:50.979]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:50.979]                         if (muffled) 
[10:27:50.979]                           invokeRestart("muffleWarning")
[10:27:50.979]                       }
[10:27:50.979]                       else if (inherits(cond, "condition")) {
[10:27:50.979]                         if (!is.null(pattern)) {
[10:27:50.979]                           computeRestarts <- base::computeRestarts
[10:27:50.979]                           grepl <- base::grepl
[10:27:50.979]                           restarts <- computeRestarts(cond)
[10:27:50.979]                           for (restart in restarts) {
[10:27:50.979]                             name <- restart$name
[10:27:50.979]                             if (is.null(name)) 
[10:27:50.979]                               next
[10:27:50.979]                             if (!grepl(pattern, name)) 
[10:27:50.979]                               next
[10:27:50.979]                             invokeRestart(restart)
[10:27:50.979]                             muffled <- TRUE
[10:27:50.979]                             break
[10:27:50.979]                           }
[10:27:50.979]                         }
[10:27:50.979]                       }
[10:27:50.979]                       invisible(muffled)
[10:27:50.979]                     }
[10:27:50.979]                     muffleCondition(cond, pattern = "^muffle")
[10:27:50.979]                   }
[10:27:50.979]                 }
[10:27:50.979]             }
[10:27:50.979]         }))
[10:27:50.979]     }, error = function(ex) {
[10:27:50.979]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:50.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:50.979]                 ...future.rng), started = ...future.startTime, 
[10:27:50.979]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:50.979]             version = "1.8"), class = "FutureResult")
[10:27:50.979]     }, finally = {
[10:27:50.979]         if (!identical(...future.workdir, getwd())) 
[10:27:50.979]             setwd(...future.workdir)
[10:27:50.979]         {
[10:27:50.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:50.979]                 ...future.oldOptions$nwarnings <- NULL
[10:27:50.979]             }
[10:27:50.979]             base::options(...future.oldOptions)
[10:27:50.979]             if (.Platform$OS.type == "windows") {
[10:27:50.979]                 old_names <- names(...future.oldEnvVars)
[10:27:50.979]                 envs <- base::Sys.getenv()
[10:27:50.979]                 names <- names(envs)
[10:27:50.979]                 common <- intersect(names, old_names)
[10:27:50.979]                 added <- setdiff(names, old_names)
[10:27:50.979]                 removed <- setdiff(old_names, names)
[10:27:50.979]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:50.979]                   envs[common]]
[10:27:50.979]                 NAMES <- toupper(changed)
[10:27:50.979]                 args <- list()
[10:27:50.979]                 for (kk in seq_along(NAMES)) {
[10:27:50.979]                   name <- changed[[kk]]
[10:27:50.979]                   NAME <- NAMES[[kk]]
[10:27:50.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.979]                     next
[10:27:50.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.979]                 }
[10:27:50.979]                 NAMES <- toupper(added)
[10:27:50.979]                 for (kk in seq_along(NAMES)) {
[10:27:50.979]                   name <- added[[kk]]
[10:27:50.979]                   NAME <- NAMES[[kk]]
[10:27:50.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.979]                     next
[10:27:50.979]                   args[[name]] <- ""
[10:27:50.979]                 }
[10:27:50.979]                 NAMES <- toupper(removed)
[10:27:50.979]                 for (kk in seq_along(NAMES)) {
[10:27:50.979]                   name <- removed[[kk]]
[10:27:50.979]                   NAME <- NAMES[[kk]]
[10:27:50.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:50.979]                     next
[10:27:50.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:50.979]                 }
[10:27:50.979]                 if (length(args) > 0) 
[10:27:50.979]                   base::do.call(base::Sys.setenv, args = args)
[10:27:50.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:50.979]             }
[10:27:50.979]             else {
[10:27:50.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:50.979]             }
[10:27:50.979]             {
[10:27:50.979]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:50.979]                   0L) {
[10:27:50.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:50.979]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:50.979]                   base::options(opts)
[10:27:50.979]                 }
[10:27:50.979]                 {
[10:27:50.979]                   {
[10:27:50.979]                     NULL
[10:27:50.979]                     RNGkind("Mersenne-Twister")
[10:27:50.979]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:50.979]                       inherits = FALSE)
[10:27:50.979]                   }
[10:27:50.979]                   options(future.plan = NULL)
[10:27:50.979]                   if (is.na(NA_character_)) 
[10:27:50.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:50.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:50.979]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:50.979]                   {
[10:27:50.979]                     future <- SequentialFuture(..., envir = envir)
[10:27:50.979]                     if (!future$lazy) 
[10:27:50.979]                       future <- run(future)
[10:27:50.979]                     invisible(future)
[10:27:50.979]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:50.979]                 }
[10:27:50.979]             }
[10:27:50.979]         }
[10:27:50.979]     })
[10:27:50.979]     if (TRUE) {
[10:27:50.979]         base::sink(type = "output", split = FALSE)
[10:27:50.979]         if (TRUE) {
[10:27:50.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:50.979]         }
[10:27:50.979]         else {
[10:27:50.979]             ...future.result["stdout"] <- base::list(NULL)
[10:27:50.979]         }
[10:27:50.979]         base::close(...future.stdout)
[10:27:50.979]         ...future.stdout <- NULL
[10:27:50.979]     }
[10:27:50.979]     ...future.result$conditions <- ...future.conditions
[10:27:50.979]     ...future.result$finished <- base::Sys.time()
[10:27:50.979]     ...future.result
[10:27:50.979] }
[10:27:50.981] plan(): Setting new future strategy stack:
[10:27:50.982] List of future strategies:
[10:27:50.982] 1. sequential:
[10:27:50.982]    - args: function (..., envir = parent.frame())
[10:27:50.982]    - tweaked: FALSE
[10:27:50.982]    - call: NULL
[10:27:50.982] plan(): nbrOfWorkers() = 1
[10:27:50.983] plan(): Setting new future strategy stack:
[10:27:50.983] List of future strategies:
[10:27:50.983] 1. sequential:
[10:27:50.983]    - args: function (..., envir = parent.frame())
[10:27:50.983]    - tweaked: FALSE
[10:27:50.983]    - call: plan(strategy)
[10:27:50.983] plan(): nbrOfWorkers() = 1
[10:27:50.983] SequentialFuture started (and completed)
[10:27:50.983] - Launch lazy future ... done
[10:27:50.984] run() for ‘SequentialFuture’ ... done
[1] 42
sequential ... done
Testing with 1 cores ... done
Testing with 2 cores ...
multicore ...
[10:27:50.991] plan(): Setting new future strategy stack:
[10:27:50.991] List of future strategies:
[10:27:50.991] 1. multicore:
[10:27:50.991]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:50.991]    - tweaked: FALSE
[10:27:50.991]    - call: plan(strategy)
[10:27:50.995] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[10:27:50.996] getGlobalsAndPackages() ...
[10:27:50.996] Searching for globals...
[10:27:50.999] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:50.999] Searching for globals ... DONE
[10:27:50.999] Resolving globals: FALSE
[10:27:50.999] 
[10:27:51.000] - packages: [1] ‘utils’
[10:27:51.000] getGlobalsAndPackages() ... DONE
[10:27:51.000] run() for ‘Future’ ...
[10:27:51.000] - state: ‘created’
[10:27:51.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:51.004] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:51.004] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:51.004]   - Field: ‘label’
[10:27:51.004]   - Field: ‘local’
[10:27:51.004]   - Field: ‘owner’
[10:27:51.004]   - Field: ‘envir’
[10:27:51.004]   - Field: ‘workers’
[10:27:51.005]   - Field: ‘packages’
[10:27:51.005]   - Field: ‘gc’
[10:27:51.005]   - Field: ‘job’
[10:27:51.005]   - Field: ‘conditions’
[10:27:51.005]   - Field: ‘expr’
[10:27:51.005]   - Field: ‘uuid’
[10:27:51.005]   - Field: ‘seed’
[10:27:51.005]   - Field: ‘version’
[10:27:51.005]   - Field: ‘result’
[10:27:51.005]   - Field: ‘asynchronous’
[10:27:51.006]   - Field: ‘calls’
[10:27:51.006]   - Field: ‘globals’
[10:27:51.006]   - Field: ‘stdout’
[10:27:51.006]   - Field: ‘earlySignal’
[10:27:51.006]   - Field: ‘lazy’
[10:27:51.006]   - Field: ‘state’
[10:27:51.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:51.006] - Launch lazy future ...
[10:27:51.007] Packages needed by the future expression (n = 1): ‘utils’
[10:27:51.007] Packages needed by future strategies (n = 0): <none>
[10:27:51.008] {
[10:27:51.008]     {
[10:27:51.008]         {
[10:27:51.008]             ...future.startTime <- base::Sys.time()
[10:27:51.008]             {
[10:27:51.008]                 {
[10:27:51.008]                   {
[10:27:51.008]                     {
[10:27:51.008]                       {
[10:27:51.008]                         base::local({
[10:27:51.008]                           has_future <- base::requireNamespace("future", 
[10:27:51.008]                             quietly = TRUE)
[10:27:51.008]                           if (has_future) {
[10:27:51.008]                             ns <- base::getNamespace("future")
[10:27:51.008]                             version <- ns[[".package"]][["version"]]
[10:27:51.008]                             if (is.null(version)) 
[10:27:51.008]                               version <- utils::packageVersion("future")
[10:27:51.008]                           }
[10:27:51.008]                           else {
[10:27:51.008]                             version <- NULL
[10:27:51.008]                           }
[10:27:51.008]                           if (!has_future || version < "1.8.0") {
[10:27:51.008]                             info <- base::c(r_version = base::gsub("R version ", 
[10:27:51.008]                               "", base::R.version$version.string), 
[10:27:51.008]                               platform = base::sprintf("%s (%s-bit)", 
[10:27:51.008]                                 base::R.version$platform, 8 * 
[10:27:51.008]                                   base::.Machine$sizeof.pointer), 
[10:27:51.008]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:51.008]                                 "release", "version")], collapse = " "), 
[10:27:51.008]                               hostname = base::Sys.info()[["nodename"]])
[10:27:51.008]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:27:51.008]                               info)
[10:27:51.008]                             info <- base::paste(info, collapse = "; ")
[10:27:51.008]                             if (!has_future) {
[10:27:51.008]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:51.008]                                 info)
[10:27:51.008]                             }
[10:27:51.008]                             else {
[10:27:51.008]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:51.008]                                 info, version)
[10:27:51.008]                             }
[10:27:51.008]                             base::stop(msg)
[10:27:51.008]                           }
[10:27:51.008]                         })
[10:27:51.008]                       }
[10:27:51.008]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:51.008]                       base::options(mc.cores = 1L)
[10:27:51.008]                     }
[10:27:51.008]                     base::local({
[10:27:51.008]                       for (pkg in "utils") {
[10:27:51.008]                         base::loadNamespace(pkg)
[10:27:51.008]                         base::library(pkg, character.only = TRUE)
[10:27:51.008]                       }
[10:27:51.008]                     })
[10:27:51.008]                   }
[10:27:51.008]                   options(future.plan = NULL)
[10:27:51.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:51.008]                 }
[10:27:51.008]                 ...future.workdir <- getwd()
[10:27:51.008]             }
[10:27:51.008]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:51.008]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:51.008]         }
[10:27:51.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:51.008]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:51.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:51.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:51.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:51.008]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:51.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:51.008]             base::names(...future.oldOptions))
[10:27:51.008]     }
[10:27:51.008]     if (FALSE) {
[10:27:51.008]     }
[10:27:51.008]     else {
[10:27:51.008]         if (TRUE) {
[10:27:51.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:51.008]                 open = "w")
[10:27:51.008]         }
[10:27:51.008]         else {
[10:27:51.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:51.008]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:51.008]         }
[10:27:51.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:51.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:51.008]             base::sink(type = "output", split = FALSE)
[10:27:51.008]             base::close(...future.stdout)
[10:27:51.008]         }, add = TRUE)
[10:27:51.008]     }
[10:27:51.008]     ...future.frame <- base::sys.nframe()
[10:27:51.008]     ...future.conditions <- base::list()
[10:27:51.008]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:51.008]     if (FALSE) {
[10:27:51.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:51.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:51.008]     }
[10:27:51.008]     ...future.result <- base::tryCatch({
[10:27:51.008]         base::withCallingHandlers({
[10:27:51.008]             ...future.value <- base::withVisible(base::local({
[10:27:51.008]                 withCallingHandlers({
[10:27:51.008]                   {
[10:27:51.008]                     print(1:50)
[10:27:51.008]                     str(1:50)
[10:27:51.008]                     cat(letters, sep = "-")
[10:27:51.008]                     cat(1:6, collapse = "\n")
[10:27:51.008]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:51.008]                     42L
[10:27:51.008]                   }
[10:27:51.008]                 }, immediateCondition = function(cond) {
[10:27:51.008]                   save_rds <- function (object, pathname, ...) 
[10:27:51.008]                   {
[10:27:51.008]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:51.008]                     if (file_test("-f", pathname_tmp)) {
[10:27:51.008]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.008]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:51.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.008]                         fi_tmp[["mtime"]])
[10:27:51.008]                     }
[10:27:51.008]                     tryCatch({
[10:27:51.008]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:51.008]                     }, error = function(ex) {
[10:27:51.008]                       msg <- conditionMessage(ex)
[10:27:51.008]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.008]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:51.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.008]                         fi_tmp[["mtime"]], msg)
[10:27:51.008]                       ex$message <- msg
[10:27:51.008]                       stop(ex)
[10:27:51.008]                     })
[10:27:51.008]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:51.008]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:51.008]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:51.008]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.008]                       fi <- file.info(pathname)
[10:27:51.008]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:51.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.008]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:51.008]                         fi[["size"]], fi[["mtime"]])
[10:27:51.008]                       stop(msg)
[10:27:51.008]                     }
[10:27:51.008]                     invisible(pathname)
[10:27:51.008]                   }
[10:27:51.008]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:51.008]                     rootPath = tempdir()) 
[10:27:51.008]                   {
[10:27:51.008]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:51.008]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:51.008]                       tmpdir = path, fileext = ".rds")
[10:27:51.008]                     save_rds(obj, file)
[10:27:51.008]                   }
[10:27:51.008]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3JSlqb/.future/immediateConditions")
[10:27:51.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.008]                   {
[10:27:51.008]                     inherits <- base::inherits
[10:27:51.008]                     invokeRestart <- base::invokeRestart
[10:27:51.008]                     is.null <- base::is.null
[10:27:51.008]                     muffled <- FALSE
[10:27:51.008]                     if (inherits(cond, "message")) {
[10:27:51.008]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:51.008]                       if (muffled) 
[10:27:51.008]                         invokeRestart("muffleMessage")
[10:27:51.008]                     }
[10:27:51.008]                     else if (inherits(cond, "warning")) {
[10:27:51.008]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:51.008]                       if (muffled) 
[10:27:51.008]                         invokeRestart("muffleWarning")
[10:27:51.008]                     }
[10:27:51.008]                     else if (inherits(cond, "condition")) {
[10:27:51.008]                       if (!is.null(pattern)) {
[10:27:51.008]                         computeRestarts <- base::computeRestarts
[10:27:51.008]                         grepl <- base::grepl
[10:27:51.008]                         restarts <- computeRestarts(cond)
[10:27:51.008]                         for (restart in restarts) {
[10:27:51.008]                           name <- restart$name
[10:27:51.008]                           if (is.null(name)) 
[10:27:51.008]                             next
[10:27:51.008]                           if (!grepl(pattern, name)) 
[10:27:51.008]                             next
[10:27:51.008]                           invokeRestart(restart)
[10:27:51.008]                           muffled <- TRUE
[10:27:51.008]                           break
[10:27:51.008]                         }
[10:27:51.008]                       }
[10:27:51.008]                     }
[10:27:51.008]                     invisible(muffled)
[10:27:51.008]                   }
[10:27:51.008]                   muffleCondition(cond)
[10:27:51.008]                 })
[10:27:51.008]             }))
[10:27:51.008]             future::FutureResult(value = ...future.value$value, 
[10:27:51.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.008]                   ...future.rng), globalenv = if (FALSE) 
[10:27:51.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:51.008]                     ...future.globalenv.names))
[10:27:51.008]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:51.008]         }, condition = base::local({
[10:27:51.008]             c <- base::c
[10:27:51.008]             inherits <- base::inherits
[10:27:51.008]             invokeRestart <- base::invokeRestart
[10:27:51.008]             length <- base::length
[10:27:51.008]             list <- base::list
[10:27:51.008]             seq.int <- base::seq.int
[10:27:51.008]             signalCondition <- base::signalCondition
[10:27:51.008]             sys.calls <- base::sys.calls
[10:27:51.008]             `[[` <- base::`[[`
[10:27:51.008]             `+` <- base::`+`
[10:27:51.008]             `<<-` <- base::`<<-`
[10:27:51.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:51.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:51.008]                   3L)]
[10:27:51.008]             }
[10:27:51.008]             function(cond) {
[10:27:51.008]                 is_error <- inherits(cond, "error")
[10:27:51.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:51.008]                   NULL)
[10:27:51.008]                 if (is_error) {
[10:27:51.008]                   sessionInformation <- function() {
[10:27:51.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:51.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:51.008]                       search = base::search(), system = base::Sys.info())
[10:27:51.008]                   }
[10:27:51.008]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:51.008]                     cond$call), session = sessionInformation(), 
[10:27:51.008]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:51.008]                   signalCondition(cond)
[10:27:51.008]                 }
[10:27:51.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:51.008]                 "immediateCondition"))) {
[10:27:51.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:51.008]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:51.008]                   if (TRUE && !signal) {
[10:27:51.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.008]                     {
[10:27:51.008]                       inherits <- base::inherits
[10:27:51.008]                       invokeRestart <- base::invokeRestart
[10:27:51.008]                       is.null <- base::is.null
[10:27:51.008]                       muffled <- FALSE
[10:27:51.008]                       if (inherits(cond, "message")) {
[10:27:51.008]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.008]                         if (muffled) 
[10:27:51.008]                           invokeRestart("muffleMessage")
[10:27:51.008]                       }
[10:27:51.008]                       else if (inherits(cond, "warning")) {
[10:27:51.008]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.008]                         if (muffled) 
[10:27:51.008]                           invokeRestart("muffleWarning")
[10:27:51.008]                       }
[10:27:51.008]                       else if (inherits(cond, "condition")) {
[10:27:51.008]                         if (!is.null(pattern)) {
[10:27:51.008]                           computeRestarts <- base::computeRestarts
[10:27:51.008]                           grepl <- base::grepl
[10:27:51.008]                           restarts <- computeRestarts(cond)
[10:27:51.008]                           for (restart in restarts) {
[10:27:51.008]                             name <- restart$name
[10:27:51.008]                             if (is.null(name)) 
[10:27:51.008]                               next
[10:27:51.008]                             if (!grepl(pattern, name)) 
[10:27:51.008]                               next
[10:27:51.008]                             invokeRestart(restart)
[10:27:51.008]                             muffled <- TRUE
[10:27:51.008]                             break
[10:27:51.008]                           }
[10:27:51.008]                         }
[10:27:51.008]                       }
[10:27:51.008]                       invisible(muffled)
[10:27:51.008]                     }
[10:27:51.008]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.008]                   }
[10:27:51.008]                 }
[10:27:51.008]                 else {
[10:27:51.008]                   if (TRUE) {
[10:27:51.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.008]                     {
[10:27:51.008]                       inherits <- base::inherits
[10:27:51.008]                       invokeRestart <- base::invokeRestart
[10:27:51.008]                       is.null <- base::is.null
[10:27:51.008]                       muffled <- FALSE
[10:27:51.008]                       if (inherits(cond, "message")) {
[10:27:51.008]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.008]                         if (muffled) 
[10:27:51.008]                           invokeRestart("muffleMessage")
[10:27:51.008]                       }
[10:27:51.008]                       else if (inherits(cond, "warning")) {
[10:27:51.008]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.008]                         if (muffled) 
[10:27:51.008]                           invokeRestart("muffleWarning")
[10:27:51.008]                       }
[10:27:51.008]                       else if (inherits(cond, "condition")) {
[10:27:51.008]                         if (!is.null(pattern)) {
[10:27:51.008]                           computeRestarts <- base::computeRestarts
[10:27:51.008]                           grepl <- base::grepl
[10:27:51.008]                           restarts <- computeRestarts(cond)
[10:27:51.008]                           for (restart in restarts) {
[10:27:51.008]                             name <- restart$name
[10:27:51.008]                             if (is.null(name)) 
[10:27:51.008]                               next
[10:27:51.008]                             if (!grepl(pattern, name)) 
[10:27:51.008]                               next
[10:27:51.008]                             invokeRestart(restart)
[10:27:51.008]                             muffled <- TRUE
[10:27:51.008]                             break
[10:27:51.008]                           }
[10:27:51.008]                         }
[10:27:51.008]                       }
[10:27:51.008]                       invisible(muffled)
[10:27:51.008]                     }
[10:27:51.008]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.008]                   }
[10:27:51.008]                 }
[10:27:51.008]             }
[10:27:51.008]         }))
[10:27:51.008]     }, error = function(ex) {
[10:27:51.008]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:51.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.008]                 ...future.rng), started = ...future.startTime, 
[10:27:51.008]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:51.008]             version = "1.8"), class = "FutureResult")
[10:27:51.008]     }, finally = {
[10:27:51.008]         if (!identical(...future.workdir, getwd())) 
[10:27:51.008]             setwd(...future.workdir)
[10:27:51.008]         {
[10:27:51.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:51.008]                 ...future.oldOptions$nwarnings <- NULL
[10:27:51.008]             }
[10:27:51.008]             base::options(...future.oldOptions)
[10:27:51.008]             if (.Platform$OS.type == "windows") {
[10:27:51.008]                 old_names <- names(...future.oldEnvVars)
[10:27:51.008]                 envs <- base::Sys.getenv()
[10:27:51.008]                 names <- names(envs)
[10:27:51.008]                 common <- intersect(names, old_names)
[10:27:51.008]                 added <- setdiff(names, old_names)
[10:27:51.008]                 removed <- setdiff(old_names, names)
[10:27:51.008]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:51.008]                   envs[common]]
[10:27:51.008]                 NAMES <- toupper(changed)
[10:27:51.008]                 args <- list()
[10:27:51.008]                 for (kk in seq_along(NAMES)) {
[10:27:51.008]                   name <- changed[[kk]]
[10:27:51.008]                   NAME <- NAMES[[kk]]
[10:27:51.008]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.008]                     next
[10:27:51.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.008]                 }
[10:27:51.008]                 NAMES <- toupper(added)
[10:27:51.008]                 for (kk in seq_along(NAMES)) {
[10:27:51.008]                   name <- added[[kk]]
[10:27:51.008]                   NAME <- NAMES[[kk]]
[10:27:51.008]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.008]                     next
[10:27:51.008]                   args[[name]] <- ""
[10:27:51.008]                 }
[10:27:51.008]                 NAMES <- toupper(removed)
[10:27:51.008]                 for (kk in seq_along(NAMES)) {
[10:27:51.008]                   name <- removed[[kk]]
[10:27:51.008]                   NAME <- NAMES[[kk]]
[10:27:51.008]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.008]                     next
[10:27:51.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.008]                 }
[10:27:51.008]                 if (length(args) > 0) 
[10:27:51.008]                   base::do.call(base::Sys.setenv, args = args)
[10:27:51.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:51.008]             }
[10:27:51.008]             else {
[10:27:51.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:51.008]             }
[10:27:51.008]             {
[10:27:51.008]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:51.008]                   0L) {
[10:27:51.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:51.008]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:51.008]                   base::options(opts)
[10:27:51.008]                 }
[10:27:51.008]                 {
[10:27:51.008]                   {
[10:27:51.008]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:51.008]                     NULL
[10:27:51.008]                   }
[10:27:51.008]                   options(future.plan = NULL)
[10:27:51.008]                   if (is.na(NA_character_)) 
[10:27:51.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:51.008]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:51.008]                     envir = parent.frame()) 
[10:27:51.008]                   {
[10:27:51.008]                     default_workers <- missing(workers)
[10:27:51.008]                     if (is.function(workers)) 
[10:27:51.008]                       workers <- workers()
[10:27:51.008]                     workers <- structure(as.integer(workers), 
[10:27:51.008]                       class = class(workers))
[10:27:51.008]                     stop_if_not(is.finite(workers), workers >= 
[10:27:51.008]                       1L)
[10:27:51.008]                     if ((workers == 1L && !inherits(workers, 
[10:27:51.008]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:51.008]                       if (default_workers) 
[10:27:51.008]                         supportsMulticore(warn = TRUE)
[10:27:51.008]                       return(sequential(..., envir = envir))
[10:27:51.008]                     }
[10:27:51.008]                     oopts <- options(mc.cores = workers)
[10:27:51.008]                     on.exit(options(oopts))
[10:27:51.008]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:51.008]                       envir = envir)
[10:27:51.008]                     if (!future$lazy) 
[10:27:51.008]                       future <- run(future)
[10:27:51.008]                     invisible(future)
[10:27:51.008]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:51.008]                 }
[10:27:51.008]             }
[10:27:51.008]         }
[10:27:51.008]     })
[10:27:51.008]     if (TRUE) {
[10:27:51.008]         base::sink(type = "output", split = FALSE)
[10:27:51.008]         if (TRUE) {
[10:27:51.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:51.008]         }
[10:27:51.008]         else {
[10:27:51.008]             ...future.result["stdout"] <- base::list(NULL)
[10:27:51.008]         }
[10:27:51.008]         base::close(...future.stdout)
[10:27:51.008]         ...future.stdout <- NULL
[10:27:51.008]     }
[10:27:51.008]     ...future.result$conditions <- ...future.conditions
[10:27:51.008]     ...future.result$finished <- base::Sys.time()
[10:27:51.008]     ...future.result
[10:27:51.008] }
[10:27:51.010] requestCore(): workers = 2
[10:27:51.013] MulticoreFuture started
[10:27:51.014] - Launch lazy future ... done
[10:27:51.014] run() for ‘MulticoreFuture’ ... done
[10:27:51.014] plan(): Setting new future strategy stack:
[10:27:51.015] result() for MulticoreFuture ...
[10:27:51.015] List of future strategies:
[10:27:51.015] 1. sequential:
[10:27:51.015]    - args: function (..., envir = parent.frame())
[10:27:51.015]    - tweaked: FALSE
[10:27:51.015]    - call: NULL
[10:27:51.016] plan(): nbrOfWorkers() = 1
[10:27:51.019] plan(): Setting new future strategy stack:
[10:27:51.019] List of future strategies:
[10:27:51.019] 1. multicore:
[10:27:51.019]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:51.019]    - tweaked: FALSE
[10:27:51.019]    - call: plan(strategy)
[10:27:51.024] plan(): nbrOfWorkers() = 2
[10:27:51.029] result() for MulticoreFuture ...
[10:27:51.029] result() for MulticoreFuture ... done
[10:27:51.029] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 10:27:51"
 $ finished    : POSIXct[1:1], format: "2025-01-07 10:27:51"
 $ session_uuid: chr "09b87d6e-8c1e-1f48-116f-de648d7afcc4"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3e863ac79bce"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92673
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 10:27:51"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:27:51.042] result() for MulticoreFuture ...
[10:27:51.042] result() for MulticoreFuture ... done
[10:27:51.042] result() for MulticoreFuture ...
[10:27:51.042] result() for MulticoreFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.01105285 secs (started 2025-01-07 10:27:51.013958)
version: 1.8
[10:27:51.043] getGlobalsAndPackages() ...
[10:27:51.043] Searching for globals...
[10:27:51.047] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:51.047] Searching for globals ... DONE
[10:27:51.047] Resolving globals: FALSE
[10:27:51.048] 
[10:27:51.048] - packages: [1] ‘utils’
[10:27:51.048] getGlobalsAndPackages() ... DONE
[10:27:51.048] run() for ‘Future’ ...
[10:27:51.049] - state: ‘created’
[10:27:51.049] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:51.053] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:51.053] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:51.054]   - Field: ‘label’
[10:27:51.054]   - Field: ‘local’
[10:27:51.054]   - Field: ‘owner’
[10:27:51.054]   - Field: ‘envir’
[10:27:51.054]   - Field: ‘workers’
[10:27:51.054]   - Field: ‘packages’
[10:27:51.054]   - Field: ‘gc’
[10:27:51.055]   - Field: ‘job’
[10:27:51.055]   - Field: ‘conditions’
[10:27:51.055]   - Field: ‘expr’
[10:27:51.055]   - Field: ‘uuid’
[10:27:51.055]   - Field: ‘seed’
[10:27:51.055]   - Field: ‘version’
[10:27:51.055]   - Field: ‘result’
[10:27:51.055]   - Field: ‘asynchronous’
[10:27:51.055]   - Field: ‘calls’
[10:27:51.056]   - Field: ‘globals’
[10:27:51.056]   - Field: ‘stdout’
[10:27:51.056]   - Field: ‘earlySignal’
[10:27:51.056]   - Field: ‘lazy’
[10:27:51.056]   - Field: ‘state’
[10:27:51.056] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:51.056] - Launch lazy future ...
[10:27:51.057] Packages needed by the future expression (n = 1): ‘utils’
[10:27:51.057] Packages needed by future strategies (n = 0): <none>
[10:27:51.057] {
[10:27:51.057]     {
[10:27:51.057]         {
[10:27:51.057]             ...future.startTime <- base::Sys.time()
[10:27:51.057]             {
[10:27:51.057]                 {
[10:27:51.057]                   {
[10:27:51.057]                     {
[10:27:51.057]                       {
[10:27:51.057]                         base::local({
[10:27:51.057]                           has_future <- base::requireNamespace("future", 
[10:27:51.057]                             quietly = TRUE)
[10:27:51.057]                           if (has_future) {
[10:27:51.057]                             ns <- base::getNamespace("future")
[10:27:51.057]                             version <- ns[[".package"]][["version"]]
[10:27:51.057]                             if (is.null(version)) 
[10:27:51.057]                               version <- utils::packageVersion("future")
[10:27:51.057]                           }
[10:27:51.057]                           else {
[10:27:51.057]                             version <- NULL
[10:27:51.057]                           }
[10:27:51.057]                           if (!has_future || version < "1.8.0") {
[10:27:51.057]                             info <- base::c(r_version = base::gsub("R version ", 
[10:27:51.057]                               "", base::R.version$version.string), 
[10:27:51.057]                               platform = base::sprintf("%s (%s-bit)", 
[10:27:51.057]                                 base::R.version$platform, 8 * 
[10:27:51.057]                                   base::.Machine$sizeof.pointer), 
[10:27:51.057]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:51.057]                                 "release", "version")], collapse = " "), 
[10:27:51.057]                               hostname = base::Sys.info()[["nodename"]])
[10:27:51.057]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:27:51.057]                               info)
[10:27:51.057]                             info <- base::paste(info, collapse = "; ")
[10:27:51.057]                             if (!has_future) {
[10:27:51.057]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:51.057]                                 info)
[10:27:51.057]                             }
[10:27:51.057]                             else {
[10:27:51.057]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:51.057]                                 info, version)
[10:27:51.057]                             }
[10:27:51.057]                             base::stop(msg)
[10:27:51.057]                           }
[10:27:51.057]                         })
[10:27:51.057]                       }
[10:27:51.057]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:51.057]                       base::options(mc.cores = 1L)
[10:27:51.057]                     }
[10:27:51.057]                     base::local({
[10:27:51.057]                       for (pkg in "utils") {
[10:27:51.057]                         base::loadNamespace(pkg)
[10:27:51.057]                         base::library(pkg, character.only = TRUE)
[10:27:51.057]                       }
[10:27:51.057]                     })
[10:27:51.057]                   }
[10:27:51.057]                   options(future.plan = NULL)
[10:27:51.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:51.057]                 }
[10:27:51.057]                 ...future.workdir <- getwd()
[10:27:51.057]             }
[10:27:51.057]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:51.057]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:51.057]         }
[10:27:51.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:51.057]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:51.057]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:51.057]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:51.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:51.057]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:51.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:51.057]             base::names(...future.oldOptions))
[10:27:51.057]     }
[10:27:51.057]     if (FALSE) {
[10:27:51.057]     }
[10:27:51.057]     else {
[10:27:51.057]         if (TRUE) {
[10:27:51.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:51.057]                 open = "w")
[10:27:51.057]         }
[10:27:51.057]         else {
[10:27:51.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:51.057]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:51.057]         }
[10:27:51.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:51.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:51.057]             base::sink(type = "output", split = FALSE)
[10:27:51.057]             base::close(...future.stdout)
[10:27:51.057]         }, add = TRUE)
[10:27:51.057]     }
[10:27:51.057]     ...future.frame <- base::sys.nframe()
[10:27:51.057]     ...future.conditions <- base::list()
[10:27:51.057]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:51.057]     if (FALSE) {
[10:27:51.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:51.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:51.057]     }
[10:27:51.057]     ...future.result <- base::tryCatch({
[10:27:51.057]         base::withCallingHandlers({
[10:27:51.057]             ...future.value <- base::withVisible(base::local({
[10:27:51.057]                 withCallingHandlers({
[10:27:51.057]                   {
[10:27:51.057]                     print(1:50)
[10:27:51.057]                     str(1:50)
[10:27:51.057]                     cat(letters, sep = "-")
[10:27:51.057]                     cat(1:6, collapse = "\n")
[10:27:51.057]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:51.057]                     42L
[10:27:51.057]                   }
[10:27:51.057]                 }, immediateCondition = function(cond) {
[10:27:51.057]                   save_rds <- function (object, pathname, ...) 
[10:27:51.057]                   {
[10:27:51.057]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:51.057]                     if (file_test("-f", pathname_tmp)) {
[10:27:51.057]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.057]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:51.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.057]                         fi_tmp[["mtime"]])
[10:27:51.057]                     }
[10:27:51.057]                     tryCatch({
[10:27:51.057]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:51.057]                     }, error = function(ex) {
[10:27:51.057]                       msg <- conditionMessage(ex)
[10:27:51.057]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.057]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:51.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.057]                         fi_tmp[["mtime"]], msg)
[10:27:51.057]                       ex$message <- msg
[10:27:51.057]                       stop(ex)
[10:27:51.057]                     })
[10:27:51.057]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:51.057]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:51.057]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:51.057]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.057]                       fi <- file.info(pathname)
[10:27:51.057]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:51.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.057]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:51.057]                         fi[["size"]], fi[["mtime"]])
[10:27:51.057]                       stop(msg)
[10:27:51.057]                     }
[10:27:51.057]                     invisible(pathname)
[10:27:51.057]                   }
[10:27:51.057]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:51.057]                     rootPath = tempdir()) 
[10:27:51.057]                   {
[10:27:51.057]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:51.057]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:51.057]                       tmpdir = path, fileext = ".rds")
[10:27:51.057]                     save_rds(obj, file)
[10:27:51.057]                   }
[10:27:51.057]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3JSlqb/.future/immediateConditions")
[10:27:51.057]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.057]                   {
[10:27:51.057]                     inherits <- base::inherits
[10:27:51.057]                     invokeRestart <- base::invokeRestart
[10:27:51.057]                     is.null <- base::is.null
[10:27:51.057]                     muffled <- FALSE
[10:27:51.057]                     if (inherits(cond, "message")) {
[10:27:51.057]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:51.057]                       if (muffled) 
[10:27:51.057]                         invokeRestart("muffleMessage")
[10:27:51.057]                     }
[10:27:51.057]                     else if (inherits(cond, "warning")) {
[10:27:51.057]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:51.057]                       if (muffled) 
[10:27:51.057]                         invokeRestart("muffleWarning")
[10:27:51.057]                     }
[10:27:51.057]                     else if (inherits(cond, "condition")) {
[10:27:51.057]                       if (!is.null(pattern)) {
[10:27:51.057]                         computeRestarts <- base::computeRestarts
[10:27:51.057]                         grepl <- base::grepl
[10:27:51.057]                         restarts <- computeRestarts(cond)
[10:27:51.057]                         for (restart in restarts) {
[10:27:51.057]                           name <- restart$name
[10:27:51.057]                           if (is.null(name)) 
[10:27:51.057]                             next
[10:27:51.057]                           if (!grepl(pattern, name)) 
[10:27:51.057]                             next
[10:27:51.057]                           invokeRestart(restart)
[10:27:51.057]                           muffled <- TRUE
[10:27:51.057]                           break
[10:27:51.057]                         }
[10:27:51.057]                       }
[10:27:51.057]                     }
[10:27:51.057]                     invisible(muffled)
[10:27:51.057]                   }
[10:27:51.057]                   muffleCondition(cond)
[10:27:51.057]                 })
[10:27:51.057]             }))
[10:27:51.057]             future::FutureResult(value = ...future.value$value, 
[10:27:51.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.057]                   ...future.rng), globalenv = if (FALSE) 
[10:27:51.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:51.057]                     ...future.globalenv.names))
[10:27:51.057]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:51.057]         }, condition = base::local({
[10:27:51.057]             c <- base::c
[10:27:51.057]             inherits <- base::inherits
[10:27:51.057]             invokeRestart <- base::invokeRestart
[10:27:51.057]             length <- base::length
[10:27:51.057]             list <- base::list
[10:27:51.057]             seq.int <- base::seq.int
[10:27:51.057]             signalCondition <- base::signalCondition
[10:27:51.057]             sys.calls <- base::sys.calls
[10:27:51.057]             `[[` <- base::`[[`
[10:27:51.057]             `+` <- base::`+`
[10:27:51.057]             `<<-` <- base::`<<-`
[10:27:51.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:51.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:51.057]                   3L)]
[10:27:51.057]             }
[10:27:51.057]             function(cond) {
[10:27:51.057]                 is_error <- inherits(cond, "error")
[10:27:51.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:51.057]                   NULL)
[10:27:51.057]                 if (is_error) {
[10:27:51.057]                   sessionInformation <- function() {
[10:27:51.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:51.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:51.057]                       search = base::search(), system = base::Sys.info())
[10:27:51.057]                   }
[10:27:51.057]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:51.057]                     cond$call), session = sessionInformation(), 
[10:27:51.057]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:51.057]                   signalCondition(cond)
[10:27:51.057]                 }
[10:27:51.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:51.057]                 "immediateCondition"))) {
[10:27:51.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:51.057]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:51.057]                   if (TRUE && !signal) {
[10:27:51.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.057]                     {
[10:27:51.057]                       inherits <- base::inherits
[10:27:51.057]                       invokeRestart <- base::invokeRestart
[10:27:51.057]                       is.null <- base::is.null
[10:27:51.057]                       muffled <- FALSE
[10:27:51.057]                       if (inherits(cond, "message")) {
[10:27:51.057]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.057]                         if (muffled) 
[10:27:51.057]                           invokeRestart("muffleMessage")
[10:27:51.057]                       }
[10:27:51.057]                       else if (inherits(cond, "warning")) {
[10:27:51.057]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.057]                         if (muffled) 
[10:27:51.057]                           invokeRestart("muffleWarning")
[10:27:51.057]                       }
[10:27:51.057]                       else if (inherits(cond, "condition")) {
[10:27:51.057]                         if (!is.null(pattern)) {
[10:27:51.057]                           computeRestarts <- base::computeRestarts
[10:27:51.057]                           grepl <- base::grepl
[10:27:51.057]                           restarts <- computeRestarts(cond)
[10:27:51.057]                           for (restart in restarts) {
[10:27:51.057]                             name <- restart$name
[10:27:51.057]                             if (is.null(name)) 
[10:27:51.057]                               next
[10:27:51.057]                             if (!grepl(pattern, name)) 
[10:27:51.057]                               next
[10:27:51.057]                             invokeRestart(restart)
[10:27:51.057]                             muffled <- TRUE
[10:27:51.057]                             break
[10:27:51.057]                           }
[10:27:51.057]                         }
[10:27:51.057]                       }
[10:27:51.057]                       invisible(muffled)
[10:27:51.057]                     }
[10:27:51.057]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.057]                   }
[10:27:51.057]                 }
[10:27:51.057]                 else {
[10:27:51.057]                   if (TRUE) {
[10:27:51.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.057]                     {
[10:27:51.057]                       inherits <- base::inherits
[10:27:51.057]                       invokeRestart <- base::invokeRestart
[10:27:51.057]                       is.null <- base::is.null
[10:27:51.057]                       muffled <- FALSE
[10:27:51.057]                       if (inherits(cond, "message")) {
[10:27:51.057]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.057]                         if (muffled) 
[10:27:51.057]                           invokeRestart("muffleMessage")
[10:27:51.057]                       }
[10:27:51.057]                       else if (inherits(cond, "warning")) {
[10:27:51.057]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.057]                         if (muffled) 
[10:27:51.057]                           invokeRestart("muffleWarning")
[10:27:51.057]                       }
[10:27:51.057]                       else if (inherits(cond, "condition")) {
[10:27:51.057]                         if (!is.null(pattern)) {
[10:27:51.057]                           computeRestarts <- base::computeRestarts
[10:27:51.057]                           grepl <- base::grepl
[10:27:51.057]                           restarts <- computeRestarts(cond)
[10:27:51.057]                           for (restart in restarts) {
[10:27:51.057]                             name <- restart$name
[10:27:51.057]                             if (is.null(name)) 
[10:27:51.057]                               next
[10:27:51.057]                             if (!grepl(pattern, name)) 
[10:27:51.057]                               next
[10:27:51.057]                             invokeRestart(restart)
[10:27:51.057]                             muffled <- TRUE
[10:27:51.057]                             break
[10:27:51.057]                           }
[10:27:51.057]                         }
[10:27:51.057]                       }
[10:27:51.057]                       invisible(muffled)
[10:27:51.057]                     }
[10:27:51.057]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.057]                   }
[10:27:51.057]                 }
[10:27:51.057]             }
[10:27:51.057]         }))
[10:27:51.057]     }, error = function(ex) {
[10:27:51.057]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:51.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.057]                 ...future.rng), started = ...future.startTime, 
[10:27:51.057]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:51.057]             version = "1.8"), class = "FutureResult")
[10:27:51.057]     }, finally = {
[10:27:51.057]         if (!identical(...future.workdir, getwd())) 
[10:27:51.057]             setwd(...future.workdir)
[10:27:51.057]         {
[10:27:51.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:51.057]                 ...future.oldOptions$nwarnings <- NULL
[10:27:51.057]             }
[10:27:51.057]             base::options(...future.oldOptions)
[10:27:51.057]             if (.Platform$OS.type == "windows") {
[10:27:51.057]                 old_names <- names(...future.oldEnvVars)
[10:27:51.057]                 envs <- base::Sys.getenv()
[10:27:51.057]                 names <- names(envs)
[10:27:51.057]                 common <- intersect(names, old_names)
[10:27:51.057]                 added <- setdiff(names, old_names)
[10:27:51.057]                 removed <- setdiff(old_names, names)
[10:27:51.057]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:51.057]                   envs[common]]
[10:27:51.057]                 NAMES <- toupper(changed)
[10:27:51.057]                 args <- list()
[10:27:51.057]                 for (kk in seq_along(NAMES)) {
[10:27:51.057]                   name <- changed[[kk]]
[10:27:51.057]                   NAME <- NAMES[[kk]]
[10:27:51.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.057]                     next
[10:27:51.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.057]                 }
[10:27:51.057]                 NAMES <- toupper(added)
[10:27:51.057]                 for (kk in seq_along(NAMES)) {
[10:27:51.057]                   name <- added[[kk]]
[10:27:51.057]                   NAME <- NAMES[[kk]]
[10:27:51.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.057]                     next
[10:27:51.057]                   args[[name]] <- ""
[10:27:51.057]                 }
[10:27:51.057]                 NAMES <- toupper(removed)
[10:27:51.057]                 for (kk in seq_along(NAMES)) {
[10:27:51.057]                   name <- removed[[kk]]
[10:27:51.057]                   NAME <- NAMES[[kk]]
[10:27:51.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.057]                     next
[10:27:51.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.057]                 }
[10:27:51.057]                 if (length(args) > 0) 
[10:27:51.057]                   base::do.call(base::Sys.setenv, args = args)
[10:27:51.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:51.057]             }
[10:27:51.057]             else {
[10:27:51.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:51.057]             }
[10:27:51.057]             {
[10:27:51.057]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:51.057]                   0L) {
[10:27:51.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:51.057]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:51.057]                   base::options(opts)
[10:27:51.057]                 }
[10:27:51.057]                 {
[10:27:51.057]                   {
[10:27:51.057]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:51.057]                     NULL
[10:27:51.057]                   }
[10:27:51.057]                   options(future.plan = NULL)
[10:27:51.057]                   if (is.na(NA_character_)) 
[10:27:51.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:51.057]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:51.057]                     envir = parent.frame()) 
[10:27:51.057]                   {
[10:27:51.057]                     default_workers <- missing(workers)
[10:27:51.057]                     if (is.function(workers)) 
[10:27:51.057]                       workers <- workers()
[10:27:51.057]                     workers <- structure(as.integer(workers), 
[10:27:51.057]                       class = class(workers))
[10:27:51.057]                     stop_if_not(is.finite(workers), workers >= 
[10:27:51.057]                       1L)
[10:27:51.057]                     if ((workers == 1L && !inherits(workers, 
[10:27:51.057]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:51.057]                       if (default_workers) 
[10:27:51.057]                         supportsMulticore(warn = TRUE)
[10:27:51.057]                       return(sequential(..., envir = envir))
[10:27:51.057]                     }
[10:27:51.057]                     oopts <- options(mc.cores = workers)
[10:27:51.057]                     on.exit(options(oopts))
[10:27:51.057]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:51.057]                       envir = envir)
[10:27:51.057]                     if (!future$lazy) 
[10:27:51.057]                       future <- run(future)
[10:27:51.057]                     invisible(future)
[10:27:51.057]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:51.057]                 }
[10:27:51.057]             }
[10:27:51.057]         }
[10:27:51.057]     })
[10:27:51.057]     if (TRUE) {
[10:27:51.057]         base::sink(type = "output", split = FALSE)
[10:27:51.057]         if (TRUE) {
[10:27:51.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:51.057]         }
[10:27:51.057]         else {
[10:27:51.057]             ...future.result["stdout"] <- base::list(NULL)
[10:27:51.057]         }
[10:27:51.057]         base::close(...future.stdout)
[10:27:51.057]         ...future.stdout <- NULL
[10:27:51.057]     }
[10:27:51.057]     ...future.result$conditions <- ...future.conditions
[10:27:51.057]     ...future.result$finished <- base::Sys.time()
[10:27:51.057]     ...future.result
[10:27:51.057] }
[10:27:51.060] requestCore(): workers = 2
[10:27:51.062] MulticoreFuture started
[10:27:51.063] - Launch lazy future ... done
[10:27:51.063] run() for ‘MulticoreFuture’ ... done
[10:27:51.064] result() for MulticoreFuture ...
[10:27:51.068] plan(): Setting new future strategy stack:
[10:27:51.068] List of future strategies:
[10:27:51.068] 1. sequential:
[10:27:51.068]    - args: function (..., envir = parent.frame())
[10:27:51.068]    - tweaked: FALSE
[10:27:51.068]    - call: NULL
[10:27:51.069] plan(): nbrOfWorkers() = 1
[10:27:51.073] plan(): Setting new future strategy stack:
[10:27:51.073] List of future strategies:
[10:27:51.073] 1. multicore:
[10:27:51.073]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:51.073]    - tweaked: FALSE
[10:27:51.073]    - call: plan(strategy)
[10:27:51.078] plan(): nbrOfWorkers() = 2
[10:27:51.079] result() for MulticoreFuture ...
[10:27:51.079] result() for MulticoreFuture ... done
[10:27:51.080] result() for MulticoreFuture ... done
[10:27:51.080] result() for MulticoreFuture ...
[10:27:51.080] result() for MulticoreFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[10:27:51.080] getGlobalsAndPackages() ...
[10:27:51.081] Searching for globals...
[10:27:51.081] - globals found: [1] ‘print’
[10:27:51.082] Searching for globals ... DONE
[10:27:51.082] Resolving globals: FALSE
[10:27:51.082] 
[10:27:51.082] 
[10:27:51.082] getGlobalsAndPackages() ... DONE
[10:27:51.083] run() for ‘Future’ ...
[10:27:51.083] - state: ‘created’
[10:27:51.083] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:51.087] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:51.088] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:51.088]   - Field: ‘label’
[10:27:51.088]   - Field: ‘local’
[10:27:51.088]   - Field: ‘owner’
[10:27:51.088]   - Field: ‘envir’
[10:27:51.088]   - Field: ‘workers’
[10:27:51.088]   - Field: ‘packages’
[10:27:51.088]   - Field: ‘gc’
[10:27:51.089]   - Field: ‘job’
[10:27:51.089]   - Field: ‘conditions’
[10:27:51.089]   - Field: ‘expr’
[10:27:51.089]   - Field: ‘uuid’
[10:27:51.089]   - Field: ‘seed’
[10:27:51.089]   - Field: ‘version’
[10:27:51.089]   - Field: ‘result’
[10:27:51.089]   - Field: ‘asynchronous’
[10:27:51.089]   - Field: ‘calls’
[10:27:51.090]   - Field: ‘globals’
[10:27:51.090]   - Field: ‘stdout’
[10:27:51.090]   - Field: ‘earlySignal’
[10:27:51.090]   - Field: ‘lazy’
[10:27:51.090]   - Field: ‘state’
[10:27:51.090] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:51.090] - Launch lazy future ...
[10:27:51.091] Packages needed by the future expression (n = 0): <none>
[10:27:51.091] Packages needed by future strategies (n = 0): <none>
[10:27:51.091] {
[10:27:51.091]     {
[10:27:51.091]         {
[10:27:51.091]             ...future.startTime <- base::Sys.time()
[10:27:51.091]             {
[10:27:51.091]                 {
[10:27:51.091]                   {
[10:27:51.091]                     {
[10:27:51.091]                       base::local({
[10:27:51.091]                         has_future <- base::requireNamespace("future", 
[10:27:51.091]                           quietly = TRUE)
[10:27:51.091]                         if (has_future) {
[10:27:51.091]                           ns <- base::getNamespace("future")
[10:27:51.091]                           version <- ns[[".package"]][["version"]]
[10:27:51.091]                           if (is.null(version)) 
[10:27:51.091]                             version <- utils::packageVersion("future")
[10:27:51.091]                         }
[10:27:51.091]                         else {
[10:27:51.091]                           version <- NULL
[10:27:51.091]                         }
[10:27:51.091]                         if (!has_future || version < "1.8.0") {
[10:27:51.091]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:51.091]                             "", base::R.version$version.string), 
[10:27:51.091]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:51.091]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:51.091]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:51.091]                               "release", "version")], collapse = " "), 
[10:27:51.091]                             hostname = base::Sys.info()[["nodename"]])
[10:27:51.091]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:51.091]                             info)
[10:27:51.091]                           info <- base::paste(info, collapse = "; ")
[10:27:51.091]                           if (!has_future) {
[10:27:51.091]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:51.091]                               info)
[10:27:51.091]                           }
[10:27:51.091]                           else {
[10:27:51.091]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:51.091]                               info, version)
[10:27:51.091]                           }
[10:27:51.091]                           base::stop(msg)
[10:27:51.091]                         }
[10:27:51.091]                       })
[10:27:51.091]                     }
[10:27:51.091]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:51.091]                     base::options(mc.cores = 1L)
[10:27:51.091]                   }
[10:27:51.091]                   options(future.plan = NULL)
[10:27:51.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:51.091]                 }
[10:27:51.091]                 ...future.workdir <- getwd()
[10:27:51.091]             }
[10:27:51.091]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:51.091]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:51.091]         }
[10:27:51.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:51.091]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:51.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:51.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:51.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:51.091]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:51.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:51.091]             base::names(...future.oldOptions))
[10:27:51.091]     }
[10:27:51.091]     if (FALSE) {
[10:27:51.091]     }
[10:27:51.091]     else {
[10:27:51.091]         if (TRUE) {
[10:27:51.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:51.091]                 open = "w")
[10:27:51.091]         }
[10:27:51.091]         else {
[10:27:51.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:51.091]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:51.091]         }
[10:27:51.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:51.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:51.091]             base::sink(type = "output", split = FALSE)
[10:27:51.091]             base::close(...future.stdout)
[10:27:51.091]         }, add = TRUE)
[10:27:51.091]     }
[10:27:51.091]     ...future.frame <- base::sys.nframe()
[10:27:51.091]     ...future.conditions <- base::list()
[10:27:51.091]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:51.091]     if (FALSE) {
[10:27:51.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:51.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:51.091]     }
[10:27:51.091]     ...future.result <- base::tryCatch({
[10:27:51.091]         base::withCallingHandlers({
[10:27:51.091]             ...future.value <- base::withVisible(base::local({
[10:27:51.091]                 withCallingHandlers({
[10:27:51.091]                   print(42)
[10:27:51.091]                 }, immediateCondition = function(cond) {
[10:27:51.091]                   save_rds <- function (object, pathname, ...) 
[10:27:51.091]                   {
[10:27:51.091]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:51.091]                     if (file_test("-f", pathname_tmp)) {
[10:27:51.091]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.091]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:51.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.091]                         fi_tmp[["mtime"]])
[10:27:51.091]                     }
[10:27:51.091]                     tryCatch({
[10:27:51.091]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:51.091]                     }, error = function(ex) {
[10:27:51.091]                       msg <- conditionMessage(ex)
[10:27:51.091]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.091]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:51.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.091]                         fi_tmp[["mtime"]], msg)
[10:27:51.091]                       ex$message <- msg
[10:27:51.091]                       stop(ex)
[10:27:51.091]                     })
[10:27:51.091]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:51.091]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:51.091]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:51.091]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.091]                       fi <- file.info(pathname)
[10:27:51.091]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:51.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.091]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:51.091]                         fi[["size"]], fi[["mtime"]])
[10:27:51.091]                       stop(msg)
[10:27:51.091]                     }
[10:27:51.091]                     invisible(pathname)
[10:27:51.091]                   }
[10:27:51.091]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:51.091]                     rootPath = tempdir()) 
[10:27:51.091]                   {
[10:27:51.091]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:51.091]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:51.091]                       tmpdir = path, fileext = ".rds")
[10:27:51.091]                     save_rds(obj, file)
[10:27:51.091]                   }
[10:27:51.091]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3JSlqb/.future/immediateConditions")
[10:27:51.091]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.091]                   {
[10:27:51.091]                     inherits <- base::inherits
[10:27:51.091]                     invokeRestart <- base::invokeRestart
[10:27:51.091]                     is.null <- base::is.null
[10:27:51.091]                     muffled <- FALSE
[10:27:51.091]                     if (inherits(cond, "message")) {
[10:27:51.091]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:51.091]                       if (muffled) 
[10:27:51.091]                         invokeRestart("muffleMessage")
[10:27:51.091]                     }
[10:27:51.091]                     else if (inherits(cond, "warning")) {
[10:27:51.091]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:51.091]                       if (muffled) 
[10:27:51.091]                         invokeRestart("muffleWarning")
[10:27:51.091]                     }
[10:27:51.091]                     else if (inherits(cond, "condition")) {
[10:27:51.091]                       if (!is.null(pattern)) {
[10:27:51.091]                         computeRestarts <- base::computeRestarts
[10:27:51.091]                         grepl <- base::grepl
[10:27:51.091]                         restarts <- computeRestarts(cond)
[10:27:51.091]                         for (restart in restarts) {
[10:27:51.091]                           name <- restart$name
[10:27:51.091]                           if (is.null(name)) 
[10:27:51.091]                             next
[10:27:51.091]                           if (!grepl(pattern, name)) 
[10:27:51.091]                             next
[10:27:51.091]                           invokeRestart(restart)
[10:27:51.091]                           muffled <- TRUE
[10:27:51.091]                           break
[10:27:51.091]                         }
[10:27:51.091]                       }
[10:27:51.091]                     }
[10:27:51.091]                     invisible(muffled)
[10:27:51.091]                   }
[10:27:51.091]                   muffleCondition(cond)
[10:27:51.091]                 })
[10:27:51.091]             }))
[10:27:51.091]             future::FutureResult(value = ...future.value$value, 
[10:27:51.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.091]                   ...future.rng), globalenv = if (FALSE) 
[10:27:51.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:51.091]                     ...future.globalenv.names))
[10:27:51.091]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:51.091]         }, condition = base::local({
[10:27:51.091]             c <- base::c
[10:27:51.091]             inherits <- base::inherits
[10:27:51.091]             invokeRestart <- base::invokeRestart
[10:27:51.091]             length <- base::length
[10:27:51.091]             list <- base::list
[10:27:51.091]             seq.int <- base::seq.int
[10:27:51.091]             signalCondition <- base::signalCondition
[10:27:51.091]             sys.calls <- base::sys.calls
[10:27:51.091]             `[[` <- base::`[[`
[10:27:51.091]             `+` <- base::`+`
[10:27:51.091]             `<<-` <- base::`<<-`
[10:27:51.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:51.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:51.091]                   3L)]
[10:27:51.091]             }
[10:27:51.091]             function(cond) {
[10:27:51.091]                 is_error <- inherits(cond, "error")
[10:27:51.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:51.091]                   NULL)
[10:27:51.091]                 if (is_error) {
[10:27:51.091]                   sessionInformation <- function() {
[10:27:51.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:51.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:51.091]                       search = base::search(), system = base::Sys.info())
[10:27:51.091]                   }
[10:27:51.091]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:51.091]                     cond$call), session = sessionInformation(), 
[10:27:51.091]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:51.091]                   signalCondition(cond)
[10:27:51.091]                 }
[10:27:51.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:51.091]                 "immediateCondition"))) {
[10:27:51.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:51.091]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:51.091]                   if (TRUE && !signal) {
[10:27:51.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.091]                     {
[10:27:51.091]                       inherits <- base::inherits
[10:27:51.091]                       invokeRestart <- base::invokeRestart
[10:27:51.091]                       is.null <- base::is.null
[10:27:51.091]                       muffled <- FALSE
[10:27:51.091]                       if (inherits(cond, "message")) {
[10:27:51.091]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.091]                         if (muffled) 
[10:27:51.091]                           invokeRestart("muffleMessage")
[10:27:51.091]                       }
[10:27:51.091]                       else if (inherits(cond, "warning")) {
[10:27:51.091]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.091]                         if (muffled) 
[10:27:51.091]                           invokeRestart("muffleWarning")
[10:27:51.091]                       }
[10:27:51.091]                       else if (inherits(cond, "condition")) {
[10:27:51.091]                         if (!is.null(pattern)) {
[10:27:51.091]                           computeRestarts <- base::computeRestarts
[10:27:51.091]                           grepl <- base::grepl
[10:27:51.091]                           restarts <- computeRestarts(cond)
[10:27:51.091]                           for (restart in restarts) {
[10:27:51.091]                             name <- restart$name
[10:27:51.091]                             if (is.null(name)) 
[10:27:51.091]                               next
[10:27:51.091]                             if (!grepl(pattern, name)) 
[10:27:51.091]                               next
[10:27:51.091]                             invokeRestart(restart)
[10:27:51.091]                             muffled <- TRUE
[10:27:51.091]                             break
[10:27:51.091]                           }
[10:27:51.091]                         }
[10:27:51.091]                       }
[10:27:51.091]                       invisible(muffled)
[10:27:51.091]                     }
[10:27:51.091]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.091]                   }
[10:27:51.091]                 }
[10:27:51.091]                 else {
[10:27:51.091]                   if (TRUE) {
[10:27:51.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.091]                     {
[10:27:51.091]                       inherits <- base::inherits
[10:27:51.091]                       invokeRestart <- base::invokeRestart
[10:27:51.091]                       is.null <- base::is.null
[10:27:51.091]                       muffled <- FALSE
[10:27:51.091]                       if (inherits(cond, "message")) {
[10:27:51.091]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.091]                         if (muffled) 
[10:27:51.091]                           invokeRestart("muffleMessage")
[10:27:51.091]                       }
[10:27:51.091]                       else if (inherits(cond, "warning")) {
[10:27:51.091]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.091]                         if (muffled) 
[10:27:51.091]                           invokeRestart("muffleWarning")
[10:27:51.091]                       }
[10:27:51.091]                       else if (inherits(cond, "condition")) {
[10:27:51.091]                         if (!is.null(pattern)) {
[10:27:51.091]                           computeRestarts <- base::computeRestarts
[10:27:51.091]                           grepl <- base::grepl
[10:27:51.091]                           restarts <- computeRestarts(cond)
[10:27:51.091]                           for (restart in restarts) {
[10:27:51.091]                             name <- restart$name
[10:27:51.091]                             if (is.null(name)) 
[10:27:51.091]                               next
[10:27:51.091]                             if (!grepl(pattern, name)) 
[10:27:51.091]                               next
[10:27:51.091]                             invokeRestart(restart)
[10:27:51.091]                             muffled <- TRUE
[10:27:51.091]                             break
[10:27:51.091]                           }
[10:27:51.091]                         }
[10:27:51.091]                       }
[10:27:51.091]                       invisible(muffled)
[10:27:51.091]                     }
[10:27:51.091]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.091]                   }
[10:27:51.091]                 }
[10:27:51.091]             }
[10:27:51.091]         }))
[10:27:51.091]     }, error = function(ex) {
[10:27:51.091]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:51.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.091]                 ...future.rng), started = ...future.startTime, 
[10:27:51.091]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:51.091]             version = "1.8"), class = "FutureResult")
[10:27:51.091]     }, finally = {
[10:27:51.091]         if (!identical(...future.workdir, getwd())) 
[10:27:51.091]             setwd(...future.workdir)
[10:27:51.091]         {
[10:27:51.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:51.091]                 ...future.oldOptions$nwarnings <- NULL
[10:27:51.091]             }
[10:27:51.091]             base::options(...future.oldOptions)
[10:27:51.091]             if (.Platform$OS.type == "windows") {
[10:27:51.091]                 old_names <- names(...future.oldEnvVars)
[10:27:51.091]                 envs <- base::Sys.getenv()
[10:27:51.091]                 names <- names(envs)
[10:27:51.091]                 common <- intersect(names, old_names)
[10:27:51.091]                 added <- setdiff(names, old_names)
[10:27:51.091]                 removed <- setdiff(old_names, names)
[10:27:51.091]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:51.091]                   envs[common]]
[10:27:51.091]                 NAMES <- toupper(changed)
[10:27:51.091]                 args <- list()
[10:27:51.091]                 for (kk in seq_along(NAMES)) {
[10:27:51.091]                   name <- changed[[kk]]
[10:27:51.091]                   NAME <- NAMES[[kk]]
[10:27:51.091]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.091]                     next
[10:27:51.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.091]                 }
[10:27:51.091]                 NAMES <- toupper(added)
[10:27:51.091]                 for (kk in seq_along(NAMES)) {
[10:27:51.091]                   name <- added[[kk]]
[10:27:51.091]                   NAME <- NAMES[[kk]]
[10:27:51.091]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.091]                     next
[10:27:51.091]                   args[[name]] <- ""
[10:27:51.091]                 }
[10:27:51.091]                 NAMES <- toupper(removed)
[10:27:51.091]                 for (kk in seq_along(NAMES)) {
[10:27:51.091]                   name <- removed[[kk]]
[10:27:51.091]                   NAME <- NAMES[[kk]]
[10:27:51.091]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.091]                     next
[10:27:51.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.091]                 }
[10:27:51.091]                 if (length(args) > 0) 
[10:27:51.091]                   base::do.call(base::Sys.setenv, args = args)
[10:27:51.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:51.091]             }
[10:27:51.091]             else {
[10:27:51.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:51.091]             }
[10:27:51.091]             {
[10:27:51.091]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:51.091]                   0L) {
[10:27:51.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:51.091]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:51.091]                   base::options(opts)
[10:27:51.091]                 }
[10:27:51.091]                 {
[10:27:51.091]                   {
[10:27:51.091]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:51.091]                     NULL
[10:27:51.091]                   }
[10:27:51.091]                   options(future.plan = NULL)
[10:27:51.091]                   if (is.na(NA_character_)) 
[10:27:51.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:51.091]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:51.091]                     envir = parent.frame()) 
[10:27:51.091]                   {
[10:27:51.091]                     default_workers <- missing(workers)
[10:27:51.091]                     if (is.function(workers)) 
[10:27:51.091]                       workers <- workers()
[10:27:51.091]                     workers <- structure(as.integer(workers), 
[10:27:51.091]                       class = class(workers))
[10:27:51.091]                     stop_if_not(is.finite(workers), workers >= 
[10:27:51.091]                       1L)
[10:27:51.091]                     if ((workers == 1L && !inherits(workers, 
[10:27:51.091]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:51.091]                       if (default_workers) 
[10:27:51.091]                         supportsMulticore(warn = TRUE)
[10:27:51.091]                       return(sequential(..., envir = envir))
[10:27:51.091]                     }
[10:27:51.091]                     oopts <- options(mc.cores = workers)
[10:27:51.091]                     on.exit(options(oopts))
[10:27:51.091]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:51.091]                       envir = envir)
[10:27:51.091]                     if (!future$lazy) 
[10:27:51.091]                       future <- run(future)
[10:27:51.091]                     invisible(future)
[10:27:51.091]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:51.091]                 }
[10:27:51.091]             }
[10:27:51.091]         }
[10:27:51.091]     })
[10:27:51.091]     if (TRUE) {
[10:27:51.091]         base::sink(type = "output", split = FALSE)
[10:27:51.091]         if (TRUE) {
[10:27:51.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:51.091]         }
[10:27:51.091]         else {
[10:27:51.091]             ...future.result["stdout"] <- base::list(NULL)
[10:27:51.091]         }
[10:27:51.091]         base::close(...future.stdout)
[10:27:51.091]         ...future.stdout <- NULL
[10:27:51.091]     }
[10:27:51.091]     ...future.result$conditions <- ...future.conditions
[10:27:51.091]     ...future.result$finished <- base::Sys.time()
[10:27:51.091]     ...future.result
[10:27:51.091] }
[10:27:51.094] requestCore(): workers = 2
[10:27:51.096] MulticoreFuture started
[10:27:51.097] - Launch lazy future ... done
[10:27:51.097] run() for ‘MulticoreFuture’ ... done
[10:27:51.097] result() for MulticoreFuture ...
[10:27:51.098] plan(): Setting new future strategy stack:
[10:27:51.098] List of future strategies:
[10:27:51.098] 1. sequential:
[10:27:51.098]    - args: function (..., envir = parent.frame())
[10:27:51.098]    - tweaked: FALSE
[10:27:51.098]    - call: NULL
[10:27:51.099] plan(): nbrOfWorkers() = 1
[10:27:51.106] plan(): Setting new future strategy stack:
[10:27:51.106] List of future strategies:
[10:27:51.106] 1. multicore:
[10:27:51.106]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:51.106]    - tweaked: FALSE
[10:27:51.106]    - call: plan(strategy)
[10:27:51.111] plan(): nbrOfWorkers() = 2
[10:27:51.115] result() for MulticoreFuture ...
[10:27:51.115] result() for MulticoreFuture ... done
[10:27:51.115] result() for MulticoreFuture ... done
[10:27:51.115] result() for MulticoreFuture ...
[10:27:51.116] result() for MulticoreFuture ... done
[10:27:51.116] result() for MulticoreFuture ...
[10:27:51.116] result() for MulticoreFuture ... done
[1] 42
[10:27:51.116] result() for MulticoreFuture ...
[10:27:51.116] result() for MulticoreFuture ... done
- stdout = FALSE
[10:27:51.117] getGlobalsAndPackages() ...
[10:27:51.117] Searching for globals...
[10:27:51.121] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:51.121] Searching for globals ... DONE
[10:27:51.121] Resolving globals: FALSE
[10:27:51.122] 
[10:27:51.122] - packages: [1] ‘utils’
[10:27:51.122] getGlobalsAndPackages() ... DONE
[10:27:51.123] run() for ‘Future’ ...
[10:27:51.123] - state: ‘created’
[10:27:51.123] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:51.127] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:51.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:51.128]   - Field: ‘label’
[10:27:51.128]   - Field: ‘local’
[10:27:51.128]   - Field: ‘owner’
[10:27:51.128]   - Field: ‘envir’
[10:27:51.128]   - Field: ‘workers’
[10:27:51.128]   - Field: ‘packages’
[10:27:51.129]   - Field: ‘gc’
[10:27:51.129]   - Field: ‘job’
[10:27:51.129]   - Field: ‘conditions’
[10:27:51.129]   - Field: ‘expr’
[10:27:51.129]   - Field: ‘uuid’
[10:27:51.129]   - Field: ‘seed’
[10:27:51.129]   - Field: ‘version’
[10:27:51.129]   - Field: ‘result’
[10:27:51.130]   - Field: ‘asynchronous’
[10:27:51.130]   - Field: ‘calls’
[10:27:51.130]   - Field: ‘globals’
[10:27:51.130]   - Field: ‘stdout’
[10:27:51.130]   - Field: ‘earlySignal’
[10:27:51.130]   - Field: ‘lazy’
[10:27:51.130]   - Field: ‘state’
[10:27:51.130] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:51.131] - Launch lazy future ...
[10:27:51.131] Packages needed by the future expression (n = 1): ‘utils’
[10:27:51.131] Packages needed by future strategies (n = 0): <none>
[10:27:51.132] {
[10:27:51.132]     {
[10:27:51.132]         {
[10:27:51.132]             ...future.startTime <- base::Sys.time()
[10:27:51.132]             {
[10:27:51.132]                 {
[10:27:51.132]                   {
[10:27:51.132]                     {
[10:27:51.132]                       {
[10:27:51.132]                         base::local({
[10:27:51.132]                           has_future <- base::requireNamespace("future", 
[10:27:51.132]                             quietly = TRUE)
[10:27:51.132]                           if (has_future) {
[10:27:51.132]                             ns <- base::getNamespace("future")
[10:27:51.132]                             version <- ns[[".package"]][["version"]]
[10:27:51.132]                             if (is.null(version)) 
[10:27:51.132]                               version <- utils::packageVersion("future")
[10:27:51.132]                           }
[10:27:51.132]                           else {
[10:27:51.132]                             version <- NULL
[10:27:51.132]                           }
[10:27:51.132]                           if (!has_future || version < "1.8.0") {
[10:27:51.132]                             info <- base::c(r_version = base::gsub("R version ", 
[10:27:51.132]                               "", base::R.version$version.string), 
[10:27:51.132]                               platform = base::sprintf("%s (%s-bit)", 
[10:27:51.132]                                 base::R.version$platform, 8 * 
[10:27:51.132]                                   base::.Machine$sizeof.pointer), 
[10:27:51.132]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:51.132]                                 "release", "version")], collapse = " "), 
[10:27:51.132]                               hostname = base::Sys.info()[["nodename"]])
[10:27:51.132]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:27:51.132]                               info)
[10:27:51.132]                             info <- base::paste(info, collapse = "; ")
[10:27:51.132]                             if (!has_future) {
[10:27:51.132]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:51.132]                                 info)
[10:27:51.132]                             }
[10:27:51.132]                             else {
[10:27:51.132]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:51.132]                                 info, version)
[10:27:51.132]                             }
[10:27:51.132]                             base::stop(msg)
[10:27:51.132]                           }
[10:27:51.132]                         })
[10:27:51.132]                       }
[10:27:51.132]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:51.132]                       base::options(mc.cores = 1L)
[10:27:51.132]                     }
[10:27:51.132]                     base::local({
[10:27:51.132]                       for (pkg in "utils") {
[10:27:51.132]                         base::loadNamespace(pkg)
[10:27:51.132]                         base::library(pkg, character.only = TRUE)
[10:27:51.132]                       }
[10:27:51.132]                     })
[10:27:51.132]                   }
[10:27:51.132]                   options(future.plan = NULL)
[10:27:51.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:51.132]                 }
[10:27:51.132]                 ...future.workdir <- getwd()
[10:27:51.132]             }
[10:27:51.132]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:51.132]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:51.132]         }
[10:27:51.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:51.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:51.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:51.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:51.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:51.132]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:51.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:51.132]             base::names(...future.oldOptions))
[10:27:51.132]     }
[10:27:51.132]     if (FALSE) {
[10:27:51.132]     }
[10:27:51.132]     else {
[10:27:51.132]         if (FALSE) {
[10:27:51.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:51.132]                 open = "w")
[10:27:51.132]         }
[10:27:51.132]         else {
[10:27:51.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:51.132]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:51.132]         }
[10:27:51.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:51.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:51.132]             base::sink(type = "output", split = FALSE)
[10:27:51.132]             base::close(...future.stdout)
[10:27:51.132]         }, add = TRUE)
[10:27:51.132]     }
[10:27:51.132]     ...future.frame <- base::sys.nframe()
[10:27:51.132]     ...future.conditions <- base::list()
[10:27:51.132]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:51.132]     if (FALSE) {
[10:27:51.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:51.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:51.132]     }
[10:27:51.132]     ...future.result <- base::tryCatch({
[10:27:51.132]         base::withCallingHandlers({
[10:27:51.132]             ...future.value <- base::withVisible(base::local({
[10:27:51.132]                 withCallingHandlers({
[10:27:51.132]                   {
[10:27:51.132]                     print(1:50)
[10:27:51.132]                     str(1:50)
[10:27:51.132]                     cat(letters, sep = "-")
[10:27:51.132]                     cat(1:6, collapse = "\n")
[10:27:51.132]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:51.132]                     42L
[10:27:51.132]                   }
[10:27:51.132]                 }, immediateCondition = function(cond) {
[10:27:51.132]                   save_rds <- function (object, pathname, ...) 
[10:27:51.132]                   {
[10:27:51.132]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:51.132]                     if (file_test("-f", pathname_tmp)) {
[10:27:51.132]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.132]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:51.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.132]                         fi_tmp[["mtime"]])
[10:27:51.132]                     }
[10:27:51.132]                     tryCatch({
[10:27:51.132]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:51.132]                     }, error = function(ex) {
[10:27:51.132]                       msg <- conditionMessage(ex)
[10:27:51.132]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.132]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:51.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.132]                         fi_tmp[["mtime"]], msg)
[10:27:51.132]                       ex$message <- msg
[10:27:51.132]                       stop(ex)
[10:27:51.132]                     })
[10:27:51.132]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:51.132]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:51.132]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:51.132]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.132]                       fi <- file.info(pathname)
[10:27:51.132]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:51.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.132]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:51.132]                         fi[["size"]], fi[["mtime"]])
[10:27:51.132]                       stop(msg)
[10:27:51.132]                     }
[10:27:51.132]                     invisible(pathname)
[10:27:51.132]                   }
[10:27:51.132]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:51.132]                     rootPath = tempdir()) 
[10:27:51.132]                   {
[10:27:51.132]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:51.132]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:51.132]                       tmpdir = path, fileext = ".rds")
[10:27:51.132]                     save_rds(obj, file)
[10:27:51.132]                   }
[10:27:51.132]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3JSlqb/.future/immediateConditions")
[10:27:51.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.132]                   {
[10:27:51.132]                     inherits <- base::inherits
[10:27:51.132]                     invokeRestart <- base::invokeRestart
[10:27:51.132]                     is.null <- base::is.null
[10:27:51.132]                     muffled <- FALSE
[10:27:51.132]                     if (inherits(cond, "message")) {
[10:27:51.132]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:51.132]                       if (muffled) 
[10:27:51.132]                         invokeRestart("muffleMessage")
[10:27:51.132]                     }
[10:27:51.132]                     else if (inherits(cond, "warning")) {
[10:27:51.132]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:51.132]                       if (muffled) 
[10:27:51.132]                         invokeRestart("muffleWarning")
[10:27:51.132]                     }
[10:27:51.132]                     else if (inherits(cond, "condition")) {
[10:27:51.132]                       if (!is.null(pattern)) {
[10:27:51.132]                         computeRestarts <- base::computeRestarts
[10:27:51.132]                         grepl <- base::grepl
[10:27:51.132]                         restarts <- computeRestarts(cond)
[10:27:51.132]                         for (restart in restarts) {
[10:27:51.132]                           name <- restart$name
[10:27:51.132]                           if (is.null(name)) 
[10:27:51.132]                             next
[10:27:51.132]                           if (!grepl(pattern, name)) 
[10:27:51.132]                             next
[10:27:51.132]                           invokeRestart(restart)
[10:27:51.132]                           muffled <- TRUE
[10:27:51.132]                           break
[10:27:51.132]                         }
[10:27:51.132]                       }
[10:27:51.132]                     }
[10:27:51.132]                     invisible(muffled)
[10:27:51.132]                   }
[10:27:51.132]                   muffleCondition(cond)
[10:27:51.132]                 })
[10:27:51.132]             }))
[10:27:51.132]             future::FutureResult(value = ...future.value$value, 
[10:27:51.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.132]                   ...future.rng), globalenv = if (FALSE) 
[10:27:51.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:51.132]                     ...future.globalenv.names))
[10:27:51.132]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:51.132]         }, condition = base::local({
[10:27:51.132]             c <- base::c
[10:27:51.132]             inherits <- base::inherits
[10:27:51.132]             invokeRestart <- base::invokeRestart
[10:27:51.132]             length <- base::length
[10:27:51.132]             list <- base::list
[10:27:51.132]             seq.int <- base::seq.int
[10:27:51.132]             signalCondition <- base::signalCondition
[10:27:51.132]             sys.calls <- base::sys.calls
[10:27:51.132]             `[[` <- base::`[[`
[10:27:51.132]             `+` <- base::`+`
[10:27:51.132]             `<<-` <- base::`<<-`
[10:27:51.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:51.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:51.132]                   3L)]
[10:27:51.132]             }
[10:27:51.132]             function(cond) {
[10:27:51.132]                 is_error <- inherits(cond, "error")
[10:27:51.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:51.132]                   NULL)
[10:27:51.132]                 if (is_error) {
[10:27:51.132]                   sessionInformation <- function() {
[10:27:51.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:51.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:51.132]                       search = base::search(), system = base::Sys.info())
[10:27:51.132]                   }
[10:27:51.132]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:51.132]                     cond$call), session = sessionInformation(), 
[10:27:51.132]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:51.132]                   signalCondition(cond)
[10:27:51.132]                 }
[10:27:51.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:51.132]                 "immediateCondition"))) {
[10:27:51.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:51.132]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:51.132]                   if (TRUE && !signal) {
[10:27:51.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.132]                     {
[10:27:51.132]                       inherits <- base::inherits
[10:27:51.132]                       invokeRestart <- base::invokeRestart
[10:27:51.132]                       is.null <- base::is.null
[10:27:51.132]                       muffled <- FALSE
[10:27:51.132]                       if (inherits(cond, "message")) {
[10:27:51.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.132]                         if (muffled) 
[10:27:51.132]                           invokeRestart("muffleMessage")
[10:27:51.132]                       }
[10:27:51.132]                       else if (inherits(cond, "warning")) {
[10:27:51.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.132]                         if (muffled) 
[10:27:51.132]                           invokeRestart("muffleWarning")
[10:27:51.132]                       }
[10:27:51.132]                       else if (inherits(cond, "condition")) {
[10:27:51.132]                         if (!is.null(pattern)) {
[10:27:51.132]                           computeRestarts <- base::computeRestarts
[10:27:51.132]                           grepl <- base::grepl
[10:27:51.132]                           restarts <- computeRestarts(cond)
[10:27:51.132]                           for (restart in restarts) {
[10:27:51.132]                             name <- restart$name
[10:27:51.132]                             if (is.null(name)) 
[10:27:51.132]                               next
[10:27:51.132]                             if (!grepl(pattern, name)) 
[10:27:51.132]                               next
[10:27:51.132]                             invokeRestart(restart)
[10:27:51.132]                             muffled <- TRUE
[10:27:51.132]                             break
[10:27:51.132]                           }
[10:27:51.132]                         }
[10:27:51.132]                       }
[10:27:51.132]                       invisible(muffled)
[10:27:51.132]                     }
[10:27:51.132]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.132]                   }
[10:27:51.132]                 }
[10:27:51.132]                 else {
[10:27:51.132]                   if (TRUE) {
[10:27:51.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.132]                     {
[10:27:51.132]                       inherits <- base::inherits
[10:27:51.132]                       invokeRestart <- base::invokeRestart
[10:27:51.132]                       is.null <- base::is.null
[10:27:51.132]                       muffled <- FALSE
[10:27:51.132]                       if (inherits(cond, "message")) {
[10:27:51.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.132]                         if (muffled) 
[10:27:51.132]                           invokeRestart("muffleMessage")
[10:27:51.132]                       }
[10:27:51.132]                       else if (inherits(cond, "warning")) {
[10:27:51.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.132]                         if (muffled) 
[10:27:51.132]                           invokeRestart("muffleWarning")
[10:27:51.132]                       }
[10:27:51.132]                       else if (inherits(cond, "condition")) {
[10:27:51.132]                         if (!is.null(pattern)) {
[10:27:51.132]                           computeRestarts <- base::computeRestarts
[10:27:51.132]                           grepl <- base::grepl
[10:27:51.132]                           restarts <- computeRestarts(cond)
[10:27:51.132]                           for (restart in restarts) {
[10:27:51.132]                             name <- restart$name
[10:27:51.132]                             if (is.null(name)) 
[10:27:51.132]                               next
[10:27:51.132]                             if (!grepl(pattern, name)) 
[10:27:51.132]                               next
[10:27:51.132]                             invokeRestart(restart)
[10:27:51.132]                             muffled <- TRUE
[10:27:51.132]                             break
[10:27:51.132]                           }
[10:27:51.132]                         }
[10:27:51.132]                       }
[10:27:51.132]                       invisible(muffled)
[10:27:51.132]                     }
[10:27:51.132]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.132]                   }
[10:27:51.132]                 }
[10:27:51.132]             }
[10:27:51.132]         }))
[10:27:51.132]     }, error = function(ex) {
[10:27:51.132]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:51.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.132]                 ...future.rng), started = ...future.startTime, 
[10:27:51.132]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:51.132]             version = "1.8"), class = "FutureResult")
[10:27:51.132]     }, finally = {
[10:27:51.132]         if (!identical(...future.workdir, getwd())) 
[10:27:51.132]             setwd(...future.workdir)
[10:27:51.132]         {
[10:27:51.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:51.132]                 ...future.oldOptions$nwarnings <- NULL
[10:27:51.132]             }
[10:27:51.132]             base::options(...future.oldOptions)
[10:27:51.132]             if (.Platform$OS.type == "windows") {
[10:27:51.132]                 old_names <- names(...future.oldEnvVars)
[10:27:51.132]                 envs <- base::Sys.getenv()
[10:27:51.132]                 names <- names(envs)
[10:27:51.132]                 common <- intersect(names, old_names)
[10:27:51.132]                 added <- setdiff(names, old_names)
[10:27:51.132]                 removed <- setdiff(old_names, names)
[10:27:51.132]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:51.132]                   envs[common]]
[10:27:51.132]                 NAMES <- toupper(changed)
[10:27:51.132]                 args <- list()
[10:27:51.132]                 for (kk in seq_along(NAMES)) {
[10:27:51.132]                   name <- changed[[kk]]
[10:27:51.132]                   NAME <- NAMES[[kk]]
[10:27:51.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.132]                     next
[10:27:51.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.132]                 }
[10:27:51.132]                 NAMES <- toupper(added)
[10:27:51.132]                 for (kk in seq_along(NAMES)) {
[10:27:51.132]                   name <- added[[kk]]
[10:27:51.132]                   NAME <- NAMES[[kk]]
[10:27:51.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.132]                     next
[10:27:51.132]                   args[[name]] <- ""
[10:27:51.132]                 }
[10:27:51.132]                 NAMES <- toupper(removed)
[10:27:51.132]                 for (kk in seq_along(NAMES)) {
[10:27:51.132]                   name <- removed[[kk]]
[10:27:51.132]                   NAME <- NAMES[[kk]]
[10:27:51.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.132]                     next
[10:27:51.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.132]                 }
[10:27:51.132]                 if (length(args) > 0) 
[10:27:51.132]                   base::do.call(base::Sys.setenv, args = args)
[10:27:51.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:51.132]             }
[10:27:51.132]             else {
[10:27:51.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:51.132]             }
[10:27:51.132]             {
[10:27:51.132]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:51.132]                   0L) {
[10:27:51.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:51.132]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:51.132]                   base::options(opts)
[10:27:51.132]                 }
[10:27:51.132]                 {
[10:27:51.132]                   {
[10:27:51.132]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:51.132]                     NULL
[10:27:51.132]                   }
[10:27:51.132]                   options(future.plan = NULL)
[10:27:51.132]                   if (is.na(NA_character_)) 
[10:27:51.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:51.132]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:51.132]                     envir = parent.frame()) 
[10:27:51.132]                   {
[10:27:51.132]                     default_workers <- missing(workers)
[10:27:51.132]                     if (is.function(workers)) 
[10:27:51.132]                       workers <- workers()
[10:27:51.132]                     workers <- structure(as.integer(workers), 
[10:27:51.132]                       class = class(workers))
[10:27:51.132]                     stop_if_not(is.finite(workers), workers >= 
[10:27:51.132]                       1L)
[10:27:51.132]                     if ((workers == 1L && !inherits(workers, 
[10:27:51.132]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:51.132]                       if (default_workers) 
[10:27:51.132]                         supportsMulticore(warn = TRUE)
[10:27:51.132]                       return(sequential(..., envir = envir))
[10:27:51.132]                     }
[10:27:51.132]                     oopts <- options(mc.cores = workers)
[10:27:51.132]                     on.exit(options(oopts))
[10:27:51.132]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:51.132]                       envir = envir)
[10:27:51.132]                     if (!future$lazy) 
[10:27:51.132]                       future <- run(future)
[10:27:51.132]                     invisible(future)
[10:27:51.132]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:51.132]                 }
[10:27:51.132]             }
[10:27:51.132]         }
[10:27:51.132]     })
[10:27:51.132]     if (TRUE) {
[10:27:51.132]         base::sink(type = "output", split = FALSE)
[10:27:51.132]         if (FALSE) {
[10:27:51.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:51.132]         }
[10:27:51.132]         else {
[10:27:51.132]             ...future.result["stdout"] <- base::list(NULL)
[10:27:51.132]         }
[10:27:51.132]         base::close(...future.stdout)
[10:27:51.132]         ...future.stdout <- NULL
[10:27:51.132]     }
[10:27:51.132]     ...future.result$conditions <- ...future.conditions
[10:27:51.132]     ...future.result$finished <- base::Sys.time()
[10:27:51.132]     ...future.result
[10:27:51.132] }
[10:27:51.134] requestCore(): workers = 2
[10:27:51.136] MulticoreFuture started
[10:27:51.137] - Launch lazy future ... done
[10:27:51.137] run() for ‘MulticoreFuture’ ... done
[10:27:51.137] result() for MulticoreFuture ...
[10:27:51.138] plan(): Setting new future strategy stack:
[10:27:51.138] List of future strategies:
[10:27:51.138] 1. sequential:
[10:27:51.138]    - args: function (..., envir = parent.frame())
[10:27:51.138]    - tweaked: FALSE
[10:27:51.138]    - call: NULL
[10:27:51.139] plan(): nbrOfWorkers() = 1
[10:27:51.143] plan(): Setting new future strategy stack:
[10:27:51.143] List of future strategies:
[10:27:51.143] 1. multicore:
[10:27:51.143]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:51.143]    - tweaked: FALSE
[10:27:51.143]    - call: plan(strategy)
[10:27:51.148] plan(): nbrOfWorkers() = 2
[10:27:51.149] result() for MulticoreFuture ...
[10:27:51.149] result() for MulticoreFuture ... done
[10:27:51.150] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 10:27:51"
 $ finished    : POSIXct[1:1], format: "2025-01-07 10:27:51"
 $ session_uuid: chr "7f620218-2d1e-61f9-7dfa-6e45b300eba4"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3e863ac79bce"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92688
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 10:27:51"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:27:51.160] result() for MulticoreFuture ...
[10:27:51.160] result() for MulticoreFuture ... done
[10:27:51.160] result() for MulticoreFuture ...
[10:27:51.160] result() for MulticoreFuture ... done
[10:27:51.161] getGlobalsAndPackages() ...
[10:27:51.161] Searching for globals...
[10:27:51.167] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:51.168] Searching for globals ... DONE
[10:27:51.168] Resolving globals: FALSE
[10:27:51.168] 
[10:27:51.168] - packages: [1] ‘utils’
[10:27:51.169] getGlobalsAndPackages() ... DONE
[10:27:51.169] run() for ‘Future’ ...
[10:27:51.169] - state: ‘created’
[10:27:51.169] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:51.175] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:51.175] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:51.175]   - Field: ‘label’
[10:27:51.176]   - Field: ‘local’
[10:27:51.176]   - Field: ‘owner’
[10:27:51.176]   - Field: ‘envir’
[10:27:51.176]   - Field: ‘workers’
[10:27:51.176]   - Field: ‘packages’
[10:27:51.177]   - Field: ‘gc’
[10:27:51.177]   - Field: ‘job’
[10:27:51.177]   - Field: ‘conditions’
[10:27:51.177]   - Field: ‘expr’
[10:27:51.177]   - Field: ‘uuid’
[10:27:51.177]   - Field: ‘seed’
[10:27:51.177]   - Field: ‘version’
[10:27:51.178]   - Field: ‘result’
[10:27:51.178]   - Field: ‘asynchronous’
[10:27:51.178]   - Field: ‘calls’
[10:27:51.178]   - Field: ‘globals’
[10:27:51.178]   - Field: ‘stdout’
[10:27:51.178]   - Field: ‘earlySignal’
[10:27:51.178]   - Field: ‘lazy’
[10:27:51.178]   - Field: ‘state’
[10:27:51.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:51.179] - Launch lazy future ...
[10:27:51.179] Packages needed by the future expression (n = 1): ‘utils’
[10:27:51.179] Packages needed by future strategies (n = 0): <none>
[10:27:51.180] {
[10:27:51.180]     {
[10:27:51.180]         {
[10:27:51.180]             ...future.startTime <- base::Sys.time()
[10:27:51.180]             {
[10:27:51.180]                 {
[10:27:51.180]                   {
[10:27:51.180]                     {
[10:27:51.180]                       {
[10:27:51.180]                         base::local({
[10:27:51.180]                           has_future <- base::requireNamespace("future", 
[10:27:51.180]                             quietly = TRUE)
[10:27:51.180]                           if (has_future) {
[10:27:51.180]                             ns <- base::getNamespace("future")
[10:27:51.180]                             version <- ns[[".package"]][["version"]]
[10:27:51.180]                             if (is.null(version)) 
[10:27:51.180]                               version <- utils::packageVersion("future")
[10:27:51.180]                           }
[10:27:51.180]                           else {
[10:27:51.180]                             version <- NULL
[10:27:51.180]                           }
[10:27:51.180]                           if (!has_future || version < "1.8.0") {
[10:27:51.180]                             info <- base::c(r_version = base::gsub("R version ", 
[10:27:51.180]                               "", base::R.version$version.string), 
[10:27:51.180]                               platform = base::sprintf("%s (%s-bit)", 
[10:27:51.180]                                 base::R.version$platform, 8 * 
[10:27:51.180]                                   base::.Machine$sizeof.pointer), 
[10:27:51.180]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:51.180]                                 "release", "version")], collapse = " "), 
[10:27:51.180]                               hostname = base::Sys.info()[["nodename"]])
[10:27:51.180]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:27:51.180]                               info)
[10:27:51.180]                             info <- base::paste(info, collapse = "; ")
[10:27:51.180]                             if (!has_future) {
[10:27:51.180]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:51.180]                                 info)
[10:27:51.180]                             }
[10:27:51.180]                             else {
[10:27:51.180]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:51.180]                                 info, version)
[10:27:51.180]                             }
[10:27:51.180]                             base::stop(msg)
[10:27:51.180]                           }
[10:27:51.180]                         })
[10:27:51.180]                       }
[10:27:51.180]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:51.180]                       base::options(mc.cores = 1L)
[10:27:51.180]                     }
[10:27:51.180]                     base::local({
[10:27:51.180]                       for (pkg in "utils") {
[10:27:51.180]                         base::loadNamespace(pkg)
[10:27:51.180]                         base::library(pkg, character.only = TRUE)
[10:27:51.180]                       }
[10:27:51.180]                     })
[10:27:51.180]                   }
[10:27:51.180]                   options(future.plan = NULL)
[10:27:51.180]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.180]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:51.180]                 }
[10:27:51.180]                 ...future.workdir <- getwd()
[10:27:51.180]             }
[10:27:51.180]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:51.180]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:51.180]         }
[10:27:51.180]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:51.180]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:51.180]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:51.180]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:51.180]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:51.180]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:51.180]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:51.180]             base::names(...future.oldOptions))
[10:27:51.180]     }
[10:27:51.180]     if (FALSE) {
[10:27:51.180]     }
[10:27:51.180]     else {
[10:27:51.180]         if (FALSE) {
[10:27:51.180]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:51.180]                 open = "w")
[10:27:51.180]         }
[10:27:51.180]         else {
[10:27:51.180]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:51.180]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:51.180]         }
[10:27:51.180]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:51.180]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:51.180]             base::sink(type = "output", split = FALSE)
[10:27:51.180]             base::close(...future.stdout)
[10:27:51.180]         }, add = TRUE)
[10:27:51.180]     }
[10:27:51.180]     ...future.frame <- base::sys.nframe()
[10:27:51.180]     ...future.conditions <- base::list()
[10:27:51.180]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:51.180]     if (FALSE) {
[10:27:51.180]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:51.180]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:51.180]     }
[10:27:51.180]     ...future.result <- base::tryCatch({
[10:27:51.180]         base::withCallingHandlers({
[10:27:51.180]             ...future.value <- base::withVisible(base::local({
[10:27:51.180]                 withCallingHandlers({
[10:27:51.180]                   {
[10:27:51.180]                     print(1:50)
[10:27:51.180]                     str(1:50)
[10:27:51.180]                     cat(letters, sep = "-")
[10:27:51.180]                     cat(1:6, collapse = "\n")
[10:27:51.180]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:51.180]                     42L
[10:27:51.180]                   }
[10:27:51.180]                 }, immediateCondition = function(cond) {
[10:27:51.180]                   save_rds <- function (object, pathname, ...) 
[10:27:51.180]                   {
[10:27:51.180]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:51.180]                     if (file_test("-f", pathname_tmp)) {
[10:27:51.180]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.180]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:51.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.180]                         fi_tmp[["mtime"]])
[10:27:51.180]                     }
[10:27:51.180]                     tryCatch({
[10:27:51.180]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:51.180]                     }, error = function(ex) {
[10:27:51.180]                       msg <- conditionMessage(ex)
[10:27:51.180]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.180]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:51.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.180]                         fi_tmp[["mtime"]], msg)
[10:27:51.180]                       ex$message <- msg
[10:27:51.180]                       stop(ex)
[10:27:51.180]                     })
[10:27:51.180]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:51.180]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:51.180]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:51.180]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.180]                       fi <- file.info(pathname)
[10:27:51.180]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:51.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.180]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:51.180]                         fi[["size"]], fi[["mtime"]])
[10:27:51.180]                       stop(msg)
[10:27:51.180]                     }
[10:27:51.180]                     invisible(pathname)
[10:27:51.180]                   }
[10:27:51.180]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:51.180]                     rootPath = tempdir()) 
[10:27:51.180]                   {
[10:27:51.180]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:51.180]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:51.180]                       tmpdir = path, fileext = ".rds")
[10:27:51.180]                     save_rds(obj, file)
[10:27:51.180]                   }
[10:27:51.180]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3JSlqb/.future/immediateConditions")
[10:27:51.180]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.180]                   {
[10:27:51.180]                     inherits <- base::inherits
[10:27:51.180]                     invokeRestart <- base::invokeRestart
[10:27:51.180]                     is.null <- base::is.null
[10:27:51.180]                     muffled <- FALSE
[10:27:51.180]                     if (inherits(cond, "message")) {
[10:27:51.180]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:51.180]                       if (muffled) 
[10:27:51.180]                         invokeRestart("muffleMessage")
[10:27:51.180]                     }
[10:27:51.180]                     else if (inherits(cond, "warning")) {
[10:27:51.180]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:51.180]                       if (muffled) 
[10:27:51.180]                         invokeRestart("muffleWarning")
[10:27:51.180]                     }
[10:27:51.180]                     else if (inherits(cond, "condition")) {
[10:27:51.180]                       if (!is.null(pattern)) {
[10:27:51.180]                         computeRestarts <- base::computeRestarts
[10:27:51.180]                         grepl <- base::grepl
[10:27:51.180]                         restarts <- computeRestarts(cond)
[10:27:51.180]                         for (restart in restarts) {
[10:27:51.180]                           name <- restart$name
[10:27:51.180]                           if (is.null(name)) 
[10:27:51.180]                             next
[10:27:51.180]                           if (!grepl(pattern, name)) 
[10:27:51.180]                             next
[10:27:51.180]                           invokeRestart(restart)
[10:27:51.180]                           muffled <- TRUE
[10:27:51.180]                           break
[10:27:51.180]                         }
[10:27:51.180]                       }
[10:27:51.180]                     }
[10:27:51.180]                     invisible(muffled)
[10:27:51.180]                   }
[10:27:51.180]                   muffleCondition(cond)
[10:27:51.180]                 })
[10:27:51.180]             }))
[10:27:51.180]             future::FutureResult(value = ...future.value$value, 
[10:27:51.180]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.180]                   ...future.rng), globalenv = if (FALSE) 
[10:27:51.180]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:51.180]                     ...future.globalenv.names))
[10:27:51.180]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:51.180]         }, condition = base::local({
[10:27:51.180]             c <- base::c
[10:27:51.180]             inherits <- base::inherits
[10:27:51.180]             invokeRestart <- base::invokeRestart
[10:27:51.180]             length <- base::length
[10:27:51.180]             list <- base::list
[10:27:51.180]             seq.int <- base::seq.int
[10:27:51.180]             signalCondition <- base::signalCondition
[10:27:51.180]             sys.calls <- base::sys.calls
[10:27:51.180]             `[[` <- base::`[[`
[10:27:51.180]             `+` <- base::`+`
[10:27:51.180]             `<<-` <- base::`<<-`
[10:27:51.180]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:51.180]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:51.180]                   3L)]
[10:27:51.180]             }
[10:27:51.180]             function(cond) {
[10:27:51.180]                 is_error <- inherits(cond, "error")
[10:27:51.180]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:51.180]                   NULL)
[10:27:51.180]                 if (is_error) {
[10:27:51.180]                   sessionInformation <- function() {
[10:27:51.180]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:51.180]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:51.180]                       search = base::search(), system = base::Sys.info())
[10:27:51.180]                   }
[10:27:51.180]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.180]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:51.180]                     cond$call), session = sessionInformation(), 
[10:27:51.180]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:51.180]                   signalCondition(cond)
[10:27:51.180]                 }
[10:27:51.180]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:51.180]                 "immediateCondition"))) {
[10:27:51.180]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:51.180]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.180]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:51.180]                   if (TRUE && !signal) {
[10:27:51.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.180]                     {
[10:27:51.180]                       inherits <- base::inherits
[10:27:51.180]                       invokeRestart <- base::invokeRestart
[10:27:51.180]                       is.null <- base::is.null
[10:27:51.180]                       muffled <- FALSE
[10:27:51.180]                       if (inherits(cond, "message")) {
[10:27:51.180]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.180]                         if (muffled) 
[10:27:51.180]                           invokeRestart("muffleMessage")
[10:27:51.180]                       }
[10:27:51.180]                       else if (inherits(cond, "warning")) {
[10:27:51.180]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.180]                         if (muffled) 
[10:27:51.180]                           invokeRestart("muffleWarning")
[10:27:51.180]                       }
[10:27:51.180]                       else if (inherits(cond, "condition")) {
[10:27:51.180]                         if (!is.null(pattern)) {
[10:27:51.180]                           computeRestarts <- base::computeRestarts
[10:27:51.180]                           grepl <- base::grepl
[10:27:51.180]                           restarts <- computeRestarts(cond)
[10:27:51.180]                           for (restart in restarts) {
[10:27:51.180]                             name <- restart$name
[10:27:51.180]                             if (is.null(name)) 
[10:27:51.180]                               next
[10:27:51.180]                             if (!grepl(pattern, name)) 
[10:27:51.180]                               next
[10:27:51.180]                             invokeRestart(restart)
[10:27:51.180]                             muffled <- TRUE
[10:27:51.180]                             break
[10:27:51.180]                           }
[10:27:51.180]                         }
[10:27:51.180]                       }
[10:27:51.180]                       invisible(muffled)
[10:27:51.180]                     }
[10:27:51.180]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.180]                   }
[10:27:51.180]                 }
[10:27:51.180]                 else {
[10:27:51.180]                   if (TRUE) {
[10:27:51.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.180]                     {
[10:27:51.180]                       inherits <- base::inherits
[10:27:51.180]                       invokeRestart <- base::invokeRestart
[10:27:51.180]                       is.null <- base::is.null
[10:27:51.180]                       muffled <- FALSE
[10:27:51.180]                       if (inherits(cond, "message")) {
[10:27:51.180]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.180]                         if (muffled) 
[10:27:51.180]                           invokeRestart("muffleMessage")
[10:27:51.180]                       }
[10:27:51.180]                       else if (inherits(cond, "warning")) {
[10:27:51.180]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.180]                         if (muffled) 
[10:27:51.180]                           invokeRestart("muffleWarning")
[10:27:51.180]                       }
[10:27:51.180]                       else if (inherits(cond, "condition")) {
[10:27:51.180]                         if (!is.null(pattern)) {
[10:27:51.180]                           computeRestarts <- base::computeRestarts
[10:27:51.180]                           grepl <- base::grepl
[10:27:51.180]                           restarts <- computeRestarts(cond)
[10:27:51.180]                           for (restart in restarts) {
[10:27:51.180]                             name <- restart$name
[10:27:51.180]                             if (is.null(name)) 
[10:27:51.180]                               next
[10:27:51.180]                             if (!grepl(pattern, name)) 
[10:27:51.180]                               next
[10:27:51.180]                             invokeRestart(restart)
[10:27:51.180]                             muffled <- TRUE
[10:27:51.180]                             break
[10:27:51.180]                           }
[10:27:51.180]                         }
[10:27:51.180]                       }
[10:27:51.180]                       invisible(muffled)
[10:27:51.180]                     }
[10:27:51.180]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.180]                   }
[10:27:51.180]                 }
[10:27:51.180]             }
[10:27:51.180]         }))
[10:27:51.180]     }, error = function(ex) {
[10:27:51.180]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:51.180]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.180]                 ...future.rng), started = ...future.startTime, 
[10:27:51.180]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:51.180]             version = "1.8"), class = "FutureResult")
[10:27:51.180]     }, finally = {
[10:27:51.180]         if (!identical(...future.workdir, getwd())) 
[10:27:51.180]             setwd(...future.workdir)
[10:27:51.180]         {
[10:27:51.180]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:51.180]                 ...future.oldOptions$nwarnings <- NULL
[10:27:51.180]             }
[10:27:51.180]             base::options(...future.oldOptions)
[10:27:51.180]             if (.Platform$OS.type == "windows") {
[10:27:51.180]                 old_names <- names(...future.oldEnvVars)
[10:27:51.180]                 envs <- base::Sys.getenv()
[10:27:51.180]                 names <- names(envs)
[10:27:51.180]                 common <- intersect(names, old_names)
[10:27:51.180]                 added <- setdiff(names, old_names)
[10:27:51.180]                 removed <- setdiff(old_names, names)
[10:27:51.180]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:51.180]                   envs[common]]
[10:27:51.180]                 NAMES <- toupper(changed)
[10:27:51.180]                 args <- list()
[10:27:51.180]                 for (kk in seq_along(NAMES)) {
[10:27:51.180]                   name <- changed[[kk]]
[10:27:51.180]                   NAME <- NAMES[[kk]]
[10:27:51.180]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.180]                     next
[10:27:51.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.180]                 }
[10:27:51.180]                 NAMES <- toupper(added)
[10:27:51.180]                 for (kk in seq_along(NAMES)) {
[10:27:51.180]                   name <- added[[kk]]
[10:27:51.180]                   NAME <- NAMES[[kk]]
[10:27:51.180]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.180]                     next
[10:27:51.180]                   args[[name]] <- ""
[10:27:51.180]                 }
[10:27:51.180]                 NAMES <- toupper(removed)
[10:27:51.180]                 for (kk in seq_along(NAMES)) {
[10:27:51.180]                   name <- removed[[kk]]
[10:27:51.180]                   NAME <- NAMES[[kk]]
[10:27:51.180]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.180]                     next
[10:27:51.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.180]                 }
[10:27:51.180]                 if (length(args) > 0) 
[10:27:51.180]                   base::do.call(base::Sys.setenv, args = args)
[10:27:51.180]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:51.180]             }
[10:27:51.180]             else {
[10:27:51.180]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:51.180]             }
[10:27:51.180]             {
[10:27:51.180]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:51.180]                   0L) {
[10:27:51.180]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:51.180]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:51.180]                   base::options(opts)
[10:27:51.180]                 }
[10:27:51.180]                 {
[10:27:51.180]                   {
[10:27:51.180]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:51.180]                     NULL
[10:27:51.180]                   }
[10:27:51.180]                   options(future.plan = NULL)
[10:27:51.180]                   if (is.na(NA_character_)) 
[10:27:51.180]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.180]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:51.180]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:51.180]                     envir = parent.frame()) 
[10:27:51.180]                   {
[10:27:51.180]                     default_workers <- missing(workers)
[10:27:51.180]                     if (is.function(workers)) 
[10:27:51.180]                       workers <- workers()
[10:27:51.180]                     workers <- structure(as.integer(workers), 
[10:27:51.180]                       class = class(workers))
[10:27:51.180]                     stop_if_not(is.finite(workers), workers >= 
[10:27:51.180]                       1L)
[10:27:51.180]                     if ((workers == 1L && !inherits(workers, 
[10:27:51.180]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:51.180]                       if (default_workers) 
[10:27:51.180]                         supportsMulticore(warn = TRUE)
[10:27:51.180]                       return(sequential(..., envir = envir))
[10:27:51.180]                     }
[10:27:51.180]                     oopts <- options(mc.cores = workers)
[10:27:51.180]                     on.exit(options(oopts))
[10:27:51.180]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:51.180]                       envir = envir)
[10:27:51.180]                     if (!future$lazy) 
[10:27:51.180]                       future <- run(future)
[10:27:51.180]                     invisible(future)
[10:27:51.180]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:51.180]                 }
[10:27:51.180]             }
[10:27:51.180]         }
[10:27:51.180]     })
[10:27:51.180]     if (TRUE) {
[10:27:51.180]         base::sink(type = "output", split = FALSE)
[10:27:51.180]         if (FALSE) {
[10:27:51.180]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:51.180]         }
[10:27:51.180]         else {
[10:27:51.180]             ...future.result["stdout"] <- base::list(NULL)
[10:27:51.180]         }
[10:27:51.180]         base::close(...future.stdout)
[10:27:51.180]         ...future.stdout <- NULL
[10:27:51.180]     }
[10:27:51.180]     ...future.result$conditions <- ...future.conditions
[10:27:51.180]     ...future.result$finished <- base::Sys.time()
[10:27:51.180]     ...future.result
[10:27:51.180] }
[10:27:51.183] requestCore(): workers = 2
[10:27:51.185] MulticoreFuture started
[10:27:51.185] - Launch lazy future ... done
[10:27:51.186] run() for ‘MulticoreFuture’ ... done
[10:27:51.186] result() for MulticoreFuture ...
[10:27:51.187] plan(): Setting new future strategy stack:
[10:27:51.187] List of future strategies:
[10:27:51.187] 1. sequential:
[10:27:51.187]    - args: function (..., envir = parent.frame())
[10:27:51.187]    - tweaked: FALSE
[10:27:51.187]    - call: NULL
[10:27:51.188] plan(): nbrOfWorkers() = 1
[10:27:51.191] plan(): Setting new future strategy stack:
[10:27:51.191] List of future strategies:
[10:27:51.191] 1. multicore:
[10:27:51.191]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:51.191]    - tweaked: FALSE
[10:27:51.191]    - call: plan(strategy)
[10:27:51.197] plan(): nbrOfWorkers() = 2
[10:27:51.198] result() for MulticoreFuture ...
[10:27:51.198] result() for MulticoreFuture ... done
[10:27:51.198] result() for MulticoreFuture ... done
[10:27:51.198] result() for MulticoreFuture ...
[10:27:51.198] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[10:27:51.199] getGlobalsAndPackages() ...
[10:27:51.199] Searching for globals...
[10:27:51.200] - globals found: [1] ‘print’
[10:27:51.200] Searching for globals ... DONE
[10:27:51.200] Resolving globals: FALSE
[10:27:51.200] 
[10:27:51.200] 
[10:27:51.200] getGlobalsAndPackages() ... DONE
[10:27:51.201] run() for ‘Future’ ...
[10:27:51.201] - state: ‘created’
[10:27:51.201] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:51.205] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:51.205] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:51.206]   - Field: ‘label’
[10:27:51.206]   - Field: ‘local’
[10:27:51.206]   - Field: ‘owner’
[10:27:51.206]   - Field: ‘envir’
[10:27:51.206]   - Field: ‘workers’
[10:27:51.206]   - Field: ‘packages’
[10:27:51.206]   - Field: ‘gc’
[10:27:51.206]   - Field: ‘job’
[10:27:51.207]   - Field: ‘conditions’
[10:27:51.207]   - Field: ‘expr’
[10:27:51.207]   - Field: ‘uuid’
[10:27:51.207]   - Field: ‘seed’
[10:27:51.207]   - Field: ‘version’
[10:27:51.207]   - Field: ‘result’
[10:27:51.207]   - Field: ‘asynchronous’
[10:27:51.207]   - Field: ‘calls’
[10:27:51.207]   - Field: ‘globals’
[10:27:51.208]   - Field: ‘stdout’
[10:27:51.208]   - Field: ‘earlySignal’
[10:27:51.208]   - Field: ‘lazy’
[10:27:51.208]   - Field: ‘state’
[10:27:51.208] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:51.208] - Launch lazy future ...
[10:27:51.208] Packages needed by the future expression (n = 0): <none>
[10:27:51.209] Packages needed by future strategies (n = 0): <none>
[10:27:51.209] {
[10:27:51.209]     {
[10:27:51.209]         {
[10:27:51.209]             ...future.startTime <- base::Sys.time()
[10:27:51.209]             {
[10:27:51.209]                 {
[10:27:51.209]                   {
[10:27:51.209]                     {
[10:27:51.209]                       base::local({
[10:27:51.209]                         has_future <- base::requireNamespace("future", 
[10:27:51.209]                           quietly = TRUE)
[10:27:51.209]                         if (has_future) {
[10:27:51.209]                           ns <- base::getNamespace("future")
[10:27:51.209]                           version <- ns[[".package"]][["version"]]
[10:27:51.209]                           if (is.null(version)) 
[10:27:51.209]                             version <- utils::packageVersion("future")
[10:27:51.209]                         }
[10:27:51.209]                         else {
[10:27:51.209]                           version <- NULL
[10:27:51.209]                         }
[10:27:51.209]                         if (!has_future || version < "1.8.0") {
[10:27:51.209]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:51.209]                             "", base::R.version$version.string), 
[10:27:51.209]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:51.209]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:51.209]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:51.209]                               "release", "version")], collapse = " "), 
[10:27:51.209]                             hostname = base::Sys.info()[["nodename"]])
[10:27:51.209]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:51.209]                             info)
[10:27:51.209]                           info <- base::paste(info, collapse = "; ")
[10:27:51.209]                           if (!has_future) {
[10:27:51.209]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:51.209]                               info)
[10:27:51.209]                           }
[10:27:51.209]                           else {
[10:27:51.209]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:51.209]                               info, version)
[10:27:51.209]                           }
[10:27:51.209]                           base::stop(msg)
[10:27:51.209]                         }
[10:27:51.209]                       })
[10:27:51.209]                     }
[10:27:51.209]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:51.209]                     base::options(mc.cores = 1L)
[10:27:51.209]                   }
[10:27:51.209]                   options(future.plan = NULL)
[10:27:51.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:51.209]                 }
[10:27:51.209]                 ...future.workdir <- getwd()
[10:27:51.209]             }
[10:27:51.209]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:51.209]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:51.209]         }
[10:27:51.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:51.209]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:51.209]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:51.209]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:51.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:51.209]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:51.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:51.209]             base::names(...future.oldOptions))
[10:27:51.209]     }
[10:27:51.209]     if (FALSE) {
[10:27:51.209]     }
[10:27:51.209]     else {
[10:27:51.209]         if (TRUE) {
[10:27:51.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:51.209]                 open = "w")
[10:27:51.209]         }
[10:27:51.209]         else {
[10:27:51.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:51.209]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:51.209]         }
[10:27:51.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:51.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:51.209]             base::sink(type = "output", split = FALSE)
[10:27:51.209]             base::close(...future.stdout)
[10:27:51.209]         }, add = TRUE)
[10:27:51.209]     }
[10:27:51.209]     ...future.frame <- base::sys.nframe()
[10:27:51.209]     ...future.conditions <- base::list()
[10:27:51.209]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:51.209]     if (FALSE) {
[10:27:51.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:51.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:51.209]     }
[10:27:51.209]     ...future.result <- base::tryCatch({
[10:27:51.209]         base::withCallingHandlers({
[10:27:51.209]             ...future.value <- base::withVisible(base::local({
[10:27:51.209]                 withCallingHandlers({
[10:27:51.209]                   print(42)
[10:27:51.209]                 }, immediateCondition = function(cond) {
[10:27:51.209]                   save_rds <- function (object, pathname, ...) 
[10:27:51.209]                   {
[10:27:51.209]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:51.209]                     if (file_test("-f", pathname_tmp)) {
[10:27:51.209]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.209]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:51.209]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.209]                         fi_tmp[["mtime"]])
[10:27:51.209]                     }
[10:27:51.209]                     tryCatch({
[10:27:51.209]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:51.209]                     }, error = function(ex) {
[10:27:51.209]                       msg <- conditionMessage(ex)
[10:27:51.209]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.209]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:51.209]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.209]                         fi_tmp[["mtime"]], msg)
[10:27:51.209]                       ex$message <- msg
[10:27:51.209]                       stop(ex)
[10:27:51.209]                     })
[10:27:51.209]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:51.209]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:51.209]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:51.209]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.209]                       fi <- file.info(pathname)
[10:27:51.209]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:51.209]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.209]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:51.209]                         fi[["size"]], fi[["mtime"]])
[10:27:51.209]                       stop(msg)
[10:27:51.209]                     }
[10:27:51.209]                     invisible(pathname)
[10:27:51.209]                   }
[10:27:51.209]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:51.209]                     rootPath = tempdir()) 
[10:27:51.209]                   {
[10:27:51.209]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:51.209]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:51.209]                       tmpdir = path, fileext = ".rds")
[10:27:51.209]                     save_rds(obj, file)
[10:27:51.209]                   }
[10:27:51.209]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3JSlqb/.future/immediateConditions")
[10:27:51.209]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.209]                   {
[10:27:51.209]                     inherits <- base::inherits
[10:27:51.209]                     invokeRestart <- base::invokeRestart
[10:27:51.209]                     is.null <- base::is.null
[10:27:51.209]                     muffled <- FALSE
[10:27:51.209]                     if (inherits(cond, "message")) {
[10:27:51.209]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:51.209]                       if (muffled) 
[10:27:51.209]                         invokeRestart("muffleMessage")
[10:27:51.209]                     }
[10:27:51.209]                     else if (inherits(cond, "warning")) {
[10:27:51.209]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:51.209]                       if (muffled) 
[10:27:51.209]                         invokeRestart("muffleWarning")
[10:27:51.209]                     }
[10:27:51.209]                     else if (inherits(cond, "condition")) {
[10:27:51.209]                       if (!is.null(pattern)) {
[10:27:51.209]                         computeRestarts <- base::computeRestarts
[10:27:51.209]                         grepl <- base::grepl
[10:27:51.209]                         restarts <- computeRestarts(cond)
[10:27:51.209]                         for (restart in restarts) {
[10:27:51.209]                           name <- restart$name
[10:27:51.209]                           if (is.null(name)) 
[10:27:51.209]                             next
[10:27:51.209]                           if (!grepl(pattern, name)) 
[10:27:51.209]                             next
[10:27:51.209]                           invokeRestart(restart)
[10:27:51.209]                           muffled <- TRUE
[10:27:51.209]                           break
[10:27:51.209]                         }
[10:27:51.209]                       }
[10:27:51.209]                     }
[10:27:51.209]                     invisible(muffled)
[10:27:51.209]                   }
[10:27:51.209]                   muffleCondition(cond)
[10:27:51.209]                 })
[10:27:51.209]             }))
[10:27:51.209]             future::FutureResult(value = ...future.value$value, 
[10:27:51.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.209]                   ...future.rng), globalenv = if (FALSE) 
[10:27:51.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:51.209]                     ...future.globalenv.names))
[10:27:51.209]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:51.209]         }, condition = base::local({
[10:27:51.209]             c <- base::c
[10:27:51.209]             inherits <- base::inherits
[10:27:51.209]             invokeRestart <- base::invokeRestart
[10:27:51.209]             length <- base::length
[10:27:51.209]             list <- base::list
[10:27:51.209]             seq.int <- base::seq.int
[10:27:51.209]             signalCondition <- base::signalCondition
[10:27:51.209]             sys.calls <- base::sys.calls
[10:27:51.209]             `[[` <- base::`[[`
[10:27:51.209]             `+` <- base::`+`
[10:27:51.209]             `<<-` <- base::`<<-`
[10:27:51.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:51.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:51.209]                   3L)]
[10:27:51.209]             }
[10:27:51.209]             function(cond) {
[10:27:51.209]                 is_error <- inherits(cond, "error")
[10:27:51.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:51.209]                   NULL)
[10:27:51.209]                 if (is_error) {
[10:27:51.209]                   sessionInformation <- function() {
[10:27:51.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:51.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:51.209]                       search = base::search(), system = base::Sys.info())
[10:27:51.209]                   }
[10:27:51.209]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:51.209]                     cond$call), session = sessionInformation(), 
[10:27:51.209]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:51.209]                   signalCondition(cond)
[10:27:51.209]                 }
[10:27:51.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:51.209]                 "immediateCondition"))) {
[10:27:51.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:51.209]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:51.209]                   if (TRUE && !signal) {
[10:27:51.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.209]                     {
[10:27:51.209]                       inherits <- base::inherits
[10:27:51.209]                       invokeRestart <- base::invokeRestart
[10:27:51.209]                       is.null <- base::is.null
[10:27:51.209]                       muffled <- FALSE
[10:27:51.209]                       if (inherits(cond, "message")) {
[10:27:51.209]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.209]                         if (muffled) 
[10:27:51.209]                           invokeRestart("muffleMessage")
[10:27:51.209]                       }
[10:27:51.209]                       else if (inherits(cond, "warning")) {
[10:27:51.209]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.209]                         if (muffled) 
[10:27:51.209]                           invokeRestart("muffleWarning")
[10:27:51.209]                       }
[10:27:51.209]                       else if (inherits(cond, "condition")) {
[10:27:51.209]                         if (!is.null(pattern)) {
[10:27:51.209]                           computeRestarts <- base::computeRestarts
[10:27:51.209]                           grepl <- base::grepl
[10:27:51.209]                           restarts <- computeRestarts(cond)
[10:27:51.209]                           for (restart in restarts) {
[10:27:51.209]                             name <- restart$name
[10:27:51.209]                             if (is.null(name)) 
[10:27:51.209]                               next
[10:27:51.209]                             if (!grepl(pattern, name)) 
[10:27:51.209]                               next
[10:27:51.209]                             invokeRestart(restart)
[10:27:51.209]                             muffled <- TRUE
[10:27:51.209]                             break
[10:27:51.209]                           }
[10:27:51.209]                         }
[10:27:51.209]                       }
[10:27:51.209]                       invisible(muffled)
[10:27:51.209]                     }
[10:27:51.209]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.209]                   }
[10:27:51.209]                 }
[10:27:51.209]                 else {
[10:27:51.209]                   if (TRUE) {
[10:27:51.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.209]                     {
[10:27:51.209]                       inherits <- base::inherits
[10:27:51.209]                       invokeRestart <- base::invokeRestart
[10:27:51.209]                       is.null <- base::is.null
[10:27:51.209]                       muffled <- FALSE
[10:27:51.209]                       if (inherits(cond, "message")) {
[10:27:51.209]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.209]                         if (muffled) 
[10:27:51.209]                           invokeRestart("muffleMessage")
[10:27:51.209]                       }
[10:27:51.209]                       else if (inherits(cond, "warning")) {
[10:27:51.209]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.209]                         if (muffled) 
[10:27:51.209]                           invokeRestart("muffleWarning")
[10:27:51.209]                       }
[10:27:51.209]                       else if (inherits(cond, "condition")) {
[10:27:51.209]                         if (!is.null(pattern)) {
[10:27:51.209]                           computeRestarts <- base::computeRestarts
[10:27:51.209]                           grepl <- base::grepl
[10:27:51.209]                           restarts <- computeRestarts(cond)
[10:27:51.209]                           for (restart in restarts) {
[10:27:51.209]                             name <- restart$name
[10:27:51.209]                             if (is.null(name)) 
[10:27:51.209]                               next
[10:27:51.209]                             if (!grepl(pattern, name)) 
[10:27:51.209]                               next
[10:27:51.209]                             invokeRestart(restart)
[10:27:51.209]                             muffled <- TRUE
[10:27:51.209]                             break
[10:27:51.209]                           }
[10:27:51.209]                         }
[10:27:51.209]                       }
[10:27:51.209]                       invisible(muffled)
[10:27:51.209]                     }
[10:27:51.209]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.209]                   }
[10:27:51.209]                 }
[10:27:51.209]             }
[10:27:51.209]         }))
[10:27:51.209]     }, error = function(ex) {
[10:27:51.209]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:51.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.209]                 ...future.rng), started = ...future.startTime, 
[10:27:51.209]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:51.209]             version = "1.8"), class = "FutureResult")
[10:27:51.209]     }, finally = {
[10:27:51.209]         if (!identical(...future.workdir, getwd())) 
[10:27:51.209]             setwd(...future.workdir)
[10:27:51.209]         {
[10:27:51.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:51.209]                 ...future.oldOptions$nwarnings <- NULL
[10:27:51.209]             }
[10:27:51.209]             base::options(...future.oldOptions)
[10:27:51.209]             if (.Platform$OS.type == "windows") {
[10:27:51.209]                 old_names <- names(...future.oldEnvVars)
[10:27:51.209]                 envs <- base::Sys.getenv()
[10:27:51.209]                 names <- names(envs)
[10:27:51.209]                 common <- intersect(names, old_names)
[10:27:51.209]                 added <- setdiff(names, old_names)
[10:27:51.209]                 removed <- setdiff(old_names, names)
[10:27:51.209]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:51.209]                   envs[common]]
[10:27:51.209]                 NAMES <- toupper(changed)
[10:27:51.209]                 args <- list()
[10:27:51.209]                 for (kk in seq_along(NAMES)) {
[10:27:51.209]                   name <- changed[[kk]]
[10:27:51.209]                   NAME <- NAMES[[kk]]
[10:27:51.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.209]                     next
[10:27:51.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.209]                 }
[10:27:51.209]                 NAMES <- toupper(added)
[10:27:51.209]                 for (kk in seq_along(NAMES)) {
[10:27:51.209]                   name <- added[[kk]]
[10:27:51.209]                   NAME <- NAMES[[kk]]
[10:27:51.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.209]                     next
[10:27:51.209]                   args[[name]] <- ""
[10:27:51.209]                 }
[10:27:51.209]                 NAMES <- toupper(removed)
[10:27:51.209]                 for (kk in seq_along(NAMES)) {
[10:27:51.209]                   name <- removed[[kk]]
[10:27:51.209]                   NAME <- NAMES[[kk]]
[10:27:51.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.209]                     next
[10:27:51.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.209]                 }
[10:27:51.209]                 if (length(args) > 0) 
[10:27:51.209]                   base::do.call(base::Sys.setenv, args = args)
[10:27:51.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:51.209]             }
[10:27:51.209]             else {
[10:27:51.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:51.209]             }
[10:27:51.209]             {
[10:27:51.209]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:51.209]                   0L) {
[10:27:51.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:51.209]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:51.209]                   base::options(opts)
[10:27:51.209]                 }
[10:27:51.209]                 {
[10:27:51.209]                   {
[10:27:51.209]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:51.209]                     NULL
[10:27:51.209]                   }
[10:27:51.209]                   options(future.plan = NULL)
[10:27:51.209]                   if (is.na(NA_character_)) 
[10:27:51.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:51.209]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:51.209]                     envir = parent.frame()) 
[10:27:51.209]                   {
[10:27:51.209]                     default_workers <- missing(workers)
[10:27:51.209]                     if (is.function(workers)) 
[10:27:51.209]                       workers <- workers()
[10:27:51.209]                     workers <- structure(as.integer(workers), 
[10:27:51.209]                       class = class(workers))
[10:27:51.209]                     stop_if_not(is.finite(workers), workers >= 
[10:27:51.209]                       1L)
[10:27:51.209]                     if ((workers == 1L && !inherits(workers, 
[10:27:51.209]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:51.209]                       if (default_workers) 
[10:27:51.209]                         supportsMulticore(warn = TRUE)
[10:27:51.209]                       return(sequential(..., envir = envir))
[10:27:51.209]                     }
[10:27:51.209]                     oopts <- options(mc.cores = workers)
[10:27:51.209]                     on.exit(options(oopts))
[10:27:51.209]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:51.209]                       envir = envir)
[10:27:51.209]                     if (!future$lazy) 
[10:27:51.209]                       future <- run(future)
[10:27:51.209]                     invisible(future)
[10:27:51.209]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:51.209]                 }
[10:27:51.209]             }
[10:27:51.209]         }
[10:27:51.209]     })
[10:27:51.209]     if (TRUE) {
[10:27:51.209]         base::sink(type = "output", split = FALSE)
[10:27:51.209]         if (TRUE) {
[10:27:51.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:51.209]         }
[10:27:51.209]         else {
[10:27:51.209]             ...future.result["stdout"] <- base::list(NULL)
[10:27:51.209]         }
[10:27:51.209]         base::close(...future.stdout)
[10:27:51.209]         ...future.stdout <- NULL
[10:27:51.209]     }
[10:27:51.209]     ...future.result$conditions <- ...future.conditions
[10:27:51.209]     ...future.result$finished <- base::Sys.time()
[10:27:51.209]     ...future.result
[10:27:51.209] }
[10:27:51.212] requestCore(): workers = 2
[10:27:51.214] MulticoreFuture started
[10:27:51.215] - Launch lazy future ... done
[10:27:51.215] run() for ‘MulticoreFuture’ ... done
[10:27:51.215] result() for MulticoreFuture ...
[10:27:51.215] plan(): Setting new future strategy stack:
[10:27:51.215] List of future strategies:
[10:27:51.215] 1. sequential:
[10:27:51.215]    - args: function (..., envir = parent.frame())
[10:27:51.215]    - tweaked: FALSE
[10:27:51.215]    - call: NULL
[10:27:51.216] plan(): nbrOfWorkers() = 1
[10:27:51.218] plan(): Setting new future strategy stack:
[10:27:51.219] List of future strategies:
[10:27:51.219] 1. multicore:
[10:27:51.219]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:51.219]    - tweaked: FALSE
[10:27:51.219]    - call: plan(strategy)
[10:27:51.223] plan(): nbrOfWorkers() = 2
[10:27:51.224] result() for MulticoreFuture ...
[10:27:51.225] result() for MulticoreFuture ... done
[10:27:51.225] result() for MulticoreFuture ... done
[10:27:51.225] result() for MulticoreFuture ...
[10:27:51.225] result() for MulticoreFuture ... done
[10:27:51.225] result() for MulticoreFuture ...
[10:27:51.225] result() for MulticoreFuture ... done
[1] 42
[10:27:51.225] result() for MulticoreFuture ...
[10:27:51.226] result() for MulticoreFuture ... done
- stdout = NA
[10:27:51.226] getGlobalsAndPackages() ...
[10:27:51.226] Searching for globals...
[10:27:51.233] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:51.233] Searching for globals ... DONE
[10:27:51.233] Resolving globals: FALSE
[10:27:51.234] 
[10:27:51.234] - packages: [1] ‘utils’
[10:27:51.234] getGlobalsAndPackages() ... DONE
[10:27:51.234] run() for ‘Future’ ...
[10:27:51.235] - state: ‘created’
[10:27:51.235] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:51.239] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:51.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:51.239]   - Field: ‘label’
[10:27:51.239]   - Field: ‘local’
[10:27:51.239]   - Field: ‘owner’
[10:27:51.240]   - Field: ‘envir’
[10:27:51.240]   - Field: ‘workers’
[10:27:51.240]   - Field: ‘packages’
[10:27:51.240]   - Field: ‘gc’
[10:27:51.240]   - Field: ‘job’
[10:27:51.240]   - Field: ‘conditions’
[10:27:51.240]   - Field: ‘expr’
[10:27:51.240]   - Field: ‘uuid’
[10:27:51.241]   - Field: ‘seed’
[10:27:51.241]   - Field: ‘version’
[10:27:51.241]   - Field: ‘result’
[10:27:51.241]   - Field: ‘asynchronous’
[10:27:51.241]   - Field: ‘calls’
[10:27:51.241]   - Field: ‘globals’
[10:27:51.241]   - Field: ‘stdout’
[10:27:51.241]   - Field: ‘earlySignal’
[10:27:51.242]   - Field: ‘lazy’
[10:27:51.242]   - Field: ‘state’
[10:27:51.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:51.242] - Launch lazy future ...
[10:27:51.242] Packages needed by the future expression (n = 1): ‘utils’
[10:27:51.242] Packages needed by future strategies (n = 0): <none>
[10:27:51.243] {
[10:27:51.243]     {
[10:27:51.243]         {
[10:27:51.243]             ...future.startTime <- base::Sys.time()
[10:27:51.243]             {
[10:27:51.243]                 {
[10:27:51.243]                   {
[10:27:51.243]                     {
[10:27:51.243]                       {
[10:27:51.243]                         base::local({
[10:27:51.243]                           has_future <- base::requireNamespace("future", 
[10:27:51.243]                             quietly = TRUE)
[10:27:51.243]                           if (has_future) {
[10:27:51.243]                             ns <- base::getNamespace("future")
[10:27:51.243]                             version <- ns[[".package"]][["version"]]
[10:27:51.243]                             if (is.null(version)) 
[10:27:51.243]                               version <- utils::packageVersion("future")
[10:27:51.243]                           }
[10:27:51.243]                           else {
[10:27:51.243]                             version <- NULL
[10:27:51.243]                           }
[10:27:51.243]                           if (!has_future || version < "1.8.0") {
[10:27:51.243]                             info <- base::c(r_version = base::gsub("R version ", 
[10:27:51.243]                               "", base::R.version$version.string), 
[10:27:51.243]                               platform = base::sprintf("%s (%s-bit)", 
[10:27:51.243]                                 base::R.version$platform, 8 * 
[10:27:51.243]                                   base::.Machine$sizeof.pointer), 
[10:27:51.243]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:51.243]                                 "release", "version")], collapse = " "), 
[10:27:51.243]                               hostname = base::Sys.info()[["nodename"]])
[10:27:51.243]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:27:51.243]                               info)
[10:27:51.243]                             info <- base::paste(info, collapse = "; ")
[10:27:51.243]                             if (!has_future) {
[10:27:51.243]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:51.243]                                 info)
[10:27:51.243]                             }
[10:27:51.243]                             else {
[10:27:51.243]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:51.243]                                 info, version)
[10:27:51.243]                             }
[10:27:51.243]                             base::stop(msg)
[10:27:51.243]                           }
[10:27:51.243]                         })
[10:27:51.243]                       }
[10:27:51.243]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:51.243]                       base::options(mc.cores = 1L)
[10:27:51.243]                     }
[10:27:51.243]                     base::local({
[10:27:51.243]                       for (pkg in "utils") {
[10:27:51.243]                         base::loadNamespace(pkg)
[10:27:51.243]                         base::library(pkg, character.only = TRUE)
[10:27:51.243]                       }
[10:27:51.243]                     })
[10:27:51.243]                   }
[10:27:51.243]                   options(future.plan = NULL)
[10:27:51.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:51.243]                 }
[10:27:51.243]                 ...future.workdir <- getwd()
[10:27:51.243]             }
[10:27:51.243]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:51.243]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:51.243]         }
[10:27:51.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:51.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:51.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:51.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:51.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:51.243]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:51.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:51.243]             base::names(...future.oldOptions))
[10:27:51.243]     }
[10:27:51.243]     if (TRUE) {
[10:27:51.243]     }
[10:27:51.243]     else {
[10:27:51.243]         if (NA) {
[10:27:51.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:51.243]                 open = "w")
[10:27:51.243]         }
[10:27:51.243]         else {
[10:27:51.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:51.243]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:51.243]         }
[10:27:51.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:51.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:51.243]             base::sink(type = "output", split = FALSE)
[10:27:51.243]             base::close(...future.stdout)
[10:27:51.243]         }, add = TRUE)
[10:27:51.243]     }
[10:27:51.243]     ...future.frame <- base::sys.nframe()
[10:27:51.243]     ...future.conditions <- base::list()
[10:27:51.243]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:51.243]     if (FALSE) {
[10:27:51.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:51.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:51.243]     }
[10:27:51.243]     ...future.result <- base::tryCatch({
[10:27:51.243]         base::withCallingHandlers({
[10:27:51.243]             ...future.value <- base::withVisible(base::local({
[10:27:51.243]                 withCallingHandlers({
[10:27:51.243]                   {
[10:27:51.243]                     print(1:50)
[10:27:51.243]                     str(1:50)
[10:27:51.243]                     cat(letters, sep = "-")
[10:27:51.243]                     cat(1:6, collapse = "\n")
[10:27:51.243]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:51.243]                     42L
[10:27:51.243]                   }
[10:27:51.243]                 }, immediateCondition = function(cond) {
[10:27:51.243]                   save_rds <- function (object, pathname, ...) 
[10:27:51.243]                   {
[10:27:51.243]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:51.243]                     if (file_test("-f", pathname_tmp)) {
[10:27:51.243]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.243]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:51.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.243]                         fi_tmp[["mtime"]])
[10:27:51.243]                     }
[10:27:51.243]                     tryCatch({
[10:27:51.243]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:51.243]                     }, error = function(ex) {
[10:27:51.243]                       msg <- conditionMessage(ex)
[10:27:51.243]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.243]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:51.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.243]                         fi_tmp[["mtime"]], msg)
[10:27:51.243]                       ex$message <- msg
[10:27:51.243]                       stop(ex)
[10:27:51.243]                     })
[10:27:51.243]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:51.243]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:51.243]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:51.243]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.243]                       fi <- file.info(pathname)
[10:27:51.243]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:51.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.243]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:51.243]                         fi[["size"]], fi[["mtime"]])
[10:27:51.243]                       stop(msg)
[10:27:51.243]                     }
[10:27:51.243]                     invisible(pathname)
[10:27:51.243]                   }
[10:27:51.243]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:51.243]                     rootPath = tempdir()) 
[10:27:51.243]                   {
[10:27:51.243]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:51.243]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:51.243]                       tmpdir = path, fileext = ".rds")
[10:27:51.243]                     save_rds(obj, file)
[10:27:51.243]                   }
[10:27:51.243]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3JSlqb/.future/immediateConditions")
[10:27:51.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.243]                   {
[10:27:51.243]                     inherits <- base::inherits
[10:27:51.243]                     invokeRestart <- base::invokeRestart
[10:27:51.243]                     is.null <- base::is.null
[10:27:51.243]                     muffled <- FALSE
[10:27:51.243]                     if (inherits(cond, "message")) {
[10:27:51.243]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:51.243]                       if (muffled) 
[10:27:51.243]                         invokeRestart("muffleMessage")
[10:27:51.243]                     }
[10:27:51.243]                     else if (inherits(cond, "warning")) {
[10:27:51.243]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:51.243]                       if (muffled) 
[10:27:51.243]                         invokeRestart("muffleWarning")
[10:27:51.243]                     }
[10:27:51.243]                     else if (inherits(cond, "condition")) {
[10:27:51.243]                       if (!is.null(pattern)) {
[10:27:51.243]                         computeRestarts <- base::computeRestarts
[10:27:51.243]                         grepl <- base::grepl
[10:27:51.243]                         restarts <- computeRestarts(cond)
[10:27:51.243]                         for (restart in restarts) {
[10:27:51.243]                           name <- restart$name
[10:27:51.243]                           if (is.null(name)) 
[10:27:51.243]                             next
[10:27:51.243]                           if (!grepl(pattern, name)) 
[10:27:51.243]                             next
[10:27:51.243]                           invokeRestart(restart)
[10:27:51.243]                           muffled <- TRUE
[10:27:51.243]                           break
[10:27:51.243]                         }
[10:27:51.243]                       }
[10:27:51.243]                     }
[10:27:51.243]                     invisible(muffled)
[10:27:51.243]                   }
[10:27:51.243]                   muffleCondition(cond)
[10:27:51.243]                 })
[10:27:51.243]             }))
[10:27:51.243]             future::FutureResult(value = ...future.value$value, 
[10:27:51.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.243]                   ...future.rng), globalenv = if (FALSE) 
[10:27:51.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:51.243]                     ...future.globalenv.names))
[10:27:51.243]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:51.243]         }, condition = base::local({
[10:27:51.243]             c <- base::c
[10:27:51.243]             inherits <- base::inherits
[10:27:51.243]             invokeRestart <- base::invokeRestart
[10:27:51.243]             length <- base::length
[10:27:51.243]             list <- base::list
[10:27:51.243]             seq.int <- base::seq.int
[10:27:51.243]             signalCondition <- base::signalCondition
[10:27:51.243]             sys.calls <- base::sys.calls
[10:27:51.243]             `[[` <- base::`[[`
[10:27:51.243]             `+` <- base::`+`
[10:27:51.243]             `<<-` <- base::`<<-`
[10:27:51.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:51.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:51.243]                   3L)]
[10:27:51.243]             }
[10:27:51.243]             function(cond) {
[10:27:51.243]                 is_error <- inherits(cond, "error")
[10:27:51.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:51.243]                   NULL)
[10:27:51.243]                 if (is_error) {
[10:27:51.243]                   sessionInformation <- function() {
[10:27:51.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:51.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:51.243]                       search = base::search(), system = base::Sys.info())
[10:27:51.243]                   }
[10:27:51.243]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:51.243]                     cond$call), session = sessionInformation(), 
[10:27:51.243]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:51.243]                   signalCondition(cond)
[10:27:51.243]                 }
[10:27:51.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:51.243]                 "immediateCondition"))) {
[10:27:51.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:51.243]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:51.243]                   if (TRUE && !signal) {
[10:27:51.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.243]                     {
[10:27:51.243]                       inherits <- base::inherits
[10:27:51.243]                       invokeRestart <- base::invokeRestart
[10:27:51.243]                       is.null <- base::is.null
[10:27:51.243]                       muffled <- FALSE
[10:27:51.243]                       if (inherits(cond, "message")) {
[10:27:51.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.243]                         if (muffled) 
[10:27:51.243]                           invokeRestart("muffleMessage")
[10:27:51.243]                       }
[10:27:51.243]                       else if (inherits(cond, "warning")) {
[10:27:51.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.243]                         if (muffled) 
[10:27:51.243]                           invokeRestart("muffleWarning")
[10:27:51.243]                       }
[10:27:51.243]                       else if (inherits(cond, "condition")) {
[10:27:51.243]                         if (!is.null(pattern)) {
[10:27:51.243]                           computeRestarts <- base::computeRestarts
[10:27:51.243]                           grepl <- base::grepl
[10:27:51.243]                           restarts <- computeRestarts(cond)
[10:27:51.243]                           for (restart in restarts) {
[10:27:51.243]                             name <- restart$name
[10:27:51.243]                             if (is.null(name)) 
[10:27:51.243]                               next
[10:27:51.243]                             if (!grepl(pattern, name)) 
[10:27:51.243]                               next
[10:27:51.243]                             invokeRestart(restart)
[10:27:51.243]                             muffled <- TRUE
[10:27:51.243]                             break
[10:27:51.243]                           }
[10:27:51.243]                         }
[10:27:51.243]                       }
[10:27:51.243]                       invisible(muffled)
[10:27:51.243]                     }
[10:27:51.243]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.243]                   }
[10:27:51.243]                 }
[10:27:51.243]                 else {
[10:27:51.243]                   if (TRUE) {
[10:27:51.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.243]                     {
[10:27:51.243]                       inherits <- base::inherits
[10:27:51.243]                       invokeRestart <- base::invokeRestart
[10:27:51.243]                       is.null <- base::is.null
[10:27:51.243]                       muffled <- FALSE
[10:27:51.243]                       if (inherits(cond, "message")) {
[10:27:51.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.243]                         if (muffled) 
[10:27:51.243]                           invokeRestart("muffleMessage")
[10:27:51.243]                       }
[10:27:51.243]                       else if (inherits(cond, "warning")) {
[10:27:51.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.243]                         if (muffled) 
[10:27:51.243]                           invokeRestart("muffleWarning")
[10:27:51.243]                       }
[10:27:51.243]                       else if (inherits(cond, "condition")) {
[10:27:51.243]                         if (!is.null(pattern)) {
[10:27:51.243]                           computeRestarts <- base::computeRestarts
[10:27:51.243]                           grepl <- base::grepl
[10:27:51.243]                           restarts <- computeRestarts(cond)
[10:27:51.243]                           for (restart in restarts) {
[10:27:51.243]                             name <- restart$name
[10:27:51.243]                             if (is.null(name)) 
[10:27:51.243]                               next
[10:27:51.243]                             if (!grepl(pattern, name)) 
[10:27:51.243]                               next
[10:27:51.243]                             invokeRestart(restart)
[10:27:51.243]                             muffled <- TRUE
[10:27:51.243]                             break
[10:27:51.243]                           }
[10:27:51.243]                         }
[10:27:51.243]                       }
[10:27:51.243]                       invisible(muffled)
[10:27:51.243]                     }
[10:27:51.243]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.243]                   }
[10:27:51.243]                 }
[10:27:51.243]             }
[10:27:51.243]         }))
[10:27:51.243]     }, error = function(ex) {
[10:27:51.243]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:51.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.243]                 ...future.rng), started = ...future.startTime, 
[10:27:51.243]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:51.243]             version = "1.8"), class = "FutureResult")
[10:27:51.243]     }, finally = {
[10:27:51.243]         if (!identical(...future.workdir, getwd())) 
[10:27:51.243]             setwd(...future.workdir)
[10:27:51.243]         {
[10:27:51.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:51.243]                 ...future.oldOptions$nwarnings <- NULL
[10:27:51.243]             }
[10:27:51.243]             base::options(...future.oldOptions)
[10:27:51.243]             if (.Platform$OS.type == "windows") {
[10:27:51.243]                 old_names <- names(...future.oldEnvVars)
[10:27:51.243]                 envs <- base::Sys.getenv()
[10:27:51.243]                 names <- names(envs)
[10:27:51.243]                 common <- intersect(names, old_names)
[10:27:51.243]                 added <- setdiff(names, old_names)
[10:27:51.243]                 removed <- setdiff(old_names, names)
[10:27:51.243]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:51.243]                   envs[common]]
[10:27:51.243]                 NAMES <- toupper(changed)
[10:27:51.243]                 args <- list()
[10:27:51.243]                 for (kk in seq_along(NAMES)) {
[10:27:51.243]                   name <- changed[[kk]]
[10:27:51.243]                   NAME <- NAMES[[kk]]
[10:27:51.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.243]                     next
[10:27:51.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.243]                 }
[10:27:51.243]                 NAMES <- toupper(added)
[10:27:51.243]                 for (kk in seq_along(NAMES)) {
[10:27:51.243]                   name <- added[[kk]]
[10:27:51.243]                   NAME <- NAMES[[kk]]
[10:27:51.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.243]                     next
[10:27:51.243]                   args[[name]] <- ""
[10:27:51.243]                 }
[10:27:51.243]                 NAMES <- toupper(removed)
[10:27:51.243]                 for (kk in seq_along(NAMES)) {
[10:27:51.243]                   name <- removed[[kk]]
[10:27:51.243]                   NAME <- NAMES[[kk]]
[10:27:51.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.243]                     next
[10:27:51.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.243]                 }
[10:27:51.243]                 if (length(args) > 0) 
[10:27:51.243]                   base::do.call(base::Sys.setenv, args = args)
[10:27:51.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:51.243]             }
[10:27:51.243]             else {
[10:27:51.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:51.243]             }
[10:27:51.243]             {
[10:27:51.243]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:51.243]                   0L) {
[10:27:51.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:51.243]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:51.243]                   base::options(opts)
[10:27:51.243]                 }
[10:27:51.243]                 {
[10:27:51.243]                   {
[10:27:51.243]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:51.243]                     NULL
[10:27:51.243]                   }
[10:27:51.243]                   options(future.plan = NULL)
[10:27:51.243]                   if (is.na(NA_character_)) 
[10:27:51.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:51.243]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:51.243]                     envir = parent.frame()) 
[10:27:51.243]                   {
[10:27:51.243]                     default_workers <- missing(workers)
[10:27:51.243]                     if (is.function(workers)) 
[10:27:51.243]                       workers <- workers()
[10:27:51.243]                     workers <- structure(as.integer(workers), 
[10:27:51.243]                       class = class(workers))
[10:27:51.243]                     stop_if_not(is.finite(workers), workers >= 
[10:27:51.243]                       1L)
[10:27:51.243]                     if ((workers == 1L && !inherits(workers, 
[10:27:51.243]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:51.243]                       if (default_workers) 
[10:27:51.243]                         supportsMulticore(warn = TRUE)
[10:27:51.243]                       return(sequential(..., envir = envir))
[10:27:51.243]                     }
[10:27:51.243]                     oopts <- options(mc.cores = workers)
[10:27:51.243]                     on.exit(options(oopts))
[10:27:51.243]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:51.243]                       envir = envir)
[10:27:51.243]                     if (!future$lazy) 
[10:27:51.243]                       future <- run(future)
[10:27:51.243]                     invisible(future)
[10:27:51.243]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:51.243]                 }
[10:27:51.243]             }
[10:27:51.243]         }
[10:27:51.243]     })
[10:27:51.243]     if (FALSE) {
[10:27:51.243]         base::sink(type = "output", split = FALSE)
[10:27:51.243]         if (NA) {
[10:27:51.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:51.243]         }
[10:27:51.243]         else {
[10:27:51.243]             ...future.result["stdout"] <- base::list(NULL)
[10:27:51.243]         }
[10:27:51.243]         base::close(...future.stdout)
[10:27:51.243]         ...future.stdout <- NULL
[10:27:51.243]     }
[10:27:51.243]     ...future.result$conditions <- ...future.conditions
[10:27:51.243]     ...future.result$finished <- base::Sys.time()
[10:27:51.243]     ...future.result
[10:27:51.243] }
[10:27:51.246] requestCore(): workers = 2
[10:27:51.248] MulticoreFuture started
[10:27:51.248] - Launch lazy future ... done
[10:27:51.248] run() for ‘MulticoreFuture’ ... done
[10:27:51.249] result() for MulticoreFuture ...
[10:27:51.250] plan(): Setting new future strategy stack:
[10:27:51.250] List of future strategies:
[10:27:51.250] 1. sequential:
[10:27:51.250]    - args: function (..., envir = parent.frame())
[10:27:51.250]    - tweaked: FALSE
[10:27:51.250]    - call: NULL
[10:27:51.251] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[10:27:51.254] plan(): Setting new future strategy stack:
[10:27:51.255] List of future strategies:
[10:27:51.255] 1. multicore:
[10:27:51.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:51.255]    - tweaked: FALSE
[10:27:51.255]    - call: plan(strategy)
[10:27:51.260] plan(): nbrOfWorkers() = 2
[10:27:51.261] result() for MulticoreFuture ...
[10:27:51.261] result() for MulticoreFuture ... done
[10:27:51.261] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 10:27:51"
 $ finished    : POSIXct[1:1], format: "2025-01-07 10:27:51"
 $ session_uuid: chr "13209d97-ec8a-bb86-c670-ee1acbada57d"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3e863ac79bce"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92703
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 10:27:51"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:27:51.271] result() for MulticoreFuture ...
[10:27:51.271] result() for MulticoreFuture ... done
[10:27:51.271] result() for MulticoreFuture ...
[10:27:51.271] result() for MulticoreFuture ... done
[10:27:51.271] getGlobalsAndPackages() ...
[10:27:51.271] Searching for globals...
[10:27:51.275] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:51.275] Searching for globals ... DONE
[10:27:51.276] Resolving globals: FALSE
[10:27:51.276] 
[10:27:51.276] - packages: [1] ‘utils’
[10:27:51.276] getGlobalsAndPackages() ... DONE
[10:27:51.277] run() for ‘Future’ ...
[10:27:51.277] - state: ‘created’
[10:27:51.277] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:51.284] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:51.284] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:51.284]   - Field: ‘label’
[10:27:51.284]   - Field: ‘local’
[10:27:51.284]   - Field: ‘owner’
[10:27:51.284]   - Field: ‘envir’
[10:27:51.285]   - Field: ‘workers’
[10:27:51.285]   - Field: ‘packages’
[10:27:51.285]   - Field: ‘gc’
[10:27:51.285]   - Field: ‘job’
[10:27:51.285]   - Field: ‘conditions’
[10:27:51.285]   - Field: ‘expr’
[10:27:51.285]   - Field: ‘uuid’
[10:27:51.285]   - Field: ‘seed’
[10:27:51.286]   - Field: ‘version’
[10:27:51.286]   - Field: ‘result’
[10:27:51.286]   - Field: ‘asynchronous’
[10:27:51.286]   - Field: ‘calls’
[10:27:51.286]   - Field: ‘globals’
[10:27:51.286]   - Field: ‘stdout’
[10:27:51.286]   - Field: ‘earlySignal’
[10:27:51.286]   - Field: ‘lazy’
[10:27:51.287]   - Field: ‘state’
[10:27:51.287] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:51.287] - Launch lazy future ...
[10:27:51.287] Packages needed by the future expression (n = 1): ‘utils’
[10:27:51.287] Packages needed by future strategies (n = 0): <none>
[10:27:51.288] {
[10:27:51.288]     {
[10:27:51.288]         {
[10:27:51.288]             ...future.startTime <- base::Sys.time()
[10:27:51.288]             {
[10:27:51.288]                 {
[10:27:51.288]                   {
[10:27:51.288]                     {
[10:27:51.288]                       {
[10:27:51.288]                         base::local({
[10:27:51.288]                           has_future <- base::requireNamespace("future", 
[10:27:51.288]                             quietly = TRUE)
[10:27:51.288]                           if (has_future) {
[10:27:51.288]                             ns <- base::getNamespace("future")
[10:27:51.288]                             version <- ns[[".package"]][["version"]]
[10:27:51.288]                             if (is.null(version)) 
[10:27:51.288]                               version <- utils::packageVersion("future")
[10:27:51.288]                           }
[10:27:51.288]                           else {
[10:27:51.288]                             version <- NULL
[10:27:51.288]                           }
[10:27:51.288]                           if (!has_future || version < "1.8.0") {
[10:27:51.288]                             info <- base::c(r_version = base::gsub("R version ", 
[10:27:51.288]                               "", base::R.version$version.string), 
[10:27:51.288]                               platform = base::sprintf("%s (%s-bit)", 
[10:27:51.288]                                 base::R.version$platform, 8 * 
[10:27:51.288]                                   base::.Machine$sizeof.pointer), 
[10:27:51.288]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:51.288]                                 "release", "version")], collapse = " "), 
[10:27:51.288]                               hostname = base::Sys.info()[["nodename"]])
[10:27:51.288]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:27:51.288]                               info)
[10:27:51.288]                             info <- base::paste(info, collapse = "; ")
[10:27:51.288]                             if (!has_future) {
[10:27:51.288]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:51.288]                                 info)
[10:27:51.288]                             }
[10:27:51.288]                             else {
[10:27:51.288]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:51.288]                                 info, version)
[10:27:51.288]                             }
[10:27:51.288]                             base::stop(msg)
[10:27:51.288]                           }
[10:27:51.288]                         })
[10:27:51.288]                       }
[10:27:51.288]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:51.288]                       base::options(mc.cores = 1L)
[10:27:51.288]                     }
[10:27:51.288]                     base::local({
[10:27:51.288]                       for (pkg in "utils") {
[10:27:51.288]                         base::loadNamespace(pkg)
[10:27:51.288]                         base::library(pkg, character.only = TRUE)
[10:27:51.288]                       }
[10:27:51.288]                     })
[10:27:51.288]                   }
[10:27:51.288]                   options(future.plan = NULL)
[10:27:51.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:51.288]                 }
[10:27:51.288]                 ...future.workdir <- getwd()
[10:27:51.288]             }
[10:27:51.288]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:51.288]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:51.288]         }
[10:27:51.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:51.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:51.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:51.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:51.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:51.288]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:51.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:51.288]             base::names(...future.oldOptions))
[10:27:51.288]     }
[10:27:51.288]     if (TRUE) {
[10:27:51.288]     }
[10:27:51.288]     else {
[10:27:51.288]         if (NA) {
[10:27:51.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:51.288]                 open = "w")
[10:27:51.288]         }
[10:27:51.288]         else {
[10:27:51.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:51.288]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:51.288]         }
[10:27:51.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:51.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:51.288]             base::sink(type = "output", split = FALSE)
[10:27:51.288]             base::close(...future.stdout)
[10:27:51.288]         }, add = TRUE)
[10:27:51.288]     }
[10:27:51.288]     ...future.frame <- base::sys.nframe()
[10:27:51.288]     ...future.conditions <- base::list()
[10:27:51.288]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:51.288]     if (FALSE) {
[10:27:51.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:51.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:51.288]     }
[10:27:51.288]     ...future.result <- base::tryCatch({
[10:27:51.288]         base::withCallingHandlers({
[10:27:51.288]             ...future.value <- base::withVisible(base::local({
[10:27:51.288]                 withCallingHandlers({
[10:27:51.288]                   {
[10:27:51.288]                     print(1:50)
[10:27:51.288]                     str(1:50)
[10:27:51.288]                     cat(letters, sep = "-")
[10:27:51.288]                     cat(1:6, collapse = "\n")
[10:27:51.288]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:51.288]                     42L
[10:27:51.288]                   }
[10:27:51.288]                 }, immediateCondition = function(cond) {
[10:27:51.288]                   save_rds <- function (object, pathname, ...) 
[10:27:51.288]                   {
[10:27:51.288]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:51.288]                     if (file_test("-f", pathname_tmp)) {
[10:27:51.288]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.288]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:51.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.288]                         fi_tmp[["mtime"]])
[10:27:51.288]                     }
[10:27:51.288]                     tryCatch({
[10:27:51.288]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:51.288]                     }, error = function(ex) {
[10:27:51.288]                       msg <- conditionMessage(ex)
[10:27:51.288]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.288]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:51.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.288]                         fi_tmp[["mtime"]], msg)
[10:27:51.288]                       ex$message <- msg
[10:27:51.288]                       stop(ex)
[10:27:51.288]                     })
[10:27:51.288]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:51.288]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:51.288]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:51.288]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.288]                       fi <- file.info(pathname)
[10:27:51.288]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:51.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.288]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:51.288]                         fi[["size"]], fi[["mtime"]])
[10:27:51.288]                       stop(msg)
[10:27:51.288]                     }
[10:27:51.288]                     invisible(pathname)
[10:27:51.288]                   }
[10:27:51.288]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:51.288]                     rootPath = tempdir()) 
[10:27:51.288]                   {
[10:27:51.288]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:51.288]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:51.288]                       tmpdir = path, fileext = ".rds")
[10:27:51.288]                     save_rds(obj, file)
[10:27:51.288]                   }
[10:27:51.288]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3JSlqb/.future/immediateConditions")
[10:27:51.288]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.288]                   {
[10:27:51.288]                     inherits <- base::inherits
[10:27:51.288]                     invokeRestart <- base::invokeRestart
[10:27:51.288]                     is.null <- base::is.null
[10:27:51.288]                     muffled <- FALSE
[10:27:51.288]                     if (inherits(cond, "message")) {
[10:27:51.288]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:51.288]                       if (muffled) 
[10:27:51.288]                         invokeRestart("muffleMessage")
[10:27:51.288]                     }
[10:27:51.288]                     else if (inherits(cond, "warning")) {
[10:27:51.288]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:51.288]                       if (muffled) 
[10:27:51.288]                         invokeRestart("muffleWarning")
[10:27:51.288]                     }
[10:27:51.288]                     else if (inherits(cond, "condition")) {
[10:27:51.288]                       if (!is.null(pattern)) {
[10:27:51.288]                         computeRestarts <- base::computeRestarts
[10:27:51.288]                         grepl <- base::grepl
[10:27:51.288]                         restarts <- computeRestarts(cond)
[10:27:51.288]                         for (restart in restarts) {
[10:27:51.288]                           name <- restart$name
[10:27:51.288]                           if (is.null(name)) 
[10:27:51.288]                             next
[10:27:51.288]                           if (!grepl(pattern, name)) 
[10:27:51.288]                             next
[10:27:51.288]                           invokeRestart(restart)
[10:27:51.288]                           muffled <- TRUE
[10:27:51.288]                           break
[10:27:51.288]                         }
[10:27:51.288]                       }
[10:27:51.288]                     }
[10:27:51.288]                     invisible(muffled)
[10:27:51.288]                   }
[10:27:51.288]                   muffleCondition(cond)
[10:27:51.288]                 })
[10:27:51.288]             }))
[10:27:51.288]             future::FutureResult(value = ...future.value$value, 
[10:27:51.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.288]                   ...future.rng), globalenv = if (FALSE) 
[10:27:51.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:51.288]                     ...future.globalenv.names))
[10:27:51.288]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:51.288]         }, condition = base::local({
[10:27:51.288]             c <- base::c
[10:27:51.288]             inherits <- base::inherits
[10:27:51.288]             invokeRestart <- base::invokeRestart
[10:27:51.288]             length <- base::length
[10:27:51.288]             list <- base::list
[10:27:51.288]             seq.int <- base::seq.int
[10:27:51.288]             signalCondition <- base::signalCondition
[10:27:51.288]             sys.calls <- base::sys.calls
[10:27:51.288]             `[[` <- base::`[[`
[10:27:51.288]             `+` <- base::`+`
[10:27:51.288]             `<<-` <- base::`<<-`
[10:27:51.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:51.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:51.288]                   3L)]
[10:27:51.288]             }
[10:27:51.288]             function(cond) {
[10:27:51.288]                 is_error <- inherits(cond, "error")
[10:27:51.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:51.288]                   NULL)
[10:27:51.288]                 if (is_error) {
[10:27:51.288]                   sessionInformation <- function() {
[10:27:51.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:51.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:51.288]                       search = base::search(), system = base::Sys.info())
[10:27:51.288]                   }
[10:27:51.288]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:51.288]                     cond$call), session = sessionInformation(), 
[10:27:51.288]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:51.288]                   signalCondition(cond)
[10:27:51.288]                 }
[10:27:51.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:51.288]                 "immediateCondition"))) {
[10:27:51.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:51.288]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:51.288]                   if (TRUE && !signal) {
[10:27:51.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.288]                     {
[10:27:51.288]                       inherits <- base::inherits
[10:27:51.288]                       invokeRestart <- base::invokeRestart
[10:27:51.288]                       is.null <- base::is.null
[10:27:51.288]                       muffled <- FALSE
[10:27:51.288]                       if (inherits(cond, "message")) {
[10:27:51.288]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.288]                         if (muffled) 
[10:27:51.288]                           invokeRestart("muffleMessage")
[10:27:51.288]                       }
[10:27:51.288]                       else if (inherits(cond, "warning")) {
[10:27:51.288]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.288]                         if (muffled) 
[10:27:51.288]                           invokeRestart("muffleWarning")
[10:27:51.288]                       }
[10:27:51.288]                       else if (inherits(cond, "condition")) {
[10:27:51.288]                         if (!is.null(pattern)) {
[10:27:51.288]                           computeRestarts <- base::computeRestarts
[10:27:51.288]                           grepl <- base::grepl
[10:27:51.288]                           restarts <- computeRestarts(cond)
[10:27:51.288]                           for (restart in restarts) {
[10:27:51.288]                             name <- restart$name
[10:27:51.288]                             if (is.null(name)) 
[10:27:51.288]                               next
[10:27:51.288]                             if (!grepl(pattern, name)) 
[10:27:51.288]                               next
[10:27:51.288]                             invokeRestart(restart)
[10:27:51.288]                             muffled <- TRUE
[10:27:51.288]                             break
[10:27:51.288]                           }
[10:27:51.288]                         }
[10:27:51.288]                       }
[10:27:51.288]                       invisible(muffled)
[10:27:51.288]                     }
[10:27:51.288]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.288]                   }
[10:27:51.288]                 }
[10:27:51.288]                 else {
[10:27:51.288]                   if (TRUE) {
[10:27:51.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.288]                     {
[10:27:51.288]                       inherits <- base::inherits
[10:27:51.288]                       invokeRestart <- base::invokeRestart
[10:27:51.288]                       is.null <- base::is.null
[10:27:51.288]                       muffled <- FALSE
[10:27:51.288]                       if (inherits(cond, "message")) {
[10:27:51.288]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.288]                         if (muffled) 
[10:27:51.288]                           invokeRestart("muffleMessage")
[10:27:51.288]                       }
[10:27:51.288]                       else if (inherits(cond, "warning")) {
[10:27:51.288]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.288]                         if (muffled) 
[10:27:51.288]                           invokeRestart("muffleWarning")
[10:27:51.288]                       }
[10:27:51.288]                       else if (inherits(cond, "condition")) {
[10:27:51.288]                         if (!is.null(pattern)) {
[10:27:51.288]                           computeRestarts <- base::computeRestarts
[10:27:51.288]                           grepl <- base::grepl
[10:27:51.288]                           restarts <- computeRestarts(cond)
[10:27:51.288]                           for (restart in restarts) {
[10:27:51.288]                             name <- restart$name
[10:27:51.288]                             if (is.null(name)) 
[10:27:51.288]                               next
[10:27:51.288]                             if (!grepl(pattern, name)) 
[10:27:51.288]                               next
[10:27:51.288]                             invokeRestart(restart)
[10:27:51.288]                             muffled <- TRUE
[10:27:51.288]                             break
[10:27:51.288]                           }
[10:27:51.288]                         }
[10:27:51.288]                       }
[10:27:51.288]                       invisible(muffled)
[10:27:51.288]                     }
[10:27:51.288]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.288]                   }
[10:27:51.288]                 }
[10:27:51.288]             }
[10:27:51.288]         }))
[10:27:51.288]     }, error = function(ex) {
[10:27:51.288]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:51.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.288]                 ...future.rng), started = ...future.startTime, 
[10:27:51.288]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:51.288]             version = "1.8"), class = "FutureResult")
[10:27:51.288]     }, finally = {
[10:27:51.288]         if (!identical(...future.workdir, getwd())) 
[10:27:51.288]             setwd(...future.workdir)
[10:27:51.288]         {
[10:27:51.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:51.288]                 ...future.oldOptions$nwarnings <- NULL
[10:27:51.288]             }
[10:27:51.288]             base::options(...future.oldOptions)
[10:27:51.288]             if (.Platform$OS.type == "windows") {
[10:27:51.288]                 old_names <- names(...future.oldEnvVars)
[10:27:51.288]                 envs <- base::Sys.getenv()
[10:27:51.288]                 names <- names(envs)
[10:27:51.288]                 common <- intersect(names, old_names)
[10:27:51.288]                 added <- setdiff(names, old_names)
[10:27:51.288]                 removed <- setdiff(old_names, names)
[10:27:51.288]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:51.288]                   envs[common]]
[10:27:51.288]                 NAMES <- toupper(changed)
[10:27:51.288]                 args <- list()
[10:27:51.288]                 for (kk in seq_along(NAMES)) {
[10:27:51.288]                   name <- changed[[kk]]
[10:27:51.288]                   NAME <- NAMES[[kk]]
[10:27:51.288]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.288]                     next
[10:27:51.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.288]                 }
[10:27:51.288]                 NAMES <- toupper(added)
[10:27:51.288]                 for (kk in seq_along(NAMES)) {
[10:27:51.288]                   name <- added[[kk]]
[10:27:51.288]                   NAME <- NAMES[[kk]]
[10:27:51.288]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.288]                     next
[10:27:51.288]                   args[[name]] <- ""
[10:27:51.288]                 }
[10:27:51.288]                 NAMES <- toupper(removed)
[10:27:51.288]                 for (kk in seq_along(NAMES)) {
[10:27:51.288]                   name <- removed[[kk]]
[10:27:51.288]                   NAME <- NAMES[[kk]]
[10:27:51.288]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.288]                     next
[10:27:51.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.288]                 }
[10:27:51.288]                 if (length(args) > 0) 
[10:27:51.288]                   base::do.call(base::Sys.setenv, args = args)
[10:27:51.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:51.288]             }
[10:27:51.288]             else {
[10:27:51.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:51.288]             }
[10:27:51.288]             {
[10:27:51.288]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:51.288]                   0L) {
[10:27:51.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:51.288]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:51.288]                   base::options(opts)
[10:27:51.288]                 }
[10:27:51.288]                 {
[10:27:51.288]                   {
[10:27:51.288]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:51.288]                     NULL
[10:27:51.288]                   }
[10:27:51.288]                   options(future.plan = NULL)
[10:27:51.288]                   if (is.na(NA_character_)) 
[10:27:51.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:51.288]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:51.288]                     envir = parent.frame()) 
[10:27:51.288]                   {
[10:27:51.288]                     default_workers <- missing(workers)
[10:27:51.288]                     if (is.function(workers)) 
[10:27:51.288]                       workers <- workers()
[10:27:51.288]                     workers <- structure(as.integer(workers), 
[10:27:51.288]                       class = class(workers))
[10:27:51.288]                     stop_if_not(is.finite(workers), workers >= 
[10:27:51.288]                       1L)
[10:27:51.288]                     if ((workers == 1L && !inherits(workers, 
[10:27:51.288]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:51.288]                       if (default_workers) 
[10:27:51.288]                         supportsMulticore(warn = TRUE)
[10:27:51.288]                       return(sequential(..., envir = envir))
[10:27:51.288]                     }
[10:27:51.288]                     oopts <- options(mc.cores = workers)
[10:27:51.288]                     on.exit(options(oopts))
[10:27:51.288]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:51.288]                       envir = envir)
[10:27:51.288]                     if (!future$lazy) 
[10:27:51.288]                       future <- run(future)
[10:27:51.288]                     invisible(future)
[10:27:51.288]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:51.288]                 }
[10:27:51.288]             }
[10:27:51.288]         }
[10:27:51.288]     })
[10:27:51.288]     if (FALSE) {
[10:27:51.288]         base::sink(type = "output", split = FALSE)
[10:27:51.288]         if (NA) {
[10:27:51.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:51.288]         }
[10:27:51.288]         else {
[10:27:51.288]             ...future.result["stdout"] <- base::list(NULL)
[10:27:51.288]         }
[10:27:51.288]         base::close(...future.stdout)
[10:27:51.288]         ...future.stdout <- NULL
[10:27:51.288]     }
[10:27:51.288]     ...future.result$conditions <- ...future.conditions
[10:27:51.288]     ...future.result$finished <- base::Sys.time()
[10:27:51.288]     ...future.result
[10:27:51.288] }
[10:27:51.290] requestCore(): workers = 2
[10:27:51.293] MulticoreFuture started
[10:27:51.293] - Launch lazy future ... done
[10:27:51.293] run() for ‘MulticoreFuture’ ... done
[10:27:51.294] result() for MulticoreFuture ...
[10:27:51.294] plan(): Setting new future strategy stack:
[10:27:51.294] List of future strategies:
[10:27:51.294] 1. sequential:
[10:27:51.294]    - args: function (..., envir = parent.frame())
[10:27:51.294]    - tweaked: FALSE
[10:27:51.294]    - call: NULL
[10:27:51.295] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[10:27:51.299] plan(): Setting new future strategy stack:
[10:27:51.299] List of future strategies:
[10:27:51.299] 1. multicore:
[10:27:51.299]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:51.299]    - tweaked: FALSE
[10:27:51.299]    - call: plan(strategy)
[10:27:51.304] plan(): nbrOfWorkers() = 2
[10:27:51.305] result() for MulticoreFuture ...
[10:27:51.305] result() for MulticoreFuture ... done
[10:27:51.305] result() for MulticoreFuture ... done
[10:27:51.306] result() for MulticoreFuture ...
[10:27:51.306] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[10:27:51.306] getGlobalsAndPackages() ...
[10:27:51.306] Searching for globals...
[10:27:51.307] - globals found: [1] ‘print’
[10:27:51.307] Searching for globals ... DONE
[10:27:51.308] Resolving globals: FALSE
[10:27:51.308] 
[10:27:51.308] 
[10:27:51.308] getGlobalsAndPackages() ... DONE
[10:27:51.308] run() for ‘Future’ ...
[10:27:51.309] - state: ‘created’
[10:27:51.309] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:51.313] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:51.313] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:51.313]   - Field: ‘label’
[10:27:51.313]   - Field: ‘local’
[10:27:51.314]   - Field: ‘owner’
[10:27:51.314]   - Field: ‘envir’
[10:27:51.314]   - Field: ‘workers’
[10:27:51.314]   - Field: ‘packages’
[10:27:51.314]   - Field: ‘gc’
[10:27:51.314]   - Field: ‘job’
[10:27:51.314]   - Field: ‘conditions’
[10:27:51.314]   - Field: ‘expr’
[10:27:51.314]   - Field: ‘uuid’
[10:27:51.315]   - Field: ‘seed’
[10:27:51.315]   - Field: ‘version’
[10:27:51.315]   - Field: ‘result’
[10:27:51.315]   - Field: ‘asynchronous’
[10:27:51.315]   - Field: ‘calls’
[10:27:51.315]   - Field: ‘globals’
[10:27:51.315]   - Field: ‘stdout’
[10:27:51.315]   - Field: ‘earlySignal’
[10:27:51.316]   - Field: ‘lazy’
[10:27:51.316]   - Field: ‘state’
[10:27:51.316] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:51.316] - Launch lazy future ...
[10:27:51.316] Packages needed by the future expression (n = 0): <none>
[10:27:51.316] Packages needed by future strategies (n = 0): <none>
[10:27:51.317] {
[10:27:51.317]     {
[10:27:51.317]         {
[10:27:51.317]             ...future.startTime <- base::Sys.time()
[10:27:51.317]             {
[10:27:51.317]                 {
[10:27:51.317]                   {
[10:27:51.317]                     {
[10:27:51.317]                       base::local({
[10:27:51.317]                         has_future <- base::requireNamespace("future", 
[10:27:51.317]                           quietly = TRUE)
[10:27:51.317]                         if (has_future) {
[10:27:51.317]                           ns <- base::getNamespace("future")
[10:27:51.317]                           version <- ns[[".package"]][["version"]]
[10:27:51.317]                           if (is.null(version)) 
[10:27:51.317]                             version <- utils::packageVersion("future")
[10:27:51.317]                         }
[10:27:51.317]                         else {
[10:27:51.317]                           version <- NULL
[10:27:51.317]                         }
[10:27:51.317]                         if (!has_future || version < "1.8.0") {
[10:27:51.317]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:51.317]                             "", base::R.version$version.string), 
[10:27:51.317]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:51.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:51.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:51.317]                               "release", "version")], collapse = " "), 
[10:27:51.317]                             hostname = base::Sys.info()[["nodename"]])
[10:27:51.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:51.317]                             info)
[10:27:51.317]                           info <- base::paste(info, collapse = "; ")
[10:27:51.317]                           if (!has_future) {
[10:27:51.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:51.317]                               info)
[10:27:51.317]                           }
[10:27:51.317]                           else {
[10:27:51.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:51.317]                               info, version)
[10:27:51.317]                           }
[10:27:51.317]                           base::stop(msg)
[10:27:51.317]                         }
[10:27:51.317]                       })
[10:27:51.317]                     }
[10:27:51.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:51.317]                     base::options(mc.cores = 1L)
[10:27:51.317]                   }
[10:27:51.317]                   options(future.plan = NULL)
[10:27:51.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:51.317]                 }
[10:27:51.317]                 ...future.workdir <- getwd()
[10:27:51.317]             }
[10:27:51.317]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:51.317]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:51.317]         }
[10:27:51.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:51.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:51.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:51.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:51.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:51.317]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:51.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:51.317]             base::names(...future.oldOptions))
[10:27:51.317]     }
[10:27:51.317]     if (FALSE) {
[10:27:51.317]     }
[10:27:51.317]     else {
[10:27:51.317]         if (TRUE) {
[10:27:51.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:51.317]                 open = "w")
[10:27:51.317]         }
[10:27:51.317]         else {
[10:27:51.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:51.317]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:51.317]         }
[10:27:51.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:51.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:51.317]             base::sink(type = "output", split = FALSE)
[10:27:51.317]             base::close(...future.stdout)
[10:27:51.317]         }, add = TRUE)
[10:27:51.317]     }
[10:27:51.317]     ...future.frame <- base::sys.nframe()
[10:27:51.317]     ...future.conditions <- base::list()
[10:27:51.317]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:51.317]     if (FALSE) {
[10:27:51.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:51.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:51.317]     }
[10:27:51.317]     ...future.result <- base::tryCatch({
[10:27:51.317]         base::withCallingHandlers({
[10:27:51.317]             ...future.value <- base::withVisible(base::local({
[10:27:51.317]                 withCallingHandlers({
[10:27:51.317]                   print(42)
[10:27:51.317]                 }, immediateCondition = function(cond) {
[10:27:51.317]                   save_rds <- function (object, pathname, ...) 
[10:27:51.317]                   {
[10:27:51.317]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:51.317]                     if (file_test("-f", pathname_tmp)) {
[10:27:51.317]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.317]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:51.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.317]                         fi_tmp[["mtime"]])
[10:27:51.317]                     }
[10:27:51.317]                     tryCatch({
[10:27:51.317]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:51.317]                     }, error = function(ex) {
[10:27:51.317]                       msg <- conditionMessage(ex)
[10:27:51.317]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.317]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:51.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.317]                         fi_tmp[["mtime"]], msg)
[10:27:51.317]                       ex$message <- msg
[10:27:51.317]                       stop(ex)
[10:27:51.317]                     })
[10:27:51.317]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:51.317]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:51.317]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:51.317]                       fi_tmp <- file.info(pathname_tmp)
[10:27:51.317]                       fi <- file.info(pathname)
[10:27:51.317]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:51.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:51.317]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:51.317]                         fi[["size"]], fi[["mtime"]])
[10:27:51.317]                       stop(msg)
[10:27:51.317]                     }
[10:27:51.317]                     invisible(pathname)
[10:27:51.317]                   }
[10:27:51.317]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:51.317]                     rootPath = tempdir()) 
[10:27:51.317]                   {
[10:27:51.317]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:51.317]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:51.317]                       tmpdir = path, fileext = ".rds")
[10:27:51.317]                     save_rds(obj, file)
[10:27:51.317]                   }
[10:27:51.317]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3JSlqb/.future/immediateConditions")
[10:27:51.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.317]                   {
[10:27:51.317]                     inherits <- base::inherits
[10:27:51.317]                     invokeRestart <- base::invokeRestart
[10:27:51.317]                     is.null <- base::is.null
[10:27:51.317]                     muffled <- FALSE
[10:27:51.317]                     if (inherits(cond, "message")) {
[10:27:51.317]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:51.317]                       if (muffled) 
[10:27:51.317]                         invokeRestart("muffleMessage")
[10:27:51.317]                     }
[10:27:51.317]                     else if (inherits(cond, "warning")) {
[10:27:51.317]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:51.317]                       if (muffled) 
[10:27:51.317]                         invokeRestart("muffleWarning")
[10:27:51.317]                     }
[10:27:51.317]                     else if (inherits(cond, "condition")) {
[10:27:51.317]                       if (!is.null(pattern)) {
[10:27:51.317]                         computeRestarts <- base::computeRestarts
[10:27:51.317]                         grepl <- base::grepl
[10:27:51.317]                         restarts <- computeRestarts(cond)
[10:27:51.317]                         for (restart in restarts) {
[10:27:51.317]                           name <- restart$name
[10:27:51.317]                           if (is.null(name)) 
[10:27:51.317]                             next
[10:27:51.317]                           if (!grepl(pattern, name)) 
[10:27:51.317]                             next
[10:27:51.317]                           invokeRestart(restart)
[10:27:51.317]                           muffled <- TRUE
[10:27:51.317]                           break
[10:27:51.317]                         }
[10:27:51.317]                       }
[10:27:51.317]                     }
[10:27:51.317]                     invisible(muffled)
[10:27:51.317]                   }
[10:27:51.317]                   muffleCondition(cond)
[10:27:51.317]                 })
[10:27:51.317]             }))
[10:27:51.317]             future::FutureResult(value = ...future.value$value, 
[10:27:51.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.317]                   ...future.rng), globalenv = if (FALSE) 
[10:27:51.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:51.317]                     ...future.globalenv.names))
[10:27:51.317]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:51.317]         }, condition = base::local({
[10:27:51.317]             c <- base::c
[10:27:51.317]             inherits <- base::inherits
[10:27:51.317]             invokeRestart <- base::invokeRestart
[10:27:51.317]             length <- base::length
[10:27:51.317]             list <- base::list
[10:27:51.317]             seq.int <- base::seq.int
[10:27:51.317]             signalCondition <- base::signalCondition
[10:27:51.317]             sys.calls <- base::sys.calls
[10:27:51.317]             `[[` <- base::`[[`
[10:27:51.317]             `+` <- base::`+`
[10:27:51.317]             `<<-` <- base::`<<-`
[10:27:51.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:51.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:51.317]                   3L)]
[10:27:51.317]             }
[10:27:51.317]             function(cond) {
[10:27:51.317]                 is_error <- inherits(cond, "error")
[10:27:51.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:51.317]                   NULL)
[10:27:51.317]                 if (is_error) {
[10:27:51.317]                   sessionInformation <- function() {
[10:27:51.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:51.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:51.317]                       search = base::search(), system = base::Sys.info())
[10:27:51.317]                   }
[10:27:51.317]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:51.317]                     cond$call), session = sessionInformation(), 
[10:27:51.317]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:51.317]                   signalCondition(cond)
[10:27:51.317]                 }
[10:27:51.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:51.317]                 "immediateCondition"))) {
[10:27:51.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:51.317]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:51.317]                   if (TRUE && !signal) {
[10:27:51.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.317]                     {
[10:27:51.317]                       inherits <- base::inherits
[10:27:51.317]                       invokeRestart <- base::invokeRestart
[10:27:51.317]                       is.null <- base::is.null
[10:27:51.317]                       muffled <- FALSE
[10:27:51.317]                       if (inherits(cond, "message")) {
[10:27:51.317]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.317]                         if (muffled) 
[10:27:51.317]                           invokeRestart("muffleMessage")
[10:27:51.317]                       }
[10:27:51.317]                       else if (inherits(cond, "warning")) {
[10:27:51.317]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.317]                         if (muffled) 
[10:27:51.317]                           invokeRestart("muffleWarning")
[10:27:51.317]                       }
[10:27:51.317]                       else if (inherits(cond, "condition")) {
[10:27:51.317]                         if (!is.null(pattern)) {
[10:27:51.317]                           computeRestarts <- base::computeRestarts
[10:27:51.317]                           grepl <- base::grepl
[10:27:51.317]                           restarts <- computeRestarts(cond)
[10:27:51.317]                           for (restart in restarts) {
[10:27:51.317]                             name <- restart$name
[10:27:51.317]                             if (is.null(name)) 
[10:27:51.317]                               next
[10:27:51.317]                             if (!grepl(pattern, name)) 
[10:27:51.317]                               next
[10:27:51.317]                             invokeRestart(restart)
[10:27:51.317]                             muffled <- TRUE
[10:27:51.317]                             break
[10:27:51.317]                           }
[10:27:51.317]                         }
[10:27:51.317]                       }
[10:27:51.317]                       invisible(muffled)
[10:27:51.317]                     }
[10:27:51.317]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.317]                   }
[10:27:51.317]                 }
[10:27:51.317]                 else {
[10:27:51.317]                   if (TRUE) {
[10:27:51.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.317]                     {
[10:27:51.317]                       inherits <- base::inherits
[10:27:51.317]                       invokeRestart <- base::invokeRestart
[10:27:51.317]                       is.null <- base::is.null
[10:27:51.317]                       muffled <- FALSE
[10:27:51.317]                       if (inherits(cond, "message")) {
[10:27:51.317]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.317]                         if (muffled) 
[10:27:51.317]                           invokeRestart("muffleMessage")
[10:27:51.317]                       }
[10:27:51.317]                       else if (inherits(cond, "warning")) {
[10:27:51.317]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.317]                         if (muffled) 
[10:27:51.317]                           invokeRestart("muffleWarning")
[10:27:51.317]                       }
[10:27:51.317]                       else if (inherits(cond, "condition")) {
[10:27:51.317]                         if (!is.null(pattern)) {
[10:27:51.317]                           computeRestarts <- base::computeRestarts
[10:27:51.317]                           grepl <- base::grepl
[10:27:51.317]                           restarts <- computeRestarts(cond)
[10:27:51.317]                           for (restart in restarts) {
[10:27:51.317]                             name <- restart$name
[10:27:51.317]                             if (is.null(name)) 
[10:27:51.317]                               next
[10:27:51.317]                             if (!grepl(pattern, name)) 
[10:27:51.317]                               next
[10:27:51.317]                             invokeRestart(restart)
[10:27:51.317]                             muffled <- TRUE
[10:27:51.317]                             break
[10:27:51.317]                           }
[10:27:51.317]                         }
[10:27:51.317]                       }
[10:27:51.317]                       invisible(muffled)
[10:27:51.317]                     }
[10:27:51.317]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.317]                   }
[10:27:51.317]                 }
[10:27:51.317]             }
[10:27:51.317]         }))
[10:27:51.317]     }, error = function(ex) {
[10:27:51.317]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:51.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.317]                 ...future.rng), started = ...future.startTime, 
[10:27:51.317]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:51.317]             version = "1.8"), class = "FutureResult")
[10:27:51.317]     }, finally = {
[10:27:51.317]         if (!identical(...future.workdir, getwd())) 
[10:27:51.317]             setwd(...future.workdir)
[10:27:51.317]         {
[10:27:51.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:51.317]                 ...future.oldOptions$nwarnings <- NULL
[10:27:51.317]             }
[10:27:51.317]             base::options(...future.oldOptions)
[10:27:51.317]             if (.Platform$OS.type == "windows") {
[10:27:51.317]                 old_names <- names(...future.oldEnvVars)
[10:27:51.317]                 envs <- base::Sys.getenv()
[10:27:51.317]                 names <- names(envs)
[10:27:51.317]                 common <- intersect(names, old_names)
[10:27:51.317]                 added <- setdiff(names, old_names)
[10:27:51.317]                 removed <- setdiff(old_names, names)
[10:27:51.317]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:51.317]                   envs[common]]
[10:27:51.317]                 NAMES <- toupper(changed)
[10:27:51.317]                 args <- list()
[10:27:51.317]                 for (kk in seq_along(NAMES)) {
[10:27:51.317]                   name <- changed[[kk]]
[10:27:51.317]                   NAME <- NAMES[[kk]]
[10:27:51.317]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.317]                     next
[10:27:51.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.317]                 }
[10:27:51.317]                 NAMES <- toupper(added)
[10:27:51.317]                 for (kk in seq_along(NAMES)) {
[10:27:51.317]                   name <- added[[kk]]
[10:27:51.317]                   NAME <- NAMES[[kk]]
[10:27:51.317]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.317]                     next
[10:27:51.317]                   args[[name]] <- ""
[10:27:51.317]                 }
[10:27:51.317]                 NAMES <- toupper(removed)
[10:27:51.317]                 for (kk in seq_along(NAMES)) {
[10:27:51.317]                   name <- removed[[kk]]
[10:27:51.317]                   NAME <- NAMES[[kk]]
[10:27:51.317]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.317]                     next
[10:27:51.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.317]                 }
[10:27:51.317]                 if (length(args) > 0) 
[10:27:51.317]                   base::do.call(base::Sys.setenv, args = args)
[10:27:51.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:51.317]             }
[10:27:51.317]             else {
[10:27:51.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:51.317]             }
[10:27:51.317]             {
[10:27:51.317]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:51.317]                   0L) {
[10:27:51.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:51.317]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:51.317]                   base::options(opts)
[10:27:51.317]                 }
[10:27:51.317]                 {
[10:27:51.317]                   {
[10:27:51.317]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:51.317]                     NULL
[10:27:51.317]                   }
[10:27:51.317]                   options(future.plan = NULL)
[10:27:51.317]                   if (is.na(NA_character_)) 
[10:27:51.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:51.317]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:51.317]                     envir = parent.frame()) 
[10:27:51.317]                   {
[10:27:51.317]                     default_workers <- missing(workers)
[10:27:51.317]                     if (is.function(workers)) 
[10:27:51.317]                       workers <- workers()
[10:27:51.317]                     workers <- structure(as.integer(workers), 
[10:27:51.317]                       class = class(workers))
[10:27:51.317]                     stop_if_not(is.finite(workers), workers >= 
[10:27:51.317]                       1L)
[10:27:51.317]                     if ((workers == 1L && !inherits(workers, 
[10:27:51.317]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:51.317]                       if (default_workers) 
[10:27:51.317]                         supportsMulticore(warn = TRUE)
[10:27:51.317]                       return(sequential(..., envir = envir))
[10:27:51.317]                     }
[10:27:51.317]                     oopts <- options(mc.cores = workers)
[10:27:51.317]                     on.exit(options(oopts))
[10:27:51.317]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:51.317]                       envir = envir)
[10:27:51.317]                     if (!future$lazy) 
[10:27:51.317]                       future <- run(future)
[10:27:51.317]                     invisible(future)
[10:27:51.317]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:51.317]                 }
[10:27:51.317]             }
[10:27:51.317]         }
[10:27:51.317]     })
[10:27:51.317]     if (TRUE) {
[10:27:51.317]         base::sink(type = "output", split = FALSE)
[10:27:51.317]         if (TRUE) {
[10:27:51.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:51.317]         }
[10:27:51.317]         else {
[10:27:51.317]             ...future.result["stdout"] <- base::list(NULL)
[10:27:51.317]         }
[10:27:51.317]         base::close(...future.stdout)
[10:27:51.317]         ...future.stdout <- NULL
[10:27:51.317]     }
[10:27:51.317]     ...future.result$conditions <- ...future.conditions
[10:27:51.317]     ...future.result$finished <- base::Sys.time()
[10:27:51.317]     ...future.result
[10:27:51.317] }
[10:27:51.320] requestCore(): workers = 2
[10:27:51.322] MulticoreFuture started
[10:27:51.322] - Launch lazy future ... done
[10:27:51.322] run() for ‘MulticoreFuture’ ... done
[10:27:51.323] result() for MulticoreFuture ...
[10:27:51.323] plan(): Setting new future strategy stack:
[10:27:51.323] List of future strategies:
[10:27:51.323] 1. sequential:
[10:27:51.323]    - args: function (..., envir = parent.frame())
[10:27:51.323]    - tweaked: FALSE
[10:27:51.323]    - call: NULL
[10:27:51.324] plan(): nbrOfWorkers() = 1
[10:27:51.326] plan(): Setting new future strategy stack:
[10:27:51.326] List of future strategies:
[10:27:51.326] 1. multicore:
[10:27:51.326]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:51.326]    - tweaked: FALSE
[10:27:51.326]    - call: plan(strategy)
[10:27:51.332] plan(): nbrOfWorkers() = 2
[10:27:51.333] result() for MulticoreFuture ...
[10:27:51.333] result() for MulticoreFuture ... done
[10:27:51.333] result() for MulticoreFuture ... done
[10:27:51.333] result() for MulticoreFuture ...
[10:27:51.333] result() for MulticoreFuture ... done
[10:27:51.333] result() for MulticoreFuture ...
[10:27:51.333] result() for MulticoreFuture ... done
[1] 42
[10:27:51.334] result() for MulticoreFuture ...
[10:27:51.334] result() for MulticoreFuture ... done
multicore ... done
multisession ...
[10:27:51.334] plan(): Setting new future strategy stack:
[10:27:51.335] List of future strategies:
[10:27:51.335] 1. multisession:
[10:27:51.335]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:27:51.335]    - tweaked: FALSE
[10:27:51.335]    - call: plan(strategy)
[10:27:51.335] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:27:51.335] multisession:
[10:27:51.335] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:27:51.335] - tweaked: FALSE
[10:27:51.335] - call: plan(strategy)
[10:27:51.342] getGlobalsAndPackages() ...
[10:27:51.342] Not searching for globals
[10:27:51.343] - globals: [0] <none>
[10:27:51.343] getGlobalsAndPackages() ... DONE
[10:27:51.343] [local output] makeClusterPSOCK() ...
[10:27:51.392] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:27:51.393] [local output] Base port: 11126
[10:27:51.393] [local output] Getting setup options for 2 cluster nodes ...
[10:27:51.393] [local output]  - Node 1 of 2 ...
[10:27:51.394] [local output] localMachine=TRUE => revtunnel=FALSE

[10:27:51.394] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp3JSlqb/worker.rank=1.parallelly.parent=92649.169e9704f75c7.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp3JSlqb/worker.rank=1.parallelly.parent=92649.169e9704f75c7.pid")'’
[10:27:51.591] - Possible to infer worker's PID: TRUE
[10:27:51.591] [local output] Rscript port: 11126

[10:27:51.592] [local output]  - Node 2 of 2 ...
[10:27:51.592] [local output] localMachine=TRUE => revtunnel=FALSE

[10:27:51.593] [local output] Rscript port: 11126

[10:27:51.593] [local output] Getting setup options for 2 cluster nodes ... done
[10:27:51.593] [local output]  - Parallel setup requested for some PSOCK nodes
[10:27:51.594] [local output] Setting up PSOCK nodes in parallel
[10:27:51.594] List of 36
[10:27:51.594]  $ worker          : chr "localhost"
[10:27:51.594]   ..- attr(*, "localhost")= logi TRUE
[10:27:51.594]  $ master          : chr "localhost"
[10:27:51.594]  $ port            : int 11126
[10:27:51.594]  $ connectTimeout  : num 120
[10:27:51.594]  $ timeout         : num 2592000
[10:27:51.594]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:27:51.594]  $ homogeneous     : logi TRUE
[10:27:51.594]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:27:51.594]  $ rscript_envs    : NULL
[10:27:51.594]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:27:51.594]  $ rscript_startup : NULL
[10:27:51.594]  $ rscript_sh      : chr "sh"
[10:27:51.594]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:27:51.594]  $ methods         : logi TRUE
[10:27:51.594]  $ socketOptions   : chr "no-delay"
[10:27:51.594]  $ useXDR          : logi FALSE
[10:27:51.594]  $ outfile         : chr "/dev/null"
[10:27:51.594]  $ renice          : int NA
[10:27:51.594]  $ rshcmd          : NULL
[10:27:51.594]  $ user            : chr(0) 
[10:27:51.594]  $ revtunnel       : logi FALSE
[10:27:51.594]  $ rshlogfile      : NULL
[10:27:51.594]  $ rshopts         : chr(0) 
[10:27:51.594]  $ rank            : int 1
[10:27:51.594]  $ manual          : logi FALSE
[10:27:51.594]  $ dryrun          : logi FALSE
[10:27:51.594]  $ quiet           : logi FALSE
[10:27:51.594]  $ setup_strategy  : chr "parallel"
[10:27:51.594]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:27:51.594]  $ pidfile         : chr "/tmp/Rtmp3JSlqb/worker.rank=1.parallelly.parent=92649.169e9704f75c7.pid"
[10:27:51.594]  $ rshcmd_label    : NULL
[10:27:51.594]  $ rsh_call        : NULL
[10:27:51.594]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:27:51.594]  $ localMachine    : logi TRUE
[10:27:51.594]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:27:51.594]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:27:51.594]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:27:51.594]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:27:51.594]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:27:51.594]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:27:51.594]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:27:51.594]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:27:51.594]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:27:51.594]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:27:51.594]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:27:51.594]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:27:51.594]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:27:51.594]  $ arguments       :List of 28
[10:27:51.594]   ..$ worker          : chr "localhost"
[10:27:51.594]   ..$ master          : NULL
[10:27:51.594]   ..$ port            : int 11126
[10:27:51.594]   ..$ connectTimeout  : num 120
[10:27:51.594]   ..$ timeout         : num 2592000
[10:27:51.594]   ..$ rscript         : NULL
[10:27:51.594]   ..$ homogeneous     : NULL
[10:27:51.594]   ..$ rscript_args    : NULL
[10:27:51.594]   ..$ rscript_envs    : NULL
[10:27:51.594]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:27:51.594]   ..$ rscript_startup : NULL
[10:27:51.594]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:27:51.594]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:27:51.594]   ..$ methods         : logi TRUE
[10:27:51.594]   ..$ socketOptions   : chr "no-delay"
[10:27:51.594]   ..$ useXDR          : logi FALSE
[10:27:51.594]   ..$ outfile         : chr "/dev/null"
[10:27:51.594]   ..$ renice          : int NA
[10:27:51.594]   ..$ rshcmd          : NULL
[10:27:51.594]   ..$ user            : NULL
[10:27:51.594]   ..$ revtunnel       : logi NA
[10:27:51.594]   ..$ rshlogfile      : NULL
[10:27:51.594]   ..$ rshopts         : NULL
[10:27:51.594]   ..$ rank            : int 1
[10:27:51.594]   ..$ manual          : logi FALSE
[10:27:51.594]   ..$ dryrun          : logi FALSE
[10:27:51.594]   ..$ quiet           : logi FALSE
[10:27:51.594]   ..$ setup_strategy  : chr "parallel"
[10:27:51.594]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:27:51.611] [local output] System call to launch all workers:
[10:27:51.611] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp3JSlqb/worker.rank=1.parallelly.parent=92649.169e9704f75c7.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11126 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:27:51.611] [local output] Starting PSOCK main server
[10:27:51.617] [local output] Workers launched
[10:27:51.617] [local output] Waiting for workers to connect back
[10:27:51.617]  - [local output] 0 workers out of 2 ready
[10:27:51.867]  - [local output] 0 workers out of 2 ready
[10:27:51.868]  - [local output] 1 workers out of 2 ready
[10:27:51.870]  - [local output] 1 workers out of 2 ready
[10:27:51.870]  - [local output] 2 workers out of 2 ready
[10:27:51.871] [local output] Launching of workers completed
[10:27:51.871] [local output] Collecting session information from workers
[10:27:51.872] [local output]  - Worker #1 of 2
[10:27:51.872] [local output]  - Worker #2 of 2
[10:27:51.872] [local output] makeClusterPSOCK() ... done
[10:27:51.884] Packages needed by the future expression (n = 0): <none>
[10:27:51.884] Packages needed by future strategies (n = 0): <none>
[10:27:51.884] {
[10:27:51.884]     {
[10:27:51.884]         {
[10:27:51.884]             ...future.startTime <- base::Sys.time()
[10:27:51.884]             {
[10:27:51.884]                 {
[10:27:51.884]                   {
[10:27:51.884]                     {
[10:27:51.884]                       base::local({
[10:27:51.884]                         has_future <- base::requireNamespace("future", 
[10:27:51.884]                           quietly = TRUE)
[10:27:51.884]                         if (has_future) {
[10:27:51.884]                           ns <- base::getNamespace("future")
[10:27:51.884]                           version <- ns[[".package"]][["version"]]
[10:27:51.884]                           if (is.null(version)) 
[10:27:51.884]                             version <- utils::packageVersion("future")
[10:27:51.884]                         }
[10:27:51.884]                         else {
[10:27:51.884]                           version <- NULL
[10:27:51.884]                         }
[10:27:51.884]                         if (!has_future || version < "1.8.0") {
[10:27:51.884]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:51.884]                             "", base::R.version$version.string), 
[10:27:51.884]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:51.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:51.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:51.884]                               "release", "version")], collapse = " "), 
[10:27:51.884]                             hostname = base::Sys.info()[["nodename"]])
[10:27:51.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:51.884]                             info)
[10:27:51.884]                           info <- base::paste(info, collapse = "; ")
[10:27:51.884]                           if (!has_future) {
[10:27:51.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:51.884]                               info)
[10:27:51.884]                           }
[10:27:51.884]                           else {
[10:27:51.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:51.884]                               info, version)
[10:27:51.884]                           }
[10:27:51.884]                           base::stop(msg)
[10:27:51.884]                         }
[10:27:51.884]                       })
[10:27:51.884]                     }
[10:27:51.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:51.884]                     base::options(mc.cores = 1L)
[10:27:51.884]                   }
[10:27:51.884]                   options(future.plan = NULL)
[10:27:51.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:51.884]                 }
[10:27:51.884]                 ...future.workdir <- getwd()
[10:27:51.884]             }
[10:27:51.884]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:51.884]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:51.884]         }
[10:27:51.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:51.884]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:51.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:51.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:51.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:51.884]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:51.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:51.884]             base::names(...future.oldOptions))
[10:27:51.884]     }
[10:27:51.884]     if (FALSE) {
[10:27:51.884]     }
[10:27:51.884]     else {
[10:27:51.884]         if (TRUE) {
[10:27:51.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:51.884]                 open = "w")
[10:27:51.884]         }
[10:27:51.884]         else {
[10:27:51.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:51.884]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:51.884]         }
[10:27:51.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:51.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:51.884]             base::sink(type = "output", split = FALSE)
[10:27:51.884]             base::close(...future.stdout)
[10:27:51.884]         }, add = TRUE)
[10:27:51.884]     }
[10:27:51.884]     ...future.frame <- base::sys.nframe()
[10:27:51.884]     ...future.conditions <- base::list()
[10:27:51.884]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:51.884]     if (FALSE) {
[10:27:51.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:51.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:51.884]     }
[10:27:51.884]     ...future.result <- base::tryCatch({
[10:27:51.884]         base::withCallingHandlers({
[10:27:51.884]             ...future.value <- base::withVisible(base::local({
[10:27:51.884]                 ...future.makeSendCondition <- base::local({
[10:27:51.884]                   sendCondition <- NULL
[10:27:51.884]                   function(frame = 1L) {
[10:27:51.884]                     if (is.function(sendCondition)) 
[10:27:51.884]                       return(sendCondition)
[10:27:51.884]                     ns <- getNamespace("parallel")
[10:27:51.884]                     if (exists("sendData", mode = "function", 
[10:27:51.884]                       envir = ns)) {
[10:27:51.884]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:51.884]                         envir = ns)
[10:27:51.884]                       envir <- sys.frame(frame)
[10:27:51.884]                       master <- NULL
[10:27:51.884]                       while (!identical(envir, .GlobalEnv) && 
[10:27:51.884]                         !identical(envir, emptyenv())) {
[10:27:51.884]                         if (exists("master", mode = "list", envir = envir, 
[10:27:51.884]                           inherits = FALSE)) {
[10:27:51.884]                           master <- get("master", mode = "list", 
[10:27:51.884]                             envir = envir, inherits = FALSE)
[10:27:51.884]                           if (inherits(master, c("SOCKnode", 
[10:27:51.884]                             "SOCK0node"))) {
[10:27:51.884]                             sendCondition <<- function(cond) {
[10:27:51.884]                               data <- list(type = "VALUE", value = cond, 
[10:27:51.884]                                 success = TRUE)
[10:27:51.884]                               parallel_sendData(master, data)
[10:27:51.884]                             }
[10:27:51.884]                             return(sendCondition)
[10:27:51.884]                           }
[10:27:51.884]                         }
[10:27:51.884]                         frame <- frame + 1L
[10:27:51.884]                         envir <- sys.frame(frame)
[10:27:51.884]                       }
[10:27:51.884]                     }
[10:27:51.884]                     sendCondition <<- function(cond) NULL
[10:27:51.884]                   }
[10:27:51.884]                 })
[10:27:51.884]                 withCallingHandlers({
[10:27:51.884]                   NA
[10:27:51.884]                 }, immediateCondition = function(cond) {
[10:27:51.884]                   sendCondition <- ...future.makeSendCondition()
[10:27:51.884]                   sendCondition(cond)
[10:27:51.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.884]                   {
[10:27:51.884]                     inherits <- base::inherits
[10:27:51.884]                     invokeRestart <- base::invokeRestart
[10:27:51.884]                     is.null <- base::is.null
[10:27:51.884]                     muffled <- FALSE
[10:27:51.884]                     if (inherits(cond, "message")) {
[10:27:51.884]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:51.884]                       if (muffled) 
[10:27:51.884]                         invokeRestart("muffleMessage")
[10:27:51.884]                     }
[10:27:51.884]                     else if (inherits(cond, "warning")) {
[10:27:51.884]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:51.884]                       if (muffled) 
[10:27:51.884]                         invokeRestart("muffleWarning")
[10:27:51.884]                     }
[10:27:51.884]                     else if (inherits(cond, "condition")) {
[10:27:51.884]                       if (!is.null(pattern)) {
[10:27:51.884]                         computeRestarts <- base::computeRestarts
[10:27:51.884]                         grepl <- base::grepl
[10:27:51.884]                         restarts <- computeRestarts(cond)
[10:27:51.884]                         for (restart in restarts) {
[10:27:51.884]                           name <- restart$name
[10:27:51.884]                           if (is.null(name)) 
[10:27:51.884]                             next
[10:27:51.884]                           if (!grepl(pattern, name)) 
[10:27:51.884]                             next
[10:27:51.884]                           invokeRestart(restart)
[10:27:51.884]                           muffled <- TRUE
[10:27:51.884]                           break
[10:27:51.884]                         }
[10:27:51.884]                       }
[10:27:51.884]                     }
[10:27:51.884]                     invisible(muffled)
[10:27:51.884]                   }
[10:27:51.884]                   muffleCondition(cond)
[10:27:51.884]                 })
[10:27:51.884]             }))
[10:27:51.884]             future::FutureResult(value = ...future.value$value, 
[10:27:51.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.884]                   ...future.rng), globalenv = if (FALSE) 
[10:27:51.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:51.884]                     ...future.globalenv.names))
[10:27:51.884]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:51.884]         }, condition = base::local({
[10:27:51.884]             c <- base::c
[10:27:51.884]             inherits <- base::inherits
[10:27:51.884]             invokeRestart <- base::invokeRestart
[10:27:51.884]             length <- base::length
[10:27:51.884]             list <- base::list
[10:27:51.884]             seq.int <- base::seq.int
[10:27:51.884]             signalCondition <- base::signalCondition
[10:27:51.884]             sys.calls <- base::sys.calls
[10:27:51.884]             `[[` <- base::`[[`
[10:27:51.884]             `+` <- base::`+`
[10:27:51.884]             `<<-` <- base::`<<-`
[10:27:51.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:51.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:51.884]                   3L)]
[10:27:51.884]             }
[10:27:51.884]             function(cond) {
[10:27:51.884]                 is_error <- inherits(cond, "error")
[10:27:51.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:51.884]                   NULL)
[10:27:51.884]                 if (is_error) {
[10:27:51.884]                   sessionInformation <- function() {
[10:27:51.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:51.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:51.884]                       search = base::search(), system = base::Sys.info())
[10:27:51.884]                   }
[10:27:51.884]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:51.884]                     cond$call), session = sessionInformation(), 
[10:27:51.884]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:51.884]                   signalCondition(cond)
[10:27:51.884]                 }
[10:27:51.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:51.884]                 "immediateCondition"))) {
[10:27:51.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:51.884]                   ...future.conditions[[length(...future.conditions) + 
[10:27:51.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:51.884]                   if (TRUE && !signal) {
[10:27:51.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.884]                     {
[10:27:51.884]                       inherits <- base::inherits
[10:27:51.884]                       invokeRestart <- base::invokeRestart
[10:27:51.884]                       is.null <- base::is.null
[10:27:51.884]                       muffled <- FALSE
[10:27:51.884]                       if (inherits(cond, "message")) {
[10:27:51.884]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.884]                         if (muffled) 
[10:27:51.884]                           invokeRestart("muffleMessage")
[10:27:51.884]                       }
[10:27:51.884]                       else if (inherits(cond, "warning")) {
[10:27:51.884]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.884]                         if (muffled) 
[10:27:51.884]                           invokeRestart("muffleWarning")
[10:27:51.884]                       }
[10:27:51.884]                       else if (inherits(cond, "condition")) {
[10:27:51.884]                         if (!is.null(pattern)) {
[10:27:51.884]                           computeRestarts <- base::computeRestarts
[10:27:51.884]                           grepl <- base::grepl
[10:27:51.884]                           restarts <- computeRestarts(cond)
[10:27:51.884]                           for (restart in restarts) {
[10:27:51.884]                             name <- restart$name
[10:27:51.884]                             if (is.null(name)) 
[10:27:51.884]                               next
[10:27:51.884]                             if (!grepl(pattern, name)) 
[10:27:51.884]                               next
[10:27:51.884]                             invokeRestart(restart)
[10:27:51.884]                             muffled <- TRUE
[10:27:51.884]                             break
[10:27:51.884]                           }
[10:27:51.884]                         }
[10:27:51.884]                       }
[10:27:51.884]                       invisible(muffled)
[10:27:51.884]                     }
[10:27:51.884]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.884]                   }
[10:27:51.884]                 }
[10:27:51.884]                 else {
[10:27:51.884]                   if (TRUE) {
[10:27:51.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:51.884]                     {
[10:27:51.884]                       inherits <- base::inherits
[10:27:51.884]                       invokeRestart <- base::invokeRestart
[10:27:51.884]                       is.null <- base::is.null
[10:27:51.884]                       muffled <- FALSE
[10:27:51.884]                       if (inherits(cond, "message")) {
[10:27:51.884]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:51.884]                         if (muffled) 
[10:27:51.884]                           invokeRestart("muffleMessage")
[10:27:51.884]                       }
[10:27:51.884]                       else if (inherits(cond, "warning")) {
[10:27:51.884]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:51.884]                         if (muffled) 
[10:27:51.884]                           invokeRestart("muffleWarning")
[10:27:51.884]                       }
[10:27:51.884]                       else if (inherits(cond, "condition")) {
[10:27:51.884]                         if (!is.null(pattern)) {
[10:27:51.884]                           computeRestarts <- base::computeRestarts
[10:27:51.884]                           grepl <- base::grepl
[10:27:51.884]                           restarts <- computeRestarts(cond)
[10:27:51.884]                           for (restart in restarts) {
[10:27:51.884]                             name <- restart$name
[10:27:51.884]                             if (is.null(name)) 
[10:27:51.884]                               next
[10:27:51.884]                             if (!grepl(pattern, name)) 
[10:27:51.884]                               next
[10:27:51.884]                             invokeRestart(restart)
[10:27:51.884]                             muffled <- TRUE
[10:27:51.884]                             break
[10:27:51.884]                           }
[10:27:51.884]                         }
[10:27:51.884]                       }
[10:27:51.884]                       invisible(muffled)
[10:27:51.884]                     }
[10:27:51.884]                     muffleCondition(cond, pattern = "^muffle")
[10:27:51.884]                   }
[10:27:51.884]                 }
[10:27:51.884]             }
[10:27:51.884]         }))
[10:27:51.884]     }, error = function(ex) {
[10:27:51.884]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:51.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:51.884]                 ...future.rng), started = ...future.startTime, 
[10:27:51.884]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:51.884]             version = "1.8"), class = "FutureResult")
[10:27:51.884]     }, finally = {
[10:27:51.884]         if (!identical(...future.workdir, getwd())) 
[10:27:51.884]             setwd(...future.workdir)
[10:27:51.884]         {
[10:27:51.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:51.884]                 ...future.oldOptions$nwarnings <- NULL
[10:27:51.884]             }
[10:27:51.884]             base::options(...future.oldOptions)
[10:27:51.884]             if (.Platform$OS.type == "windows") {
[10:27:51.884]                 old_names <- names(...future.oldEnvVars)
[10:27:51.884]                 envs <- base::Sys.getenv()
[10:27:51.884]                 names <- names(envs)
[10:27:51.884]                 common <- intersect(names, old_names)
[10:27:51.884]                 added <- setdiff(names, old_names)
[10:27:51.884]                 removed <- setdiff(old_names, names)
[10:27:51.884]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:51.884]                   envs[common]]
[10:27:51.884]                 NAMES <- toupper(changed)
[10:27:51.884]                 args <- list()
[10:27:51.884]                 for (kk in seq_along(NAMES)) {
[10:27:51.884]                   name <- changed[[kk]]
[10:27:51.884]                   NAME <- NAMES[[kk]]
[10:27:51.884]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.884]                     next
[10:27:51.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.884]                 }
[10:27:51.884]                 NAMES <- toupper(added)
[10:27:51.884]                 for (kk in seq_along(NAMES)) {
[10:27:51.884]                   name <- added[[kk]]
[10:27:51.884]                   NAME <- NAMES[[kk]]
[10:27:51.884]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.884]                     next
[10:27:51.884]                   args[[name]] <- ""
[10:27:51.884]                 }
[10:27:51.884]                 NAMES <- toupper(removed)
[10:27:51.884]                 for (kk in seq_along(NAMES)) {
[10:27:51.884]                   name <- removed[[kk]]
[10:27:51.884]                   NAME <- NAMES[[kk]]
[10:27:51.884]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:51.884]                     next
[10:27:51.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:51.884]                 }
[10:27:51.884]                 if (length(args) > 0) 
[10:27:51.884]                   base::do.call(base::Sys.setenv, args = args)
[10:27:51.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:51.884]             }
[10:27:51.884]             else {
[10:27:51.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:51.884]             }
[10:27:51.884]             {
[10:27:51.884]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:51.884]                   0L) {
[10:27:51.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:51.884]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:51.884]                   base::options(opts)
[10:27:51.884]                 }
[10:27:51.884]                 {
[10:27:51.884]                   {
[10:27:51.884]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:51.884]                     NULL
[10:27:51.884]                   }
[10:27:51.884]                   options(future.plan = NULL)
[10:27:51.884]                   if (is.na(NA_character_)) 
[10:27:51.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:51.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:51.884]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:51.884]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:51.884]                     envir = parent.frame()) 
[10:27:51.884]                   {
[10:27:51.884]                     if (is.function(workers)) 
[10:27:51.884]                       workers <- workers()
[10:27:51.884]                     workers <- structure(as.integer(workers), 
[10:27:51.884]                       class = class(workers))
[10:27:51.884]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:51.884]                       workers >= 1)
[10:27:51.884]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:51.884]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:51.884]                     }
[10:27:51.884]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:51.884]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:51.884]                       envir = envir)
[10:27:51.884]                     if (!future$lazy) 
[10:27:51.884]                       future <- run(future)
[10:27:51.884]                     invisible(future)
[10:27:51.884]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:51.884]                 }
[10:27:51.884]             }
[10:27:51.884]         }
[10:27:51.884]     })
[10:27:51.884]     if (TRUE) {
[10:27:51.884]         base::sink(type = "output", split = FALSE)
[10:27:51.884]         if (TRUE) {
[10:27:51.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:51.884]         }
[10:27:51.884]         else {
[10:27:51.884]             ...future.result["stdout"] <- base::list(NULL)
[10:27:51.884]         }
[10:27:51.884]         base::close(...future.stdout)
[10:27:51.884]         ...future.stdout <- NULL
[10:27:51.884]     }
[10:27:51.884]     ...future.result$conditions <- ...future.conditions
[10:27:51.884]     ...future.result$finished <- base::Sys.time()
[10:27:51.884]     ...future.result
[10:27:51.884] }
[10:27:51.939] MultisessionFuture started
[10:27:51.939] result() for ClusterFuture ...
[10:27:51.940] receiveMessageFromWorker() for ClusterFuture ...
[10:27:51.941] - Validating connection of MultisessionFuture
[10:27:51.986] - received message: FutureResult
[10:27:51.987] - Received FutureResult
[10:27:51.987] - Erased future from FutureRegistry
[10:27:51.987] result() for ClusterFuture ...
[10:27:51.987] - result already collected: FutureResult
[10:27:51.987] result() for ClusterFuture ... done
[10:27:51.987] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:51.987] result() for ClusterFuture ... done
[10:27:51.987] result() for ClusterFuture ...
[10:27:51.988] - result already collected: FutureResult
[10:27:51.988] result() for ClusterFuture ... done
[10:27:51.988] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:27:51.991] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[10:27:51.992] getGlobalsAndPackages() ...
[10:27:51.992] Searching for globals...
[10:27:51.996] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:51.996] Searching for globals ... DONE
[10:27:51.996] Resolving globals: FALSE
[10:27:51.997] 
[10:27:51.997] - packages: [1] ‘utils’
[10:27:51.997] getGlobalsAndPackages() ... DONE
[10:27:51.997] run() for ‘Future’ ...
[10:27:51.997] - state: ‘created’
[10:27:51.998] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:52.012] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:52.012] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:52.012]   - Field: ‘node’
[10:27:52.012]   - Field: ‘label’
[10:27:52.012]   - Field: ‘local’
[10:27:52.013]   - Field: ‘owner’
[10:27:52.013]   - Field: ‘envir’
[10:27:52.013]   - Field: ‘workers’
[10:27:52.013]   - Field: ‘packages’
[10:27:52.013]   - Field: ‘gc’
[10:27:52.013]   - Field: ‘conditions’
[10:27:52.013]   - Field: ‘persistent’
[10:27:52.013]   - Field: ‘expr’
[10:27:52.013]   - Field: ‘uuid’
[10:27:52.014]   - Field: ‘seed’
[10:27:52.014]   - Field: ‘version’
[10:27:52.014]   - Field: ‘result’
[10:27:52.014]   - Field: ‘asynchronous’
[10:27:52.014]   - Field: ‘calls’
[10:27:52.014]   - Field: ‘globals’
[10:27:52.014]   - Field: ‘stdout’
[10:27:52.014]   - Field: ‘earlySignal’
[10:27:52.014]   - Field: ‘lazy’
[10:27:52.015]   - Field: ‘state’
[10:27:52.015] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:52.015] - Launch lazy future ...
[10:27:52.015] Packages needed by the future expression (n = 1): ‘utils’
[10:27:52.015] Packages needed by future strategies (n = 0): <none>
[10:27:52.016] {
[10:27:52.016]     {
[10:27:52.016]         {
[10:27:52.016]             ...future.startTime <- base::Sys.time()
[10:27:52.016]             {
[10:27:52.016]                 {
[10:27:52.016]                   {
[10:27:52.016]                     {
[10:27:52.016]                       {
[10:27:52.016]                         base::local({
[10:27:52.016]                           has_future <- base::requireNamespace("future", 
[10:27:52.016]                             quietly = TRUE)
[10:27:52.016]                           if (has_future) {
[10:27:52.016]                             ns <- base::getNamespace("future")
[10:27:52.016]                             version <- ns[[".package"]][["version"]]
[10:27:52.016]                             if (is.null(version)) 
[10:27:52.016]                               version <- utils::packageVersion("future")
[10:27:52.016]                           }
[10:27:52.016]                           else {
[10:27:52.016]                             version <- NULL
[10:27:52.016]                           }
[10:27:52.016]                           if (!has_future || version < "1.8.0") {
[10:27:52.016]                             info <- base::c(r_version = base::gsub("R version ", 
[10:27:52.016]                               "", base::R.version$version.string), 
[10:27:52.016]                               platform = base::sprintf("%s (%s-bit)", 
[10:27:52.016]                                 base::R.version$platform, 8 * 
[10:27:52.016]                                   base::.Machine$sizeof.pointer), 
[10:27:52.016]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:52.016]                                 "release", "version")], collapse = " "), 
[10:27:52.016]                               hostname = base::Sys.info()[["nodename"]])
[10:27:52.016]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:27:52.016]                               info)
[10:27:52.016]                             info <- base::paste(info, collapse = "; ")
[10:27:52.016]                             if (!has_future) {
[10:27:52.016]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:52.016]                                 info)
[10:27:52.016]                             }
[10:27:52.016]                             else {
[10:27:52.016]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:52.016]                                 info, version)
[10:27:52.016]                             }
[10:27:52.016]                             base::stop(msg)
[10:27:52.016]                           }
[10:27:52.016]                         })
[10:27:52.016]                       }
[10:27:52.016]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:52.016]                       base::options(mc.cores = 1L)
[10:27:52.016]                     }
[10:27:52.016]                     base::local({
[10:27:52.016]                       for (pkg in "utils") {
[10:27:52.016]                         base::loadNamespace(pkg)
[10:27:52.016]                         base::library(pkg, character.only = TRUE)
[10:27:52.016]                       }
[10:27:52.016]                     })
[10:27:52.016]                   }
[10:27:52.016]                   options(future.plan = NULL)
[10:27:52.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:52.016]                 }
[10:27:52.016]                 ...future.workdir <- getwd()
[10:27:52.016]             }
[10:27:52.016]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:52.016]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:52.016]         }
[10:27:52.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:52.016]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:52.016]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:52.016]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:52.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:52.016]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:52.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:52.016]             base::names(...future.oldOptions))
[10:27:52.016]     }
[10:27:52.016]     if (FALSE) {
[10:27:52.016]     }
[10:27:52.016]     else {
[10:27:52.016]         if (TRUE) {
[10:27:52.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:52.016]                 open = "w")
[10:27:52.016]         }
[10:27:52.016]         else {
[10:27:52.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:52.016]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:52.016]         }
[10:27:52.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:52.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:52.016]             base::sink(type = "output", split = FALSE)
[10:27:52.016]             base::close(...future.stdout)
[10:27:52.016]         }, add = TRUE)
[10:27:52.016]     }
[10:27:52.016]     ...future.frame <- base::sys.nframe()
[10:27:52.016]     ...future.conditions <- base::list()
[10:27:52.016]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:52.016]     if (FALSE) {
[10:27:52.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:52.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:52.016]     }
[10:27:52.016]     ...future.result <- base::tryCatch({
[10:27:52.016]         base::withCallingHandlers({
[10:27:52.016]             ...future.value <- base::withVisible(base::local({
[10:27:52.016]                 ...future.makeSendCondition <- base::local({
[10:27:52.016]                   sendCondition <- NULL
[10:27:52.016]                   function(frame = 1L) {
[10:27:52.016]                     if (is.function(sendCondition)) 
[10:27:52.016]                       return(sendCondition)
[10:27:52.016]                     ns <- getNamespace("parallel")
[10:27:52.016]                     if (exists("sendData", mode = "function", 
[10:27:52.016]                       envir = ns)) {
[10:27:52.016]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:52.016]                         envir = ns)
[10:27:52.016]                       envir <- sys.frame(frame)
[10:27:52.016]                       master <- NULL
[10:27:52.016]                       while (!identical(envir, .GlobalEnv) && 
[10:27:52.016]                         !identical(envir, emptyenv())) {
[10:27:52.016]                         if (exists("master", mode = "list", envir = envir, 
[10:27:52.016]                           inherits = FALSE)) {
[10:27:52.016]                           master <- get("master", mode = "list", 
[10:27:52.016]                             envir = envir, inherits = FALSE)
[10:27:52.016]                           if (inherits(master, c("SOCKnode", 
[10:27:52.016]                             "SOCK0node"))) {
[10:27:52.016]                             sendCondition <<- function(cond) {
[10:27:52.016]                               data <- list(type = "VALUE", value = cond, 
[10:27:52.016]                                 success = TRUE)
[10:27:52.016]                               parallel_sendData(master, data)
[10:27:52.016]                             }
[10:27:52.016]                             return(sendCondition)
[10:27:52.016]                           }
[10:27:52.016]                         }
[10:27:52.016]                         frame <- frame + 1L
[10:27:52.016]                         envir <- sys.frame(frame)
[10:27:52.016]                       }
[10:27:52.016]                     }
[10:27:52.016]                     sendCondition <<- function(cond) NULL
[10:27:52.016]                   }
[10:27:52.016]                 })
[10:27:52.016]                 withCallingHandlers({
[10:27:52.016]                   {
[10:27:52.016]                     print(1:50)
[10:27:52.016]                     str(1:50)
[10:27:52.016]                     cat(letters, sep = "-")
[10:27:52.016]                     cat(1:6, collapse = "\n")
[10:27:52.016]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:52.016]                     42L
[10:27:52.016]                   }
[10:27:52.016]                 }, immediateCondition = function(cond) {
[10:27:52.016]                   sendCondition <- ...future.makeSendCondition()
[10:27:52.016]                   sendCondition(cond)
[10:27:52.016]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.016]                   {
[10:27:52.016]                     inherits <- base::inherits
[10:27:52.016]                     invokeRestart <- base::invokeRestart
[10:27:52.016]                     is.null <- base::is.null
[10:27:52.016]                     muffled <- FALSE
[10:27:52.016]                     if (inherits(cond, "message")) {
[10:27:52.016]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:52.016]                       if (muffled) 
[10:27:52.016]                         invokeRestart("muffleMessage")
[10:27:52.016]                     }
[10:27:52.016]                     else if (inherits(cond, "warning")) {
[10:27:52.016]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:52.016]                       if (muffled) 
[10:27:52.016]                         invokeRestart("muffleWarning")
[10:27:52.016]                     }
[10:27:52.016]                     else if (inherits(cond, "condition")) {
[10:27:52.016]                       if (!is.null(pattern)) {
[10:27:52.016]                         computeRestarts <- base::computeRestarts
[10:27:52.016]                         grepl <- base::grepl
[10:27:52.016]                         restarts <- computeRestarts(cond)
[10:27:52.016]                         for (restart in restarts) {
[10:27:52.016]                           name <- restart$name
[10:27:52.016]                           if (is.null(name)) 
[10:27:52.016]                             next
[10:27:52.016]                           if (!grepl(pattern, name)) 
[10:27:52.016]                             next
[10:27:52.016]                           invokeRestart(restart)
[10:27:52.016]                           muffled <- TRUE
[10:27:52.016]                           break
[10:27:52.016]                         }
[10:27:52.016]                       }
[10:27:52.016]                     }
[10:27:52.016]                     invisible(muffled)
[10:27:52.016]                   }
[10:27:52.016]                   muffleCondition(cond)
[10:27:52.016]                 })
[10:27:52.016]             }))
[10:27:52.016]             future::FutureResult(value = ...future.value$value, 
[10:27:52.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.016]                   ...future.rng), globalenv = if (FALSE) 
[10:27:52.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:52.016]                     ...future.globalenv.names))
[10:27:52.016]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:52.016]         }, condition = base::local({
[10:27:52.016]             c <- base::c
[10:27:52.016]             inherits <- base::inherits
[10:27:52.016]             invokeRestart <- base::invokeRestart
[10:27:52.016]             length <- base::length
[10:27:52.016]             list <- base::list
[10:27:52.016]             seq.int <- base::seq.int
[10:27:52.016]             signalCondition <- base::signalCondition
[10:27:52.016]             sys.calls <- base::sys.calls
[10:27:52.016]             `[[` <- base::`[[`
[10:27:52.016]             `+` <- base::`+`
[10:27:52.016]             `<<-` <- base::`<<-`
[10:27:52.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:52.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:52.016]                   3L)]
[10:27:52.016]             }
[10:27:52.016]             function(cond) {
[10:27:52.016]                 is_error <- inherits(cond, "error")
[10:27:52.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:52.016]                   NULL)
[10:27:52.016]                 if (is_error) {
[10:27:52.016]                   sessionInformation <- function() {
[10:27:52.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:52.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:52.016]                       search = base::search(), system = base::Sys.info())
[10:27:52.016]                   }
[10:27:52.016]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:52.016]                     cond$call), session = sessionInformation(), 
[10:27:52.016]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:52.016]                   signalCondition(cond)
[10:27:52.016]                 }
[10:27:52.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:52.016]                 "immediateCondition"))) {
[10:27:52.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:52.016]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:52.016]                   if (TRUE && !signal) {
[10:27:52.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.016]                     {
[10:27:52.016]                       inherits <- base::inherits
[10:27:52.016]                       invokeRestart <- base::invokeRestart
[10:27:52.016]                       is.null <- base::is.null
[10:27:52.016]                       muffled <- FALSE
[10:27:52.016]                       if (inherits(cond, "message")) {
[10:27:52.016]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.016]                         if (muffled) 
[10:27:52.016]                           invokeRestart("muffleMessage")
[10:27:52.016]                       }
[10:27:52.016]                       else if (inherits(cond, "warning")) {
[10:27:52.016]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.016]                         if (muffled) 
[10:27:52.016]                           invokeRestart("muffleWarning")
[10:27:52.016]                       }
[10:27:52.016]                       else if (inherits(cond, "condition")) {
[10:27:52.016]                         if (!is.null(pattern)) {
[10:27:52.016]                           computeRestarts <- base::computeRestarts
[10:27:52.016]                           grepl <- base::grepl
[10:27:52.016]                           restarts <- computeRestarts(cond)
[10:27:52.016]                           for (restart in restarts) {
[10:27:52.016]                             name <- restart$name
[10:27:52.016]                             if (is.null(name)) 
[10:27:52.016]                               next
[10:27:52.016]                             if (!grepl(pattern, name)) 
[10:27:52.016]                               next
[10:27:52.016]                             invokeRestart(restart)
[10:27:52.016]                             muffled <- TRUE
[10:27:52.016]                             break
[10:27:52.016]                           }
[10:27:52.016]                         }
[10:27:52.016]                       }
[10:27:52.016]                       invisible(muffled)
[10:27:52.016]                     }
[10:27:52.016]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.016]                   }
[10:27:52.016]                 }
[10:27:52.016]                 else {
[10:27:52.016]                   if (TRUE) {
[10:27:52.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.016]                     {
[10:27:52.016]                       inherits <- base::inherits
[10:27:52.016]                       invokeRestart <- base::invokeRestart
[10:27:52.016]                       is.null <- base::is.null
[10:27:52.016]                       muffled <- FALSE
[10:27:52.016]                       if (inherits(cond, "message")) {
[10:27:52.016]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.016]                         if (muffled) 
[10:27:52.016]                           invokeRestart("muffleMessage")
[10:27:52.016]                       }
[10:27:52.016]                       else if (inherits(cond, "warning")) {
[10:27:52.016]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.016]                         if (muffled) 
[10:27:52.016]                           invokeRestart("muffleWarning")
[10:27:52.016]                       }
[10:27:52.016]                       else if (inherits(cond, "condition")) {
[10:27:52.016]                         if (!is.null(pattern)) {
[10:27:52.016]                           computeRestarts <- base::computeRestarts
[10:27:52.016]                           grepl <- base::grepl
[10:27:52.016]                           restarts <- computeRestarts(cond)
[10:27:52.016]                           for (restart in restarts) {
[10:27:52.016]                             name <- restart$name
[10:27:52.016]                             if (is.null(name)) 
[10:27:52.016]                               next
[10:27:52.016]                             if (!grepl(pattern, name)) 
[10:27:52.016]                               next
[10:27:52.016]                             invokeRestart(restart)
[10:27:52.016]                             muffled <- TRUE
[10:27:52.016]                             break
[10:27:52.016]                           }
[10:27:52.016]                         }
[10:27:52.016]                       }
[10:27:52.016]                       invisible(muffled)
[10:27:52.016]                     }
[10:27:52.016]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.016]                   }
[10:27:52.016]                 }
[10:27:52.016]             }
[10:27:52.016]         }))
[10:27:52.016]     }, error = function(ex) {
[10:27:52.016]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:52.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.016]                 ...future.rng), started = ...future.startTime, 
[10:27:52.016]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:52.016]             version = "1.8"), class = "FutureResult")
[10:27:52.016]     }, finally = {
[10:27:52.016]         if (!identical(...future.workdir, getwd())) 
[10:27:52.016]             setwd(...future.workdir)
[10:27:52.016]         {
[10:27:52.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:52.016]                 ...future.oldOptions$nwarnings <- NULL
[10:27:52.016]             }
[10:27:52.016]             base::options(...future.oldOptions)
[10:27:52.016]             if (.Platform$OS.type == "windows") {
[10:27:52.016]                 old_names <- names(...future.oldEnvVars)
[10:27:52.016]                 envs <- base::Sys.getenv()
[10:27:52.016]                 names <- names(envs)
[10:27:52.016]                 common <- intersect(names, old_names)
[10:27:52.016]                 added <- setdiff(names, old_names)
[10:27:52.016]                 removed <- setdiff(old_names, names)
[10:27:52.016]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:52.016]                   envs[common]]
[10:27:52.016]                 NAMES <- toupper(changed)
[10:27:52.016]                 args <- list()
[10:27:52.016]                 for (kk in seq_along(NAMES)) {
[10:27:52.016]                   name <- changed[[kk]]
[10:27:52.016]                   NAME <- NAMES[[kk]]
[10:27:52.016]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.016]                     next
[10:27:52.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.016]                 }
[10:27:52.016]                 NAMES <- toupper(added)
[10:27:52.016]                 for (kk in seq_along(NAMES)) {
[10:27:52.016]                   name <- added[[kk]]
[10:27:52.016]                   NAME <- NAMES[[kk]]
[10:27:52.016]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.016]                     next
[10:27:52.016]                   args[[name]] <- ""
[10:27:52.016]                 }
[10:27:52.016]                 NAMES <- toupper(removed)
[10:27:52.016]                 for (kk in seq_along(NAMES)) {
[10:27:52.016]                   name <- removed[[kk]]
[10:27:52.016]                   NAME <- NAMES[[kk]]
[10:27:52.016]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.016]                     next
[10:27:52.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.016]                 }
[10:27:52.016]                 if (length(args) > 0) 
[10:27:52.016]                   base::do.call(base::Sys.setenv, args = args)
[10:27:52.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:52.016]             }
[10:27:52.016]             else {
[10:27:52.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:52.016]             }
[10:27:52.016]             {
[10:27:52.016]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:52.016]                   0L) {
[10:27:52.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:52.016]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:52.016]                   base::options(opts)
[10:27:52.016]                 }
[10:27:52.016]                 {
[10:27:52.016]                   {
[10:27:52.016]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:52.016]                     NULL
[10:27:52.016]                   }
[10:27:52.016]                   options(future.plan = NULL)
[10:27:52.016]                   if (is.na(NA_character_)) 
[10:27:52.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:52.016]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:52.016]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:52.016]                     envir = parent.frame()) 
[10:27:52.016]                   {
[10:27:52.016]                     if (is.function(workers)) 
[10:27:52.016]                       workers <- workers()
[10:27:52.016]                     workers <- structure(as.integer(workers), 
[10:27:52.016]                       class = class(workers))
[10:27:52.016]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:52.016]                       workers >= 1)
[10:27:52.016]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:52.016]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:52.016]                     }
[10:27:52.016]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:52.016]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:52.016]                       envir = envir)
[10:27:52.016]                     if (!future$lazy) 
[10:27:52.016]                       future <- run(future)
[10:27:52.016]                     invisible(future)
[10:27:52.016]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:52.016]                 }
[10:27:52.016]             }
[10:27:52.016]         }
[10:27:52.016]     })
[10:27:52.016]     if (TRUE) {
[10:27:52.016]         base::sink(type = "output", split = FALSE)
[10:27:52.016]         if (TRUE) {
[10:27:52.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:52.016]         }
[10:27:52.016]         else {
[10:27:52.016]             ...future.result["stdout"] <- base::list(NULL)
[10:27:52.016]         }
[10:27:52.016]         base::close(...future.stdout)
[10:27:52.016]         ...future.stdout <- NULL
[10:27:52.016]     }
[10:27:52.016]     ...future.result$conditions <- ...future.conditions
[10:27:52.016]     ...future.result$finished <- base::Sys.time()
[10:27:52.016]     ...future.result
[10:27:52.016] }
[10:27:52.020] MultisessionFuture started
[10:27:52.020] - Launch lazy future ... done
[10:27:52.020] run() for ‘MultisessionFuture’ ... done
[10:27:52.020] result() for ClusterFuture ...
[10:27:52.020] receiveMessageFromWorker() for ClusterFuture ...
[10:27:52.021] - Validating connection of MultisessionFuture
[10:27:52.071] - received message: FutureResult
[10:27:52.071] - Received FutureResult
[10:27:52.072] - Erased future from FutureRegistry
[10:27:52.072] result() for ClusterFuture ...
[10:27:52.072] - result already collected: FutureResult
[10:27:52.072] result() for ClusterFuture ... done
[10:27:52.072] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:52.072] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 10:27:52"
 $ finished    : POSIXct[1:1], format: "2025-01-07 10:27:52"
 $ session_uuid: chr "9aae1eae-5b12-11aa-1b3a-17f5fdd55b12"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3e863ac79bce"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92751
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 10:27:51"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:27:52.082] result() for ClusterFuture ...
[10:27:52.082] - result already collected: FutureResult
[10:27:52.082] result() for ClusterFuture ... done
[10:27:52.082] result() for ClusterFuture ...
[10:27:52.083] - result already collected: FutureResult
[10:27:52.083] result() for ClusterFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.009258032 secs (started 2025-01-07 10:27:52.062162)
version: 1.8
[10:27:52.083] getGlobalsAndPackages() ...
[10:27:52.084] Searching for globals...
[10:27:52.087] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:52.088] Searching for globals ... DONE
[10:27:52.088] Resolving globals: FALSE
[10:27:52.088] 
[10:27:52.088] - packages: [1] ‘utils’
[10:27:52.089] getGlobalsAndPackages() ... DONE
[10:27:52.089] run() for ‘Future’ ...
[10:27:52.089] - state: ‘created’
[10:27:52.089] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:52.104] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:52.104] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:52.104]   - Field: ‘node’
[10:27:52.104]   - Field: ‘label’
[10:27:52.104]   - Field: ‘local’
[10:27:52.104]   - Field: ‘owner’
[10:27:52.104]   - Field: ‘envir’
[10:27:52.104]   - Field: ‘workers’
[10:27:52.105]   - Field: ‘packages’
[10:27:52.105]   - Field: ‘gc’
[10:27:52.105]   - Field: ‘conditions’
[10:27:52.105]   - Field: ‘persistent’
[10:27:52.105]   - Field: ‘expr’
[10:27:52.105]   - Field: ‘uuid’
[10:27:52.105]   - Field: ‘seed’
[10:27:52.105]   - Field: ‘version’
[10:27:52.105]   - Field: ‘result’
[10:27:52.106]   - Field: ‘asynchronous’
[10:27:52.106]   - Field: ‘calls’
[10:27:52.106]   - Field: ‘globals’
[10:27:52.106]   - Field: ‘stdout’
[10:27:52.106]   - Field: ‘earlySignal’
[10:27:52.106]   - Field: ‘lazy’
[10:27:52.106]   - Field: ‘state’
[10:27:52.106] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:52.107] - Launch lazy future ...
[10:27:52.107] Packages needed by the future expression (n = 1): ‘utils’
[10:27:52.107] Packages needed by future strategies (n = 0): <none>
[10:27:52.108] {
[10:27:52.108]     {
[10:27:52.108]         {
[10:27:52.108]             ...future.startTime <- base::Sys.time()
[10:27:52.108]             {
[10:27:52.108]                 {
[10:27:52.108]                   {
[10:27:52.108]                     {
[10:27:52.108]                       {
[10:27:52.108]                         base::local({
[10:27:52.108]                           has_future <- base::requireNamespace("future", 
[10:27:52.108]                             quietly = TRUE)
[10:27:52.108]                           if (has_future) {
[10:27:52.108]                             ns <- base::getNamespace("future")
[10:27:52.108]                             version <- ns[[".package"]][["version"]]
[10:27:52.108]                             if (is.null(version)) 
[10:27:52.108]                               version <- utils::packageVersion("future")
[10:27:52.108]                           }
[10:27:52.108]                           else {
[10:27:52.108]                             version <- NULL
[10:27:52.108]                           }
[10:27:52.108]                           if (!has_future || version < "1.8.0") {
[10:27:52.108]                             info <- base::c(r_version = base::gsub("R version ", 
[10:27:52.108]                               "", base::R.version$version.string), 
[10:27:52.108]                               platform = base::sprintf("%s (%s-bit)", 
[10:27:52.108]                                 base::R.version$platform, 8 * 
[10:27:52.108]                                   base::.Machine$sizeof.pointer), 
[10:27:52.108]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:52.108]                                 "release", "version")], collapse = " "), 
[10:27:52.108]                               hostname = base::Sys.info()[["nodename"]])
[10:27:52.108]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:27:52.108]                               info)
[10:27:52.108]                             info <- base::paste(info, collapse = "; ")
[10:27:52.108]                             if (!has_future) {
[10:27:52.108]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:52.108]                                 info)
[10:27:52.108]                             }
[10:27:52.108]                             else {
[10:27:52.108]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:52.108]                                 info, version)
[10:27:52.108]                             }
[10:27:52.108]                             base::stop(msg)
[10:27:52.108]                           }
[10:27:52.108]                         })
[10:27:52.108]                       }
[10:27:52.108]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:52.108]                       base::options(mc.cores = 1L)
[10:27:52.108]                     }
[10:27:52.108]                     base::local({
[10:27:52.108]                       for (pkg in "utils") {
[10:27:52.108]                         base::loadNamespace(pkg)
[10:27:52.108]                         base::library(pkg, character.only = TRUE)
[10:27:52.108]                       }
[10:27:52.108]                     })
[10:27:52.108]                   }
[10:27:52.108]                   options(future.plan = NULL)
[10:27:52.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:52.108]                 }
[10:27:52.108]                 ...future.workdir <- getwd()
[10:27:52.108]             }
[10:27:52.108]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:52.108]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:52.108]         }
[10:27:52.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:52.108]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:52.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:52.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:52.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:52.108]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:52.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:52.108]             base::names(...future.oldOptions))
[10:27:52.108]     }
[10:27:52.108]     if (FALSE) {
[10:27:52.108]     }
[10:27:52.108]     else {
[10:27:52.108]         if (TRUE) {
[10:27:52.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:52.108]                 open = "w")
[10:27:52.108]         }
[10:27:52.108]         else {
[10:27:52.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:52.108]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:52.108]         }
[10:27:52.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:52.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:52.108]             base::sink(type = "output", split = FALSE)
[10:27:52.108]             base::close(...future.stdout)
[10:27:52.108]         }, add = TRUE)
[10:27:52.108]     }
[10:27:52.108]     ...future.frame <- base::sys.nframe()
[10:27:52.108]     ...future.conditions <- base::list()
[10:27:52.108]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:52.108]     if (FALSE) {
[10:27:52.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:52.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:52.108]     }
[10:27:52.108]     ...future.result <- base::tryCatch({
[10:27:52.108]         base::withCallingHandlers({
[10:27:52.108]             ...future.value <- base::withVisible(base::local({
[10:27:52.108]                 ...future.makeSendCondition <- base::local({
[10:27:52.108]                   sendCondition <- NULL
[10:27:52.108]                   function(frame = 1L) {
[10:27:52.108]                     if (is.function(sendCondition)) 
[10:27:52.108]                       return(sendCondition)
[10:27:52.108]                     ns <- getNamespace("parallel")
[10:27:52.108]                     if (exists("sendData", mode = "function", 
[10:27:52.108]                       envir = ns)) {
[10:27:52.108]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:52.108]                         envir = ns)
[10:27:52.108]                       envir <- sys.frame(frame)
[10:27:52.108]                       master <- NULL
[10:27:52.108]                       while (!identical(envir, .GlobalEnv) && 
[10:27:52.108]                         !identical(envir, emptyenv())) {
[10:27:52.108]                         if (exists("master", mode = "list", envir = envir, 
[10:27:52.108]                           inherits = FALSE)) {
[10:27:52.108]                           master <- get("master", mode = "list", 
[10:27:52.108]                             envir = envir, inherits = FALSE)
[10:27:52.108]                           if (inherits(master, c("SOCKnode", 
[10:27:52.108]                             "SOCK0node"))) {
[10:27:52.108]                             sendCondition <<- function(cond) {
[10:27:52.108]                               data <- list(type = "VALUE", value = cond, 
[10:27:52.108]                                 success = TRUE)
[10:27:52.108]                               parallel_sendData(master, data)
[10:27:52.108]                             }
[10:27:52.108]                             return(sendCondition)
[10:27:52.108]                           }
[10:27:52.108]                         }
[10:27:52.108]                         frame <- frame + 1L
[10:27:52.108]                         envir <- sys.frame(frame)
[10:27:52.108]                       }
[10:27:52.108]                     }
[10:27:52.108]                     sendCondition <<- function(cond) NULL
[10:27:52.108]                   }
[10:27:52.108]                 })
[10:27:52.108]                 withCallingHandlers({
[10:27:52.108]                   {
[10:27:52.108]                     print(1:50)
[10:27:52.108]                     str(1:50)
[10:27:52.108]                     cat(letters, sep = "-")
[10:27:52.108]                     cat(1:6, collapse = "\n")
[10:27:52.108]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:52.108]                     42L
[10:27:52.108]                   }
[10:27:52.108]                 }, immediateCondition = function(cond) {
[10:27:52.108]                   sendCondition <- ...future.makeSendCondition()
[10:27:52.108]                   sendCondition(cond)
[10:27:52.108]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.108]                   {
[10:27:52.108]                     inherits <- base::inherits
[10:27:52.108]                     invokeRestart <- base::invokeRestart
[10:27:52.108]                     is.null <- base::is.null
[10:27:52.108]                     muffled <- FALSE
[10:27:52.108]                     if (inherits(cond, "message")) {
[10:27:52.108]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:52.108]                       if (muffled) 
[10:27:52.108]                         invokeRestart("muffleMessage")
[10:27:52.108]                     }
[10:27:52.108]                     else if (inherits(cond, "warning")) {
[10:27:52.108]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:52.108]                       if (muffled) 
[10:27:52.108]                         invokeRestart("muffleWarning")
[10:27:52.108]                     }
[10:27:52.108]                     else if (inherits(cond, "condition")) {
[10:27:52.108]                       if (!is.null(pattern)) {
[10:27:52.108]                         computeRestarts <- base::computeRestarts
[10:27:52.108]                         grepl <- base::grepl
[10:27:52.108]                         restarts <- computeRestarts(cond)
[10:27:52.108]                         for (restart in restarts) {
[10:27:52.108]                           name <- restart$name
[10:27:52.108]                           if (is.null(name)) 
[10:27:52.108]                             next
[10:27:52.108]                           if (!grepl(pattern, name)) 
[10:27:52.108]                             next
[10:27:52.108]                           invokeRestart(restart)
[10:27:52.108]                           muffled <- TRUE
[10:27:52.108]                           break
[10:27:52.108]                         }
[10:27:52.108]                       }
[10:27:52.108]                     }
[10:27:52.108]                     invisible(muffled)
[10:27:52.108]                   }
[10:27:52.108]                   muffleCondition(cond)
[10:27:52.108]                 })
[10:27:52.108]             }))
[10:27:52.108]             future::FutureResult(value = ...future.value$value, 
[10:27:52.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.108]                   ...future.rng), globalenv = if (FALSE) 
[10:27:52.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:52.108]                     ...future.globalenv.names))
[10:27:52.108]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:52.108]         }, condition = base::local({
[10:27:52.108]             c <- base::c
[10:27:52.108]             inherits <- base::inherits
[10:27:52.108]             invokeRestart <- base::invokeRestart
[10:27:52.108]             length <- base::length
[10:27:52.108]             list <- base::list
[10:27:52.108]             seq.int <- base::seq.int
[10:27:52.108]             signalCondition <- base::signalCondition
[10:27:52.108]             sys.calls <- base::sys.calls
[10:27:52.108]             `[[` <- base::`[[`
[10:27:52.108]             `+` <- base::`+`
[10:27:52.108]             `<<-` <- base::`<<-`
[10:27:52.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:52.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:52.108]                   3L)]
[10:27:52.108]             }
[10:27:52.108]             function(cond) {
[10:27:52.108]                 is_error <- inherits(cond, "error")
[10:27:52.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:52.108]                   NULL)
[10:27:52.108]                 if (is_error) {
[10:27:52.108]                   sessionInformation <- function() {
[10:27:52.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:52.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:52.108]                       search = base::search(), system = base::Sys.info())
[10:27:52.108]                   }
[10:27:52.108]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:52.108]                     cond$call), session = sessionInformation(), 
[10:27:52.108]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:52.108]                   signalCondition(cond)
[10:27:52.108]                 }
[10:27:52.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:52.108]                 "immediateCondition"))) {
[10:27:52.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:52.108]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:52.108]                   if (TRUE && !signal) {
[10:27:52.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.108]                     {
[10:27:52.108]                       inherits <- base::inherits
[10:27:52.108]                       invokeRestart <- base::invokeRestart
[10:27:52.108]                       is.null <- base::is.null
[10:27:52.108]                       muffled <- FALSE
[10:27:52.108]                       if (inherits(cond, "message")) {
[10:27:52.108]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.108]                         if (muffled) 
[10:27:52.108]                           invokeRestart("muffleMessage")
[10:27:52.108]                       }
[10:27:52.108]                       else if (inherits(cond, "warning")) {
[10:27:52.108]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.108]                         if (muffled) 
[10:27:52.108]                           invokeRestart("muffleWarning")
[10:27:52.108]                       }
[10:27:52.108]                       else if (inherits(cond, "condition")) {
[10:27:52.108]                         if (!is.null(pattern)) {
[10:27:52.108]                           computeRestarts <- base::computeRestarts
[10:27:52.108]                           grepl <- base::grepl
[10:27:52.108]                           restarts <- computeRestarts(cond)
[10:27:52.108]                           for (restart in restarts) {
[10:27:52.108]                             name <- restart$name
[10:27:52.108]                             if (is.null(name)) 
[10:27:52.108]                               next
[10:27:52.108]                             if (!grepl(pattern, name)) 
[10:27:52.108]                               next
[10:27:52.108]                             invokeRestart(restart)
[10:27:52.108]                             muffled <- TRUE
[10:27:52.108]                             break
[10:27:52.108]                           }
[10:27:52.108]                         }
[10:27:52.108]                       }
[10:27:52.108]                       invisible(muffled)
[10:27:52.108]                     }
[10:27:52.108]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.108]                   }
[10:27:52.108]                 }
[10:27:52.108]                 else {
[10:27:52.108]                   if (TRUE) {
[10:27:52.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.108]                     {
[10:27:52.108]                       inherits <- base::inherits
[10:27:52.108]                       invokeRestart <- base::invokeRestart
[10:27:52.108]                       is.null <- base::is.null
[10:27:52.108]                       muffled <- FALSE
[10:27:52.108]                       if (inherits(cond, "message")) {
[10:27:52.108]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.108]                         if (muffled) 
[10:27:52.108]                           invokeRestart("muffleMessage")
[10:27:52.108]                       }
[10:27:52.108]                       else if (inherits(cond, "warning")) {
[10:27:52.108]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.108]                         if (muffled) 
[10:27:52.108]                           invokeRestart("muffleWarning")
[10:27:52.108]                       }
[10:27:52.108]                       else if (inherits(cond, "condition")) {
[10:27:52.108]                         if (!is.null(pattern)) {
[10:27:52.108]                           computeRestarts <- base::computeRestarts
[10:27:52.108]                           grepl <- base::grepl
[10:27:52.108]                           restarts <- computeRestarts(cond)
[10:27:52.108]                           for (restart in restarts) {
[10:27:52.108]                             name <- restart$name
[10:27:52.108]                             if (is.null(name)) 
[10:27:52.108]                               next
[10:27:52.108]                             if (!grepl(pattern, name)) 
[10:27:52.108]                               next
[10:27:52.108]                             invokeRestart(restart)
[10:27:52.108]                             muffled <- TRUE
[10:27:52.108]                             break
[10:27:52.108]                           }
[10:27:52.108]                         }
[10:27:52.108]                       }
[10:27:52.108]                       invisible(muffled)
[10:27:52.108]                     }
[10:27:52.108]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.108]                   }
[10:27:52.108]                 }
[10:27:52.108]             }
[10:27:52.108]         }))
[10:27:52.108]     }, error = function(ex) {
[10:27:52.108]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:52.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.108]                 ...future.rng), started = ...future.startTime, 
[10:27:52.108]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:52.108]             version = "1.8"), class = "FutureResult")
[10:27:52.108]     }, finally = {
[10:27:52.108]         if (!identical(...future.workdir, getwd())) 
[10:27:52.108]             setwd(...future.workdir)
[10:27:52.108]         {
[10:27:52.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:52.108]                 ...future.oldOptions$nwarnings <- NULL
[10:27:52.108]             }
[10:27:52.108]             base::options(...future.oldOptions)
[10:27:52.108]             if (.Platform$OS.type == "windows") {
[10:27:52.108]                 old_names <- names(...future.oldEnvVars)
[10:27:52.108]                 envs <- base::Sys.getenv()
[10:27:52.108]                 names <- names(envs)
[10:27:52.108]                 common <- intersect(names, old_names)
[10:27:52.108]                 added <- setdiff(names, old_names)
[10:27:52.108]                 removed <- setdiff(old_names, names)
[10:27:52.108]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:52.108]                   envs[common]]
[10:27:52.108]                 NAMES <- toupper(changed)
[10:27:52.108]                 args <- list()
[10:27:52.108]                 for (kk in seq_along(NAMES)) {
[10:27:52.108]                   name <- changed[[kk]]
[10:27:52.108]                   NAME <- NAMES[[kk]]
[10:27:52.108]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.108]                     next
[10:27:52.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.108]                 }
[10:27:52.108]                 NAMES <- toupper(added)
[10:27:52.108]                 for (kk in seq_along(NAMES)) {
[10:27:52.108]                   name <- added[[kk]]
[10:27:52.108]                   NAME <- NAMES[[kk]]
[10:27:52.108]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.108]                     next
[10:27:52.108]                   args[[name]] <- ""
[10:27:52.108]                 }
[10:27:52.108]                 NAMES <- toupper(removed)
[10:27:52.108]                 for (kk in seq_along(NAMES)) {
[10:27:52.108]                   name <- removed[[kk]]
[10:27:52.108]                   NAME <- NAMES[[kk]]
[10:27:52.108]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.108]                     next
[10:27:52.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.108]                 }
[10:27:52.108]                 if (length(args) > 0) 
[10:27:52.108]                   base::do.call(base::Sys.setenv, args = args)
[10:27:52.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:52.108]             }
[10:27:52.108]             else {
[10:27:52.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:52.108]             }
[10:27:52.108]             {
[10:27:52.108]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:52.108]                   0L) {
[10:27:52.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:52.108]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:52.108]                   base::options(opts)
[10:27:52.108]                 }
[10:27:52.108]                 {
[10:27:52.108]                   {
[10:27:52.108]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:52.108]                     NULL
[10:27:52.108]                   }
[10:27:52.108]                   options(future.plan = NULL)
[10:27:52.108]                   if (is.na(NA_character_)) 
[10:27:52.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:52.108]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:52.108]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:52.108]                     envir = parent.frame()) 
[10:27:52.108]                   {
[10:27:52.108]                     if (is.function(workers)) 
[10:27:52.108]                       workers <- workers()
[10:27:52.108]                     workers <- structure(as.integer(workers), 
[10:27:52.108]                       class = class(workers))
[10:27:52.108]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:52.108]                       workers >= 1)
[10:27:52.108]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:52.108]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:52.108]                     }
[10:27:52.108]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:52.108]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:52.108]                       envir = envir)
[10:27:52.108]                     if (!future$lazy) 
[10:27:52.108]                       future <- run(future)
[10:27:52.108]                     invisible(future)
[10:27:52.108]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:52.108]                 }
[10:27:52.108]             }
[10:27:52.108]         }
[10:27:52.108]     })
[10:27:52.108]     if (TRUE) {
[10:27:52.108]         base::sink(type = "output", split = FALSE)
[10:27:52.108]         if (TRUE) {
[10:27:52.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:52.108]         }
[10:27:52.108]         else {
[10:27:52.108]             ...future.result["stdout"] <- base::list(NULL)
[10:27:52.108]         }
[10:27:52.108]         base::close(...future.stdout)
[10:27:52.108]         ...future.stdout <- NULL
[10:27:52.108]     }
[10:27:52.108]     ...future.result$conditions <- ...future.conditions
[10:27:52.108]     ...future.result$finished <- base::Sys.time()
[10:27:52.108]     ...future.result
[10:27:52.108] }
[10:27:52.112] MultisessionFuture started
[10:27:52.112] - Launch lazy future ... done
[10:27:52.112] run() for ‘MultisessionFuture’ ... done
[10:27:52.112] result() for ClusterFuture ...
[10:27:52.112] receiveMessageFromWorker() for ClusterFuture ...
[10:27:52.113] - Validating connection of MultisessionFuture
[10:27:52.162] - received message: FutureResult
[10:27:52.162] - Received FutureResult
[10:27:52.162] - Erased future from FutureRegistry
[10:27:52.162] result() for ClusterFuture ...
[10:27:52.163] - result already collected: FutureResult
[10:27:52.163] result() for ClusterFuture ... done
[10:27:52.163] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:52.163] result() for ClusterFuture ... done
[10:27:52.163] result() for ClusterFuture ...
[10:27:52.163] - result already collected: FutureResult
[10:27:52.163] result() for ClusterFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[10:27:52.164] getGlobalsAndPackages() ...
[10:27:52.164] Searching for globals...
[10:27:52.164] - globals found: [1] ‘print’
[10:27:52.164] Searching for globals ... DONE
[10:27:52.165] Resolving globals: FALSE
[10:27:52.165] 
[10:27:52.165] 
[10:27:52.165] getGlobalsAndPackages() ... DONE
[10:27:52.165] run() for ‘Future’ ...
[10:27:52.165] - state: ‘created’
[10:27:52.166] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:52.180] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:52.180] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:52.180]   - Field: ‘node’
[10:27:52.180]   - Field: ‘label’
[10:27:52.180]   - Field: ‘local’
[10:27:52.180]   - Field: ‘owner’
[10:27:52.181]   - Field: ‘envir’
[10:27:52.181]   - Field: ‘workers’
[10:27:52.181]   - Field: ‘packages’
[10:27:52.181]   - Field: ‘gc’
[10:27:52.181]   - Field: ‘conditions’
[10:27:52.181]   - Field: ‘persistent’
[10:27:52.181]   - Field: ‘expr’
[10:27:52.181]   - Field: ‘uuid’
[10:27:52.181]   - Field: ‘seed’
[10:27:52.181]   - Field: ‘version’
[10:27:52.181]   - Field: ‘result’
[10:27:52.182]   - Field: ‘asynchronous’
[10:27:52.182]   - Field: ‘calls’
[10:27:52.182]   - Field: ‘globals’
[10:27:52.182]   - Field: ‘stdout’
[10:27:52.182]   - Field: ‘earlySignal’
[10:27:52.182]   - Field: ‘lazy’
[10:27:52.182]   - Field: ‘state’
[10:27:52.182] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:52.182] - Launch lazy future ...
[10:27:52.183] Packages needed by the future expression (n = 0): <none>
[10:27:52.183] Packages needed by future strategies (n = 0): <none>
[10:27:52.183] {
[10:27:52.183]     {
[10:27:52.183]         {
[10:27:52.183]             ...future.startTime <- base::Sys.time()
[10:27:52.183]             {
[10:27:52.183]                 {
[10:27:52.183]                   {
[10:27:52.183]                     {
[10:27:52.183]                       base::local({
[10:27:52.183]                         has_future <- base::requireNamespace("future", 
[10:27:52.183]                           quietly = TRUE)
[10:27:52.183]                         if (has_future) {
[10:27:52.183]                           ns <- base::getNamespace("future")
[10:27:52.183]                           version <- ns[[".package"]][["version"]]
[10:27:52.183]                           if (is.null(version)) 
[10:27:52.183]                             version <- utils::packageVersion("future")
[10:27:52.183]                         }
[10:27:52.183]                         else {
[10:27:52.183]                           version <- NULL
[10:27:52.183]                         }
[10:27:52.183]                         if (!has_future || version < "1.8.0") {
[10:27:52.183]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:52.183]                             "", base::R.version$version.string), 
[10:27:52.183]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:52.183]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:52.183]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:52.183]                               "release", "version")], collapse = " "), 
[10:27:52.183]                             hostname = base::Sys.info()[["nodename"]])
[10:27:52.183]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:52.183]                             info)
[10:27:52.183]                           info <- base::paste(info, collapse = "; ")
[10:27:52.183]                           if (!has_future) {
[10:27:52.183]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:52.183]                               info)
[10:27:52.183]                           }
[10:27:52.183]                           else {
[10:27:52.183]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:52.183]                               info, version)
[10:27:52.183]                           }
[10:27:52.183]                           base::stop(msg)
[10:27:52.183]                         }
[10:27:52.183]                       })
[10:27:52.183]                     }
[10:27:52.183]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:52.183]                     base::options(mc.cores = 1L)
[10:27:52.183]                   }
[10:27:52.183]                   options(future.plan = NULL)
[10:27:52.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:52.183]                 }
[10:27:52.183]                 ...future.workdir <- getwd()
[10:27:52.183]             }
[10:27:52.183]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:52.183]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:52.183]         }
[10:27:52.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:52.183]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:52.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:52.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:52.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:52.183]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:52.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:52.183]             base::names(...future.oldOptions))
[10:27:52.183]     }
[10:27:52.183]     if (FALSE) {
[10:27:52.183]     }
[10:27:52.183]     else {
[10:27:52.183]         if (TRUE) {
[10:27:52.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:52.183]                 open = "w")
[10:27:52.183]         }
[10:27:52.183]         else {
[10:27:52.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:52.183]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:52.183]         }
[10:27:52.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:52.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:52.183]             base::sink(type = "output", split = FALSE)
[10:27:52.183]             base::close(...future.stdout)
[10:27:52.183]         }, add = TRUE)
[10:27:52.183]     }
[10:27:52.183]     ...future.frame <- base::sys.nframe()
[10:27:52.183]     ...future.conditions <- base::list()
[10:27:52.183]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:52.183]     if (FALSE) {
[10:27:52.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:52.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:52.183]     }
[10:27:52.183]     ...future.result <- base::tryCatch({
[10:27:52.183]         base::withCallingHandlers({
[10:27:52.183]             ...future.value <- base::withVisible(base::local({
[10:27:52.183]                 ...future.makeSendCondition <- base::local({
[10:27:52.183]                   sendCondition <- NULL
[10:27:52.183]                   function(frame = 1L) {
[10:27:52.183]                     if (is.function(sendCondition)) 
[10:27:52.183]                       return(sendCondition)
[10:27:52.183]                     ns <- getNamespace("parallel")
[10:27:52.183]                     if (exists("sendData", mode = "function", 
[10:27:52.183]                       envir = ns)) {
[10:27:52.183]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:52.183]                         envir = ns)
[10:27:52.183]                       envir <- sys.frame(frame)
[10:27:52.183]                       master <- NULL
[10:27:52.183]                       while (!identical(envir, .GlobalEnv) && 
[10:27:52.183]                         !identical(envir, emptyenv())) {
[10:27:52.183]                         if (exists("master", mode = "list", envir = envir, 
[10:27:52.183]                           inherits = FALSE)) {
[10:27:52.183]                           master <- get("master", mode = "list", 
[10:27:52.183]                             envir = envir, inherits = FALSE)
[10:27:52.183]                           if (inherits(master, c("SOCKnode", 
[10:27:52.183]                             "SOCK0node"))) {
[10:27:52.183]                             sendCondition <<- function(cond) {
[10:27:52.183]                               data <- list(type = "VALUE", value = cond, 
[10:27:52.183]                                 success = TRUE)
[10:27:52.183]                               parallel_sendData(master, data)
[10:27:52.183]                             }
[10:27:52.183]                             return(sendCondition)
[10:27:52.183]                           }
[10:27:52.183]                         }
[10:27:52.183]                         frame <- frame + 1L
[10:27:52.183]                         envir <- sys.frame(frame)
[10:27:52.183]                       }
[10:27:52.183]                     }
[10:27:52.183]                     sendCondition <<- function(cond) NULL
[10:27:52.183]                   }
[10:27:52.183]                 })
[10:27:52.183]                 withCallingHandlers({
[10:27:52.183]                   print(42)
[10:27:52.183]                 }, immediateCondition = function(cond) {
[10:27:52.183]                   sendCondition <- ...future.makeSendCondition()
[10:27:52.183]                   sendCondition(cond)
[10:27:52.183]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.183]                   {
[10:27:52.183]                     inherits <- base::inherits
[10:27:52.183]                     invokeRestart <- base::invokeRestart
[10:27:52.183]                     is.null <- base::is.null
[10:27:52.183]                     muffled <- FALSE
[10:27:52.183]                     if (inherits(cond, "message")) {
[10:27:52.183]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:52.183]                       if (muffled) 
[10:27:52.183]                         invokeRestart("muffleMessage")
[10:27:52.183]                     }
[10:27:52.183]                     else if (inherits(cond, "warning")) {
[10:27:52.183]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:52.183]                       if (muffled) 
[10:27:52.183]                         invokeRestart("muffleWarning")
[10:27:52.183]                     }
[10:27:52.183]                     else if (inherits(cond, "condition")) {
[10:27:52.183]                       if (!is.null(pattern)) {
[10:27:52.183]                         computeRestarts <- base::computeRestarts
[10:27:52.183]                         grepl <- base::grepl
[10:27:52.183]                         restarts <- computeRestarts(cond)
[10:27:52.183]                         for (restart in restarts) {
[10:27:52.183]                           name <- restart$name
[10:27:52.183]                           if (is.null(name)) 
[10:27:52.183]                             next
[10:27:52.183]                           if (!grepl(pattern, name)) 
[10:27:52.183]                             next
[10:27:52.183]                           invokeRestart(restart)
[10:27:52.183]                           muffled <- TRUE
[10:27:52.183]                           break
[10:27:52.183]                         }
[10:27:52.183]                       }
[10:27:52.183]                     }
[10:27:52.183]                     invisible(muffled)
[10:27:52.183]                   }
[10:27:52.183]                   muffleCondition(cond)
[10:27:52.183]                 })
[10:27:52.183]             }))
[10:27:52.183]             future::FutureResult(value = ...future.value$value, 
[10:27:52.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.183]                   ...future.rng), globalenv = if (FALSE) 
[10:27:52.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:52.183]                     ...future.globalenv.names))
[10:27:52.183]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:52.183]         }, condition = base::local({
[10:27:52.183]             c <- base::c
[10:27:52.183]             inherits <- base::inherits
[10:27:52.183]             invokeRestart <- base::invokeRestart
[10:27:52.183]             length <- base::length
[10:27:52.183]             list <- base::list
[10:27:52.183]             seq.int <- base::seq.int
[10:27:52.183]             signalCondition <- base::signalCondition
[10:27:52.183]             sys.calls <- base::sys.calls
[10:27:52.183]             `[[` <- base::`[[`
[10:27:52.183]             `+` <- base::`+`
[10:27:52.183]             `<<-` <- base::`<<-`
[10:27:52.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:52.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:52.183]                   3L)]
[10:27:52.183]             }
[10:27:52.183]             function(cond) {
[10:27:52.183]                 is_error <- inherits(cond, "error")
[10:27:52.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:52.183]                   NULL)
[10:27:52.183]                 if (is_error) {
[10:27:52.183]                   sessionInformation <- function() {
[10:27:52.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:52.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:52.183]                       search = base::search(), system = base::Sys.info())
[10:27:52.183]                   }
[10:27:52.183]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:52.183]                     cond$call), session = sessionInformation(), 
[10:27:52.183]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:52.183]                   signalCondition(cond)
[10:27:52.183]                 }
[10:27:52.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:52.183]                 "immediateCondition"))) {
[10:27:52.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:52.183]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:52.183]                   if (TRUE && !signal) {
[10:27:52.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.183]                     {
[10:27:52.183]                       inherits <- base::inherits
[10:27:52.183]                       invokeRestart <- base::invokeRestart
[10:27:52.183]                       is.null <- base::is.null
[10:27:52.183]                       muffled <- FALSE
[10:27:52.183]                       if (inherits(cond, "message")) {
[10:27:52.183]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.183]                         if (muffled) 
[10:27:52.183]                           invokeRestart("muffleMessage")
[10:27:52.183]                       }
[10:27:52.183]                       else if (inherits(cond, "warning")) {
[10:27:52.183]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.183]                         if (muffled) 
[10:27:52.183]                           invokeRestart("muffleWarning")
[10:27:52.183]                       }
[10:27:52.183]                       else if (inherits(cond, "condition")) {
[10:27:52.183]                         if (!is.null(pattern)) {
[10:27:52.183]                           computeRestarts <- base::computeRestarts
[10:27:52.183]                           grepl <- base::grepl
[10:27:52.183]                           restarts <- computeRestarts(cond)
[10:27:52.183]                           for (restart in restarts) {
[10:27:52.183]                             name <- restart$name
[10:27:52.183]                             if (is.null(name)) 
[10:27:52.183]                               next
[10:27:52.183]                             if (!grepl(pattern, name)) 
[10:27:52.183]                               next
[10:27:52.183]                             invokeRestart(restart)
[10:27:52.183]                             muffled <- TRUE
[10:27:52.183]                             break
[10:27:52.183]                           }
[10:27:52.183]                         }
[10:27:52.183]                       }
[10:27:52.183]                       invisible(muffled)
[10:27:52.183]                     }
[10:27:52.183]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.183]                   }
[10:27:52.183]                 }
[10:27:52.183]                 else {
[10:27:52.183]                   if (TRUE) {
[10:27:52.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.183]                     {
[10:27:52.183]                       inherits <- base::inherits
[10:27:52.183]                       invokeRestart <- base::invokeRestart
[10:27:52.183]                       is.null <- base::is.null
[10:27:52.183]                       muffled <- FALSE
[10:27:52.183]                       if (inherits(cond, "message")) {
[10:27:52.183]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.183]                         if (muffled) 
[10:27:52.183]                           invokeRestart("muffleMessage")
[10:27:52.183]                       }
[10:27:52.183]                       else if (inherits(cond, "warning")) {
[10:27:52.183]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.183]                         if (muffled) 
[10:27:52.183]                           invokeRestart("muffleWarning")
[10:27:52.183]                       }
[10:27:52.183]                       else if (inherits(cond, "condition")) {
[10:27:52.183]                         if (!is.null(pattern)) {
[10:27:52.183]                           computeRestarts <- base::computeRestarts
[10:27:52.183]                           grepl <- base::grepl
[10:27:52.183]                           restarts <- computeRestarts(cond)
[10:27:52.183]                           for (restart in restarts) {
[10:27:52.183]                             name <- restart$name
[10:27:52.183]                             if (is.null(name)) 
[10:27:52.183]                               next
[10:27:52.183]                             if (!grepl(pattern, name)) 
[10:27:52.183]                               next
[10:27:52.183]                             invokeRestart(restart)
[10:27:52.183]                             muffled <- TRUE
[10:27:52.183]                             break
[10:27:52.183]                           }
[10:27:52.183]                         }
[10:27:52.183]                       }
[10:27:52.183]                       invisible(muffled)
[10:27:52.183]                     }
[10:27:52.183]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.183]                   }
[10:27:52.183]                 }
[10:27:52.183]             }
[10:27:52.183]         }))
[10:27:52.183]     }, error = function(ex) {
[10:27:52.183]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:52.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.183]                 ...future.rng), started = ...future.startTime, 
[10:27:52.183]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:52.183]             version = "1.8"), class = "FutureResult")
[10:27:52.183]     }, finally = {
[10:27:52.183]         if (!identical(...future.workdir, getwd())) 
[10:27:52.183]             setwd(...future.workdir)
[10:27:52.183]         {
[10:27:52.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:52.183]                 ...future.oldOptions$nwarnings <- NULL
[10:27:52.183]             }
[10:27:52.183]             base::options(...future.oldOptions)
[10:27:52.183]             if (.Platform$OS.type == "windows") {
[10:27:52.183]                 old_names <- names(...future.oldEnvVars)
[10:27:52.183]                 envs <- base::Sys.getenv()
[10:27:52.183]                 names <- names(envs)
[10:27:52.183]                 common <- intersect(names, old_names)
[10:27:52.183]                 added <- setdiff(names, old_names)
[10:27:52.183]                 removed <- setdiff(old_names, names)
[10:27:52.183]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:52.183]                   envs[common]]
[10:27:52.183]                 NAMES <- toupper(changed)
[10:27:52.183]                 args <- list()
[10:27:52.183]                 for (kk in seq_along(NAMES)) {
[10:27:52.183]                   name <- changed[[kk]]
[10:27:52.183]                   NAME <- NAMES[[kk]]
[10:27:52.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.183]                     next
[10:27:52.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.183]                 }
[10:27:52.183]                 NAMES <- toupper(added)
[10:27:52.183]                 for (kk in seq_along(NAMES)) {
[10:27:52.183]                   name <- added[[kk]]
[10:27:52.183]                   NAME <- NAMES[[kk]]
[10:27:52.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.183]                     next
[10:27:52.183]                   args[[name]] <- ""
[10:27:52.183]                 }
[10:27:52.183]                 NAMES <- toupper(removed)
[10:27:52.183]                 for (kk in seq_along(NAMES)) {
[10:27:52.183]                   name <- removed[[kk]]
[10:27:52.183]                   NAME <- NAMES[[kk]]
[10:27:52.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.183]                     next
[10:27:52.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.183]                 }
[10:27:52.183]                 if (length(args) > 0) 
[10:27:52.183]                   base::do.call(base::Sys.setenv, args = args)
[10:27:52.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:52.183]             }
[10:27:52.183]             else {
[10:27:52.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:52.183]             }
[10:27:52.183]             {
[10:27:52.183]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:52.183]                   0L) {
[10:27:52.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:52.183]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:52.183]                   base::options(opts)
[10:27:52.183]                 }
[10:27:52.183]                 {
[10:27:52.183]                   {
[10:27:52.183]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:52.183]                     NULL
[10:27:52.183]                   }
[10:27:52.183]                   options(future.plan = NULL)
[10:27:52.183]                   if (is.na(NA_character_)) 
[10:27:52.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:52.183]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:52.183]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:52.183]                     envir = parent.frame()) 
[10:27:52.183]                   {
[10:27:52.183]                     if (is.function(workers)) 
[10:27:52.183]                       workers <- workers()
[10:27:52.183]                     workers <- structure(as.integer(workers), 
[10:27:52.183]                       class = class(workers))
[10:27:52.183]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:52.183]                       workers >= 1)
[10:27:52.183]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:52.183]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:52.183]                     }
[10:27:52.183]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:52.183]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:52.183]                       envir = envir)
[10:27:52.183]                     if (!future$lazy) 
[10:27:52.183]                       future <- run(future)
[10:27:52.183]                     invisible(future)
[10:27:52.183]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:52.183]                 }
[10:27:52.183]             }
[10:27:52.183]         }
[10:27:52.183]     })
[10:27:52.183]     if (TRUE) {
[10:27:52.183]         base::sink(type = "output", split = FALSE)
[10:27:52.183]         if (TRUE) {
[10:27:52.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:52.183]         }
[10:27:52.183]         else {
[10:27:52.183]             ...future.result["stdout"] <- base::list(NULL)
[10:27:52.183]         }
[10:27:52.183]         base::close(...future.stdout)
[10:27:52.183]         ...future.stdout <- NULL
[10:27:52.183]     }
[10:27:52.183]     ...future.result$conditions <- ...future.conditions
[10:27:52.183]     ...future.result$finished <- base::Sys.time()
[10:27:52.183]     ...future.result
[10:27:52.183] }
[10:27:52.186] MultisessionFuture started
[10:27:52.187] - Launch lazy future ... done
[10:27:52.187] run() for ‘MultisessionFuture’ ... done
[10:27:52.187] result() for ClusterFuture ...
[10:27:52.187] receiveMessageFromWorker() for ClusterFuture ...
[10:27:52.187] - Validating connection of MultisessionFuture
[10:27:52.235] - received message: FutureResult
[10:27:52.235] - Received FutureResult
[10:27:52.235] - Erased future from FutureRegistry
[10:27:52.236] result() for ClusterFuture ...
[10:27:52.236] - result already collected: FutureResult
[10:27:52.236] result() for ClusterFuture ... done
[10:27:52.236] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:52.236] result() for ClusterFuture ... done
[10:27:52.236] result() for ClusterFuture ...
[10:27:52.236] - result already collected: FutureResult
[10:27:52.236] result() for ClusterFuture ... done
[10:27:52.236] result() for ClusterFuture ...
[10:27:52.237] - result already collected: FutureResult
[10:27:52.237] result() for ClusterFuture ... done
[1] 42
[10:27:52.237] result() for ClusterFuture ...
[10:27:52.237] - result already collected: FutureResult
[10:27:52.237] result() for ClusterFuture ... done
- stdout = FALSE
[10:27:52.237] getGlobalsAndPackages() ...
[10:27:52.237] Searching for globals...
[10:27:52.240] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:52.240] Searching for globals ... DONE
[10:27:52.240] Resolving globals: FALSE
[10:27:52.241] 
[10:27:52.241] - packages: [1] ‘utils’
[10:27:52.241] getGlobalsAndPackages() ... DONE
[10:27:52.241] run() for ‘Future’ ...
[10:27:52.242] - state: ‘created’
[10:27:52.242] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:52.256] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:52.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:52.256]   - Field: ‘node’
[10:27:52.256]   - Field: ‘label’
[10:27:52.256]   - Field: ‘local’
[10:27:52.256]   - Field: ‘owner’
[10:27:52.256]   - Field: ‘envir’
[10:27:52.256]   - Field: ‘workers’
[10:27:52.257]   - Field: ‘packages’
[10:27:52.257]   - Field: ‘gc’
[10:27:52.257]   - Field: ‘conditions’
[10:27:52.257]   - Field: ‘persistent’
[10:27:52.257]   - Field: ‘expr’
[10:27:52.257]   - Field: ‘uuid’
[10:27:52.257]   - Field: ‘seed’
[10:27:52.257]   - Field: ‘version’
[10:27:52.257]   - Field: ‘result’
[10:27:52.257]   - Field: ‘asynchronous’
[10:27:52.257]   - Field: ‘calls’
[10:27:52.258]   - Field: ‘globals’
[10:27:52.258]   - Field: ‘stdout’
[10:27:52.258]   - Field: ‘earlySignal’
[10:27:52.258]   - Field: ‘lazy’
[10:27:52.258]   - Field: ‘state’
[10:27:52.258] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:52.258] - Launch lazy future ...
[10:27:52.258] Packages needed by the future expression (n = 1): ‘utils’
[10:27:52.259] Packages needed by future strategies (n = 0): <none>
[10:27:52.259] {
[10:27:52.259]     {
[10:27:52.259]         {
[10:27:52.259]             ...future.startTime <- base::Sys.time()
[10:27:52.259]             {
[10:27:52.259]                 {
[10:27:52.259]                   {
[10:27:52.259]                     {
[10:27:52.259]                       {
[10:27:52.259]                         base::local({
[10:27:52.259]                           has_future <- base::requireNamespace("future", 
[10:27:52.259]                             quietly = TRUE)
[10:27:52.259]                           if (has_future) {
[10:27:52.259]                             ns <- base::getNamespace("future")
[10:27:52.259]                             version <- ns[[".package"]][["version"]]
[10:27:52.259]                             if (is.null(version)) 
[10:27:52.259]                               version <- utils::packageVersion("future")
[10:27:52.259]                           }
[10:27:52.259]                           else {
[10:27:52.259]                             version <- NULL
[10:27:52.259]                           }
[10:27:52.259]                           if (!has_future || version < "1.8.0") {
[10:27:52.259]                             info <- base::c(r_version = base::gsub("R version ", 
[10:27:52.259]                               "", base::R.version$version.string), 
[10:27:52.259]                               platform = base::sprintf("%s (%s-bit)", 
[10:27:52.259]                                 base::R.version$platform, 8 * 
[10:27:52.259]                                   base::.Machine$sizeof.pointer), 
[10:27:52.259]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:52.259]                                 "release", "version")], collapse = " "), 
[10:27:52.259]                               hostname = base::Sys.info()[["nodename"]])
[10:27:52.259]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:27:52.259]                               info)
[10:27:52.259]                             info <- base::paste(info, collapse = "; ")
[10:27:52.259]                             if (!has_future) {
[10:27:52.259]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:52.259]                                 info)
[10:27:52.259]                             }
[10:27:52.259]                             else {
[10:27:52.259]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:52.259]                                 info, version)
[10:27:52.259]                             }
[10:27:52.259]                             base::stop(msg)
[10:27:52.259]                           }
[10:27:52.259]                         })
[10:27:52.259]                       }
[10:27:52.259]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:52.259]                       base::options(mc.cores = 1L)
[10:27:52.259]                     }
[10:27:52.259]                     base::local({
[10:27:52.259]                       for (pkg in "utils") {
[10:27:52.259]                         base::loadNamespace(pkg)
[10:27:52.259]                         base::library(pkg, character.only = TRUE)
[10:27:52.259]                       }
[10:27:52.259]                     })
[10:27:52.259]                   }
[10:27:52.259]                   options(future.plan = NULL)
[10:27:52.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:52.259]                 }
[10:27:52.259]                 ...future.workdir <- getwd()
[10:27:52.259]             }
[10:27:52.259]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:52.259]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:52.259]         }
[10:27:52.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:52.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:52.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:52.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:52.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:52.259]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:52.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:52.259]             base::names(...future.oldOptions))
[10:27:52.259]     }
[10:27:52.259]     if (FALSE) {
[10:27:52.259]     }
[10:27:52.259]     else {
[10:27:52.259]         if (FALSE) {
[10:27:52.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:52.259]                 open = "w")
[10:27:52.259]         }
[10:27:52.259]         else {
[10:27:52.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:52.259]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:52.259]         }
[10:27:52.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:52.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:52.259]             base::sink(type = "output", split = FALSE)
[10:27:52.259]             base::close(...future.stdout)
[10:27:52.259]         }, add = TRUE)
[10:27:52.259]     }
[10:27:52.259]     ...future.frame <- base::sys.nframe()
[10:27:52.259]     ...future.conditions <- base::list()
[10:27:52.259]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:52.259]     if (FALSE) {
[10:27:52.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:52.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:52.259]     }
[10:27:52.259]     ...future.result <- base::tryCatch({
[10:27:52.259]         base::withCallingHandlers({
[10:27:52.259]             ...future.value <- base::withVisible(base::local({
[10:27:52.259]                 ...future.makeSendCondition <- base::local({
[10:27:52.259]                   sendCondition <- NULL
[10:27:52.259]                   function(frame = 1L) {
[10:27:52.259]                     if (is.function(sendCondition)) 
[10:27:52.259]                       return(sendCondition)
[10:27:52.259]                     ns <- getNamespace("parallel")
[10:27:52.259]                     if (exists("sendData", mode = "function", 
[10:27:52.259]                       envir = ns)) {
[10:27:52.259]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:52.259]                         envir = ns)
[10:27:52.259]                       envir <- sys.frame(frame)
[10:27:52.259]                       master <- NULL
[10:27:52.259]                       while (!identical(envir, .GlobalEnv) && 
[10:27:52.259]                         !identical(envir, emptyenv())) {
[10:27:52.259]                         if (exists("master", mode = "list", envir = envir, 
[10:27:52.259]                           inherits = FALSE)) {
[10:27:52.259]                           master <- get("master", mode = "list", 
[10:27:52.259]                             envir = envir, inherits = FALSE)
[10:27:52.259]                           if (inherits(master, c("SOCKnode", 
[10:27:52.259]                             "SOCK0node"))) {
[10:27:52.259]                             sendCondition <<- function(cond) {
[10:27:52.259]                               data <- list(type = "VALUE", value = cond, 
[10:27:52.259]                                 success = TRUE)
[10:27:52.259]                               parallel_sendData(master, data)
[10:27:52.259]                             }
[10:27:52.259]                             return(sendCondition)
[10:27:52.259]                           }
[10:27:52.259]                         }
[10:27:52.259]                         frame <- frame + 1L
[10:27:52.259]                         envir <- sys.frame(frame)
[10:27:52.259]                       }
[10:27:52.259]                     }
[10:27:52.259]                     sendCondition <<- function(cond) NULL
[10:27:52.259]                   }
[10:27:52.259]                 })
[10:27:52.259]                 withCallingHandlers({
[10:27:52.259]                   {
[10:27:52.259]                     print(1:50)
[10:27:52.259]                     str(1:50)
[10:27:52.259]                     cat(letters, sep = "-")
[10:27:52.259]                     cat(1:6, collapse = "\n")
[10:27:52.259]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:52.259]                     42L
[10:27:52.259]                   }
[10:27:52.259]                 }, immediateCondition = function(cond) {
[10:27:52.259]                   sendCondition <- ...future.makeSendCondition()
[10:27:52.259]                   sendCondition(cond)
[10:27:52.259]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.259]                   {
[10:27:52.259]                     inherits <- base::inherits
[10:27:52.259]                     invokeRestart <- base::invokeRestart
[10:27:52.259]                     is.null <- base::is.null
[10:27:52.259]                     muffled <- FALSE
[10:27:52.259]                     if (inherits(cond, "message")) {
[10:27:52.259]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:52.259]                       if (muffled) 
[10:27:52.259]                         invokeRestart("muffleMessage")
[10:27:52.259]                     }
[10:27:52.259]                     else if (inherits(cond, "warning")) {
[10:27:52.259]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:52.259]                       if (muffled) 
[10:27:52.259]                         invokeRestart("muffleWarning")
[10:27:52.259]                     }
[10:27:52.259]                     else if (inherits(cond, "condition")) {
[10:27:52.259]                       if (!is.null(pattern)) {
[10:27:52.259]                         computeRestarts <- base::computeRestarts
[10:27:52.259]                         grepl <- base::grepl
[10:27:52.259]                         restarts <- computeRestarts(cond)
[10:27:52.259]                         for (restart in restarts) {
[10:27:52.259]                           name <- restart$name
[10:27:52.259]                           if (is.null(name)) 
[10:27:52.259]                             next
[10:27:52.259]                           if (!grepl(pattern, name)) 
[10:27:52.259]                             next
[10:27:52.259]                           invokeRestart(restart)
[10:27:52.259]                           muffled <- TRUE
[10:27:52.259]                           break
[10:27:52.259]                         }
[10:27:52.259]                       }
[10:27:52.259]                     }
[10:27:52.259]                     invisible(muffled)
[10:27:52.259]                   }
[10:27:52.259]                   muffleCondition(cond)
[10:27:52.259]                 })
[10:27:52.259]             }))
[10:27:52.259]             future::FutureResult(value = ...future.value$value, 
[10:27:52.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.259]                   ...future.rng), globalenv = if (FALSE) 
[10:27:52.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:52.259]                     ...future.globalenv.names))
[10:27:52.259]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:52.259]         }, condition = base::local({
[10:27:52.259]             c <- base::c
[10:27:52.259]             inherits <- base::inherits
[10:27:52.259]             invokeRestart <- base::invokeRestart
[10:27:52.259]             length <- base::length
[10:27:52.259]             list <- base::list
[10:27:52.259]             seq.int <- base::seq.int
[10:27:52.259]             signalCondition <- base::signalCondition
[10:27:52.259]             sys.calls <- base::sys.calls
[10:27:52.259]             `[[` <- base::`[[`
[10:27:52.259]             `+` <- base::`+`
[10:27:52.259]             `<<-` <- base::`<<-`
[10:27:52.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:52.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:52.259]                   3L)]
[10:27:52.259]             }
[10:27:52.259]             function(cond) {
[10:27:52.259]                 is_error <- inherits(cond, "error")
[10:27:52.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:52.259]                   NULL)
[10:27:52.259]                 if (is_error) {
[10:27:52.259]                   sessionInformation <- function() {
[10:27:52.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:52.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:52.259]                       search = base::search(), system = base::Sys.info())
[10:27:52.259]                   }
[10:27:52.259]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:52.259]                     cond$call), session = sessionInformation(), 
[10:27:52.259]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:52.259]                   signalCondition(cond)
[10:27:52.259]                 }
[10:27:52.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:52.259]                 "immediateCondition"))) {
[10:27:52.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:52.259]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:52.259]                   if (TRUE && !signal) {
[10:27:52.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.259]                     {
[10:27:52.259]                       inherits <- base::inherits
[10:27:52.259]                       invokeRestart <- base::invokeRestart
[10:27:52.259]                       is.null <- base::is.null
[10:27:52.259]                       muffled <- FALSE
[10:27:52.259]                       if (inherits(cond, "message")) {
[10:27:52.259]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.259]                         if (muffled) 
[10:27:52.259]                           invokeRestart("muffleMessage")
[10:27:52.259]                       }
[10:27:52.259]                       else if (inherits(cond, "warning")) {
[10:27:52.259]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.259]                         if (muffled) 
[10:27:52.259]                           invokeRestart("muffleWarning")
[10:27:52.259]                       }
[10:27:52.259]                       else if (inherits(cond, "condition")) {
[10:27:52.259]                         if (!is.null(pattern)) {
[10:27:52.259]                           computeRestarts <- base::computeRestarts
[10:27:52.259]                           grepl <- base::grepl
[10:27:52.259]                           restarts <- computeRestarts(cond)
[10:27:52.259]                           for (restart in restarts) {
[10:27:52.259]                             name <- restart$name
[10:27:52.259]                             if (is.null(name)) 
[10:27:52.259]                               next
[10:27:52.259]                             if (!grepl(pattern, name)) 
[10:27:52.259]                               next
[10:27:52.259]                             invokeRestart(restart)
[10:27:52.259]                             muffled <- TRUE
[10:27:52.259]                             break
[10:27:52.259]                           }
[10:27:52.259]                         }
[10:27:52.259]                       }
[10:27:52.259]                       invisible(muffled)
[10:27:52.259]                     }
[10:27:52.259]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.259]                   }
[10:27:52.259]                 }
[10:27:52.259]                 else {
[10:27:52.259]                   if (TRUE) {
[10:27:52.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.259]                     {
[10:27:52.259]                       inherits <- base::inherits
[10:27:52.259]                       invokeRestart <- base::invokeRestart
[10:27:52.259]                       is.null <- base::is.null
[10:27:52.259]                       muffled <- FALSE
[10:27:52.259]                       if (inherits(cond, "message")) {
[10:27:52.259]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.259]                         if (muffled) 
[10:27:52.259]                           invokeRestart("muffleMessage")
[10:27:52.259]                       }
[10:27:52.259]                       else if (inherits(cond, "warning")) {
[10:27:52.259]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.259]                         if (muffled) 
[10:27:52.259]                           invokeRestart("muffleWarning")
[10:27:52.259]                       }
[10:27:52.259]                       else if (inherits(cond, "condition")) {
[10:27:52.259]                         if (!is.null(pattern)) {
[10:27:52.259]                           computeRestarts <- base::computeRestarts
[10:27:52.259]                           grepl <- base::grepl
[10:27:52.259]                           restarts <- computeRestarts(cond)
[10:27:52.259]                           for (restart in restarts) {
[10:27:52.259]                             name <- restart$name
[10:27:52.259]                             if (is.null(name)) 
[10:27:52.259]                               next
[10:27:52.259]                             if (!grepl(pattern, name)) 
[10:27:52.259]                               next
[10:27:52.259]                             invokeRestart(restart)
[10:27:52.259]                             muffled <- TRUE
[10:27:52.259]                             break
[10:27:52.259]                           }
[10:27:52.259]                         }
[10:27:52.259]                       }
[10:27:52.259]                       invisible(muffled)
[10:27:52.259]                     }
[10:27:52.259]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.259]                   }
[10:27:52.259]                 }
[10:27:52.259]             }
[10:27:52.259]         }))
[10:27:52.259]     }, error = function(ex) {
[10:27:52.259]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:52.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.259]                 ...future.rng), started = ...future.startTime, 
[10:27:52.259]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:52.259]             version = "1.8"), class = "FutureResult")
[10:27:52.259]     }, finally = {
[10:27:52.259]         if (!identical(...future.workdir, getwd())) 
[10:27:52.259]             setwd(...future.workdir)
[10:27:52.259]         {
[10:27:52.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:52.259]                 ...future.oldOptions$nwarnings <- NULL
[10:27:52.259]             }
[10:27:52.259]             base::options(...future.oldOptions)
[10:27:52.259]             if (.Platform$OS.type == "windows") {
[10:27:52.259]                 old_names <- names(...future.oldEnvVars)
[10:27:52.259]                 envs <- base::Sys.getenv()
[10:27:52.259]                 names <- names(envs)
[10:27:52.259]                 common <- intersect(names, old_names)
[10:27:52.259]                 added <- setdiff(names, old_names)
[10:27:52.259]                 removed <- setdiff(old_names, names)
[10:27:52.259]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:52.259]                   envs[common]]
[10:27:52.259]                 NAMES <- toupper(changed)
[10:27:52.259]                 args <- list()
[10:27:52.259]                 for (kk in seq_along(NAMES)) {
[10:27:52.259]                   name <- changed[[kk]]
[10:27:52.259]                   NAME <- NAMES[[kk]]
[10:27:52.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.259]                     next
[10:27:52.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.259]                 }
[10:27:52.259]                 NAMES <- toupper(added)
[10:27:52.259]                 for (kk in seq_along(NAMES)) {
[10:27:52.259]                   name <- added[[kk]]
[10:27:52.259]                   NAME <- NAMES[[kk]]
[10:27:52.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.259]                     next
[10:27:52.259]                   args[[name]] <- ""
[10:27:52.259]                 }
[10:27:52.259]                 NAMES <- toupper(removed)
[10:27:52.259]                 for (kk in seq_along(NAMES)) {
[10:27:52.259]                   name <- removed[[kk]]
[10:27:52.259]                   NAME <- NAMES[[kk]]
[10:27:52.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.259]                     next
[10:27:52.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.259]                 }
[10:27:52.259]                 if (length(args) > 0) 
[10:27:52.259]                   base::do.call(base::Sys.setenv, args = args)
[10:27:52.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:52.259]             }
[10:27:52.259]             else {
[10:27:52.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:52.259]             }
[10:27:52.259]             {
[10:27:52.259]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:52.259]                   0L) {
[10:27:52.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:52.259]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:52.259]                   base::options(opts)
[10:27:52.259]                 }
[10:27:52.259]                 {
[10:27:52.259]                   {
[10:27:52.259]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:52.259]                     NULL
[10:27:52.259]                   }
[10:27:52.259]                   options(future.plan = NULL)
[10:27:52.259]                   if (is.na(NA_character_)) 
[10:27:52.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:52.259]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:52.259]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:52.259]                     envir = parent.frame()) 
[10:27:52.259]                   {
[10:27:52.259]                     if (is.function(workers)) 
[10:27:52.259]                       workers <- workers()
[10:27:52.259]                     workers <- structure(as.integer(workers), 
[10:27:52.259]                       class = class(workers))
[10:27:52.259]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:52.259]                       workers >= 1)
[10:27:52.259]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:52.259]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:52.259]                     }
[10:27:52.259]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:52.259]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:52.259]                       envir = envir)
[10:27:52.259]                     if (!future$lazy) 
[10:27:52.259]                       future <- run(future)
[10:27:52.259]                     invisible(future)
[10:27:52.259]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:52.259]                 }
[10:27:52.259]             }
[10:27:52.259]         }
[10:27:52.259]     })
[10:27:52.259]     if (TRUE) {
[10:27:52.259]         base::sink(type = "output", split = FALSE)
[10:27:52.259]         if (FALSE) {
[10:27:52.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:52.259]         }
[10:27:52.259]         else {
[10:27:52.259]             ...future.result["stdout"] <- base::list(NULL)
[10:27:52.259]         }
[10:27:52.259]         base::close(...future.stdout)
[10:27:52.259]         ...future.stdout <- NULL
[10:27:52.259]     }
[10:27:52.259]     ...future.result$conditions <- ...future.conditions
[10:27:52.259]     ...future.result$finished <- base::Sys.time()
[10:27:52.259]     ...future.result
[10:27:52.259] }
[10:27:52.262] MultisessionFuture started
[10:27:52.263] - Launch lazy future ... done
[10:27:52.263] run() for ‘MultisessionFuture’ ... done
[10:27:52.263] result() for ClusterFuture ...
[10:27:52.263] receiveMessageFromWorker() for ClusterFuture ...
[10:27:52.263] - Validating connection of MultisessionFuture
[10:27:52.311] - received message: FutureResult
[10:27:52.312] - Received FutureResult
[10:27:52.312] - Erased future from FutureRegistry
[10:27:52.312] result() for ClusterFuture ...
[10:27:52.312] - result already collected: FutureResult
[10:27:52.312] result() for ClusterFuture ... done
[10:27:52.312] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:52.312] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 10:27:52"
 $ finished    : POSIXct[1:1], format: "2025-01-07 10:27:52"
 $ session_uuid: chr "9aae1eae-5b12-11aa-1b3a-17f5fdd55b12"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3e863ac79bce"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92751
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 10:27:51"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:27:52.320] result() for ClusterFuture ...
[10:27:52.320] - result already collected: FutureResult
[10:27:52.320] result() for ClusterFuture ... done
[10:27:52.321] result() for ClusterFuture ...
[10:27:52.321] - result already collected: FutureResult
[10:27:52.321] result() for ClusterFuture ... done
[10:27:52.321] getGlobalsAndPackages() ...
[10:27:52.321] Searching for globals...
[10:27:52.324] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:52.324] Searching for globals ... DONE
[10:27:52.324] Resolving globals: FALSE
[10:27:52.325] 
[10:27:52.325] - packages: [1] ‘utils’
[10:27:52.325] getGlobalsAndPackages() ... DONE
[10:27:52.325] run() for ‘Future’ ...
[10:27:52.325] - state: ‘created’
[10:27:52.326] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:52.339] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:52.339] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:52.339]   - Field: ‘node’
[10:27:52.340]   - Field: ‘label’
[10:27:52.340]   - Field: ‘local’
[10:27:52.340]   - Field: ‘owner’
[10:27:52.340]   - Field: ‘envir’
[10:27:52.340]   - Field: ‘workers’
[10:27:52.340]   - Field: ‘packages’
[10:27:52.340]   - Field: ‘gc’
[10:27:52.340]   - Field: ‘conditions’
[10:27:52.340]   - Field: ‘persistent’
[10:27:52.340]   - Field: ‘expr’
[10:27:52.341]   - Field: ‘uuid’
[10:27:52.341]   - Field: ‘seed’
[10:27:52.341]   - Field: ‘version’
[10:27:52.341]   - Field: ‘result’
[10:27:52.341]   - Field: ‘asynchronous’
[10:27:52.341]   - Field: ‘calls’
[10:27:52.341]   - Field: ‘globals’
[10:27:52.341]   - Field: ‘stdout’
[10:27:52.341]   - Field: ‘earlySignal’
[10:27:52.341]   - Field: ‘lazy’
[10:27:52.341]   - Field: ‘state’
[10:27:52.342] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:52.342] - Launch lazy future ...
[10:27:52.342] Packages needed by the future expression (n = 1): ‘utils’
[10:27:52.342] Packages needed by future strategies (n = 0): <none>
[10:27:52.343] {
[10:27:52.343]     {
[10:27:52.343]         {
[10:27:52.343]             ...future.startTime <- base::Sys.time()
[10:27:52.343]             {
[10:27:52.343]                 {
[10:27:52.343]                   {
[10:27:52.343]                     {
[10:27:52.343]                       {
[10:27:52.343]                         base::local({
[10:27:52.343]                           has_future <- base::requireNamespace("future", 
[10:27:52.343]                             quietly = TRUE)
[10:27:52.343]                           if (has_future) {
[10:27:52.343]                             ns <- base::getNamespace("future")
[10:27:52.343]                             version <- ns[[".package"]][["version"]]
[10:27:52.343]                             if (is.null(version)) 
[10:27:52.343]                               version <- utils::packageVersion("future")
[10:27:52.343]                           }
[10:27:52.343]                           else {
[10:27:52.343]                             version <- NULL
[10:27:52.343]                           }
[10:27:52.343]                           if (!has_future || version < "1.8.0") {
[10:27:52.343]                             info <- base::c(r_version = base::gsub("R version ", 
[10:27:52.343]                               "", base::R.version$version.string), 
[10:27:52.343]                               platform = base::sprintf("%s (%s-bit)", 
[10:27:52.343]                                 base::R.version$platform, 8 * 
[10:27:52.343]                                   base::.Machine$sizeof.pointer), 
[10:27:52.343]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:52.343]                                 "release", "version")], collapse = " "), 
[10:27:52.343]                               hostname = base::Sys.info()[["nodename"]])
[10:27:52.343]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:27:52.343]                               info)
[10:27:52.343]                             info <- base::paste(info, collapse = "; ")
[10:27:52.343]                             if (!has_future) {
[10:27:52.343]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:52.343]                                 info)
[10:27:52.343]                             }
[10:27:52.343]                             else {
[10:27:52.343]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:52.343]                                 info, version)
[10:27:52.343]                             }
[10:27:52.343]                             base::stop(msg)
[10:27:52.343]                           }
[10:27:52.343]                         })
[10:27:52.343]                       }
[10:27:52.343]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:52.343]                       base::options(mc.cores = 1L)
[10:27:52.343]                     }
[10:27:52.343]                     base::local({
[10:27:52.343]                       for (pkg in "utils") {
[10:27:52.343]                         base::loadNamespace(pkg)
[10:27:52.343]                         base::library(pkg, character.only = TRUE)
[10:27:52.343]                       }
[10:27:52.343]                     })
[10:27:52.343]                   }
[10:27:52.343]                   options(future.plan = NULL)
[10:27:52.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:52.343]                 }
[10:27:52.343]                 ...future.workdir <- getwd()
[10:27:52.343]             }
[10:27:52.343]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:52.343]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:52.343]         }
[10:27:52.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:52.343]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:52.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:52.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:52.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:52.343]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:52.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:52.343]             base::names(...future.oldOptions))
[10:27:52.343]     }
[10:27:52.343]     if (FALSE) {
[10:27:52.343]     }
[10:27:52.343]     else {
[10:27:52.343]         if (FALSE) {
[10:27:52.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:52.343]                 open = "w")
[10:27:52.343]         }
[10:27:52.343]         else {
[10:27:52.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:52.343]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:52.343]         }
[10:27:52.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:52.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:52.343]             base::sink(type = "output", split = FALSE)
[10:27:52.343]             base::close(...future.stdout)
[10:27:52.343]         }, add = TRUE)
[10:27:52.343]     }
[10:27:52.343]     ...future.frame <- base::sys.nframe()
[10:27:52.343]     ...future.conditions <- base::list()
[10:27:52.343]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:52.343]     if (FALSE) {
[10:27:52.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:52.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:52.343]     }
[10:27:52.343]     ...future.result <- base::tryCatch({
[10:27:52.343]         base::withCallingHandlers({
[10:27:52.343]             ...future.value <- base::withVisible(base::local({
[10:27:52.343]                 ...future.makeSendCondition <- base::local({
[10:27:52.343]                   sendCondition <- NULL
[10:27:52.343]                   function(frame = 1L) {
[10:27:52.343]                     if (is.function(sendCondition)) 
[10:27:52.343]                       return(sendCondition)
[10:27:52.343]                     ns <- getNamespace("parallel")
[10:27:52.343]                     if (exists("sendData", mode = "function", 
[10:27:52.343]                       envir = ns)) {
[10:27:52.343]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:52.343]                         envir = ns)
[10:27:52.343]                       envir <- sys.frame(frame)
[10:27:52.343]                       master <- NULL
[10:27:52.343]                       while (!identical(envir, .GlobalEnv) && 
[10:27:52.343]                         !identical(envir, emptyenv())) {
[10:27:52.343]                         if (exists("master", mode = "list", envir = envir, 
[10:27:52.343]                           inherits = FALSE)) {
[10:27:52.343]                           master <- get("master", mode = "list", 
[10:27:52.343]                             envir = envir, inherits = FALSE)
[10:27:52.343]                           if (inherits(master, c("SOCKnode", 
[10:27:52.343]                             "SOCK0node"))) {
[10:27:52.343]                             sendCondition <<- function(cond) {
[10:27:52.343]                               data <- list(type = "VALUE", value = cond, 
[10:27:52.343]                                 success = TRUE)
[10:27:52.343]                               parallel_sendData(master, data)
[10:27:52.343]                             }
[10:27:52.343]                             return(sendCondition)
[10:27:52.343]                           }
[10:27:52.343]                         }
[10:27:52.343]                         frame <- frame + 1L
[10:27:52.343]                         envir <- sys.frame(frame)
[10:27:52.343]                       }
[10:27:52.343]                     }
[10:27:52.343]                     sendCondition <<- function(cond) NULL
[10:27:52.343]                   }
[10:27:52.343]                 })
[10:27:52.343]                 withCallingHandlers({
[10:27:52.343]                   {
[10:27:52.343]                     print(1:50)
[10:27:52.343]                     str(1:50)
[10:27:52.343]                     cat(letters, sep = "-")
[10:27:52.343]                     cat(1:6, collapse = "\n")
[10:27:52.343]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:52.343]                     42L
[10:27:52.343]                   }
[10:27:52.343]                 }, immediateCondition = function(cond) {
[10:27:52.343]                   sendCondition <- ...future.makeSendCondition()
[10:27:52.343]                   sendCondition(cond)
[10:27:52.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.343]                   {
[10:27:52.343]                     inherits <- base::inherits
[10:27:52.343]                     invokeRestart <- base::invokeRestart
[10:27:52.343]                     is.null <- base::is.null
[10:27:52.343]                     muffled <- FALSE
[10:27:52.343]                     if (inherits(cond, "message")) {
[10:27:52.343]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:52.343]                       if (muffled) 
[10:27:52.343]                         invokeRestart("muffleMessage")
[10:27:52.343]                     }
[10:27:52.343]                     else if (inherits(cond, "warning")) {
[10:27:52.343]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:52.343]                       if (muffled) 
[10:27:52.343]                         invokeRestart("muffleWarning")
[10:27:52.343]                     }
[10:27:52.343]                     else if (inherits(cond, "condition")) {
[10:27:52.343]                       if (!is.null(pattern)) {
[10:27:52.343]                         computeRestarts <- base::computeRestarts
[10:27:52.343]                         grepl <- base::grepl
[10:27:52.343]                         restarts <- computeRestarts(cond)
[10:27:52.343]                         for (restart in restarts) {
[10:27:52.343]                           name <- restart$name
[10:27:52.343]                           if (is.null(name)) 
[10:27:52.343]                             next
[10:27:52.343]                           if (!grepl(pattern, name)) 
[10:27:52.343]                             next
[10:27:52.343]                           invokeRestart(restart)
[10:27:52.343]                           muffled <- TRUE
[10:27:52.343]                           break
[10:27:52.343]                         }
[10:27:52.343]                       }
[10:27:52.343]                     }
[10:27:52.343]                     invisible(muffled)
[10:27:52.343]                   }
[10:27:52.343]                   muffleCondition(cond)
[10:27:52.343]                 })
[10:27:52.343]             }))
[10:27:52.343]             future::FutureResult(value = ...future.value$value, 
[10:27:52.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.343]                   ...future.rng), globalenv = if (FALSE) 
[10:27:52.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:52.343]                     ...future.globalenv.names))
[10:27:52.343]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:52.343]         }, condition = base::local({
[10:27:52.343]             c <- base::c
[10:27:52.343]             inherits <- base::inherits
[10:27:52.343]             invokeRestart <- base::invokeRestart
[10:27:52.343]             length <- base::length
[10:27:52.343]             list <- base::list
[10:27:52.343]             seq.int <- base::seq.int
[10:27:52.343]             signalCondition <- base::signalCondition
[10:27:52.343]             sys.calls <- base::sys.calls
[10:27:52.343]             `[[` <- base::`[[`
[10:27:52.343]             `+` <- base::`+`
[10:27:52.343]             `<<-` <- base::`<<-`
[10:27:52.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:52.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:52.343]                   3L)]
[10:27:52.343]             }
[10:27:52.343]             function(cond) {
[10:27:52.343]                 is_error <- inherits(cond, "error")
[10:27:52.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:52.343]                   NULL)
[10:27:52.343]                 if (is_error) {
[10:27:52.343]                   sessionInformation <- function() {
[10:27:52.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:52.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:52.343]                       search = base::search(), system = base::Sys.info())
[10:27:52.343]                   }
[10:27:52.343]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:52.343]                     cond$call), session = sessionInformation(), 
[10:27:52.343]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:52.343]                   signalCondition(cond)
[10:27:52.343]                 }
[10:27:52.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:52.343]                 "immediateCondition"))) {
[10:27:52.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:52.343]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:52.343]                   if (TRUE && !signal) {
[10:27:52.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.343]                     {
[10:27:52.343]                       inherits <- base::inherits
[10:27:52.343]                       invokeRestart <- base::invokeRestart
[10:27:52.343]                       is.null <- base::is.null
[10:27:52.343]                       muffled <- FALSE
[10:27:52.343]                       if (inherits(cond, "message")) {
[10:27:52.343]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.343]                         if (muffled) 
[10:27:52.343]                           invokeRestart("muffleMessage")
[10:27:52.343]                       }
[10:27:52.343]                       else if (inherits(cond, "warning")) {
[10:27:52.343]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.343]                         if (muffled) 
[10:27:52.343]                           invokeRestart("muffleWarning")
[10:27:52.343]                       }
[10:27:52.343]                       else if (inherits(cond, "condition")) {
[10:27:52.343]                         if (!is.null(pattern)) {
[10:27:52.343]                           computeRestarts <- base::computeRestarts
[10:27:52.343]                           grepl <- base::grepl
[10:27:52.343]                           restarts <- computeRestarts(cond)
[10:27:52.343]                           for (restart in restarts) {
[10:27:52.343]                             name <- restart$name
[10:27:52.343]                             if (is.null(name)) 
[10:27:52.343]                               next
[10:27:52.343]                             if (!grepl(pattern, name)) 
[10:27:52.343]                               next
[10:27:52.343]                             invokeRestart(restart)
[10:27:52.343]                             muffled <- TRUE
[10:27:52.343]                             break
[10:27:52.343]                           }
[10:27:52.343]                         }
[10:27:52.343]                       }
[10:27:52.343]                       invisible(muffled)
[10:27:52.343]                     }
[10:27:52.343]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.343]                   }
[10:27:52.343]                 }
[10:27:52.343]                 else {
[10:27:52.343]                   if (TRUE) {
[10:27:52.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.343]                     {
[10:27:52.343]                       inherits <- base::inherits
[10:27:52.343]                       invokeRestart <- base::invokeRestart
[10:27:52.343]                       is.null <- base::is.null
[10:27:52.343]                       muffled <- FALSE
[10:27:52.343]                       if (inherits(cond, "message")) {
[10:27:52.343]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.343]                         if (muffled) 
[10:27:52.343]                           invokeRestart("muffleMessage")
[10:27:52.343]                       }
[10:27:52.343]                       else if (inherits(cond, "warning")) {
[10:27:52.343]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.343]                         if (muffled) 
[10:27:52.343]                           invokeRestart("muffleWarning")
[10:27:52.343]                       }
[10:27:52.343]                       else if (inherits(cond, "condition")) {
[10:27:52.343]                         if (!is.null(pattern)) {
[10:27:52.343]                           computeRestarts <- base::computeRestarts
[10:27:52.343]                           grepl <- base::grepl
[10:27:52.343]                           restarts <- computeRestarts(cond)
[10:27:52.343]                           for (restart in restarts) {
[10:27:52.343]                             name <- restart$name
[10:27:52.343]                             if (is.null(name)) 
[10:27:52.343]                               next
[10:27:52.343]                             if (!grepl(pattern, name)) 
[10:27:52.343]                               next
[10:27:52.343]                             invokeRestart(restart)
[10:27:52.343]                             muffled <- TRUE
[10:27:52.343]                             break
[10:27:52.343]                           }
[10:27:52.343]                         }
[10:27:52.343]                       }
[10:27:52.343]                       invisible(muffled)
[10:27:52.343]                     }
[10:27:52.343]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.343]                   }
[10:27:52.343]                 }
[10:27:52.343]             }
[10:27:52.343]         }))
[10:27:52.343]     }, error = function(ex) {
[10:27:52.343]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:52.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.343]                 ...future.rng), started = ...future.startTime, 
[10:27:52.343]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:52.343]             version = "1.8"), class = "FutureResult")
[10:27:52.343]     }, finally = {
[10:27:52.343]         if (!identical(...future.workdir, getwd())) 
[10:27:52.343]             setwd(...future.workdir)
[10:27:52.343]         {
[10:27:52.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:52.343]                 ...future.oldOptions$nwarnings <- NULL
[10:27:52.343]             }
[10:27:52.343]             base::options(...future.oldOptions)
[10:27:52.343]             if (.Platform$OS.type == "windows") {
[10:27:52.343]                 old_names <- names(...future.oldEnvVars)
[10:27:52.343]                 envs <- base::Sys.getenv()
[10:27:52.343]                 names <- names(envs)
[10:27:52.343]                 common <- intersect(names, old_names)
[10:27:52.343]                 added <- setdiff(names, old_names)
[10:27:52.343]                 removed <- setdiff(old_names, names)
[10:27:52.343]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:52.343]                   envs[common]]
[10:27:52.343]                 NAMES <- toupper(changed)
[10:27:52.343]                 args <- list()
[10:27:52.343]                 for (kk in seq_along(NAMES)) {
[10:27:52.343]                   name <- changed[[kk]]
[10:27:52.343]                   NAME <- NAMES[[kk]]
[10:27:52.343]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.343]                     next
[10:27:52.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.343]                 }
[10:27:52.343]                 NAMES <- toupper(added)
[10:27:52.343]                 for (kk in seq_along(NAMES)) {
[10:27:52.343]                   name <- added[[kk]]
[10:27:52.343]                   NAME <- NAMES[[kk]]
[10:27:52.343]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.343]                     next
[10:27:52.343]                   args[[name]] <- ""
[10:27:52.343]                 }
[10:27:52.343]                 NAMES <- toupper(removed)
[10:27:52.343]                 for (kk in seq_along(NAMES)) {
[10:27:52.343]                   name <- removed[[kk]]
[10:27:52.343]                   NAME <- NAMES[[kk]]
[10:27:52.343]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.343]                     next
[10:27:52.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.343]                 }
[10:27:52.343]                 if (length(args) > 0) 
[10:27:52.343]                   base::do.call(base::Sys.setenv, args = args)
[10:27:52.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:52.343]             }
[10:27:52.343]             else {
[10:27:52.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:52.343]             }
[10:27:52.343]             {
[10:27:52.343]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:52.343]                   0L) {
[10:27:52.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:52.343]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:52.343]                   base::options(opts)
[10:27:52.343]                 }
[10:27:52.343]                 {
[10:27:52.343]                   {
[10:27:52.343]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:52.343]                     NULL
[10:27:52.343]                   }
[10:27:52.343]                   options(future.plan = NULL)
[10:27:52.343]                   if (is.na(NA_character_)) 
[10:27:52.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:52.343]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:52.343]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:52.343]                     envir = parent.frame()) 
[10:27:52.343]                   {
[10:27:52.343]                     if (is.function(workers)) 
[10:27:52.343]                       workers <- workers()
[10:27:52.343]                     workers <- structure(as.integer(workers), 
[10:27:52.343]                       class = class(workers))
[10:27:52.343]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:52.343]                       workers >= 1)
[10:27:52.343]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:52.343]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:52.343]                     }
[10:27:52.343]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:52.343]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:52.343]                       envir = envir)
[10:27:52.343]                     if (!future$lazy) 
[10:27:52.343]                       future <- run(future)
[10:27:52.343]                     invisible(future)
[10:27:52.343]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:52.343]                 }
[10:27:52.343]             }
[10:27:52.343]         }
[10:27:52.343]     })
[10:27:52.343]     if (TRUE) {
[10:27:52.343]         base::sink(type = "output", split = FALSE)
[10:27:52.343]         if (FALSE) {
[10:27:52.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:52.343]         }
[10:27:52.343]         else {
[10:27:52.343]             ...future.result["stdout"] <- base::list(NULL)
[10:27:52.343]         }
[10:27:52.343]         base::close(...future.stdout)
[10:27:52.343]         ...future.stdout <- NULL
[10:27:52.343]     }
[10:27:52.343]     ...future.result$conditions <- ...future.conditions
[10:27:52.343]     ...future.result$finished <- base::Sys.time()
[10:27:52.343]     ...future.result
[10:27:52.343] }
[10:27:52.346] MultisessionFuture started
[10:27:52.346] - Launch lazy future ... done
[10:27:52.346] run() for ‘MultisessionFuture’ ... done
[10:27:52.347] result() for ClusterFuture ...
[10:27:52.347] receiveMessageFromWorker() for ClusterFuture ...
[10:27:52.347] - Validating connection of MultisessionFuture
[10:27:52.396] - received message: FutureResult
[10:27:52.396] - Received FutureResult
[10:27:52.396] - Erased future from FutureRegistry
[10:27:52.396] result() for ClusterFuture ...
[10:27:52.396] - result already collected: FutureResult
[10:27:52.396] result() for ClusterFuture ... done
[10:27:52.397] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:52.397] result() for ClusterFuture ... done
[10:27:52.397] result() for ClusterFuture ...
[10:27:52.397] - result already collected: FutureResult
[10:27:52.397] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[10:27:52.397] getGlobalsAndPackages() ...
[10:27:52.397] Searching for globals...
[10:27:52.398] - globals found: [1] ‘print’
[10:27:52.398] Searching for globals ... DONE
[10:27:52.398] Resolving globals: FALSE
[10:27:52.398] 
[10:27:52.399] 
[10:27:52.399] getGlobalsAndPackages() ... DONE
[10:27:52.399] run() for ‘Future’ ...
[10:27:52.399] - state: ‘created’
[10:27:52.399] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:52.413] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:52.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:52.413]   - Field: ‘node’
[10:27:52.413]   - Field: ‘label’
[10:27:52.414]   - Field: ‘local’
[10:27:52.414]   - Field: ‘owner’
[10:27:52.414]   - Field: ‘envir’
[10:27:52.414]   - Field: ‘workers’
[10:27:52.414]   - Field: ‘packages’
[10:27:52.414]   - Field: ‘gc’
[10:27:52.414]   - Field: ‘conditions’
[10:27:52.414]   - Field: ‘persistent’
[10:27:52.414]   - Field: ‘expr’
[10:27:52.414]   - Field: ‘uuid’
[10:27:52.414]   - Field: ‘seed’
[10:27:52.415]   - Field: ‘version’
[10:27:52.415]   - Field: ‘result’
[10:27:52.415]   - Field: ‘asynchronous’
[10:27:52.415]   - Field: ‘calls’
[10:27:52.415]   - Field: ‘globals’
[10:27:52.415]   - Field: ‘stdout’
[10:27:52.415]   - Field: ‘earlySignal’
[10:27:52.415]   - Field: ‘lazy’
[10:27:52.415]   - Field: ‘state’
[10:27:52.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:52.415] - Launch lazy future ...
[10:27:52.416] Packages needed by the future expression (n = 0): <none>
[10:27:52.416] Packages needed by future strategies (n = 0): <none>
[10:27:52.416] {
[10:27:52.416]     {
[10:27:52.416]         {
[10:27:52.416]             ...future.startTime <- base::Sys.time()
[10:27:52.416]             {
[10:27:52.416]                 {
[10:27:52.416]                   {
[10:27:52.416]                     {
[10:27:52.416]                       base::local({
[10:27:52.416]                         has_future <- base::requireNamespace("future", 
[10:27:52.416]                           quietly = TRUE)
[10:27:52.416]                         if (has_future) {
[10:27:52.416]                           ns <- base::getNamespace("future")
[10:27:52.416]                           version <- ns[[".package"]][["version"]]
[10:27:52.416]                           if (is.null(version)) 
[10:27:52.416]                             version <- utils::packageVersion("future")
[10:27:52.416]                         }
[10:27:52.416]                         else {
[10:27:52.416]                           version <- NULL
[10:27:52.416]                         }
[10:27:52.416]                         if (!has_future || version < "1.8.0") {
[10:27:52.416]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:52.416]                             "", base::R.version$version.string), 
[10:27:52.416]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:52.416]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:52.416]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:52.416]                               "release", "version")], collapse = " "), 
[10:27:52.416]                             hostname = base::Sys.info()[["nodename"]])
[10:27:52.416]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:52.416]                             info)
[10:27:52.416]                           info <- base::paste(info, collapse = "; ")
[10:27:52.416]                           if (!has_future) {
[10:27:52.416]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:52.416]                               info)
[10:27:52.416]                           }
[10:27:52.416]                           else {
[10:27:52.416]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:52.416]                               info, version)
[10:27:52.416]                           }
[10:27:52.416]                           base::stop(msg)
[10:27:52.416]                         }
[10:27:52.416]                       })
[10:27:52.416]                     }
[10:27:52.416]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:52.416]                     base::options(mc.cores = 1L)
[10:27:52.416]                   }
[10:27:52.416]                   options(future.plan = NULL)
[10:27:52.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:52.416]                 }
[10:27:52.416]                 ...future.workdir <- getwd()
[10:27:52.416]             }
[10:27:52.416]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:52.416]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:52.416]         }
[10:27:52.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:52.416]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:52.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:52.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:52.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:52.416]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:52.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:52.416]             base::names(...future.oldOptions))
[10:27:52.416]     }
[10:27:52.416]     if (FALSE) {
[10:27:52.416]     }
[10:27:52.416]     else {
[10:27:52.416]         if (TRUE) {
[10:27:52.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:52.416]                 open = "w")
[10:27:52.416]         }
[10:27:52.416]         else {
[10:27:52.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:52.416]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:52.416]         }
[10:27:52.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:52.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:52.416]             base::sink(type = "output", split = FALSE)
[10:27:52.416]             base::close(...future.stdout)
[10:27:52.416]         }, add = TRUE)
[10:27:52.416]     }
[10:27:52.416]     ...future.frame <- base::sys.nframe()
[10:27:52.416]     ...future.conditions <- base::list()
[10:27:52.416]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:52.416]     if (FALSE) {
[10:27:52.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:52.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:52.416]     }
[10:27:52.416]     ...future.result <- base::tryCatch({
[10:27:52.416]         base::withCallingHandlers({
[10:27:52.416]             ...future.value <- base::withVisible(base::local({
[10:27:52.416]                 ...future.makeSendCondition <- base::local({
[10:27:52.416]                   sendCondition <- NULL
[10:27:52.416]                   function(frame = 1L) {
[10:27:52.416]                     if (is.function(sendCondition)) 
[10:27:52.416]                       return(sendCondition)
[10:27:52.416]                     ns <- getNamespace("parallel")
[10:27:52.416]                     if (exists("sendData", mode = "function", 
[10:27:52.416]                       envir = ns)) {
[10:27:52.416]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:52.416]                         envir = ns)
[10:27:52.416]                       envir <- sys.frame(frame)
[10:27:52.416]                       master <- NULL
[10:27:52.416]                       while (!identical(envir, .GlobalEnv) && 
[10:27:52.416]                         !identical(envir, emptyenv())) {
[10:27:52.416]                         if (exists("master", mode = "list", envir = envir, 
[10:27:52.416]                           inherits = FALSE)) {
[10:27:52.416]                           master <- get("master", mode = "list", 
[10:27:52.416]                             envir = envir, inherits = FALSE)
[10:27:52.416]                           if (inherits(master, c("SOCKnode", 
[10:27:52.416]                             "SOCK0node"))) {
[10:27:52.416]                             sendCondition <<- function(cond) {
[10:27:52.416]                               data <- list(type = "VALUE", value = cond, 
[10:27:52.416]                                 success = TRUE)
[10:27:52.416]                               parallel_sendData(master, data)
[10:27:52.416]                             }
[10:27:52.416]                             return(sendCondition)
[10:27:52.416]                           }
[10:27:52.416]                         }
[10:27:52.416]                         frame <- frame + 1L
[10:27:52.416]                         envir <- sys.frame(frame)
[10:27:52.416]                       }
[10:27:52.416]                     }
[10:27:52.416]                     sendCondition <<- function(cond) NULL
[10:27:52.416]                   }
[10:27:52.416]                 })
[10:27:52.416]                 withCallingHandlers({
[10:27:52.416]                   print(42)
[10:27:52.416]                 }, immediateCondition = function(cond) {
[10:27:52.416]                   sendCondition <- ...future.makeSendCondition()
[10:27:52.416]                   sendCondition(cond)
[10:27:52.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.416]                   {
[10:27:52.416]                     inherits <- base::inherits
[10:27:52.416]                     invokeRestart <- base::invokeRestart
[10:27:52.416]                     is.null <- base::is.null
[10:27:52.416]                     muffled <- FALSE
[10:27:52.416]                     if (inherits(cond, "message")) {
[10:27:52.416]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:52.416]                       if (muffled) 
[10:27:52.416]                         invokeRestart("muffleMessage")
[10:27:52.416]                     }
[10:27:52.416]                     else if (inherits(cond, "warning")) {
[10:27:52.416]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:52.416]                       if (muffled) 
[10:27:52.416]                         invokeRestart("muffleWarning")
[10:27:52.416]                     }
[10:27:52.416]                     else if (inherits(cond, "condition")) {
[10:27:52.416]                       if (!is.null(pattern)) {
[10:27:52.416]                         computeRestarts <- base::computeRestarts
[10:27:52.416]                         grepl <- base::grepl
[10:27:52.416]                         restarts <- computeRestarts(cond)
[10:27:52.416]                         for (restart in restarts) {
[10:27:52.416]                           name <- restart$name
[10:27:52.416]                           if (is.null(name)) 
[10:27:52.416]                             next
[10:27:52.416]                           if (!grepl(pattern, name)) 
[10:27:52.416]                             next
[10:27:52.416]                           invokeRestart(restart)
[10:27:52.416]                           muffled <- TRUE
[10:27:52.416]                           break
[10:27:52.416]                         }
[10:27:52.416]                       }
[10:27:52.416]                     }
[10:27:52.416]                     invisible(muffled)
[10:27:52.416]                   }
[10:27:52.416]                   muffleCondition(cond)
[10:27:52.416]                 })
[10:27:52.416]             }))
[10:27:52.416]             future::FutureResult(value = ...future.value$value, 
[10:27:52.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.416]                   ...future.rng), globalenv = if (FALSE) 
[10:27:52.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:52.416]                     ...future.globalenv.names))
[10:27:52.416]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:52.416]         }, condition = base::local({
[10:27:52.416]             c <- base::c
[10:27:52.416]             inherits <- base::inherits
[10:27:52.416]             invokeRestart <- base::invokeRestart
[10:27:52.416]             length <- base::length
[10:27:52.416]             list <- base::list
[10:27:52.416]             seq.int <- base::seq.int
[10:27:52.416]             signalCondition <- base::signalCondition
[10:27:52.416]             sys.calls <- base::sys.calls
[10:27:52.416]             `[[` <- base::`[[`
[10:27:52.416]             `+` <- base::`+`
[10:27:52.416]             `<<-` <- base::`<<-`
[10:27:52.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:52.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:52.416]                   3L)]
[10:27:52.416]             }
[10:27:52.416]             function(cond) {
[10:27:52.416]                 is_error <- inherits(cond, "error")
[10:27:52.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:52.416]                   NULL)
[10:27:52.416]                 if (is_error) {
[10:27:52.416]                   sessionInformation <- function() {
[10:27:52.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:52.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:52.416]                       search = base::search(), system = base::Sys.info())
[10:27:52.416]                   }
[10:27:52.416]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:52.416]                     cond$call), session = sessionInformation(), 
[10:27:52.416]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:52.416]                   signalCondition(cond)
[10:27:52.416]                 }
[10:27:52.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:52.416]                 "immediateCondition"))) {
[10:27:52.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:52.416]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:52.416]                   if (TRUE && !signal) {
[10:27:52.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.416]                     {
[10:27:52.416]                       inherits <- base::inherits
[10:27:52.416]                       invokeRestart <- base::invokeRestart
[10:27:52.416]                       is.null <- base::is.null
[10:27:52.416]                       muffled <- FALSE
[10:27:52.416]                       if (inherits(cond, "message")) {
[10:27:52.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.416]                         if (muffled) 
[10:27:52.416]                           invokeRestart("muffleMessage")
[10:27:52.416]                       }
[10:27:52.416]                       else if (inherits(cond, "warning")) {
[10:27:52.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.416]                         if (muffled) 
[10:27:52.416]                           invokeRestart("muffleWarning")
[10:27:52.416]                       }
[10:27:52.416]                       else if (inherits(cond, "condition")) {
[10:27:52.416]                         if (!is.null(pattern)) {
[10:27:52.416]                           computeRestarts <- base::computeRestarts
[10:27:52.416]                           grepl <- base::grepl
[10:27:52.416]                           restarts <- computeRestarts(cond)
[10:27:52.416]                           for (restart in restarts) {
[10:27:52.416]                             name <- restart$name
[10:27:52.416]                             if (is.null(name)) 
[10:27:52.416]                               next
[10:27:52.416]                             if (!grepl(pattern, name)) 
[10:27:52.416]                               next
[10:27:52.416]                             invokeRestart(restart)
[10:27:52.416]                             muffled <- TRUE
[10:27:52.416]                             break
[10:27:52.416]                           }
[10:27:52.416]                         }
[10:27:52.416]                       }
[10:27:52.416]                       invisible(muffled)
[10:27:52.416]                     }
[10:27:52.416]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.416]                   }
[10:27:52.416]                 }
[10:27:52.416]                 else {
[10:27:52.416]                   if (TRUE) {
[10:27:52.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.416]                     {
[10:27:52.416]                       inherits <- base::inherits
[10:27:52.416]                       invokeRestart <- base::invokeRestart
[10:27:52.416]                       is.null <- base::is.null
[10:27:52.416]                       muffled <- FALSE
[10:27:52.416]                       if (inherits(cond, "message")) {
[10:27:52.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.416]                         if (muffled) 
[10:27:52.416]                           invokeRestart("muffleMessage")
[10:27:52.416]                       }
[10:27:52.416]                       else if (inherits(cond, "warning")) {
[10:27:52.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.416]                         if (muffled) 
[10:27:52.416]                           invokeRestart("muffleWarning")
[10:27:52.416]                       }
[10:27:52.416]                       else if (inherits(cond, "condition")) {
[10:27:52.416]                         if (!is.null(pattern)) {
[10:27:52.416]                           computeRestarts <- base::computeRestarts
[10:27:52.416]                           grepl <- base::grepl
[10:27:52.416]                           restarts <- computeRestarts(cond)
[10:27:52.416]                           for (restart in restarts) {
[10:27:52.416]                             name <- restart$name
[10:27:52.416]                             if (is.null(name)) 
[10:27:52.416]                               next
[10:27:52.416]                             if (!grepl(pattern, name)) 
[10:27:52.416]                               next
[10:27:52.416]                             invokeRestart(restart)
[10:27:52.416]                             muffled <- TRUE
[10:27:52.416]                             break
[10:27:52.416]                           }
[10:27:52.416]                         }
[10:27:52.416]                       }
[10:27:52.416]                       invisible(muffled)
[10:27:52.416]                     }
[10:27:52.416]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.416]                   }
[10:27:52.416]                 }
[10:27:52.416]             }
[10:27:52.416]         }))
[10:27:52.416]     }, error = function(ex) {
[10:27:52.416]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:52.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.416]                 ...future.rng), started = ...future.startTime, 
[10:27:52.416]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:52.416]             version = "1.8"), class = "FutureResult")
[10:27:52.416]     }, finally = {
[10:27:52.416]         if (!identical(...future.workdir, getwd())) 
[10:27:52.416]             setwd(...future.workdir)
[10:27:52.416]         {
[10:27:52.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:52.416]                 ...future.oldOptions$nwarnings <- NULL
[10:27:52.416]             }
[10:27:52.416]             base::options(...future.oldOptions)
[10:27:52.416]             if (.Platform$OS.type == "windows") {
[10:27:52.416]                 old_names <- names(...future.oldEnvVars)
[10:27:52.416]                 envs <- base::Sys.getenv()
[10:27:52.416]                 names <- names(envs)
[10:27:52.416]                 common <- intersect(names, old_names)
[10:27:52.416]                 added <- setdiff(names, old_names)
[10:27:52.416]                 removed <- setdiff(old_names, names)
[10:27:52.416]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:52.416]                   envs[common]]
[10:27:52.416]                 NAMES <- toupper(changed)
[10:27:52.416]                 args <- list()
[10:27:52.416]                 for (kk in seq_along(NAMES)) {
[10:27:52.416]                   name <- changed[[kk]]
[10:27:52.416]                   NAME <- NAMES[[kk]]
[10:27:52.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.416]                     next
[10:27:52.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.416]                 }
[10:27:52.416]                 NAMES <- toupper(added)
[10:27:52.416]                 for (kk in seq_along(NAMES)) {
[10:27:52.416]                   name <- added[[kk]]
[10:27:52.416]                   NAME <- NAMES[[kk]]
[10:27:52.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.416]                     next
[10:27:52.416]                   args[[name]] <- ""
[10:27:52.416]                 }
[10:27:52.416]                 NAMES <- toupper(removed)
[10:27:52.416]                 for (kk in seq_along(NAMES)) {
[10:27:52.416]                   name <- removed[[kk]]
[10:27:52.416]                   NAME <- NAMES[[kk]]
[10:27:52.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.416]                     next
[10:27:52.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.416]                 }
[10:27:52.416]                 if (length(args) > 0) 
[10:27:52.416]                   base::do.call(base::Sys.setenv, args = args)
[10:27:52.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:52.416]             }
[10:27:52.416]             else {
[10:27:52.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:52.416]             }
[10:27:52.416]             {
[10:27:52.416]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:52.416]                   0L) {
[10:27:52.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:52.416]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:52.416]                   base::options(opts)
[10:27:52.416]                 }
[10:27:52.416]                 {
[10:27:52.416]                   {
[10:27:52.416]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:52.416]                     NULL
[10:27:52.416]                   }
[10:27:52.416]                   options(future.plan = NULL)
[10:27:52.416]                   if (is.na(NA_character_)) 
[10:27:52.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:52.416]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:52.416]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:52.416]                     envir = parent.frame()) 
[10:27:52.416]                   {
[10:27:52.416]                     if (is.function(workers)) 
[10:27:52.416]                       workers <- workers()
[10:27:52.416]                     workers <- structure(as.integer(workers), 
[10:27:52.416]                       class = class(workers))
[10:27:52.416]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:52.416]                       workers >= 1)
[10:27:52.416]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:52.416]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:52.416]                     }
[10:27:52.416]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:52.416]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:52.416]                       envir = envir)
[10:27:52.416]                     if (!future$lazy) 
[10:27:52.416]                       future <- run(future)
[10:27:52.416]                     invisible(future)
[10:27:52.416]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:52.416]                 }
[10:27:52.416]             }
[10:27:52.416]         }
[10:27:52.416]     })
[10:27:52.416]     if (TRUE) {
[10:27:52.416]         base::sink(type = "output", split = FALSE)
[10:27:52.416]         if (TRUE) {
[10:27:52.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:52.416]         }
[10:27:52.416]         else {
[10:27:52.416]             ...future.result["stdout"] <- base::list(NULL)
[10:27:52.416]         }
[10:27:52.416]         base::close(...future.stdout)
[10:27:52.416]         ...future.stdout <- NULL
[10:27:52.416]     }
[10:27:52.416]     ...future.result$conditions <- ...future.conditions
[10:27:52.416]     ...future.result$finished <- base::Sys.time()
[10:27:52.416]     ...future.result
[10:27:52.416] }
[10:27:52.420] MultisessionFuture started
[10:27:52.420] - Launch lazy future ... done
[10:27:52.420] run() for ‘MultisessionFuture’ ... done
[10:27:52.420] result() for ClusterFuture ...
[10:27:52.420] receiveMessageFromWorker() for ClusterFuture ...
[10:27:52.420] - Validating connection of MultisessionFuture
[10:27:52.467] - received message: FutureResult
[10:27:52.467] - Received FutureResult
[10:27:52.467] - Erased future from FutureRegistry
[10:27:52.467] result() for ClusterFuture ...
[10:27:52.467] - result already collected: FutureResult
[10:27:52.468] result() for ClusterFuture ... done
[10:27:52.468] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:52.468] result() for ClusterFuture ... done
[10:27:52.468] result() for ClusterFuture ...
[10:27:52.468] - result already collected: FutureResult
[10:27:52.468] result() for ClusterFuture ... done
[10:27:52.468] result() for ClusterFuture ...
[10:27:52.468] - result already collected: FutureResult
[10:27:52.468] result() for ClusterFuture ... done
[1] 42
[10:27:52.468] result() for ClusterFuture ...
[10:27:52.468] - result already collected: FutureResult
[10:27:52.469] result() for ClusterFuture ... done
- stdout = NA
[10:27:52.469] getGlobalsAndPackages() ...
[10:27:52.469] Searching for globals...
[10:27:52.472] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:52.472] Searching for globals ... DONE
[10:27:52.472] Resolving globals: FALSE
[10:27:52.473] 
[10:27:52.473] - packages: [1] ‘utils’
[10:27:52.473] getGlobalsAndPackages() ... DONE
[10:27:52.473] run() for ‘Future’ ...
[10:27:52.473] - state: ‘created’
[10:27:52.474] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:52.487] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:52.488] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:52.488]   - Field: ‘node’
[10:27:52.488]   - Field: ‘label’
[10:27:52.488]   - Field: ‘local’
[10:27:52.488]   - Field: ‘owner’
[10:27:52.488]   - Field: ‘envir’
[10:27:52.488]   - Field: ‘workers’
[10:27:52.488]   - Field: ‘packages’
[10:27:52.488]   - Field: ‘gc’
[10:27:52.490]   - Field: ‘conditions’
[10:27:52.491]   - Field: ‘persistent’
[10:27:52.491]   - Field: ‘expr’
[10:27:52.491]   - Field: ‘uuid’
[10:27:52.491]   - Field: ‘seed’
[10:27:52.491]   - Field: ‘version’
[10:27:52.491]   - Field: ‘result’
[10:27:52.491]   - Field: ‘asynchronous’
[10:27:52.491]   - Field: ‘calls’
[10:27:52.491]   - Field: ‘globals’
[10:27:52.491]   - Field: ‘stdout’
[10:27:52.491]   - Field: ‘earlySignal’
[10:27:52.491]   - Field: ‘lazy’
[10:27:52.492]   - Field: ‘state’
[10:27:52.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:52.492] - Launch lazy future ...
[10:27:52.492] Packages needed by the future expression (n = 1): ‘utils’
[10:27:52.492] Packages needed by future strategies (n = 0): <none>
[10:27:52.493] {
[10:27:52.493]     {
[10:27:52.493]         {
[10:27:52.493]             ...future.startTime <- base::Sys.time()
[10:27:52.493]             {
[10:27:52.493]                 {
[10:27:52.493]                   {
[10:27:52.493]                     {
[10:27:52.493]                       {
[10:27:52.493]                         base::local({
[10:27:52.493]                           has_future <- base::requireNamespace("future", 
[10:27:52.493]                             quietly = TRUE)
[10:27:52.493]                           if (has_future) {
[10:27:52.493]                             ns <- base::getNamespace("future")
[10:27:52.493]                             version <- ns[[".package"]][["version"]]
[10:27:52.493]                             if (is.null(version)) 
[10:27:52.493]                               version <- utils::packageVersion("future")
[10:27:52.493]                           }
[10:27:52.493]                           else {
[10:27:52.493]                             version <- NULL
[10:27:52.493]                           }
[10:27:52.493]                           if (!has_future || version < "1.8.0") {
[10:27:52.493]                             info <- base::c(r_version = base::gsub("R version ", 
[10:27:52.493]                               "", base::R.version$version.string), 
[10:27:52.493]                               platform = base::sprintf("%s (%s-bit)", 
[10:27:52.493]                                 base::R.version$platform, 8 * 
[10:27:52.493]                                   base::.Machine$sizeof.pointer), 
[10:27:52.493]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:52.493]                                 "release", "version")], collapse = " "), 
[10:27:52.493]                               hostname = base::Sys.info()[["nodename"]])
[10:27:52.493]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:27:52.493]                               info)
[10:27:52.493]                             info <- base::paste(info, collapse = "; ")
[10:27:52.493]                             if (!has_future) {
[10:27:52.493]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:52.493]                                 info)
[10:27:52.493]                             }
[10:27:52.493]                             else {
[10:27:52.493]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:52.493]                                 info, version)
[10:27:52.493]                             }
[10:27:52.493]                             base::stop(msg)
[10:27:52.493]                           }
[10:27:52.493]                         })
[10:27:52.493]                       }
[10:27:52.493]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:52.493]                       base::options(mc.cores = 1L)
[10:27:52.493]                     }
[10:27:52.493]                     base::local({
[10:27:52.493]                       for (pkg in "utils") {
[10:27:52.493]                         base::loadNamespace(pkg)
[10:27:52.493]                         base::library(pkg, character.only = TRUE)
[10:27:52.493]                       }
[10:27:52.493]                     })
[10:27:52.493]                   }
[10:27:52.493]                   options(future.plan = NULL)
[10:27:52.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:52.493]                 }
[10:27:52.493]                 ...future.workdir <- getwd()
[10:27:52.493]             }
[10:27:52.493]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:52.493]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:52.493]         }
[10:27:52.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:52.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:52.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:52.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:52.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:52.493]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:52.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:52.493]             base::names(...future.oldOptions))
[10:27:52.493]     }
[10:27:52.493]     if (TRUE) {
[10:27:52.493]     }
[10:27:52.493]     else {
[10:27:52.493]         if (NA) {
[10:27:52.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:52.493]                 open = "w")
[10:27:52.493]         }
[10:27:52.493]         else {
[10:27:52.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:52.493]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:52.493]         }
[10:27:52.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:52.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:52.493]             base::sink(type = "output", split = FALSE)
[10:27:52.493]             base::close(...future.stdout)
[10:27:52.493]         }, add = TRUE)
[10:27:52.493]     }
[10:27:52.493]     ...future.frame <- base::sys.nframe()
[10:27:52.493]     ...future.conditions <- base::list()
[10:27:52.493]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:52.493]     if (FALSE) {
[10:27:52.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:52.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:52.493]     }
[10:27:52.493]     ...future.result <- base::tryCatch({
[10:27:52.493]         base::withCallingHandlers({
[10:27:52.493]             ...future.value <- base::withVisible(base::local({
[10:27:52.493]                 ...future.makeSendCondition <- base::local({
[10:27:52.493]                   sendCondition <- NULL
[10:27:52.493]                   function(frame = 1L) {
[10:27:52.493]                     if (is.function(sendCondition)) 
[10:27:52.493]                       return(sendCondition)
[10:27:52.493]                     ns <- getNamespace("parallel")
[10:27:52.493]                     if (exists("sendData", mode = "function", 
[10:27:52.493]                       envir = ns)) {
[10:27:52.493]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:52.493]                         envir = ns)
[10:27:52.493]                       envir <- sys.frame(frame)
[10:27:52.493]                       master <- NULL
[10:27:52.493]                       while (!identical(envir, .GlobalEnv) && 
[10:27:52.493]                         !identical(envir, emptyenv())) {
[10:27:52.493]                         if (exists("master", mode = "list", envir = envir, 
[10:27:52.493]                           inherits = FALSE)) {
[10:27:52.493]                           master <- get("master", mode = "list", 
[10:27:52.493]                             envir = envir, inherits = FALSE)
[10:27:52.493]                           if (inherits(master, c("SOCKnode", 
[10:27:52.493]                             "SOCK0node"))) {
[10:27:52.493]                             sendCondition <<- function(cond) {
[10:27:52.493]                               data <- list(type = "VALUE", value = cond, 
[10:27:52.493]                                 success = TRUE)
[10:27:52.493]                               parallel_sendData(master, data)
[10:27:52.493]                             }
[10:27:52.493]                             return(sendCondition)
[10:27:52.493]                           }
[10:27:52.493]                         }
[10:27:52.493]                         frame <- frame + 1L
[10:27:52.493]                         envir <- sys.frame(frame)
[10:27:52.493]                       }
[10:27:52.493]                     }
[10:27:52.493]                     sendCondition <<- function(cond) NULL
[10:27:52.493]                   }
[10:27:52.493]                 })
[10:27:52.493]                 withCallingHandlers({
[10:27:52.493]                   {
[10:27:52.493]                     print(1:50)
[10:27:52.493]                     str(1:50)
[10:27:52.493]                     cat(letters, sep = "-")
[10:27:52.493]                     cat(1:6, collapse = "\n")
[10:27:52.493]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:52.493]                     42L
[10:27:52.493]                   }
[10:27:52.493]                 }, immediateCondition = function(cond) {
[10:27:52.493]                   sendCondition <- ...future.makeSendCondition()
[10:27:52.493]                   sendCondition(cond)
[10:27:52.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.493]                   {
[10:27:52.493]                     inherits <- base::inherits
[10:27:52.493]                     invokeRestart <- base::invokeRestart
[10:27:52.493]                     is.null <- base::is.null
[10:27:52.493]                     muffled <- FALSE
[10:27:52.493]                     if (inherits(cond, "message")) {
[10:27:52.493]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:52.493]                       if (muffled) 
[10:27:52.493]                         invokeRestart("muffleMessage")
[10:27:52.493]                     }
[10:27:52.493]                     else if (inherits(cond, "warning")) {
[10:27:52.493]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:52.493]                       if (muffled) 
[10:27:52.493]                         invokeRestart("muffleWarning")
[10:27:52.493]                     }
[10:27:52.493]                     else if (inherits(cond, "condition")) {
[10:27:52.493]                       if (!is.null(pattern)) {
[10:27:52.493]                         computeRestarts <- base::computeRestarts
[10:27:52.493]                         grepl <- base::grepl
[10:27:52.493]                         restarts <- computeRestarts(cond)
[10:27:52.493]                         for (restart in restarts) {
[10:27:52.493]                           name <- restart$name
[10:27:52.493]                           if (is.null(name)) 
[10:27:52.493]                             next
[10:27:52.493]                           if (!grepl(pattern, name)) 
[10:27:52.493]                             next
[10:27:52.493]                           invokeRestart(restart)
[10:27:52.493]                           muffled <- TRUE
[10:27:52.493]                           break
[10:27:52.493]                         }
[10:27:52.493]                       }
[10:27:52.493]                     }
[10:27:52.493]                     invisible(muffled)
[10:27:52.493]                   }
[10:27:52.493]                   muffleCondition(cond)
[10:27:52.493]                 })
[10:27:52.493]             }))
[10:27:52.493]             future::FutureResult(value = ...future.value$value, 
[10:27:52.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.493]                   ...future.rng), globalenv = if (FALSE) 
[10:27:52.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:52.493]                     ...future.globalenv.names))
[10:27:52.493]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:52.493]         }, condition = base::local({
[10:27:52.493]             c <- base::c
[10:27:52.493]             inherits <- base::inherits
[10:27:52.493]             invokeRestart <- base::invokeRestart
[10:27:52.493]             length <- base::length
[10:27:52.493]             list <- base::list
[10:27:52.493]             seq.int <- base::seq.int
[10:27:52.493]             signalCondition <- base::signalCondition
[10:27:52.493]             sys.calls <- base::sys.calls
[10:27:52.493]             `[[` <- base::`[[`
[10:27:52.493]             `+` <- base::`+`
[10:27:52.493]             `<<-` <- base::`<<-`
[10:27:52.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:52.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:52.493]                   3L)]
[10:27:52.493]             }
[10:27:52.493]             function(cond) {
[10:27:52.493]                 is_error <- inherits(cond, "error")
[10:27:52.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:52.493]                   NULL)
[10:27:52.493]                 if (is_error) {
[10:27:52.493]                   sessionInformation <- function() {
[10:27:52.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:52.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:52.493]                       search = base::search(), system = base::Sys.info())
[10:27:52.493]                   }
[10:27:52.493]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:52.493]                     cond$call), session = sessionInformation(), 
[10:27:52.493]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:52.493]                   signalCondition(cond)
[10:27:52.493]                 }
[10:27:52.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:52.493]                 "immediateCondition"))) {
[10:27:52.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:52.493]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:52.493]                   if (TRUE && !signal) {
[10:27:52.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.493]                     {
[10:27:52.493]                       inherits <- base::inherits
[10:27:52.493]                       invokeRestart <- base::invokeRestart
[10:27:52.493]                       is.null <- base::is.null
[10:27:52.493]                       muffled <- FALSE
[10:27:52.493]                       if (inherits(cond, "message")) {
[10:27:52.493]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.493]                         if (muffled) 
[10:27:52.493]                           invokeRestart("muffleMessage")
[10:27:52.493]                       }
[10:27:52.493]                       else if (inherits(cond, "warning")) {
[10:27:52.493]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.493]                         if (muffled) 
[10:27:52.493]                           invokeRestart("muffleWarning")
[10:27:52.493]                       }
[10:27:52.493]                       else if (inherits(cond, "condition")) {
[10:27:52.493]                         if (!is.null(pattern)) {
[10:27:52.493]                           computeRestarts <- base::computeRestarts
[10:27:52.493]                           grepl <- base::grepl
[10:27:52.493]                           restarts <- computeRestarts(cond)
[10:27:52.493]                           for (restart in restarts) {
[10:27:52.493]                             name <- restart$name
[10:27:52.493]                             if (is.null(name)) 
[10:27:52.493]                               next
[10:27:52.493]                             if (!grepl(pattern, name)) 
[10:27:52.493]                               next
[10:27:52.493]                             invokeRestart(restart)
[10:27:52.493]                             muffled <- TRUE
[10:27:52.493]                             break
[10:27:52.493]                           }
[10:27:52.493]                         }
[10:27:52.493]                       }
[10:27:52.493]                       invisible(muffled)
[10:27:52.493]                     }
[10:27:52.493]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.493]                   }
[10:27:52.493]                 }
[10:27:52.493]                 else {
[10:27:52.493]                   if (TRUE) {
[10:27:52.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.493]                     {
[10:27:52.493]                       inherits <- base::inherits
[10:27:52.493]                       invokeRestart <- base::invokeRestart
[10:27:52.493]                       is.null <- base::is.null
[10:27:52.493]                       muffled <- FALSE
[10:27:52.493]                       if (inherits(cond, "message")) {
[10:27:52.493]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.493]                         if (muffled) 
[10:27:52.493]                           invokeRestart("muffleMessage")
[10:27:52.493]                       }
[10:27:52.493]                       else if (inherits(cond, "warning")) {
[10:27:52.493]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.493]                         if (muffled) 
[10:27:52.493]                           invokeRestart("muffleWarning")
[10:27:52.493]                       }
[10:27:52.493]                       else if (inherits(cond, "condition")) {
[10:27:52.493]                         if (!is.null(pattern)) {
[10:27:52.493]                           computeRestarts <- base::computeRestarts
[10:27:52.493]                           grepl <- base::grepl
[10:27:52.493]                           restarts <- computeRestarts(cond)
[10:27:52.493]                           for (restart in restarts) {
[10:27:52.493]                             name <- restart$name
[10:27:52.493]                             if (is.null(name)) 
[10:27:52.493]                               next
[10:27:52.493]                             if (!grepl(pattern, name)) 
[10:27:52.493]                               next
[10:27:52.493]                             invokeRestart(restart)
[10:27:52.493]                             muffled <- TRUE
[10:27:52.493]                             break
[10:27:52.493]                           }
[10:27:52.493]                         }
[10:27:52.493]                       }
[10:27:52.493]                       invisible(muffled)
[10:27:52.493]                     }
[10:27:52.493]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.493]                   }
[10:27:52.493]                 }
[10:27:52.493]             }
[10:27:52.493]         }))
[10:27:52.493]     }, error = function(ex) {
[10:27:52.493]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:52.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.493]                 ...future.rng), started = ...future.startTime, 
[10:27:52.493]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:52.493]             version = "1.8"), class = "FutureResult")
[10:27:52.493]     }, finally = {
[10:27:52.493]         if (!identical(...future.workdir, getwd())) 
[10:27:52.493]             setwd(...future.workdir)
[10:27:52.493]         {
[10:27:52.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:52.493]                 ...future.oldOptions$nwarnings <- NULL
[10:27:52.493]             }
[10:27:52.493]             base::options(...future.oldOptions)
[10:27:52.493]             if (.Platform$OS.type == "windows") {
[10:27:52.493]                 old_names <- names(...future.oldEnvVars)
[10:27:52.493]                 envs <- base::Sys.getenv()
[10:27:52.493]                 names <- names(envs)
[10:27:52.493]                 common <- intersect(names, old_names)
[10:27:52.493]                 added <- setdiff(names, old_names)
[10:27:52.493]                 removed <- setdiff(old_names, names)
[10:27:52.493]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:52.493]                   envs[common]]
[10:27:52.493]                 NAMES <- toupper(changed)
[10:27:52.493]                 args <- list()
[10:27:52.493]                 for (kk in seq_along(NAMES)) {
[10:27:52.493]                   name <- changed[[kk]]
[10:27:52.493]                   NAME <- NAMES[[kk]]
[10:27:52.493]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.493]                     next
[10:27:52.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.493]                 }
[10:27:52.493]                 NAMES <- toupper(added)
[10:27:52.493]                 for (kk in seq_along(NAMES)) {
[10:27:52.493]                   name <- added[[kk]]
[10:27:52.493]                   NAME <- NAMES[[kk]]
[10:27:52.493]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.493]                     next
[10:27:52.493]                   args[[name]] <- ""
[10:27:52.493]                 }
[10:27:52.493]                 NAMES <- toupper(removed)
[10:27:52.493]                 for (kk in seq_along(NAMES)) {
[10:27:52.493]                   name <- removed[[kk]]
[10:27:52.493]                   NAME <- NAMES[[kk]]
[10:27:52.493]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.493]                     next
[10:27:52.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.493]                 }
[10:27:52.493]                 if (length(args) > 0) 
[10:27:52.493]                   base::do.call(base::Sys.setenv, args = args)
[10:27:52.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:52.493]             }
[10:27:52.493]             else {
[10:27:52.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:52.493]             }
[10:27:52.493]             {
[10:27:52.493]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:52.493]                   0L) {
[10:27:52.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:52.493]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:52.493]                   base::options(opts)
[10:27:52.493]                 }
[10:27:52.493]                 {
[10:27:52.493]                   {
[10:27:52.493]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:52.493]                     NULL
[10:27:52.493]                   }
[10:27:52.493]                   options(future.plan = NULL)
[10:27:52.493]                   if (is.na(NA_character_)) 
[10:27:52.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:52.493]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:52.493]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:52.493]                     envir = parent.frame()) 
[10:27:52.493]                   {
[10:27:52.493]                     if (is.function(workers)) 
[10:27:52.493]                       workers <- workers()
[10:27:52.493]                     workers <- structure(as.integer(workers), 
[10:27:52.493]                       class = class(workers))
[10:27:52.493]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:52.493]                       workers >= 1)
[10:27:52.493]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:52.493]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:52.493]                     }
[10:27:52.493]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:52.493]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:52.493]                       envir = envir)
[10:27:52.493]                     if (!future$lazy) 
[10:27:52.493]                       future <- run(future)
[10:27:52.493]                     invisible(future)
[10:27:52.493]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:52.493]                 }
[10:27:52.493]             }
[10:27:52.493]         }
[10:27:52.493]     })
[10:27:52.493]     if (FALSE) {
[10:27:52.493]         base::sink(type = "output", split = FALSE)
[10:27:52.493]         if (NA) {
[10:27:52.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:52.493]         }
[10:27:52.493]         else {
[10:27:52.493]             ...future.result["stdout"] <- base::list(NULL)
[10:27:52.493]         }
[10:27:52.493]         base::close(...future.stdout)
[10:27:52.493]         ...future.stdout <- NULL
[10:27:52.493]     }
[10:27:52.493]     ...future.result$conditions <- ...future.conditions
[10:27:52.493]     ...future.result$finished <- base::Sys.time()
[10:27:52.493]     ...future.result
[10:27:52.493] }
[10:27:52.496] MultisessionFuture started
[10:27:52.496] - Launch lazy future ... done
[10:27:52.496] run() for ‘MultisessionFuture’ ... done
[10:27:52.497] result() for ClusterFuture ...
[10:27:52.497] receiveMessageFromWorker() for ClusterFuture ...
[10:27:52.497] - Validating connection of MultisessionFuture
[10:27:52.543] - received message: FutureResult
[10:27:52.544] - Received FutureResult
[10:27:52.544] - Erased future from FutureRegistry
[10:27:52.544] result() for ClusterFuture ...
[10:27:52.544] - result already collected: FutureResult
[10:27:52.544] result() for ClusterFuture ... done
[10:27:52.544] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:52.544] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-01-07 10:27:52"
 $ finished    : POSIXct[1:1], format: "2025-01-07 10:27:52"
 $ session_uuid: chr "9aae1eae-5b12-11aa-1b3a-17f5fdd55b12"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3e863ac79bce"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 92751
  .. ..$ time  : POSIXct[1:1], format: "2025-01-07 10:27:51"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 3 2
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:27:52.552] result() for ClusterFuture ...
[10:27:52.552] - result already collected: FutureResult
[10:27:52.552] result() for ClusterFuture ... done
[10:27:52.553] result() for ClusterFuture ...
[10:27:52.553] - result already collected: FutureResult
[10:27:52.553] result() for ClusterFuture ... done
[10:27:52.553] getGlobalsAndPackages() ...
[10:27:52.553] Searching for globals...
[10:27:52.556] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:27:52.556] Searching for globals ... DONE
[10:27:52.556] Resolving globals: FALSE
[10:27:52.557] 
[10:27:52.557] - packages: [1] ‘utils’
[10:27:52.557] getGlobalsAndPackages() ... DONE
[10:27:52.557] run() for ‘Future’ ...
[10:27:52.557] - state: ‘created’
[10:27:52.558] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:52.572] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:52.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:52.572]   - Field: ‘node’
[10:27:52.572]   - Field: ‘label’
[10:27:52.572]   - Field: ‘local’
[10:27:52.573]   - Field: ‘owner’
[10:27:52.573]   - Field: ‘envir’
[10:27:52.573]   - Field: ‘workers’
[10:27:52.573]   - Field: ‘packages’
[10:27:52.573]   - Field: ‘gc’
[10:27:52.573]   - Field: ‘conditions’
[10:27:52.573]   - Field: ‘persistent’
[10:27:52.573]   - Field: ‘expr’
[10:27:52.573]   - Field: ‘uuid’
[10:27:52.573]   - Field: ‘seed’
[10:27:52.573]   - Field: ‘version’
[10:27:52.574]   - Field: ‘result’
[10:27:52.574]   - Field: ‘asynchronous’
[10:27:52.574]   - Field: ‘calls’
[10:27:52.574]   - Field: ‘globals’
[10:27:52.574]   - Field: ‘stdout’
[10:27:52.574]   - Field: ‘earlySignal’
[10:27:52.574]   - Field: ‘lazy’
[10:27:52.574]   - Field: ‘state’
[10:27:52.574] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:52.574] - Launch lazy future ...
[10:27:52.575] Packages needed by the future expression (n = 1): ‘utils’
[10:27:52.575] Packages needed by future strategies (n = 0): <none>
[10:27:52.575] {
[10:27:52.575]     {
[10:27:52.575]         {
[10:27:52.575]             ...future.startTime <- base::Sys.time()
[10:27:52.575]             {
[10:27:52.575]                 {
[10:27:52.575]                   {
[10:27:52.575]                     {
[10:27:52.575]                       {
[10:27:52.575]                         base::local({
[10:27:52.575]                           has_future <- base::requireNamespace("future", 
[10:27:52.575]                             quietly = TRUE)
[10:27:52.575]                           if (has_future) {
[10:27:52.575]                             ns <- base::getNamespace("future")
[10:27:52.575]                             version <- ns[[".package"]][["version"]]
[10:27:52.575]                             if (is.null(version)) 
[10:27:52.575]                               version <- utils::packageVersion("future")
[10:27:52.575]                           }
[10:27:52.575]                           else {
[10:27:52.575]                             version <- NULL
[10:27:52.575]                           }
[10:27:52.575]                           if (!has_future || version < "1.8.0") {
[10:27:52.575]                             info <- base::c(r_version = base::gsub("R version ", 
[10:27:52.575]                               "", base::R.version$version.string), 
[10:27:52.575]                               platform = base::sprintf("%s (%s-bit)", 
[10:27:52.575]                                 base::R.version$platform, 8 * 
[10:27:52.575]                                   base::.Machine$sizeof.pointer), 
[10:27:52.575]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:52.575]                                 "release", "version")], collapse = " "), 
[10:27:52.575]                               hostname = base::Sys.info()[["nodename"]])
[10:27:52.575]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:27:52.575]                               info)
[10:27:52.575]                             info <- base::paste(info, collapse = "; ")
[10:27:52.575]                             if (!has_future) {
[10:27:52.575]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:52.575]                                 info)
[10:27:52.575]                             }
[10:27:52.575]                             else {
[10:27:52.575]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:52.575]                                 info, version)
[10:27:52.575]                             }
[10:27:52.575]                             base::stop(msg)
[10:27:52.575]                           }
[10:27:52.575]                         })
[10:27:52.575]                       }
[10:27:52.575]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:52.575]                       base::options(mc.cores = 1L)
[10:27:52.575]                     }
[10:27:52.575]                     base::local({
[10:27:52.575]                       for (pkg in "utils") {
[10:27:52.575]                         base::loadNamespace(pkg)
[10:27:52.575]                         base::library(pkg, character.only = TRUE)
[10:27:52.575]                       }
[10:27:52.575]                     })
[10:27:52.575]                   }
[10:27:52.575]                   options(future.plan = NULL)
[10:27:52.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:52.575]                 }
[10:27:52.575]                 ...future.workdir <- getwd()
[10:27:52.575]             }
[10:27:52.575]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:52.575]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:52.575]         }
[10:27:52.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:52.575]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:52.575]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:52.575]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:52.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:52.575]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:52.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:52.575]             base::names(...future.oldOptions))
[10:27:52.575]     }
[10:27:52.575]     if (TRUE) {
[10:27:52.575]     }
[10:27:52.575]     else {
[10:27:52.575]         if (NA) {
[10:27:52.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:52.575]                 open = "w")
[10:27:52.575]         }
[10:27:52.575]         else {
[10:27:52.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:52.575]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:52.575]         }
[10:27:52.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:52.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:52.575]             base::sink(type = "output", split = FALSE)
[10:27:52.575]             base::close(...future.stdout)
[10:27:52.575]         }, add = TRUE)
[10:27:52.575]     }
[10:27:52.575]     ...future.frame <- base::sys.nframe()
[10:27:52.575]     ...future.conditions <- base::list()
[10:27:52.575]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:52.575]     if (FALSE) {
[10:27:52.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:52.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:52.575]     }
[10:27:52.575]     ...future.result <- base::tryCatch({
[10:27:52.575]         base::withCallingHandlers({
[10:27:52.575]             ...future.value <- base::withVisible(base::local({
[10:27:52.575]                 ...future.makeSendCondition <- base::local({
[10:27:52.575]                   sendCondition <- NULL
[10:27:52.575]                   function(frame = 1L) {
[10:27:52.575]                     if (is.function(sendCondition)) 
[10:27:52.575]                       return(sendCondition)
[10:27:52.575]                     ns <- getNamespace("parallel")
[10:27:52.575]                     if (exists("sendData", mode = "function", 
[10:27:52.575]                       envir = ns)) {
[10:27:52.575]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:52.575]                         envir = ns)
[10:27:52.575]                       envir <- sys.frame(frame)
[10:27:52.575]                       master <- NULL
[10:27:52.575]                       while (!identical(envir, .GlobalEnv) && 
[10:27:52.575]                         !identical(envir, emptyenv())) {
[10:27:52.575]                         if (exists("master", mode = "list", envir = envir, 
[10:27:52.575]                           inherits = FALSE)) {
[10:27:52.575]                           master <- get("master", mode = "list", 
[10:27:52.575]                             envir = envir, inherits = FALSE)
[10:27:52.575]                           if (inherits(master, c("SOCKnode", 
[10:27:52.575]                             "SOCK0node"))) {
[10:27:52.575]                             sendCondition <<- function(cond) {
[10:27:52.575]                               data <- list(type = "VALUE", value = cond, 
[10:27:52.575]                                 success = TRUE)
[10:27:52.575]                               parallel_sendData(master, data)
[10:27:52.575]                             }
[10:27:52.575]                             return(sendCondition)
[10:27:52.575]                           }
[10:27:52.575]                         }
[10:27:52.575]                         frame <- frame + 1L
[10:27:52.575]                         envir <- sys.frame(frame)
[10:27:52.575]                       }
[10:27:52.575]                     }
[10:27:52.575]                     sendCondition <<- function(cond) NULL
[10:27:52.575]                   }
[10:27:52.575]                 })
[10:27:52.575]                 withCallingHandlers({
[10:27:52.575]                   {
[10:27:52.575]                     print(1:50)
[10:27:52.575]                     str(1:50)
[10:27:52.575]                     cat(letters, sep = "-")
[10:27:52.575]                     cat(1:6, collapse = "\n")
[10:27:52.575]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:27:52.575]                     42L
[10:27:52.575]                   }
[10:27:52.575]                 }, immediateCondition = function(cond) {
[10:27:52.575]                   sendCondition <- ...future.makeSendCondition()
[10:27:52.575]                   sendCondition(cond)
[10:27:52.575]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.575]                   {
[10:27:52.575]                     inherits <- base::inherits
[10:27:52.575]                     invokeRestart <- base::invokeRestart
[10:27:52.575]                     is.null <- base::is.null
[10:27:52.575]                     muffled <- FALSE
[10:27:52.575]                     if (inherits(cond, "message")) {
[10:27:52.575]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:52.575]                       if (muffled) 
[10:27:52.575]                         invokeRestart("muffleMessage")
[10:27:52.575]                     }
[10:27:52.575]                     else if (inherits(cond, "warning")) {
[10:27:52.575]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:52.575]                       if (muffled) 
[10:27:52.575]                         invokeRestart("muffleWarning")
[10:27:52.575]                     }
[10:27:52.575]                     else if (inherits(cond, "condition")) {
[10:27:52.575]                       if (!is.null(pattern)) {
[10:27:52.575]                         computeRestarts <- base::computeRestarts
[10:27:52.575]                         grepl <- base::grepl
[10:27:52.575]                         restarts <- computeRestarts(cond)
[10:27:52.575]                         for (restart in restarts) {
[10:27:52.575]                           name <- restart$name
[10:27:52.575]                           if (is.null(name)) 
[10:27:52.575]                             next
[10:27:52.575]                           if (!grepl(pattern, name)) 
[10:27:52.575]                             next
[10:27:52.575]                           invokeRestart(restart)
[10:27:52.575]                           muffled <- TRUE
[10:27:52.575]                           break
[10:27:52.575]                         }
[10:27:52.575]                       }
[10:27:52.575]                     }
[10:27:52.575]                     invisible(muffled)
[10:27:52.575]                   }
[10:27:52.575]                   muffleCondition(cond)
[10:27:52.575]                 })
[10:27:52.575]             }))
[10:27:52.575]             future::FutureResult(value = ...future.value$value, 
[10:27:52.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.575]                   ...future.rng), globalenv = if (FALSE) 
[10:27:52.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:52.575]                     ...future.globalenv.names))
[10:27:52.575]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:52.575]         }, condition = base::local({
[10:27:52.575]             c <- base::c
[10:27:52.575]             inherits <- base::inherits
[10:27:52.575]             invokeRestart <- base::invokeRestart
[10:27:52.575]             length <- base::length
[10:27:52.575]             list <- base::list
[10:27:52.575]             seq.int <- base::seq.int
[10:27:52.575]             signalCondition <- base::signalCondition
[10:27:52.575]             sys.calls <- base::sys.calls
[10:27:52.575]             `[[` <- base::`[[`
[10:27:52.575]             `+` <- base::`+`
[10:27:52.575]             `<<-` <- base::`<<-`
[10:27:52.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:52.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:52.575]                   3L)]
[10:27:52.575]             }
[10:27:52.575]             function(cond) {
[10:27:52.575]                 is_error <- inherits(cond, "error")
[10:27:52.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:52.575]                   NULL)
[10:27:52.575]                 if (is_error) {
[10:27:52.575]                   sessionInformation <- function() {
[10:27:52.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:52.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:52.575]                       search = base::search(), system = base::Sys.info())
[10:27:52.575]                   }
[10:27:52.575]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:52.575]                     cond$call), session = sessionInformation(), 
[10:27:52.575]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:52.575]                   signalCondition(cond)
[10:27:52.575]                 }
[10:27:52.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:52.575]                 "immediateCondition"))) {
[10:27:52.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:52.575]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:52.575]                   if (TRUE && !signal) {
[10:27:52.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.575]                     {
[10:27:52.575]                       inherits <- base::inherits
[10:27:52.575]                       invokeRestart <- base::invokeRestart
[10:27:52.575]                       is.null <- base::is.null
[10:27:52.575]                       muffled <- FALSE
[10:27:52.575]                       if (inherits(cond, "message")) {
[10:27:52.575]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.575]                         if (muffled) 
[10:27:52.575]                           invokeRestart("muffleMessage")
[10:27:52.575]                       }
[10:27:52.575]                       else if (inherits(cond, "warning")) {
[10:27:52.575]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.575]                         if (muffled) 
[10:27:52.575]                           invokeRestart("muffleWarning")
[10:27:52.575]                       }
[10:27:52.575]                       else if (inherits(cond, "condition")) {
[10:27:52.575]                         if (!is.null(pattern)) {
[10:27:52.575]                           computeRestarts <- base::computeRestarts
[10:27:52.575]                           grepl <- base::grepl
[10:27:52.575]                           restarts <- computeRestarts(cond)
[10:27:52.575]                           for (restart in restarts) {
[10:27:52.575]                             name <- restart$name
[10:27:52.575]                             if (is.null(name)) 
[10:27:52.575]                               next
[10:27:52.575]                             if (!grepl(pattern, name)) 
[10:27:52.575]                               next
[10:27:52.575]                             invokeRestart(restart)
[10:27:52.575]                             muffled <- TRUE
[10:27:52.575]                             break
[10:27:52.575]                           }
[10:27:52.575]                         }
[10:27:52.575]                       }
[10:27:52.575]                       invisible(muffled)
[10:27:52.575]                     }
[10:27:52.575]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.575]                   }
[10:27:52.575]                 }
[10:27:52.575]                 else {
[10:27:52.575]                   if (TRUE) {
[10:27:52.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.575]                     {
[10:27:52.575]                       inherits <- base::inherits
[10:27:52.575]                       invokeRestart <- base::invokeRestart
[10:27:52.575]                       is.null <- base::is.null
[10:27:52.575]                       muffled <- FALSE
[10:27:52.575]                       if (inherits(cond, "message")) {
[10:27:52.575]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.575]                         if (muffled) 
[10:27:52.575]                           invokeRestart("muffleMessage")
[10:27:52.575]                       }
[10:27:52.575]                       else if (inherits(cond, "warning")) {
[10:27:52.575]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.575]                         if (muffled) 
[10:27:52.575]                           invokeRestart("muffleWarning")
[10:27:52.575]                       }
[10:27:52.575]                       else if (inherits(cond, "condition")) {
[10:27:52.575]                         if (!is.null(pattern)) {
[10:27:52.575]                           computeRestarts <- base::computeRestarts
[10:27:52.575]                           grepl <- base::grepl
[10:27:52.575]                           restarts <- computeRestarts(cond)
[10:27:52.575]                           for (restart in restarts) {
[10:27:52.575]                             name <- restart$name
[10:27:52.575]                             if (is.null(name)) 
[10:27:52.575]                               next
[10:27:52.575]                             if (!grepl(pattern, name)) 
[10:27:52.575]                               next
[10:27:52.575]                             invokeRestart(restart)
[10:27:52.575]                             muffled <- TRUE
[10:27:52.575]                             break
[10:27:52.575]                           }
[10:27:52.575]                         }
[10:27:52.575]                       }
[10:27:52.575]                       invisible(muffled)
[10:27:52.575]                     }
[10:27:52.575]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.575]                   }
[10:27:52.575]                 }
[10:27:52.575]             }
[10:27:52.575]         }))
[10:27:52.575]     }, error = function(ex) {
[10:27:52.575]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:52.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.575]                 ...future.rng), started = ...future.startTime, 
[10:27:52.575]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:52.575]             version = "1.8"), class = "FutureResult")
[10:27:52.575]     }, finally = {
[10:27:52.575]         if (!identical(...future.workdir, getwd())) 
[10:27:52.575]             setwd(...future.workdir)
[10:27:52.575]         {
[10:27:52.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:52.575]                 ...future.oldOptions$nwarnings <- NULL
[10:27:52.575]             }
[10:27:52.575]             base::options(...future.oldOptions)
[10:27:52.575]             if (.Platform$OS.type == "windows") {
[10:27:52.575]                 old_names <- names(...future.oldEnvVars)
[10:27:52.575]                 envs <- base::Sys.getenv()
[10:27:52.575]                 names <- names(envs)
[10:27:52.575]                 common <- intersect(names, old_names)
[10:27:52.575]                 added <- setdiff(names, old_names)
[10:27:52.575]                 removed <- setdiff(old_names, names)
[10:27:52.575]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:52.575]                   envs[common]]
[10:27:52.575]                 NAMES <- toupper(changed)
[10:27:52.575]                 args <- list()
[10:27:52.575]                 for (kk in seq_along(NAMES)) {
[10:27:52.575]                   name <- changed[[kk]]
[10:27:52.575]                   NAME <- NAMES[[kk]]
[10:27:52.575]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.575]                     next
[10:27:52.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.575]                 }
[10:27:52.575]                 NAMES <- toupper(added)
[10:27:52.575]                 for (kk in seq_along(NAMES)) {
[10:27:52.575]                   name <- added[[kk]]
[10:27:52.575]                   NAME <- NAMES[[kk]]
[10:27:52.575]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.575]                     next
[10:27:52.575]                   args[[name]] <- ""
[10:27:52.575]                 }
[10:27:52.575]                 NAMES <- toupper(removed)
[10:27:52.575]                 for (kk in seq_along(NAMES)) {
[10:27:52.575]                   name <- removed[[kk]]
[10:27:52.575]                   NAME <- NAMES[[kk]]
[10:27:52.575]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.575]                     next
[10:27:52.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.575]                 }
[10:27:52.575]                 if (length(args) > 0) 
[10:27:52.575]                   base::do.call(base::Sys.setenv, args = args)
[10:27:52.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:52.575]             }
[10:27:52.575]             else {
[10:27:52.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:52.575]             }
[10:27:52.575]             {
[10:27:52.575]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:52.575]                   0L) {
[10:27:52.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:52.575]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:52.575]                   base::options(opts)
[10:27:52.575]                 }
[10:27:52.575]                 {
[10:27:52.575]                   {
[10:27:52.575]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:52.575]                     NULL
[10:27:52.575]                   }
[10:27:52.575]                   options(future.plan = NULL)
[10:27:52.575]                   if (is.na(NA_character_)) 
[10:27:52.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:52.575]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:52.575]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:52.575]                     envir = parent.frame()) 
[10:27:52.575]                   {
[10:27:52.575]                     if (is.function(workers)) 
[10:27:52.575]                       workers <- workers()
[10:27:52.575]                     workers <- structure(as.integer(workers), 
[10:27:52.575]                       class = class(workers))
[10:27:52.575]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:52.575]                       workers >= 1)
[10:27:52.575]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:52.575]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:52.575]                     }
[10:27:52.575]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:52.575]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:52.575]                       envir = envir)
[10:27:52.575]                     if (!future$lazy) 
[10:27:52.575]                       future <- run(future)
[10:27:52.575]                     invisible(future)
[10:27:52.575]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:52.575]                 }
[10:27:52.575]             }
[10:27:52.575]         }
[10:27:52.575]     })
[10:27:52.575]     if (FALSE) {
[10:27:52.575]         base::sink(type = "output", split = FALSE)
[10:27:52.575]         if (NA) {
[10:27:52.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:52.575]         }
[10:27:52.575]         else {
[10:27:52.575]             ...future.result["stdout"] <- base::list(NULL)
[10:27:52.575]         }
[10:27:52.575]         base::close(...future.stdout)
[10:27:52.575]         ...future.stdout <- NULL
[10:27:52.575]     }
[10:27:52.575]     ...future.result$conditions <- ...future.conditions
[10:27:52.575]     ...future.result$finished <- base::Sys.time()
[10:27:52.575]     ...future.result
[10:27:52.575] }
[10:27:52.579] MultisessionFuture started
[10:27:52.579] - Launch lazy future ... done
[10:27:52.579] run() for ‘MultisessionFuture’ ... done
[10:27:52.579] result() for ClusterFuture ...
[10:27:52.580] receiveMessageFromWorker() for ClusterFuture ...
[10:27:52.580] - Validating connection of MultisessionFuture
[10:27:52.627] - received message: FutureResult
[10:27:52.628] - Received FutureResult
[10:27:52.628] - Erased future from FutureRegistry
[10:27:52.628] result() for ClusterFuture ...
[10:27:52.628] - result already collected: FutureResult
[10:27:52.628] result() for ClusterFuture ... done
[10:27:52.628] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:52.628] result() for ClusterFuture ... done
[10:27:52.628] result() for ClusterFuture ...
[10:27:52.629] - result already collected: FutureResult
[10:27:52.629] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[10:27:52.629] getGlobalsAndPackages() ...
[10:27:52.629] Searching for globals...
[10:27:52.630] - globals found: [1] ‘print’
[10:27:52.630] Searching for globals ... DONE
[10:27:52.630] Resolving globals: FALSE
[10:27:52.630] 
[10:27:52.630] 
[10:27:52.630] getGlobalsAndPackages() ... DONE
[10:27:52.631] run() for ‘Future’ ...
[10:27:52.631] - state: ‘created’
[10:27:52.631] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:52.644] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:52.645] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:52.645]   - Field: ‘node’
[10:27:52.645]   - Field: ‘label’
[10:27:52.645]   - Field: ‘local’
[10:27:52.645]   - Field: ‘owner’
[10:27:52.645]   - Field: ‘envir’
[10:27:52.645]   - Field: ‘workers’
[10:27:52.645]   - Field: ‘packages’
[10:27:52.645]   - Field: ‘gc’
[10:27:52.645]   - Field: ‘conditions’
[10:27:52.646]   - Field: ‘persistent’
[10:27:52.646]   - Field: ‘expr’
[10:27:52.646]   - Field: ‘uuid’
[10:27:52.646]   - Field: ‘seed’
[10:27:52.646]   - Field: ‘version’
[10:27:52.646]   - Field: ‘result’
[10:27:52.646]   - Field: ‘asynchronous’
[10:27:52.646]   - Field: ‘calls’
[10:27:52.646]   - Field: ‘globals’
[10:27:52.646]   - Field: ‘stdout’
[10:27:52.647]   - Field: ‘earlySignal’
[10:27:52.647]   - Field: ‘lazy’
[10:27:52.647]   - Field: ‘state’
[10:27:52.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:52.647] - Launch lazy future ...
[10:27:52.647] Packages needed by the future expression (n = 0): <none>
[10:27:52.647] Packages needed by future strategies (n = 0): <none>
[10:27:52.648] {
[10:27:52.648]     {
[10:27:52.648]         {
[10:27:52.648]             ...future.startTime <- base::Sys.time()
[10:27:52.648]             {
[10:27:52.648]                 {
[10:27:52.648]                   {
[10:27:52.648]                     {
[10:27:52.648]                       base::local({
[10:27:52.648]                         has_future <- base::requireNamespace("future", 
[10:27:52.648]                           quietly = TRUE)
[10:27:52.648]                         if (has_future) {
[10:27:52.648]                           ns <- base::getNamespace("future")
[10:27:52.648]                           version <- ns[[".package"]][["version"]]
[10:27:52.648]                           if (is.null(version)) 
[10:27:52.648]                             version <- utils::packageVersion("future")
[10:27:52.648]                         }
[10:27:52.648]                         else {
[10:27:52.648]                           version <- NULL
[10:27:52.648]                         }
[10:27:52.648]                         if (!has_future || version < "1.8.0") {
[10:27:52.648]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:52.648]                             "", base::R.version$version.string), 
[10:27:52.648]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:52.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:52.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:52.648]                               "release", "version")], collapse = " "), 
[10:27:52.648]                             hostname = base::Sys.info()[["nodename"]])
[10:27:52.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:52.648]                             info)
[10:27:52.648]                           info <- base::paste(info, collapse = "; ")
[10:27:52.648]                           if (!has_future) {
[10:27:52.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:52.648]                               info)
[10:27:52.648]                           }
[10:27:52.648]                           else {
[10:27:52.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:52.648]                               info, version)
[10:27:52.648]                           }
[10:27:52.648]                           base::stop(msg)
[10:27:52.648]                         }
[10:27:52.648]                       })
[10:27:52.648]                     }
[10:27:52.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:52.648]                     base::options(mc.cores = 1L)
[10:27:52.648]                   }
[10:27:52.648]                   options(future.plan = NULL)
[10:27:52.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:52.648]                 }
[10:27:52.648]                 ...future.workdir <- getwd()
[10:27:52.648]             }
[10:27:52.648]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:52.648]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:52.648]         }
[10:27:52.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:52.648]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:52.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:52.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:52.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:52.648]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:52.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:52.648]             base::names(...future.oldOptions))
[10:27:52.648]     }
[10:27:52.648]     if (FALSE) {
[10:27:52.648]     }
[10:27:52.648]     else {
[10:27:52.648]         if (TRUE) {
[10:27:52.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:52.648]                 open = "w")
[10:27:52.648]         }
[10:27:52.648]         else {
[10:27:52.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:52.648]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:52.648]         }
[10:27:52.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:52.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:52.648]             base::sink(type = "output", split = FALSE)
[10:27:52.648]             base::close(...future.stdout)
[10:27:52.648]         }, add = TRUE)
[10:27:52.648]     }
[10:27:52.648]     ...future.frame <- base::sys.nframe()
[10:27:52.648]     ...future.conditions <- base::list()
[10:27:52.648]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:52.648]     if (FALSE) {
[10:27:52.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:52.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:52.648]     }
[10:27:52.648]     ...future.result <- base::tryCatch({
[10:27:52.648]         base::withCallingHandlers({
[10:27:52.648]             ...future.value <- base::withVisible(base::local({
[10:27:52.648]                 ...future.makeSendCondition <- base::local({
[10:27:52.648]                   sendCondition <- NULL
[10:27:52.648]                   function(frame = 1L) {
[10:27:52.648]                     if (is.function(sendCondition)) 
[10:27:52.648]                       return(sendCondition)
[10:27:52.648]                     ns <- getNamespace("parallel")
[10:27:52.648]                     if (exists("sendData", mode = "function", 
[10:27:52.648]                       envir = ns)) {
[10:27:52.648]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:52.648]                         envir = ns)
[10:27:52.648]                       envir <- sys.frame(frame)
[10:27:52.648]                       master <- NULL
[10:27:52.648]                       while (!identical(envir, .GlobalEnv) && 
[10:27:52.648]                         !identical(envir, emptyenv())) {
[10:27:52.648]                         if (exists("master", mode = "list", envir = envir, 
[10:27:52.648]                           inherits = FALSE)) {
[10:27:52.648]                           master <- get("master", mode = "list", 
[10:27:52.648]                             envir = envir, inherits = FALSE)
[10:27:52.648]                           if (inherits(master, c("SOCKnode", 
[10:27:52.648]                             "SOCK0node"))) {
[10:27:52.648]                             sendCondition <<- function(cond) {
[10:27:52.648]                               data <- list(type = "VALUE", value = cond, 
[10:27:52.648]                                 success = TRUE)
[10:27:52.648]                               parallel_sendData(master, data)
[10:27:52.648]                             }
[10:27:52.648]                             return(sendCondition)
[10:27:52.648]                           }
[10:27:52.648]                         }
[10:27:52.648]                         frame <- frame + 1L
[10:27:52.648]                         envir <- sys.frame(frame)
[10:27:52.648]                       }
[10:27:52.648]                     }
[10:27:52.648]                     sendCondition <<- function(cond) NULL
[10:27:52.648]                   }
[10:27:52.648]                 })
[10:27:52.648]                 withCallingHandlers({
[10:27:52.648]                   print(42)
[10:27:52.648]                 }, immediateCondition = function(cond) {
[10:27:52.648]                   sendCondition <- ...future.makeSendCondition()
[10:27:52.648]                   sendCondition(cond)
[10:27:52.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.648]                   {
[10:27:52.648]                     inherits <- base::inherits
[10:27:52.648]                     invokeRestart <- base::invokeRestart
[10:27:52.648]                     is.null <- base::is.null
[10:27:52.648]                     muffled <- FALSE
[10:27:52.648]                     if (inherits(cond, "message")) {
[10:27:52.648]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:52.648]                       if (muffled) 
[10:27:52.648]                         invokeRestart("muffleMessage")
[10:27:52.648]                     }
[10:27:52.648]                     else if (inherits(cond, "warning")) {
[10:27:52.648]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:52.648]                       if (muffled) 
[10:27:52.648]                         invokeRestart("muffleWarning")
[10:27:52.648]                     }
[10:27:52.648]                     else if (inherits(cond, "condition")) {
[10:27:52.648]                       if (!is.null(pattern)) {
[10:27:52.648]                         computeRestarts <- base::computeRestarts
[10:27:52.648]                         grepl <- base::grepl
[10:27:52.648]                         restarts <- computeRestarts(cond)
[10:27:52.648]                         for (restart in restarts) {
[10:27:52.648]                           name <- restart$name
[10:27:52.648]                           if (is.null(name)) 
[10:27:52.648]                             next
[10:27:52.648]                           if (!grepl(pattern, name)) 
[10:27:52.648]                             next
[10:27:52.648]                           invokeRestart(restart)
[10:27:52.648]                           muffled <- TRUE
[10:27:52.648]                           break
[10:27:52.648]                         }
[10:27:52.648]                       }
[10:27:52.648]                     }
[10:27:52.648]                     invisible(muffled)
[10:27:52.648]                   }
[10:27:52.648]                   muffleCondition(cond)
[10:27:52.648]                 })
[10:27:52.648]             }))
[10:27:52.648]             future::FutureResult(value = ...future.value$value, 
[10:27:52.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.648]                   ...future.rng), globalenv = if (FALSE) 
[10:27:52.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:52.648]                     ...future.globalenv.names))
[10:27:52.648]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:52.648]         }, condition = base::local({
[10:27:52.648]             c <- base::c
[10:27:52.648]             inherits <- base::inherits
[10:27:52.648]             invokeRestart <- base::invokeRestart
[10:27:52.648]             length <- base::length
[10:27:52.648]             list <- base::list
[10:27:52.648]             seq.int <- base::seq.int
[10:27:52.648]             signalCondition <- base::signalCondition
[10:27:52.648]             sys.calls <- base::sys.calls
[10:27:52.648]             `[[` <- base::`[[`
[10:27:52.648]             `+` <- base::`+`
[10:27:52.648]             `<<-` <- base::`<<-`
[10:27:52.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:52.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:52.648]                   3L)]
[10:27:52.648]             }
[10:27:52.648]             function(cond) {
[10:27:52.648]                 is_error <- inherits(cond, "error")
[10:27:52.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:52.648]                   NULL)
[10:27:52.648]                 if (is_error) {
[10:27:52.648]                   sessionInformation <- function() {
[10:27:52.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:52.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:52.648]                       search = base::search(), system = base::Sys.info())
[10:27:52.648]                   }
[10:27:52.648]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:52.648]                     cond$call), session = sessionInformation(), 
[10:27:52.648]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:52.648]                   signalCondition(cond)
[10:27:52.648]                 }
[10:27:52.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:52.648]                 "immediateCondition"))) {
[10:27:52.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:52.648]                   ...future.conditions[[length(...future.conditions) + 
[10:27:52.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:52.648]                   if (TRUE && !signal) {
[10:27:52.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.648]                     {
[10:27:52.648]                       inherits <- base::inherits
[10:27:52.648]                       invokeRestart <- base::invokeRestart
[10:27:52.648]                       is.null <- base::is.null
[10:27:52.648]                       muffled <- FALSE
[10:27:52.648]                       if (inherits(cond, "message")) {
[10:27:52.648]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.648]                         if (muffled) 
[10:27:52.648]                           invokeRestart("muffleMessage")
[10:27:52.648]                       }
[10:27:52.648]                       else if (inherits(cond, "warning")) {
[10:27:52.648]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.648]                         if (muffled) 
[10:27:52.648]                           invokeRestart("muffleWarning")
[10:27:52.648]                       }
[10:27:52.648]                       else if (inherits(cond, "condition")) {
[10:27:52.648]                         if (!is.null(pattern)) {
[10:27:52.648]                           computeRestarts <- base::computeRestarts
[10:27:52.648]                           grepl <- base::grepl
[10:27:52.648]                           restarts <- computeRestarts(cond)
[10:27:52.648]                           for (restart in restarts) {
[10:27:52.648]                             name <- restart$name
[10:27:52.648]                             if (is.null(name)) 
[10:27:52.648]                               next
[10:27:52.648]                             if (!grepl(pattern, name)) 
[10:27:52.648]                               next
[10:27:52.648]                             invokeRestart(restart)
[10:27:52.648]                             muffled <- TRUE
[10:27:52.648]                             break
[10:27:52.648]                           }
[10:27:52.648]                         }
[10:27:52.648]                       }
[10:27:52.648]                       invisible(muffled)
[10:27:52.648]                     }
[10:27:52.648]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.648]                   }
[10:27:52.648]                 }
[10:27:52.648]                 else {
[10:27:52.648]                   if (TRUE) {
[10:27:52.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:52.648]                     {
[10:27:52.648]                       inherits <- base::inherits
[10:27:52.648]                       invokeRestart <- base::invokeRestart
[10:27:52.648]                       is.null <- base::is.null
[10:27:52.648]                       muffled <- FALSE
[10:27:52.648]                       if (inherits(cond, "message")) {
[10:27:52.648]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:52.648]                         if (muffled) 
[10:27:52.648]                           invokeRestart("muffleMessage")
[10:27:52.648]                       }
[10:27:52.648]                       else if (inherits(cond, "warning")) {
[10:27:52.648]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:52.648]                         if (muffled) 
[10:27:52.648]                           invokeRestart("muffleWarning")
[10:27:52.648]                       }
[10:27:52.648]                       else if (inherits(cond, "condition")) {
[10:27:52.648]                         if (!is.null(pattern)) {
[10:27:52.648]                           computeRestarts <- base::computeRestarts
[10:27:52.648]                           grepl <- base::grepl
[10:27:52.648]                           restarts <- computeRestarts(cond)
[10:27:52.648]                           for (restart in restarts) {
[10:27:52.648]                             name <- restart$name
[10:27:52.648]                             if (is.null(name)) 
[10:27:52.648]                               next
[10:27:52.648]                             if (!grepl(pattern, name)) 
[10:27:52.648]                               next
[10:27:52.648]                             invokeRestart(restart)
[10:27:52.648]                             muffled <- TRUE
[10:27:52.648]                             break
[10:27:52.648]                           }
[10:27:52.648]                         }
[10:27:52.648]                       }
[10:27:52.648]                       invisible(muffled)
[10:27:52.648]                     }
[10:27:52.648]                     muffleCondition(cond, pattern = "^muffle")
[10:27:52.648]                   }
[10:27:52.648]                 }
[10:27:52.648]             }
[10:27:52.648]         }))
[10:27:52.648]     }, error = function(ex) {
[10:27:52.648]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:52.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:52.648]                 ...future.rng), started = ...future.startTime, 
[10:27:52.648]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:52.648]             version = "1.8"), class = "FutureResult")
[10:27:52.648]     }, finally = {
[10:27:52.648]         if (!identical(...future.workdir, getwd())) 
[10:27:52.648]             setwd(...future.workdir)
[10:27:52.648]         {
[10:27:52.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:52.648]                 ...future.oldOptions$nwarnings <- NULL
[10:27:52.648]             }
[10:27:52.648]             base::options(...future.oldOptions)
[10:27:52.648]             if (.Platform$OS.type == "windows") {
[10:27:52.648]                 old_names <- names(...future.oldEnvVars)
[10:27:52.648]                 envs <- base::Sys.getenv()
[10:27:52.648]                 names <- names(envs)
[10:27:52.648]                 common <- intersect(names, old_names)
[10:27:52.648]                 added <- setdiff(names, old_names)
[10:27:52.648]                 removed <- setdiff(old_names, names)
[10:27:52.648]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:52.648]                   envs[common]]
[10:27:52.648]                 NAMES <- toupper(changed)
[10:27:52.648]                 args <- list()
[10:27:52.648]                 for (kk in seq_along(NAMES)) {
[10:27:52.648]                   name <- changed[[kk]]
[10:27:52.648]                   NAME <- NAMES[[kk]]
[10:27:52.648]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.648]                     next
[10:27:52.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.648]                 }
[10:27:52.648]                 NAMES <- toupper(added)
[10:27:52.648]                 for (kk in seq_along(NAMES)) {
[10:27:52.648]                   name <- added[[kk]]
[10:27:52.648]                   NAME <- NAMES[[kk]]
[10:27:52.648]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.648]                     next
[10:27:52.648]                   args[[name]] <- ""
[10:27:52.648]                 }
[10:27:52.648]                 NAMES <- toupper(removed)
[10:27:52.648]                 for (kk in seq_along(NAMES)) {
[10:27:52.648]                   name <- removed[[kk]]
[10:27:52.648]                   NAME <- NAMES[[kk]]
[10:27:52.648]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:52.648]                     next
[10:27:52.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:52.648]                 }
[10:27:52.648]                 if (length(args) > 0) 
[10:27:52.648]                   base::do.call(base::Sys.setenv, args = args)
[10:27:52.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:52.648]             }
[10:27:52.648]             else {
[10:27:52.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:52.648]             }
[10:27:52.648]             {
[10:27:52.648]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:52.648]                   0L) {
[10:27:52.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:52.648]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:52.648]                   base::options(opts)
[10:27:52.648]                 }
[10:27:52.648]                 {
[10:27:52.648]                   {
[10:27:52.648]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:52.648]                     NULL
[10:27:52.648]                   }
[10:27:52.648]                   options(future.plan = NULL)
[10:27:52.648]                   if (is.na(NA_character_)) 
[10:27:52.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:52.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:52.648]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:52.648]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:52.648]                     envir = parent.frame()) 
[10:27:52.648]                   {
[10:27:52.648]                     if (is.function(workers)) 
[10:27:52.648]                       workers <- workers()
[10:27:52.648]                     workers <- structure(as.integer(workers), 
[10:27:52.648]                       class = class(workers))
[10:27:52.648]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:52.648]                       workers >= 1)
[10:27:52.648]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:52.648]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:52.648]                     }
[10:27:52.648]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:52.648]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:52.648]                       envir = envir)
[10:27:52.648]                     if (!future$lazy) 
[10:27:52.648]                       future <- run(future)
[10:27:52.648]                     invisible(future)
[10:27:52.648]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:52.648]                 }
[10:27:52.648]             }
[10:27:52.648]         }
[10:27:52.648]     })
[10:27:52.648]     if (TRUE) {
[10:27:52.648]         base::sink(type = "output", split = FALSE)
[10:27:52.648]         if (TRUE) {
[10:27:52.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:52.648]         }
[10:27:52.648]         else {
[10:27:52.648]             ...future.result["stdout"] <- base::list(NULL)
[10:27:52.648]         }
[10:27:52.648]         base::close(...future.stdout)
[10:27:52.648]         ...future.stdout <- NULL
[10:27:52.648]     }
[10:27:52.648]     ...future.result$conditions <- ...future.conditions
[10:27:52.648]     ...future.result$finished <- base::Sys.time()
[10:27:52.648]     ...future.result
[10:27:52.648] }
[10:27:52.651] MultisessionFuture started
[10:27:52.651] - Launch lazy future ... done
[10:27:52.651] run() for ‘MultisessionFuture’ ... done
[10:27:52.652] result() for ClusterFuture ...
[10:27:52.652] receiveMessageFromWorker() for ClusterFuture ...
[10:27:52.652] - Validating connection of MultisessionFuture
[10:27:52.699] - received message: FutureResult
[10:27:52.699] - Received FutureResult
[10:27:52.699] - Erased future from FutureRegistry
[10:27:52.699] result() for ClusterFuture ...
[10:27:52.699] - result already collected: FutureResult
[10:27:52.700] result() for ClusterFuture ... done
[10:27:52.700] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:52.700] result() for ClusterFuture ... done
[10:27:52.700] result() for ClusterFuture ...
[10:27:52.700] - result already collected: FutureResult
[10:27:52.700] result() for ClusterFuture ... done
[10:27:52.700] result() for ClusterFuture ...
[10:27:52.700] - result already collected: FutureResult
[10:27:52.700] result() for ClusterFuture ... done
[1] 42
[10:27:52.700] result() for ClusterFuture ...
[10:27:52.700] - result already collected: FutureResult
[10:27:52.701] result() for ClusterFuture ... done
multisession ... done
Testing with 2 cores ... done
> 
> message("*** Standard output ... DONE")
*** Standard output ... DONE
> 
> source("incl/end.R")
[10:27:52.701] plan(): Setting new future strategy stack:
[10:27:52.702] List of future strategies:
[10:27:52.702] 1. FutureStrategy:
[10:27:52.702]    - args: function (..., envir = parent.frame())
[10:27:52.702]    - tweaked: FALSE
[10:27:52.702]    - call: future::plan(oplan)
[10:27:52.702] plan(): nbrOfWorkers() = 1
> 
