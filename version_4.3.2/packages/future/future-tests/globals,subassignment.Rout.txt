
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:23:26.575] plan(): Setting new future strategy stack:
[13:23:26.575] List of future strategies:
[13:23:26.575] 1. sequential:
[13:23:26.575]    - args: function (..., envir = parent.frame())
[13:23:26.575]    - tweaked: FALSE
[13:23:26.575]    - call: future::plan("sequential")
[13:23:26.591] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[13:23:26.662] plan(): Setting new future strategy stack:
[13:23:26.662] List of future strategies:
[13:23:26.662] 1. sequential:
[13:23:26.662]    - args: function (..., envir = parent.frame())
[13:23:26.662]    - tweaked: FALSE
[13:23:26.662]    - call: plan(strategy)
[13:23:26.674] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.675] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.675] Searching for globals...
[13:23:26.683] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.683] Searching for globals ... DONE
[13:23:26.684] Resolving globals: TRUE
[13:23:26.684] Resolving any globals that are futures ...
[13:23:26.684] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.684] Resolving any globals that are futures ... DONE
[13:23:26.685] Resolving futures part of globals (recursively) ...
[13:23:26.685] resolve() on list ...
[13:23:26.686]  recursive: 99
[13:23:26.686]  length: 1
[13:23:26.686]  elements: ‘x’
[13:23:26.686]  length: 0 (resolved future 1)
[13:23:26.686] resolve() on list ... DONE
[13:23:26.686] - globals: [1] ‘x’
[13:23:26.686] Resolving futures part of globals (recursively) ... DONE
[13:23:26.687] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.687] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.687] - globals: [1] ‘x’
[13:23:26.688] 
[13:23:26.688] getGlobalsAndPackages() ... DONE
[13:23:26.688] run() for ‘Future’ ...
[13:23:26.689] - state: ‘created’
[13:23:26.689] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:26.689] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:26.689] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:26.689]   - Field: ‘label’
[13:23:26.689]   - Field: ‘local’
[13:23:26.690]   - Field: ‘owner’
[13:23:26.690]   - Field: ‘envir’
[13:23:26.690]   - Field: ‘packages’
[13:23:26.690]   - Field: ‘gc’
[13:23:26.690]   - Field: ‘conditions’
[13:23:26.690]   - Field: ‘expr’
[13:23:26.690]   - Field: ‘uuid’
[13:23:26.690]   - Field: ‘seed’
[13:23:26.690]   - Field: ‘version’
[13:23:26.690]   - Field: ‘result’
[13:23:26.691]   - Field: ‘asynchronous’
[13:23:26.691]   - Field: ‘calls’
[13:23:26.691]   - Field: ‘globals’
[13:23:26.691]   - Field: ‘stdout’
[13:23:26.691]   - Field: ‘earlySignal’
[13:23:26.691]   - Field: ‘lazy’
[13:23:26.691]   - Field: ‘state’
[13:23:26.691] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:26.691] - Launch lazy future ...
[13:23:26.694] Packages needed by the future expression (n = 0): <none>
[13:23:26.694] Packages needed by future strategies (n = 0): <none>
[13:23:26.695] {
[13:23:26.695]     {
[13:23:26.695]         {
[13:23:26.695]             ...future.startTime <- base::Sys.time()
[13:23:26.695]             {
[13:23:26.695]                 {
[13:23:26.695]                   {
[13:23:26.695]                     base::local({
[13:23:26.695]                       has_future <- base::requireNamespace("future", 
[13:23:26.695]                         quietly = TRUE)
[13:23:26.695]                       if (has_future) {
[13:23:26.695]                         ns <- base::getNamespace("future")
[13:23:26.695]                         version <- ns[[".package"]][["version"]]
[13:23:26.695]                         if (is.null(version)) 
[13:23:26.695]                           version <- utils::packageVersion("future")
[13:23:26.695]                       }
[13:23:26.695]                       else {
[13:23:26.695]                         version <- NULL
[13:23:26.695]                       }
[13:23:26.695]                       if (!has_future || version < "1.8.0") {
[13:23:26.695]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.695]                           "", base::R.version$version.string), 
[13:23:26.695]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:26.695]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.695]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.695]                             "release", "version")], collapse = " "), 
[13:23:26.695]                           hostname = base::Sys.info()[["nodename"]])
[13:23:26.695]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.695]                           info)
[13:23:26.695]                         info <- base::paste(info, collapse = "; ")
[13:23:26.695]                         if (!has_future) {
[13:23:26.695]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.695]                             info)
[13:23:26.695]                         }
[13:23:26.695]                         else {
[13:23:26.695]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.695]                             info, version)
[13:23:26.695]                         }
[13:23:26.695]                         base::stop(msg)
[13:23:26.695]                       }
[13:23:26.695]                     })
[13:23:26.695]                   }
[13:23:26.695]                   options(future.plan = NULL)
[13:23:26.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.695]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.695]                 }
[13:23:26.695]                 ...future.workdir <- getwd()
[13:23:26.695]             }
[13:23:26.695]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.695]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.695]         }
[13:23:26.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.695]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.695]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.695]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.695]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.695]             base::names(...future.oldOptions))
[13:23:26.695]     }
[13:23:26.695]     if (FALSE) {
[13:23:26.695]     }
[13:23:26.695]     else {
[13:23:26.695]         if (TRUE) {
[13:23:26.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.695]                 open = "w")
[13:23:26.695]         }
[13:23:26.695]         else {
[13:23:26.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.695]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.695]         }
[13:23:26.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.695]             base::sink(type = "output", split = FALSE)
[13:23:26.695]             base::close(...future.stdout)
[13:23:26.695]         }, add = TRUE)
[13:23:26.695]     }
[13:23:26.695]     ...future.frame <- base::sys.nframe()
[13:23:26.695]     ...future.conditions <- base::list()
[13:23:26.695]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.695]     if (FALSE) {
[13:23:26.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.695]     }
[13:23:26.695]     ...future.result <- base::tryCatch({
[13:23:26.695]         base::withCallingHandlers({
[13:23:26.695]             ...future.value <- base::withVisible(base::local({
[13:23:26.695]                 x$a <- 1
[13:23:26.695]                 x
[13:23:26.695]             }))
[13:23:26.695]             future::FutureResult(value = ...future.value$value, 
[13:23:26.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.695]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.695]                     ...future.globalenv.names))
[13:23:26.695]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.695]         }, condition = base::local({
[13:23:26.695]             c <- base::c
[13:23:26.695]             inherits <- base::inherits
[13:23:26.695]             invokeRestart <- base::invokeRestart
[13:23:26.695]             length <- base::length
[13:23:26.695]             list <- base::list
[13:23:26.695]             seq.int <- base::seq.int
[13:23:26.695]             signalCondition <- base::signalCondition
[13:23:26.695]             sys.calls <- base::sys.calls
[13:23:26.695]             `[[` <- base::`[[`
[13:23:26.695]             `+` <- base::`+`
[13:23:26.695]             `<<-` <- base::`<<-`
[13:23:26.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.695]                   3L)]
[13:23:26.695]             }
[13:23:26.695]             function(cond) {
[13:23:26.695]                 is_error <- inherits(cond, "error")
[13:23:26.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.695]                   NULL)
[13:23:26.695]                 if (is_error) {
[13:23:26.695]                   sessionInformation <- function() {
[13:23:26.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.695]                       search = base::search(), system = base::Sys.info())
[13:23:26.695]                   }
[13:23:26.695]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.695]                     cond$call), session = sessionInformation(), 
[13:23:26.695]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.695]                   signalCondition(cond)
[13:23:26.695]                 }
[13:23:26.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.695]                 "immediateCondition"))) {
[13:23:26.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.695]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.695]                   if (TRUE && !signal) {
[13:23:26.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.695]                     {
[13:23:26.695]                       inherits <- base::inherits
[13:23:26.695]                       invokeRestart <- base::invokeRestart
[13:23:26.695]                       is.null <- base::is.null
[13:23:26.695]                       muffled <- FALSE
[13:23:26.695]                       if (inherits(cond, "message")) {
[13:23:26.695]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.695]                         if (muffled) 
[13:23:26.695]                           invokeRestart("muffleMessage")
[13:23:26.695]                       }
[13:23:26.695]                       else if (inherits(cond, "warning")) {
[13:23:26.695]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.695]                         if (muffled) 
[13:23:26.695]                           invokeRestart("muffleWarning")
[13:23:26.695]                       }
[13:23:26.695]                       else if (inherits(cond, "condition")) {
[13:23:26.695]                         if (!is.null(pattern)) {
[13:23:26.695]                           computeRestarts <- base::computeRestarts
[13:23:26.695]                           grepl <- base::grepl
[13:23:26.695]                           restarts <- computeRestarts(cond)
[13:23:26.695]                           for (restart in restarts) {
[13:23:26.695]                             name <- restart$name
[13:23:26.695]                             if (is.null(name)) 
[13:23:26.695]                               next
[13:23:26.695]                             if (!grepl(pattern, name)) 
[13:23:26.695]                               next
[13:23:26.695]                             invokeRestart(restart)
[13:23:26.695]                             muffled <- TRUE
[13:23:26.695]                             break
[13:23:26.695]                           }
[13:23:26.695]                         }
[13:23:26.695]                       }
[13:23:26.695]                       invisible(muffled)
[13:23:26.695]                     }
[13:23:26.695]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.695]                   }
[13:23:26.695]                 }
[13:23:26.695]                 else {
[13:23:26.695]                   if (TRUE) {
[13:23:26.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.695]                     {
[13:23:26.695]                       inherits <- base::inherits
[13:23:26.695]                       invokeRestart <- base::invokeRestart
[13:23:26.695]                       is.null <- base::is.null
[13:23:26.695]                       muffled <- FALSE
[13:23:26.695]                       if (inherits(cond, "message")) {
[13:23:26.695]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.695]                         if (muffled) 
[13:23:26.695]                           invokeRestart("muffleMessage")
[13:23:26.695]                       }
[13:23:26.695]                       else if (inherits(cond, "warning")) {
[13:23:26.695]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.695]                         if (muffled) 
[13:23:26.695]                           invokeRestart("muffleWarning")
[13:23:26.695]                       }
[13:23:26.695]                       else if (inherits(cond, "condition")) {
[13:23:26.695]                         if (!is.null(pattern)) {
[13:23:26.695]                           computeRestarts <- base::computeRestarts
[13:23:26.695]                           grepl <- base::grepl
[13:23:26.695]                           restarts <- computeRestarts(cond)
[13:23:26.695]                           for (restart in restarts) {
[13:23:26.695]                             name <- restart$name
[13:23:26.695]                             if (is.null(name)) 
[13:23:26.695]                               next
[13:23:26.695]                             if (!grepl(pattern, name)) 
[13:23:26.695]                               next
[13:23:26.695]                             invokeRestart(restart)
[13:23:26.695]                             muffled <- TRUE
[13:23:26.695]                             break
[13:23:26.695]                           }
[13:23:26.695]                         }
[13:23:26.695]                       }
[13:23:26.695]                       invisible(muffled)
[13:23:26.695]                     }
[13:23:26.695]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.695]                   }
[13:23:26.695]                 }
[13:23:26.695]             }
[13:23:26.695]         }))
[13:23:26.695]     }, error = function(ex) {
[13:23:26.695]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.695]                 ...future.rng), started = ...future.startTime, 
[13:23:26.695]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.695]             version = "1.8"), class = "FutureResult")
[13:23:26.695]     }, finally = {
[13:23:26.695]         if (!identical(...future.workdir, getwd())) 
[13:23:26.695]             setwd(...future.workdir)
[13:23:26.695]         {
[13:23:26.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.695]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.695]             }
[13:23:26.695]             base::options(...future.oldOptions)
[13:23:26.695]             if (.Platform$OS.type == "windows") {
[13:23:26.695]                 old_names <- names(...future.oldEnvVars)
[13:23:26.695]                 envs <- base::Sys.getenv()
[13:23:26.695]                 names <- names(envs)
[13:23:26.695]                 common <- intersect(names, old_names)
[13:23:26.695]                 added <- setdiff(names, old_names)
[13:23:26.695]                 removed <- setdiff(old_names, names)
[13:23:26.695]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.695]                   envs[common]]
[13:23:26.695]                 NAMES <- toupper(changed)
[13:23:26.695]                 args <- list()
[13:23:26.695]                 for (kk in seq_along(NAMES)) {
[13:23:26.695]                   name <- changed[[kk]]
[13:23:26.695]                   NAME <- NAMES[[kk]]
[13:23:26.695]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.695]                     next
[13:23:26.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.695]                 }
[13:23:26.695]                 NAMES <- toupper(added)
[13:23:26.695]                 for (kk in seq_along(NAMES)) {
[13:23:26.695]                   name <- added[[kk]]
[13:23:26.695]                   NAME <- NAMES[[kk]]
[13:23:26.695]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.695]                     next
[13:23:26.695]                   args[[name]] <- ""
[13:23:26.695]                 }
[13:23:26.695]                 NAMES <- toupper(removed)
[13:23:26.695]                 for (kk in seq_along(NAMES)) {
[13:23:26.695]                   name <- removed[[kk]]
[13:23:26.695]                   NAME <- NAMES[[kk]]
[13:23:26.695]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.695]                     next
[13:23:26.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.695]                 }
[13:23:26.695]                 if (length(args) > 0) 
[13:23:26.695]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.695]             }
[13:23:26.695]             else {
[13:23:26.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.695]             }
[13:23:26.695]             {
[13:23:26.695]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.695]                   0L) {
[13:23:26.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.695]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.695]                   base::options(opts)
[13:23:26.695]                 }
[13:23:26.695]                 {
[13:23:26.695]                   {
[13:23:26.695]                     NULL
[13:23:26.695]                     RNGkind("Mersenne-Twister")
[13:23:26.695]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:26.695]                       inherits = FALSE)
[13:23:26.695]                   }
[13:23:26.695]                   options(future.plan = NULL)
[13:23:26.695]                   if (is.na(NA_character_)) 
[13:23:26.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.695]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:26.695]                   {
[13:23:26.695]                     future <- SequentialFuture(..., envir = envir)
[13:23:26.695]                     if (!future$lazy) 
[13:23:26.695]                       future <- run(future)
[13:23:26.695]                     invisible(future)
[13:23:26.695]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.695]                 }
[13:23:26.695]             }
[13:23:26.695]         }
[13:23:26.695]     })
[13:23:26.695]     if (TRUE) {
[13:23:26.695]         base::sink(type = "output", split = FALSE)
[13:23:26.695]         if (TRUE) {
[13:23:26.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.695]         }
[13:23:26.695]         else {
[13:23:26.695]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.695]         }
[13:23:26.695]         base::close(...future.stdout)
[13:23:26.695]         ...future.stdout <- NULL
[13:23:26.695]     }
[13:23:26.695]     ...future.result$conditions <- ...future.conditions
[13:23:26.695]     ...future.result$finished <- base::Sys.time()
[13:23:26.695]     ...future.result
[13:23:26.695] }
[13:23:26.697] assign_globals() ...
[13:23:26.697] List of 1
[13:23:26.697]  $ x: list()
[13:23:26.697]  - attr(*, "where")=List of 1
[13:23:26.697]   ..$ x:<environment: R_EmptyEnv> 
[13:23:26.697]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.697]  - attr(*, "resolved")= logi TRUE
[13:23:26.697]  - attr(*, "total_size")= num 0
[13:23:26.697]  - attr(*, "already-done")= logi TRUE
[13:23:26.700] - copied ‘x’ to environment
[13:23:26.700] assign_globals() ... done
[13:23:26.701] plan(): Setting new future strategy stack:
[13:23:26.701] List of future strategies:
[13:23:26.701] 1. sequential:
[13:23:26.701]    - args: function (..., envir = parent.frame())
[13:23:26.701]    - tweaked: FALSE
[13:23:26.701]    - call: NULL
[13:23:26.701] plan(): nbrOfWorkers() = 1
[13:23:26.702] plan(): Setting new future strategy stack:
[13:23:26.702] List of future strategies:
[13:23:26.702] 1. sequential:
[13:23:26.702]    - args: function (..., envir = parent.frame())
[13:23:26.702]    - tweaked: FALSE
[13:23:26.702]    - call: plan(strategy)
[13:23:26.703] plan(): nbrOfWorkers() = 1
[13:23:26.703] SequentialFuture started (and completed)
[13:23:26.703] - Launch lazy future ... done
[13:23:26.703] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.704] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.704] Searching for globals...
[13:23:26.706] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.707] Searching for globals ... DONE
[13:23:26.707] Resolving globals: TRUE
[13:23:26.707] Resolving any globals that are futures ...
[13:23:26.707] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.707] Resolving any globals that are futures ... DONE
[13:23:26.707] Resolving futures part of globals (recursively) ...
[13:23:26.708] resolve() on list ...
[13:23:26.708]  recursive: 99
[13:23:26.708]  length: 1
[13:23:26.708]  elements: ‘x’
[13:23:26.708]  length: 0 (resolved future 1)
[13:23:26.708] resolve() on list ... DONE
[13:23:26.708] - globals: [1] ‘x’
[13:23:26.708] Resolving futures part of globals (recursively) ... DONE
[13:23:26.708] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.709] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.709] - globals: [1] ‘x’
[13:23:26.709] 
[13:23:26.709] getGlobalsAndPackages() ... DONE
[13:23:26.709] run() for ‘Future’ ...
[13:23:26.710] - state: ‘created’
[13:23:26.710] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:26.710] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:26.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:26.710]   - Field: ‘label’
[13:23:26.710]   - Field: ‘local’
[13:23:26.710]   - Field: ‘owner’
[13:23:26.710]   - Field: ‘envir’
[13:23:26.711]   - Field: ‘packages’
[13:23:26.711]   - Field: ‘gc’
[13:23:26.711]   - Field: ‘conditions’
[13:23:26.711]   - Field: ‘expr’
[13:23:26.711]   - Field: ‘uuid’
[13:23:26.711]   - Field: ‘seed’
[13:23:26.711]   - Field: ‘version’
[13:23:26.711]   - Field: ‘result’
[13:23:26.711]   - Field: ‘asynchronous’
[13:23:26.711]   - Field: ‘calls’
[13:23:26.712]   - Field: ‘globals’
[13:23:26.712]   - Field: ‘stdout’
[13:23:26.712]   - Field: ‘earlySignal’
[13:23:26.712]   - Field: ‘lazy’
[13:23:26.712]   - Field: ‘state’
[13:23:26.712] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:26.712] - Launch lazy future ...
[13:23:26.712] Packages needed by the future expression (n = 0): <none>
[13:23:26.713] Packages needed by future strategies (n = 0): <none>
[13:23:26.713] {
[13:23:26.713]     {
[13:23:26.713]         {
[13:23:26.713]             ...future.startTime <- base::Sys.time()
[13:23:26.713]             {
[13:23:26.713]                 {
[13:23:26.713]                   {
[13:23:26.713]                     base::local({
[13:23:26.713]                       has_future <- base::requireNamespace("future", 
[13:23:26.713]                         quietly = TRUE)
[13:23:26.713]                       if (has_future) {
[13:23:26.713]                         ns <- base::getNamespace("future")
[13:23:26.713]                         version <- ns[[".package"]][["version"]]
[13:23:26.713]                         if (is.null(version)) 
[13:23:26.713]                           version <- utils::packageVersion("future")
[13:23:26.713]                       }
[13:23:26.713]                       else {
[13:23:26.713]                         version <- NULL
[13:23:26.713]                       }
[13:23:26.713]                       if (!has_future || version < "1.8.0") {
[13:23:26.713]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.713]                           "", base::R.version$version.string), 
[13:23:26.713]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:26.713]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.713]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.713]                             "release", "version")], collapse = " "), 
[13:23:26.713]                           hostname = base::Sys.info()[["nodename"]])
[13:23:26.713]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.713]                           info)
[13:23:26.713]                         info <- base::paste(info, collapse = "; ")
[13:23:26.713]                         if (!has_future) {
[13:23:26.713]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.713]                             info)
[13:23:26.713]                         }
[13:23:26.713]                         else {
[13:23:26.713]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.713]                             info, version)
[13:23:26.713]                         }
[13:23:26.713]                         base::stop(msg)
[13:23:26.713]                       }
[13:23:26.713]                     })
[13:23:26.713]                   }
[13:23:26.713]                   options(future.plan = NULL)
[13:23:26.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.713]                 }
[13:23:26.713]                 ...future.workdir <- getwd()
[13:23:26.713]             }
[13:23:26.713]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.713]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.713]         }
[13:23:26.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.713]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.713]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.713]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.713]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.713]             base::names(...future.oldOptions))
[13:23:26.713]     }
[13:23:26.713]     if (FALSE) {
[13:23:26.713]     }
[13:23:26.713]     else {
[13:23:26.713]         if (TRUE) {
[13:23:26.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.713]                 open = "w")
[13:23:26.713]         }
[13:23:26.713]         else {
[13:23:26.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.713]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.713]         }
[13:23:26.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.713]             base::sink(type = "output", split = FALSE)
[13:23:26.713]             base::close(...future.stdout)
[13:23:26.713]         }, add = TRUE)
[13:23:26.713]     }
[13:23:26.713]     ...future.frame <- base::sys.nframe()
[13:23:26.713]     ...future.conditions <- base::list()
[13:23:26.713]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.713]     if (FALSE) {
[13:23:26.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.713]     }
[13:23:26.713]     ...future.result <- base::tryCatch({
[13:23:26.713]         base::withCallingHandlers({
[13:23:26.713]             ...future.value <- base::withVisible(base::local({
[13:23:26.713]                 x$a <- 1
[13:23:26.713]                 x
[13:23:26.713]             }))
[13:23:26.713]             future::FutureResult(value = ...future.value$value, 
[13:23:26.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.713]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.713]                     ...future.globalenv.names))
[13:23:26.713]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.713]         }, condition = base::local({
[13:23:26.713]             c <- base::c
[13:23:26.713]             inherits <- base::inherits
[13:23:26.713]             invokeRestart <- base::invokeRestart
[13:23:26.713]             length <- base::length
[13:23:26.713]             list <- base::list
[13:23:26.713]             seq.int <- base::seq.int
[13:23:26.713]             signalCondition <- base::signalCondition
[13:23:26.713]             sys.calls <- base::sys.calls
[13:23:26.713]             `[[` <- base::`[[`
[13:23:26.713]             `+` <- base::`+`
[13:23:26.713]             `<<-` <- base::`<<-`
[13:23:26.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.713]                   3L)]
[13:23:26.713]             }
[13:23:26.713]             function(cond) {
[13:23:26.713]                 is_error <- inherits(cond, "error")
[13:23:26.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.713]                   NULL)
[13:23:26.713]                 if (is_error) {
[13:23:26.713]                   sessionInformation <- function() {
[13:23:26.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.713]                       search = base::search(), system = base::Sys.info())
[13:23:26.713]                   }
[13:23:26.713]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.713]                     cond$call), session = sessionInformation(), 
[13:23:26.713]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.713]                   signalCondition(cond)
[13:23:26.713]                 }
[13:23:26.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.713]                 "immediateCondition"))) {
[13:23:26.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.713]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.713]                   if (TRUE && !signal) {
[13:23:26.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.713]                     {
[13:23:26.713]                       inherits <- base::inherits
[13:23:26.713]                       invokeRestart <- base::invokeRestart
[13:23:26.713]                       is.null <- base::is.null
[13:23:26.713]                       muffled <- FALSE
[13:23:26.713]                       if (inherits(cond, "message")) {
[13:23:26.713]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.713]                         if (muffled) 
[13:23:26.713]                           invokeRestart("muffleMessage")
[13:23:26.713]                       }
[13:23:26.713]                       else if (inherits(cond, "warning")) {
[13:23:26.713]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.713]                         if (muffled) 
[13:23:26.713]                           invokeRestart("muffleWarning")
[13:23:26.713]                       }
[13:23:26.713]                       else if (inherits(cond, "condition")) {
[13:23:26.713]                         if (!is.null(pattern)) {
[13:23:26.713]                           computeRestarts <- base::computeRestarts
[13:23:26.713]                           grepl <- base::grepl
[13:23:26.713]                           restarts <- computeRestarts(cond)
[13:23:26.713]                           for (restart in restarts) {
[13:23:26.713]                             name <- restart$name
[13:23:26.713]                             if (is.null(name)) 
[13:23:26.713]                               next
[13:23:26.713]                             if (!grepl(pattern, name)) 
[13:23:26.713]                               next
[13:23:26.713]                             invokeRestart(restart)
[13:23:26.713]                             muffled <- TRUE
[13:23:26.713]                             break
[13:23:26.713]                           }
[13:23:26.713]                         }
[13:23:26.713]                       }
[13:23:26.713]                       invisible(muffled)
[13:23:26.713]                     }
[13:23:26.713]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.713]                   }
[13:23:26.713]                 }
[13:23:26.713]                 else {
[13:23:26.713]                   if (TRUE) {
[13:23:26.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.713]                     {
[13:23:26.713]                       inherits <- base::inherits
[13:23:26.713]                       invokeRestart <- base::invokeRestart
[13:23:26.713]                       is.null <- base::is.null
[13:23:26.713]                       muffled <- FALSE
[13:23:26.713]                       if (inherits(cond, "message")) {
[13:23:26.713]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.713]                         if (muffled) 
[13:23:26.713]                           invokeRestart("muffleMessage")
[13:23:26.713]                       }
[13:23:26.713]                       else if (inherits(cond, "warning")) {
[13:23:26.713]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.713]                         if (muffled) 
[13:23:26.713]                           invokeRestart("muffleWarning")
[13:23:26.713]                       }
[13:23:26.713]                       else if (inherits(cond, "condition")) {
[13:23:26.713]                         if (!is.null(pattern)) {
[13:23:26.713]                           computeRestarts <- base::computeRestarts
[13:23:26.713]                           grepl <- base::grepl
[13:23:26.713]                           restarts <- computeRestarts(cond)
[13:23:26.713]                           for (restart in restarts) {
[13:23:26.713]                             name <- restart$name
[13:23:26.713]                             if (is.null(name)) 
[13:23:26.713]                               next
[13:23:26.713]                             if (!grepl(pattern, name)) 
[13:23:26.713]                               next
[13:23:26.713]                             invokeRestart(restart)
[13:23:26.713]                             muffled <- TRUE
[13:23:26.713]                             break
[13:23:26.713]                           }
[13:23:26.713]                         }
[13:23:26.713]                       }
[13:23:26.713]                       invisible(muffled)
[13:23:26.713]                     }
[13:23:26.713]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.713]                   }
[13:23:26.713]                 }
[13:23:26.713]             }
[13:23:26.713]         }))
[13:23:26.713]     }, error = function(ex) {
[13:23:26.713]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.713]                 ...future.rng), started = ...future.startTime, 
[13:23:26.713]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.713]             version = "1.8"), class = "FutureResult")
[13:23:26.713]     }, finally = {
[13:23:26.713]         if (!identical(...future.workdir, getwd())) 
[13:23:26.713]             setwd(...future.workdir)
[13:23:26.713]         {
[13:23:26.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.713]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.713]             }
[13:23:26.713]             base::options(...future.oldOptions)
[13:23:26.713]             if (.Platform$OS.type == "windows") {
[13:23:26.713]                 old_names <- names(...future.oldEnvVars)
[13:23:26.713]                 envs <- base::Sys.getenv()
[13:23:26.713]                 names <- names(envs)
[13:23:26.713]                 common <- intersect(names, old_names)
[13:23:26.713]                 added <- setdiff(names, old_names)
[13:23:26.713]                 removed <- setdiff(old_names, names)
[13:23:26.713]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.713]                   envs[common]]
[13:23:26.713]                 NAMES <- toupper(changed)
[13:23:26.713]                 args <- list()
[13:23:26.713]                 for (kk in seq_along(NAMES)) {
[13:23:26.713]                   name <- changed[[kk]]
[13:23:26.713]                   NAME <- NAMES[[kk]]
[13:23:26.713]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.713]                     next
[13:23:26.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.713]                 }
[13:23:26.713]                 NAMES <- toupper(added)
[13:23:26.713]                 for (kk in seq_along(NAMES)) {
[13:23:26.713]                   name <- added[[kk]]
[13:23:26.713]                   NAME <- NAMES[[kk]]
[13:23:26.713]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.713]                     next
[13:23:26.713]                   args[[name]] <- ""
[13:23:26.713]                 }
[13:23:26.713]                 NAMES <- toupper(removed)
[13:23:26.713]                 for (kk in seq_along(NAMES)) {
[13:23:26.713]                   name <- removed[[kk]]
[13:23:26.713]                   NAME <- NAMES[[kk]]
[13:23:26.713]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.713]                     next
[13:23:26.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.713]                 }
[13:23:26.713]                 if (length(args) > 0) 
[13:23:26.713]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.713]             }
[13:23:26.713]             else {
[13:23:26.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.713]             }
[13:23:26.713]             {
[13:23:26.713]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.713]                   0L) {
[13:23:26.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.713]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.713]                   base::options(opts)
[13:23:26.713]                 }
[13:23:26.713]                 {
[13:23:26.713]                   {
[13:23:26.713]                     NULL
[13:23:26.713]                     RNGkind("Mersenne-Twister")
[13:23:26.713]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:26.713]                       inherits = FALSE)
[13:23:26.713]                   }
[13:23:26.713]                   options(future.plan = NULL)
[13:23:26.713]                   if (is.na(NA_character_)) 
[13:23:26.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.713]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:26.713]                   {
[13:23:26.713]                     future <- SequentialFuture(..., envir = envir)
[13:23:26.713]                     if (!future$lazy) 
[13:23:26.713]                       future <- run(future)
[13:23:26.713]                     invisible(future)
[13:23:26.713]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.713]                 }
[13:23:26.713]             }
[13:23:26.713]         }
[13:23:26.713]     })
[13:23:26.713]     if (TRUE) {
[13:23:26.713]         base::sink(type = "output", split = FALSE)
[13:23:26.713]         if (TRUE) {
[13:23:26.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.713]         }
[13:23:26.713]         else {
[13:23:26.713]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.713]         }
[13:23:26.713]         base::close(...future.stdout)
[13:23:26.713]         ...future.stdout <- NULL
[13:23:26.713]     }
[13:23:26.713]     ...future.result$conditions <- ...future.conditions
[13:23:26.713]     ...future.result$finished <- base::Sys.time()
[13:23:26.713]     ...future.result
[13:23:26.713] }
[13:23:26.715] assign_globals() ...
[13:23:26.715] List of 1
[13:23:26.715]  $ x: list()
[13:23:26.715]  - attr(*, "where")=List of 1
[13:23:26.715]   ..$ x:<environment: R_EmptyEnv> 
[13:23:26.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.715]  - attr(*, "resolved")= logi TRUE
[13:23:26.715]  - attr(*, "total_size")= num 0
[13:23:26.715]  - attr(*, "already-done")= logi TRUE
[13:23:26.717] - copied ‘x’ to environment
[13:23:26.718] assign_globals() ... done
[13:23:26.718] plan(): Setting new future strategy stack:
[13:23:26.718] List of future strategies:
[13:23:26.718] 1. sequential:
[13:23:26.718]    - args: function (..., envir = parent.frame())
[13:23:26.718]    - tweaked: FALSE
[13:23:26.718]    - call: NULL
[13:23:26.718] plan(): nbrOfWorkers() = 1
[13:23:26.719] plan(): Setting new future strategy stack:
[13:23:26.719] List of future strategies:
[13:23:26.719] 1. sequential:
[13:23:26.719]    - args: function (..., envir = parent.frame())
[13:23:26.719]    - tweaked: FALSE
[13:23:26.719]    - call: plan(strategy)
[13:23:26.720] plan(): nbrOfWorkers() = 1
[13:23:26.720] SequentialFuture started (and completed)
[13:23:26.720] - Launch lazy future ... done
[13:23:26.720] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.721] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.722] Searching for globals...
[13:23:26.724] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.724] Searching for globals ... DONE
[13:23:26.724] Resolving globals: TRUE
[13:23:26.724] Resolving any globals that are futures ...
[13:23:26.724] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.724] Resolving any globals that are futures ... DONE
[13:23:26.725] Resolving futures part of globals (recursively) ...
[13:23:26.725] resolve() on list ...
[13:23:26.725]  recursive: 99
[13:23:26.725]  length: 1
[13:23:26.725]  elements: ‘x’
[13:23:26.725]  length: 0 (resolved future 1)
[13:23:26.725] resolve() on list ... DONE
[13:23:26.726] - globals: [1] ‘x’
[13:23:26.726] Resolving futures part of globals (recursively) ... DONE
[13:23:26.726] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.726] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.728] - globals: [1] ‘x’
[13:23:26.729] 
[13:23:26.729] getGlobalsAndPackages() ... DONE
[13:23:26.729] run() for ‘Future’ ...
[13:23:26.729] - state: ‘created’
[13:23:26.729] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:26.730] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:26.730] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:26.730]   - Field: ‘label’
[13:23:26.730]   - Field: ‘local’
[13:23:26.730]   - Field: ‘owner’
[13:23:26.730]   - Field: ‘envir’
[13:23:26.730]   - Field: ‘packages’
[13:23:26.730]   - Field: ‘gc’
[13:23:26.731]   - Field: ‘conditions’
[13:23:26.731]   - Field: ‘expr’
[13:23:26.731]   - Field: ‘uuid’
[13:23:26.731]   - Field: ‘seed’
[13:23:26.731]   - Field: ‘version’
[13:23:26.731]   - Field: ‘result’
[13:23:26.731]   - Field: ‘asynchronous’
[13:23:26.731]   - Field: ‘calls’
[13:23:26.731]   - Field: ‘globals’
[13:23:26.731]   - Field: ‘stdout’
[13:23:26.732]   - Field: ‘earlySignal’
[13:23:26.732]   - Field: ‘lazy’
[13:23:26.732]   - Field: ‘state’
[13:23:26.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:26.732] - Launch lazy future ...
[13:23:26.732] Packages needed by the future expression (n = 0): <none>
[13:23:26.732] Packages needed by future strategies (n = 0): <none>
[13:23:26.733] {
[13:23:26.733]     {
[13:23:26.733]         {
[13:23:26.733]             ...future.startTime <- base::Sys.time()
[13:23:26.733]             {
[13:23:26.733]                 {
[13:23:26.733]                   {
[13:23:26.733]                     base::local({
[13:23:26.733]                       has_future <- base::requireNamespace("future", 
[13:23:26.733]                         quietly = TRUE)
[13:23:26.733]                       if (has_future) {
[13:23:26.733]                         ns <- base::getNamespace("future")
[13:23:26.733]                         version <- ns[[".package"]][["version"]]
[13:23:26.733]                         if (is.null(version)) 
[13:23:26.733]                           version <- utils::packageVersion("future")
[13:23:26.733]                       }
[13:23:26.733]                       else {
[13:23:26.733]                         version <- NULL
[13:23:26.733]                       }
[13:23:26.733]                       if (!has_future || version < "1.8.0") {
[13:23:26.733]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.733]                           "", base::R.version$version.string), 
[13:23:26.733]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:26.733]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.733]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.733]                             "release", "version")], collapse = " "), 
[13:23:26.733]                           hostname = base::Sys.info()[["nodename"]])
[13:23:26.733]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.733]                           info)
[13:23:26.733]                         info <- base::paste(info, collapse = "; ")
[13:23:26.733]                         if (!has_future) {
[13:23:26.733]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.733]                             info)
[13:23:26.733]                         }
[13:23:26.733]                         else {
[13:23:26.733]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.733]                             info, version)
[13:23:26.733]                         }
[13:23:26.733]                         base::stop(msg)
[13:23:26.733]                       }
[13:23:26.733]                     })
[13:23:26.733]                   }
[13:23:26.733]                   options(future.plan = NULL)
[13:23:26.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.733]                 }
[13:23:26.733]                 ...future.workdir <- getwd()
[13:23:26.733]             }
[13:23:26.733]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.733]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.733]         }
[13:23:26.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.733]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.733]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.733]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.733]             base::names(...future.oldOptions))
[13:23:26.733]     }
[13:23:26.733]     if (FALSE) {
[13:23:26.733]     }
[13:23:26.733]     else {
[13:23:26.733]         if (TRUE) {
[13:23:26.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.733]                 open = "w")
[13:23:26.733]         }
[13:23:26.733]         else {
[13:23:26.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.733]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.733]         }
[13:23:26.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.733]             base::sink(type = "output", split = FALSE)
[13:23:26.733]             base::close(...future.stdout)
[13:23:26.733]         }, add = TRUE)
[13:23:26.733]     }
[13:23:26.733]     ...future.frame <- base::sys.nframe()
[13:23:26.733]     ...future.conditions <- base::list()
[13:23:26.733]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.733]     if (FALSE) {
[13:23:26.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.733]     }
[13:23:26.733]     ...future.result <- base::tryCatch({
[13:23:26.733]         base::withCallingHandlers({
[13:23:26.733]             ...future.value <- base::withVisible(base::local({
[13:23:26.733]                 x$a <- 1
[13:23:26.733]                 x
[13:23:26.733]             }))
[13:23:26.733]             future::FutureResult(value = ...future.value$value, 
[13:23:26.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.733]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.733]                     ...future.globalenv.names))
[13:23:26.733]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.733]         }, condition = base::local({
[13:23:26.733]             c <- base::c
[13:23:26.733]             inherits <- base::inherits
[13:23:26.733]             invokeRestart <- base::invokeRestart
[13:23:26.733]             length <- base::length
[13:23:26.733]             list <- base::list
[13:23:26.733]             seq.int <- base::seq.int
[13:23:26.733]             signalCondition <- base::signalCondition
[13:23:26.733]             sys.calls <- base::sys.calls
[13:23:26.733]             `[[` <- base::`[[`
[13:23:26.733]             `+` <- base::`+`
[13:23:26.733]             `<<-` <- base::`<<-`
[13:23:26.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.733]                   3L)]
[13:23:26.733]             }
[13:23:26.733]             function(cond) {
[13:23:26.733]                 is_error <- inherits(cond, "error")
[13:23:26.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.733]                   NULL)
[13:23:26.733]                 if (is_error) {
[13:23:26.733]                   sessionInformation <- function() {
[13:23:26.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.733]                       search = base::search(), system = base::Sys.info())
[13:23:26.733]                   }
[13:23:26.733]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.733]                     cond$call), session = sessionInformation(), 
[13:23:26.733]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.733]                   signalCondition(cond)
[13:23:26.733]                 }
[13:23:26.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.733]                 "immediateCondition"))) {
[13:23:26.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.733]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.733]                   if (TRUE && !signal) {
[13:23:26.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.733]                     {
[13:23:26.733]                       inherits <- base::inherits
[13:23:26.733]                       invokeRestart <- base::invokeRestart
[13:23:26.733]                       is.null <- base::is.null
[13:23:26.733]                       muffled <- FALSE
[13:23:26.733]                       if (inherits(cond, "message")) {
[13:23:26.733]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.733]                         if (muffled) 
[13:23:26.733]                           invokeRestart("muffleMessage")
[13:23:26.733]                       }
[13:23:26.733]                       else if (inherits(cond, "warning")) {
[13:23:26.733]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.733]                         if (muffled) 
[13:23:26.733]                           invokeRestart("muffleWarning")
[13:23:26.733]                       }
[13:23:26.733]                       else if (inherits(cond, "condition")) {
[13:23:26.733]                         if (!is.null(pattern)) {
[13:23:26.733]                           computeRestarts <- base::computeRestarts
[13:23:26.733]                           grepl <- base::grepl
[13:23:26.733]                           restarts <- computeRestarts(cond)
[13:23:26.733]                           for (restart in restarts) {
[13:23:26.733]                             name <- restart$name
[13:23:26.733]                             if (is.null(name)) 
[13:23:26.733]                               next
[13:23:26.733]                             if (!grepl(pattern, name)) 
[13:23:26.733]                               next
[13:23:26.733]                             invokeRestart(restart)
[13:23:26.733]                             muffled <- TRUE
[13:23:26.733]                             break
[13:23:26.733]                           }
[13:23:26.733]                         }
[13:23:26.733]                       }
[13:23:26.733]                       invisible(muffled)
[13:23:26.733]                     }
[13:23:26.733]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.733]                   }
[13:23:26.733]                 }
[13:23:26.733]                 else {
[13:23:26.733]                   if (TRUE) {
[13:23:26.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.733]                     {
[13:23:26.733]                       inherits <- base::inherits
[13:23:26.733]                       invokeRestart <- base::invokeRestart
[13:23:26.733]                       is.null <- base::is.null
[13:23:26.733]                       muffled <- FALSE
[13:23:26.733]                       if (inherits(cond, "message")) {
[13:23:26.733]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.733]                         if (muffled) 
[13:23:26.733]                           invokeRestart("muffleMessage")
[13:23:26.733]                       }
[13:23:26.733]                       else if (inherits(cond, "warning")) {
[13:23:26.733]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.733]                         if (muffled) 
[13:23:26.733]                           invokeRestart("muffleWarning")
[13:23:26.733]                       }
[13:23:26.733]                       else if (inherits(cond, "condition")) {
[13:23:26.733]                         if (!is.null(pattern)) {
[13:23:26.733]                           computeRestarts <- base::computeRestarts
[13:23:26.733]                           grepl <- base::grepl
[13:23:26.733]                           restarts <- computeRestarts(cond)
[13:23:26.733]                           for (restart in restarts) {
[13:23:26.733]                             name <- restart$name
[13:23:26.733]                             if (is.null(name)) 
[13:23:26.733]                               next
[13:23:26.733]                             if (!grepl(pattern, name)) 
[13:23:26.733]                               next
[13:23:26.733]                             invokeRestart(restart)
[13:23:26.733]                             muffled <- TRUE
[13:23:26.733]                             break
[13:23:26.733]                           }
[13:23:26.733]                         }
[13:23:26.733]                       }
[13:23:26.733]                       invisible(muffled)
[13:23:26.733]                     }
[13:23:26.733]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.733]                   }
[13:23:26.733]                 }
[13:23:26.733]             }
[13:23:26.733]         }))
[13:23:26.733]     }, error = function(ex) {
[13:23:26.733]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.733]                 ...future.rng), started = ...future.startTime, 
[13:23:26.733]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.733]             version = "1.8"), class = "FutureResult")
[13:23:26.733]     }, finally = {
[13:23:26.733]         if (!identical(...future.workdir, getwd())) 
[13:23:26.733]             setwd(...future.workdir)
[13:23:26.733]         {
[13:23:26.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.733]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.733]             }
[13:23:26.733]             base::options(...future.oldOptions)
[13:23:26.733]             if (.Platform$OS.type == "windows") {
[13:23:26.733]                 old_names <- names(...future.oldEnvVars)
[13:23:26.733]                 envs <- base::Sys.getenv()
[13:23:26.733]                 names <- names(envs)
[13:23:26.733]                 common <- intersect(names, old_names)
[13:23:26.733]                 added <- setdiff(names, old_names)
[13:23:26.733]                 removed <- setdiff(old_names, names)
[13:23:26.733]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.733]                   envs[common]]
[13:23:26.733]                 NAMES <- toupper(changed)
[13:23:26.733]                 args <- list()
[13:23:26.733]                 for (kk in seq_along(NAMES)) {
[13:23:26.733]                   name <- changed[[kk]]
[13:23:26.733]                   NAME <- NAMES[[kk]]
[13:23:26.733]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.733]                     next
[13:23:26.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.733]                 }
[13:23:26.733]                 NAMES <- toupper(added)
[13:23:26.733]                 for (kk in seq_along(NAMES)) {
[13:23:26.733]                   name <- added[[kk]]
[13:23:26.733]                   NAME <- NAMES[[kk]]
[13:23:26.733]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.733]                     next
[13:23:26.733]                   args[[name]] <- ""
[13:23:26.733]                 }
[13:23:26.733]                 NAMES <- toupper(removed)
[13:23:26.733]                 for (kk in seq_along(NAMES)) {
[13:23:26.733]                   name <- removed[[kk]]
[13:23:26.733]                   NAME <- NAMES[[kk]]
[13:23:26.733]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.733]                     next
[13:23:26.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.733]                 }
[13:23:26.733]                 if (length(args) > 0) 
[13:23:26.733]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.733]             }
[13:23:26.733]             else {
[13:23:26.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.733]             }
[13:23:26.733]             {
[13:23:26.733]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.733]                   0L) {
[13:23:26.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.733]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.733]                   base::options(opts)
[13:23:26.733]                 }
[13:23:26.733]                 {
[13:23:26.733]                   {
[13:23:26.733]                     NULL
[13:23:26.733]                     RNGkind("Mersenne-Twister")
[13:23:26.733]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:26.733]                       inherits = FALSE)
[13:23:26.733]                   }
[13:23:26.733]                   options(future.plan = NULL)
[13:23:26.733]                   if (is.na(NA_character_)) 
[13:23:26.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.733]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:26.733]                   {
[13:23:26.733]                     future <- SequentialFuture(..., envir = envir)
[13:23:26.733]                     if (!future$lazy) 
[13:23:26.733]                       future <- run(future)
[13:23:26.733]                     invisible(future)
[13:23:26.733]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.733]                 }
[13:23:26.733]             }
[13:23:26.733]         }
[13:23:26.733]     })
[13:23:26.733]     if (TRUE) {
[13:23:26.733]         base::sink(type = "output", split = FALSE)
[13:23:26.733]         if (TRUE) {
[13:23:26.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.733]         }
[13:23:26.733]         else {
[13:23:26.733]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.733]         }
[13:23:26.733]         base::close(...future.stdout)
[13:23:26.733]         ...future.stdout <- NULL
[13:23:26.733]     }
[13:23:26.733]     ...future.result$conditions <- ...future.conditions
[13:23:26.733]     ...future.result$finished <- base::Sys.time()
[13:23:26.733]     ...future.result
[13:23:26.733] }
[13:23:26.734] assign_globals() ...
[13:23:26.735] List of 1
[13:23:26.735]  $ x: list()
[13:23:26.735]  - attr(*, "where")=List of 1
[13:23:26.735]   ..$ x:<environment: R_EmptyEnv> 
[13:23:26.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.735]  - attr(*, "resolved")= logi TRUE
[13:23:26.735]  - attr(*, "total_size")= num 0
[13:23:26.735]  - attr(*, "already-done")= logi TRUE
[13:23:26.737] - copied ‘x’ to environment
[13:23:26.737] assign_globals() ... done
[13:23:26.737] plan(): Setting new future strategy stack:
[13:23:26.738] List of future strategies:
[13:23:26.738] 1. sequential:
[13:23:26.738]    - args: function (..., envir = parent.frame())
[13:23:26.738]    - tweaked: FALSE
[13:23:26.738]    - call: NULL
[13:23:26.738] plan(): nbrOfWorkers() = 1
[13:23:26.739] plan(): Setting new future strategy stack:
[13:23:26.739] List of future strategies:
[13:23:26.739] 1. sequential:
[13:23:26.739]    - args: function (..., envir = parent.frame())
[13:23:26.739]    - tweaked: FALSE
[13:23:26.739]    - call: plan(strategy)
[13:23:26.739] plan(): nbrOfWorkers() = 1
[13:23:26.739] SequentialFuture started (and completed)
[13:23:26.740] - Launch lazy future ... done
[13:23:26.740] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.740] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.740] Searching for globals...
[13:23:26.742] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.742] Searching for globals ... DONE
[13:23:26.743] Resolving globals: TRUE
[13:23:26.743] Resolving any globals that are futures ...
[13:23:26.743] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.743] Resolving any globals that are futures ... DONE
[13:23:26.743] Resolving futures part of globals (recursively) ...
[13:23:26.744] resolve() on list ...
[13:23:26.744]  recursive: 99
[13:23:26.744]  length: 1
[13:23:26.744]  elements: ‘x’
[13:23:26.744]  length: 0 (resolved future 1)
[13:23:26.744] resolve() on list ... DONE
[13:23:26.744] - globals: [1] ‘x’
[13:23:26.744] Resolving futures part of globals (recursively) ... DONE
[13:23:26.744] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.745] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.745] - globals: [1] ‘x’
[13:23:26.745] 
[13:23:26.745] getGlobalsAndPackages() ... DONE
[13:23:26.745] run() for ‘Future’ ...
[13:23:26.746] - state: ‘created’
[13:23:26.746] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:26.746] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:26.746] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:26.746]   - Field: ‘label’
[13:23:26.746]   - Field: ‘local’
[13:23:26.746]   - Field: ‘owner’
[13:23:26.746]   - Field: ‘envir’
[13:23:26.747]   - Field: ‘packages’
[13:23:26.747]   - Field: ‘gc’
[13:23:26.747]   - Field: ‘conditions’
[13:23:26.747]   - Field: ‘expr’
[13:23:26.747]   - Field: ‘uuid’
[13:23:26.747]   - Field: ‘seed’
[13:23:26.747]   - Field: ‘version’
[13:23:26.747]   - Field: ‘result’
[13:23:26.747]   - Field: ‘asynchronous’
[13:23:26.747]   - Field: ‘calls’
[13:23:26.747]   - Field: ‘globals’
[13:23:26.748]   - Field: ‘stdout’
[13:23:26.748]   - Field: ‘earlySignal’
[13:23:26.748]   - Field: ‘lazy’
[13:23:26.748]   - Field: ‘state’
[13:23:26.748] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:26.748] - Launch lazy future ...
[13:23:26.748] Packages needed by the future expression (n = 0): <none>
[13:23:26.748] Packages needed by future strategies (n = 0): <none>
[13:23:26.749] {
[13:23:26.749]     {
[13:23:26.749]         {
[13:23:26.749]             ...future.startTime <- base::Sys.time()
[13:23:26.749]             {
[13:23:26.749]                 {
[13:23:26.749]                   {
[13:23:26.749]                     base::local({
[13:23:26.749]                       has_future <- base::requireNamespace("future", 
[13:23:26.749]                         quietly = TRUE)
[13:23:26.749]                       if (has_future) {
[13:23:26.749]                         ns <- base::getNamespace("future")
[13:23:26.749]                         version <- ns[[".package"]][["version"]]
[13:23:26.749]                         if (is.null(version)) 
[13:23:26.749]                           version <- utils::packageVersion("future")
[13:23:26.749]                       }
[13:23:26.749]                       else {
[13:23:26.749]                         version <- NULL
[13:23:26.749]                       }
[13:23:26.749]                       if (!has_future || version < "1.8.0") {
[13:23:26.749]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.749]                           "", base::R.version$version.string), 
[13:23:26.749]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:26.749]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.749]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.749]                             "release", "version")], collapse = " "), 
[13:23:26.749]                           hostname = base::Sys.info()[["nodename"]])
[13:23:26.749]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.749]                           info)
[13:23:26.749]                         info <- base::paste(info, collapse = "; ")
[13:23:26.749]                         if (!has_future) {
[13:23:26.749]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.749]                             info)
[13:23:26.749]                         }
[13:23:26.749]                         else {
[13:23:26.749]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.749]                             info, version)
[13:23:26.749]                         }
[13:23:26.749]                         base::stop(msg)
[13:23:26.749]                       }
[13:23:26.749]                     })
[13:23:26.749]                   }
[13:23:26.749]                   options(future.plan = NULL)
[13:23:26.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.749]                 }
[13:23:26.749]                 ...future.workdir <- getwd()
[13:23:26.749]             }
[13:23:26.749]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.749]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.749]         }
[13:23:26.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.749]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.749]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.749]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.749]             base::names(...future.oldOptions))
[13:23:26.749]     }
[13:23:26.749]     if (FALSE) {
[13:23:26.749]     }
[13:23:26.749]     else {
[13:23:26.749]         if (TRUE) {
[13:23:26.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.749]                 open = "w")
[13:23:26.749]         }
[13:23:26.749]         else {
[13:23:26.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.749]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.749]         }
[13:23:26.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.749]             base::sink(type = "output", split = FALSE)
[13:23:26.749]             base::close(...future.stdout)
[13:23:26.749]         }, add = TRUE)
[13:23:26.749]     }
[13:23:26.749]     ...future.frame <- base::sys.nframe()
[13:23:26.749]     ...future.conditions <- base::list()
[13:23:26.749]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.749]     if (FALSE) {
[13:23:26.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.749]     }
[13:23:26.749]     ...future.result <- base::tryCatch({
[13:23:26.749]         base::withCallingHandlers({
[13:23:26.749]             ...future.value <- base::withVisible(base::local({
[13:23:26.749]                 x$a <- 1
[13:23:26.749]                 x
[13:23:26.749]             }))
[13:23:26.749]             future::FutureResult(value = ...future.value$value, 
[13:23:26.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.749]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.749]                     ...future.globalenv.names))
[13:23:26.749]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.749]         }, condition = base::local({
[13:23:26.749]             c <- base::c
[13:23:26.749]             inherits <- base::inherits
[13:23:26.749]             invokeRestart <- base::invokeRestart
[13:23:26.749]             length <- base::length
[13:23:26.749]             list <- base::list
[13:23:26.749]             seq.int <- base::seq.int
[13:23:26.749]             signalCondition <- base::signalCondition
[13:23:26.749]             sys.calls <- base::sys.calls
[13:23:26.749]             `[[` <- base::`[[`
[13:23:26.749]             `+` <- base::`+`
[13:23:26.749]             `<<-` <- base::`<<-`
[13:23:26.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.749]                   3L)]
[13:23:26.749]             }
[13:23:26.749]             function(cond) {
[13:23:26.749]                 is_error <- inherits(cond, "error")
[13:23:26.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.749]                   NULL)
[13:23:26.749]                 if (is_error) {
[13:23:26.749]                   sessionInformation <- function() {
[13:23:26.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.749]                       search = base::search(), system = base::Sys.info())
[13:23:26.749]                   }
[13:23:26.749]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.749]                     cond$call), session = sessionInformation(), 
[13:23:26.749]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.749]                   signalCondition(cond)
[13:23:26.749]                 }
[13:23:26.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.749]                 "immediateCondition"))) {
[13:23:26.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.749]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.749]                   if (TRUE && !signal) {
[13:23:26.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.749]                     {
[13:23:26.749]                       inherits <- base::inherits
[13:23:26.749]                       invokeRestart <- base::invokeRestart
[13:23:26.749]                       is.null <- base::is.null
[13:23:26.749]                       muffled <- FALSE
[13:23:26.749]                       if (inherits(cond, "message")) {
[13:23:26.749]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.749]                         if (muffled) 
[13:23:26.749]                           invokeRestart("muffleMessage")
[13:23:26.749]                       }
[13:23:26.749]                       else if (inherits(cond, "warning")) {
[13:23:26.749]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.749]                         if (muffled) 
[13:23:26.749]                           invokeRestart("muffleWarning")
[13:23:26.749]                       }
[13:23:26.749]                       else if (inherits(cond, "condition")) {
[13:23:26.749]                         if (!is.null(pattern)) {
[13:23:26.749]                           computeRestarts <- base::computeRestarts
[13:23:26.749]                           grepl <- base::grepl
[13:23:26.749]                           restarts <- computeRestarts(cond)
[13:23:26.749]                           for (restart in restarts) {
[13:23:26.749]                             name <- restart$name
[13:23:26.749]                             if (is.null(name)) 
[13:23:26.749]                               next
[13:23:26.749]                             if (!grepl(pattern, name)) 
[13:23:26.749]                               next
[13:23:26.749]                             invokeRestart(restart)
[13:23:26.749]                             muffled <- TRUE
[13:23:26.749]                             break
[13:23:26.749]                           }
[13:23:26.749]                         }
[13:23:26.749]                       }
[13:23:26.749]                       invisible(muffled)
[13:23:26.749]                     }
[13:23:26.749]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.749]                   }
[13:23:26.749]                 }
[13:23:26.749]                 else {
[13:23:26.749]                   if (TRUE) {
[13:23:26.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.749]                     {
[13:23:26.749]                       inherits <- base::inherits
[13:23:26.749]                       invokeRestart <- base::invokeRestart
[13:23:26.749]                       is.null <- base::is.null
[13:23:26.749]                       muffled <- FALSE
[13:23:26.749]                       if (inherits(cond, "message")) {
[13:23:26.749]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.749]                         if (muffled) 
[13:23:26.749]                           invokeRestart("muffleMessage")
[13:23:26.749]                       }
[13:23:26.749]                       else if (inherits(cond, "warning")) {
[13:23:26.749]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.749]                         if (muffled) 
[13:23:26.749]                           invokeRestart("muffleWarning")
[13:23:26.749]                       }
[13:23:26.749]                       else if (inherits(cond, "condition")) {
[13:23:26.749]                         if (!is.null(pattern)) {
[13:23:26.749]                           computeRestarts <- base::computeRestarts
[13:23:26.749]                           grepl <- base::grepl
[13:23:26.749]                           restarts <- computeRestarts(cond)
[13:23:26.749]                           for (restart in restarts) {
[13:23:26.749]                             name <- restart$name
[13:23:26.749]                             if (is.null(name)) 
[13:23:26.749]                               next
[13:23:26.749]                             if (!grepl(pattern, name)) 
[13:23:26.749]                               next
[13:23:26.749]                             invokeRestart(restart)
[13:23:26.749]                             muffled <- TRUE
[13:23:26.749]                             break
[13:23:26.749]                           }
[13:23:26.749]                         }
[13:23:26.749]                       }
[13:23:26.749]                       invisible(muffled)
[13:23:26.749]                     }
[13:23:26.749]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.749]                   }
[13:23:26.749]                 }
[13:23:26.749]             }
[13:23:26.749]         }))
[13:23:26.749]     }, error = function(ex) {
[13:23:26.749]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.749]                 ...future.rng), started = ...future.startTime, 
[13:23:26.749]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.749]             version = "1.8"), class = "FutureResult")
[13:23:26.749]     }, finally = {
[13:23:26.749]         if (!identical(...future.workdir, getwd())) 
[13:23:26.749]             setwd(...future.workdir)
[13:23:26.749]         {
[13:23:26.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.749]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.749]             }
[13:23:26.749]             base::options(...future.oldOptions)
[13:23:26.749]             if (.Platform$OS.type == "windows") {
[13:23:26.749]                 old_names <- names(...future.oldEnvVars)
[13:23:26.749]                 envs <- base::Sys.getenv()
[13:23:26.749]                 names <- names(envs)
[13:23:26.749]                 common <- intersect(names, old_names)
[13:23:26.749]                 added <- setdiff(names, old_names)
[13:23:26.749]                 removed <- setdiff(old_names, names)
[13:23:26.749]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.749]                   envs[common]]
[13:23:26.749]                 NAMES <- toupper(changed)
[13:23:26.749]                 args <- list()
[13:23:26.749]                 for (kk in seq_along(NAMES)) {
[13:23:26.749]                   name <- changed[[kk]]
[13:23:26.749]                   NAME <- NAMES[[kk]]
[13:23:26.749]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.749]                     next
[13:23:26.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.749]                 }
[13:23:26.749]                 NAMES <- toupper(added)
[13:23:26.749]                 for (kk in seq_along(NAMES)) {
[13:23:26.749]                   name <- added[[kk]]
[13:23:26.749]                   NAME <- NAMES[[kk]]
[13:23:26.749]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.749]                     next
[13:23:26.749]                   args[[name]] <- ""
[13:23:26.749]                 }
[13:23:26.749]                 NAMES <- toupper(removed)
[13:23:26.749]                 for (kk in seq_along(NAMES)) {
[13:23:26.749]                   name <- removed[[kk]]
[13:23:26.749]                   NAME <- NAMES[[kk]]
[13:23:26.749]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.749]                     next
[13:23:26.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.749]                 }
[13:23:26.749]                 if (length(args) > 0) 
[13:23:26.749]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.749]             }
[13:23:26.749]             else {
[13:23:26.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.749]             }
[13:23:26.749]             {
[13:23:26.749]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.749]                   0L) {
[13:23:26.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.749]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.749]                   base::options(opts)
[13:23:26.749]                 }
[13:23:26.749]                 {
[13:23:26.749]                   {
[13:23:26.749]                     NULL
[13:23:26.749]                     RNGkind("Mersenne-Twister")
[13:23:26.749]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:26.749]                       inherits = FALSE)
[13:23:26.749]                   }
[13:23:26.749]                   options(future.plan = NULL)
[13:23:26.749]                   if (is.na(NA_character_)) 
[13:23:26.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.749]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:26.749]                   {
[13:23:26.749]                     future <- SequentialFuture(..., envir = envir)
[13:23:26.749]                     if (!future$lazy) 
[13:23:26.749]                       future <- run(future)
[13:23:26.749]                     invisible(future)
[13:23:26.749]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.749]                 }
[13:23:26.749]             }
[13:23:26.749]         }
[13:23:26.749]     })
[13:23:26.749]     if (TRUE) {
[13:23:26.749]         base::sink(type = "output", split = FALSE)
[13:23:26.749]         if (TRUE) {
[13:23:26.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.749]         }
[13:23:26.749]         else {
[13:23:26.749]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.749]         }
[13:23:26.749]         base::close(...future.stdout)
[13:23:26.749]         ...future.stdout <- NULL
[13:23:26.749]     }
[13:23:26.749]     ...future.result$conditions <- ...future.conditions
[13:23:26.749]     ...future.result$finished <- base::Sys.time()
[13:23:26.749]     ...future.result
[13:23:26.749] }
[13:23:26.751] assign_globals() ...
[13:23:26.751] List of 1
[13:23:26.751]  $ x: list()
[13:23:26.751]  - attr(*, "where")=List of 1
[13:23:26.751]   ..$ x:<environment: R_EmptyEnv> 
[13:23:26.751]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.751]  - attr(*, "resolved")= logi TRUE
[13:23:26.751]  - attr(*, "total_size")= num 0
[13:23:26.751]  - attr(*, "already-done")= logi TRUE
[13:23:26.753] - copied ‘x’ to environment
[13:23:26.753] assign_globals() ... done
[13:23:26.754] plan(): Setting new future strategy stack:
[13:23:26.754] List of future strategies:
[13:23:26.754] 1. sequential:
[13:23:26.754]    - args: function (..., envir = parent.frame())
[13:23:26.754]    - tweaked: FALSE
[13:23:26.754]    - call: NULL
[13:23:26.754] plan(): nbrOfWorkers() = 1
[13:23:26.755] plan(): Setting new future strategy stack:
[13:23:26.755] List of future strategies:
[13:23:26.755] 1. sequential:
[13:23:26.755]    - args: function (..., envir = parent.frame())
[13:23:26.755]    - tweaked: FALSE
[13:23:26.755]    - call: plan(strategy)
[13:23:26.755] plan(): nbrOfWorkers() = 1
[13:23:26.756] SequentialFuture started (and completed)
[13:23:26.756] - Launch lazy future ... done
[13:23:26.756] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.756] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.757] Searching for globals...
[13:23:26.761] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[13:23:26.761] Searching for globals ... DONE
[13:23:26.761] Resolving globals: TRUE
[13:23:26.761] Resolving any globals that are futures ...
[13:23:26.761] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[13:23:26.762] Resolving any globals that are futures ... DONE
[13:23:26.762] 
[13:23:26.762] 
[13:23:26.762] getGlobalsAndPackages() ... DONE
[13:23:26.762] run() for ‘Future’ ...
[13:23:26.762] - state: ‘created’
[13:23:26.763] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:26.763] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:26.763] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:26.763]   - Field: ‘label’
[13:23:26.763]   - Field: ‘local’
[13:23:26.763]   - Field: ‘owner’
[13:23:26.763]   - Field: ‘envir’
[13:23:26.763]   - Field: ‘packages’
[13:23:26.764]   - Field: ‘gc’
[13:23:26.764]   - Field: ‘conditions’
[13:23:26.764]   - Field: ‘expr’
[13:23:26.764]   - Field: ‘uuid’
[13:23:26.764]   - Field: ‘seed’
[13:23:26.764]   - Field: ‘version’
[13:23:26.764]   - Field: ‘result’
[13:23:26.764]   - Field: ‘asynchronous’
[13:23:26.764]   - Field: ‘calls’
[13:23:26.764]   - Field: ‘globals’
[13:23:26.765]   - Field: ‘stdout’
[13:23:26.765]   - Field: ‘earlySignal’
[13:23:26.765]   - Field: ‘lazy’
[13:23:26.765]   - Field: ‘state’
[13:23:26.765] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:26.765] - Launch lazy future ...
[13:23:26.765] Packages needed by the future expression (n = 0): <none>
[13:23:26.765] Packages needed by future strategies (n = 0): <none>
[13:23:26.766] {
[13:23:26.766]     {
[13:23:26.766]         {
[13:23:26.766]             ...future.startTime <- base::Sys.time()
[13:23:26.766]             {
[13:23:26.766]                 {
[13:23:26.766]                   {
[13:23:26.766]                     base::local({
[13:23:26.766]                       has_future <- base::requireNamespace("future", 
[13:23:26.766]                         quietly = TRUE)
[13:23:26.766]                       if (has_future) {
[13:23:26.766]                         ns <- base::getNamespace("future")
[13:23:26.766]                         version <- ns[[".package"]][["version"]]
[13:23:26.766]                         if (is.null(version)) 
[13:23:26.766]                           version <- utils::packageVersion("future")
[13:23:26.766]                       }
[13:23:26.766]                       else {
[13:23:26.766]                         version <- NULL
[13:23:26.766]                       }
[13:23:26.766]                       if (!has_future || version < "1.8.0") {
[13:23:26.766]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.766]                           "", base::R.version$version.string), 
[13:23:26.766]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:26.766]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.766]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.766]                             "release", "version")], collapse = " "), 
[13:23:26.766]                           hostname = base::Sys.info()[["nodename"]])
[13:23:26.766]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.766]                           info)
[13:23:26.766]                         info <- base::paste(info, collapse = "; ")
[13:23:26.766]                         if (!has_future) {
[13:23:26.766]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.766]                             info)
[13:23:26.766]                         }
[13:23:26.766]                         else {
[13:23:26.766]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.766]                             info, version)
[13:23:26.766]                         }
[13:23:26.766]                         base::stop(msg)
[13:23:26.766]                       }
[13:23:26.766]                     })
[13:23:26.766]                   }
[13:23:26.766]                   options(future.plan = NULL)
[13:23:26.766]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.766]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.766]                 }
[13:23:26.766]                 ...future.workdir <- getwd()
[13:23:26.766]             }
[13:23:26.766]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.766]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.766]         }
[13:23:26.766]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.766]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.766]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.766]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.766]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.766]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.766]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.766]             base::names(...future.oldOptions))
[13:23:26.766]     }
[13:23:26.766]     if (FALSE) {
[13:23:26.766]     }
[13:23:26.766]     else {
[13:23:26.766]         if (TRUE) {
[13:23:26.766]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.766]                 open = "w")
[13:23:26.766]         }
[13:23:26.766]         else {
[13:23:26.766]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.766]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.766]         }
[13:23:26.766]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.766]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.766]             base::sink(type = "output", split = FALSE)
[13:23:26.766]             base::close(...future.stdout)
[13:23:26.766]         }, add = TRUE)
[13:23:26.766]     }
[13:23:26.766]     ...future.frame <- base::sys.nframe()
[13:23:26.766]     ...future.conditions <- base::list()
[13:23:26.766]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.766]     if (FALSE) {
[13:23:26.766]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.766]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.766]     }
[13:23:26.766]     ...future.result <- base::tryCatch({
[13:23:26.766]         base::withCallingHandlers({
[13:23:26.766]             ...future.value <- base::withVisible(base::local({
[13:23:26.766]                 x <- list(b = 2)
[13:23:26.766]                 x$a <- 1
[13:23:26.766]                 x
[13:23:26.766]             }))
[13:23:26.766]             future::FutureResult(value = ...future.value$value, 
[13:23:26.766]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.766]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.766]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.766]                     ...future.globalenv.names))
[13:23:26.766]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.766]         }, condition = base::local({
[13:23:26.766]             c <- base::c
[13:23:26.766]             inherits <- base::inherits
[13:23:26.766]             invokeRestart <- base::invokeRestart
[13:23:26.766]             length <- base::length
[13:23:26.766]             list <- base::list
[13:23:26.766]             seq.int <- base::seq.int
[13:23:26.766]             signalCondition <- base::signalCondition
[13:23:26.766]             sys.calls <- base::sys.calls
[13:23:26.766]             `[[` <- base::`[[`
[13:23:26.766]             `+` <- base::`+`
[13:23:26.766]             `<<-` <- base::`<<-`
[13:23:26.766]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.766]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.766]                   3L)]
[13:23:26.766]             }
[13:23:26.766]             function(cond) {
[13:23:26.766]                 is_error <- inherits(cond, "error")
[13:23:26.766]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.766]                   NULL)
[13:23:26.766]                 if (is_error) {
[13:23:26.766]                   sessionInformation <- function() {
[13:23:26.766]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.766]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.766]                       search = base::search(), system = base::Sys.info())
[13:23:26.766]                   }
[13:23:26.766]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.766]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.766]                     cond$call), session = sessionInformation(), 
[13:23:26.766]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.766]                   signalCondition(cond)
[13:23:26.766]                 }
[13:23:26.766]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.766]                 "immediateCondition"))) {
[13:23:26.766]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.766]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.766]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.766]                   if (TRUE && !signal) {
[13:23:26.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.766]                     {
[13:23:26.766]                       inherits <- base::inherits
[13:23:26.766]                       invokeRestart <- base::invokeRestart
[13:23:26.766]                       is.null <- base::is.null
[13:23:26.766]                       muffled <- FALSE
[13:23:26.766]                       if (inherits(cond, "message")) {
[13:23:26.766]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.766]                         if (muffled) 
[13:23:26.766]                           invokeRestart("muffleMessage")
[13:23:26.766]                       }
[13:23:26.766]                       else if (inherits(cond, "warning")) {
[13:23:26.766]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.766]                         if (muffled) 
[13:23:26.766]                           invokeRestart("muffleWarning")
[13:23:26.766]                       }
[13:23:26.766]                       else if (inherits(cond, "condition")) {
[13:23:26.766]                         if (!is.null(pattern)) {
[13:23:26.766]                           computeRestarts <- base::computeRestarts
[13:23:26.766]                           grepl <- base::grepl
[13:23:26.766]                           restarts <- computeRestarts(cond)
[13:23:26.766]                           for (restart in restarts) {
[13:23:26.766]                             name <- restart$name
[13:23:26.766]                             if (is.null(name)) 
[13:23:26.766]                               next
[13:23:26.766]                             if (!grepl(pattern, name)) 
[13:23:26.766]                               next
[13:23:26.766]                             invokeRestart(restart)
[13:23:26.766]                             muffled <- TRUE
[13:23:26.766]                             break
[13:23:26.766]                           }
[13:23:26.766]                         }
[13:23:26.766]                       }
[13:23:26.766]                       invisible(muffled)
[13:23:26.766]                     }
[13:23:26.766]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.766]                   }
[13:23:26.766]                 }
[13:23:26.766]                 else {
[13:23:26.766]                   if (TRUE) {
[13:23:26.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.766]                     {
[13:23:26.766]                       inherits <- base::inherits
[13:23:26.766]                       invokeRestart <- base::invokeRestart
[13:23:26.766]                       is.null <- base::is.null
[13:23:26.766]                       muffled <- FALSE
[13:23:26.766]                       if (inherits(cond, "message")) {
[13:23:26.766]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.766]                         if (muffled) 
[13:23:26.766]                           invokeRestart("muffleMessage")
[13:23:26.766]                       }
[13:23:26.766]                       else if (inherits(cond, "warning")) {
[13:23:26.766]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.766]                         if (muffled) 
[13:23:26.766]                           invokeRestart("muffleWarning")
[13:23:26.766]                       }
[13:23:26.766]                       else if (inherits(cond, "condition")) {
[13:23:26.766]                         if (!is.null(pattern)) {
[13:23:26.766]                           computeRestarts <- base::computeRestarts
[13:23:26.766]                           grepl <- base::grepl
[13:23:26.766]                           restarts <- computeRestarts(cond)
[13:23:26.766]                           for (restart in restarts) {
[13:23:26.766]                             name <- restart$name
[13:23:26.766]                             if (is.null(name)) 
[13:23:26.766]                               next
[13:23:26.766]                             if (!grepl(pattern, name)) 
[13:23:26.766]                               next
[13:23:26.766]                             invokeRestart(restart)
[13:23:26.766]                             muffled <- TRUE
[13:23:26.766]                             break
[13:23:26.766]                           }
[13:23:26.766]                         }
[13:23:26.766]                       }
[13:23:26.766]                       invisible(muffled)
[13:23:26.766]                     }
[13:23:26.766]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.766]                   }
[13:23:26.766]                 }
[13:23:26.766]             }
[13:23:26.766]         }))
[13:23:26.766]     }, error = function(ex) {
[13:23:26.766]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.766]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.766]                 ...future.rng), started = ...future.startTime, 
[13:23:26.766]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.766]             version = "1.8"), class = "FutureResult")
[13:23:26.766]     }, finally = {
[13:23:26.766]         if (!identical(...future.workdir, getwd())) 
[13:23:26.766]             setwd(...future.workdir)
[13:23:26.766]         {
[13:23:26.766]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.766]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.766]             }
[13:23:26.766]             base::options(...future.oldOptions)
[13:23:26.766]             if (.Platform$OS.type == "windows") {
[13:23:26.766]                 old_names <- names(...future.oldEnvVars)
[13:23:26.766]                 envs <- base::Sys.getenv()
[13:23:26.766]                 names <- names(envs)
[13:23:26.766]                 common <- intersect(names, old_names)
[13:23:26.766]                 added <- setdiff(names, old_names)
[13:23:26.766]                 removed <- setdiff(old_names, names)
[13:23:26.766]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.766]                   envs[common]]
[13:23:26.766]                 NAMES <- toupper(changed)
[13:23:26.766]                 args <- list()
[13:23:26.766]                 for (kk in seq_along(NAMES)) {
[13:23:26.766]                   name <- changed[[kk]]
[13:23:26.766]                   NAME <- NAMES[[kk]]
[13:23:26.766]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.766]                     next
[13:23:26.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.766]                 }
[13:23:26.766]                 NAMES <- toupper(added)
[13:23:26.766]                 for (kk in seq_along(NAMES)) {
[13:23:26.766]                   name <- added[[kk]]
[13:23:26.766]                   NAME <- NAMES[[kk]]
[13:23:26.766]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.766]                     next
[13:23:26.766]                   args[[name]] <- ""
[13:23:26.766]                 }
[13:23:26.766]                 NAMES <- toupper(removed)
[13:23:26.766]                 for (kk in seq_along(NAMES)) {
[13:23:26.766]                   name <- removed[[kk]]
[13:23:26.766]                   NAME <- NAMES[[kk]]
[13:23:26.766]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.766]                     next
[13:23:26.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.766]                 }
[13:23:26.766]                 if (length(args) > 0) 
[13:23:26.766]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.766]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.766]             }
[13:23:26.766]             else {
[13:23:26.766]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.766]             }
[13:23:26.766]             {
[13:23:26.766]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.766]                   0L) {
[13:23:26.766]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.766]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.766]                   base::options(opts)
[13:23:26.766]                 }
[13:23:26.766]                 {
[13:23:26.766]                   {
[13:23:26.766]                     NULL
[13:23:26.766]                     RNGkind("Mersenne-Twister")
[13:23:26.766]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:26.766]                       inherits = FALSE)
[13:23:26.766]                   }
[13:23:26.766]                   options(future.plan = NULL)
[13:23:26.766]                   if (is.na(NA_character_)) 
[13:23:26.766]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.766]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.766]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:26.766]                   {
[13:23:26.766]                     future <- SequentialFuture(..., envir = envir)
[13:23:26.766]                     if (!future$lazy) 
[13:23:26.766]                       future <- run(future)
[13:23:26.766]                     invisible(future)
[13:23:26.766]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.766]                 }
[13:23:26.766]             }
[13:23:26.766]         }
[13:23:26.766]     })
[13:23:26.766]     if (TRUE) {
[13:23:26.766]         base::sink(type = "output", split = FALSE)
[13:23:26.766]         if (TRUE) {
[13:23:26.766]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.766]         }
[13:23:26.766]         else {
[13:23:26.766]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.766]         }
[13:23:26.766]         base::close(...future.stdout)
[13:23:26.766]         ...future.stdout <- NULL
[13:23:26.766]     }
[13:23:26.766]     ...future.result$conditions <- ...future.conditions
[13:23:26.766]     ...future.result$finished <- base::Sys.time()
[13:23:26.766]     ...future.result
[13:23:26.766] }
[13:23:26.768] plan(): Setting new future strategy stack:
[13:23:26.768] List of future strategies:
[13:23:26.768] 1. sequential:
[13:23:26.768]    - args: function (..., envir = parent.frame())
[13:23:26.768]    - tweaked: FALSE
[13:23:26.768]    - call: NULL
[13:23:26.768] plan(): nbrOfWorkers() = 1
[13:23:26.769] plan(): Setting new future strategy stack:
[13:23:26.769] List of future strategies:
[13:23:26.769] 1. sequential:
[13:23:26.769]    - args: function (..., envir = parent.frame())
[13:23:26.769]    - tweaked: FALSE
[13:23:26.769]    - call: plan(strategy)
[13:23:26.769] plan(): nbrOfWorkers() = 1
[13:23:26.770] SequentialFuture started (and completed)
[13:23:26.770] - Launch lazy future ... done
[13:23:26.770] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.770] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.770] Searching for globals...
[13:23:26.772] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:26.773] Searching for globals ... DONE
[13:23:26.773] Resolving globals: TRUE
[13:23:26.773] Resolving any globals that are futures ...
[13:23:26.773] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:26.773] Resolving any globals that are futures ... DONE
[13:23:26.773] Resolving futures part of globals (recursively) ...
[13:23:26.774] resolve() on list ...
[13:23:26.774]  recursive: 99
[13:23:26.774]  length: 1
[13:23:26.774]  elements: ‘x’
[13:23:26.774]  length: 0 (resolved future 1)
[13:23:26.774] resolve() on list ... DONE
[13:23:26.774] - globals: [1] ‘x’
[13:23:26.774] Resolving futures part of globals (recursively) ... DONE
[13:23:26.774] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.775] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.775] - globals: [1] ‘x’
[13:23:26.775] 
[13:23:26.775] getGlobalsAndPackages() ... DONE
[13:23:26.775] run() for ‘Future’ ...
[13:23:26.775] - state: ‘created’
[13:23:26.776] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:26.776] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:26.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:26.776]   - Field: ‘label’
[13:23:26.776]   - Field: ‘local’
[13:23:26.776]   - Field: ‘owner’
[13:23:26.776]   - Field: ‘envir’
[13:23:26.777]   - Field: ‘packages’
[13:23:26.777]   - Field: ‘gc’
[13:23:26.777]   - Field: ‘conditions’
[13:23:26.777]   - Field: ‘expr’
[13:23:26.777]   - Field: ‘uuid’
[13:23:26.777]   - Field: ‘seed’
[13:23:26.777]   - Field: ‘version’
[13:23:26.777]   - Field: ‘result’
[13:23:26.777]   - Field: ‘asynchronous’
[13:23:26.777]   - Field: ‘calls’
[13:23:26.777]   - Field: ‘globals’
[13:23:26.778]   - Field: ‘stdout’
[13:23:26.778]   - Field: ‘earlySignal’
[13:23:26.778]   - Field: ‘lazy’
[13:23:26.778]   - Field: ‘state’
[13:23:26.778] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:26.778] - Launch lazy future ...
[13:23:26.778] Packages needed by the future expression (n = 0): <none>
[13:23:26.778] Packages needed by future strategies (n = 0): <none>
[13:23:26.779] {
[13:23:26.779]     {
[13:23:26.779]         {
[13:23:26.779]             ...future.startTime <- base::Sys.time()
[13:23:26.779]             {
[13:23:26.779]                 {
[13:23:26.779]                   {
[13:23:26.779]                     base::local({
[13:23:26.779]                       has_future <- base::requireNamespace("future", 
[13:23:26.779]                         quietly = TRUE)
[13:23:26.779]                       if (has_future) {
[13:23:26.779]                         ns <- base::getNamespace("future")
[13:23:26.779]                         version <- ns[[".package"]][["version"]]
[13:23:26.779]                         if (is.null(version)) 
[13:23:26.779]                           version <- utils::packageVersion("future")
[13:23:26.779]                       }
[13:23:26.779]                       else {
[13:23:26.779]                         version <- NULL
[13:23:26.779]                       }
[13:23:26.779]                       if (!has_future || version < "1.8.0") {
[13:23:26.779]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.779]                           "", base::R.version$version.string), 
[13:23:26.779]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:26.779]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.779]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.779]                             "release", "version")], collapse = " "), 
[13:23:26.779]                           hostname = base::Sys.info()[["nodename"]])
[13:23:26.779]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.779]                           info)
[13:23:26.779]                         info <- base::paste(info, collapse = "; ")
[13:23:26.779]                         if (!has_future) {
[13:23:26.779]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.779]                             info)
[13:23:26.779]                         }
[13:23:26.779]                         else {
[13:23:26.779]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.779]                             info, version)
[13:23:26.779]                         }
[13:23:26.779]                         base::stop(msg)
[13:23:26.779]                       }
[13:23:26.779]                     })
[13:23:26.779]                   }
[13:23:26.779]                   options(future.plan = NULL)
[13:23:26.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.779]                 }
[13:23:26.779]                 ...future.workdir <- getwd()
[13:23:26.779]             }
[13:23:26.779]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.779]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.779]         }
[13:23:26.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.779]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.779]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.779]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.779]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.779]             base::names(...future.oldOptions))
[13:23:26.779]     }
[13:23:26.779]     if (FALSE) {
[13:23:26.779]     }
[13:23:26.779]     else {
[13:23:26.779]         if (TRUE) {
[13:23:26.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.779]                 open = "w")
[13:23:26.779]         }
[13:23:26.779]         else {
[13:23:26.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.779]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.779]         }
[13:23:26.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.779]             base::sink(type = "output", split = FALSE)
[13:23:26.779]             base::close(...future.stdout)
[13:23:26.779]         }, add = TRUE)
[13:23:26.779]     }
[13:23:26.779]     ...future.frame <- base::sys.nframe()
[13:23:26.779]     ...future.conditions <- base::list()
[13:23:26.779]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.779]     if (FALSE) {
[13:23:26.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.779]     }
[13:23:26.779]     ...future.result <- base::tryCatch({
[13:23:26.779]         base::withCallingHandlers({
[13:23:26.779]             ...future.value <- base::withVisible(base::local({
[13:23:26.779]                 x[["a"]] <- 1
[13:23:26.779]                 x
[13:23:26.779]             }))
[13:23:26.779]             future::FutureResult(value = ...future.value$value, 
[13:23:26.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.779]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.779]                     ...future.globalenv.names))
[13:23:26.779]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.779]         }, condition = base::local({
[13:23:26.779]             c <- base::c
[13:23:26.779]             inherits <- base::inherits
[13:23:26.779]             invokeRestart <- base::invokeRestart
[13:23:26.779]             length <- base::length
[13:23:26.779]             list <- base::list
[13:23:26.779]             seq.int <- base::seq.int
[13:23:26.779]             signalCondition <- base::signalCondition
[13:23:26.779]             sys.calls <- base::sys.calls
[13:23:26.779]             `[[` <- base::`[[`
[13:23:26.779]             `+` <- base::`+`
[13:23:26.779]             `<<-` <- base::`<<-`
[13:23:26.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.779]                   3L)]
[13:23:26.779]             }
[13:23:26.779]             function(cond) {
[13:23:26.779]                 is_error <- inherits(cond, "error")
[13:23:26.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.779]                   NULL)
[13:23:26.779]                 if (is_error) {
[13:23:26.779]                   sessionInformation <- function() {
[13:23:26.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.779]                       search = base::search(), system = base::Sys.info())
[13:23:26.779]                   }
[13:23:26.779]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.779]                     cond$call), session = sessionInformation(), 
[13:23:26.779]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.779]                   signalCondition(cond)
[13:23:26.779]                 }
[13:23:26.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.779]                 "immediateCondition"))) {
[13:23:26.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.779]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.779]                   if (TRUE && !signal) {
[13:23:26.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.779]                     {
[13:23:26.779]                       inherits <- base::inherits
[13:23:26.779]                       invokeRestart <- base::invokeRestart
[13:23:26.779]                       is.null <- base::is.null
[13:23:26.779]                       muffled <- FALSE
[13:23:26.779]                       if (inherits(cond, "message")) {
[13:23:26.779]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.779]                         if (muffled) 
[13:23:26.779]                           invokeRestart("muffleMessage")
[13:23:26.779]                       }
[13:23:26.779]                       else if (inherits(cond, "warning")) {
[13:23:26.779]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.779]                         if (muffled) 
[13:23:26.779]                           invokeRestart("muffleWarning")
[13:23:26.779]                       }
[13:23:26.779]                       else if (inherits(cond, "condition")) {
[13:23:26.779]                         if (!is.null(pattern)) {
[13:23:26.779]                           computeRestarts <- base::computeRestarts
[13:23:26.779]                           grepl <- base::grepl
[13:23:26.779]                           restarts <- computeRestarts(cond)
[13:23:26.779]                           for (restart in restarts) {
[13:23:26.779]                             name <- restart$name
[13:23:26.779]                             if (is.null(name)) 
[13:23:26.779]                               next
[13:23:26.779]                             if (!grepl(pattern, name)) 
[13:23:26.779]                               next
[13:23:26.779]                             invokeRestart(restart)
[13:23:26.779]                             muffled <- TRUE
[13:23:26.779]                             break
[13:23:26.779]                           }
[13:23:26.779]                         }
[13:23:26.779]                       }
[13:23:26.779]                       invisible(muffled)
[13:23:26.779]                     }
[13:23:26.779]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.779]                   }
[13:23:26.779]                 }
[13:23:26.779]                 else {
[13:23:26.779]                   if (TRUE) {
[13:23:26.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.779]                     {
[13:23:26.779]                       inherits <- base::inherits
[13:23:26.779]                       invokeRestart <- base::invokeRestart
[13:23:26.779]                       is.null <- base::is.null
[13:23:26.779]                       muffled <- FALSE
[13:23:26.779]                       if (inherits(cond, "message")) {
[13:23:26.779]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.779]                         if (muffled) 
[13:23:26.779]                           invokeRestart("muffleMessage")
[13:23:26.779]                       }
[13:23:26.779]                       else if (inherits(cond, "warning")) {
[13:23:26.779]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.779]                         if (muffled) 
[13:23:26.779]                           invokeRestart("muffleWarning")
[13:23:26.779]                       }
[13:23:26.779]                       else if (inherits(cond, "condition")) {
[13:23:26.779]                         if (!is.null(pattern)) {
[13:23:26.779]                           computeRestarts <- base::computeRestarts
[13:23:26.779]                           grepl <- base::grepl
[13:23:26.779]                           restarts <- computeRestarts(cond)
[13:23:26.779]                           for (restart in restarts) {
[13:23:26.779]                             name <- restart$name
[13:23:26.779]                             if (is.null(name)) 
[13:23:26.779]                               next
[13:23:26.779]                             if (!grepl(pattern, name)) 
[13:23:26.779]                               next
[13:23:26.779]                             invokeRestart(restart)
[13:23:26.779]                             muffled <- TRUE
[13:23:26.779]                             break
[13:23:26.779]                           }
[13:23:26.779]                         }
[13:23:26.779]                       }
[13:23:26.779]                       invisible(muffled)
[13:23:26.779]                     }
[13:23:26.779]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.779]                   }
[13:23:26.779]                 }
[13:23:26.779]             }
[13:23:26.779]         }))
[13:23:26.779]     }, error = function(ex) {
[13:23:26.779]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.779]                 ...future.rng), started = ...future.startTime, 
[13:23:26.779]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.779]             version = "1.8"), class = "FutureResult")
[13:23:26.779]     }, finally = {
[13:23:26.779]         if (!identical(...future.workdir, getwd())) 
[13:23:26.779]             setwd(...future.workdir)
[13:23:26.779]         {
[13:23:26.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.779]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.779]             }
[13:23:26.779]             base::options(...future.oldOptions)
[13:23:26.779]             if (.Platform$OS.type == "windows") {
[13:23:26.779]                 old_names <- names(...future.oldEnvVars)
[13:23:26.779]                 envs <- base::Sys.getenv()
[13:23:26.779]                 names <- names(envs)
[13:23:26.779]                 common <- intersect(names, old_names)
[13:23:26.779]                 added <- setdiff(names, old_names)
[13:23:26.779]                 removed <- setdiff(old_names, names)
[13:23:26.779]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.779]                   envs[common]]
[13:23:26.779]                 NAMES <- toupper(changed)
[13:23:26.779]                 args <- list()
[13:23:26.779]                 for (kk in seq_along(NAMES)) {
[13:23:26.779]                   name <- changed[[kk]]
[13:23:26.779]                   NAME <- NAMES[[kk]]
[13:23:26.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.779]                     next
[13:23:26.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.779]                 }
[13:23:26.779]                 NAMES <- toupper(added)
[13:23:26.779]                 for (kk in seq_along(NAMES)) {
[13:23:26.779]                   name <- added[[kk]]
[13:23:26.779]                   NAME <- NAMES[[kk]]
[13:23:26.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.779]                     next
[13:23:26.779]                   args[[name]] <- ""
[13:23:26.779]                 }
[13:23:26.779]                 NAMES <- toupper(removed)
[13:23:26.779]                 for (kk in seq_along(NAMES)) {
[13:23:26.779]                   name <- removed[[kk]]
[13:23:26.779]                   NAME <- NAMES[[kk]]
[13:23:26.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.779]                     next
[13:23:26.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.779]                 }
[13:23:26.779]                 if (length(args) > 0) 
[13:23:26.779]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.779]             }
[13:23:26.779]             else {
[13:23:26.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.779]             }
[13:23:26.779]             {
[13:23:26.779]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.779]                   0L) {
[13:23:26.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.779]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.779]                   base::options(opts)
[13:23:26.779]                 }
[13:23:26.779]                 {
[13:23:26.779]                   {
[13:23:26.779]                     NULL
[13:23:26.779]                     RNGkind("Mersenne-Twister")
[13:23:26.779]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:26.779]                       inherits = FALSE)
[13:23:26.779]                   }
[13:23:26.779]                   options(future.plan = NULL)
[13:23:26.779]                   if (is.na(NA_character_)) 
[13:23:26.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.779]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:26.779]                   {
[13:23:26.779]                     future <- SequentialFuture(..., envir = envir)
[13:23:26.779]                     if (!future$lazy) 
[13:23:26.779]                       future <- run(future)
[13:23:26.779]                     invisible(future)
[13:23:26.779]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.779]                 }
[13:23:26.779]             }
[13:23:26.779]         }
[13:23:26.779]     })
[13:23:26.779]     if (TRUE) {
[13:23:26.779]         base::sink(type = "output", split = FALSE)
[13:23:26.779]         if (TRUE) {
[13:23:26.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.779]         }
[13:23:26.779]         else {
[13:23:26.779]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.779]         }
[13:23:26.779]         base::close(...future.stdout)
[13:23:26.779]         ...future.stdout <- NULL
[13:23:26.779]     }
[13:23:26.779]     ...future.result$conditions <- ...future.conditions
[13:23:26.779]     ...future.result$finished <- base::Sys.time()
[13:23:26.779]     ...future.result
[13:23:26.779] }
[13:23:26.780] assign_globals() ...
[13:23:26.781] List of 1
[13:23:26.781]  $ x: list()
[13:23:26.781]  - attr(*, "where")=List of 1
[13:23:26.781]   ..$ x:<environment: R_EmptyEnv> 
[13:23:26.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.781]  - attr(*, "resolved")= logi TRUE
[13:23:26.781]  - attr(*, "total_size")= num 0
[13:23:26.781]  - attr(*, "already-done")= logi TRUE
[13:23:26.783] - copied ‘x’ to environment
[13:23:26.783] assign_globals() ... done
[13:23:26.783] plan(): Setting new future strategy stack:
[13:23:26.783] List of future strategies:
[13:23:26.783] 1. sequential:
[13:23:26.783]    - args: function (..., envir = parent.frame())
[13:23:26.783]    - tweaked: FALSE
[13:23:26.783]    - call: NULL
[13:23:26.784] plan(): nbrOfWorkers() = 1
[13:23:26.785] plan(): Setting new future strategy stack:
[13:23:26.785] List of future strategies:
[13:23:26.785] 1. sequential:
[13:23:26.785]    - args: function (..., envir = parent.frame())
[13:23:26.785]    - tweaked: FALSE
[13:23:26.785]    - call: plan(strategy)
[13:23:26.785] plan(): nbrOfWorkers() = 1
[13:23:26.785] SequentialFuture started (and completed)
[13:23:26.785] - Launch lazy future ... done
[13:23:26.786] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.786] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.786] Searching for globals...
[13:23:26.790] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:26.790] Searching for globals ... DONE
[13:23:26.790] Resolving globals: TRUE
[13:23:26.790] Resolving any globals that are futures ...
[13:23:26.790] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:26.791] Resolving any globals that are futures ... DONE
[13:23:26.791] Resolving futures part of globals (recursively) ...
[13:23:26.791] resolve() on list ...
[13:23:26.791]  recursive: 99
[13:23:26.791]  length: 1
[13:23:26.791]  elements: ‘x’
[13:23:26.792]  length: 0 (resolved future 1)
[13:23:26.792] resolve() on list ... DONE
[13:23:26.792] - globals: [1] ‘x’
[13:23:26.792] Resolving futures part of globals (recursively) ... DONE
[13:23:26.792] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.792] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.793] - globals: [1] ‘x’
[13:23:26.793] 
[13:23:26.793] getGlobalsAndPackages() ... DONE
[13:23:26.793] run() for ‘Future’ ...
[13:23:26.793] - state: ‘created’
[13:23:26.793] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:26.794] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:26.794] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:26.794]   - Field: ‘label’
[13:23:26.794]   - Field: ‘local’
[13:23:26.794]   - Field: ‘owner’
[13:23:26.794]   - Field: ‘envir’
[13:23:26.794]   - Field: ‘packages’
[13:23:26.794]   - Field: ‘gc’
[13:23:26.794]   - Field: ‘conditions’
[13:23:26.794]   - Field: ‘expr’
[13:23:26.795]   - Field: ‘uuid’
[13:23:26.795]   - Field: ‘seed’
[13:23:26.795]   - Field: ‘version’
[13:23:26.795]   - Field: ‘result’
[13:23:26.795]   - Field: ‘asynchronous’
[13:23:26.795]   - Field: ‘calls’
[13:23:26.795]   - Field: ‘globals’
[13:23:26.795]   - Field: ‘stdout’
[13:23:26.795]   - Field: ‘earlySignal’
[13:23:26.795]   - Field: ‘lazy’
[13:23:26.795]   - Field: ‘state’
[13:23:26.796] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:26.796] - Launch lazy future ...
[13:23:26.796] Packages needed by the future expression (n = 0): <none>
[13:23:26.796] Packages needed by future strategies (n = 0): <none>
[13:23:26.796] {
[13:23:26.796]     {
[13:23:26.796]         {
[13:23:26.796]             ...future.startTime <- base::Sys.time()
[13:23:26.796]             {
[13:23:26.796]                 {
[13:23:26.796]                   {
[13:23:26.796]                     base::local({
[13:23:26.796]                       has_future <- base::requireNamespace("future", 
[13:23:26.796]                         quietly = TRUE)
[13:23:26.796]                       if (has_future) {
[13:23:26.796]                         ns <- base::getNamespace("future")
[13:23:26.796]                         version <- ns[[".package"]][["version"]]
[13:23:26.796]                         if (is.null(version)) 
[13:23:26.796]                           version <- utils::packageVersion("future")
[13:23:26.796]                       }
[13:23:26.796]                       else {
[13:23:26.796]                         version <- NULL
[13:23:26.796]                       }
[13:23:26.796]                       if (!has_future || version < "1.8.0") {
[13:23:26.796]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.796]                           "", base::R.version$version.string), 
[13:23:26.796]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:26.796]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.796]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.796]                             "release", "version")], collapse = " "), 
[13:23:26.796]                           hostname = base::Sys.info()[["nodename"]])
[13:23:26.796]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.796]                           info)
[13:23:26.796]                         info <- base::paste(info, collapse = "; ")
[13:23:26.796]                         if (!has_future) {
[13:23:26.796]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.796]                             info)
[13:23:26.796]                         }
[13:23:26.796]                         else {
[13:23:26.796]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.796]                             info, version)
[13:23:26.796]                         }
[13:23:26.796]                         base::stop(msg)
[13:23:26.796]                       }
[13:23:26.796]                     })
[13:23:26.796]                   }
[13:23:26.796]                   options(future.plan = NULL)
[13:23:26.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.796]                 }
[13:23:26.796]                 ...future.workdir <- getwd()
[13:23:26.796]             }
[13:23:26.796]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.796]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.796]         }
[13:23:26.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.796]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.796]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.796]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.796]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.796]             base::names(...future.oldOptions))
[13:23:26.796]     }
[13:23:26.796]     if (FALSE) {
[13:23:26.796]     }
[13:23:26.796]     else {
[13:23:26.796]         if (TRUE) {
[13:23:26.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.796]                 open = "w")
[13:23:26.796]         }
[13:23:26.796]         else {
[13:23:26.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.796]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.796]         }
[13:23:26.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.796]             base::sink(type = "output", split = FALSE)
[13:23:26.796]             base::close(...future.stdout)
[13:23:26.796]         }, add = TRUE)
[13:23:26.796]     }
[13:23:26.796]     ...future.frame <- base::sys.nframe()
[13:23:26.796]     ...future.conditions <- base::list()
[13:23:26.796]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.796]     if (FALSE) {
[13:23:26.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.796]     }
[13:23:26.796]     ...future.result <- base::tryCatch({
[13:23:26.796]         base::withCallingHandlers({
[13:23:26.796]             ...future.value <- base::withVisible(base::local({
[13:23:26.796]                 x[["a"]] <- 1
[13:23:26.796]                 x
[13:23:26.796]             }))
[13:23:26.796]             future::FutureResult(value = ...future.value$value, 
[13:23:26.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.796]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.796]                     ...future.globalenv.names))
[13:23:26.796]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.796]         }, condition = base::local({
[13:23:26.796]             c <- base::c
[13:23:26.796]             inherits <- base::inherits
[13:23:26.796]             invokeRestart <- base::invokeRestart
[13:23:26.796]             length <- base::length
[13:23:26.796]             list <- base::list
[13:23:26.796]             seq.int <- base::seq.int
[13:23:26.796]             signalCondition <- base::signalCondition
[13:23:26.796]             sys.calls <- base::sys.calls
[13:23:26.796]             `[[` <- base::`[[`
[13:23:26.796]             `+` <- base::`+`
[13:23:26.796]             `<<-` <- base::`<<-`
[13:23:26.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.796]                   3L)]
[13:23:26.796]             }
[13:23:26.796]             function(cond) {
[13:23:26.796]                 is_error <- inherits(cond, "error")
[13:23:26.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.796]                   NULL)
[13:23:26.796]                 if (is_error) {
[13:23:26.796]                   sessionInformation <- function() {
[13:23:26.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.796]                       search = base::search(), system = base::Sys.info())
[13:23:26.796]                   }
[13:23:26.796]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.796]                     cond$call), session = sessionInformation(), 
[13:23:26.796]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.796]                   signalCondition(cond)
[13:23:26.796]                 }
[13:23:26.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.796]                 "immediateCondition"))) {
[13:23:26.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.796]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.796]                   if (TRUE && !signal) {
[13:23:26.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.796]                     {
[13:23:26.796]                       inherits <- base::inherits
[13:23:26.796]                       invokeRestart <- base::invokeRestart
[13:23:26.796]                       is.null <- base::is.null
[13:23:26.796]                       muffled <- FALSE
[13:23:26.796]                       if (inherits(cond, "message")) {
[13:23:26.796]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.796]                         if (muffled) 
[13:23:26.796]                           invokeRestart("muffleMessage")
[13:23:26.796]                       }
[13:23:26.796]                       else if (inherits(cond, "warning")) {
[13:23:26.796]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.796]                         if (muffled) 
[13:23:26.796]                           invokeRestart("muffleWarning")
[13:23:26.796]                       }
[13:23:26.796]                       else if (inherits(cond, "condition")) {
[13:23:26.796]                         if (!is.null(pattern)) {
[13:23:26.796]                           computeRestarts <- base::computeRestarts
[13:23:26.796]                           grepl <- base::grepl
[13:23:26.796]                           restarts <- computeRestarts(cond)
[13:23:26.796]                           for (restart in restarts) {
[13:23:26.796]                             name <- restart$name
[13:23:26.796]                             if (is.null(name)) 
[13:23:26.796]                               next
[13:23:26.796]                             if (!grepl(pattern, name)) 
[13:23:26.796]                               next
[13:23:26.796]                             invokeRestart(restart)
[13:23:26.796]                             muffled <- TRUE
[13:23:26.796]                             break
[13:23:26.796]                           }
[13:23:26.796]                         }
[13:23:26.796]                       }
[13:23:26.796]                       invisible(muffled)
[13:23:26.796]                     }
[13:23:26.796]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.796]                   }
[13:23:26.796]                 }
[13:23:26.796]                 else {
[13:23:26.796]                   if (TRUE) {
[13:23:26.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.796]                     {
[13:23:26.796]                       inherits <- base::inherits
[13:23:26.796]                       invokeRestart <- base::invokeRestart
[13:23:26.796]                       is.null <- base::is.null
[13:23:26.796]                       muffled <- FALSE
[13:23:26.796]                       if (inherits(cond, "message")) {
[13:23:26.796]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.796]                         if (muffled) 
[13:23:26.796]                           invokeRestart("muffleMessage")
[13:23:26.796]                       }
[13:23:26.796]                       else if (inherits(cond, "warning")) {
[13:23:26.796]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.796]                         if (muffled) 
[13:23:26.796]                           invokeRestart("muffleWarning")
[13:23:26.796]                       }
[13:23:26.796]                       else if (inherits(cond, "condition")) {
[13:23:26.796]                         if (!is.null(pattern)) {
[13:23:26.796]                           computeRestarts <- base::computeRestarts
[13:23:26.796]                           grepl <- base::grepl
[13:23:26.796]                           restarts <- computeRestarts(cond)
[13:23:26.796]                           for (restart in restarts) {
[13:23:26.796]                             name <- restart$name
[13:23:26.796]                             if (is.null(name)) 
[13:23:26.796]                               next
[13:23:26.796]                             if (!grepl(pattern, name)) 
[13:23:26.796]                               next
[13:23:26.796]                             invokeRestart(restart)
[13:23:26.796]                             muffled <- TRUE
[13:23:26.796]                             break
[13:23:26.796]                           }
[13:23:26.796]                         }
[13:23:26.796]                       }
[13:23:26.796]                       invisible(muffled)
[13:23:26.796]                     }
[13:23:26.796]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.796]                   }
[13:23:26.796]                 }
[13:23:26.796]             }
[13:23:26.796]         }))
[13:23:26.796]     }, error = function(ex) {
[13:23:26.796]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.796]                 ...future.rng), started = ...future.startTime, 
[13:23:26.796]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.796]             version = "1.8"), class = "FutureResult")
[13:23:26.796]     }, finally = {
[13:23:26.796]         if (!identical(...future.workdir, getwd())) 
[13:23:26.796]             setwd(...future.workdir)
[13:23:26.796]         {
[13:23:26.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.796]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.796]             }
[13:23:26.796]             base::options(...future.oldOptions)
[13:23:26.796]             if (.Platform$OS.type == "windows") {
[13:23:26.796]                 old_names <- names(...future.oldEnvVars)
[13:23:26.796]                 envs <- base::Sys.getenv()
[13:23:26.796]                 names <- names(envs)
[13:23:26.796]                 common <- intersect(names, old_names)
[13:23:26.796]                 added <- setdiff(names, old_names)
[13:23:26.796]                 removed <- setdiff(old_names, names)
[13:23:26.796]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.796]                   envs[common]]
[13:23:26.796]                 NAMES <- toupper(changed)
[13:23:26.796]                 args <- list()
[13:23:26.796]                 for (kk in seq_along(NAMES)) {
[13:23:26.796]                   name <- changed[[kk]]
[13:23:26.796]                   NAME <- NAMES[[kk]]
[13:23:26.796]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.796]                     next
[13:23:26.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.796]                 }
[13:23:26.796]                 NAMES <- toupper(added)
[13:23:26.796]                 for (kk in seq_along(NAMES)) {
[13:23:26.796]                   name <- added[[kk]]
[13:23:26.796]                   NAME <- NAMES[[kk]]
[13:23:26.796]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.796]                     next
[13:23:26.796]                   args[[name]] <- ""
[13:23:26.796]                 }
[13:23:26.796]                 NAMES <- toupper(removed)
[13:23:26.796]                 for (kk in seq_along(NAMES)) {
[13:23:26.796]                   name <- removed[[kk]]
[13:23:26.796]                   NAME <- NAMES[[kk]]
[13:23:26.796]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.796]                     next
[13:23:26.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.796]                 }
[13:23:26.796]                 if (length(args) > 0) 
[13:23:26.796]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.796]             }
[13:23:26.796]             else {
[13:23:26.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.796]             }
[13:23:26.796]             {
[13:23:26.796]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.796]                   0L) {
[13:23:26.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.796]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.796]                   base::options(opts)
[13:23:26.796]                 }
[13:23:26.796]                 {
[13:23:26.796]                   {
[13:23:26.796]                     NULL
[13:23:26.796]                     RNGkind("Mersenne-Twister")
[13:23:26.796]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:26.796]                       inherits = FALSE)
[13:23:26.796]                   }
[13:23:26.796]                   options(future.plan = NULL)
[13:23:26.796]                   if (is.na(NA_character_)) 
[13:23:26.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.796]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:26.796]                   {
[13:23:26.796]                     future <- SequentialFuture(..., envir = envir)
[13:23:26.796]                     if (!future$lazy) 
[13:23:26.796]                       future <- run(future)
[13:23:26.796]                     invisible(future)
[13:23:26.796]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.796]                 }
[13:23:26.796]             }
[13:23:26.796]         }
[13:23:26.796]     })
[13:23:26.796]     if (TRUE) {
[13:23:26.796]         base::sink(type = "output", split = FALSE)
[13:23:26.796]         if (TRUE) {
[13:23:26.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.796]         }
[13:23:26.796]         else {
[13:23:26.796]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.796]         }
[13:23:26.796]         base::close(...future.stdout)
[13:23:26.796]         ...future.stdout <- NULL
[13:23:26.796]     }
[13:23:26.796]     ...future.result$conditions <- ...future.conditions
[13:23:26.796]     ...future.result$finished <- base::Sys.time()
[13:23:26.796]     ...future.result
[13:23:26.796] }
[13:23:26.798] assign_globals() ...
[13:23:26.798] List of 1
[13:23:26.798]  $ x: list()
[13:23:26.798]  - attr(*, "where")=List of 1
[13:23:26.798]   ..$ x:<environment: R_EmptyEnv> 
[13:23:26.798]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.798]  - attr(*, "resolved")= logi TRUE
[13:23:26.798]  - attr(*, "total_size")= num 0
[13:23:26.798]  - attr(*, "already-done")= logi TRUE
[13:23:26.801] - copied ‘x’ to environment
[13:23:26.801] assign_globals() ... done
[13:23:26.801] plan(): Setting new future strategy stack:
[13:23:26.801] List of future strategies:
[13:23:26.801] 1. sequential:
[13:23:26.801]    - args: function (..., envir = parent.frame())
[13:23:26.801]    - tweaked: FALSE
[13:23:26.801]    - call: NULL
[13:23:26.802] plan(): nbrOfWorkers() = 1
[13:23:26.802] plan(): Setting new future strategy stack:
[13:23:26.803] List of future strategies:
[13:23:26.803] 1. sequential:
[13:23:26.803]    - args: function (..., envir = parent.frame())
[13:23:26.803]    - tweaked: FALSE
[13:23:26.803]    - call: plan(strategy)
[13:23:26.803] plan(): nbrOfWorkers() = 1
[13:23:26.803] SequentialFuture started (and completed)
[13:23:26.803] - Launch lazy future ... done
[13:23:26.803] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.804] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.804] Searching for globals...
[13:23:26.806] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:26.806] Searching for globals ... DONE
[13:23:26.806] Resolving globals: TRUE
[13:23:26.806] Resolving any globals that are futures ...
[13:23:26.806] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:26.807] Resolving any globals that are futures ... DONE
[13:23:26.807] Resolving futures part of globals (recursively) ...
[13:23:26.807] resolve() on list ...
[13:23:26.807]  recursive: 99
[13:23:26.807]  length: 1
[13:23:26.807]  elements: ‘x’
[13:23:26.808]  length: 0 (resolved future 1)
[13:23:26.808] resolve() on list ... DONE
[13:23:26.808] - globals: [1] ‘x’
[13:23:26.808] Resolving futures part of globals (recursively) ... DONE
[13:23:26.808] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.808] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.809] - globals: [1] ‘x’
[13:23:26.809] 
[13:23:26.809] getGlobalsAndPackages() ... DONE
[13:23:26.809] run() for ‘Future’ ...
[13:23:26.809] - state: ‘created’
[13:23:26.809] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:26.810] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:26.810] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:26.810]   - Field: ‘label’
[13:23:26.810]   - Field: ‘local’
[13:23:26.810]   - Field: ‘owner’
[13:23:26.810]   - Field: ‘envir’
[13:23:26.810]   - Field: ‘packages’
[13:23:26.810]   - Field: ‘gc’
[13:23:26.810]   - Field: ‘conditions’
[13:23:26.810]   - Field: ‘expr’
[13:23:26.811]   - Field: ‘uuid’
[13:23:26.811]   - Field: ‘seed’
[13:23:26.811]   - Field: ‘version’
[13:23:26.811]   - Field: ‘result’
[13:23:26.811]   - Field: ‘asynchronous’
[13:23:26.811]   - Field: ‘calls’
[13:23:26.811]   - Field: ‘globals’
[13:23:26.811]   - Field: ‘stdout’
[13:23:26.811]   - Field: ‘earlySignal’
[13:23:26.811]   - Field: ‘lazy’
[13:23:26.811]   - Field: ‘state’
[13:23:26.812] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:26.812] - Launch lazy future ...
[13:23:26.812] Packages needed by the future expression (n = 0): <none>
[13:23:26.812] Packages needed by future strategies (n = 0): <none>
[13:23:26.812] {
[13:23:26.812]     {
[13:23:26.812]         {
[13:23:26.812]             ...future.startTime <- base::Sys.time()
[13:23:26.812]             {
[13:23:26.812]                 {
[13:23:26.812]                   {
[13:23:26.812]                     base::local({
[13:23:26.812]                       has_future <- base::requireNamespace("future", 
[13:23:26.812]                         quietly = TRUE)
[13:23:26.812]                       if (has_future) {
[13:23:26.812]                         ns <- base::getNamespace("future")
[13:23:26.812]                         version <- ns[[".package"]][["version"]]
[13:23:26.812]                         if (is.null(version)) 
[13:23:26.812]                           version <- utils::packageVersion("future")
[13:23:26.812]                       }
[13:23:26.812]                       else {
[13:23:26.812]                         version <- NULL
[13:23:26.812]                       }
[13:23:26.812]                       if (!has_future || version < "1.8.0") {
[13:23:26.812]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.812]                           "", base::R.version$version.string), 
[13:23:26.812]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:26.812]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.812]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.812]                             "release", "version")], collapse = " "), 
[13:23:26.812]                           hostname = base::Sys.info()[["nodename"]])
[13:23:26.812]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.812]                           info)
[13:23:26.812]                         info <- base::paste(info, collapse = "; ")
[13:23:26.812]                         if (!has_future) {
[13:23:26.812]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.812]                             info)
[13:23:26.812]                         }
[13:23:26.812]                         else {
[13:23:26.812]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.812]                             info, version)
[13:23:26.812]                         }
[13:23:26.812]                         base::stop(msg)
[13:23:26.812]                       }
[13:23:26.812]                     })
[13:23:26.812]                   }
[13:23:26.812]                   options(future.plan = NULL)
[13:23:26.812]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.812]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.812]                 }
[13:23:26.812]                 ...future.workdir <- getwd()
[13:23:26.812]             }
[13:23:26.812]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.812]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.812]         }
[13:23:26.812]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.812]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.812]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.812]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.812]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.812]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.812]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.812]             base::names(...future.oldOptions))
[13:23:26.812]     }
[13:23:26.812]     if (FALSE) {
[13:23:26.812]     }
[13:23:26.812]     else {
[13:23:26.812]         if (TRUE) {
[13:23:26.812]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.812]                 open = "w")
[13:23:26.812]         }
[13:23:26.812]         else {
[13:23:26.812]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.812]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.812]         }
[13:23:26.812]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.812]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.812]             base::sink(type = "output", split = FALSE)
[13:23:26.812]             base::close(...future.stdout)
[13:23:26.812]         }, add = TRUE)
[13:23:26.812]     }
[13:23:26.812]     ...future.frame <- base::sys.nframe()
[13:23:26.812]     ...future.conditions <- base::list()
[13:23:26.812]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.812]     if (FALSE) {
[13:23:26.812]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.812]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.812]     }
[13:23:26.812]     ...future.result <- base::tryCatch({
[13:23:26.812]         base::withCallingHandlers({
[13:23:26.812]             ...future.value <- base::withVisible(base::local({
[13:23:26.812]                 x[["a"]] <- 1
[13:23:26.812]                 x
[13:23:26.812]             }))
[13:23:26.812]             future::FutureResult(value = ...future.value$value, 
[13:23:26.812]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.812]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.812]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.812]                     ...future.globalenv.names))
[13:23:26.812]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.812]         }, condition = base::local({
[13:23:26.812]             c <- base::c
[13:23:26.812]             inherits <- base::inherits
[13:23:26.812]             invokeRestart <- base::invokeRestart
[13:23:26.812]             length <- base::length
[13:23:26.812]             list <- base::list
[13:23:26.812]             seq.int <- base::seq.int
[13:23:26.812]             signalCondition <- base::signalCondition
[13:23:26.812]             sys.calls <- base::sys.calls
[13:23:26.812]             `[[` <- base::`[[`
[13:23:26.812]             `+` <- base::`+`
[13:23:26.812]             `<<-` <- base::`<<-`
[13:23:26.812]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.812]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.812]                   3L)]
[13:23:26.812]             }
[13:23:26.812]             function(cond) {
[13:23:26.812]                 is_error <- inherits(cond, "error")
[13:23:26.812]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.812]                   NULL)
[13:23:26.812]                 if (is_error) {
[13:23:26.812]                   sessionInformation <- function() {
[13:23:26.812]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.812]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.812]                       search = base::search(), system = base::Sys.info())
[13:23:26.812]                   }
[13:23:26.812]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.812]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.812]                     cond$call), session = sessionInformation(), 
[13:23:26.812]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.812]                   signalCondition(cond)
[13:23:26.812]                 }
[13:23:26.812]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.812]                 "immediateCondition"))) {
[13:23:26.812]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.812]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.812]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.812]                   if (TRUE && !signal) {
[13:23:26.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.812]                     {
[13:23:26.812]                       inherits <- base::inherits
[13:23:26.812]                       invokeRestart <- base::invokeRestart
[13:23:26.812]                       is.null <- base::is.null
[13:23:26.812]                       muffled <- FALSE
[13:23:26.812]                       if (inherits(cond, "message")) {
[13:23:26.812]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.812]                         if (muffled) 
[13:23:26.812]                           invokeRestart("muffleMessage")
[13:23:26.812]                       }
[13:23:26.812]                       else if (inherits(cond, "warning")) {
[13:23:26.812]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.812]                         if (muffled) 
[13:23:26.812]                           invokeRestart("muffleWarning")
[13:23:26.812]                       }
[13:23:26.812]                       else if (inherits(cond, "condition")) {
[13:23:26.812]                         if (!is.null(pattern)) {
[13:23:26.812]                           computeRestarts <- base::computeRestarts
[13:23:26.812]                           grepl <- base::grepl
[13:23:26.812]                           restarts <- computeRestarts(cond)
[13:23:26.812]                           for (restart in restarts) {
[13:23:26.812]                             name <- restart$name
[13:23:26.812]                             if (is.null(name)) 
[13:23:26.812]                               next
[13:23:26.812]                             if (!grepl(pattern, name)) 
[13:23:26.812]                               next
[13:23:26.812]                             invokeRestart(restart)
[13:23:26.812]                             muffled <- TRUE
[13:23:26.812]                             break
[13:23:26.812]                           }
[13:23:26.812]                         }
[13:23:26.812]                       }
[13:23:26.812]                       invisible(muffled)
[13:23:26.812]                     }
[13:23:26.812]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.812]                   }
[13:23:26.812]                 }
[13:23:26.812]                 else {
[13:23:26.812]                   if (TRUE) {
[13:23:26.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.812]                     {
[13:23:26.812]                       inherits <- base::inherits
[13:23:26.812]                       invokeRestart <- base::invokeRestart
[13:23:26.812]                       is.null <- base::is.null
[13:23:26.812]                       muffled <- FALSE
[13:23:26.812]                       if (inherits(cond, "message")) {
[13:23:26.812]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.812]                         if (muffled) 
[13:23:26.812]                           invokeRestart("muffleMessage")
[13:23:26.812]                       }
[13:23:26.812]                       else if (inherits(cond, "warning")) {
[13:23:26.812]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.812]                         if (muffled) 
[13:23:26.812]                           invokeRestart("muffleWarning")
[13:23:26.812]                       }
[13:23:26.812]                       else if (inherits(cond, "condition")) {
[13:23:26.812]                         if (!is.null(pattern)) {
[13:23:26.812]                           computeRestarts <- base::computeRestarts
[13:23:26.812]                           grepl <- base::grepl
[13:23:26.812]                           restarts <- computeRestarts(cond)
[13:23:26.812]                           for (restart in restarts) {
[13:23:26.812]                             name <- restart$name
[13:23:26.812]                             if (is.null(name)) 
[13:23:26.812]                               next
[13:23:26.812]                             if (!grepl(pattern, name)) 
[13:23:26.812]                               next
[13:23:26.812]                             invokeRestart(restart)
[13:23:26.812]                             muffled <- TRUE
[13:23:26.812]                             break
[13:23:26.812]                           }
[13:23:26.812]                         }
[13:23:26.812]                       }
[13:23:26.812]                       invisible(muffled)
[13:23:26.812]                     }
[13:23:26.812]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.812]                   }
[13:23:26.812]                 }
[13:23:26.812]             }
[13:23:26.812]         }))
[13:23:26.812]     }, error = function(ex) {
[13:23:26.812]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.812]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.812]                 ...future.rng), started = ...future.startTime, 
[13:23:26.812]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.812]             version = "1.8"), class = "FutureResult")
[13:23:26.812]     }, finally = {
[13:23:26.812]         if (!identical(...future.workdir, getwd())) 
[13:23:26.812]             setwd(...future.workdir)
[13:23:26.812]         {
[13:23:26.812]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.812]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.812]             }
[13:23:26.812]             base::options(...future.oldOptions)
[13:23:26.812]             if (.Platform$OS.type == "windows") {
[13:23:26.812]                 old_names <- names(...future.oldEnvVars)
[13:23:26.812]                 envs <- base::Sys.getenv()
[13:23:26.812]                 names <- names(envs)
[13:23:26.812]                 common <- intersect(names, old_names)
[13:23:26.812]                 added <- setdiff(names, old_names)
[13:23:26.812]                 removed <- setdiff(old_names, names)
[13:23:26.812]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.812]                   envs[common]]
[13:23:26.812]                 NAMES <- toupper(changed)
[13:23:26.812]                 args <- list()
[13:23:26.812]                 for (kk in seq_along(NAMES)) {
[13:23:26.812]                   name <- changed[[kk]]
[13:23:26.812]                   NAME <- NAMES[[kk]]
[13:23:26.812]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.812]                     next
[13:23:26.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.812]                 }
[13:23:26.812]                 NAMES <- toupper(added)
[13:23:26.812]                 for (kk in seq_along(NAMES)) {
[13:23:26.812]                   name <- added[[kk]]
[13:23:26.812]                   NAME <- NAMES[[kk]]
[13:23:26.812]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.812]                     next
[13:23:26.812]                   args[[name]] <- ""
[13:23:26.812]                 }
[13:23:26.812]                 NAMES <- toupper(removed)
[13:23:26.812]                 for (kk in seq_along(NAMES)) {
[13:23:26.812]                   name <- removed[[kk]]
[13:23:26.812]                   NAME <- NAMES[[kk]]
[13:23:26.812]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.812]                     next
[13:23:26.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.812]                 }
[13:23:26.812]                 if (length(args) > 0) 
[13:23:26.812]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.812]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.812]             }
[13:23:26.812]             else {
[13:23:26.812]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.812]             }
[13:23:26.812]             {
[13:23:26.812]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.812]                   0L) {
[13:23:26.812]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.812]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.812]                   base::options(opts)
[13:23:26.812]                 }
[13:23:26.812]                 {
[13:23:26.812]                   {
[13:23:26.812]                     NULL
[13:23:26.812]                     RNGkind("Mersenne-Twister")
[13:23:26.812]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:26.812]                       inherits = FALSE)
[13:23:26.812]                   }
[13:23:26.812]                   options(future.plan = NULL)
[13:23:26.812]                   if (is.na(NA_character_)) 
[13:23:26.812]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.812]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.812]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:26.812]                   {
[13:23:26.812]                     future <- SequentialFuture(..., envir = envir)
[13:23:26.812]                     if (!future$lazy) 
[13:23:26.812]                       future <- run(future)
[13:23:26.812]                     invisible(future)
[13:23:26.812]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.812]                 }
[13:23:26.812]             }
[13:23:26.812]         }
[13:23:26.812]     })
[13:23:26.812]     if (TRUE) {
[13:23:26.812]         base::sink(type = "output", split = FALSE)
[13:23:26.812]         if (TRUE) {
[13:23:26.812]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.812]         }
[13:23:26.812]         else {
[13:23:26.812]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.812]         }
[13:23:26.812]         base::close(...future.stdout)
[13:23:26.812]         ...future.stdout <- NULL
[13:23:26.812]     }
[13:23:26.812]     ...future.result$conditions <- ...future.conditions
[13:23:26.812]     ...future.result$finished <- base::Sys.time()
[13:23:26.812]     ...future.result
[13:23:26.812] }
[13:23:26.814] assign_globals() ...
[13:23:26.814] List of 1
[13:23:26.814]  $ x: list()
[13:23:26.814]  - attr(*, "where")=List of 1
[13:23:26.814]   ..$ x:<environment: R_EmptyEnv> 
[13:23:26.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.814]  - attr(*, "resolved")= logi TRUE
[13:23:26.814]  - attr(*, "total_size")= num 0
[13:23:26.814]  - attr(*, "already-done")= logi TRUE
[13:23:26.817] - copied ‘x’ to environment
[13:23:26.819] assign_globals() ... done
[13:23:26.819] plan(): Setting new future strategy stack:
[13:23:26.819] List of future strategies:
[13:23:26.819] 1. sequential:
[13:23:26.819]    - args: function (..., envir = parent.frame())
[13:23:26.819]    - tweaked: FALSE
[13:23:26.819]    - call: NULL
[13:23:26.820] plan(): nbrOfWorkers() = 1
[13:23:26.820] plan(): Setting new future strategy stack:
[13:23:26.820] List of future strategies:
[13:23:26.820] 1. sequential:
[13:23:26.820]    - args: function (..., envir = parent.frame())
[13:23:26.820]    - tweaked: FALSE
[13:23:26.820]    - call: plan(strategy)
[13:23:26.821] plan(): nbrOfWorkers() = 1
[13:23:26.821] SequentialFuture started (and completed)
[13:23:26.821] - Launch lazy future ... done
[13:23:26.821] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.822] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.822] Searching for globals...
[13:23:26.824] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:26.824] Searching for globals ... DONE
[13:23:26.824] Resolving globals: TRUE
[13:23:26.824] Resolving any globals that are futures ...
[13:23:26.824] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:26.825] Resolving any globals that are futures ... DONE
[13:23:26.825] Resolving futures part of globals (recursively) ...
[13:23:26.825] resolve() on list ...
[13:23:26.825]  recursive: 99
[13:23:26.825]  length: 1
[13:23:26.825]  elements: ‘x’
[13:23:26.826]  length: 0 (resolved future 1)
[13:23:26.826] resolve() on list ... DONE
[13:23:26.826] - globals: [1] ‘x’
[13:23:26.826] Resolving futures part of globals (recursively) ... DONE
[13:23:26.826] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.826] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.826] - globals: [1] ‘x’
[13:23:26.827] 
[13:23:26.827] getGlobalsAndPackages() ... DONE
[13:23:26.827] run() for ‘Future’ ...
[13:23:26.827] - state: ‘created’
[13:23:26.827] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:26.827] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:26.828] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:26.828]   - Field: ‘label’
[13:23:26.828]   - Field: ‘local’
[13:23:26.828]   - Field: ‘owner’
[13:23:26.828]   - Field: ‘envir’
[13:23:26.828]   - Field: ‘packages’
[13:23:26.828]   - Field: ‘gc’
[13:23:26.828]   - Field: ‘conditions’
[13:23:26.828]   - Field: ‘expr’
[13:23:26.828]   - Field: ‘uuid’
[13:23:26.829]   - Field: ‘seed’
[13:23:26.829]   - Field: ‘version’
[13:23:26.829]   - Field: ‘result’
[13:23:26.829]   - Field: ‘asynchronous’
[13:23:26.829]   - Field: ‘calls’
[13:23:26.829]   - Field: ‘globals’
[13:23:26.829]   - Field: ‘stdout’
[13:23:26.829]   - Field: ‘earlySignal’
[13:23:26.829]   - Field: ‘lazy’
[13:23:26.829]   - Field: ‘state’
[13:23:26.830] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:26.830] - Launch lazy future ...
[13:23:26.830] Packages needed by the future expression (n = 0): <none>
[13:23:26.830] Packages needed by future strategies (n = 0): <none>
[13:23:26.830] {
[13:23:26.830]     {
[13:23:26.830]         {
[13:23:26.830]             ...future.startTime <- base::Sys.time()
[13:23:26.830]             {
[13:23:26.830]                 {
[13:23:26.830]                   {
[13:23:26.830]                     base::local({
[13:23:26.830]                       has_future <- base::requireNamespace("future", 
[13:23:26.830]                         quietly = TRUE)
[13:23:26.830]                       if (has_future) {
[13:23:26.830]                         ns <- base::getNamespace("future")
[13:23:26.830]                         version <- ns[[".package"]][["version"]]
[13:23:26.830]                         if (is.null(version)) 
[13:23:26.830]                           version <- utils::packageVersion("future")
[13:23:26.830]                       }
[13:23:26.830]                       else {
[13:23:26.830]                         version <- NULL
[13:23:26.830]                       }
[13:23:26.830]                       if (!has_future || version < "1.8.0") {
[13:23:26.830]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.830]                           "", base::R.version$version.string), 
[13:23:26.830]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:26.830]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.830]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.830]                             "release", "version")], collapse = " "), 
[13:23:26.830]                           hostname = base::Sys.info()[["nodename"]])
[13:23:26.830]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.830]                           info)
[13:23:26.830]                         info <- base::paste(info, collapse = "; ")
[13:23:26.830]                         if (!has_future) {
[13:23:26.830]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.830]                             info)
[13:23:26.830]                         }
[13:23:26.830]                         else {
[13:23:26.830]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.830]                             info, version)
[13:23:26.830]                         }
[13:23:26.830]                         base::stop(msg)
[13:23:26.830]                       }
[13:23:26.830]                     })
[13:23:26.830]                   }
[13:23:26.830]                   options(future.plan = NULL)
[13:23:26.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.830]                 }
[13:23:26.830]                 ...future.workdir <- getwd()
[13:23:26.830]             }
[13:23:26.830]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.830]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.830]         }
[13:23:26.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.830]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.830]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.830]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.830]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.830]             base::names(...future.oldOptions))
[13:23:26.830]     }
[13:23:26.830]     if (FALSE) {
[13:23:26.830]     }
[13:23:26.830]     else {
[13:23:26.830]         if (TRUE) {
[13:23:26.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.830]                 open = "w")
[13:23:26.830]         }
[13:23:26.830]         else {
[13:23:26.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.830]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.830]         }
[13:23:26.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.830]             base::sink(type = "output", split = FALSE)
[13:23:26.830]             base::close(...future.stdout)
[13:23:26.830]         }, add = TRUE)
[13:23:26.830]     }
[13:23:26.830]     ...future.frame <- base::sys.nframe()
[13:23:26.830]     ...future.conditions <- base::list()
[13:23:26.830]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.830]     if (FALSE) {
[13:23:26.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.830]     }
[13:23:26.830]     ...future.result <- base::tryCatch({
[13:23:26.830]         base::withCallingHandlers({
[13:23:26.830]             ...future.value <- base::withVisible(base::local({
[13:23:26.830]                 x["a"] <- list(1)
[13:23:26.830]                 x
[13:23:26.830]             }))
[13:23:26.830]             future::FutureResult(value = ...future.value$value, 
[13:23:26.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.830]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.830]                     ...future.globalenv.names))
[13:23:26.830]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.830]         }, condition = base::local({
[13:23:26.830]             c <- base::c
[13:23:26.830]             inherits <- base::inherits
[13:23:26.830]             invokeRestart <- base::invokeRestart
[13:23:26.830]             length <- base::length
[13:23:26.830]             list <- base::list
[13:23:26.830]             seq.int <- base::seq.int
[13:23:26.830]             signalCondition <- base::signalCondition
[13:23:26.830]             sys.calls <- base::sys.calls
[13:23:26.830]             `[[` <- base::`[[`
[13:23:26.830]             `+` <- base::`+`
[13:23:26.830]             `<<-` <- base::`<<-`
[13:23:26.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.830]                   3L)]
[13:23:26.830]             }
[13:23:26.830]             function(cond) {
[13:23:26.830]                 is_error <- inherits(cond, "error")
[13:23:26.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.830]                   NULL)
[13:23:26.830]                 if (is_error) {
[13:23:26.830]                   sessionInformation <- function() {
[13:23:26.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.830]                       search = base::search(), system = base::Sys.info())
[13:23:26.830]                   }
[13:23:26.830]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.830]                     cond$call), session = sessionInformation(), 
[13:23:26.830]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.830]                   signalCondition(cond)
[13:23:26.830]                 }
[13:23:26.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.830]                 "immediateCondition"))) {
[13:23:26.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.830]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.830]                   if (TRUE && !signal) {
[13:23:26.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.830]                     {
[13:23:26.830]                       inherits <- base::inherits
[13:23:26.830]                       invokeRestart <- base::invokeRestart
[13:23:26.830]                       is.null <- base::is.null
[13:23:26.830]                       muffled <- FALSE
[13:23:26.830]                       if (inherits(cond, "message")) {
[13:23:26.830]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.830]                         if (muffled) 
[13:23:26.830]                           invokeRestart("muffleMessage")
[13:23:26.830]                       }
[13:23:26.830]                       else if (inherits(cond, "warning")) {
[13:23:26.830]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.830]                         if (muffled) 
[13:23:26.830]                           invokeRestart("muffleWarning")
[13:23:26.830]                       }
[13:23:26.830]                       else if (inherits(cond, "condition")) {
[13:23:26.830]                         if (!is.null(pattern)) {
[13:23:26.830]                           computeRestarts <- base::computeRestarts
[13:23:26.830]                           grepl <- base::grepl
[13:23:26.830]                           restarts <- computeRestarts(cond)
[13:23:26.830]                           for (restart in restarts) {
[13:23:26.830]                             name <- restart$name
[13:23:26.830]                             if (is.null(name)) 
[13:23:26.830]                               next
[13:23:26.830]                             if (!grepl(pattern, name)) 
[13:23:26.830]                               next
[13:23:26.830]                             invokeRestart(restart)
[13:23:26.830]                             muffled <- TRUE
[13:23:26.830]                             break
[13:23:26.830]                           }
[13:23:26.830]                         }
[13:23:26.830]                       }
[13:23:26.830]                       invisible(muffled)
[13:23:26.830]                     }
[13:23:26.830]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.830]                   }
[13:23:26.830]                 }
[13:23:26.830]                 else {
[13:23:26.830]                   if (TRUE) {
[13:23:26.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.830]                     {
[13:23:26.830]                       inherits <- base::inherits
[13:23:26.830]                       invokeRestart <- base::invokeRestart
[13:23:26.830]                       is.null <- base::is.null
[13:23:26.830]                       muffled <- FALSE
[13:23:26.830]                       if (inherits(cond, "message")) {
[13:23:26.830]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.830]                         if (muffled) 
[13:23:26.830]                           invokeRestart("muffleMessage")
[13:23:26.830]                       }
[13:23:26.830]                       else if (inherits(cond, "warning")) {
[13:23:26.830]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.830]                         if (muffled) 
[13:23:26.830]                           invokeRestart("muffleWarning")
[13:23:26.830]                       }
[13:23:26.830]                       else if (inherits(cond, "condition")) {
[13:23:26.830]                         if (!is.null(pattern)) {
[13:23:26.830]                           computeRestarts <- base::computeRestarts
[13:23:26.830]                           grepl <- base::grepl
[13:23:26.830]                           restarts <- computeRestarts(cond)
[13:23:26.830]                           for (restart in restarts) {
[13:23:26.830]                             name <- restart$name
[13:23:26.830]                             if (is.null(name)) 
[13:23:26.830]                               next
[13:23:26.830]                             if (!grepl(pattern, name)) 
[13:23:26.830]                               next
[13:23:26.830]                             invokeRestart(restart)
[13:23:26.830]                             muffled <- TRUE
[13:23:26.830]                             break
[13:23:26.830]                           }
[13:23:26.830]                         }
[13:23:26.830]                       }
[13:23:26.830]                       invisible(muffled)
[13:23:26.830]                     }
[13:23:26.830]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.830]                   }
[13:23:26.830]                 }
[13:23:26.830]             }
[13:23:26.830]         }))
[13:23:26.830]     }, error = function(ex) {
[13:23:26.830]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.830]                 ...future.rng), started = ...future.startTime, 
[13:23:26.830]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.830]             version = "1.8"), class = "FutureResult")
[13:23:26.830]     }, finally = {
[13:23:26.830]         if (!identical(...future.workdir, getwd())) 
[13:23:26.830]             setwd(...future.workdir)
[13:23:26.830]         {
[13:23:26.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.830]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.830]             }
[13:23:26.830]             base::options(...future.oldOptions)
[13:23:26.830]             if (.Platform$OS.type == "windows") {
[13:23:26.830]                 old_names <- names(...future.oldEnvVars)
[13:23:26.830]                 envs <- base::Sys.getenv()
[13:23:26.830]                 names <- names(envs)
[13:23:26.830]                 common <- intersect(names, old_names)
[13:23:26.830]                 added <- setdiff(names, old_names)
[13:23:26.830]                 removed <- setdiff(old_names, names)
[13:23:26.830]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.830]                   envs[common]]
[13:23:26.830]                 NAMES <- toupper(changed)
[13:23:26.830]                 args <- list()
[13:23:26.830]                 for (kk in seq_along(NAMES)) {
[13:23:26.830]                   name <- changed[[kk]]
[13:23:26.830]                   NAME <- NAMES[[kk]]
[13:23:26.830]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.830]                     next
[13:23:26.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.830]                 }
[13:23:26.830]                 NAMES <- toupper(added)
[13:23:26.830]                 for (kk in seq_along(NAMES)) {
[13:23:26.830]                   name <- added[[kk]]
[13:23:26.830]                   NAME <- NAMES[[kk]]
[13:23:26.830]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.830]                     next
[13:23:26.830]                   args[[name]] <- ""
[13:23:26.830]                 }
[13:23:26.830]                 NAMES <- toupper(removed)
[13:23:26.830]                 for (kk in seq_along(NAMES)) {
[13:23:26.830]                   name <- removed[[kk]]
[13:23:26.830]                   NAME <- NAMES[[kk]]
[13:23:26.830]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.830]                     next
[13:23:26.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.830]                 }
[13:23:26.830]                 if (length(args) > 0) 
[13:23:26.830]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.830]             }
[13:23:26.830]             else {
[13:23:26.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.830]             }
[13:23:26.830]             {
[13:23:26.830]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.830]                   0L) {
[13:23:26.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.830]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.830]                   base::options(opts)
[13:23:26.830]                 }
[13:23:26.830]                 {
[13:23:26.830]                   {
[13:23:26.830]                     NULL
[13:23:26.830]                     RNGkind("Mersenne-Twister")
[13:23:26.830]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:26.830]                       inherits = FALSE)
[13:23:26.830]                   }
[13:23:26.830]                   options(future.plan = NULL)
[13:23:26.830]                   if (is.na(NA_character_)) 
[13:23:26.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.830]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:26.830]                   {
[13:23:26.830]                     future <- SequentialFuture(..., envir = envir)
[13:23:26.830]                     if (!future$lazy) 
[13:23:26.830]                       future <- run(future)
[13:23:26.830]                     invisible(future)
[13:23:26.830]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.830]                 }
[13:23:26.830]             }
[13:23:26.830]         }
[13:23:26.830]     })
[13:23:26.830]     if (TRUE) {
[13:23:26.830]         base::sink(type = "output", split = FALSE)
[13:23:26.830]         if (TRUE) {
[13:23:26.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.830]         }
[13:23:26.830]         else {
[13:23:26.830]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.830]         }
[13:23:26.830]         base::close(...future.stdout)
[13:23:26.830]         ...future.stdout <- NULL
[13:23:26.830]     }
[13:23:26.830]     ...future.result$conditions <- ...future.conditions
[13:23:26.830]     ...future.result$finished <- base::Sys.time()
[13:23:26.830]     ...future.result
[13:23:26.830] }
[13:23:26.832] assign_globals() ...
[13:23:26.832] List of 1
[13:23:26.832]  $ x: list()
[13:23:26.832]  - attr(*, "where")=List of 1
[13:23:26.832]   ..$ x:<environment: R_EmptyEnv> 
[13:23:26.832]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.832]  - attr(*, "resolved")= logi TRUE
[13:23:26.832]  - attr(*, "total_size")= num 0
[13:23:26.832]  - attr(*, "already-done")= logi TRUE
[13:23:26.835] - copied ‘x’ to environment
[13:23:26.835] assign_globals() ... done
[13:23:26.835] plan(): Setting new future strategy stack:
[13:23:26.835] List of future strategies:
[13:23:26.835] 1. sequential:
[13:23:26.835]    - args: function (..., envir = parent.frame())
[13:23:26.835]    - tweaked: FALSE
[13:23:26.835]    - call: NULL
[13:23:26.836] plan(): nbrOfWorkers() = 1
[13:23:26.836] plan(): Setting new future strategy stack:
[13:23:26.837] List of future strategies:
[13:23:26.837] 1. sequential:
[13:23:26.837]    - args: function (..., envir = parent.frame())
[13:23:26.837]    - tweaked: FALSE
[13:23:26.837]    - call: plan(strategy)
[13:23:26.837] plan(): nbrOfWorkers() = 1
[13:23:26.837] SequentialFuture started (and completed)
[13:23:26.837] - Launch lazy future ... done
[13:23:26.837] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.838] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.838] Searching for globals...
[13:23:26.840] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:26.840] Searching for globals ... DONE
[13:23:26.840] Resolving globals: TRUE
[13:23:26.840] Resolving any globals that are futures ...
[13:23:26.840] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:26.841] Resolving any globals that are futures ... DONE
[13:23:26.841] Resolving futures part of globals (recursively) ...
[13:23:26.841] resolve() on list ...
[13:23:26.841]  recursive: 99
[13:23:26.841]  length: 1
[13:23:26.842]  elements: ‘x’
[13:23:26.842]  length: 0 (resolved future 1)
[13:23:26.842] resolve() on list ... DONE
[13:23:26.842] - globals: [1] ‘x’
[13:23:26.842] Resolving futures part of globals (recursively) ... DONE
[13:23:26.842] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.842] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.843] - globals: [1] ‘x’
[13:23:26.843] 
[13:23:26.843] getGlobalsAndPackages() ... DONE
[13:23:26.843] run() for ‘Future’ ...
[13:23:26.843] - state: ‘created’
[13:23:26.843] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:26.844] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:26.844] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:26.844]   - Field: ‘label’
[13:23:26.844]   - Field: ‘local’
[13:23:26.844]   - Field: ‘owner’
[13:23:26.844]   - Field: ‘envir’
[13:23:26.844]   - Field: ‘packages’
[13:23:26.844]   - Field: ‘gc’
[13:23:26.844]   - Field: ‘conditions’
[13:23:26.844]   - Field: ‘expr’
[13:23:26.845]   - Field: ‘uuid’
[13:23:26.845]   - Field: ‘seed’
[13:23:26.845]   - Field: ‘version’
[13:23:26.845]   - Field: ‘result’
[13:23:26.845]   - Field: ‘asynchronous’
[13:23:26.847]   - Field: ‘calls’
[13:23:26.847]   - Field: ‘globals’
[13:23:26.847]   - Field: ‘stdout’
[13:23:26.847]   - Field: ‘earlySignal’
[13:23:26.847]   - Field: ‘lazy’
[13:23:26.847]   - Field: ‘state’
[13:23:26.847] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:26.848] - Launch lazy future ...
[13:23:26.848] Packages needed by the future expression (n = 0): <none>
[13:23:26.848] Packages needed by future strategies (n = 0): <none>
[13:23:26.848] {
[13:23:26.848]     {
[13:23:26.848]         {
[13:23:26.848]             ...future.startTime <- base::Sys.time()
[13:23:26.848]             {
[13:23:26.848]                 {
[13:23:26.848]                   {
[13:23:26.848]                     base::local({
[13:23:26.848]                       has_future <- base::requireNamespace("future", 
[13:23:26.848]                         quietly = TRUE)
[13:23:26.848]                       if (has_future) {
[13:23:26.848]                         ns <- base::getNamespace("future")
[13:23:26.848]                         version <- ns[[".package"]][["version"]]
[13:23:26.848]                         if (is.null(version)) 
[13:23:26.848]                           version <- utils::packageVersion("future")
[13:23:26.848]                       }
[13:23:26.848]                       else {
[13:23:26.848]                         version <- NULL
[13:23:26.848]                       }
[13:23:26.848]                       if (!has_future || version < "1.8.0") {
[13:23:26.848]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.848]                           "", base::R.version$version.string), 
[13:23:26.848]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:26.848]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.848]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.848]                             "release", "version")], collapse = " "), 
[13:23:26.848]                           hostname = base::Sys.info()[["nodename"]])
[13:23:26.848]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.848]                           info)
[13:23:26.848]                         info <- base::paste(info, collapse = "; ")
[13:23:26.848]                         if (!has_future) {
[13:23:26.848]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.848]                             info)
[13:23:26.848]                         }
[13:23:26.848]                         else {
[13:23:26.848]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.848]                             info, version)
[13:23:26.848]                         }
[13:23:26.848]                         base::stop(msg)
[13:23:26.848]                       }
[13:23:26.848]                     })
[13:23:26.848]                   }
[13:23:26.848]                   options(future.plan = NULL)
[13:23:26.848]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.848]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.848]                 }
[13:23:26.848]                 ...future.workdir <- getwd()
[13:23:26.848]             }
[13:23:26.848]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.848]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.848]         }
[13:23:26.848]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.848]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.848]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.848]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.848]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.848]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.848]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.848]             base::names(...future.oldOptions))
[13:23:26.848]     }
[13:23:26.848]     if (FALSE) {
[13:23:26.848]     }
[13:23:26.848]     else {
[13:23:26.848]         if (TRUE) {
[13:23:26.848]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.848]                 open = "w")
[13:23:26.848]         }
[13:23:26.848]         else {
[13:23:26.848]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.848]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.848]         }
[13:23:26.848]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.848]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.848]             base::sink(type = "output", split = FALSE)
[13:23:26.848]             base::close(...future.stdout)
[13:23:26.848]         }, add = TRUE)
[13:23:26.848]     }
[13:23:26.848]     ...future.frame <- base::sys.nframe()
[13:23:26.848]     ...future.conditions <- base::list()
[13:23:26.848]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.848]     if (FALSE) {
[13:23:26.848]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.848]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.848]     }
[13:23:26.848]     ...future.result <- base::tryCatch({
[13:23:26.848]         base::withCallingHandlers({
[13:23:26.848]             ...future.value <- base::withVisible(base::local({
[13:23:26.848]                 x["a"] <- list(1)
[13:23:26.848]                 x
[13:23:26.848]             }))
[13:23:26.848]             future::FutureResult(value = ...future.value$value, 
[13:23:26.848]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.848]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.848]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.848]                     ...future.globalenv.names))
[13:23:26.848]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.848]         }, condition = base::local({
[13:23:26.848]             c <- base::c
[13:23:26.848]             inherits <- base::inherits
[13:23:26.848]             invokeRestart <- base::invokeRestart
[13:23:26.848]             length <- base::length
[13:23:26.848]             list <- base::list
[13:23:26.848]             seq.int <- base::seq.int
[13:23:26.848]             signalCondition <- base::signalCondition
[13:23:26.848]             sys.calls <- base::sys.calls
[13:23:26.848]             `[[` <- base::`[[`
[13:23:26.848]             `+` <- base::`+`
[13:23:26.848]             `<<-` <- base::`<<-`
[13:23:26.848]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.848]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.848]                   3L)]
[13:23:26.848]             }
[13:23:26.848]             function(cond) {
[13:23:26.848]                 is_error <- inherits(cond, "error")
[13:23:26.848]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.848]                   NULL)
[13:23:26.848]                 if (is_error) {
[13:23:26.848]                   sessionInformation <- function() {
[13:23:26.848]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.848]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.848]                       search = base::search(), system = base::Sys.info())
[13:23:26.848]                   }
[13:23:26.848]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.848]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.848]                     cond$call), session = sessionInformation(), 
[13:23:26.848]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.848]                   signalCondition(cond)
[13:23:26.848]                 }
[13:23:26.848]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.848]                 "immediateCondition"))) {
[13:23:26.848]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.848]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.848]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.848]                   if (TRUE && !signal) {
[13:23:26.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.848]                     {
[13:23:26.848]                       inherits <- base::inherits
[13:23:26.848]                       invokeRestart <- base::invokeRestart
[13:23:26.848]                       is.null <- base::is.null
[13:23:26.848]                       muffled <- FALSE
[13:23:26.848]                       if (inherits(cond, "message")) {
[13:23:26.848]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.848]                         if (muffled) 
[13:23:26.848]                           invokeRestart("muffleMessage")
[13:23:26.848]                       }
[13:23:26.848]                       else if (inherits(cond, "warning")) {
[13:23:26.848]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.848]                         if (muffled) 
[13:23:26.848]                           invokeRestart("muffleWarning")
[13:23:26.848]                       }
[13:23:26.848]                       else if (inherits(cond, "condition")) {
[13:23:26.848]                         if (!is.null(pattern)) {
[13:23:26.848]                           computeRestarts <- base::computeRestarts
[13:23:26.848]                           grepl <- base::grepl
[13:23:26.848]                           restarts <- computeRestarts(cond)
[13:23:26.848]                           for (restart in restarts) {
[13:23:26.848]                             name <- restart$name
[13:23:26.848]                             if (is.null(name)) 
[13:23:26.848]                               next
[13:23:26.848]                             if (!grepl(pattern, name)) 
[13:23:26.848]                               next
[13:23:26.848]                             invokeRestart(restart)
[13:23:26.848]                             muffled <- TRUE
[13:23:26.848]                             break
[13:23:26.848]                           }
[13:23:26.848]                         }
[13:23:26.848]                       }
[13:23:26.848]                       invisible(muffled)
[13:23:26.848]                     }
[13:23:26.848]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.848]                   }
[13:23:26.848]                 }
[13:23:26.848]                 else {
[13:23:26.848]                   if (TRUE) {
[13:23:26.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.848]                     {
[13:23:26.848]                       inherits <- base::inherits
[13:23:26.848]                       invokeRestart <- base::invokeRestart
[13:23:26.848]                       is.null <- base::is.null
[13:23:26.848]                       muffled <- FALSE
[13:23:26.848]                       if (inherits(cond, "message")) {
[13:23:26.848]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.848]                         if (muffled) 
[13:23:26.848]                           invokeRestart("muffleMessage")
[13:23:26.848]                       }
[13:23:26.848]                       else if (inherits(cond, "warning")) {
[13:23:26.848]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.848]                         if (muffled) 
[13:23:26.848]                           invokeRestart("muffleWarning")
[13:23:26.848]                       }
[13:23:26.848]                       else if (inherits(cond, "condition")) {
[13:23:26.848]                         if (!is.null(pattern)) {
[13:23:26.848]                           computeRestarts <- base::computeRestarts
[13:23:26.848]                           grepl <- base::grepl
[13:23:26.848]                           restarts <- computeRestarts(cond)
[13:23:26.848]                           for (restart in restarts) {
[13:23:26.848]                             name <- restart$name
[13:23:26.848]                             if (is.null(name)) 
[13:23:26.848]                               next
[13:23:26.848]                             if (!grepl(pattern, name)) 
[13:23:26.848]                               next
[13:23:26.848]                             invokeRestart(restart)
[13:23:26.848]                             muffled <- TRUE
[13:23:26.848]                             break
[13:23:26.848]                           }
[13:23:26.848]                         }
[13:23:26.848]                       }
[13:23:26.848]                       invisible(muffled)
[13:23:26.848]                     }
[13:23:26.848]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.848]                   }
[13:23:26.848]                 }
[13:23:26.848]             }
[13:23:26.848]         }))
[13:23:26.848]     }, error = function(ex) {
[13:23:26.848]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.848]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.848]                 ...future.rng), started = ...future.startTime, 
[13:23:26.848]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.848]             version = "1.8"), class = "FutureResult")
[13:23:26.848]     }, finally = {
[13:23:26.848]         if (!identical(...future.workdir, getwd())) 
[13:23:26.848]             setwd(...future.workdir)
[13:23:26.848]         {
[13:23:26.848]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.848]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.848]             }
[13:23:26.848]             base::options(...future.oldOptions)
[13:23:26.848]             if (.Platform$OS.type == "windows") {
[13:23:26.848]                 old_names <- names(...future.oldEnvVars)
[13:23:26.848]                 envs <- base::Sys.getenv()
[13:23:26.848]                 names <- names(envs)
[13:23:26.848]                 common <- intersect(names, old_names)
[13:23:26.848]                 added <- setdiff(names, old_names)
[13:23:26.848]                 removed <- setdiff(old_names, names)
[13:23:26.848]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.848]                   envs[common]]
[13:23:26.848]                 NAMES <- toupper(changed)
[13:23:26.848]                 args <- list()
[13:23:26.848]                 for (kk in seq_along(NAMES)) {
[13:23:26.848]                   name <- changed[[kk]]
[13:23:26.848]                   NAME <- NAMES[[kk]]
[13:23:26.848]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.848]                     next
[13:23:26.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.848]                 }
[13:23:26.848]                 NAMES <- toupper(added)
[13:23:26.848]                 for (kk in seq_along(NAMES)) {
[13:23:26.848]                   name <- added[[kk]]
[13:23:26.848]                   NAME <- NAMES[[kk]]
[13:23:26.848]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.848]                     next
[13:23:26.848]                   args[[name]] <- ""
[13:23:26.848]                 }
[13:23:26.848]                 NAMES <- toupper(removed)
[13:23:26.848]                 for (kk in seq_along(NAMES)) {
[13:23:26.848]                   name <- removed[[kk]]
[13:23:26.848]                   NAME <- NAMES[[kk]]
[13:23:26.848]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.848]                     next
[13:23:26.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.848]                 }
[13:23:26.848]                 if (length(args) > 0) 
[13:23:26.848]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.848]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.848]             }
[13:23:26.848]             else {
[13:23:26.848]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.848]             }
[13:23:26.848]             {
[13:23:26.848]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.848]                   0L) {
[13:23:26.848]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.848]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.848]                   base::options(opts)
[13:23:26.848]                 }
[13:23:26.848]                 {
[13:23:26.848]                   {
[13:23:26.848]                     NULL
[13:23:26.848]                     RNGkind("Mersenne-Twister")
[13:23:26.848]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:26.848]                       inherits = FALSE)
[13:23:26.848]                   }
[13:23:26.848]                   options(future.plan = NULL)
[13:23:26.848]                   if (is.na(NA_character_)) 
[13:23:26.848]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.848]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.848]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:26.848]                   {
[13:23:26.848]                     future <- SequentialFuture(..., envir = envir)
[13:23:26.848]                     if (!future$lazy) 
[13:23:26.848]                       future <- run(future)
[13:23:26.848]                     invisible(future)
[13:23:26.848]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.848]                 }
[13:23:26.848]             }
[13:23:26.848]         }
[13:23:26.848]     })
[13:23:26.848]     if (TRUE) {
[13:23:26.848]         base::sink(type = "output", split = FALSE)
[13:23:26.848]         if (TRUE) {
[13:23:26.848]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.848]         }
[13:23:26.848]         else {
[13:23:26.848]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.848]         }
[13:23:26.848]         base::close(...future.stdout)
[13:23:26.848]         ...future.stdout <- NULL
[13:23:26.848]     }
[13:23:26.848]     ...future.result$conditions <- ...future.conditions
[13:23:26.848]     ...future.result$finished <- base::Sys.time()
[13:23:26.848]     ...future.result
[13:23:26.848] }
[13:23:26.850] assign_globals() ...
[13:23:26.850] List of 1
[13:23:26.850]  $ x: list()
[13:23:26.850]  - attr(*, "where")=List of 1
[13:23:26.850]   ..$ x:<environment: R_EmptyEnv> 
[13:23:26.850]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.850]  - attr(*, "resolved")= logi TRUE
[13:23:26.850]  - attr(*, "total_size")= num 0
[13:23:26.850]  - attr(*, "already-done")= logi TRUE
[13:23:26.853] - copied ‘x’ to environment
[13:23:26.853] assign_globals() ... done
[13:23:26.853] plan(): Setting new future strategy stack:
[13:23:26.853] List of future strategies:
[13:23:26.853] 1. sequential:
[13:23:26.853]    - args: function (..., envir = parent.frame())
[13:23:26.853]    - tweaked: FALSE
[13:23:26.853]    - call: NULL
[13:23:26.854] plan(): nbrOfWorkers() = 1
[13:23:26.854] plan(): Setting new future strategy stack:
[13:23:26.855] List of future strategies:
[13:23:26.855] 1. sequential:
[13:23:26.855]    - args: function (..., envir = parent.frame())
[13:23:26.855]    - tweaked: FALSE
[13:23:26.855]    - call: plan(strategy)
[13:23:26.855] plan(): nbrOfWorkers() = 1
[13:23:26.855] SequentialFuture started (and completed)
[13:23:26.855] - Launch lazy future ... done
[13:23:26.855] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.856] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.856] Searching for globals...
[13:23:26.858] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:26.858] Searching for globals ... DONE
[13:23:26.858] Resolving globals: TRUE
[13:23:26.858] Resolving any globals that are futures ...
[13:23:26.859] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:26.859] Resolving any globals that are futures ... DONE
[13:23:26.859] Resolving futures part of globals (recursively) ...
[13:23:26.859] resolve() on list ...
[13:23:26.859]  recursive: 99
[13:23:26.860]  length: 1
[13:23:26.860]  elements: ‘x’
[13:23:26.860]  length: 0 (resolved future 1)
[13:23:26.860] resolve() on list ... DONE
[13:23:26.860] - globals: [1] ‘x’
[13:23:26.860] Resolving futures part of globals (recursively) ... DONE
[13:23:26.860] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.861] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.861] - globals: [1] ‘x’
[13:23:26.861] 
[13:23:26.861] getGlobalsAndPackages() ... DONE
[13:23:26.861] run() for ‘Future’ ...
[13:23:26.861] - state: ‘created’
[13:23:26.861] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:26.862] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:26.862] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:26.862]   - Field: ‘label’
[13:23:26.862]   - Field: ‘local’
[13:23:26.862]   - Field: ‘owner’
[13:23:26.862]   - Field: ‘envir’
[13:23:26.862]   - Field: ‘packages’
[13:23:26.862]   - Field: ‘gc’
[13:23:26.863]   - Field: ‘conditions’
[13:23:26.863]   - Field: ‘expr’
[13:23:26.863]   - Field: ‘uuid’
[13:23:26.863]   - Field: ‘seed’
[13:23:26.863]   - Field: ‘version’
[13:23:26.863]   - Field: ‘result’
[13:23:26.863]   - Field: ‘asynchronous’
[13:23:26.863]   - Field: ‘calls’
[13:23:26.863]   - Field: ‘globals’
[13:23:26.863]   - Field: ‘stdout’
[13:23:26.863]   - Field: ‘earlySignal’
[13:23:26.864]   - Field: ‘lazy’
[13:23:26.864]   - Field: ‘state’
[13:23:26.864] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:26.864] - Launch lazy future ...
[13:23:26.864] Packages needed by the future expression (n = 0): <none>
[13:23:26.864] Packages needed by future strategies (n = 0): <none>
[13:23:26.865] {
[13:23:26.865]     {
[13:23:26.865]         {
[13:23:26.865]             ...future.startTime <- base::Sys.time()
[13:23:26.865]             {
[13:23:26.865]                 {
[13:23:26.865]                   {
[13:23:26.865]                     base::local({
[13:23:26.865]                       has_future <- base::requireNamespace("future", 
[13:23:26.865]                         quietly = TRUE)
[13:23:26.865]                       if (has_future) {
[13:23:26.865]                         ns <- base::getNamespace("future")
[13:23:26.865]                         version <- ns[[".package"]][["version"]]
[13:23:26.865]                         if (is.null(version)) 
[13:23:26.865]                           version <- utils::packageVersion("future")
[13:23:26.865]                       }
[13:23:26.865]                       else {
[13:23:26.865]                         version <- NULL
[13:23:26.865]                       }
[13:23:26.865]                       if (!has_future || version < "1.8.0") {
[13:23:26.865]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.865]                           "", base::R.version$version.string), 
[13:23:26.865]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:26.865]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.865]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.865]                             "release", "version")], collapse = " "), 
[13:23:26.865]                           hostname = base::Sys.info()[["nodename"]])
[13:23:26.865]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.865]                           info)
[13:23:26.865]                         info <- base::paste(info, collapse = "; ")
[13:23:26.865]                         if (!has_future) {
[13:23:26.865]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.865]                             info)
[13:23:26.865]                         }
[13:23:26.865]                         else {
[13:23:26.865]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.865]                             info, version)
[13:23:26.865]                         }
[13:23:26.865]                         base::stop(msg)
[13:23:26.865]                       }
[13:23:26.865]                     })
[13:23:26.865]                   }
[13:23:26.865]                   options(future.plan = NULL)
[13:23:26.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.865]                 }
[13:23:26.865]                 ...future.workdir <- getwd()
[13:23:26.865]             }
[13:23:26.865]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.865]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.865]         }
[13:23:26.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.865]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.865]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.865]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.865]             base::names(...future.oldOptions))
[13:23:26.865]     }
[13:23:26.865]     if (FALSE) {
[13:23:26.865]     }
[13:23:26.865]     else {
[13:23:26.865]         if (TRUE) {
[13:23:26.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.865]                 open = "w")
[13:23:26.865]         }
[13:23:26.865]         else {
[13:23:26.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.865]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.865]         }
[13:23:26.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.865]             base::sink(type = "output", split = FALSE)
[13:23:26.865]             base::close(...future.stdout)
[13:23:26.865]         }, add = TRUE)
[13:23:26.865]     }
[13:23:26.865]     ...future.frame <- base::sys.nframe()
[13:23:26.865]     ...future.conditions <- base::list()
[13:23:26.865]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.865]     if (FALSE) {
[13:23:26.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.865]     }
[13:23:26.865]     ...future.result <- base::tryCatch({
[13:23:26.865]         base::withCallingHandlers({
[13:23:26.865]             ...future.value <- base::withVisible(base::local({
[13:23:26.865]                 x["a"] <- list(1)
[13:23:26.865]                 x
[13:23:26.865]             }))
[13:23:26.865]             future::FutureResult(value = ...future.value$value, 
[13:23:26.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.865]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.865]                     ...future.globalenv.names))
[13:23:26.865]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.865]         }, condition = base::local({
[13:23:26.865]             c <- base::c
[13:23:26.865]             inherits <- base::inherits
[13:23:26.865]             invokeRestart <- base::invokeRestart
[13:23:26.865]             length <- base::length
[13:23:26.865]             list <- base::list
[13:23:26.865]             seq.int <- base::seq.int
[13:23:26.865]             signalCondition <- base::signalCondition
[13:23:26.865]             sys.calls <- base::sys.calls
[13:23:26.865]             `[[` <- base::`[[`
[13:23:26.865]             `+` <- base::`+`
[13:23:26.865]             `<<-` <- base::`<<-`
[13:23:26.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.865]                   3L)]
[13:23:26.865]             }
[13:23:26.865]             function(cond) {
[13:23:26.865]                 is_error <- inherits(cond, "error")
[13:23:26.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.865]                   NULL)
[13:23:26.865]                 if (is_error) {
[13:23:26.865]                   sessionInformation <- function() {
[13:23:26.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.865]                       search = base::search(), system = base::Sys.info())
[13:23:26.865]                   }
[13:23:26.865]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.865]                     cond$call), session = sessionInformation(), 
[13:23:26.865]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.865]                   signalCondition(cond)
[13:23:26.865]                 }
[13:23:26.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.865]                 "immediateCondition"))) {
[13:23:26.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.865]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.865]                   if (TRUE && !signal) {
[13:23:26.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.865]                     {
[13:23:26.865]                       inherits <- base::inherits
[13:23:26.865]                       invokeRestart <- base::invokeRestart
[13:23:26.865]                       is.null <- base::is.null
[13:23:26.865]                       muffled <- FALSE
[13:23:26.865]                       if (inherits(cond, "message")) {
[13:23:26.865]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.865]                         if (muffled) 
[13:23:26.865]                           invokeRestart("muffleMessage")
[13:23:26.865]                       }
[13:23:26.865]                       else if (inherits(cond, "warning")) {
[13:23:26.865]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.865]                         if (muffled) 
[13:23:26.865]                           invokeRestart("muffleWarning")
[13:23:26.865]                       }
[13:23:26.865]                       else if (inherits(cond, "condition")) {
[13:23:26.865]                         if (!is.null(pattern)) {
[13:23:26.865]                           computeRestarts <- base::computeRestarts
[13:23:26.865]                           grepl <- base::grepl
[13:23:26.865]                           restarts <- computeRestarts(cond)
[13:23:26.865]                           for (restart in restarts) {
[13:23:26.865]                             name <- restart$name
[13:23:26.865]                             if (is.null(name)) 
[13:23:26.865]                               next
[13:23:26.865]                             if (!grepl(pattern, name)) 
[13:23:26.865]                               next
[13:23:26.865]                             invokeRestart(restart)
[13:23:26.865]                             muffled <- TRUE
[13:23:26.865]                             break
[13:23:26.865]                           }
[13:23:26.865]                         }
[13:23:26.865]                       }
[13:23:26.865]                       invisible(muffled)
[13:23:26.865]                     }
[13:23:26.865]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.865]                   }
[13:23:26.865]                 }
[13:23:26.865]                 else {
[13:23:26.865]                   if (TRUE) {
[13:23:26.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.865]                     {
[13:23:26.865]                       inherits <- base::inherits
[13:23:26.865]                       invokeRestart <- base::invokeRestart
[13:23:26.865]                       is.null <- base::is.null
[13:23:26.865]                       muffled <- FALSE
[13:23:26.865]                       if (inherits(cond, "message")) {
[13:23:26.865]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.865]                         if (muffled) 
[13:23:26.865]                           invokeRestart("muffleMessage")
[13:23:26.865]                       }
[13:23:26.865]                       else if (inherits(cond, "warning")) {
[13:23:26.865]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.865]                         if (muffled) 
[13:23:26.865]                           invokeRestart("muffleWarning")
[13:23:26.865]                       }
[13:23:26.865]                       else if (inherits(cond, "condition")) {
[13:23:26.865]                         if (!is.null(pattern)) {
[13:23:26.865]                           computeRestarts <- base::computeRestarts
[13:23:26.865]                           grepl <- base::grepl
[13:23:26.865]                           restarts <- computeRestarts(cond)
[13:23:26.865]                           for (restart in restarts) {
[13:23:26.865]                             name <- restart$name
[13:23:26.865]                             if (is.null(name)) 
[13:23:26.865]                               next
[13:23:26.865]                             if (!grepl(pattern, name)) 
[13:23:26.865]                               next
[13:23:26.865]                             invokeRestart(restart)
[13:23:26.865]                             muffled <- TRUE
[13:23:26.865]                             break
[13:23:26.865]                           }
[13:23:26.865]                         }
[13:23:26.865]                       }
[13:23:26.865]                       invisible(muffled)
[13:23:26.865]                     }
[13:23:26.865]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.865]                   }
[13:23:26.865]                 }
[13:23:26.865]             }
[13:23:26.865]         }))
[13:23:26.865]     }, error = function(ex) {
[13:23:26.865]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.865]                 ...future.rng), started = ...future.startTime, 
[13:23:26.865]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.865]             version = "1.8"), class = "FutureResult")
[13:23:26.865]     }, finally = {
[13:23:26.865]         if (!identical(...future.workdir, getwd())) 
[13:23:26.865]             setwd(...future.workdir)
[13:23:26.865]         {
[13:23:26.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.865]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.865]             }
[13:23:26.865]             base::options(...future.oldOptions)
[13:23:26.865]             if (.Platform$OS.type == "windows") {
[13:23:26.865]                 old_names <- names(...future.oldEnvVars)
[13:23:26.865]                 envs <- base::Sys.getenv()
[13:23:26.865]                 names <- names(envs)
[13:23:26.865]                 common <- intersect(names, old_names)
[13:23:26.865]                 added <- setdiff(names, old_names)
[13:23:26.865]                 removed <- setdiff(old_names, names)
[13:23:26.865]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.865]                   envs[common]]
[13:23:26.865]                 NAMES <- toupper(changed)
[13:23:26.865]                 args <- list()
[13:23:26.865]                 for (kk in seq_along(NAMES)) {
[13:23:26.865]                   name <- changed[[kk]]
[13:23:26.865]                   NAME <- NAMES[[kk]]
[13:23:26.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.865]                     next
[13:23:26.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.865]                 }
[13:23:26.865]                 NAMES <- toupper(added)
[13:23:26.865]                 for (kk in seq_along(NAMES)) {
[13:23:26.865]                   name <- added[[kk]]
[13:23:26.865]                   NAME <- NAMES[[kk]]
[13:23:26.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.865]                     next
[13:23:26.865]                   args[[name]] <- ""
[13:23:26.865]                 }
[13:23:26.865]                 NAMES <- toupper(removed)
[13:23:26.865]                 for (kk in seq_along(NAMES)) {
[13:23:26.865]                   name <- removed[[kk]]
[13:23:26.865]                   NAME <- NAMES[[kk]]
[13:23:26.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.865]                     next
[13:23:26.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.865]                 }
[13:23:26.865]                 if (length(args) > 0) 
[13:23:26.865]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.865]             }
[13:23:26.865]             else {
[13:23:26.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.865]             }
[13:23:26.865]             {
[13:23:26.865]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.865]                   0L) {
[13:23:26.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.865]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.865]                   base::options(opts)
[13:23:26.865]                 }
[13:23:26.865]                 {
[13:23:26.865]                   {
[13:23:26.865]                     NULL
[13:23:26.865]                     RNGkind("Mersenne-Twister")
[13:23:26.865]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:26.865]                       inherits = FALSE)
[13:23:26.865]                   }
[13:23:26.865]                   options(future.plan = NULL)
[13:23:26.865]                   if (is.na(NA_character_)) 
[13:23:26.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.865]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:26.865]                   {
[13:23:26.865]                     future <- SequentialFuture(..., envir = envir)
[13:23:26.865]                     if (!future$lazy) 
[13:23:26.865]                       future <- run(future)
[13:23:26.865]                     invisible(future)
[13:23:26.865]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.865]                 }
[13:23:26.865]             }
[13:23:26.865]         }
[13:23:26.865]     })
[13:23:26.865]     if (TRUE) {
[13:23:26.865]         base::sink(type = "output", split = FALSE)
[13:23:26.865]         if (TRUE) {
[13:23:26.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.865]         }
[13:23:26.865]         else {
[13:23:26.865]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.865]         }
[13:23:26.865]         base::close(...future.stdout)
[13:23:26.865]         ...future.stdout <- NULL
[13:23:26.865]     }
[13:23:26.865]     ...future.result$conditions <- ...future.conditions
[13:23:26.865]     ...future.result$finished <- base::Sys.time()
[13:23:26.865]     ...future.result
[13:23:26.865] }
[13:23:26.866] assign_globals() ...
[13:23:26.867] List of 1
[13:23:26.867]  $ x: list()
[13:23:26.867]  - attr(*, "where")=List of 1
[13:23:26.867]   ..$ x:<environment: R_EmptyEnv> 
[13:23:26.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.867]  - attr(*, "resolved")= logi TRUE
[13:23:26.867]  - attr(*, "total_size")= num 0
[13:23:26.867]  - attr(*, "already-done")= logi TRUE
[13:23:26.869] - copied ‘x’ to environment
[13:23:26.869] assign_globals() ... done
[13:23:26.869] plan(): Setting new future strategy stack:
[13:23:26.870] List of future strategies:
[13:23:26.870] 1. sequential:
[13:23:26.870]    - args: function (..., envir = parent.frame())
[13:23:26.870]    - tweaked: FALSE
[13:23:26.870]    - call: NULL
[13:23:26.870] plan(): nbrOfWorkers() = 1
[13:23:26.871] plan(): Setting new future strategy stack:
[13:23:26.871] List of future strategies:
[13:23:26.871] 1. sequential:
[13:23:26.871]    - args: function (..., envir = parent.frame())
[13:23:26.871]    - tweaked: FALSE
[13:23:26.871]    - call: plan(strategy)
[13:23:26.871] plan(): nbrOfWorkers() = 1
[13:23:26.871] SequentialFuture started (and completed)
[13:23:26.872] - Launch lazy future ... done
[13:23:26.872] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.872] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.873] Searching for globals...
[13:23:26.876] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[13:23:26.877] Searching for globals ... DONE
[13:23:26.877] Resolving globals: TRUE
[13:23:26.877] Resolving any globals that are futures ...
[13:23:26.877] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[13:23:26.877] Resolving any globals that are futures ... DONE
[13:23:26.877] Resolving futures part of globals (recursively) ...
[13:23:26.878] resolve() on list ...
[13:23:26.878]  recursive: 99
[13:23:26.878]  length: 2
[13:23:26.878]  elements: ‘x’, ‘name’
[13:23:26.878]  length: 1 (resolved future 1)
[13:23:26.878]  length: 0 (resolved future 2)
[13:23:26.878] resolve() on list ... DONE
[13:23:26.878] - globals: [2] ‘x’, ‘name’
[13:23:26.879] Resolving futures part of globals (recursively) ... DONE
[13:23:26.879] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:26.879] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[13:23:26.879] - globals: [2] ‘x’, ‘name’
[13:23:26.879] 
[13:23:26.879] getGlobalsAndPackages() ... DONE
[13:23:26.880] run() for ‘Future’ ...
[13:23:26.880] - state: ‘created’
[13:23:26.880] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:26.880] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:26.880] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:26.881]   - Field: ‘label’
[13:23:26.881]   - Field: ‘local’
[13:23:26.881]   - Field: ‘owner’
[13:23:26.881]   - Field: ‘envir’
[13:23:26.881]   - Field: ‘packages’
[13:23:26.881]   - Field: ‘gc’
[13:23:26.881]   - Field: ‘conditions’
[13:23:26.881]   - Field: ‘expr’
[13:23:26.881]   - Field: ‘uuid’
[13:23:26.881]   - Field: ‘seed’
[13:23:26.881]   - Field: ‘version’
[13:23:26.882]   - Field: ‘result’
[13:23:26.882]   - Field: ‘asynchronous’
[13:23:26.882]   - Field: ‘calls’
[13:23:26.882]   - Field: ‘globals’
[13:23:26.882]   - Field: ‘stdout’
[13:23:26.882]   - Field: ‘earlySignal’
[13:23:26.882]   - Field: ‘lazy’
[13:23:26.882]   - Field: ‘state’
[13:23:26.882] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:26.882] - Launch lazy future ...
[13:23:26.883] Packages needed by the future expression (n = 0): <none>
[13:23:26.883] Packages needed by future strategies (n = 0): <none>
[13:23:26.883] {
[13:23:26.883]     {
[13:23:26.883]         {
[13:23:26.883]             ...future.startTime <- base::Sys.time()
[13:23:26.883]             {
[13:23:26.883]                 {
[13:23:26.883]                   {
[13:23:26.883]                     base::local({
[13:23:26.883]                       has_future <- base::requireNamespace("future", 
[13:23:26.883]                         quietly = TRUE)
[13:23:26.883]                       if (has_future) {
[13:23:26.883]                         ns <- base::getNamespace("future")
[13:23:26.883]                         version <- ns[[".package"]][["version"]]
[13:23:26.883]                         if (is.null(version)) 
[13:23:26.883]                           version <- utils::packageVersion("future")
[13:23:26.883]                       }
[13:23:26.883]                       else {
[13:23:26.883]                         version <- NULL
[13:23:26.883]                       }
[13:23:26.883]                       if (!has_future || version < "1.8.0") {
[13:23:26.883]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.883]                           "", base::R.version$version.string), 
[13:23:26.883]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:26.883]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.883]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.883]                             "release", "version")], collapse = " "), 
[13:23:26.883]                           hostname = base::Sys.info()[["nodename"]])
[13:23:26.883]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.883]                           info)
[13:23:26.883]                         info <- base::paste(info, collapse = "; ")
[13:23:26.883]                         if (!has_future) {
[13:23:26.883]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.883]                             info)
[13:23:26.883]                         }
[13:23:26.883]                         else {
[13:23:26.883]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.883]                             info, version)
[13:23:26.883]                         }
[13:23:26.883]                         base::stop(msg)
[13:23:26.883]                       }
[13:23:26.883]                     })
[13:23:26.883]                   }
[13:23:26.883]                   options(future.plan = NULL)
[13:23:26.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.883]                 }
[13:23:26.883]                 ...future.workdir <- getwd()
[13:23:26.883]             }
[13:23:26.883]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.883]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.883]         }
[13:23:26.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.883]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.883]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.883]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.883]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.883]             base::names(...future.oldOptions))
[13:23:26.883]     }
[13:23:26.883]     if (FALSE) {
[13:23:26.883]     }
[13:23:26.883]     else {
[13:23:26.883]         if (TRUE) {
[13:23:26.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.883]                 open = "w")
[13:23:26.883]         }
[13:23:26.883]         else {
[13:23:26.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.883]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.883]         }
[13:23:26.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.883]             base::sink(type = "output", split = FALSE)
[13:23:26.883]             base::close(...future.stdout)
[13:23:26.883]         }, add = TRUE)
[13:23:26.883]     }
[13:23:26.883]     ...future.frame <- base::sys.nframe()
[13:23:26.883]     ...future.conditions <- base::list()
[13:23:26.883]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.883]     if (FALSE) {
[13:23:26.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.883]     }
[13:23:26.883]     ...future.result <- base::tryCatch({
[13:23:26.883]         base::withCallingHandlers({
[13:23:26.883]             ...future.value <- base::withVisible(base::local({
[13:23:26.883]                 x[name] <- list(1)
[13:23:26.883]                 x
[13:23:26.883]             }))
[13:23:26.883]             future::FutureResult(value = ...future.value$value, 
[13:23:26.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.883]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.883]                     ...future.globalenv.names))
[13:23:26.883]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.883]         }, condition = base::local({
[13:23:26.883]             c <- base::c
[13:23:26.883]             inherits <- base::inherits
[13:23:26.883]             invokeRestart <- base::invokeRestart
[13:23:26.883]             length <- base::length
[13:23:26.883]             list <- base::list
[13:23:26.883]             seq.int <- base::seq.int
[13:23:26.883]             signalCondition <- base::signalCondition
[13:23:26.883]             sys.calls <- base::sys.calls
[13:23:26.883]             `[[` <- base::`[[`
[13:23:26.883]             `+` <- base::`+`
[13:23:26.883]             `<<-` <- base::`<<-`
[13:23:26.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.883]                   3L)]
[13:23:26.883]             }
[13:23:26.883]             function(cond) {
[13:23:26.883]                 is_error <- inherits(cond, "error")
[13:23:26.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.883]                   NULL)
[13:23:26.883]                 if (is_error) {
[13:23:26.883]                   sessionInformation <- function() {
[13:23:26.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.883]                       search = base::search(), system = base::Sys.info())
[13:23:26.883]                   }
[13:23:26.883]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.883]                     cond$call), session = sessionInformation(), 
[13:23:26.883]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.883]                   signalCondition(cond)
[13:23:26.883]                 }
[13:23:26.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.883]                 "immediateCondition"))) {
[13:23:26.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.883]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.883]                   if (TRUE && !signal) {
[13:23:26.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.883]                     {
[13:23:26.883]                       inherits <- base::inherits
[13:23:26.883]                       invokeRestart <- base::invokeRestart
[13:23:26.883]                       is.null <- base::is.null
[13:23:26.883]                       muffled <- FALSE
[13:23:26.883]                       if (inherits(cond, "message")) {
[13:23:26.883]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.883]                         if (muffled) 
[13:23:26.883]                           invokeRestart("muffleMessage")
[13:23:26.883]                       }
[13:23:26.883]                       else if (inherits(cond, "warning")) {
[13:23:26.883]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.883]                         if (muffled) 
[13:23:26.883]                           invokeRestart("muffleWarning")
[13:23:26.883]                       }
[13:23:26.883]                       else if (inherits(cond, "condition")) {
[13:23:26.883]                         if (!is.null(pattern)) {
[13:23:26.883]                           computeRestarts <- base::computeRestarts
[13:23:26.883]                           grepl <- base::grepl
[13:23:26.883]                           restarts <- computeRestarts(cond)
[13:23:26.883]                           for (restart in restarts) {
[13:23:26.883]                             name <- restart$name
[13:23:26.883]                             if (is.null(name)) 
[13:23:26.883]                               next
[13:23:26.883]                             if (!grepl(pattern, name)) 
[13:23:26.883]                               next
[13:23:26.883]                             invokeRestart(restart)
[13:23:26.883]                             muffled <- TRUE
[13:23:26.883]                             break
[13:23:26.883]                           }
[13:23:26.883]                         }
[13:23:26.883]                       }
[13:23:26.883]                       invisible(muffled)
[13:23:26.883]                     }
[13:23:26.883]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.883]                   }
[13:23:26.883]                 }
[13:23:26.883]                 else {
[13:23:26.883]                   if (TRUE) {
[13:23:26.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.883]                     {
[13:23:26.883]                       inherits <- base::inherits
[13:23:26.883]                       invokeRestart <- base::invokeRestart
[13:23:26.883]                       is.null <- base::is.null
[13:23:26.883]                       muffled <- FALSE
[13:23:26.883]                       if (inherits(cond, "message")) {
[13:23:26.883]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.883]                         if (muffled) 
[13:23:26.883]                           invokeRestart("muffleMessage")
[13:23:26.883]                       }
[13:23:26.883]                       else if (inherits(cond, "warning")) {
[13:23:26.883]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.883]                         if (muffled) 
[13:23:26.883]                           invokeRestart("muffleWarning")
[13:23:26.883]                       }
[13:23:26.883]                       else if (inherits(cond, "condition")) {
[13:23:26.883]                         if (!is.null(pattern)) {
[13:23:26.883]                           computeRestarts <- base::computeRestarts
[13:23:26.883]                           grepl <- base::grepl
[13:23:26.883]                           restarts <- computeRestarts(cond)
[13:23:26.883]                           for (restart in restarts) {
[13:23:26.883]                             name <- restart$name
[13:23:26.883]                             if (is.null(name)) 
[13:23:26.883]                               next
[13:23:26.883]                             if (!grepl(pattern, name)) 
[13:23:26.883]                               next
[13:23:26.883]                             invokeRestart(restart)
[13:23:26.883]                             muffled <- TRUE
[13:23:26.883]                             break
[13:23:26.883]                           }
[13:23:26.883]                         }
[13:23:26.883]                       }
[13:23:26.883]                       invisible(muffled)
[13:23:26.883]                     }
[13:23:26.883]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.883]                   }
[13:23:26.883]                 }
[13:23:26.883]             }
[13:23:26.883]         }))
[13:23:26.883]     }, error = function(ex) {
[13:23:26.883]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.883]                 ...future.rng), started = ...future.startTime, 
[13:23:26.883]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.883]             version = "1.8"), class = "FutureResult")
[13:23:26.883]     }, finally = {
[13:23:26.883]         if (!identical(...future.workdir, getwd())) 
[13:23:26.883]             setwd(...future.workdir)
[13:23:26.883]         {
[13:23:26.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.883]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.883]             }
[13:23:26.883]             base::options(...future.oldOptions)
[13:23:26.883]             if (.Platform$OS.type == "windows") {
[13:23:26.883]                 old_names <- names(...future.oldEnvVars)
[13:23:26.883]                 envs <- base::Sys.getenv()
[13:23:26.883]                 names <- names(envs)
[13:23:26.883]                 common <- intersect(names, old_names)
[13:23:26.883]                 added <- setdiff(names, old_names)
[13:23:26.883]                 removed <- setdiff(old_names, names)
[13:23:26.883]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.883]                   envs[common]]
[13:23:26.883]                 NAMES <- toupper(changed)
[13:23:26.883]                 args <- list()
[13:23:26.883]                 for (kk in seq_along(NAMES)) {
[13:23:26.883]                   name <- changed[[kk]]
[13:23:26.883]                   NAME <- NAMES[[kk]]
[13:23:26.883]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.883]                     next
[13:23:26.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.883]                 }
[13:23:26.883]                 NAMES <- toupper(added)
[13:23:26.883]                 for (kk in seq_along(NAMES)) {
[13:23:26.883]                   name <- added[[kk]]
[13:23:26.883]                   NAME <- NAMES[[kk]]
[13:23:26.883]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.883]                     next
[13:23:26.883]                   args[[name]] <- ""
[13:23:26.883]                 }
[13:23:26.883]                 NAMES <- toupper(removed)
[13:23:26.883]                 for (kk in seq_along(NAMES)) {
[13:23:26.883]                   name <- removed[[kk]]
[13:23:26.883]                   NAME <- NAMES[[kk]]
[13:23:26.883]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.883]                     next
[13:23:26.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.883]                 }
[13:23:26.883]                 if (length(args) > 0) 
[13:23:26.883]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.883]             }
[13:23:26.883]             else {
[13:23:26.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.883]             }
[13:23:26.883]             {
[13:23:26.883]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.883]                   0L) {
[13:23:26.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.883]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.883]                   base::options(opts)
[13:23:26.883]                 }
[13:23:26.883]                 {
[13:23:26.883]                   {
[13:23:26.883]                     NULL
[13:23:26.883]                     RNGkind("Mersenne-Twister")
[13:23:26.883]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:26.883]                       inherits = FALSE)
[13:23:26.883]                   }
[13:23:26.883]                   options(future.plan = NULL)
[13:23:26.883]                   if (is.na(NA_character_)) 
[13:23:26.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.883]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:26.883]                   {
[13:23:26.883]                     future <- SequentialFuture(..., envir = envir)
[13:23:26.883]                     if (!future$lazy) 
[13:23:26.883]                       future <- run(future)
[13:23:26.883]                     invisible(future)
[13:23:26.883]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.883]                 }
[13:23:26.883]             }
[13:23:26.883]         }
[13:23:26.883]     })
[13:23:26.883]     if (TRUE) {
[13:23:26.883]         base::sink(type = "output", split = FALSE)
[13:23:26.883]         if (TRUE) {
[13:23:26.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.883]         }
[13:23:26.883]         else {
[13:23:26.883]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.883]         }
[13:23:26.883]         base::close(...future.stdout)
[13:23:26.883]         ...future.stdout <- NULL
[13:23:26.883]     }
[13:23:26.883]     ...future.result$conditions <- ...future.conditions
[13:23:26.883]     ...future.result$finished <- base::Sys.time()
[13:23:26.883]     ...future.result
[13:23:26.883] }
[13:23:26.885] assign_globals() ...
[13:23:26.885] List of 2
[13:23:26.885]  $ x   : list()
[13:23:26.885]  $ name: chr "a"
[13:23:26.885]  - attr(*, "where")=List of 2
[13:23:26.885]   ..$ x   :<environment: R_EmptyEnv> 
[13:23:26.885]   ..$ name:<environment: R_EmptyEnv> 
[13:23:26.885]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.885]  - attr(*, "resolved")= logi TRUE
[13:23:26.885]  - attr(*, "total_size")= num 112
[13:23:26.885]  - attr(*, "already-done")= logi TRUE
[13:23:26.888] - copied ‘x’ to environment
[13:23:26.888] - copied ‘name’ to environment
[13:23:26.888] assign_globals() ... done
[13:23:26.888] plan(): Setting new future strategy stack:
[13:23:26.889] List of future strategies:
[13:23:26.889] 1. sequential:
[13:23:26.889]    - args: function (..., envir = parent.frame())
[13:23:26.889]    - tweaked: FALSE
[13:23:26.889]    - call: NULL
[13:23:26.889] plan(): nbrOfWorkers() = 1
[13:23:26.890] plan(): Setting new future strategy stack:
[13:23:26.890] List of future strategies:
[13:23:26.890] 1. sequential:
[13:23:26.890]    - args: function (..., envir = parent.frame())
[13:23:26.890]    - tweaked: FALSE
[13:23:26.890]    - call: plan(strategy)
[13:23:26.890] plan(): nbrOfWorkers() = 1
[13:23:26.890] SequentialFuture started (and completed)
[13:23:26.890] - Launch lazy future ... done
[13:23:26.891] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[13:23:26.900] plan(): Setting new future strategy stack:
[13:23:26.900] List of future strategies:
[13:23:26.900] 1. multicore:
[13:23:26.900]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:26.900]    - tweaked: FALSE
[13:23:26.900]    - call: plan(strategy)
[13:23:26.904] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.904] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.904] Searching for globals...
[13:23:26.908] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.908] Searching for globals ... DONE
[13:23:26.909] Resolving globals: TRUE
[13:23:26.909] Resolving any globals that are futures ...
[13:23:26.909] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.909] Resolving any globals that are futures ... DONE
[13:23:26.909] Resolving futures part of globals (recursively) ...
[13:23:26.910] resolve() on list ...
[13:23:26.910]  recursive: 99
[13:23:26.910]  length: 1
[13:23:26.910]  elements: ‘x’
[13:23:26.910]  length: 0 (resolved future 1)
[13:23:26.910] resolve() on list ... DONE
[13:23:26.910] - globals: [1] ‘x’
[13:23:26.910] Resolving futures part of globals (recursively) ... DONE
[13:23:26.910] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.911] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.911] - globals: [1] ‘x’
[13:23:26.911] 
[13:23:26.911] getGlobalsAndPackages() ... DONE
[13:23:26.911] run() for ‘Future’ ...
[13:23:26.912] - state: ‘created’
[13:23:26.912] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:26.916] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:26.916] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:26.916]   - Field: ‘label’
[13:23:26.916]   - Field: ‘local’
[13:23:26.916]   - Field: ‘owner’
[13:23:26.916]   - Field: ‘envir’
[13:23:26.916]   - Field: ‘workers’
[13:23:26.916]   - Field: ‘packages’
[13:23:26.917]   - Field: ‘gc’
[13:23:26.917]   - Field: ‘job’
[13:23:26.917]   - Field: ‘conditions’
[13:23:26.917]   - Field: ‘expr’
[13:23:26.917]   - Field: ‘uuid’
[13:23:26.917]   - Field: ‘seed’
[13:23:26.917]   - Field: ‘version’
[13:23:26.917]   - Field: ‘result’
[13:23:26.917]   - Field: ‘asynchronous’
[13:23:26.917]   - Field: ‘calls’
[13:23:26.918]   - Field: ‘globals’
[13:23:26.918]   - Field: ‘stdout’
[13:23:26.918]   - Field: ‘earlySignal’
[13:23:26.918]   - Field: ‘lazy’
[13:23:26.918]   - Field: ‘state’
[13:23:26.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:26.918] - Launch lazy future ...
[13:23:26.919] Packages needed by the future expression (n = 0): <none>
[13:23:26.919] Packages needed by future strategies (n = 0): <none>
[13:23:26.920] {
[13:23:26.920]     {
[13:23:26.920]         {
[13:23:26.920]             ...future.startTime <- base::Sys.time()
[13:23:26.920]             {
[13:23:26.920]                 {
[13:23:26.920]                   {
[13:23:26.920]                     {
[13:23:26.920]                       base::local({
[13:23:26.920]                         has_future <- base::requireNamespace("future", 
[13:23:26.920]                           quietly = TRUE)
[13:23:26.920]                         if (has_future) {
[13:23:26.920]                           ns <- base::getNamespace("future")
[13:23:26.920]                           version <- ns[[".package"]][["version"]]
[13:23:26.920]                           if (is.null(version)) 
[13:23:26.920]                             version <- utils::packageVersion("future")
[13:23:26.920]                         }
[13:23:26.920]                         else {
[13:23:26.920]                           version <- NULL
[13:23:26.920]                         }
[13:23:26.920]                         if (!has_future || version < "1.8.0") {
[13:23:26.920]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.920]                             "", base::R.version$version.string), 
[13:23:26.920]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:26.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.920]                               "release", "version")], collapse = " "), 
[13:23:26.920]                             hostname = base::Sys.info()[["nodename"]])
[13:23:26.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.920]                             info)
[13:23:26.920]                           info <- base::paste(info, collapse = "; ")
[13:23:26.920]                           if (!has_future) {
[13:23:26.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.920]                               info)
[13:23:26.920]                           }
[13:23:26.920]                           else {
[13:23:26.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.920]                               info, version)
[13:23:26.920]                           }
[13:23:26.920]                           base::stop(msg)
[13:23:26.920]                         }
[13:23:26.920]                       })
[13:23:26.920]                     }
[13:23:26.920]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:26.920]                     base::options(mc.cores = 1L)
[13:23:26.920]                   }
[13:23:26.920]                   options(future.plan = NULL)
[13:23:26.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.920]                 }
[13:23:26.920]                 ...future.workdir <- getwd()
[13:23:26.920]             }
[13:23:26.920]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.920]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.920]         }
[13:23:26.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.920]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.920]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.920]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.920]             base::names(...future.oldOptions))
[13:23:26.920]     }
[13:23:26.920]     if (FALSE) {
[13:23:26.920]     }
[13:23:26.920]     else {
[13:23:26.920]         if (TRUE) {
[13:23:26.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.920]                 open = "w")
[13:23:26.920]         }
[13:23:26.920]         else {
[13:23:26.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.920]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.920]         }
[13:23:26.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.920]             base::sink(type = "output", split = FALSE)
[13:23:26.920]             base::close(...future.stdout)
[13:23:26.920]         }, add = TRUE)
[13:23:26.920]     }
[13:23:26.920]     ...future.frame <- base::sys.nframe()
[13:23:26.920]     ...future.conditions <- base::list()
[13:23:26.920]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.920]     if (FALSE) {
[13:23:26.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.920]     }
[13:23:26.920]     ...future.result <- base::tryCatch({
[13:23:26.920]         base::withCallingHandlers({
[13:23:26.920]             ...future.value <- base::withVisible(base::local({
[13:23:26.920]                 withCallingHandlers({
[13:23:26.920]                   {
[13:23:26.920]                     x$a <- 1
[13:23:26.920]                     x
[13:23:26.920]                   }
[13:23:26.920]                 }, immediateCondition = function(cond) {
[13:23:26.920]                   save_rds <- function (object, pathname, ...) 
[13:23:26.920]                   {
[13:23:26.920]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:26.920]                     if (file_test("-f", pathname_tmp)) {
[13:23:26.920]                       fi_tmp <- file.info(pathname_tmp)
[13:23:26.920]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:26.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:26.920]                         fi_tmp[["mtime"]])
[13:23:26.920]                     }
[13:23:26.920]                     tryCatch({
[13:23:26.920]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:26.920]                     }, error = function(ex) {
[13:23:26.920]                       msg <- conditionMessage(ex)
[13:23:26.920]                       fi_tmp <- file.info(pathname_tmp)
[13:23:26.920]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:26.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:26.920]                         fi_tmp[["mtime"]], msg)
[13:23:26.920]                       ex$message <- msg
[13:23:26.920]                       stop(ex)
[13:23:26.920]                     })
[13:23:26.920]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:26.920]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:26.920]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:26.920]                       fi_tmp <- file.info(pathname_tmp)
[13:23:26.920]                       fi <- file.info(pathname)
[13:23:26.920]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:26.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:26.920]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:26.920]                         fi[["size"]], fi[["mtime"]])
[13:23:26.920]                       stop(msg)
[13:23:26.920]                     }
[13:23:26.920]                     invisible(pathname)
[13:23:26.920]                   }
[13:23:26.920]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:26.920]                     rootPath = tempdir()) 
[13:23:26.920]                   {
[13:23:26.920]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:26.920]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:26.920]                       tmpdir = path, fileext = ".rds")
[13:23:26.920]                     save_rds(obj, file)
[13:23:26.920]                   }
[13:23:26.920]                   saveImmediateCondition(cond, path = "/tmp/Rtmpxi2rDI/.future/immediateConditions")
[13:23:26.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.920]                   {
[13:23:26.920]                     inherits <- base::inherits
[13:23:26.920]                     invokeRestart <- base::invokeRestart
[13:23:26.920]                     is.null <- base::is.null
[13:23:26.920]                     muffled <- FALSE
[13:23:26.920]                     if (inherits(cond, "message")) {
[13:23:26.920]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:26.920]                       if (muffled) 
[13:23:26.920]                         invokeRestart("muffleMessage")
[13:23:26.920]                     }
[13:23:26.920]                     else if (inherits(cond, "warning")) {
[13:23:26.920]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:26.920]                       if (muffled) 
[13:23:26.920]                         invokeRestart("muffleWarning")
[13:23:26.920]                     }
[13:23:26.920]                     else if (inherits(cond, "condition")) {
[13:23:26.920]                       if (!is.null(pattern)) {
[13:23:26.920]                         computeRestarts <- base::computeRestarts
[13:23:26.920]                         grepl <- base::grepl
[13:23:26.920]                         restarts <- computeRestarts(cond)
[13:23:26.920]                         for (restart in restarts) {
[13:23:26.920]                           name <- restart$name
[13:23:26.920]                           if (is.null(name)) 
[13:23:26.920]                             next
[13:23:26.920]                           if (!grepl(pattern, name)) 
[13:23:26.920]                             next
[13:23:26.920]                           invokeRestart(restart)
[13:23:26.920]                           muffled <- TRUE
[13:23:26.920]                           break
[13:23:26.920]                         }
[13:23:26.920]                       }
[13:23:26.920]                     }
[13:23:26.920]                     invisible(muffled)
[13:23:26.920]                   }
[13:23:26.920]                   muffleCondition(cond)
[13:23:26.920]                 })
[13:23:26.920]             }))
[13:23:26.920]             future::FutureResult(value = ...future.value$value, 
[13:23:26.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.920]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.920]                     ...future.globalenv.names))
[13:23:26.920]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.920]         }, condition = base::local({
[13:23:26.920]             c <- base::c
[13:23:26.920]             inherits <- base::inherits
[13:23:26.920]             invokeRestart <- base::invokeRestart
[13:23:26.920]             length <- base::length
[13:23:26.920]             list <- base::list
[13:23:26.920]             seq.int <- base::seq.int
[13:23:26.920]             signalCondition <- base::signalCondition
[13:23:26.920]             sys.calls <- base::sys.calls
[13:23:26.920]             `[[` <- base::`[[`
[13:23:26.920]             `+` <- base::`+`
[13:23:26.920]             `<<-` <- base::`<<-`
[13:23:26.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.920]                   3L)]
[13:23:26.920]             }
[13:23:26.920]             function(cond) {
[13:23:26.920]                 is_error <- inherits(cond, "error")
[13:23:26.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.920]                   NULL)
[13:23:26.920]                 if (is_error) {
[13:23:26.920]                   sessionInformation <- function() {
[13:23:26.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.920]                       search = base::search(), system = base::Sys.info())
[13:23:26.920]                   }
[13:23:26.920]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.920]                     cond$call), session = sessionInformation(), 
[13:23:26.920]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.920]                   signalCondition(cond)
[13:23:26.920]                 }
[13:23:26.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.920]                 "immediateCondition"))) {
[13:23:26.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.920]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.920]                   if (TRUE && !signal) {
[13:23:26.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.920]                     {
[13:23:26.920]                       inherits <- base::inherits
[13:23:26.920]                       invokeRestart <- base::invokeRestart
[13:23:26.920]                       is.null <- base::is.null
[13:23:26.920]                       muffled <- FALSE
[13:23:26.920]                       if (inherits(cond, "message")) {
[13:23:26.920]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.920]                         if (muffled) 
[13:23:26.920]                           invokeRestart("muffleMessage")
[13:23:26.920]                       }
[13:23:26.920]                       else if (inherits(cond, "warning")) {
[13:23:26.920]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.920]                         if (muffled) 
[13:23:26.920]                           invokeRestart("muffleWarning")
[13:23:26.920]                       }
[13:23:26.920]                       else if (inherits(cond, "condition")) {
[13:23:26.920]                         if (!is.null(pattern)) {
[13:23:26.920]                           computeRestarts <- base::computeRestarts
[13:23:26.920]                           grepl <- base::grepl
[13:23:26.920]                           restarts <- computeRestarts(cond)
[13:23:26.920]                           for (restart in restarts) {
[13:23:26.920]                             name <- restart$name
[13:23:26.920]                             if (is.null(name)) 
[13:23:26.920]                               next
[13:23:26.920]                             if (!grepl(pattern, name)) 
[13:23:26.920]                               next
[13:23:26.920]                             invokeRestart(restart)
[13:23:26.920]                             muffled <- TRUE
[13:23:26.920]                             break
[13:23:26.920]                           }
[13:23:26.920]                         }
[13:23:26.920]                       }
[13:23:26.920]                       invisible(muffled)
[13:23:26.920]                     }
[13:23:26.920]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.920]                   }
[13:23:26.920]                 }
[13:23:26.920]                 else {
[13:23:26.920]                   if (TRUE) {
[13:23:26.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.920]                     {
[13:23:26.920]                       inherits <- base::inherits
[13:23:26.920]                       invokeRestart <- base::invokeRestart
[13:23:26.920]                       is.null <- base::is.null
[13:23:26.920]                       muffled <- FALSE
[13:23:26.920]                       if (inherits(cond, "message")) {
[13:23:26.920]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.920]                         if (muffled) 
[13:23:26.920]                           invokeRestart("muffleMessage")
[13:23:26.920]                       }
[13:23:26.920]                       else if (inherits(cond, "warning")) {
[13:23:26.920]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.920]                         if (muffled) 
[13:23:26.920]                           invokeRestart("muffleWarning")
[13:23:26.920]                       }
[13:23:26.920]                       else if (inherits(cond, "condition")) {
[13:23:26.920]                         if (!is.null(pattern)) {
[13:23:26.920]                           computeRestarts <- base::computeRestarts
[13:23:26.920]                           grepl <- base::grepl
[13:23:26.920]                           restarts <- computeRestarts(cond)
[13:23:26.920]                           for (restart in restarts) {
[13:23:26.920]                             name <- restart$name
[13:23:26.920]                             if (is.null(name)) 
[13:23:26.920]                               next
[13:23:26.920]                             if (!grepl(pattern, name)) 
[13:23:26.920]                               next
[13:23:26.920]                             invokeRestart(restart)
[13:23:26.920]                             muffled <- TRUE
[13:23:26.920]                             break
[13:23:26.920]                           }
[13:23:26.920]                         }
[13:23:26.920]                       }
[13:23:26.920]                       invisible(muffled)
[13:23:26.920]                     }
[13:23:26.920]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.920]                   }
[13:23:26.920]                 }
[13:23:26.920]             }
[13:23:26.920]         }))
[13:23:26.920]     }, error = function(ex) {
[13:23:26.920]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.920]                 ...future.rng), started = ...future.startTime, 
[13:23:26.920]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.920]             version = "1.8"), class = "FutureResult")
[13:23:26.920]     }, finally = {
[13:23:26.920]         if (!identical(...future.workdir, getwd())) 
[13:23:26.920]             setwd(...future.workdir)
[13:23:26.920]         {
[13:23:26.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.920]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.920]             }
[13:23:26.920]             base::options(...future.oldOptions)
[13:23:26.920]             if (.Platform$OS.type == "windows") {
[13:23:26.920]                 old_names <- names(...future.oldEnvVars)
[13:23:26.920]                 envs <- base::Sys.getenv()
[13:23:26.920]                 names <- names(envs)
[13:23:26.920]                 common <- intersect(names, old_names)
[13:23:26.920]                 added <- setdiff(names, old_names)
[13:23:26.920]                 removed <- setdiff(old_names, names)
[13:23:26.920]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.920]                   envs[common]]
[13:23:26.920]                 NAMES <- toupper(changed)
[13:23:26.920]                 args <- list()
[13:23:26.920]                 for (kk in seq_along(NAMES)) {
[13:23:26.920]                   name <- changed[[kk]]
[13:23:26.920]                   NAME <- NAMES[[kk]]
[13:23:26.920]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.920]                     next
[13:23:26.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.920]                 }
[13:23:26.920]                 NAMES <- toupper(added)
[13:23:26.920]                 for (kk in seq_along(NAMES)) {
[13:23:26.920]                   name <- added[[kk]]
[13:23:26.920]                   NAME <- NAMES[[kk]]
[13:23:26.920]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.920]                     next
[13:23:26.920]                   args[[name]] <- ""
[13:23:26.920]                 }
[13:23:26.920]                 NAMES <- toupper(removed)
[13:23:26.920]                 for (kk in seq_along(NAMES)) {
[13:23:26.920]                   name <- removed[[kk]]
[13:23:26.920]                   NAME <- NAMES[[kk]]
[13:23:26.920]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.920]                     next
[13:23:26.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.920]                 }
[13:23:26.920]                 if (length(args) > 0) 
[13:23:26.920]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.920]             }
[13:23:26.920]             else {
[13:23:26.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.920]             }
[13:23:26.920]             {
[13:23:26.920]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.920]                   0L) {
[13:23:26.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.920]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.920]                   base::options(opts)
[13:23:26.920]                 }
[13:23:26.920]                 {
[13:23:26.920]                   {
[13:23:26.920]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:26.920]                     NULL
[13:23:26.920]                   }
[13:23:26.920]                   options(future.plan = NULL)
[13:23:26.920]                   if (is.na(NA_character_)) 
[13:23:26.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.920]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:26.920]                     envir = parent.frame()) 
[13:23:26.920]                   {
[13:23:26.920]                     default_workers <- missing(workers)
[13:23:26.920]                     if (is.function(workers)) 
[13:23:26.920]                       workers <- workers()
[13:23:26.920]                     workers <- structure(as.integer(workers), 
[13:23:26.920]                       class = class(workers))
[13:23:26.920]                     stop_if_not(is.finite(workers), workers >= 
[13:23:26.920]                       1L)
[13:23:26.920]                     if ((workers == 1L && !inherits(workers, 
[13:23:26.920]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:26.920]                       if (default_workers) 
[13:23:26.920]                         supportsMulticore(warn = TRUE)
[13:23:26.920]                       return(sequential(..., envir = envir))
[13:23:26.920]                     }
[13:23:26.920]                     oopts <- options(mc.cores = workers)
[13:23:26.920]                     on.exit(options(oopts))
[13:23:26.920]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:26.920]                       envir = envir)
[13:23:26.920]                     if (!future$lazy) 
[13:23:26.920]                       future <- run(future)
[13:23:26.920]                     invisible(future)
[13:23:26.920]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.920]                 }
[13:23:26.920]             }
[13:23:26.920]         }
[13:23:26.920]     })
[13:23:26.920]     if (TRUE) {
[13:23:26.920]         base::sink(type = "output", split = FALSE)
[13:23:26.920]         if (TRUE) {
[13:23:26.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.920]         }
[13:23:26.920]         else {
[13:23:26.920]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.920]         }
[13:23:26.920]         base::close(...future.stdout)
[13:23:26.920]         ...future.stdout <- NULL
[13:23:26.920]     }
[13:23:26.920]     ...future.result$conditions <- ...future.conditions
[13:23:26.920]     ...future.result$finished <- base::Sys.time()
[13:23:26.920]     ...future.result
[13:23:26.920] }
[13:23:26.922] assign_globals() ...
[13:23:26.922] List of 1
[13:23:26.922]  $ x: list()
[13:23:26.922]  - attr(*, "where")=List of 1
[13:23:26.922]   ..$ x:<environment: R_EmptyEnv> 
[13:23:26.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.922]  - attr(*, "resolved")= logi TRUE
[13:23:26.922]  - attr(*, "total_size")= num 0
[13:23:26.922]  - attr(*, "already-done")= logi TRUE
[13:23:26.925] - copied ‘x’ to environment
[13:23:26.925] assign_globals() ... done
[13:23:26.925] requestCore(): workers = 2
[13:23:26.928] MulticoreFuture started
[13:23:26.929] - Launch lazy future ... done
[13:23:26.929] run() for ‘MulticoreFuture’ ... done
[13:23:26.929] plan(): Setting new future strategy stack:
[13:23:26.929] List of future strategies:
[13:23:26.929] 1. sequential:
[13:23:26.929]    - args: function (..., envir = parent.frame())
[13:23:26.929]    - tweaked: FALSE
[13:23:26.929]    - call: NULL
[13:23:26.930] plan(): nbrOfWorkers() = 1
[13:23:26.930] result() for MulticoreFuture ...
[13:23:26.932] plan(): Setting new future strategy stack:
[13:23:26.932] List of future strategies:
[13:23:26.932] 1. multicore:
[13:23:26.932]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:26.932]    - tweaked: FALSE
[13:23:26.932]    - call: plan(strategy)
[13:23:26.937] plan(): nbrOfWorkers() = 2
[13:23:26.942] result() for MulticoreFuture ...
[13:23:26.942] result() for MulticoreFuture ... done
[13:23:26.943] result() for MulticoreFuture ... done
[13:23:26.943] result() for MulticoreFuture ...
[13:23:26.943] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.943] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.944] Searching for globals...
[13:23:26.946] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.946] Searching for globals ... DONE
[13:23:26.946] Resolving globals: TRUE
[13:23:26.946] Resolving any globals that are futures ...
[13:23:26.947] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.947] Resolving any globals that are futures ... DONE
[13:23:26.947] Resolving futures part of globals (recursively) ...
[13:23:26.948] resolve() on list ...
[13:23:26.948]  recursive: 99
[13:23:26.948]  length: 1
[13:23:26.948]  elements: ‘x’
[13:23:26.948]  length: 0 (resolved future 1)
[13:23:26.948] resolve() on list ... DONE
[13:23:26.948] - globals: [1] ‘x’
[13:23:26.948] Resolving futures part of globals (recursively) ... DONE
[13:23:26.949] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.949] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.949] - globals: [1] ‘x’
[13:23:26.949] 
[13:23:26.949] getGlobalsAndPackages() ... DONE
[13:23:26.950] run() for ‘Future’ ...
[13:23:26.950] - state: ‘created’
[13:23:26.950] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:26.955] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:26.955] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:26.955]   - Field: ‘label’
[13:23:26.955]   - Field: ‘local’
[13:23:26.956]   - Field: ‘owner’
[13:23:26.956]   - Field: ‘envir’
[13:23:26.956]   - Field: ‘workers’
[13:23:26.956]   - Field: ‘packages’
[13:23:26.956]   - Field: ‘gc’
[13:23:26.959]   - Field: ‘job’
[13:23:26.959]   - Field: ‘conditions’
[13:23:26.959]   - Field: ‘expr’
[13:23:26.959]   - Field: ‘uuid’
[13:23:26.959]   - Field: ‘seed’
[13:23:26.960]   - Field: ‘version’
[13:23:26.960]   - Field: ‘result’
[13:23:26.960]   - Field: ‘asynchronous’
[13:23:26.960]   - Field: ‘calls’
[13:23:26.960]   - Field: ‘globals’
[13:23:26.960]   - Field: ‘stdout’
[13:23:26.960]   - Field: ‘earlySignal’
[13:23:26.961]   - Field: ‘lazy’
[13:23:26.961]   - Field: ‘state’
[13:23:26.961] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:26.961] - Launch lazy future ...
[13:23:26.961] Packages needed by the future expression (n = 0): <none>
[13:23:26.962] Packages needed by future strategies (n = 0): <none>
[13:23:26.962] {
[13:23:26.962]     {
[13:23:26.962]         {
[13:23:26.962]             ...future.startTime <- base::Sys.time()
[13:23:26.962]             {
[13:23:26.962]                 {
[13:23:26.962]                   {
[13:23:26.962]                     {
[13:23:26.962]                       base::local({
[13:23:26.962]                         has_future <- base::requireNamespace("future", 
[13:23:26.962]                           quietly = TRUE)
[13:23:26.962]                         if (has_future) {
[13:23:26.962]                           ns <- base::getNamespace("future")
[13:23:26.962]                           version <- ns[[".package"]][["version"]]
[13:23:26.962]                           if (is.null(version)) 
[13:23:26.962]                             version <- utils::packageVersion("future")
[13:23:26.962]                         }
[13:23:26.962]                         else {
[13:23:26.962]                           version <- NULL
[13:23:26.962]                         }
[13:23:26.962]                         if (!has_future || version < "1.8.0") {
[13:23:26.962]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.962]                             "", base::R.version$version.string), 
[13:23:26.962]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:26.962]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.962]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.962]                               "release", "version")], collapse = " "), 
[13:23:26.962]                             hostname = base::Sys.info()[["nodename"]])
[13:23:26.962]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.962]                             info)
[13:23:26.962]                           info <- base::paste(info, collapse = "; ")
[13:23:26.962]                           if (!has_future) {
[13:23:26.962]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.962]                               info)
[13:23:26.962]                           }
[13:23:26.962]                           else {
[13:23:26.962]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.962]                               info, version)
[13:23:26.962]                           }
[13:23:26.962]                           base::stop(msg)
[13:23:26.962]                         }
[13:23:26.962]                       })
[13:23:26.962]                     }
[13:23:26.962]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:26.962]                     base::options(mc.cores = 1L)
[13:23:26.962]                   }
[13:23:26.962]                   options(future.plan = NULL)
[13:23:26.962]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.962]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.962]                 }
[13:23:26.962]                 ...future.workdir <- getwd()
[13:23:26.962]             }
[13:23:26.962]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.962]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.962]         }
[13:23:26.962]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.962]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.962]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.962]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.962]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.962]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.962]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.962]             base::names(...future.oldOptions))
[13:23:26.962]     }
[13:23:26.962]     if (FALSE) {
[13:23:26.962]     }
[13:23:26.962]     else {
[13:23:26.962]         if (TRUE) {
[13:23:26.962]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.962]                 open = "w")
[13:23:26.962]         }
[13:23:26.962]         else {
[13:23:26.962]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.962]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.962]         }
[13:23:26.962]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.962]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.962]             base::sink(type = "output", split = FALSE)
[13:23:26.962]             base::close(...future.stdout)
[13:23:26.962]         }, add = TRUE)
[13:23:26.962]     }
[13:23:26.962]     ...future.frame <- base::sys.nframe()
[13:23:26.962]     ...future.conditions <- base::list()
[13:23:26.962]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.962]     if (FALSE) {
[13:23:26.962]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.962]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.962]     }
[13:23:26.962]     ...future.result <- base::tryCatch({
[13:23:26.962]         base::withCallingHandlers({
[13:23:26.962]             ...future.value <- base::withVisible(base::local({
[13:23:26.962]                 withCallingHandlers({
[13:23:26.962]                   {
[13:23:26.962]                     x$a <- 1
[13:23:26.962]                     x
[13:23:26.962]                   }
[13:23:26.962]                 }, immediateCondition = function(cond) {
[13:23:26.962]                   save_rds <- function (object, pathname, ...) 
[13:23:26.962]                   {
[13:23:26.962]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:26.962]                     if (file_test("-f", pathname_tmp)) {
[13:23:26.962]                       fi_tmp <- file.info(pathname_tmp)
[13:23:26.962]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:26.962]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:26.962]                         fi_tmp[["mtime"]])
[13:23:26.962]                     }
[13:23:26.962]                     tryCatch({
[13:23:26.962]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:26.962]                     }, error = function(ex) {
[13:23:26.962]                       msg <- conditionMessage(ex)
[13:23:26.962]                       fi_tmp <- file.info(pathname_tmp)
[13:23:26.962]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:26.962]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:26.962]                         fi_tmp[["mtime"]], msg)
[13:23:26.962]                       ex$message <- msg
[13:23:26.962]                       stop(ex)
[13:23:26.962]                     })
[13:23:26.962]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:26.962]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:26.962]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:26.962]                       fi_tmp <- file.info(pathname_tmp)
[13:23:26.962]                       fi <- file.info(pathname)
[13:23:26.962]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:26.962]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:26.962]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:26.962]                         fi[["size"]], fi[["mtime"]])
[13:23:26.962]                       stop(msg)
[13:23:26.962]                     }
[13:23:26.962]                     invisible(pathname)
[13:23:26.962]                   }
[13:23:26.962]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:26.962]                     rootPath = tempdir()) 
[13:23:26.962]                   {
[13:23:26.962]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:26.962]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:26.962]                       tmpdir = path, fileext = ".rds")
[13:23:26.962]                     save_rds(obj, file)
[13:23:26.962]                   }
[13:23:26.962]                   saveImmediateCondition(cond, path = "/tmp/Rtmpxi2rDI/.future/immediateConditions")
[13:23:26.962]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.962]                   {
[13:23:26.962]                     inherits <- base::inherits
[13:23:26.962]                     invokeRestart <- base::invokeRestart
[13:23:26.962]                     is.null <- base::is.null
[13:23:26.962]                     muffled <- FALSE
[13:23:26.962]                     if (inherits(cond, "message")) {
[13:23:26.962]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:26.962]                       if (muffled) 
[13:23:26.962]                         invokeRestart("muffleMessage")
[13:23:26.962]                     }
[13:23:26.962]                     else if (inherits(cond, "warning")) {
[13:23:26.962]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:26.962]                       if (muffled) 
[13:23:26.962]                         invokeRestart("muffleWarning")
[13:23:26.962]                     }
[13:23:26.962]                     else if (inherits(cond, "condition")) {
[13:23:26.962]                       if (!is.null(pattern)) {
[13:23:26.962]                         computeRestarts <- base::computeRestarts
[13:23:26.962]                         grepl <- base::grepl
[13:23:26.962]                         restarts <- computeRestarts(cond)
[13:23:26.962]                         for (restart in restarts) {
[13:23:26.962]                           name <- restart$name
[13:23:26.962]                           if (is.null(name)) 
[13:23:26.962]                             next
[13:23:26.962]                           if (!grepl(pattern, name)) 
[13:23:26.962]                             next
[13:23:26.962]                           invokeRestart(restart)
[13:23:26.962]                           muffled <- TRUE
[13:23:26.962]                           break
[13:23:26.962]                         }
[13:23:26.962]                       }
[13:23:26.962]                     }
[13:23:26.962]                     invisible(muffled)
[13:23:26.962]                   }
[13:23:26.962]                   muffleCondition(cond)
[13:23:26.962]                 })
[13:23:26.962]             }))
[13:23:26.962]             future::FutureResult(value = ...future.value$value, 
[13:23:26.962]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.962]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.962]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.962]                     ...future.globalenv.names))
[13:23:26.962]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.962]         }, condition = base::local({
[13:23:26.962]             c <- base::c
[13:23:26.962]             inherits <- base::inherits
[13:23:26.962]             invokeRestart <- base::invokeRestart
[13:23:26.962]             length <- base::length
[13:23:26.962]             list <- base::list
[13:23:26.962]             seq.int <- base::seq.int
[13:23:26.962]             signalCondition <- base::signalCondition
[13:23:26.962]             sys.calls <- base::sys.calls
[13:23:26.962]             `[[` <- base::`[[`
[13:23:26.962]             `+` <- base::`+`
[13:23:26.962]             `<<-` <- base::`<<-`
[13:23:26.962]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.962]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.962]                   3L)]
[13:23:26.962]             }
[13:23:26.962]             function(cond) {
[13:23:26.962]                 is_error <- inherits(cond, "error")
[13:23:26.962]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.962]                   NULL)
[13:23:26.962]                 if (is_error) {
[13:23:26.962]                   sessionInformation <- function() {
[13:23:26.962]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.962]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.962]                       search = base::search(), system = base::Sys.info())
[13:23:26.962]                   }
[13:23:26.962]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.962]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.962]                     cond$call), session = sessionInformation(), 
[13:23:26.962]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.962]                   signalCondition(cond)
[13:23:26.962]                 }
[13:23:26.962]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.962]                 "immediateCondition"))) {
[13:23:26.962]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.962]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.962]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.962]                   if (TRUE && !signal) {
[13:23:26.962]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.962]                     {
[13:23:26.962]                       inherits <- base::inherits
[13:23:26.962]                       invokeRestart <- base::invokeRestart
[13:23:26.962]                       is.null <- base::is.null
[13:23:26.962]                       muffled <- FALSE
[13:23:26.962]                       if (inherits(cond, "message")) {
[13:23:26.962]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.962]                         if (muffled) 
[13:23:26.962]                           invokeRestart("muffleMessage")
[13:23:26.962]                       }
[13:23:26.962]                       else if (inherits(cond, "warning")) {
[13:23:26.962]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.962]                         if (muffled) 
[13:23:26.962]                           invokeRestart("muffleWarning")
[13:23:26.962]                       }
[13:23:26.962]                       else if (inherits(cond, "condition")) {
[13:23:26.962]                         if (!is.null(pattern)) {
[13:23:26.962]                           computeRestarts <- base::computeRestarts
[13:23:26.962]                           grepl <- base::grepl
[13:23:26.962]                           restarts <- computeRestarts(cond)
[13:23:26.962]                           for (restart in restarts) {
[13:23:26.962]                             name <- restart$name
[13:23:26.962]                             if (is.null(name)) 
[13:23:26.962]                               next
[13:23:26.962]                             if (!grepl(pattern, name)) 
[13:23:26.962]                               next
[13:23:26.962]                             invokeRestart(restart)
[13:23:26.962]                             muffled <- TRUE
[13:23:26.962]                             break
[13:23:26.962]                           }
[13:23:26.962]                         }
[13:23:26.962]                       }
[13:23:26.962]                       invisible(muffled)
[13:23:26.962]                     }
[13:23:26.962]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.962]                   }
[13:23:26.962]                 }
[13:23:26.962]                 else {
[13:23:26.962]                   if (TRUE) {
[13:23:26.962]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.962]                     {
[13:23:26.962]                       inherits <- base::inherits
[13:23:26.962]                       invokeRestart <- base::invokeRestart
[13:23:26.962]                       is.null <- base::is.null
[13:23:26.962]                       muffled <- FALSE
[13:23:26.962]                       if (inherits(cond, "message")) {
[13:23:26.962]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.962]                         if (muffled) 
[13:23:26.962]                           invokeRestart("muffleMessage")
[13:23:26.962]                       }
[13:23:26.962]                       else if (inherits(cond, "warning")) {
[13:23:26.962]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.962]                         if (muffled) 
[13:23:26.962]                           invokeRestart("muffleWarning")
[13:23:26.962]                       }
[13:23:26.962]                       else if (inherits(cond, "condition")) {
[13:23:26.962]                         if (!is.null(pattern)) {
[13:23:26.962]                           computeRestarts <- base::computeRestarts
[13:23:26.962]                           grepl <- base::grepl
[13:23:26.962]                           restarts <- computeRestarts(cond)
[13:23:26.962]                           for (restart in restarts) {
[13:23:26.962]                             name <- restart$name
[13:23:26.962]                             if (is.null(name)) 
[13:23:26.962]                               next
[13:23:26.962]                             if (!grepl(pattern, name)) 
[13:23:26.962]                               next
[13:23:26.962]                             invokeRestart(restart)
[13:23:26.962]                             muffled <- TRUE
[13:23:26.962]                             break
[13:23:26.962]                           }
[13:23:26.962]                         }
[13:23:26.962]                       }
[13:23:26.962]                       invisible(muffled)
[13:23:26.962]                     }
[13:23:26.962]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.962]                   }
[13:23:26.962]                 }
[13:23:26.962]             }
[13:23:26.962]         }))
[13:23:26.962]     }, error = function(ex) {
[13:23:26.962]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.962]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.962]                 ...future.rng), started = ...future.startTime, 
[13:23:26.962]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.962]             version = "1.8"), class = "FutureResult")
[13:23:26.962]     }, finally = {
[13:23:26.962]         if (!identical(...future.workdir, getwd())) 
[13:23:26.962]             setwd(...future.workdir)
[13:23:26.962]         {
[13:23:26.962]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.962]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.962]             }
[13:23:26.962]             base::options(...future.oldOptions)
[13:23:26.962]             if (.Platform$OS.type == "windows") {
[13:23:26.962]                 old_names <- names(...future.oldEnvVars)
[13:23:26.962]                 envs <- base::Sys.getenv()
[13:23:26.962]                 names <- names(envs)
[13:23:26.962]                 common <- intersect(names, old_names)
[13:23:26.962]                 added <- setdiff(names, old_names)
[13:23:26.962]                 removed <- setdiff(old_names, names)
[13:23:26.962]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.962]                   envs[common]]
[13:23:26.962]                 NAMES <- toupper(changed)
[13:23:26.962]                 args <- list()
[13:23:26.962]                 for (kk in seq_along(NAMES)) {
[13:23:26.962]                   name <- changed[[kk]]
[13:23:26.962]                   NAME <- NAMES[[kk]]
[13:23:26.962]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.962]                     next
[13:23:26.962]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.962]                 }
[13:23:26.962]                 NAMES <- toupper(added)
[13:23:26.962]                 for (kk in seq_along(NAMES)) {
[13:23:26.962]                   name <- added[[kk]]
[13:23:26.962]                   NAME <- NAMES[[kk]]
[13:23:26.962]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.962]                     next
[13:23:26.962]                   args[[name]] <- ""
[13:23:26.962]                 }
[13:23:26.962]                 NAMES <- toupper(removed)
[13:23:26.962]                 for (kk in seq_along(NAMES)) {
[13:23:26.962]                   name <- removed[[kk]]
[13:23:26.962]                   NAME <- NAMES[[kk]]
[13:23:26.962]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.962]                     next
[13:23:26.962]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.962]                 }
[13:23:26.962]                 if (length(args) > 0) 
[13:23:26.962]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.962]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.962]             }
[13:23:26.962]             else {
[13:23:26.962]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.962]             }
[13:23:26.962]             {
[13:23:26.962]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.962]                   0L) {
[13:23:26.962]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.962]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.962]                   base::options(opts)
[13:23:26.962]                 }
[13:23:26.962]                 {
[13:23:26.962]                   {
[13:23:26.962]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:26.962]                     NULL
[13:23:26.962]                   }
[13:23:26.962]                   options(future.plan = NULL)
[13:23:26.962]                   if (is.na(NA_character_)) 
[13:23:26.962]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.962]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.962]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:26.962]                     envir = parent.frame()) 
[13:23:26.962]                   {
[13:23:26.962]                     default_workers <- missing(workers)
[13:23:26.962]                     if (is.function(workers)) 
[13:23:26.962]                       workers <- workers()
[13:23:26.962]                     workers <- structure(as.integer(workers), 
[13:23:26.962]                       class = class(workers))
[13:23:26.962]                     stop_if_not(is.finite(workers), workers >= 
[13:23:26.962]                       1L)
[13:23:26.962]                     if ((workers == 1L && !inherits(workers, 
[13:23:26.962]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:26.962]                       if (default_workers) 
[13:23:26.962]                         supportsMulticore(warn = TRUE)
[13:23:26.962]                       return(sequential(..., envir = envir))
[13:23:26.962]                     }
[13:23:26.962]                     oopts <- options(mc.cores = workers)
[13:23:26.962]                     on.exit(options(oopts))
[13:23:26.962]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:26.962]                       envir = envir)
[13:23:26.962]                     if (!future$lazy) 
[13:23:26.962]                       future <- run(future)
[13:23:26.962]                     invisible(future)
[13:23:26.962]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.962]                 }
[13:23:26.962]             }
[13:23:26.962]         }
[13:23:26.962]     })
[13:23:26.962]     if (TRUE) {
[13:23:26.962]         base::sink(type = "output", split = FALSE)
[13:23:26.962]         if (TRUE) {
[13:23:26.962]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.962]         }
[13:23:26.962]         else {
[13:23:26.962]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.962]         }
[13:23:26.962]         base::close(...future.stdout)
[13:23:26.962]         ...future.stdout <- NULL
[13:23:26.962]     }
[13:23:26.962]     ...future.result$conditions <- ...future.conditions
[13:23:26.962]     ...future.result$finished <- base::Sys.time()
[13:23:26.962]     ...future.result
[13:23:26.962] }
[13:23:26.965] assign_globals() ...
[13:23:26.965] List of 1
[13:23:26.965]  $ x: list()
[13:23:26.965]  - attr(*, "where")=List of 1
[13:23:26.965]   ..$ x:<environment: R_EmptyEnv> 
[13:23:26.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:26.965]  - attr(*, "resolved")= logi TRUE
[13:23:26.965]  - attr(*, "total_size")= num 0
[13:23:26.965]  - attr(*, "already-done")= logi TRUE
[13:23:26.968] - copied ‘x’ to environment
[13:23:26.968] assign_globals() ... done
[13:23:26.968] requestCore(): workers = 2
[13:23:26.971] MulticoreFuture started
[13:23:26.971] - Launch lazy future ... done
[13:23:26.971] run() for ‘MulticoreFuture’ ... done
[13:23:26.971] result() for MulticoreFuture ...
[13:23:26.972] plan(): Setting new future strategy stack:
[13:23:26.972] List of future strategies:
[13:23:26.972] 1. sequential:
[13:23:26.972]    - args: function (..., envir = parent.frame())
[13:23:26.972]    - tweaked: FALSE
[13:23:26.972]    - call: NULL
[13:23:26.973] plan(): nbrOfWorkers() = 1
[13:23:26.975] plan(): Setting new future strategy stack:
[13:23:26.975] List of future strategies:
[13:23:26.975] 1. multicore:
[13:23:26.975]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:26.975]    - tweaked: FALSE
[13:23:26.975]    - call: plan(strategy)
[13:23:26.981] plan(): nbrOfWorkers() = 2
[13:23:26.982] result() for MulticoreFuture ...
[13:23:26.982] result() for MulticoreFuture ... done
[13:23:26.982] result() for MulticoreFuture ... done
[13:23:26.982] result() for MulticoreFuture ...
[13:23:26.983] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:26.983] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:26.984] Searching for globals...
[13:23:26.986] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.987] Searching for globals ... DONE
[13:23:26.987] Resolving globals: TRUE
[13:23:26.987] Resolving any globals that are futures ...
[13:23:26.987] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:26.987] Resolving any globals that are futures ... DONE
[13:23:26.988] Resolving futures part of globals (recursively) ...
[13:23:26.988] resolve() on list ...
[13:23:26.988]  recursive: 99
[13:23:26.988]  length: 1
[13:23:26.988]  elements: ‘x’
[13:23:26.989]  length: 0 (resolved future 1)
[13:23:26.989] resolve() on list ... DONE
[13:23:26.989] - globals: [1] ‘x’
[13:23:26.989] Resolving futures part of globals (recursively) ... DONE
[13:23:26.989] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:26.990] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:26.990] - globals: [1] ‘x’
[13:23:26.990] 
[13:23:26.990] getGlobalsAndPackages() ... DONE
[13:23:26.990] run() for ‘Future’ ...
[13:23:26.991] - state: ‘created’
[13:23:26.991] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:26.995] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:26.995] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:26.995]   - Field: ‘label’
[13:23:26.996]   - Field: ‘local’
[13:23:26.996]   - Field: ‘owner’
[13:23:26.996]   - Field: ‘envir’
[13:23:26.996]   - Field: ‘workers’
[13:23:26.996]   - Field: ‘packages’
[13:23:26.996]   - Field: ‘gc’
[13:23:26.996]   - Field: ‘job’
[13:23:26.996]   - Field: ‘conditions’
[13:23:26.997]   - Field: ‘expr’
[13:23:26.997]   - Field: ‘uuid’
[13:23:26.997]   - Field: ‘seed’
[13:23:26.997]   - Field: ‘version’
[13:23:26.997]   - Field: ‘result’
[13:23:26.997]   - Field: ‘asynchronous’
[13:23:26.997]   - Field: ‘calls’
[13:23:26.997]   - Field: ‘globals’
[13:23:26.997]   - Field: ‘stdout’
[13:23:26.998]   - Field: ‘earlySignal’
[13:23:26.998]   - Field: ‘lazy’
[13:23:26.998]   - Field: ‘state’
[13:23:26.998] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:26.998] - Launch lazy future ...
[13:23:26.998] Packages needed by the future expression (n = 0): <none>
[13:23:26.999] Packages needed by future strategies (n = 0): <none>
[13:23:26.999] {
[13:23:26.999]     {
[13:23:26.999]         {
[13:23:26.999]             ...future.startTime <- base::Sys.time()
[13:23:26.999]             {
[13:23:26.999]                 {
[13:23:26.999]                   {
[13:23:26.999]                     {
[13:23:26.999]                       base::local({
[13:23:26.999]                         has_future <- base::requireNamespace("future", 
[13:23:26.999]                           quietly = TRUE)
[13:23:26.999]                         if (has_future) {
[13:23:26.999]                           ns <- base::getNamespace("future")
[13:23:26.999]                           version <- ns[[".package"]][["version"]]
[13:23:26.999]                           if (is.null(version)) 
[13:23:26.999]                             version <- utils::packageVersion("future")
[13:23:26.999]                         }
[13:23:26.999]                         else {
[13:23:26.999]                           version <- NULL
[13:23:26.999]                         }
[13:23:26.999]                         if (!has_future || version < "1.8.0") {
[13:23:26.999]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:26.999]                             "", base::R.version$version.string), 
[13:23:26.999]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:26.999]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:26.999]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:26.999]                               "release", "version")], collapse = " "), 
[13:23:26.999]                             hostname = base::Sys.info()[["nodename"]])
[13:23:26.999]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:26.999]                             info)
[13:23:26.999]                           info <- base::paste(info, collapse = "; ")
[13:23:26.999]                           if (!has_future) {
[13:23:26.999]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:26.999]                               info)
[13:23:26.999]                           }
[13:23:26.999]                           else {
[13:23:26.999]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:26.999]                               info, version)
[13:23:26.999]                           }
[13:23:26.999]                           base::stop(msg)
[13:23:26.999]                         }
[13:23:26.999]                       })
[13:23:26.999]                     }
[13:23:26.999]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:26.999]                     base::options(mc.cores = 1L)
[13:23:26.999]                   }
[13:23:26.999]                   options(future.plan = NULL)
[13:23:26.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:26.999]                 }
[13:23:26.999]                 ...future.workdir <- getwd()
[13:23:26.999]             }
[13:23:26.999]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:26.999]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:26.999]         }
[13:23:26.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:26.999]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:26.999]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:26.999]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:26.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:26.999]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:26.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:26.999]             base::names(...future.oldOptions))
[13:23:26.999]     }
[13:23:26.999]     if (FALSE) {
[13:23:26.999]     }
[13:23:26.999]     else {
[13:23:26.999]         if (TRUE) {
[13:23:26.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:26.999]                 open = "w")
[13:23:26.999]         }
[13:23:26.999]         else {
[13:23:26.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:26.999]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:26.999]         }
[13:23:26.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:26.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:26.999]             base::sink(type = "output", split = FALSE)
[13:23:26.999]             base::close(...future.stdout)
[13:23:26.999]         }, add = TRUE)
[13:23:26.999]     }
[13:23:26.999]     ...future.frame <- base::sys.nframe()
[13:23:26.999]     ...future.conditions <- base::list()
[13:23:26.999]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:26.999]     if (FALSE) {
[13:23:26.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:26.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:26.999]     }
[13:23:26.999]     ...future.result <- base::tryCatch({
[13:23:26.999]         base::withCallingHandlers({
[13:23:26.999]             ...future.value <- base::withVisible(base::local({
[13:23:26.999]                 withCallingHandlers({
[13:23:26.999]                   {
[13:23:26.999]                     x$a <- 1
[13:23:26.999]                     x
[13:23:26.999]                   }
[13:23:26.999]                 }, immediateCondition = function(cond) {
[13:23:26.999]                   save_rds <- function (object, pathname, ...) 
[13:23:26.999]                   {
[13:23:26.999]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:26.999]                     if (file_test("-f", pathname_tmp)) {
[13:23:26.999]                       fi_tmp <- file.info(pathname_tmp)
[13:23:26.999]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:26.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:26.999]                         fi_tmp[["mtime"]])
[13:23:26.999]                     }
[13:23:26.999]                     tryCatch({
[13:23:26.999]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:26.999]                     }, error = function(ex) {
[13:23:26.999]                       msg <- conditionMessage(ex)
[13:23:26.999]                       fi_tmp <- file.info(pathname_tmp)
[13:23:26.999]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:26.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:26.999]                         fi_tmp[["mtime"]], msg)
[13:23:26.999]                       ex$message <- msg
[13:23:26.999]                       stop(ex)
[13:23:26.999]                     })
[13:23:26.999]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:26.999]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:26.999]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:26.999]                       fi_tmp <- file.info(pathname_tmp)
[13:23:26.999]                       fi <- file.info(pathname)
[13:23:26.999]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:26.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:26.999]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:26.999]                         fi[["size"]], fi[["mtime"]])
[13:23:26.999]                       stop(msg)
[13:23:26.999]                     }
[13:23:26.999]                     invisible(pathname)
[13:23:26.999]                   }
[13:23:26.999]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:26.999]                     rootPath = tempdir()) 
[13:23:26.999]                   {
[13:23:26.999]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:26.999]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:26.999]                       tmpdir = path, fileext = ".rds")
[13:23:26.999]                     save_rds(obj, file)
[13:23:26.999]                   }
[13:23:26.999]                   saveImmediateCondition(cond, path = "/tmp/Rtmpxi2rDI/.future/immediateConditions")
[13:23:26.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.999]                   {
[13:23:26.999]                     inherits <- base::inherits
[13:23:26.999]                     invokeRestart <- base::invokeRestart
[13:23:26.999]                     is.null <- base::is.null
[13:23:26.999]                     muffled <- FALSE
[13:23:26.999]                     if (inherits(cond, "message")) {
[13:23:26.999]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:26.999]                       if (muffled) 
[13:23:26.999]                         invokeRestart("muffleMessage")
[13:23:26.999]                     }
[13:23:26.999]                     else if (inherits(cond, "warning")) {
[13:23:26.999]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:26.999]                       if (muffled) 
[13:23:26.999]                         invokeRestart("muffleWarning")
[13:23:26.999]                     }
[13:23:26.999]                     else if (inherits(cond, "condition")) {
[13:23:26.999]                       if (!is.null(pattern)) {
[13:23:26.999]                         computeRestarts <- base::computeRestarts
[13:23:26.999]                         grepl <- base::grepl
[13:23:26.999]                         restarts <- computeRestarts(cond)
[13:23:26.999]                         for (restart in restarts) {
[13:23:26.999]                           name <- restart$name
[13:23:26.999]                           if (is.null(name)) 
[13:23:26.999]                             next
[13:23:26.999]                           if (!grepl(pattern, name)) 
[13:23:26.999]                             next
[13:23:26.999]                           invokeRestart(restart)
[13:23:26.999]                           muffled <- TRUE
[13:23:26.999]                           break
[13:23:26.999]                         }
[13:23:26.999]                       }
[13:23:26.999]                     }
[13:23:26.999]                     invisible(muffled)
[13:23:26.999]                   }
[13:23:26.999]                   muffleCondition(cond)
[13:23:26.999]                 })
[13:23:26.999]             }))
[13:23:26.999]             future::FutureResult(value = ...future.value$value, 
[13:23:26.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.999]                   ...future.rng), globalenv = if (FALSE) 
[13:23:26.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:26.999]                     ...future.globalenv.names))
[13:23:26.999]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:26.999]         }, condition = base::local({
[13:23:26.999]             c <- base::c
[13:23:26.999]             inherits <- base::inherits
[13:23:26.999]             invokeRestart <- base::invokeRestart
[13:23:26.999]             length <- base::length
[13:23:26.999]             list <- base::list
[13:23:26.999]             seq.int <- base::seq.int
[13:23:26.999]             signalCondition <- base::signalCondition
[13:23:26.999]             sys.calls <- base::sys.calls
[13:23:26.999]             `[[` <- base::`[[`
[13:23:26.999]             `+` <- base::`+`
[13:23:26.999]             `<<-` <- base::`<<-`
[13:23:26.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:26.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:26.999]                   3L)]
[13:23:26.999]             }
[13:23:26.999]             function(cond) {
[13:23:26.999]                 is_error <- inherits(cond, "error")
[13:23:26.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:26.999]                   NULL)
[13:23:26.999]                 if (is_error) {
[13:23:26.999]                   sessionInformation <- function() {
[13:23:26.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:26.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:26.999]                       search = base::search(), system = base::Sys.info())
[13:23:26.999]                   }
[13:23:26.999]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:26.999]                     cond$call), session = sessionInformation(), 
[13:23:26.999]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:26.999]                   signalCondition(cond)
[13:23:26.999]                 }
[13:23:26.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:26.999]                 "immediateCondition"))) {
[13:23:26.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:26.999]                   ...future.conditions[[length(...future.conditions) + 
[13:23:26.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:26.999]                   if (TRUE && !signal) {
[13:23:26.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.999]                     {
[13:23:26.999]                       inherits <- base::inherits
[13:23:26.999]                       invokeRestart <- base::invokeRestart
[13:23:26.999]                       is.null <- base::is.null
[13:23:26.999]                       muffled <- FALSE
[13:23:26.999]                       if (inherits(cond, "message")) {
[13:23:26.999]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.999]                         if (muffled) 
[13:23:26.999]                           invokeRestart("muffleMessage")
[13:23:26.999]                       }
[13:23:26.999]                       else if (inherits(cond, "warning")) {
[13:23:26.999]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.999]                         if (muffled) 
[13:23:26.999]                           invokeRestart("muffleWarning")
[13:23:26.999]                       }
[13:23:26.999]                       else if (inherits(cond, "condition")) {
[13:23:26.999]                         if (!is.null(pattern)) {
[13:23:26.999]                           computeRestarts <- base::computeRestarts
[13:23:26.999]                           grepl <- base::grepl
[13:23:26.999]                           restarts <- computeRestarts(cond)
[13:23:26.999]                           for (restart in restarts) {
[13:23:26.999]                             name <- restart$name
[13:23:26.999]                             if (is.null(name)) 
[13:23:26.999]                               next
[13:23:26.999]                             if (!grepl(pattern, name)) 
[13:23:26.999]                               next
[13:23:26.999]                             invokeRestart(restart)
[13:23:26.999]                             muffled <- TRUE
[13:23:26.999]                             break
[13:23:26.999]                           }
[13:23:26.999]                         }
[13:23:26.999]                       }
[13:23:26.999]                       invisible(muffled)
[13:23:26.999]                     }
[13:23:26.999]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.999]                   }
[13:23:26.999]                 }
[13:23:26.999]                 else {
[13:23:26.999]                   if (TRUE) {
[13:23:26.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:26.999]                     {
[13:23:26.999]                       inherits <- base::inherits
[13:23:26.999]                       invokeRestart <- base::invokeRestart
[13:23:26.999]                       is.null <- base::is.null
[13:23:26.999]                       muffled <- FALSE
[13:23:26.999]                       if (inherits(cond, "message")) {
[13:23:26.999]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:26.999]                         if (muffled) 
[13:23:26.999]                           invokeRestart("muffleMessage")
[13:23:26.999]                       }
[13:23:26.999]                       else if (inherits(cond, "warning")) {
[13:23:26.999]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:26.999]                         if (muffled) 
[13:23:26.999]                           invokeRestart("muffleWarning")
[13:23:26.999]                       }
[13:23:26.999]                       else if (inherits(cond, "condition")) {
[13:23:26.999]                         if (!is.null(pattern)) {
[13:23:26.999]                           computeRestarts <- base::computeRestarts
[13:23:26.999]                           grepl <- base::grepl
[13:23:26.999]                           restarts <- computeRestarts(cond)
[13:23:26.999]                           for (restart in restarts) {
[13:23:26.999]                             name <- restart$name
[13:23:26.999]                             if (is.null(name)) 
[13:23:26.999]                               next
[13:23:26.999]                             if (!grepl(pattern, name)) 
[13:23:26.999]                               next
[13:23:26.999]                             invokeRestart(restart)
[13:23:26.999]                             muffled <- TRUE
[13:23:26.999]                             break
[13:23:26.999]                           }
[13:23:26.999]                         }
[13:23:26.999]                       }
[13:23:26.999]                       invisible(muffled)
[13:23:26.999]                     }
[13:23:26.999]                     muffleCondition(cond, pattern = "^muffle")
[13:23:26.999]                   }
[13:23:26.999]                 }
[13:23:26.999]             }
[13:23:26.999]         }))
[13:23:26.999]     }, error = function(ex) {
[13:23:26.999]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:26.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:26.999]                 ...future.rng), started = ...future.startTime, 
[13:23:26.999]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:26.999]             version = "1.8"), class = "FutureResult")
[13:23:26.999]     }, finally = {
[13:23:26.999]         if (!identical(...future.workdir, getwd())) 
[13:23:26.999]             setwd(...future.workdir)
[13:23:26.999]         {
[13:23:26.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:26.999]                 ...future.oldOptions$nwarnings <- NULL
[13:23:26.999]             }
[13:23:26.999]             base::options(...future.oldOptions)
[13:23:26.999]             if (.Platform$OS.type == "windows") {
[13:23:26.999]                 old_names <- names(...future.oldEnvVars)
[13:23:26.999]                 envs <- base::Sys.getenv()
[13:23:26.999]                 names <- names(envs)
[13:23:26.999]                 common <- intersect(names, old_names)
[13:23:26.999]                 added <- setdiff(names, old_names)
[13:23:26.999]                 removed <- setdiff(old_names, names)
[13:23:26.999]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:26.999]                   envs[common]]
[13:23:26.999]                 NAMES <- toupper(changed)
[13:23:26.999]                 args <- list()
[13:23:26.999]                 for (kk in seq_along(NAMES)) {
[13:23:26.999]                   name <- changed[[kk]]
[13:23:26.999]                   NAME <- NAMES[[kk]]
[13:23:26.999]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.999]                     next
[13:23:26.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.999]                 }
[13:23:26.999]                 NAMES <- toupper(added)
[13:23:26.999]                 for (kk in seq_along(NAMES)) {
[13:23:26.999]                   name <- added[[kk]]
[13:23:26.999]                   NAME <- NAMES[[kk]]
[13:23:26.999]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.999]                     next
[13:23:26.999]                   args[[name]] <- ""
[13:23:26.999]                 }
[13:23:26.999]                 NAMES <- toupper(removed)
[13:23:26.999]                 for (kk in seq_along(NAMES)) {
[13:23:26.999]                   name <- removed[[kk]]
[13:23:26.999]                   NAME <- NAMES[[kk]]
[13:23:26.999]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:26.999]                     next
[13:23:26.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:26.999]                 }
[13:23:26.999]                 if (length(args) > 0) 
[13:23:26.999]                   base::do.call(base::Sys.setenv, args = args)
[13:23:26.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:26.999]             }
[13:23:26.999]             else {
[13:23:26.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:26.999]             }
[13:23:26.999]             {
[13:23:26.999]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:26.999]                   0L) {
[13:23:26.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:26.999]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:26.999]                   base::options(opts)
[13:23:26.999]                 }
[13:23:26.999]                 {
[13:23:26.999]                   {
[13:23:26.999]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:26.999]                     NULL
[13:23:26.999]                   }
[13:23:26.999]                   options(future.plan = NULL)
[13:23:26.999]                   if (is.na(NA_character_)) 
[13:23:26.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:26.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:26.999]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:26.999]                     envir = parent.frame()) 
[13:23:26.999]                   {
[13:23:26.999]                     default_workers <- missing(workers)
[13:23:26.999]                     if (is.function(workers)) 
[13:23:26.999]                       workers <- workers()
[13:23:26.999]                     workers <- structure(as.integer(workers), 
[13:23:26.999]                       class = class(workers))
[13:23:26.999]                     stop_if_not(is.finite(workers), workers >= 
[13:23:26.999]                       1L)
[13:23:26.999]                     if ((workers == 1L && !inherits(workers, 
[13:23:26.999]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:26.999]                       if (default_workers) 
[13:23:26.999]                         supportsMulticore(warn = TRUE)
[13:23:26.999]                       return(sequential(..., envir = envir))
[13:23:26.999]                     }
[13:23:26.999]                     oopts <- options(mc.cores = workers)
[13:23:26.999]                     on.exit(options(oopts))
[13:23:26.999]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:26.999]                       envir = envir)
[13:23:26.999]                     if (!future$lazy) 
[13:23:26.999]                       future <- run(future)
[13:23:26.999]                     invisible(future)
[13:23:26.999]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:26.999]                 }
[13:23:26.999]             }
[13:23:26.999]         }
[13:23:26.999]     })
[13:23:26.999]     if (TRUE) {
[13:23:26.999]         base::sink(type = "output", split = FALSE)
[13:23:26.999]         if (TRUE) {
[13:23:26.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:26.999]         }
[13:23:26.999]         else {
[13:23:26.999]             ...future.result["stdout"] <- base::list(NULL)
[13:23:26.999]         }
[13:23:26.999]         base::close(...future.stdout)
[13:23:26.999]         ...future.stdout <- NULL
[13:23:26.999]     }
[13:23:26.999]     ...future.result$conditions <- ...future.conditions
[13:23:26.999]     ...future.result$finished <- base::Sys.time()
[13:23:26.999]     ...future.result
[13:23:26.999] }
[13:23:27.002] assign_globals() ...
[13:23:27.002] List of 1
[13:23:27.002]  $ x: list()
[13:23:27.002]  - attr(*, "where")=List of 1
[13:23:27.002]   ..$ x:<environment: R_EmptyEnv> 
[13:23:27.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:27.002]  - attr(*, "resolved")= logi TRUE
[13:23:27.002]  - attr(*, "total_size")= num 0
[13:23:27.002]  - attr(*, "already-done")= logi TRUE
[13:23:27.005] - copied ‘x’ to environment
[13:23:27.005] assign_globals() ... done
[13:23:27.006] requestCore(): workers = 2
[13:23:27.008] MulticoreFuture started
[13:23:27.008] - Launch lazy future ... done
[13:23:27.009] run() for ‘MulticoreFuture’ ... done
[13:23:27.009] result() for MulticoreFuture ...
[13:23:27.009] plan(): Setting new future strategy stack:
[13:23:27.009] List of future strategies:
[13:23:27.009] 1. sequential:
[13:23:27.009]    - args: function (..., envir = parent.frame())
[13:23:27.009]    - tweaked: FALSE
[13:23:27.009]    - call: NULL
[13:23:27.010] plan(): nbrOfWorkers() = 1
[13:23:27.012] plan(): Setting new future strategy stack:
[13:23:27.013] List of future strategies:
[13:23:27.013] 1. multicore:
[13:23:27.013]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:27.013]    - tweaked: FALSE
[13:23:27.013]    - call: plan(strategy)
[13:23:27.022] plan(): nbrOfWorkers() = 2
[13:23:27.023] result() for MulticoreFuture ...
[13:23:27.024] result() for MulticoreFuture ... done
[13:23:27.024] result() for MulticoreFuture ... done
[13:23:27.024] result() for MulticoreFuture ...
[13:23:27.024] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:27.025] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:27.025] Searching for globals...
[13:23:27.031] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:27.032] Searching for globals ... DONE
[13:23:27.032] Resolving globals: TRUE
[13:23:27.032] Resolving any globals that are futures ...
[13:23:27.032] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:27.032] Resolving any globals that are futures ... DONE
[13:23:27.033] Resolving futures part of globals (recursively) ...
[13:23:27.033] resolve() on list ...
[13:23:27.033]  recursive: 99
[13:23:27.033]  length: 1
[13:23:27.033]  elements: ‘x’
[13:23:27.034]  length: 0 (resolved future 1)
[13:23:27.034] resolve() on list ... DONE
[13:23:27.034] - globals: [1] ‘x’
[13:23:27.034] Resolving futures part of globals (recursively) ... DONE
[13:23:27.034] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:27.035] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:27.035] - globals: [1] ‘x’
[13:23:27.035] 
[13:23:27.035] getGlobalsAndPackages() ... DONE
[13:23:27.035] run() for ‘Future’ ...
[13:23:27.036] - state: ‘created’
[13:23:27.036] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:27.040] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:27.040] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:27.040]   - Field: ‘label’
[13:23:27.040]   - Field: ‘local’
[13:23:27.041]   - Field: ‘owner’
[13:23:27.041]   - Field: ‘envir’
[13:23:27.041]   - Field: ‘workers’
[13:23:27.041]   - Field: ‘packages’
[13:23:27.041]   - Field: ‘gc’
[13:23:27.041]   - Field: ‘job’
[13:23:27.041]   - Field: ‘conditions’
[13:23:27.041]   - Field: ‘expr’
[13:23:27.042]   - Field: ‘uuid’
[13:23:27.042]   - Field: ‘seed’
[13:23:27.042]   - Field: ‘version’
[13:23:27.042]   - Field: ‘result’
[13:23:27.042]   - Field: ‘asynchronous’
[13:23:27.042]   - Field: ‘calls’
[13:23:27.042]   - Field: ‘globals’
[13:23:27.042]   - Field: ‘stdout’
[13:23:27.042]   - Field: ‘earlySignal’
[13:23:27.043]   - Field: ‘lazy’
[13:23:27.043]   - Field: ‘state’
[13:23:27.043] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:27.043] - Launch lazy future ...
[13:23:27.043] Packages needed by the future expression (n = 0): <none>
[13:23:27.043] Packages needed by future strategies (n = 0): <none>
[13:23:27.044] {
[13:23:27.044]     {
[13:23:27.044]         {
[13:23:27.044]             ...future.startTime <- base::Sys.time()
[13:23:27.044]             {
[13:23:27.044]                 {
[13:23:27.044]                   {
[13:23:27.044]                     {
[13:23:27.044]                       base::local({
[13:23:27.044]                         has_future <- base::requireNamespace("future", 
[13:23:27.044]                           quietly = TRUE)
[13:23:27.044]                         if (has_future) {
[13:23:27.044]                           ns <- base::getNamespace("future")
[13:23:27.044]                           version <- ns[[".package"]][["version"]]
[13:23:27.044]                           if (is.null(version)) 
[13:23:27.044]                             version <- utils::packageVersion("future")
[13:23:27.044]                         }
[13:23:27.044]                         else {
[13:23:27.044]                           version <- NULL
[13:23:27.044]                         }
[13:23:27.044]                         if (!has_future || version < "1.8.0") {
[13:23:27.044]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:27.044]                             "", base::R.version$version.string), 
[13:23:27.044]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:27.044]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:27.044]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:27.044]                               "release", "version")], collapse = " "), 
[13:23:27.044]                             hostname = base::Sys.info()[["nodename"]])
[13:23:27.044]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:27.044]                             info)
[13:23:27.044]                           info <- base::paste(info, collapse = "; ")
[13:23:27.044]                           if (!has_future) {
[13:23:27.044]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:27.044]                               info)
[13:23:27.044]                           }
[13:23:27.044]                           else {
[13:23:27.044]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:27.044]                               info, version)
[13:23:27.044]                           }
[13:23:27.044]                           base::stop(msg)
[13:23:27.044]                         }
[13:23:27.044]                       })
[13:23:27.044]                     }
[13:23:27.044]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:27.044]                     base::options(mc.cores = 1L)
[13:23:27.044]                   }
[13:23:27.044]                   options(future.plan = NULL)
[13:23:27.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:27.044]                 }
[13:23:27.044]                 ...future.workdir <- getwd()
[13:23:27.044]             }
[13:23:27.044]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:27.044]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:27.044]         }
[13:23:27.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:27.044]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:27.044]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:27.044]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:27.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:27.044]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:27.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:27.044]             base::names(...future.oldOptions))
[13:23:27.044]     }
[13:23:27.044]     if (FALSE) {
[13:23:27.044]     }
[13:23:27.044]     else {
[13:23:27.044]         if (TRUE) {
[13:23:27.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:27.044]                 open = "w")
[13:23:27.044]         }
[13:23:27.044]         else {
[13:23:27.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:27.044]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:27.044]         }
[13:23:27.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:27.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:27.044]             base::sink(type = "output", split = FALSE)
[13:23:27.044]             base::close(...future.stdout)
[13:23:27.044]         }, add = TRUE)
[13:23:27.044]     }
[13:23:27.044]     ...future.frame <- base::sys.nframe()
[13:23:27.044]     ...future.conditions <- base::list()
[13:23:27.044]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:27.044]     if (FALSE) {
[13:23:27.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:27.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:27.044]     }
[13:23:27.044]     ...future.result <- base::tryCatch({
[13:23:27.044]         base::withCallingHandlers({
[13:23:27.044]             ...future.value <- base::withVisible(base::local({
[13:23:27.044]                 withCallingHandlers({
[13:23:27.044]                   {
[13:23:27.044]                     x$a <- 1
[13:23:27.044]                     x
[13:23:27.044]                   }
[13:23:27.044]                 }, immediateCondition = function(cond) {
[13:23:27.044]                   save_rds <- function (object, pathname, ...) 
[13:23:27.044]                   {
[13:23:27.044]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:27.044]                     if (file_test("-f", pathname_tmp)) {
[13:23:27.044]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.044]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:27.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.044]                         fi_tmp[["mtime"]])
[13:23:27.044]                     }
[13:23:27.044]                     tryCatch({
[13:23:27.044]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:27.044]                     }, error = function(ex) {
[13:23:27.044]                       msg <- conditionMessage(ex)
[13:23:27.044]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.044]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:27.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.044]                         fi_tmp[["mtime"]], msg)
[13:23:27.044]                       ex$message <- msg
[13:23:27.044]                       stop(ex)
[13:23:27.044]                     })
[13:23:27.044]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:27.044]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:27.044]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:27.044]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.044]                       fi <- file.info(pathname)
[13:23:27.044]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:27.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.044]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:27.044]                         fi[["size"]], fi[["mtime"]])
[13:23:27.044]                       stop(msg)
[13:23:27.044]                     }
[13:23:27.044]                     invisible(pathname)
[13:23:27.044]                   }
[13:23:27.044]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:27.044]                     rootPath = tempdir()) 
[13:23:27.044]                   {
[13:23:27.044]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:27.044]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:27.044]                       tmpdir = path, fileext = ".rds")
[13:23:27.044]                     save_rds(obj, file)
[13:23:27.044]                   }
[13:23:27.044]                   saveImmediateCondition(cond, path = "/tmp/Rtmpxi2rDI/.future/immediateConditions")
[13:23:27.044]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.044]                   {
[13:23:27.044]                     inherits <- base::inherits
[13:23:27.044]                     invokeRestart <- base::invokeRestart
[13:23:27.044]                     is.null <- base::is.null
[13:23:27.044]                     muffled <- FALSE
[13:23:27.044]                     if (inherits(cond, "message")) {
[13:23:27.044]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:27.044]                       if (muffled) 
[13:23:27.044]                         invokeRestart("muffleMessage")
[13:23:27.044]                     }
[13:23:27.044]                     else if (inherits(cond, "warning")) {
[13:23:27.044]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:27.044]                       if (muffled) 
[13:23:27.044]                         invokeRestart("muffleWarning")
[13:23:27.044]                     }
[13:23:27.044]                     else if (inherits(cond, "condition")) {
[13:23:27.044]                       if (!is.null(pattern)) {
[13:23:27.044]                         computeRestarts <- base::computeRestarts
[13:23:27.044]                         grepl <- base::grepl
[13:23:27.044]                         restarts <- computeRestarts(cond)
[13:23:27.044]                         for (restart in restarts) {
[13:23:27.044]                           name <- restart$name
[13:23:27.044]                           if (is.null(name)) 
[13:23:27.044]                             next
[13:23:27.044]                           if (!grepl(pattern, name)) 
[13:23:27.044]                             next
[13:23:27.044]                           invokeRestart(restart)
[13:23:27.044]                           muffled <- TRUE
[13:23:27.044]                           break
[13:23:27.044]                         }
[13:23:27.044]                       }
[13:23:27.044]                     }
[13:23:27.044]                     invisible(muffled)
[13:23:27.044]                   }
[13:23:27.044]                   muffleCondition(cond)
[13:23:27.044]                 })
[13:23:27.044]             }))
[13:23:27.044]             future::FutureResult(value = ...future.value$value, 
[13:23:27.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.044]                   ...future.rng), globalenv = if (FALSE) 
[13:23:27.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:27.044]                     ...future.globalenv.names))
[13:23:27.044]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:27.044]         }, condition = base::local({
[13:23:27.044]             c <- base::c
[13:23:27.044]             inherits <- base::inherits
[13:23:27.044]             invokeRestart <- base::invokeRestart
[13:23:27.044]             length <- base::length
[13:23:27.044]             list <- base::list
[13:23:27.044]             seq.int <- base::seq.int
[13:23:27.044]             signalCondition <- base::signalCondition
[13:23:27.044]             sys.calls <- base::sys.calls
[13:23:27.044]             `[[` <- base::`[[`
[13:23:27.044]             `+` <- base::`+`
[13:23:27.044]             `<<-` <- base::`<<-`
[13:23:27.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:27.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:27.044]                   3L)]
[13:23:27.044]             }
[13:23:27.044]             function(cond) {
[13:23:27.044]                 is_error <- inherits(cond, "error")
[13:23:27.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:27.044]                   NULL)
[13:23:27.044]                 if (is_error) {
[13:23:27.044]                   sessionInformation <- function() {
[13:23:27.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:27.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:27.044]                       search = base::search(), system = base::Sys.info())
[13:23:27.044]                   }
[13:23:27.044]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:27.044]                     cond$call), session = sessionInformation(), 
[13:23:27.044]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:27.044]                   signalCondition(cond)
[13:23:27.044]                 }
[13:23:27.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:27.044]                 "immediateCondition"))) {
[13:23:27.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:27.044]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:27.044]                   if (TRUE && !signal) {
[13:23:27.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.044]                     {
[13:23:27.044]                       inherits <- base::inherits
[13:23:27.044]                       invokeRestart <- base::invokeRestart
[13:23:27.044]                       is.null <- base::is.null
[13:23:27.044]                       muffled <- FALSE
[13:23:27.044]                       if (inherits(cond, "message")) {
[13:23:27.044]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.044]                         if (muffled) 
[13:23:27.044]                           invokeRestart("muffleMessage")
[13:23:27.044]                       }
[13:23:27.044]                       else if (inherits(cond, "warning")) {
[13:23:27.044]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.044]                         if (muffled) 
[13:23:27.044]                           invokeRestart("muffleWarning")
[13:23:27.044]                       }
[13:23:27.044]                       else if (inherits(cond, "condition")) {
[13:23:27.044]                         if (!is.null(pattern)) {
[13:23:27.044]                           computeRestarts <- base::computeRestarts
[13:23:27.044]                           grepl <- base::grepl
[13:23:27.044]                           restarts <- computeRestarts(cond)
[13:23:27.044]                           for (restart in restarts) {
[13:23:27.044]                             name <- restart$name
[13:23:27.044]                             if (is.null(name)) 
[13:23:27.044]                               next
[13:23:27.044]                             if (!grepl(pattern, name)) 
[13:23:27.044]                               next
[13:23:27.044]                             invokeRestart(restart)
[13:23:27.044]                             muffled <- TRUE
[13:23:27.044]                             break
[13:23:27.044]                           }
[13:23:27.044]                         }
[13:23:27.044]                       }
[13:23:27.044]                       invisible(muffled)
[13:23:27.044]                     }
[13:23:27.044]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.044]                   }
[13:23:27.044]                 }
[13:23:27.044]                 else {
[13:23:27.044]                   if (TRUE) {
[13:23:27.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.044]                     {
[13:23:27.044]                       inherits <- base::inherits
[13:23:27.044]                       invokeRestart <- base::invokeRestart
[13:23:27.044]                       is.null <- base::is.null
[13:23:27.044]                       muffled <- FALSE
[13:23:27.044]                       if (inherits(cond, "message")) {
[13:23:27.044]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.044]                         if (muffled) 
[13:23:27.044]                           invokeRestart("muffleMessage")
[13:23:27.044]                       }
[13:23:27.044]                       else if (inherits(cond, "warning")) {
[13:23:27.044]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.044]                         if (muffled) 
[13:23:27.044]                           invokeRestart("muffleWarning")
[13:23:27.044]                       }
[13:23:27.044]                       else if (inherits(cond, "condition")) {
[13:23:27.044]                         if (!is.null(pattern)) {
[13:23:27.044]                           computeRestarts <- base::computeRestarts
[13:23:27.044]                           grepl <- base::grepl
[13:23:27.044]                           restarts <- computeRestarts(cond)
[13:23:27.044]                           for (restart in restarts) {
[13:23:27.044]                             name <- restart$name
[13:23:27.044]                             if (is.null(name)) 
[13:23:27.044]                               next
[13:23:27.044]                             if (!grepl(pattern, name)) 
[13:23:27.044]                               next
[13:23:27.044]                             invokeRestart(restart)
[13:23:27.044]                             muffled <- TRUE
[13:23:27.044]                             break
[13:23:27.044]                           }
[13:23:27.044]                         }
[13:23:27.044]                       }
[13:23:27.044]                       invisible(muffled)
[13:23:27.044]                     }
[13:23:27.044]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.044]                   }
[13:23:27.044]                 }
[13:23:27.044]             }
[13:23:27.044]         }))
[13:23:27.044]     }, error = function(ex) {
[13:23:27.044]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:27.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.044]                 ...future.rng), started = ...future.startTime, 
[13:23:27.044]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:27.044]             version = "1.8"), class = "FutureResult")
[13:23:27.044]     }, finally = {
[13:23:27.044]         if (!identical(...future.workdir, getwd())) 
[13:23:27.044]             setwd(...future.workdir)
[13:23:27.044]         {
[13:23:27.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:27.044]                 ...future.oldOptions$nwarnings <- NULL
[13:23:27.044]             }
[13:23:27.044]             base::options(...future.oldOptions)
[13:23:27.044]             if (.Platform$OS.type == "windows") {
[13:23:27.044]                 old_names <- names(...future.oldEnvVars)
[13:23:27.044]                 envs <- base::Sys.getenv()
[13:23:27.044]                 names <- names(envs)
[13:23:27.044]                 common <- intersect(names, old_names)
[13:23:27.044]                 added <- setdiff(names, old_names)
[13:23:27.044]                 removed <- setdiff(old_names, names)
[13:23:27.044]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:27.044]                   envs[common]]
[13:23:27.044]                 NAMES <- toupper(changed)
[13:23:27.044]                 args <- list()
[13:23:27.044]                 for (kk in seq_along(NAMES)) {
[13:23:27.044]                   name <- changed[[kk]]
[13:23:27.044]                   NAME <- NAMES[[kk]]
[13:23:27.044]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.044]                     next
[13:23:27.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.044]                 }
[13:23:27.044]                 NAMES <- toupper(added)
[13:23:27.044]                 for (kk in seq_along(NAMES)) {
[13:23:27.044]                   name <- added[[kk]]
[13:23:27.044]                   NAME <- NAMES[[kk]]
[13:23:27.044]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.044]                     next
[13:23:27.044]                   args[[name]] <- ""
[13:23:27.044]                 }
[13:23:27.044]                 NAMES <- toupper(removed)
[13:23:27.044]                 for (kk in seq_along(NAMES)) {
[13:23:27.044]                   name <- removed[[kk]]
[13:23:27.044]                   NAME <- NAMES[[kk]]
[13:23:27.044]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.044]                     next
[13:23:27.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.044]                 }
[13:23:27.044]                 if (length(args) > 0) 
[13:23:27.044]                   base::do.call(base::Sys.setenv, args = args)
[13:23:27.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:27.044]             }
[13:23:27.044]             else {
[13:23:27.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:27.044]             }
[13:23:27.044]             {
[13:23:27.044]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:27.044]                   0L) {
[13:23:27.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:27.044]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:27.044]                   base::options(opts)
[13:23:27.044]                 }
[13:23:27.044]                 {
[13:23:27.044]                   {
[13:23:27.044]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:27.044]                     NULL
[13:23:27.044]                   }
[13:23:27.044]                   options(future.plan = NULL)
[13:23:27.044]                   if (is.na(NA_character_)) 
[13:23:27.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:27.044]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:27.044]                     envir = parent.frame()) 
[13:23:27.044]                   {
[13:23:27.044]                     default_workers <- missing(workers)
[13:23:27.044]                     if (is.function(workers)) 
[13:23:27.044]                       workers <- workers()
[13:23:27.044]                     workers <- structure(as.integer(workers), 
[13:23:27.044]                       class = class(workers))
[13:23:27.044]                     stop_if_not(is.finite(workers), workers >= 
[13:23:27.044]                       1L)
[13:23:27.044]                     if ((workers == 1L && !inherits(workers, 
[13:23:27.044]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:27.044]                       if (default_workers) 
[13:23:27.044]                         supportsMulticore(warn = TRUE)
[13:23:27.044]                       return(sequential(..., envir = envir))
[13:23:27.044]                     }
[13:23:27.044]                     oopts <- options(mc.cores = workers)
[13:23:27.044]                     on.exit(options(oopts))
[13:23:27.044]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:27.044]                       envir = envir)
[13:23:27.044]                     if (!future$lazy) 
[13:23:27.044]                       future <- run(future)
[13:23:27.044]                     invisible(future)
[13:23:27.044]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:27.044]                 }
[13:23:27.044]             }
[13:23:27.044]         }
[13:23:27.044]     })
[13:23:27.044]     if (TRUE) {
[13:23:27.044]         base::sink(type = "output", split = FALSE)
[13:23:27.044]         if (TRUE) {
[13:23:27.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:27.044]         }
[13:23:27.044]         else {
[13:23:27.044]             ...future.result["stdout"] <- base::list(NULL)
[13:23:27.044]         }
[13:23:27.044]         base::close(...future.stdout)
[13:23:27.044]         ...future.stdout <- NULL
[13:23:27.044]     }
[13:23:27.044]     ...future.result$conditions <- ...future.conditions
[13:23:27.044]     ...future.result$finished <- base::Sys.time()
[13:23:27.044]     ...future.result
[13:23:27.044] }
[13:23:27.046] assign_globals() ...
[13:23:27.047] List of 1
[13:23:27.047]  $ x: list()
[13:23:27.047]  - attr(*, "where")=List of 1
[13:23:27.047]   ..$ x:<environment: R_EmptyEnv> 
[13:23:27.047]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:27.047]  - attr(*, "resolved")= logi TRUE
[13:23:27.047]  - attr(*, "total_size")= num 0
[13:23:27.047]  - attr(*, "already-done")= logi TRUE
[13:23:27.050] - copied ‘x’ to environment
[13:23:27.050] assign_globals() ... done
[13:23:27.050] requestCore(): workers = 2
[13:23:27.052] MulticoreFuture started
[13:23:27.053] - Launch lazy future ... done
[13:23:27.053] run() for ‘MulticoreFuture’ ... done
[13:23:27.053] result() for MulticoreFuture ...
[13:23:27.053] plan(): Setting new future strategy stack:
[13:23:27.054] List of future strategies:
[13:23:27.054] 1. sequential:
[13:23:27.054]    - args: function (..., envir = parent.frame())
[13:23:27.054]    - tweaked: FALSE
[13:23:27.054]    - call: NULL
[13:23:27.055] plan(): nbrOfWorkers() = 1
[13:23:27.057] plan(): Setting new future strategy stack:
[13:23:27.057] List of future strategies:
[13:23:27.057] 1. multicore:
[13:23:27.057]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:27.057]    - tweaked: FALSE
[13:23:27.057]    - call: plan(strategy)
[13:23:27.062] plan(): nbrOfWorkers() = 2
[13:23:27.063] result() for MulticoreFuture ...
[13:23:27.064] result() for MulticoreFuture ... done
[13:23:27.064] result() for MulticoreFuture ... done
[13:23:27.064] result() for MulticoreFuture ...
[13:23:27.064] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:27.065] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:27.065] Searching for globals...
[13:23:27.069] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[13:23:27.069] Searching for globals ... DONE
[13:23:27.069] Resolving globals: TRUE
[13:23:27.069] Resolving any globals that are futures ...
[13:23:27.069] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[13:23:27.069] Resolving any globals that are futures ... DONE
[13:23:27.070] 
[13:23:27.070] 
[13:23:27.070] getGlobalsAndPackages() ... DONE
[13:23:27.070] run() for ‘Future’ ...
[13:23:27.071] - state: ‘created’
[13:23:27.071] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:27.075] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:27.075] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:27.075]   - Field: ‘label’
[13:23:27.076]   - Field: ‘local’
[13:23:27.076]   - Field: ‘owner’
[13:23:27.076]   - Field: ‘envir’
[13:23:27.076]   - Field: ‘workers’
[13:23:27.076]   - Field: ‘packages’
[13:23:27.076]   - Field: ‘gc’
[13:23:27.076]   - Field: ‘job’
[13:23:27.076]   - Field: ‘conditions’
[13:23:27.077]   - Field: ‘expr’
[13:23:27.077]   - Field: ‘uuid’
[13:23:27.077]   - Field: ‘seed’
[13:23:27.077]   - Field: ‘version’
[13:23:27.077]   - Field: ‘result’
[13:23:27.077]   - Field: ‘asynchronous’
[13:23:27.077]   - Field: ‘calls’
[13:23:27.077]   - Field: ‘globals’
[13:23:27.077]   - Field: ‘stdout’
[13:23:27.078]   - Field: ‘earlySignal’
[13:23:27.078]   - Field: ‘lazy’
[13:23:27.078]   - Field: ‘state’
[13:23:27.078] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:27.080] - Launch lazy future ...
[13:23:27.081] Packages needed by the future expression (n = 0): <none>
[13:23:27.081] Packages needed by future strategies (n = 0): <none>
[13:23:27.082] {
[13:23:27.082]     {
[13:23:27.082]         {
[13:23:27.082]             ...future.startTime <- base::Sys.time()
[13:23:27.082]             {
[13:23:27.082]                 {
[13:23:27.082]                   {
[13:23:27.082]                     {
[13:23:27.082]                       base::local({
[13:23:27.082]                         has_future <- base::requireNamespace("future", 
[13:23:27.082]                           quietly = TRUE)
[13:23:27.082]                         if (has_future) {
[13:23:27.082]                           ns <- base::getNamespace("future")
[13:23:27.082]                           version <- ns[[".package"]][["version"]]
[13:23:27.082]                           if (is.null(version)) 
[13:23:27.082]                             version <- utils::packageVersion("future")
[13:23:27.082]                         }
[13:23:27.082]                         else {
[13:23:27.082]                           version <- NULL
[13:23:27.082]                         }
[13:23:27.082]                         if (!has_future || version < "1.8.0") {
[13:23:27.082]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:27.082]                             "", base::R.version$version.string), 
[13:23:27.082]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:27.082]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:27.082]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:27.082]                               "release", "version")], collapse = " "), 
[13:23:27.082]                             hostname = base::Sys.info()[["nodename"]])
[13:23:27.082]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:27.082]                             info)
[13:23:27.082]                           info <- base::paste(info, collapse = "; ")
[13:23:27.082]                           if (!has_future) {
[13:23:27.082]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:27.082]                               info)
[13:23:27.082]                           }
[13:23:27.082]                           else {
[13:23:27.082]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:27.082]                               info, version)
[13:23:27.082]                           }
[13:23:27.082]                           base::stop(msg)
[13:23:27.082]                         }
[13:23:27.082]                       })
[13:23:27.082]                     }
[13:23:27.082]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:27.082]                     base::options(mc.cores = 1L)
[13:23:27.082]                   }
[13:23:27.082]                   options(future.plan = NULL)
[13:23:27.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:27.082]                 }
[13:23:27.082]                 ...future.workdir <- getwd()
[13:23:27.082]             }
[13:23:27.082]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:27.082]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:27.082]         }
[13:23:27.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:27.082]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:27.082]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:27.082]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:27.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:27.082]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:27.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:27.082]             base::names(...future.oldOptions))
[13:23:27.082]     }
[13:23:27.082]     if (FALSE) {
[13:23:27.082]     }
[13:23:27.082]     else {
[13:23:27.082]         if (TRUE) {
[13:23:27.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:27.082]                 open = "w")
[13:23:27.082]         }
[13:23:27.082]         else {
[13:23:27.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:27.082]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:27.082]         }
[13:23:27.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:27.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:27.082]             base::sink(type = "output", split = FALSE)
[13:23:27.082]             base::close(...future.stdout)
[13:23:27.082]         }, add = TRUE)
[13:23:27.082]     }
[13:23:27.082]     ...future.frame <- base::sys.nframe()
[13:23:27.082]     ...future.conditions <- base::list()
[13:23:27.082]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:27.082]     if (FALSE) {
[13:23:27.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:27.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:27.082]     }
[13:23:27.082]     ...future.result <- base::tryCatch({
[13:23:27.082]         base::withCallingHandlers({
[13:23:27.082]             ...future.value <- base::withVisible(base::local({
[13:23:27.082]                 withCallingHandlers({
[13:23:27.082]                   {
[13:23:27.082]                     x <- list(b = 2)
[13:23:27.082]                     x$a <- 1
[13:23:27.082]                     x
[13:23:27.082]                   }
[13:23:27.082]                 }, immediateCondition = function(cond) {
[13:23:27.082]                   save_rds <- function (object, pathname, ...) 
[13:23:27.082]                   {
[13:23:27.082]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:27.082]                     if (file_test("-f", pathname_tmp)) {
[13:23:27.082]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.082]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:27.082]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.082]                         fi_tmp[["mtime"]])
[13:23:27.082]                     }
[13:23:27.082]                     tryCatch({
[13:23:27.082]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:27.082]                     }, error = function(ex) {
[13:23:27.082]                       msg <- conditionMessage(ex)
[13:23:27.082]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.082]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:27.082]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.082]                         fi_tmp[["mtime"]], msg)
[13:23:27.082]                       ex$message <- msg
[13:23:27.082]                       stop(ex)
[13:23:27.082]                     })
[13:23:27.082]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:27.082]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:27.082]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:27.082]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.082]                       fi <- file.info(pathname)
[13:23:27.082]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:27.082]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.082]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:27.082]                         fi[["size"]], fi[["mtime"]])
[13:23:27.082]                       stop(msg)
[13:23:27.082]                     }
[13:23:27.082]                     invisible(pathname)
[13:23:27.082]                   }
[13:23:27.082]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:27.082]                     rootPath = tempdir()) 
[13:23:27.082]                   {
[13:23:27.082]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:27.082]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:27.082]                       tmpdir = path, fileext = ".rds")
[13:23:27.082]                     save_rds(obj, file)
[13:23:27.082]                   }
[13:23:27.082]                   saveImmediateCondition(cond, path = "/tmp/Rtmpxi2rDI/.future/immediateConditions")
[13:23:27.082]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.082]                   {
[13:23:27.082]                     inherits <- base::inherits
[13:23:27.082]                     invokeRestart <- base::invokeRestart
[13:23:27.082]                     is.null <- base::is.null
[13:23:27.082]                     muffled <- FALSE
[13:23:27.082]                     if (inherits(cond, "message")) {
[13:23:27.082]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:27.082]                       if (muffled) 
[13:23:27.082]                         invokeRestart("muffleMessage")
[13:23:27.082]                     }
[13:23:27.082]                     else if (inherits(cond, "warning")) {
[13:23:27.082]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:27.082]                       if (muffled) 
[13:23:27.082]                         invokeRestart("muffleWarning")
[13:23:27.082]                     }
[13:23:27.082]                     else if (inherits(cond, "condition")) {
[13:23:27.082]                       if (!is.null(pattern)) {
[13:23:27.082]                         computeRestarts <- base::computeRestarts
[13:23:27.082]                         grepl <- base::grepl
[13:23:27.082]                         restarts <- computeRestarts(cond)
[13:23:27.082]                         for (restart in restarts) {
[13:23:27.082]                           name <- restart$name
[13:23:27.082]                           if (is.null(name)) 
[13:23:27.082]                             next
[13:23:27.082]                           if (!grepl(pattern, name)) 
[13:23:27.082]                             next
[13:23:27.082]                           invokeRestart(restart)
[13:23:27.082]                           muffled <- TRUE
[13:23:27.082]                           break
[13:23:27.082]                         }
[13:23:27.082]                       }
[13:23:27.082]                     }
[13:23:27.082]                     invisible(muffled)
[13:23:27.082]                   }
[13:23:27.082]                   muffleCondition(cond)
[13:23:27.082]                 })
[13:23:27.082]             }))
[13:23:27.082]             future::FutureResult(value = ...future.value$value, 
[13:23:27.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.082]                   ...future.rng), globalenv = if (FALSE) 
[13:23:27.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:27.082]                     ...future.globalenv.names))
[13:23:27.082]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:27.082]         }, condition = base::local({
[13:23:27.082]             c <- base::c
[13:23:27.082]             inherits <- base::inherits
[13:23:27.082]             invokeRestart <- base::invokeRestart
[13:23:27.082]             length <- base::length
[13:23:27.082]             list <- base::list
[13:23:27.082]             seq.int <- base::seq.int
[13:23:27.082]             signalCondition <- base::signalCondition
[13:23:27.082]             sys.calls <- base::sys.calls
[13:23:27.082]             `[[` <- base::`[[`
[13:23:27.082]             `+` <- base::`+`
[13:23:27.082]             `<<-` <- base::`<<-`
[13:23:27.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:27.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:27.082]                   3L)]
[13:23:27.082]             }
[13:23:27.082]             function(cond) {
[13:23:27.082]                 is_error <- inherits(cond, "error")
[13:23:27.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:27.082]                   NULL)
[13:23:27.082]                 if (is_error) {
[13:23:27.082]                   sessionInformation <- function() {
[13:23:27.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:27.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:27.082]                       search = base::search(), system = base::Sys.info())
[13:23:27.082]                   }
[13:23:27.082]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:27.082]                     cond$call), session = sessionInformation(), 
[13:23:27.082]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:27.082]                   signalCondition(cond)
[13:23:27.082]                 }
[13:23:27.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:27.082]                 "immediateCondition"))) {
[13:23:27.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:27.082]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:27.082]                   if (TRUE && !signal) {
[13:23:27.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.082]                     {
[13:23:27.082]                       inherits <- base::inherits
[13:23:27.082]                       invokeRestart <- base::invokeRestart
[13:23:27.082]                       is.null <- base::is.null
[13:23:27.082]                       muffled <- FALSE
[13:23:27.082]                       if (inherits(cond, "message")) {
[13:23:27.082]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.082]                         if (muffled) 
[13:23:27.082]                           invokeRestart("muffleMessage")
[13:23:27.082]                       }
[13:23:27.082]                       else if (inherits(cond, "warning")) {
[13:23:27.082]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.082]                         if (muffled) 
[13:23:27.082]                           invokeRestart("muffleWarning")
[13:23:27.082]                       }
[13:23:27.082]                       else if (inherits(cond, "condition")) {
[13:23:27.082]                         if (!is.null(pattern)) {
[13:23:27.082]                           computeRestarts <- base::computeRestarts
[13:23:27.082]                           grepl <- base::grepl
[13:23:27.082]                           restarts <- computeRestarts(cond)
[13:23:27.082]                           for (restart in restarts) {
[13:23:27.082]                             name <- restart$name
[13:23:27.082]                             if (is.null(name)) 
[13:23:27.082]                               next
[13:23:27.082]                             if (!grepl(pattern, name)) 
[13:23:27.082]                               next
[13:23:27.082]                             invokeRestart(restart)
[13:23:27.082]                             muffled <- TRUE
[13:23:27.082]                             break
[13:23:27.082]                           }
[13:23:27.082]                         }
[13:23:27.082]                       }
[13:23:27.082]                       invisible(muffled)
[13:23:27.082]                     }
[13:23:27.082]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.082]                   }
[13:23:27.082]                 }
[13:23:27.082]                 else {
[13:23:27.082]                   if (TRUE) {
[13:23:27.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.082]                     {
[13:23:27.082]                       inherits <- base::inherits
[13:23:27.082]                       invokeRestart <- base::invokeRestart
[13:23:27.082]                       is.null <- base::is.null
[13:23:27.082]                       muffled <- FALSE
[13:23:27.082]                       if (inherits(cond, "message")) {
[13:23:27.082]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.082]                         if (muffled) 
[13:23:27.082]                           invokeRestart("muffleMessage")
[13:23:27.082]                       }
[13:23:27.082]                       else if (inherits(cond, "warning")) {
[13:23:27.082]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.082]                         if (muffled) 
[13:23:27.082]                           invokeRestart("muffleWarning")
[13:23:27.082]                       }
[13:23:27.082]                       else if (inherits(cond, "condition")) {
[13:23:27.082]                         if (!is.null(pattern)) {
[13:23:27.082]                           computeRestarts <- base::computeRestarts
[13:23:27.082]                           grepl <- base::grepl
[13:23:27.082]                           restarts <- computeRestarts(cond)
[13:23:27.082]                           for (restart in restarts) {
[13:23:27.082]                             name <- restart$name
[13:23:27.082]                             if (is.null(name)) 
[13:23:27.082]                               next
[13:23:27.082]                             if (!grepl(pattern, name)) 
[13:23:27.082]                               next
[13:23:27.082]                             invokeRestart(restart)
[13:23:27.082]                             muffled <- TRUE
[13:23:27.082]                             break
[13:23:27.082]                           }
[13:23:27.082]                         }
[13:23:27.082]                       }
[13:23:27.082]                       invisible(muffled)
[13:23:27.082]                     }
[13:23:27.082]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.082]                   }
[13:23:27.082]                 }
[13:23:27.082]             }
[13:23:27.082]         }))
[13:23:27.082]     }, error = function(ex) {
[13:23:27.082]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:27.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.082]                 ...future.rng), started = ...future.startTime, 
[13:23:27.082]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:27.082]             version = "1.8"), class = "FutureResult")
[13:23:27.082]     }, finally = {
[13:23:27.082]         if (!identical(...future.workdir, getwd())) 
[13:23:27.082]             setwd(...future.workdir)
[13:23:27.082]         {
[13:23:27.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:27.082]                 ...future.oldOptions$nwarnings <- NULL
[13:23:27.082]             }
[13:23:27.082]             base::options(...future.oldOptions)
[13:23:27.082]             if (.Platform$OS.type == "windows") {
[13:23:27.082]                 old_names <- names(...future.oldEnvVars)
[13:23:27.082]                 envs <- base::Sys.getenv()
[13:23:27.082]                 names <- names(envs)
[13:23:27.082]                 common <- intersect(names, old_names)
[13:23:27.082]                 added <- setdiff(names, old_names)
[13:23:27.082]                 removed <- setdiff(old_names, names)
[13:23:27.082]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:27.082]                   envs[common]]
[13:23:27.082]                 NAMES <- toupper(changed)
[13:23:27.082]                 args <- list()
[13:23:27.082]                 for (kk in seq_along(NAMES)) {
[13:23:27.082]                   name <- changed[[kk]]
[13:23:27.082]                   NAME <- NAMES[[kk]]
[13:23:27.082]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.082]                     next
[13:23:27.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.082]                 }
[13:23:27.082]                 NAMES <- toupper(added)
[13:23:27.082]                 for (kk in seq_along(NAMES)) {
[13:23:27.082]                   name <- added[[kk]]
[13:23:27.082]                   NAME <- NAMES[[kk]]
[13:23:27.082]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.082]                     next
[13:23:27.082]                   args[[name]] <- ""
[13:23:27.082]                 }
[13:23:27.082]                 NAMES <- toupper(removed)
[13:23:27.082]                 for (kk in seq_along(NAMES)) {
[13:23:27.082]                   name <- removed[[kk]]
[13:23:27.082]                   NAME <- NAMES[[kk]]
[13:23:27.082]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.082]                     next
[13:23:27.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.082]                 }
[13:23:27.082]                 if (length(args) > 0) 
[13:23:27.082]                   base::do.call(base::Sys.setenv, args = args)
[13:23:27.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:27.082]             }
[13:23:27.082]             else {
[13:23:27.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:27.082]             }
[13:23:27.082]             {
[13:23:27.082]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:27.082]                   0L) {
[13:23:27.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:27.082]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:27.082]                   base::options(opts)
[13:23:27.082]                 }
[13:23:27.082]                 {
[13:23:27.082]                   {
[13:23:27.082]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:27.082]                     NULL
[13:23:27.082]                   }
[13:23:27.082]                   options(future.plan = NULL)
[13:23:27.082]                   if (is.na(NA_character_)) 
[13:23:27.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:27.082]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:27.082]                     envir = parent.frame()) 
[13:23:27.082]                   {
[13:23:27.082]                     default_workers <- missing(workers)
[13:23:27.082]                     if (is.function(workers)) 
[13:23:27.082]                       workers <- workers()
[13:23:27.082]                     workers <- structure(as.integer(workers), 
[13:23:27.082]                       class = class(workers))
[13:23:27.082]                     stop_if_not(is.finite(workers), workers >= 
[13:23:27.082]                       1L)
[13:23:27.082]                     if ((workers == 1L && !inherits(workers, 
[13:23:27.082]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:27.082]                       if (default_workers) 
[13:23:27.082]                         supportsMulticore(warn = TRUE)
[13:23:27.082]                       return(sequential(..., envir = envir))
[13:23:27.082]                     }
[13:23:27.082]                     oopts <- options(mc.cores = workers)
[13:23:27.082]                     on.exit(options(oopts))
[13:23:27.082]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:27.082]                       envir = envir)
[13:23:27.082]                     if (!future$lazy) 
[13:23:27.082]                       future <- run(future)
[13:23:27.082]                     invisible(future)
[13:23:27.082]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:27.082]                 }
[13:23:27.082]             }
[13:23:27.082]         }
[13:23:27.082]     })
[13:23:27.082]     if (TRUE) {
[13:23:27.082]         base::sink(type = "output", split = FALSE)
[13:23:27.082]         if (TRUE) {
[13:23:27.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:27.082]         }
[13:23:27.082]         else {
[13:23:27.082]             ...future.result["stdout"] <- base::list(NULL)
[13:23:27.082]         }
[13:23:27.082]         base::close(...future.stdout)
[13:23:27.082]         ...future.stdout <- NULL
[13:23:27.082]     }
[13:23:27.082]     ...future.result$conditions <- ...future.conditions
[13:23:27.082]     ...future.result$finished <- base::Sys.time()
[13:23:27.082]     ...future.result
[13:23:27.082] }
[13:23:27.084] requestCore(): workers = 2
[13:23:27.087] MulticoreFuture started
[13:23:27.087] - Launch lazy future ... done
[13:23:27.087] run() for ‘MulticoreFuture’ ... done
[13:23:27.088] plan(): Setting new future strategy stack:
[13:23:27.088] result() for MulticoreFuture ...
[13:23:27.088] List of future strategies:
[13:23:27.088] 1. sequential:
[13:23:27.088]    - args: function (..., envir = parent.frame())
[13:23:27.088]    - tweaked: FALSE
[13:23:27.088]    - call: NULL
[13:23:27.089] plan(): nbrOfWorkers() = 1
[13:23:27.091] plan(): Setting new future strategy stack:
[13:23:27.092] List of future strategies:
[13:23:27.092] 1. multicore:
[13:23:27.092]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:27.092]    - tweaked: FALSE
[13:23:27.092]    - call: plan(strategy)
[13:23:27.097] plan(): nbrOfWorkers() = 2
[13:23:27.098] result() for MulticoreFuture ...
[13:23:27.098] result() for MulticoreFuture ... done
[13:23:27.098] result() for MulticoreFuture ... done
[13:23:27.098] result() for MulticoreFuture ...
[13:23:27.099] result() for MulticoreFuture ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:27.099] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:27.099] Searching for globals...
[13:23:27.102] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:27.102] Searching for globals ... DONE
[13:23:27.103] Resolving globals: TRUE
[13:23:27.103] Resolving any globals that are futures ...
[13:23:27.103] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:27.103] Resolving any globals that are futures ... DONE
[13:23:27.104] Resolving futures part of globals (recursively) ...
[13:23:27.104] resolve() on list ...
[13:23:27.104]  recursive: 99
[13:23:27.104]  length: 1
[13:23:27.104]  elements: ‘x’
[13:23:27.104]  length: 0 (resolved future 1)
[13:23:27.105] resolve() on list ... DONE
[13:23:27.105] - globals: [1] ‘x’
[13:23:27.105] Resolving futures part of globals (recursively) ... DONE
[13:23:27.105] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:27.105] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:27.106] - globals: [1] ‘x’
[13:23:27.106] 
[13:23:27.106] getGlobalsAndPackages() ... DONE
[13:23:27.106] run() for ‘Future’ ...
[13:23:27.106] - state: ‘created’
[13:23:27.107] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:27.111] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:27.111] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:27.112]   - Field: ‘label’
[13:23:27.112]   - Field: ‘local’
[13:23:27.112]   - Field: ‘owner’
[13:23:27.112]   - Field: ‘envir’
[13:23:27.112]   - Field: ‘workers’
[13:23:27.113]   - Field: ‘packages’
[13:23:27.113]   - Field: ‘gc’
[13:23:27.113]   - Field: ‘job’
[13:23:27.113]   - Field: ‘conditions’
[13:23:27.113]   - Field: ‘expr’
[13:23:27.113]   - Field: ‘uuid’
[13:23:27.113]   - Field: ‘seed’
[13:23:27.113]   - Field: ‘version’
[13:23:27.114]   - Field: ‘result’
[13:23:27.114]   - Field: ‘asynchronous’
[13:23:27.114]   - Field: ‘calls’
[13:23:27.114]   - Field: ‘globals’
[13:23:27.114]   - Field: ‘stdout’
[13:23:27.114]   - Field: ‘earlySignal’
[13:23:27.114]   - Field: ‘lazy’
[13:23:27.114]   - Field: ‘state’
[13:23:27.115] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:27.115] - Launch lazy future ...
[13:23:27.115] Packages needed by the future expression (n = 0): <none>
[13:23:27.115] Packages needed by future strategies (n = 0): <none>
[13:23:27.116] {
[13:23:27.116]     {
[13:23:27.116]         {
[13:23:27.116]             ...future.startTime <- base::Sys.time()
[13:23:27.116]             {
[13:23:27.116]                 {
[13:23:27.116]                   {
[13:23:27.116]                     {
[13:23:27.116]                       base::local({
[13:23:27.116]                         has_future <- base::requireNamespace("future", 
[13:23:27.116]                           quietly = TRUE)
[13:23:27.116]                         if (has_future) {
[13:23:27.116]                           ns <- base::getNamespace("future")
[13:23:27.116]                           version <- ns[[".package"]][["version"]]
[13:23:27.116]                           if (is.null(version)) 
[13:23:27.116]                             version <- utils::packageVersion("future")
[13:23:27.116]                         }
[13:23:27.116]                         else {
[13:23:27.116]                           version <- NULL
[13:23:27.116]                         }
[13:23:27.116]                         if (!has_future || version < "1.8.0") {
[13:23:27.116]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:27.116]                             "", base::R.version$version.string), 
[13:23:27.116]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:27.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:27.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:27.116]                               "release", "version")], collapse = " "), 
[13:23:27.116]                             hostname = base::Sys.info()[["nodename"]])
[13:23:27.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:27.116]                             info)
[13:23:27.116]                           info <- base::paste(info, collapse = "; ")
[13:23:27.116]                           if (!has_future) {
[13:23:27.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:27.116]                               info)
[13:23:27.116]                           }
[13:23:27.116]                           else {
[13:23:27.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:27.116]                               info, version)
[13:23:27.116]                           }
[13:23:27.116]                           base::stop(msg)
[13:23:27.116]                         }
[13:23:27.116]                       })
[13:23:27.116]                     }
[13:23:27.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:27.116]                     base::options(mc.cores = 1L)
[13:23:27.116]                   }
[13:23:27.116]                   options(future.plan = NULL)
[13:23:27.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:27.116]                 }
[13:23:27.116]                 ...future.workdir <- getwd()
[13:23:27.116]             }
[13:23:27.116]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:27.116]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:27.116]         }
[13:23:27.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:27.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:27.116]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:27.116]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:27.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:27.116]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:27.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:27.116]             base::names(...future.oldOptions))
[13:23:27.116]     }
[13:23:27.116]     if (FALSE) {
[13:23:27.116]     }
[13:23:27.116]     else {
[13:23:27.116]         if (TRUE) {
[13:23:27.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:27.116]                 open = "w")
[13:23:27.116]         }
[13:23:27.116]         else {
[13:23:27.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:27.116]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:27.116]         }
[13:23:27.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:27.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:27.116]             base::sink(type = "output", split = FALSE)
[13:23:27.116]             base::close(...future.stdout)
[13:23:27.116]         }, add = TRUE)
[13:23:27.116]     }
[13:23:27.116]     ...future.frame <- base::sys.nframe()
[13:23:27.116]     ...future.conditions <- base::list()
[13:23:27.116]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:27.116]     if (FALSE) {
[13:23:27.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:27.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:27.116]     }
[13:23:27.116]     ...future.result <- base::tryCatch({
[13:23:27.116]         base::withCallingHandlers({
[13:23:27.116]             ...future.value <- base::withVisible(base::local({
[13:23:27.116]                 withCallingHandlers({
[13:23:27.116]                   {
[13:23:27.116]                     x[["a"]] <- 1
[13:23:27.116]                     x
[13:23:27.116]                   }
[13:23:27.116]                 }, immediateCondition = function(cond) {
[13:23:27.116]                   save_rds <- function (object, pathname, ...) 
[13:23:27.116]                   {
[13:23:27.116]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:27.116]                     if (file_test("-f", pathname_tmp)) {
[13:23:27.116]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.116]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:27.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.116]                         fi_tmp[["mtime"]])
[13:23:27.116]                     }
[13:23:27.116]                     tryCatch({
[13:23:27.116]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:27.116]                     }, error = function(ex) {
[13:23:27.116]                       msg <- conditionMessage(ex)
[13:23:27.116]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.116]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:27.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.116]                         fi_tmp[["mtime"]], msg)
[13:23:27.116]                       ex$message <- msg
[13:23:27.116]                       stop(ex)
[13:23:27.116]                     })
[13:23:27.116]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:27.116]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:27.116]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:27.116]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.116]                       fi <- file.info(pathname)
[13:23:27.116]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:27.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.116]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:27.116]                         fi[["size"]], fi[["mtime"]])
[13:23:27.116]                       stop(msg)
[13:23:27.116]                     }
[13:23:27.116]                     invisible(pathname)
[13:23:27.116]                   }
[13:23:27.116]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:27.116]                     rootPath = tempdir()) 
[13:23:27.116]                   {
[13:23:27.116]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:27.116]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:27.116]                       tmpdir = path, fileext = ".rds")
[13:23:27.116]                     save_rds(obj, file)
[13:23:27.116]                   }
[13:23:27.116]                   saveImmediateCondition(cond, path = "/tmp/Rtmpxi2rDI/.future/immediateConditions")
[13:23:27.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.116]                   {
[13:23:27.116]                     inherits <- base::inherits
[13:23:27.116]                     invokeRestart <- base::invokeRestart
[13:23:27.116]                     is.null <- base::is.null
[13:23:27.116]                     muffled <- FALSE
[13:23:27.116]                     if (inherits(cond, "message")) {
[13:23:27.116]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:27.116]                       if (muffled) 
[13:23:27.116]                         invokeRestart("muffleMessage")
[13:23:27.116]                     }
[13:23:27.116]                     else if (inherits(cond, "warning")) {
[13:23:27.116]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:27.116]                       if (muffled) 
[13:23:27.116]                         invokeRestart("muffleWarning")
[13:23:27.116]                     }
[13:23:27.116]                     else if (inherits(cond, "condition")) {
[13:23:27.116]                       if (!is.null(pattern)) {
[13:23:27.116]                         computeRestarts <- base::computeRestarts
[13:23:27.116]                         grepl <- base::grepl
[13:23:27.116]                         restarts <- computeRestarts(cond)
[13:23:27.116]                         for (restart in restarts) {
[13:23:27.116]                           name <- restart$name
[13:23:27.116]                           if (is.null(name)) 
[13:23:27.116]                             next
[13:23:27.116]                           if (!grepl(pattern, name)) 
[13:23:27.116]                             next
[13:23:27.116]                           invokeRestart(restart)
[13:23:27.116]                           muffled <- TRUE
[13:23:27.116]                           break
[13:23:27.116]                         }
[13:23:27.116]                       }
[13:23:27.116]                     }
[13:23:27.116]                     invisible(muffled)
[13:23:27.116]                   }
[13:23:27.116]                   muffleCondition(cond)
[13:23:27.116]                 })
[13:23:27.116]             }))
[13:23:27.116]             future::FutureResult(value = ...future.value$value, 
[13:23:27.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.116]                   ...future.rng), globalenv = if (FALSE) 
[13:23:27.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:27.116]                     ...future.globalenv.names))
[13:23:27.116]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:27.116]         }, condition = base::local({
[13:23:27.116]             c <- base::c
[13:23:27.116]             inherits <- base::inherits
[13:23:27.116]             invokeRestart <- base::invokeRestart
[13:23:27.116]             length <- base::length
[13:23:27.116]             list <- base::list
[13:23:27.116]             seq.int <- base::seq.int
[13:23:27.116]             signalCondition <- base::signalCondition
[13:23:27.116]             sys.calls <- base::sys.calls
[13:23:27.116]             `[[` <- base::`[[`
[13:23:27.116]             `+` <- base::`+`
[13:23:27.116]             `<<-` <- base::`<<-`
[13:23:27.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:27.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:27.116]                   3L)]
[13:23:27.116]             }
[13:23:27.116]             function(cond) {
[13:23:27.116]                 is_error <- inherits(cond, "error")
[13:23:27.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:27.116]                   NULL)
[13:23:27.116]                 if (is_error) {
[13:23:27.116]                   sessionInformation <- function() {
[13:23:27.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:27.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:27.116]                       search = base::search(), system = base::Sys.info())
[13:23:27.116]                   }
[13:23:27.116]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:27.116]                     cond$call), session = sessionInformation(), 
[13:23:27.116]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:27.116]                   signalCondition(cond)
[13:23:27.116]                 }
[13:23:27.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:27.116]                 "immediateCondition"))) {
[13:23:27.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:27.116]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:27.116]                   if (TRUE && !signal) {
[13:23:27.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.116]                     {
[13:23:27.116]                       inherits <- base::inherits
[13:23:27.116]                       invokeRestart <- base::invokeRestart
[13:23:27.116]                       is.null <- base::is.null
[13:23:27.116]                       muffled <- FALSE
[13:23:27.116]                       if (inherits(cond, "message")) {
[13:23:27.116]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.116]                         if (muffled) 
[13:23:27.116]                           invokeRestart("muffleMessage")
[13:23:27.116]                       }
[13:23:27.116]                       else if (inherits(cond, "warning")) {
[13:23:27.116]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.116]                         if (muffled) 
[13:23:27.116]                           invokeRestart("muffleWarning")
[13:23:27.116]                       }
[13:23:27.116]                       else if (inherits(cond, "condition")) {
[13:23:27.116]                         if (!is.null(pattern)) {
[13:23:27.116]                           computeRestarts <- base::computeRestarts
[13:23:27.116]                           grepl <- base::grepl
[13:23:27.116]                           restarts <- computeRestarts(cond)
[13:23:27.116]                           for (restart in restarts) {
[13:23:27.116]                             name <- restart$name
[13:23:27.116]                             if (is.null(name)) 
[13:23:27.116]                               next
[13:23:27.116]                             if (!grepl(pattern, name)) 
[13:23:27.116]                               next
[13:23:27.116]                             invokeRestart(restart)
[13:23:27.116]                             muffled <- TRUE
[13:23:27.116]                             break
[13:23:27.116]                           }
[13:23:27.116]                         }
[13:23:27.116]                       }
[13:23:27.116]                       invisible(muffled)
[13:23:27.116]                     }
[13:23:27.116]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.116]                   }
[13:23:27.116]                 }
[13:23:27.116]                 else {
[13:23:27.116]                   if (TRUE) {
[13:23:27.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.116]                     {
[13:23:27.116]                       inherits <- base::inherits
[13:23:27.116]                       invokeRestart <- base::invokeRestart
[13:23:27.116]                       is.null <- base::is.null
[13:23:27.116]                       muffled <- FALSE
[13:23:27.116]                       if (inherits(cond, "message")) {
[13:23:27.116]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.116]                         if (muffled) 
[13:23:27.116]                           invokeRestart("muffleMessage")
[13:23:27.116]                       }
[13:23:27.116]                       else if (inherits(cond, "warning")) {
[13:23:27.116]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.116]                         if (muffled) 
[13:23:27.116]                           invokeRestart("muffleWarning")
[13:23:27.116]                       }
[13:23:27.116]                       else if (inherits(cond, "condition")) {
[13:23:27.116]                         if (!is.null(pattern)) {
[13:23:27.116]                           computeRestarts <- base::computeRestarts
[13:23:27.116]                           grepl <- base::grepl
[13:23:27.116]                           restarts <- computeRestarts(cond)
[13:23:27.116]                           for (restart in restarts) {
[13:23:27.116]                             name <- restart$name
[13:23:27.116]                             if (is.null(name)) 
[13:23:27.116]                               next
[13:23:27.116]                             if (!grepl(pattern, name)) 
[13:23:27.116]                               next
[13:23:27.116]                             invokeRestart(restart)
[13:23:27.116]                             muffled <- TRUE
[13:23:27.116]                             break
[13:23:27.116]                           }
[13:23:27.116]                         }
[13:23:27.116]                       }
[13:23:27.116]                       invisible(muffled)
[13:23:27.116]                     }
[13:23:27.116]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.116]                   }
[13:23:27.116]                 }
[13:23:27.116]             }
[13:23:27.116]         }))
[13:23:27.116]     }, error = function(ex) {
[13:23:27.116]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:27.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.116]                 ...future.rng), started = ...future.startTime, 
[13:23:27.116]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:27.116]             version = "1.8"), class = "FutureResult")
[13:23:27.116]     }, finally = {
[13:23:27.116]         if (!identical(...future.workdir, getwd())) 
[13:23:27.116]             setwd(...future.workdir)
[13:23:27.116]         {
[13:23:27.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:27.116]                 ...future.oldOptions$nwarnings <- NULL
[13:23:27.116]             }
[13:23:27.116]             base::options(...future.oldOptions)
[13:23:27.116]             if (.Platform$OS.type == "windows") {
[13:23:27.116]                 old_names <- names(...future.oldEnvVars)
[13:23:27.116]                 envs <- base::Sys.getenv()
[13:23:27.116]                 names <- names(envs)
[13:23:27.116]                 common <- intersect(names, old_names)
[13:23:27.116]                 added <- setdiff(names, old_names)
[13:23:27.116]                 removed <- setdiff(old_names, names)
[13:23:27.116]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:27.116]                   envs[common]]
[13:23:27.116]                 NAMES <- toupper(changed)
[13:23:27.116]                 args <- list()
[13:23:27.116]                 for (kk in seq_along(NAMES)) {
[13:23:27.116]                   name <- changed[[kk]]
[13:23:27.116]                   NAME <- NAMES[[kk]]
[13:23:27.116]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.116]                     next
[13:23:27.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.116]                 }
[13:23:27.116]                 NAMES <- toupper(added)
[13:23:27.116]                 for (kk in seq_along(NAMES)) {
[13:23:27.116]                   name <- added[[kk]]
[13:23:27.116]                   NAME <- NAMES[[kk]]
[13:23:27.116]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.116]                     next
[13:23:27.116]                   args[[name]] <- ""
[13:23:27.116]                 }
[13:23:27.116]                 NAMES <- toupper(removed)
[13:23:27.116]                 for (kk in seq_along(NAMES)) {
[13:23:27.116]                   name <- removed[[kk]]
[13:23:27.116]                   NAME <- NAMES[[kk]]
[13:23:27.116]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.116]                     next
[13:23:27.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.116]                 }
[13:23:27.116]                 if (length(args) > 0) 
[13:23:27.116]                   base::do.call(base::Sys.setenv, args = args)
[13:23:27.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:27.116]             }
[13:23:27.116]             else {
[13:23:27.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:27.116]             }
[13:23:27.116]             {
[13:23:27.116]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:27.116]                   0L) {
[13:23:27.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:27.116]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:27.116]                   base::options(opts)
[13:23:27.116]                 }
[13:23:27.116]                 {
[13:23:27.116]                   {
[13:23:27.116]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:27.116]                     NULL
[13:23:27.116]                   }
[13:23:27.116]                   options(future.plan = NULL)
[13:23:27.116]                   if (is.na(NA_character_)) 
[13:23:27.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:27.116]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:27.116]                     envir = parent.frame()) 
[13:23:27.116]                   {
[13:23:27.116]                     default_workers <- missing(workers)
[13:23:27.116]                     if (is.function(workers)) 
[13:23:27.116]                       workers <- workers()
[13:23:27.116]                     workers <- structure(as.integer(workers), 
[13:23:27.116]                       class = class(workers))
[13:23:27.116]                     stop_if_not(is.finite(workers), workers >= 
[13:23:27.116]                       1L)
[13:23:27.116]                     if ((workers == 1L && !inherits(workers, 
[13:23:27.116]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:27.116]                       if (default_workers) 
[13:23:27.116]                         supportsMulticore(warn = TRUE)
[13:23:27.116]                       return(sequential(..., envir = envir))
[13:23:27.116]                     }
[13:23:27.116]                     oopts <- options(mc.cores = workers)
[13:23:27.116]                     on.exit(options(oopts))
[13:23:27.116]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:27.116]                       envir = envir)
[13:23:27.116]                     if (!future$lazy) 
[13:23:27.116]                       future <- run(future)
[13:23:27.116]                     invisible(future)
[13:23:27.116]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:27.116]                 }
[13:23:27.116]             }
[13:23:27.116]         }
[13:23:27.116]     })
[13:23:27.116]     if (TRUE) {
[13:23:27.116]         base::sink(type = "output", split = FALSE)
[13:23:27.116]         if (TRUE) {
[13:23:27.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:27.116]         }
[13:23:27.116]         else {
[13:23:27.116]             ...future.result["stdout"] <- base::list(NULL)
[13:23:27.116]         }
[13:23:27.116]         base::close(...future.stdout)
[13:23:27.116]         ...future.stdout <- NULL
[13:23:27.116]     }
[13:23:27.116]     ...future.result$conditions <- ...future.conditions
[13:23:27.116]     ...future.result$finished <- base::Sys.time()
[13:23:27.116]     ...future.result
[13:23:27.116] }
[13:23:27.119] assign_globals() ...
[13:23:27.119] List of 1
[13:23:27.119]  $ x: list()
[13:23:27.119]  - attr(*, "where")=List of 1
[13:23:27.119]   ..$ x:<environment: R_EmptyEnv> 
[13:23:27.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:27.119]  - attr(*, "resolved")= logi TRUE
[13:23:27.119]  - attr(*, "total_size")= num 0
[13:23:27.119]  - attr(*, "already-done")= logi TRUE
[13:23:27.122] - copied ‘x’ to environment
[13:23:27.122] assign_globals() ... done
[13:23:27.122] requestCore(): workers = 2
[13:23:27.124] MulticoreFuture started
[13:23:27.125] - Launch lazy future ... done
[13:23:27.125] run() for ‘MulticoreFuture’ ... done
[13:23:27.125] result() for MulticoreFuture ...
[13:23:27.126] plan(): Setting new future strategy stack:
[13:23:27.126] List of future strategies:
[13:23:27.126] 1. sequential:
[13:23:27.126]    - args: function (..., envir = parent.frame())
[13:23:27.126]    - tweaked: FALSE
[13:23:27.126]    - call: NULL
[13:23:27.127] plan(): nbrOfWorkers() = 1
[13:23:27.129] plan(): Setting new future strategy stack:
[13:23:27.129] List of future strategies:
[13:23:27.129] 1. multicore:
[13:23:27.129]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:27.129]    - tweaked: FALSE
[13:23:27.129]    - call: plan(strategy)
[13:23:27.134] plan(): nbrOfWorkers() = 2
[13:23:27.135] result() for MulticoreFuture ...
[13:23:27.135] result() for MulticoreFuture ... done
[13:23:27.135] result() for MulticoreFuture ... done
[13:23:27.135] result() for MulticoreFuture ...
[13:23:27.136] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:27.136] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:27.136] Searching for globals...
[13:23:27.139] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:27.139] Searching for globals ... DONE
[13:23:27.139] Resolving globals: TRUE
[13:23:27.139] Resolving any globals that are futures ...
[13:23:27.140] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:27.140] Resolving any globals that are futures ... DONE
[13:23:27.140] Resolving futures part of globals (recursively) ...
[13:23:27.141] resolve() on list ...
[13:23:27.141]  recursive: 99
[13:23:27.141]  length: 1
[13:23:27.141]  elements: ‘x’
[13:23:27.141]  length: 0 (resolved future 1)
[13:23:27.141] resolve() on list ... DONE
[13:23:27.141] - globals: [1] ‘x’
[13:23:27.141] Resolving futures part of globals (recursively) ... DONE
[13:23:27.142] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:27.142] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:27.142] - globals: [1] ‘x’
[13:23:27.142] 
[13:23:27.142] getGlobalsAndPackages() ... DONE
[13:23:27.145] run() for ‘Future’ ...
[13:23:27.146] - state: ‘created’
[13:23:27.146] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:27.150] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:27.151] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:27.151]   - Field: ‘label’
[13:23:27.151]   - Field: ‘local’
[13:23:27.151]   - Field: ‘owner’
[13:23:27.151]   - Field: ‘envir’
[13:23:27.151]   - Field: ‘workers’
[13:23:27.151]   - Field: ‘packages’
[13:23:27.151]   - Field: ‘gc’
[13:23:27.152]   - Field: ‘job’
[13:23:27.152]   - Field: ‘conditions’
[13:23:27.152]   - Field: ‘expr’
[13:23:27.152]   - Field: ‘uuid’
[13:23:27.152]   - Field: ‘seed’
[13:23:27.152]   - Field: ‘version’
[13:23:27.152]   - Field: ‘result’
[13:23:27.153]   - Field: ‘asynchronous’
[13:23:27.153]   - Field: ‘calls’
[13:23:27.153]   - Field: ‘globals’
[13:23:27.153]   - Field: ‘stdout’
[13:23:27.153]   - Field: ‘earlySignal’
[13:23:27.153]   - Field: ‘lazy’
[13:23:27.153]   - Field: ‘state’
[13:23:27.153] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:27.153] - Launch lazy future ...
[13:23:27.154] Packages needed by the future expression (n = 0): <none>
[13:23:27.154] Packages needed by future strategies (n = 0): <none>
[13:23:27.155] {
[13:23:27.155]     {
[13:23:27.155]         {
[13:23:27.155]             ...future.startTime <- base::Sys.time()
[13:23:27.155]             {
[13:23:27.155]                 {
[13:23:27.155]                   {
[13:23:27.155]                     {
[13:23:27.155]                       base::local({
[13:23:27.155]                         has_future <- base::requireNamespace("future", 
[13:23:27.155]                           quietly = TRUE)
[13:23:27.155]                         if (has_future) {
[13:23:27.155]                           ns <- base::getNamespace("future")
[13:23:27.155]                           version <- ns[[".package"]][["version"]]
[13:23:27.155]                           if (is.null(version)) 
[13:23:27.155]                             version <- utils::packageVersion("future")
[13:23:27.155]                         }
[13:23:27.155]                         else {
[13:23:27.155]                           version <- NULL
[13:23:27.155]                         }
[13:23:27.155]                         if (!has_future || version < "1.8.0") {
[13:23:27.155]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:27.155]                             "", base::R.version$version.string), 
[13:23:27.155]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:27.155]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:27.155]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:27.155]                               "release", "version")], collapse = " "), 
[13:23:27.155]                             hostname = base::Sys.info()[["nodename"]])
[13:23:27.155]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:27.155]                             info)
[13:23:27.155]                           info <- base::paste(info, collapse = "; ")
[13:23:27.155]                           if (!has_future) {
[13:23:27.155]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:27.155]                               info)
[13:23:27.155]                           }
[13:23:27.155]                           else {
[13:23:27.155]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:27.155]                               info, version)
[13:23:27.155]                           }
[13:23:27.155]                           base::stop(msg)
[13:23:27.155]                         }
[13:23:27.155]                       })
[13:23:27.155]                     }
[13:23:27.155]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:27.155]                     base::options(mc.cores = 1L)
[13:23:27.155]                   }
[13:23:27.155]                   options(future.plan = NULL)
[13:23:27.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:27.155]                 }
[13:23:27.155]                 ...future.workdir <- getwd()
[13:23:27.155]             }
[13:23:27.155]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:27.155]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:27.155]         }
[13:23:27.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:27.155]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:27.155]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:27.155]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:27.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:27.155]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:27.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:27.155]             base::names(...future.oldOptions))
[13:23:27.155]     }
[13:23:27.155]     if (FALSE) {
[13:23:27.155]     }
[13:23:27.155]     else {
[13:23:27.155]         if (TRUE) {
[13:23:27.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:27.155]                 open = "w")
[13:23:27.155]         }
[13:23:27.155]         else {
[13:23:27.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:27.155]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:27.155]         }
[13:23:27.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:27.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:27.155]             base::sink(type = "output", split = FALSE)
[13:23:27.155]             base::close(...future.stdout)
[13:23:27.155]         }, add = TRUE)
[13:23:27.155]     }
[13:23:27.155]     ...future.frame <- base::sys.nframe()
[13:23:27.155]     ...future.conditions <- base::list()
[13:23:27.155]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:27.155]     if (FALSE) {
[13:23:27.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:27.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:27.155]     }
[13:23:27.155]     ...future.result <- base::tryCatch({
[13:23:27.155]         base::withCallingHandlers({
[13:23:27.155]             ...future.value <- base::withVisible(base::local({
[13:23:27.155]                 withCallingHandlers({
[13:23:27.155]                   {
[13:23:27.155]                     x[["a"]] <- 1
[13:23:27.155]                     x
[13:23:27.155]                   }
[13:23:27.155]                 }, immediateCondition = function(cond) {
[13:23:27.155]                   save_rds <- function (object, pathname, ...) 
[13:23:27.155]                   {
[13:23:27.155]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:27.155]                     if (file_test("-f", pathname_tmp)) {
[13:23:27.155]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.155]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:27.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.155]                         fi_tmp[["mtime"]])
[13:23:27.155]                     }
[13:23:27.155]                     tryCatch({
[13:23:27.155]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:27.155]                     }, error = function(ex) {
[13:23:27.155]                       msg <- conditionMessage(ex)
[13:23:27.155]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.155]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:27.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.155]                         fi_tmp[["mtime"]], msg)
[13:23:27.155]                       ex$message <- msg
[13:23:27.155]                       stop(ex)
[13:23:27.155]                     })
[13:23:27.155]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:27.155]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:27.155]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:27.155]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.155]                       fi <- file.info(pathname)
[13:23:27.155]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:27.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.155]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:27.155]                         fi[["size"]], fi[["mtime"]])
[13:23:27.155]                       stop(msg)
[13:23:27.155]                     }
[13:23:27.155]                     invisible(pathname)
[13:23:27.155]                   }
[13:23:27.155]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:27.155]                     rootPath = tempdir()) 
[13:23:27.155]                   {
[13:23:27.155]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:27.155]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:27.155]                       tmpdir = path, fileext = ".rds")
[13:23:27.155]                     save_rds(obj, file)
[13:23:27.155]                   }
[13:23:27.155]                   saveImmediateCondition(cond, path = "/tmp/Rtmpxi2rDI/.future/immediateConditions")
[13:23:27.155]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.155]                   {
[13:23:27.155]                     inherits <- base::inherits
[13:23:27.155]                     invokeRestart <- base::invokeRestart
[13:23:27.155]                     is.null <- base::is.null
[13:23:27.155]                     muffled <- FALSE
[13:23:27.155]                     if (inherits(cond, "message")) {
[13:23:27.155]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:27.155]                       if (muffled) 
[13:23:27.155]                         invokeRestart("muffleMessage")
[13:23:27.155]                     }
[13:23:27.155]                     else if (inherits(cond, "warning")) {
[13:23:27.155]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:27.155]                       if (muffled) 
[13:23:27.155]                         invokeRestart("muffleWarning")
[13:23:27.155]                     }
[13:23:27.155]                     else if (inherits(cond, "condition")) {
[13:23:27.155]                       if (!is.null(pattern)) {
[13:23:27.155]                         computeRestarts <- base::computeRestarts
[13:23:27.155]                         grepl <- base::grepl
[13:23:27.155]                         restarts <- computeRestarts(cond)
[13:23:27.155]                         for (restart in restarts) {
[13:23:27.155]                           name <- restart$name
[13:23:27.155]                           if (is.null(name)) 
[13:23:27.155]                             next
[13:23:27.155]                           if (!grepl(pattern, name)) 
[13:23:27.155]                             next
[13:23:27.155]                           invokeRestart(restart)
[13:23:27.155]                           muffled <- TRUE
[13:23:27.155]                           break
[13:23:27.155]                         }
[13:23:27.155]                       }
[13:23:27.155]                     }
[13:23:27.155]                     invisible(muffled)
[13:23:27.155]                   }
[13:23:27.155]                   muffleCondition(cond)
[13:23:27.155]                 })
[13:23:27.155]             }))
[13:23:27.155]             future::FutureResult(value = ...future.value$value, 
[13:23:27.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.155]                   ...future.rng), globalenv = if (FALSE) 
[13:23:27.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:27.155]                     ...future.globalenv.names))
[13:23:27.155]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:27.155]         }, condition = base::local({
[13:23:27.155]             c <- base::c
[13:23:27.155]             inherits <- base::inherits
[13:23:27.155]             invokeRestart <- base::invokeRestart
[13:23:27.155]             length <- base::length
[13:23:27.155]             list <- base::list
[13:23:27.155]             seq.int <- base::seq.int
[13:23:27.155]             signalCondition <- base::signalCondition
[13:23:27.155]             sys.calls <- base::sys.calls
[13:23:27.155]             `[[` <- base::`[[`
[13:23:27.155]             `+` <- base::`+`
[13:23:27.155]             `<<-` <- base::`<<-`
[13:23:27.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:27.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:27.155]                   3L)]
[13:23:27.155]             }
[13:23:27.155]             function(cond) {
[13:23:27.155]                 is_error <- inherits(cond, "error")
[13:23:27.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:27.155]                   NULL)
[13:23:27.155]                 if (is_error) {
[13:23:27.155]                   sessionInformation <- function() {
[13:23:27.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:27.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:27.155]                       search = base::search(), system = base::Sys.info())
[13:23:27.155]                   }
[13:23:27.155]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:27.155]                     cond$call), session = sessionInformation(), 
[13:23:27.155]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:27.155]                   signalCondition(cond)
[13:23:27.155]                 }
[13:23:27.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:27.155]                 "immediateCondition"))) {
[13:23:27.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:27.155]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:27.155]                   if (TRUE && !signal) {
[13:23:27.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.155]                     {
[13:23:27.155]                       inherits <- base::inherits
[13:23:27.155]                       invokeRestart <- base::invokeRestart
[13:23:27.155]                       is.null <- base::is.null
[13:23:27.155]                       muffled <- FALSE
[13:23:27.155]                       if (inherits(cond, "message")) {
[13:23:27.155]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.155]                         if (muffled) 
[13:23:27.155]                           invokeRestart("muffleMessage")
[13:23:27.155]                       }
[13:23:27.155]                       else if (inherits(cond, "warning")) {
[13:23:27.155]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.155]                         if (muffled) 
[13:23:27.155]                           invokeRestart("muffleWarning")
[13:23:27.155]                       }
[13:23:27.155]                       else if (inherits(cond, "condition")) {
[13:23:27.155]                         if (!is.null(pattern)) {
[13:23:27.155]                           computeRestarts <- base::computeRestarts
[13:23:27.155]                           grepl <- base::grepl
[13:23:27.155]                           restarts <- computeRestarts(cond)
[13:23:27.155]                           for (restart in restarts) {
[13:23:27.155]                             name <- restart$name
[13:23:27.155]                             if (is.null(name)) 
[13:23:27.155]                               next
[13:23:27.155]                             if (!grepl(pattern, name)) 
[13:23:27.155]                               next
[13:23:27.155]                             invokeRestart(restart)
[13:23:27.155]                             muffled <- TRUE
[13:23:27.155]                             break
[13:23:27.155]                           }
[13:23:27.155]                         }
[13:23:27.155]                       }
[13:23:27.155]                       invisible(muffled)
[13:23:27.155]                     }
[13:23:27.155]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.155]                   }
[13:23:27.155]                 }
[13:23:27.155]                 else {
[13:23:27.155]                   if (TRUE) {
[13:23:27.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.155]                     {
[13:23:27.155]                       inherits <- base::inherits
[13:23:27.155]                       invokeRestart <- base::invokeRestart
[13:23:27.155]                       is.null <- base::is.null
[13:23:27.155]                       muffled <- FALSE
[13:23:27.155]                       if (inherits(cond, "message")) {
[13:23:27.155]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.155]                         if (muffled) 
[13:23:27.155]                           invokeRestart("muffleMessage")
[13:23:27.155]                       }
[13:23:27.155]                       else if (inherits(cond, "warning")) {
[13:23:27.155]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.155]                         if (muffled) 
[13:23:27.155]                           invokeRestart("muffleWarning")
[13:23:27.155]                       }
[13:23:27.155]                       else if (inherits(cond, "condition")) {
[13:23:27.155]                         if (!is.null(pattern)) {
[13:23:27.155]                           computeRestarts <- base::computeRestarts
[13:23:27.155]                           grepl <- base::grepl
[13:23:27.155]                           restarts <- computeRestarts(cond)
[13:23:27.155]                           for (restart in restarts) {
[13:23:27.155]                             name <- restart$name
[13:23:27.155]                             if (is.null(name)) 
[13:23:27.155]                               next
[13:23:27.155]                             if (!grepl(pattern, name)) 
[13:23:27.155]                               next
[13:23:27.155]                             invokeRestart(restart)
[13:23:27.155]                             muffled <- TRUE
[13:23:27.155]                             break
[13:23:27.155]                           }
[13:23:27.155]                         }
[13:23:27.155]                       }
[13:23:27.155]                       invisible(muffled)
[13:23:27.155]                     }
[13:23:27.155]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.155]                   }
[13:23:27.155]                 }
[13:23:27.155]             }
[13:23:27.155]         }))
[13:23:27.155]     }, error = function(ex) {
[13:23:27.155]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:27.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.155]                 ...future.rng), started = ...future.startTime, 
[13:23:27.155]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:27.155]             version = "1.8"), class = "FutureResult")
[13:23:27.155]     }, finally = {
[13:23:27.155]         if (!identical(...future.workdir, getwd())) 
[13:23:27.155]             setwd(...future.workdir)
[13:23:27.155]         {
[13:23:27.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:27.155]                 ...future.oldOptions$nwarnings <- NULL
[13:23:27.155]             }
[13:23:27.155]             base::options(...future.oldOptions)
[13:23:27.155]             if (.Platform$OS.type == "windows") {
[13:23:27.155]                 old_names <- names(...future.oldEnvVars)
[13:23:27.155]                 envs <- base::Sys.getenv()
[13:23:27.155]                 names <- names(envs)
[13:23:27.155]                 common <- intersect(names, old_names)
[13:23:27.155]                 added <- setdiff(names, old_names)
[13:23:27.155]                 removed <- setdiff(old_names, names)
[13:23:27.155]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:27.155]                   envs[common]]
[13:23:27.155]                 NAMES <- toupper(changed)
[13:23:27.155]                 args <- list()
[13:23:27.155]                 for (kk in seq_along(NAMES)) {
[13:23:27.155]                   name <- changed[[kk]]
[13:23:27.155]                   NAME <- NAMES[[kk]]
[13:23:27.155]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.155]                     next
[13:23:27.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.155]                 }
[13:23:27.155]                 NAMES <- toupper(added)
[13:23:27.155]                 for (kk in seq_along(NAMES)) {
[13:23:27.155]                   name <- added[[kk]]
[13:23:27.155]                   NAME <- NAMES[[kk]]
[13:23:27.155]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.155]                     next
[13:23:27.155]                   args[[name]] <- ""
[13:23:27.155]                 }
[13:23:27.155]                 NAMES <- toupper(removed)
[13:23:27.155]                 for (kk in seq_along(NAMES)) {
[13:23:27.155]                   name <- removed[[kk]]
[13:23:27.155]                   NAME <- NAMES[[kk]]
[13:23:27.155]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.155]                     next
[13:23:27.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.155]                 }
[13:23:27.155]                 if (length(args) > 0) 
[13:23:27.155]                   base::do.call(base::Sys.setenv, args = args)
[13:23:27.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:27.155]             }
[13:23:27.155]             else {
[13:23:27.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:27.155]             }
[13:23:27.155]             {
[13:23:27.155]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:27.155]                   0L) {
[13:23:27.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:27.155]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:27.155]                   base::options(opts)
[13:23:27.155]                 }
[13:23:27.155]                 {
[13:23:27.155]                   {
[13:23:27.155]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:27.155]                     NULL
[13:23:27.155]                   }
[13:23:27.155]                   options(future.plan = NULL)
[13:23:27.155]                   if (is.na(NA_character_)) 
[13:23:27.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:27.155]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:27.155]                     envir = parent.frame()) 
[13:23:27.155]                   {
[13:23:27.155]                     default_workers <- missing(workers)
[13:23:27.155]                     if (is.function(workers)) 
[13:23:27.155]                       workers <- workers()
[13:23:27.155]                     workers <- structure(as.integer(workers), 
[13:23:27.155]                       class = class(workers))
[13:23:27.155]                     stop_if_not(is.finite(workers), workers >= 
[13:23:27.155]                       1L)
[13:23:27.155]                     if ((workers == 1L && !inherits(workers, 
[13:23:27.155]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:27.155]                       if (default_workers) 
[13:23:27.155]                         supportsMulticore(warn = TRUE)
[13:23:27.155]                       return(sequential(..., envir = envir))
[13:23:27.155]                     }
[13:23:27.155]                     oopts <- options(mc.cores = workers)
[13:23:27.155]                     on.exit(options(oopts))
[13:23:27.155]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:27.155]                       envir = envir)
[13:23:27.155]                     if (!future$lazy) 
[13:23:27.155]                       future <- run(future)
[13:23:27.155]                     invisible(future)
[13:23:27.155]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:27.155]                 }
[13:23:27.155]             }
[13:23:27.155]         }
[13:23:27.155]     })
[13:23:27.155]     if (TRUE) {
[13:23:27.155]         base::sink(type = "output", split = FALSE)
[13:23:27.155]         if (TRUE) {
[13:23:27.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:27.155]         }
[13:23:27.155]         else {
[13:23:27.155]             ...future.result["stdout"] <- base::list(NULL)
[13:23:27.155]         }
[13:23:27.155]         base::close(...future.stdout)
[13:23:27.155]         ...future.stdout <- NULL
[13:23:27.155]     }
[13:23:27.155]     ...future.result$conditions <- ...future.conditions
[13:23:27.155]     ...future.result$finished <- base::Sys.time()
[13:23:27.155]     ...future.result
[13:23:27.155] }
[13:23:27.157] assign_globals() ...
[13:23:27.157] List of 1
[13:23:27.157]  $ x: list()
[13:23:27.157]  - attr(*, "where")=List of 1
[13:23:27.157]   ..$ x:<environment: R_EmptyEnv> 
[13:23:27.157]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:27.157]  - attr(*, "resolved")= logi TRUE
[13:23:27.157]  - attr(*, "total_size")= num 0
[13:23:27.157]  - attr(*, "already-done")= logi TRUE
[13:23:27.160] - copied ‘x’ to environment
[13:23:27.161] assign_globals() ... done
[13:23:27.161] requestCore(): workers = 2
[13:23:27.163] MulticoreFuture started
[13:23:27.163] - Launch lazy future ... done
[13:23:27.163] run() for ‘MulticoreFuture’ ... done
[13:23:27.164] result() for MulticoreFuture ...
[13:23:27.164] plan(): Setting new future strategy stack:
[13:23:27.164] List of future strategies:
[13:23:27.164] 1. sequential:
[13:23:27.164]    - args: function (..., envir = parent.frame())
[13:23:27.164]    - tweaked: FALSE
[13:23:27.164]    - call: NULL
[13:23:27.165] plan(): nbrOfWorkers() = 1
[13:23:27.167] plan(): Setting new future strategy stack:
[13:23:27.167] List of future strategies:
[13:23:27.167] 1. multicore:
[13:23:27.167]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:27.167]    - tweaked: FALSE
[13:23:27.167]    - call: plan(strategy)
[13:23:27.173] plan(): nbrOfWorkers() = 2
[13:23:27.174] result() for MulticoreFuture ...
[13:23:27.174] result() for MulticoreFuture ... done
[13:23:27.174] result() for MulticoreFuture ... done
[13:23:27.174] result() for MulticoreFuture ...
[13:23:27.174] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:27.175] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:27.175] Searching for globals...
[13:23:27.178] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:27.178] Searching for globals ... DONE
[13:23:27.178] Resolving globals: TRUE
[13:23:27.178] Resolving any globals that are futures ...
[13:23:27.179] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:27.179] Resolving any globals that are futures ... DONE
[13:23:27.179] Resolving futures part of globals (recursively) ...
[13:23:27.180] resolve() on list ...
[13:23:27.180]  recursive: 99
[13:23:27.180]  length: 1
[13:23:27.180]  elements: ‘x’
[13:23:27.180]  length: 0 (resolved future 1)
[13:23:27.180] resolve() on list ... DONE
[13:23:27.180] - globals: [1] ‘x’
[13:23:27.180] Resolving futures part of globals (recursively) ... DONE
[13:23:27.181] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:27.181] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:27.181] - globals: [1] ‘x’
[13:23:27.181] 
[13:23:27.182] getGlobalsAndPackages() ... DONE
[13:23:27.182] run() for ‘Future’ ...
[13:23:27.182] - state: ‘created’
[13:23:27.182] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:27.187] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:27.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:27.187]   - Field: ‘label’
[13:23:27.187]   - Field: ‘local’
[13:23:27.187]   - Field: ‘owner’
[13:23:27.187]   - Field: ‘envir’
[13:23:27.187]   - Field: ‘workers’
[13:23:27.187]   - Field: ‘packages’
[13:23:27.188]   - Field: ‘gc’
[13:23:27.188]   - Field: ‘job’
[13:23:27.188]   - Field: ‘conditions’
[13:23:27.188]   - Field: ‘expr’
[13:23:27.188]   - Field: ‘uuid’
[13:23:27.188]   - Field: ‘seed’
[13:23:27.188]   - Field: ‘version’
[13:23:27.188]   - Field: ‘result’
[13:23:27.188]   - Field: ‘asynchronous’
[13:23:27.189]   - Field: ‘calls’
[13:23:27.189]   - Field: ‘globals’
[13:23:27.189]   - Field: ‘stdout’
[13:23:27.189]   - Field: ‘earlySignal’
[13:23:27.189]   - Field: ‘lazy’
[13:23:27.189]   - Field: ‘state’
[13:23:27.189] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:27.189] - Launch lazy future ...
[13:23:27.190] Packages needed by the future expression (n = 0): <none>
[13:23:27.190] Packages needed by future strategies (n = 0): <none>
[13:23:27.191] {
[13:23:27.191]     {
[13:23:27.191]         {
[13:23:27.191]             ...future.startTime <- base::Sys.time()
[13:23:27.191]             {
[13:23:27.191]                 {
[13:23:27.191]                   {
[13:23:27.191]                     {
[13:23:27.191]                       base::local({
[13:23:27.191]                         has_future <- base::requireNamespace("future", 
[13:23:27.191]                           quietly = TRUE)
[13:23:27.191]                         if (has_future) {
[13:23:27.191]                           ns <- base::getNamespace("future")
[13:23:27.191]                           version <- ns[[".package"]][["version"]]
[13:23:27.191]                           if (is.null(version)) 
[13:23:27.191]                             version <- utils::packageVersion("future")
[13:23:27.191]                         }
[13:23:27.191]                         else {
[13:23:27.191]                           version <- NULL
[13:23:27.191]                         }
[13:23:27.191]                         if (!has_future || version < "1.8.0") {
[13:23:27.191]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:27.191]                             "", base::R.version$version.string), 
[13:23:27.191]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:27.191]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:27.191]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:27.191]                               "release", "version")], collapse = " "), 
[13:23:27.191]                             hostname = base::Sys.info()[["nodename"]])
[13:23:27.191]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:27.191]                             info)
[13:23:27.191]                           info <- base::paste(info, collapse = "; ")
[13:23:27.191]                           if (!has_future) {
[13:23:27.191]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:27.191]                               info)
[13:23:27.191]                           }
[13:23:27.191]                           else {
[13:23:27.191]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:27.191]                               info, version)
[13:23:27.191]                           }
[13:23:27.191]                           base::stop(msg)
[13:23:27.191]                         }
[13:23:27.191]                       })
[13:23:27.191]                     }
[13:23:27.191]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:27.191]                     base::options(mc.cores = 1L)
[13:23:27.191]                   }
[13:23:27.191]                   options(future.plan = NULL)
[13:23:27.191]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.191]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:27.191]                 }
[13:23:27.191]                 ...future.workdir <- getwd()
[13:23:27.191]             }
[13:23:27.191]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:27.191]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:27.191]         }
[13:23:27.191]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:27.191]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:27.191]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:27.191]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:27.191]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:27.191]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:27.191]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:27.191]             base::names(...future.oldOptions))
[13:23:27.191]     }
[13:23:27.191]     if (FALSE) {
[13:23:27.191]     }
[13:23:27.191]     else {
[13:23:27.191]         if (TRUE) {
[13:23:27.191]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:27.191]                 open = "w")
[13:23:27.191]         }
[13:23:27.191]         else {
[13:23:27.191]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:27.191]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:27.191]         }
[13:23:27.191]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:27.191]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:27.191]             base::sink(type = "output", split = FALSE)
[13:23:27.191]             base::close(...future.stdout)
[13:23:27.191]         }, add = TRUE)
[13:23:27.191]     }
[13:23:27.191]     ...future.frame <- base::sys.nframe()
[13:23:27.191]     ...future.conditions <- base::list()
[13:23:27.191]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:27.191]     if (FALSE) {
[13:23:27.191]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:27.191]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:27.191]     }
[13:23:27.191]     ...future.result <- base::tryCatch({
[13:23:27.191]         base::withCallingHandlers({
[13:23:27.191]             ...future.value <- base::withVisible(base::local({
[13:23:27.191]                 withCallingHandlers({
[13:23:27.191]                   {
[13:23:27.191]                     x[["a"]] <- 1
[13:23:27.191]                     x
[13:23:27.191]                   }
[13:23:27.191]                 }, immediateCondition = function(cond) {
[13:23:27.191]                   save_rds <- function (object, pathname, ...) 
[13:23:27.191]                   {
[13:23:27.191]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:27.191]                     if (file_test("-f", pathname_tmp)) {
[13:23:27.191]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.191]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:27.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.191]                         fi_tmp[["mtime"]])
[13:23:27.191]                     }
[13:23:27.191]                     tryCatch({
[13:23:27.191]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:27.191]                     }, error = function(ex) {
[13:23:27.191]                       msg <- conditionMessage(ex)
[13:23:27.191]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.191]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:27.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.191]                         fi_tmp[["mtime"]], msg)
[13:23:27.191]                       ex$message <- msg
[13:23:27.191]                       stop(ex)
[13:23:27.191]                     })
[13:23:27.191]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:27.191]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:27.191]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:27.191]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.191]                       fi <- file.info(pathname)
[13:23:27.191]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:27.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.191]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:27.191]                         fi[["size"]], fi[["mtime"]])
[13:23:27.191]                       stop(msg)
[13:23:27.191]                     }
[13:23:27.191]                     invisible(pathname)
[13:23:27.191]                   }
[13:23:27.191]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:27.191]                     rootPath = tempdir()) 
[13:23:27.191]                   {
[13:23:27.191]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:27.191]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:27.191]                       tmpdir = path, fileext = ".rds")
[13:23:27.191]                     save_rds(obj, file)
[13:23:27.191]                   }
[13:23:27.191]                   saveImmediateCondition(cond, path = "/tmp/Rtmpxi2rDI/.future/immediateConditions")
[13:23:27.191]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.191]                   {
[13:23:27.191]                     inherits <- base::inherits
[13:23:27.191]                     invokeRestart <- base::invokeRestart
[13:23:27.191]                     is.null <- base::is.null
[13:23:27.191]                     muffled <- FALSE
[13:23:27.191]                     if (inherits(cond, "message")) {
[13:23:27.191]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:27.191]                       if (muffled) 
[13:23:27.191]                         invokeRestart("muffleMessage")
[13:23:27.191]                     }
[13:23:27.191]                     else if (inherits(cond, "warning")) {
[13:23:27.191]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:27.191]                       if (muffled) 
[13:23:27.191]                         invokeRestart("muffleWarning")
[13:23:27.191]                     }
[13:23:27.191]                     else if (inherits(cond, "condition")) {
[13:23:27.191]                       if (!is.null(pattern)) {
[13:23:27.191]                         computeRestarts <- base::computeRestarts
[13:23:27.191]                         grepl <- base::grepl
[13:23:27.191]                         restarts <- computeRestarts(cond)
[13:23:27.191]                         for (restart in restarts) {
[13:23:27.191]                           name <- restart$name
[13:23:27.191]                           if (is.null(name)) 
[13:23:27.191]                             next
[13:23:27.191]                           if (!grepl(pattern, name)) 
[13:23:27.191]                             next
[13:23:27.191]                           invokeRestart(restart)
[13:23:27.191]                           muffled <- TRUE
[13:23:27.191]                           break
[13:23:27.191]                         }
[13:23:27.191]                       }
[13:23:27.191]                     }
[13:23:27.191]                     invisible(muffled)
[13:23:27.191]                   }
[13:23:27.191]                   muffleCondition(cond)
[13:23:27.191]                 })
[13:23:27.191]             }))
[13:23:27.191]             future::FutureResult(value = ...future.value$value, 
[13:23:27.191]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.191]                   ...future.rng), globalenv = if (FALSE) 
[13:23:27.191]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:27.191]                     ...future.globalenv.names))
[13:23:27.191]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:27.191]         }, condition = base::local({
[13:23:27.191]             c <- base::c
[13:23:27.191]             inherits <- base::inherits
[13:23:27.191]             invokeRestart <- base::invokeRestart
[13:23:27.191]             length <- base::length
[13:23:27.191]             list <- base::list
[13:23:27.191]             seq.int <- base::seq.int
[13:23:27.191]             signalCondition <- base::signalCondition
[13:23:27.191]             sys.calls <- base::sys.calls
[13:23:27.191]             `[[` <- base::`[[`
[13:23:27.191]             `+` <- base::`+`
[13:23:27.191]             `<<-` <- base::`<<-`
[13:23:27.191]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:27.191]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:27.191]                   3L)]
[13:23:27.191]             }
[13:23:27.191]             function(cond) {
[13:23:27.191]                 is_error <- inherits(cond, "error")
[13:23:27.191]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:27.191]                   NULL)
[13:23:27.191]                 if (is_error) {
[13:23:27.191]                   sessionInformation <- function() {
[13:23:27.191]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:27.191]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:27.191]                       search = base::search(), system = base::Sys.info())
[13:23:27.191]                   }
[13:23:27.191]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.191]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:27.191]                     cond$call), session = sessionInformation(), 
[13:23:27.191]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:27.191]                   signalCondition(cond)
[13:23:27.191]                 }
[13:23:27.191]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:27.191]                 "immediateCondition"))) {
[13:23:27.191]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:27.191]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.191]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:27.191]                   if (TRUE && !signal) {
[13:23:27.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.191]                     {
[13:23:27.191]                       inherits <- base::inherits
[13:23:27.191]                       invokeRestart <- base::invokeRestart
[13:23:27.191]                       is.null <- base::is.null
[13:23:27.191]                       muffled <- FALSE
[13:23:27.191]                       if (inherits(cond, "message")) {
[13:23:27.191]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.191]                         if (muffled) 
[13:23:27.191]                           invokeRestart("muffleMessage")
[13:23:27.191]                       }
[13:23:27.191]                       else if (inherits(cond, "warning")) {
[13:23:27.191]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.191]                         if (muffled) 
[13:23:27.191]                           invokeRestart("muffleWarning")
[13:23:27.191]                       }
[13:23:27.191]                       else if (inherits(cond, "condition")) {
[13:23:27.191]                         if (!is.null(pattern)) {
[13:23:27.191]                           computeRestarts <- base::computeRestarts
[13:23:27.191]                           grepl <- base::grepl
[13:23:27.191]                           restarts <- computeRestarts(cond)
[13:23:27.191]                           for (restart in restarts) {
[13:23:27.191]                             name <- restart$name
[13:23:27.191]                             if (is.null(name)) 
[13:23:27.191]                               next
[13:23:27.191]                             if (!grepl(pattern, name)) 
[13:23:27.191]                               next
[13:23:27.191]                             invokeRestart(restart)
[13:23:27.191]                             muffled <- TRUE
[13:23:27.191]                             break
[13:23:27.191]                           }
[13:23:27.191]                         }
[13:23:27.191]                       }
[13:23:27.191]                       invisible(muffled)
[13:23:27.191]                     }
[13:23:27.191]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.191]                   }
[13:23:27.191]                 }
[13:23:27.191]                 else {
[13:23:27.191]                   if (TRUE) {
[13:23:27.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.191]                     {
[13:23:27.191]                       inherits <- base::inherits
[13:23:27.191]                       invokeRestart <- base::invokeRestart
[13:23:27.191]                       is.null <- base::is.null
[13:23:27.191]                       muffled <- FALSE
[13:23:27.191]                       if (inherits(cond, "message")) {
[13:23:27.191]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.191]                         if (muffled) 
[13:23:27.191]                           invokeRestart("muffleMessage")
[13:23:27.191]                       }
[13:23:27.191]                       else if (inherits(cond, "warning")) {
[13:23:27.191]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.191]                         if (muffled) 
[13:23:27.191]                           invokeRestart("muffleWarning")
[13:23:27.191]                       }
[13:23:27.191]                       else if (inherits(cond, "condition")) {
[13:23:27.191]                         if (!is.null(pattern)) {
[13:23:27.191]                           computeRestarts <- base::computeRestarts
[13:23:27.191]                           grepl <- base::grepl
[13:23:27.191]                           restarts <- computeRestarts(cond)
[13:23:27.191]                           for (restart in restarts) {
[13:23:27.191]                             name <- restart$name
[13:23:27.191]                             if (is.null(name)) 
[13:23:27.191]                               next
[13:23:27.191]                             if (!grepl(pattern, name)) 
[13:23:27.191]                               next
[13:23:27.191]                             invokeRestart(restart)
[13:23:27.191]                             muffled <- TRUE
[13:23:27.191]                             break
[13:23:27.191]                           }
[13:23:27.191]                         }
[13:23:27.191]                       }
[13:23:27.191]                       invisible(muffled)
[13:23:27.191]                     }
[13:23:27.191]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.191]                   }
[13:23:27.191]                 }
[13:23:27.191]             }
[13:23:27.191]         }))
[13:23:27.191]     }, error = function(ex) {
[13:23:27.191]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:27.191]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.191]                 ...future.rng), started = ...future.startTime, 
[13:23:27.191]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:27.191]             version = "1.8"), class = "FutureResult")
[13:23:27.191]     }, finally = {
[13:23:27.191]         if (!identical(...future.workdir, getwd())) 
[13:23:27.191]             setwd(...future.workdir)
[13:23:27.191]         {
[13:23:27.191]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:27.191]                 ...future.oldOptions$nwarnings <- NULL
[13:23:27.191]             }
[13:23:27.191]             base::options(...future.oldOptions)
[13:23:27.191]             if (.Platform$OS.type == "windows") {
[13:23:27.191]                 old_names <- names(...future.oldEnvVars)
[13:23:27.191]                 envs <- base::Sys.getenv()
[13:23:27.191]                 names <- names(envs)
[13:23:27.191]                 common <- intersect(names, old_names)
[13:23:27.191]                 added <- setdiff(names, old_names)
[13:23:27.191]                 removed <- setdiff(old_names, names)
[13:23:27.191]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:27.191]                   envs[common]]
[13:23:27.191]                 NAMES <- toupper(changed)
[13:23:27.191]                 args <- list()
[13:23:27.191]                 for (kk in seq_along(NAMES)) {
[13:23:27.191]                   name <- changed[[kk]]
[13:23:27.191]                   NAME <- NAMES[[kk]]
[13:23:27.191]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.191]                     next
[13:23:27.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.191]                 }
[13:23:27.191]                 NAMES <- toupper(added)
[13:23:27.191]                 for (kk in seq_along(NAMES)) {
[13:23:27.191]                   name <- added[[kk]]
[13:23:27.191]                   NAME <- NAMES[[kk]]
[13:23:27.191]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.191]                     next
[13:23:27.191]                   args[[name]] <- ""
[13:23:27.191]                 }
[13:23:27.191]                 NAMES <- toupper(removed)
[13:23:27.191]                 for (kk in seq_along(NAMES)) {
[13:23:27.191]                   name <- removed[[kk]]
[13:23:27.191]                   NAME <- NAMES[[kk]]
[13:23:27.191]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.191]                     next
[13:23:27.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.191]                 }
[13:23:27.191]                 if (length(args) > 0) 
[13:23:27.191]                   base::do.call(base::Sys.setenv, args = args)
[13:23:27.191]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:27.191]             }
[13:23:27.191]             else {
[13:23:27.191]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:27.191]             }
[13:23:27.191]             {
[13:23:27.191]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:27.191]                   0L) {
[13:23:27.191]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:27.191]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:27.191]                   base::options(opts)
[13:23:27.191]                 }
[13:23:27.191]                 {
[13:23:27.191]                   {
[13:23:27.191]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:27.191]                     NULL
[13:23:27.191]                   }
[13:23:27.191]                   options(future.plan = NULL)
[13:23:27.191]                   if (is.na(NA_character_)) 
[13:23:27.191]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.191]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:27.191]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:27.191]                     envir = parent.frame()) 
[13:23:27.191]                   {
[13:23:27.191]                     default_workers <- missing(workers)
[13:23:27.191]                     if (is.function(workers)) 
[13:23:27.191]                       workers <- workers()
[13:23:27.191]                     workers <- structure(as.integer(workers), 
[13:23:27.191]                       class = class(workers))
[13:23:27.191]                     stop_if_not(is.finite(workers), workers >= 
[13:23:27.191]                       1L)
[13:23:27.191]                     if ((workers == 1L && !inherits(workers, 
[13:23:27.191]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:27.191]                       if (default_workers) 
[13:23:27.191]                         supportsMulticore(warn = TRUE)
[13:23:27.191]                       return(sequential(..., envir = envir))
[13:23:27.191]                     }
[13:23:27.191]                     oopts <- options(mc.cores = workers)
[13:23:27.191]                     on.exit(options(oopts))
[13:23:27.191]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:27.191]                       envir = envir)
[13:23:27.191]                     if (!future$lazy) 
[13:23:27.191]                       future <- run(future)
[13:23:27.191]                     invisible(future)
[13:23:27.191]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:27.191]                 }
[13:23:27.191]             }
[13:23:27.191]         }
[13:23:27.191]     })
[13:23:27.191]     if (TRUE) {
[13:23:27.191]         base::sink(type = "output", split = FALSE)
[13:23:27.191]         if (TRUE) {
[13:23:27.191]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:27.191]         }
[13:23:27.191]         else {
[13:23:27.191]             ...future.result["stdout"] <- base::list(NULL)
[13:23:27.191]         }
[13:23:27.191]         base::close(...future.stdout)
[13:23:27.191]         ...future.stdout <- NULL
[13:23:27.191]     }
[13:23:27.191]     ...future.result$conditions <- ...future.conditions
[13:23:27.191]     ...future.result$finished <- base::Sys.time()
[13:23:27.191]     ...future.result
[13:23:27.191] }
[13:23:27.193] assign_globals() ...
[13:23:27.194] List of 1
[13:23:27.194]  $ x: list()
[13:23:27.194]  - attr(*, "where")=List of 1
[13:23:27.194]   ..$ x:<environment: R_EmptyEnv> 
[13:23:27.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:27.194]  - attr(*, "resolved")= logi TRUE
[13:23:27.194]  - attr(*, "total_size")= num 0
[13:23:27.194]  - attr(*, "already-done")= logi TRUE
[13:23:27.199] - copied ‘x’ to environment
[13:23:27.199] assign_globals() ... done
[13:23:27.199] requestCore(): workers = 2
[13:23:27.202] MulticoreFuture started
[13:23:27.202] - Launch lazy future ... done
[13:23:27.203] run() for ‘MulticoreFuture’ ... done
[13:23:27.203] plan(): Setting new future strategy stack:
[13:23:27.203] result() for MulticoreFuture ...
[13:23:27.203] List of future strategies:
[13:23:27.203] 1. sequential:
[13:23:27.203]    - args: function (..., envir = parent.frame())
[13:23:27.203]    - tweaked: FALSE
[13:23:27.203]    - call: NULL
[13:23:27.204] plan(): nbrOfWorkers() = 1
[13:23:27.206] plan(): Setting new future strategy stack:
[13:23:27.207] List of future strategies:
[13:23:27.207] 1. multicore:
[13:23:27.207]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:27.207]    - tweaked: FALSE
[13:23:27.207]    - call: plan(strategy)
[13:23:27.212] plan(): nbrOfWorkers() = 2
[13:23:27.213] result() for MulticoreFuture ...
[13:23:27.213] result() for MulticoreFuture ... done
[13:23:27.213] result() for MulticoreFuture ... done
[13:23:27.214] result() for MulticoreFuture ...
[13:23:27.214] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:27.214] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:27.215] Searching for globals...
[13:23:27.218] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:27.218] Searching for globals ... DONE
[13:23:27.218] Resolving globals: TRUE
[13:23:27.218] Resolving any globals that are futures ...
[13:23:27.218] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:27.219] Resolving any globals that are futures ... DONE
[13:23:27.219] Resolving futures part of globals (recursively) ...
[13:23:27.219] resolve() on list ...
[13:23:27.220]  recursive: 99
[13:23:27.220]  length: 1
[13:23:27.220]  elements: ‘x’
[13:23:27.220]  length: 0 (resolved future 1)
[13:23:27.220] resolve() on list ... DONE
[13:23:27.220] - globals: [1] ‘x’
[13:23:27.220] Resolving futures part of globals (recursively) ... DONE
[13:23:27.221] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:27.221] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:27.221] - globals: [1] ‘x’
[13:23:27.221] 
[13:23:27.221] getGlobalsAndPackages() ... DONE
[13:23:27.222] run() for ‘Future’ ...
[13:23:27.222] - state: ‘created’
[13:23:27.222] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:27.226] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:27.226] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:27.227]   - Field: ‘label’
[13:23:27.227]   - Field: ‘local’
[13:23:27.227]   - Field: ‘owner’
[13:23:27.227]   - Field: ‘envir’
[13:23:27.227]   - Field: ‘workers’
[13:23:27.227]   - Field: ‘packages’
[13:23:27.227]   - Field: ‘gc’
[13:23:27.227]   - Field: ‘job’
[13:23:27.228]   - Field: ‘conditions’
[13:23:27.228]   - Field: ‘expr’
[13:23:27.228]   - Field: ‘uuid’
[13:23:27.228]   - Field: ‘seed’
[13:23:27.228]   - Field: ‘version’
[13:23:27.228]   - Field: ‘result’
[13:23:27.228]   - Field: ‘asynchronous’
[13:23:27.228]   - Field: ‘calls’
[13:23:27.229]   - Field: ‘globals’
[13:23:27.229]   - Field: ‘stdout’
[13:23:27.229]   - Field: ‘earlySignal’
[13:23:27.229]   - Field: ‘lazy’
[13:23:27.229]   - Field: ‘state’
[13:23:27.229] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:27.229] - Launch lazy future ...
[13:23:27.230] Packages needed by the future expression (n = 0): <none>
[13:23:27.230] Packages needed by future strategies (n = 0): <none>
[13:23:27.230] {
[13:23:27.230]     {
[13:23:27.230]         {
[13:23:27.230]             ...future.startTime <- base::Sys.time()
[13:23:27.230]             {
[13:23:27.230]                 {
[13:23:27.230]                   {
[13:23:27.230]                     {
[13:23:27.230]                       base::local({
[13:23:27.230]                         has_future <- base::requireNamespace("future", 
[13:23:27.230]                           quietly = TRUE)
[13:23:27.230]                         if (has_future) {
[13:23:27.230]                           ns <- base::getNamespace("future")
[13:23:27.230]                           version <- ns[[".package"]][["version"]]
[13:23:27.230]                           if (is.null(version)) 
[13:23:27.230]                             version <- utils::packageVersion("future")
[13:23:27.230]                         }
[13:23:27.230]                         else {
[13:23:27.230]                           version <- NULL
[13:23:27.230]                         }
[13:23:27.230]                         if (!has_future || version < "1.8.0") {
[13:23:27.230]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:27.230]                             "", base::R.version$version.string), 
[13:23:27.230]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:27.230]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:27.230]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:27.230]                               "release", "version")], collapse = " "), 
[13:23:27.230]                             hostname = base::Sys.info()[["nodename"]])
[13:23:27.230]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:27.230]                             info)
[13:23:27.230]                           info <- base::paste(info, collapse = "; ")
[13:23:27.230]                           if (!has_future) {
[13:23:27.230]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:27.230]                               info)
[13:23:27.230]                           }
[13:23:27.230]                           else {
[13:23:27.230]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:27.230]                               info, version)
[13:23:27.230]                           }
[13:23:27.230]                           base::stop(msg)
[13:23:27.230]                         }
[13:23:27.230]                       })
[13:23:27.230]                     }
[13:23:27.230]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:27.230]                     base::options(mc.cores = 1L)
[13:23:27.230]                   }
[13:23:27.230]                   options(future.plan = NULL)
[13:23:27.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:27.230]                 }
[13:23:27.230]                 ...future.workdir <- getwd()
[13:23:27.230]             }
[13:23:27.230]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:27.230]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:27.230]         }
[13:23:27.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:27.230]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:27.230]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:27.230]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:27.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:27.230]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:27.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:27.230]             base::names(...future.oldOptions))
[13:23:27.230]     }
[13:23:27.230]     if (FALSE) {
[13:23:27.230]     }
[13:23:27.230]     else {
[13:23:27.230]         if (TRUE) {
[13:23:27.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:27.230]                 open = "w")
[13:23:27.230]         }
[13:23:27.230]         else {
[13:23:27.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:27.230]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:27.230]         }
[13:23:27.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:27.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:27.230]             base::sink(type = "output", split = FALSE)
[13:23:27.230]             base::close(...future.stdout)
[13:23:27.230]         }, add = TRUE)
[13:23:27.230]     }
[13:23:27.230]     ...future.frame <- base::sys.nframe()
[13:23:27.230]     ...future.conditions <- base::list()
[13:23:27.230]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:27.230]     if (FALSE) {
[13:23:27.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:27.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:27.230]     }
[13:23:27.230]     ...future.result <- base::tryCatch({
[13:23:27.230]         base::withCallingHandlers({
[13:23:27.230]             ...future.value <- base::withVisible(base::local({
[13:23:27.230]                 withCallingHandlers({
[13:23:27.230]                   {
[13:23:27.230]                     x["a"] <- list(1)
[13:23:27.230]                     x
[13:23:27.230]                   }
[13:23:27.230]                 }, immediateCondition = function(cond) {
[13:23:27.230]                   save_rds <- function (object, pathname, ...) 
[13:23:27.230]                   {
[13:23:27.230]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:27.230]                     if (file_test("-f", pathname_tmp)) {
[13:23:27.230]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.230]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:27.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.230]                         fi_tmp[["mtime"]])
[13:23:27.230]                     }
[13:23:27.230]                     tryCatch({
[13:23:27.230]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:27.230]                     }, error = function(ex) {
[13:23:27.230]                       msg <- conditionMessage(ex)
[13:23:27.230]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.230]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:27.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.230]                         fi_tmp[["mtime"]], msg)
[13:23:27.230]                       ex$message <- msg
[13:23:27.230]                       stop(ex)
[13:23:27.230]                     })
[13:23:27.230]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:27.230]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:27.230]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:27.230]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.230]                       fi <- file.info(pathname)
[13:23:27.230]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:27.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.230]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:27.230]                         fi[["size"]], fi[["mtime"]])
[13:23:27.230]                       stop(msg)
[13:23:27.230]                     }
[13:23:27.230]                     invisible(pathname)
[13:23:27.230]                   }
[13:23:27.230]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:27.230]                     rootPath = tempdir()) 
[13:23:27.230]                   {
[13:23:27.230]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:27.230]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:27.230]                       tmpdir = path, fileext = ".rds")
[13:23:27.230]                     save_rds(obj, file)
[13:23:27.230]                   }
[13:23:27.230]                   saveImmediateCondition(cond, path = "/tmp/Rtmpxi2rDI/.future/immediateConditions")
[13:23:27.230]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.230]                   {
[13:23:27.230]                     inherits <- base::inherits
[13:23:27.230]                     invokeRestart <- base::invokeRestart
[13:23:27.230]                     is.null <- base::is.null
[13:23:27.230]                     muffled <- FALSE
[13:23:27.230]                     if (inherits(cond, "message")) {
[13:23:27.230]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:27.230]                       if (muffled) 
[13:23:27.230]                         invokeRestart("muffleMessage")
[13:23:27.230]                     }
[13:23:27.230]                     else if (inherits(cond, "warning")) {
[13:23:27.230]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:27.230]                       if (muffled) 
[13:23:27.230]                         invokeRestart("muffleWarning")
[13:23:27.230]                     }
[13:23:27.230]                     else if (inherits(cond, "condition")) {
[13:23:27.230]                       if (!is.null(pattern)) {
[13:23:27.230]                         computeRestarts <- base::computeRestarts
[13:23:27.230]                         grepl <- base::grepl
[13:23:27.230]                         restarts <- computeRestarts(cond)
[13:23:27.230]                         for (restart in restarts) {
[13:23:27.230]                           name <- restart$name
[13:23:27.230]                           if (is.null(name)) 
[13:23:27.230]                             next
[13:23:27.230]                           if (!grepl(pattern, name)) 
[13:23:27.230]                             next
[13:23:27.230]                           invokeRestart(restart)
[13:23:27.230]                           muffled <- TRUE
[13:23:27.230]                           break
[13:23:27.230]                         }
[13:23:27.230]                       }
[13:23:27.230]                     }
[13:23:27.230]                     invisible(muffled)
[13:23:27.230]                   }
[13:23:27.230]                   muffleCondition(cond)
[13:23:27.230]                 })
[13:23:27.230]             }))
[13:23:27.230]             future::FutureResult(value = ...future.value$value, 
[13:23:27.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.230]                   ...future.rng), globalenv = if (FALSE) 
[13:23:27.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:27.230]                     ...future.globalenv.names))
[13:23:27.230]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:27.230]         }, condition = base::local({
[13:23:27.230]             c <- base::c
[13:23:27.230]             inherits <- base::inherits
[13:23:27.230]             invokeRestart <- base::invokeRestart
[13:23:27.230]             length <- base::length
[13:23:27.230]             list <- base::list
[13:23:27.230]             seq.int <- base::seq.int
[13:23:27.230]             signalCondition <- base::signalCondition
[13:23:27.230]             sys.calls <- base::sys.calls
[13:23:27.230]             `[[` <- base::`[[`
[13:23:27.230]             `+` <- base::`+`
[13:23:27.230]             `<<-` <- base::`<<-`
[13:23:27.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:27.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:27.230]                   3L)]
[13:23:27.230]             }
[13:23:27.230]             function(cond) {
[13:23:27.230]                 is_error <- inherits(cond, "error")
[13:23:27.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:27.230]                   NULL)
[13:23:27.230]                 if (is_error) {
[13:23:27.230]                   sessionInformation <- function() {
[13:23:27.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:27.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:27.230]                       search = base::search(), system = base::Sys.info())
[13:23:27.230]                   }
[13:23:27.230]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:27.230]                     cond$call), session = sessionInformation(), 
[13:23:27.230]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:27.230]                   signalCondition(cond)
[13:23:27.230]                 }
[13:23:27.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:27.230]                 "immediateCondition"))) {
[13:23:27.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:27.230]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:27.230]                   if (TRUE && !signal) {
[13:23:27.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.230]                     {
[13:23:27.230]                       inherits <- base::inherits
[13:23:27.230]                       invokeRestart <- base::invokeRestart
[13:23:27.230]                       is.null <- base::is.null
[13:23:27.230]                       muffled <- FALSE
[13:23:27.230]                       if (inherits(cond, "message")) {
[13:23:27.230]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.230]                         if (muffled) 
[13:23:27.230]                           invokeRestart("muffleMessage")
[13:23:27.230]                       }
[13:23:27.230]                       else if (inherits(cond, "warning")) {
[13:23:27.230]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.230]                         if (muffled) 
[13:23:27.230]                           invokeRestart("muffleWarning")
[13:23:27.230]                       }
[13:23:27.230]                       else if (inherits(cond, "condition")) {
[13:23:27.230]                         if (!is.null(pattern)) {
[13:23:27.230]                           computeRestarts <- base::computeRestarts
[13:23:27.230]                           grepl <- base::grepl
[13:23:27.230]                           restarts <- computeRestarts(cond)
[13:23:27.230]                           for (restart in restarts) {
[13:23:27.230]                             name <- restart$name
[13:23:27.230]                             if (is.null(name)) 
[13:23:27.230]                               next
[13:23:27.230]                             if (!grepl(pattern, name)) 
[13:23:27.230]                               next
[13:23:27.230]                             invokeRestart(restart)
[13:23:27.230]                             muffled <- TRUE
[13:23:27.230]                             break
[13:23:27.230]                           }
[13:23:27.230]                         }
[13:23:27.230]                       }
[13:23:27.230]                       invisible(muffled)
[13:23:27.230]                     }
[13:23:27.230]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.230]                   }
[13:23:27.230]                 }
[13:23:27.230]                 else {
[13:23:27.230]                   if (TRUE) {
[13:23:27.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.230]                     {
[13:23:27.230]                       inherits <- base::inherits
[13:23:27.230]                       invokeRestart <- base::invokeRestart
[13:23:27.230]                       is.null <- base::is.null
[13:23:27.230]                       muffled <- FALSE
[13:23:27.230]                       if (inherits(cond, "message")) {
[13:23:27.230]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.230]                         if (muffled) 
[13:23:27.230]                           invokeRestart("muffleMessage")
[13:23:27.230]                       }
[13:23:27.230]                       else if (inherits(cond, "warning")) {
[13:23:27.230]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.230]                         if (muffled) 
[13:23:27.230]                           invokeRestart("muffleWarning")
[13:23:27.230]                       }
[13:23:27.230]                       else if (inherits(cond, "condition")) {
[13:23:27.230]                         if (!is.null(pattern)) {
[13:23:27.230]                           computeRestarts <- base::computeRestarts
[13:23:27.230]                           grepl <- base::grepl
[13:23:27.230]                           restarts <- computeRestarts(cond)
[13:23:27.230]                           for (restart in restarts) {
[13:23:27.230]                             name <- restart$name
[13:23:27.230]                             if (is.null(name)) 
[13:23:27.230]                               next
[13:23:27.230]                             if (!grepl(pattern, name)) 
[13:23:27.230]                               next
[13:23:27.230]                             invokeRestart(restart)
[13:23:27.230]                             muffled <- TRUE
[13:23:27.230]                             break
[13:23:27.230]                           }
[13:23:27.230]                         }
[13:23:27.230]                       }
[13:23:27.230]                       invisible(muffled)
[13:23:27.230]                     }
[13:23:27.230]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.230]                   }
[13:23:27.230]                 }
[13:23:27.230]             }
[13:23:27.230]         }))
[13:23:27.230]     }, error = function(ex) {
[13:23:27.230]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:27.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.230]                 ...future.rng), started = ...future.startTime, 
[13:23:27.230]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:27.230]             version = "1.8"), class = "FutureResult")
[13:23:27.230]     }, finally = {
[13:23:27.230]         if (!identical(...future.workdir, getwd())) 
[13:23:27.230]             setwd(...future.workdir)
[13:23:27.230]         {
[13:23:27.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:27.230]                 ...future.oldOptions$nwarnings <- NULL
[13:23:27.230]             }
[13:23:27.230]             base::options(...future.oldOptions)
[13:23:27.230]             if (.Platform$OS.type == "windows") {
[13:23:27.230]                 old_names <- names(...future.oldEnvVars)
[13:23:27.230]                 envs <- base::Sys.getenv()
[13:23:27.230]                 names <- names(envs)
[13:23:27.230]                 common <- intersect(names, old_names)
[13:23:27.230]                 added <- setdiff(names, old_names)
[13:23:27.230]                 removed <- setdiff(old_names, names)
[13:23:27.230]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:27.230]                   envs[common]]
[13:23:27.230]                 NAMES <- toupper(changed)
[13:23:27.230]                 args <- list()
[13:23:27.230]                 for (kk in seq_along(NAMES)) {
[13:23:27.230]                   name <- changed[[kk]]
[13:23:27.230]                   NAME <- NAMES[[kk]]
[13:23:27.230]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.230]                     next
[13:23:27.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.230]                 }
[13:23:27.230]                 NAMES <- toupper(added)
[13:23:27.230]                 for (kk in seq_along(NAMES)) {
[13:23:27.230]                   name <- added[[kk]]
[13:23:27.230]                   NAME <- NAMES[[kk]]
[13:23:27.230]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.230]                     next
[13:23:27.230]                   args[[name]] <- ""
[13:23:27.230]                 }
[13:23:27.230]                 NAMES <- toupper(removed)
[13:23:27.230]                 for (kk in seq_along(NAMES)) {
[13:23:27.230]                   name <- removed[[kk]]
[13:23:27.230]                   NAME <- NAMES[[kk]]
[13:23:27.230]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.230]                     next
[13:23:27.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.230]                 }
[13:23:27.230]                 if (length(args) > 0) 
[13:23:27.230]                   base::do.call(base::Sys.setenv, args = args)
[13:23:27.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:27.230]             }
[13:23:27.230]             else {
[13:23:27.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:27.230]             }
[13:23:27.230]             {
[13:23:27.230]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:27.230]                   0L) {
[13:23:27.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:27.230]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:27.230]                   base::options(opts)
[13:23:27.230]                 }
[13:23:27.230]                 {
[13:23:27.230]                   {
[13:23:27.230]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:27.230]                     NULL
[13:23:27.230]                   }
[13:23:27.230]                   options(future.plan = NULL)
[13:23:27.230]                   if (is.na(NA_character_)) 
[13:23:27.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:27.230]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:27.230]                     envir = parent.frame()) 
[13:23:27.230]                   {
[13:23:27.230]                     default_workers <- missing(workers)
[13:23:27.230]                     if (is.function(workers)) 
[13:23:27.230]                       workers <- workers()
[13:23:27.230]                     workers <- structure(as.integer(workers), 
[13:23:27.230]                       class = class(workers))
[13:23:27.230]                     stop_if_not(is.finite(workers), workers >= 
[13:23:27.230]                       1L)
[13:23:27.230]                     if ((workers == 1L && !inherits(workers, 
[13:23:27.230]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:27.230]                       if (default_workers) 
[13:23:27.230]                         supportsMulticore(warn = TRUE)
[13:23:27.230]                       return(sequential(..., envir = envir))
[13:23:27.230]                     }
[13:23:27.230]                     oopts <- options(mc.cores = workers)
[13:23:27.230]                     on.exit(options(oopts))
[13:23:27.230]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:27.230]                       envir = envir)
[13:23:27.230]                     if (!future$lazy) 
[13:23:27.230]                       future <- run(future)
[13:23:27.230]                     invisible(future)
[13:23:27.230]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:27.230]                 }
[13:23:27.230]             }
[13:23:27.230]         }
[13:23:27.230]     })
[13:23:27.230]     if (TRUE) {
[13:23:27.230]         base::sink(type = "output", split = FALSE)
[13:23:27.230]         if (TRUE) {
[13:23:27.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:27.230]         }
[13:23:27.230]         else {
[13:23:27.230]             ...future.result["stdout"] <- base::list(NULL)
[13:23:27.230]         }
[13:23:27.230]         base::close(...future.stdout)
[13:23:27.230]         ...future.stdout <- NULL
[13:23:27.230]     }
[13:23:27.230]     ...future.result$conditions <- ...future.conditions
[13:23:27.230]     ...future.result$finished <- base::Sys.time()
[13:23:27.230]     ...future.result
[13:23:27.230] }
[13:23:27.233] assign_globals() ...
[13:23:27.233] List of 1
[13:23:27.233]  $ x: list()
[13:23:27.233]  - attr(*, "where")=List of 1
[13:23:27.233]   ..$ x:<environment: R_EmptyEnv> 
[13:23:27.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:27.233]  - attr(*, "resolved")= logi TRUE
[13:23:27.233]  - attr(*, "total_size")= num 0
[13:23:27.233]  - attr(*, "already-done")= logi TRUE
[13:23:27.236] - copied ‘x’ to environment
[13:23:27.237] assign_globals() ... done
[13:23:27.237] requestCore(): workers = 2
[13:23:27.239] MulticoreFuture started
[13:23:27.239] - Launch lazy future ... done
[13:23:27.239] run() for ‘MulticoreFuture’ ... done
[13:23:27.240] result() for MulticoreFuture ...
[13:23:27.240] plan(): Setting new future strategy stack:
[13:23:27.240] List of future strategies:
[13:23:27.240] 1. sequential:
[13:23:27.240]    - args: function (..., envir = parent.frame())
[13:23:27.240]    - tweaked: FALSE
[13:23:27.240]    - call: NULL
[13:23:27.241] plan(): nbrOfWorkers() = 1
[13:23:27.243] plan(): Setting new future strategy stack:
[13:23:27.243] List of future strategies:
[13:23:27.243] 1. multicore:
[13:23:27.243]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:27.243]    - tweaked: FALSE
[13:23:27.243]    - call: plan(strategy)
[13:23:27.249] plan(): nbrOfWorkers() = 2
[13:23:27.249] result() for MulticoreFuture ...
[13:23:27.250] result() for MulticoreFuture ... done
[13:23:27.250] result() for MulticoreFuture ... done
[13:23:27.250] result() for MulticoreFuture ...
[13:23:27.250] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:27.250] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:27.251] Searching for globals...
[13:23:27.254] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:27.254] Searching for globals ... DONE
[13:23:27.254] Resolving globals: TRUE
[13:23:27.254] Resolving any globals that are futures ...
[13:23:27.254] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:27.254] Resolving any globals that are futures ... DONE
[13:23:27.255] Resolving futures part of globals (recursively) ...
[13:23:27.255] resolve() on list ...
[13:23:27.256]  recursive: 99
[13:23:27.256]  length: 1
[13:23:27.256]  elements: ‘x’
[13:23:27.256]  length: 0 (resolved future 1)
[13:23:27.256] resolve() on list ... DONE
[13:23:27.256] - globals: [1] ‘x’
[13:23:27.256] Resolving futures part of globals (recursively) ... DONE
[13:23:27.257] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:27.257] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:27.260] - globals: [1] ‘x’
[13:23:27.260] 
[13:23:27.260] getGlobalsAndPackages() ... DONE
[13:23:27.260] run() for ‘Future’ ...
[13:23:27.260] - state: ‘created’
[13:23:27.261] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:27.265] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:27.265] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:27.265]   - Field: ‘label’
[13:23:27.266]   - Field: ‘local’
[13:23:27.266]   - Field: ‘owner’
[13:23:27.266]   - Field: ‘envir’
[13:23:27.266]   - Field: ‘workers’
[13:23:27.266]   - Field: ‘packages’
[13:23:27.266]   - Field: ‘gc’
[13:23:27.266]   - Field: ‘job’
[13:23:27.266]   - Field: ‘conditions’
[13:23:27.267]   - Field: ‘expr’
[13:23:27.267]   - Field: ‘uuid’
[13:23:27.267]   - Field: ‘seed’
[13:23:27.267]   - Field: ‘version’
[13:23:27.267]   - Field: ‘result’
[13:23:27.267]   - Field: ‘asynchronous’
[13:23:27.267]   - Field: ‘calls’
[13:23:27.267]   - Field: ‘globals’
[13:23:27.268]   - Field: ‘stdout’
[13:23:27.268]   - Field: ‘earlySignal’
[13:23:27.268]   - Field: ‘lazy’
[13:23:27.268]   - Field: ‘state’
[13:23:27.268] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:27.268] - Launch lazy future ...
[13:23:27.269] Packages needed by the future expression (n = 0): <none>
[13:23:27.269] Packages needed by future strategies (n = 0): <none>
[13:23:27.269] {
[13:23:27.269]     {
[13:23:27.269]         {
[13:23:27.269]             ...future.startTime <- base::Sys.time()
[13:23:27.269]             {
[13:23:27.269]                 {
[13:23:27.269]                   {
[13:23:27.269]                     {
[13:23:27.269]                       base::local({
[13:23:27.269]                         has_future <- base::requireNamespace("future", 
[13:23:27.269]                           quietly = TRUE)
[13:23:27.269]                         if (has_future) {
[13:23:27.269]                           ns <- base::getNamespace("future")
[13:23:27.269]                           version <- ns[[".package"]][["version"]]
[13:23:27.269]                           if (is.null(version)) 
[13:23:27.269]                             version <- utils::packageVersion("future")
[13:23:27.269]                         }
[13:23:27.269]                         else {
[13:23:27.269]                           version <- NULL
[13:23:27.269]                         }
[13:23:27.269]                         if (!has_future || version < "1.8.0") {
[13:23:27.269]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:27.269]                             "", base::R.version$version.string), 
[13:23:27.269]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:27.269]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:27.269]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:27.269]                               "release", "version")], collapse = " "), 
[13:23:27.269]                             hostname = base::Sys.info()[["nodename"]])
[13:23:27.269]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:27.269]                             info)
[13:23:27.269]                           info <- base::paste(info, collapse = "; ")
[13:23:27.269]                           if (!has_future) {
[13:23:27.269]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:27.269]                               info)
[13:23:27.269]                           }
[13:23:27.269]                           else {
[13:23:27.269]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:27.269]                               info, version)
[13:23:27.269]                           }
[13:23:27.269]                           base::stop(msg)
[13:23:27.269]                         }
[13:23:27.269]                       })
[13:23:27.269]                     }
[13:23:27.269]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:27.269]                     base::options(mc.cores = 1L)
[13:23:27.269]                   }
[13:23:27.269]                   options(future.plan = NULL)
[13:23:27.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:27.269]                 }
[13:23:27.269]                 ...future.workdir <- getwd()
[13:23:27.269]             }
[13:23:27.269]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:27.269]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:27.269]         }
[13:23:27.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:27.269]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:27.269]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:27.269]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:27.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:27.269]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:27.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:27.269]             base::names(...future.oldOptions))
[13:23:27.269]     }
[13:23:27.269]     if (FALSE) {
[13:23:27.269]     }
[13:23:27.269]     else {
[13:23:27.269]         if (TRUE) {
[13:23:27.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:27.269]                 open = "w")
[13:23:27.269]         }
[13:23:27.269]         else {
[13:23:27.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:27.269]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:27.269]         }
[13:23:27.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:27.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:27.269]             base::sink(type = "output", split = FALSE)
[13:23:27.269]             base::close(...future.stdout)
[13:23:27.269]         }, add = TRUE)
[13:23:27.269]     }
[13:23:27.269]     ...future.frame <- base::sys.nframe()
[13:23:27.269]     ...future.conditions <- base::list()
[13:23:27.269]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:27.269]     if (FALSE) {
[13:23:27.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:27.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:27.269]     }
[13:23:27.269]     ...future.result <- base::tryCatch({
[13:23:27.269]         base::withCallingHandlers({
[13:23:27.269]             ...future.value <- base::withVisible(base::local({
[13:23:27.269]                 withCallingHandlers({
[13:23:27.269]                   {
[13:23:27.269]                     x["a"] <- list(1)
[13:23:27.269]                     x
[13:23:27.269]                   }
[13:23:27.269]                 }, immediateCondition = function(cond) {
[13:23:27.269]                   save_rds <- function (object, pathname, ...) 
[13:23:27.269]                   {
[13:23:27.269]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:27.269]                     if (file_test("-f", pathname_tmp)) {
[13:23:27.269]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.269]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:27.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.269]                         fi_tmp[["mtime"]])
[13:23:27.269]                     }
[13:23:27.269]                     tryCatch({
[13:23:27.269]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:27.269]                     }, error = function(ex) {
[13:23:27.269]                       msg <- conditionMessage(ex)
[13:23:27.269]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.269]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:27.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.269]                         fi_tmp[["mtime"]], msg)
[13:23:27.269]                       ex$message <- msg
[13:23:27.269]                       stop(ex)
[13:23:27.269]                     })
[13:23:27.269]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:27.269]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:27.269]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:27.269]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.269]                       fi <- file.info(pathname)
[13:23:27.269]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:27.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.269]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:27.269]                         fi[["size"]], fi[["mtime"]])
[13:23:27.269]                       stop(msg)
[13:23:27.269]                     }
[13:23:27.269]                     invisible(pathname)
[13:23:27.269]                   }
[13:23:27.269]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:27.269]                     rootPath = tempdir()) 
[13:23:27.269]                   {
[13:23:27.269]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:27.269]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:27.269]                       tmpdir = path, fileext = ".rds")
[13:23:27.269]                     save_rds(obj, file)
[13:23:27.269]                   }
[13:23:27.269]                   saveImmediateCondition(cond, path = "/tmp/Rtmpxi2rDI/.future/immediateConditions")
[13:23:27.269]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.269]                   {
[13:23:27.269]                     inherits <- base::inherits
[13:23:27.269]                     invokeRestart <- base::invokeRestart
[13:23:27.269]                     is.null <- base::is.null
[13:23:27.269]                     muffled <- FALSE
[13:23:27.269]                     if (inherits(cond, "message")) {
[13:23:27.269]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:27.269]                       if (muffled) 
[13:23:27.269]                         invokeRestart("muffleMessage")
[13:23:27.269]                     }
[13:23:27.269]                     else if (inherits(cond, "warning")) {
[13:23:27.269]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:27.269]                       if (muffled) 
[13:23:27.269]                         invokeRestart("muffleWarning")
[13:23:27.269]                     }
[13:23:27.269]                     else if (inherits(cond, "condition")) {
[13:23:27.269]                       if (!is.null(pattern)) {
[13:23:27.269]                         computeRestarts <- base::computeRestarts
[13:23:27.269]                         grepl <- base::grepl
[13:23:27.269]                         restarts <- computeRestarts(cond)
[13:23:27.269]                         for (restart in restarts) {
[13:23:27.269]                           name <- restart$name
[13:23:27.269]                           if (is.null(name)) 
[13:23:27.269]                             next
[13:23:27.269]                           if (!grepl(pattern, name)) 
[13:23:27.269]                             next
[13:23:27.269]                           invokeRestart(restart)
[13:23:27.269]                           muffled <- TRUE
[13:23:27.269]                           break
[13:23:27.269]                         }
[13:23:27.269]                       }
[13:23:27.269]                     }
[13:23:27.269]                     invisible(muffled)
[13:23:27.269]                   }
[13:23:27.269]                   muffleCondition(cond)
[13:23:27.269]                 })
[13:23:27.269]             }))
[13:23:27.269]             future::FutureResult(value = ...future.value$value, 
[13:23:27.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.269]                   ...future.rng), globalenv = if (FALSE) 
[13:23:27.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:27.269]                     ...future.globalenv.names))
[13:23:27.269]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:27.269]         }, condition = base::local({
[13:23:27.269]             c <- base::c
[13:23:27.269]             inherits <- base::inherits
[13:23:27.269]             invokeRestart <- base::invokeRestart
[13:23:27.269]             length <- base::length
[13:23:27.269]             list <- base::list
[13:23:27.269]             seq.int <- base::seq.int
[13:23:27.269]             signalCondition <- base::signalCondition
[13:23:27.269]             sys.calls <- base::sys.calls
[13:23:27.269]             `[[` <- base::`[[`
[13:23:27.269]             `+` <- base::`+`
[13:23:27.269]             `<<-` <- base::`<<-`
[13:23:27.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:27.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:27.269]                   3L)]
[13:23:27.269]             }
[13:23:27.269]             function(cond) {
[13:23:27.269]                 is_error <- inherits(cond, "error")
[13:23:27.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:27.269]                   NULL)
[13:23:27.269]                 if (is_error) {
[13:23:27.269]                   sessionInformation <- function() {
[13:23:27.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:27.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:27.269]                       search = base::search(), system = base::Sys.info())
[13:23:27.269]                   }
[13:23:27.269]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:27.269]                     cond$call), session = sessionInformation(), 
[13:23:27.269]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:27.269]                   signalCondition(cond)
[13:23:27.269]                 }
[13:23:27.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:27.269]                 "immediateCondition"))) {
[13:23:27.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:27.269]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:27.269]                   if (TRUE && !signal) {
[13:23:27.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.269]                     {
[13:23:27.269]                       inherits <- base::inherits
[13:23:27.269]                       invokeRestart <- base::invokeRestart
[13:23:27.269]                       is.null <- base::is.null
[13:23:27.269]                       muffled <- FALSE
[13:23:27.269]                       if (inherits(cond, "message")) {
[13:23:27.269]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.269]                         if (muffled) 
[13:23:27.269]                           invokeRestart("muffleMessage")
[13:23:27.269]                       }
[13:23:27.269]                       else if (inherits(cond, "warning")) {
[13:23:27.269]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.269]                         if (muffled) 
[13:23:27.269]                           invokeRestart("muffleWarning")
[13:23:27.269]                       }
[13:23:27.269]                       else if (inherits(cond, "condition")) {
[13:23:27.269]                         if (!is.null(pattern)) {
[13:23:27.269]                           computeRestarts <- base::computeRestarts
[13:23:27.269]                           grepl <- base::grepl
[13:23:27.269]                           restarts <- computeRestarts(cond)
[13:23:27.269]                           for (restart in restarts) {
[13:23:27.269]                             name <- restart$name
[13:23:27.269]                             if (is.null(name)) 
[13:23:27.269]                               next
[13:23:27.269]                             if (!grepl(pattern, name)) 
[13:23:27.269]                               next
[13:23:27.269]                             invokeRestart(restart)
[13:23:27.269]                             muffled <- TRUE
[13:23:27.269]                             break
[13:23:27.269]                           }
[13:23:27.269]                         }
[13:23:27.269]                       }
[13:23:27.269]                       invisible(muffled)
[13:23:27.269]                     }
[13:23:27.269]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.269]                   }
[13:23:27.269]                 }
[13:23:27.269]                 else {
[13:23:27.269]                   if (TRUE) {
[13:23:27.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.269]                     {
[13:23:27.269]                       inherits <- base::inherits
[13:23:27.269]                       invokeRestart <- base::invokeRestart
[13:23:27.269]                       is.null <- base::is.null
[13:23:27.269]                       muffled <- FALSE
[13:23:27.269]                       if (inherits(cond, "message")) {
[13:23:27.269]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.269]                         if (muffled) 
[13:23:27.269]                           invokeRestart("muffleMessage")
[13:23:27.269]                       }
[13:23:27.269]                       else if (inherits(cond, "warning")) {
[13:23:27.269]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.269]                         if (muffled) 
[13:23:27.269]                           invokeRestart("muffleWarning")
[13:23:27.269]                       }
[13:23:27.269]                       else if (inherits(cond, "condition")) {
[13:23:27.269]                         if (!is.null(pattern)) {
[13:23:27.269]                           computeRestarts <- base::computeRestarts
[13:23:27.269]                           grepl <- base::grepl
[13:23:27.269]                           restarts <- computeRestarts(cond)
[13:23:27.269]                           for (restart in restarts) {
[13:23:27.269]                             name <- restart$name
[13:23:27.269]                             if (is.null(name)) 
[13:23:27.269]                               next
[13:23:27.269]                             if (!grepl(pattern, name)) 
[13:23:27.269]                               next
[13:23:27.269]                             invokeRestart(restart)
[13:23:27.269]                             muffled <- TRUE
[13:23:27.269]                             break
[13:23:27.269]                           }
[13:23:27.269]                         }
[13:23:27.269]                       }
[13:23:27.269]                       invisible(muffled)
[13:23:27.269]                     }
[13:23:27.269]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.269]                   }
[13:23:27.269]                 }
[13:23:27.269]             }
[13:23:27.269]         }))
[13:23:27.269]     }, error = function(ex) {
[13:23:27.269]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:27.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.269]                 ...future.rng), started = ...future.startTime, 
[13:23:27.269]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:27.269]             version = "1.8"), class = "FutureResult")
[13:23:27.269]     }, finally = {
[13:23:27.269]         if (!identical(...future.workdir, getwd())) 
[13:23:27.269]             setwd(...future.workdir)
[13:23:27.269]         {
[13:23:27.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:27.269]                 ...future.oldOptions$nwarnings <- NULL
[13:23:27.269]             }
[13:23:27.269]             base::options(...future.oldOptions)
[13:23:27.269]             if (.Platform$OS.type == "windows") {
[13:23:27.269]                 old_names <- names(...future.oldEnvVars)
[13:23:27.269]                 envs <- base::Sys.getenv()
[13:23:27.269]                 names <- names(envs)
[13:23:27.269]                 common <- intersect(names, old_names)
[13:23:27.269]                 added <- setdiff(names, old_names)
[13:23:27.269]                 removed <- setdiff(old_names, names)
[13:23:27.269]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:27.269]                   envs[common]]
[13:23:27.269]                 NAMES <- toupper(changed)
[13:23:27.269]                 args <- list()
[13:23:27.269]                 for (kk in seq_along(NAMES)) {
[13:23:27.269]                   name <- changed[[kk]]
[13:23:27.269]                   NAME <- NAMES[[kk]]
[13:23:27.269]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.269]                     next
[13:23:27.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.269]                 }
[13:23:27.269]                 NAMES <- toupper(added)
[13:23:27.269]                 for (kk in seq_along(NAMES)) {
[13:23:27.269]                   name <- added[[kk]]
[13:23:27.269]                   NAME <- NAMES[[kk]]
[13:23:27.269]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.269]                     next
[13:23:27.269]                   args[[name]] <- ""
[13:23:27.269]                 }
[13:23:27.269]                 NAMES <- toupper(removed)
[13:23:27.269]                 for (kk in seq_along(NAMES)) {
[13:23:27.269]                   name <- removed[[kk]]
[13:23:27.269]                   NAME <- NAMES[[kk]]
[13:23:27.269]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.269]                     next
[13:23:27.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.269]                 }
[13:23:27.269]                 if (length(args) > 0) 
[13:23:27.269]                   base::do.call(base::Sys.setenv, args = args)
[13:23:27.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:27.269]             }
[13:23:27.269]             else {
[13:23:27.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:27.269]             }
[13:23:27.269]             {
[13:23:27.269]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:27.269]                   0L) {
[13:23:27.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:27.269]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:27.269]                   base::options(opts)
[13:23:27.269]                 }
[13:23:27.269]                 {
[13:23:27.269]                   {
[13:23:27.269]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:27.269]                     NULL
[13:23:27.269]                   }
[13:23:27.269]                   options(future.plan = NULL)
[13:23:27.269]                   if (is.na(NA_character_)) 
[13:23:27.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:27.269]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:27.269]                     envir = parent.frame()) 
[13:23:27.269]                   {
[13:23:27.269]                     default_workers <- missing(workers)
[13:23:27.269]                     if (is.function(workers)) 
[13:23:27.269]                       workers <- workers()
[13:23:27.269]                     workers <- structure(as.integer(workers), 
[13:23:27.269]                       class = class(workers))
[13:23:27.269]                     stop_if_not(is.finite(workers), workers >= 
[13:23:27.269]                       1L)
[13:23:27.269]                     if ((workers == 1L && !inherits(workers, 
[13:23:27.269]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:27.269]                       if (default_workers) 
[13:23:27.269]                         supportsMulticore(warn = TRUE)
[13:23:27.269]                       return(sequential(..., envir = envir))
[13:23:27.269]                     }
[13:23:27.269]                     oopts <- options(mc.cores = workers)
[13:23:27.269]                     on.exit(options(oopts))
[13:23:27.269]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:27.269]                       envir = envir)
[13:23:27.269]                     if (!future$lazy) 
[13:23:27.269]                       future <- run(future)
[13:23:27.269]                     invisible(future)
[13:23:27.269]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:27.269]                 }
[13:23:27.269]             }
[13:23:27.269]         }
[13:23:27.269]     })
[13:23:27.269]     if (TRUE) {
[13:23:27.269]         base::sink(type = "output", split = FALSE)
[13:23:27.269]         if (TRUE) {
[13:23:27.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:27.269]         }
[13:23:27.269]         else {
[13:23:27.269]             ...future.result["stdout"] <- base::list(NULL)
[13:23:27.269]         }
[13:23:27.269]         base::close(...future.stdout)
[13:23:27.269]         ...future.stdout <- NULL
[13:23:27.269]     }
[13:23:27.269]     ...future.result$conditions <- ...future.conditions
[13:23:27.269]     ...future.result$finished <- base::Sys.time()
[13:23:27.269]     ...future.result
[13:23:27.269] }
[13:23:27.272] assign_globals() ...
[13:23:27.272] List of 1
[13:23:27.272]  $ x: list()
[13:23:27.272]  - attr(*, "where")=List of 1
[13:23:27.272]   ..$ x:<environment: R_EmptyEnv> 
[13:23:27.272]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:27.272]  - attr(*, "resolved")= logi TRUE
[13:23:27.272]  - attr(*, "total_size")= num 0
[13:23:27.272]  - attr(*, "already-done")= logi TRUE
[13:23:27.275] - copied ‘x’ to environment
[13:23:27.275] assign_globals() ... done
[13:23:27.276] requestCore(): workers = 2
[13:23:27.278] MulticoreFuture started
[13:23:27.278] - Launch lazy future ... done
[13:23:27.278] run() for ‘MulticoreFuture’ ... done
[13:23:27.279] result() for MulticoreFuture ...
[13:23:27.279] plan(): Setting new future strategy stack:
[13:23:27.279] List of future strategies:
[13:23:27.279] 1. sequential:
[13:23:27.279]    - args: function (..., envir = parent.frame())
[13:23:27.279]    - tweaked: FALSE
[13:23:27.279]    - call: NULL
[13:23:27.280] plan(): nbrOfWorkers() = 1
[13:23:27.282] plan(): Setting new future strategy stack:
[13:23:27.282] List of future strategies:
[13:23:27.282] 1. multicore:
[13:23:27.282]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:27.282]    - tweaked: FALSE
[13:23:27.282]    - call: plan(strategy)
[13:23:27.288] plan(): nbrOfWorkers() = 2
[13:23:27.289] result() for MulticoreFuture ...
[13:23:27.289] result() for MulticoreFuture ... done
[13:23:27.290] result() for MulticoreFuture ... done
[13:23:27.290] result() for MulticoreFuture ...
[13:23:27.290] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:27.291] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:27.291] Searching for globals...
[13:23:27.294] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:27.294] Searching for globals ... DONE
[13:23:27.294] Resolving globals: TRUE
[13:23:27.294] Resolving any globals that are futures ...
[13:23:27.295] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:27.295] Resolving any globals that are futures ... DONE
[13:23:27.295] Resolving futures part of globals (recursively) ...
[13:23:27.296] resolve() on list ...
[13:23:27.296]  recursive: 99
[13:23:27.296]  length: 1
[13:23:27.296]  elements: ‘x’
[13:23:27.296]  length: 0 (resolved future 1)
[13:23:27.296] resolve() on list ... DONE
[13:23:27.296] - globals: [1] ‘x’
[13:23:27.297] Resolving futures part of globals (recursively) ... DONE
[13:23:27.297] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:27.297] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:27.297] - globals: [1] ‘x’
[13:23:27.297] 
[13:23:27.298] getGlobalsAndPackages() ... DONE
[13:23:27.298] run() for ‘Future’ ...
[13:23:27.298] - state: ‘created’
[13:23:27.298] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:27.303] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:27.303] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:27.303]   - Field: ‘label’
[13:23:27.304]   - Field: ‘local’
[13:23:27.304]   - Field: ‘owner’
[13:23:27.304]   - Field: ‘envir’
[13:23:27.304]   - Field: ‘workers’
[13:23:27.304]   - Field: ‘packages’
[13:23:27.304]   - Field: ‘gc’
[13:23:27.304]   - Field: ‘job’
[13:23:27.305]   - Field: ‘conditions’
[13:23:27.305]   - Field: ‘expr’
[13:23:27.305]   - Field: ‘uuid’
[13:23:27.305]   - Field: ‘seed’
[13:23:27.305]   - Field: ‘version’
[13:23:27.305]   - Field: ‘result’
[13:23:27.305]   - Field: ‘asynchronous’
[13:23:27.305]   - Field: ‘calls’
[13:23:27.305]   - Field: ‘globals’
[13:23:27.306]   - Field: ‘stdout’
[13:23:27.306]   - Field: ‘earlySignal’
[13:23:27.306]   - Field: ‘lazy’
[13:23:27.306]   - Field: ‘state’
[13:23:27.306] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:27.306] - Launch lazy future ...
[13:23:27.307] Packages needed by the future expression (n = 0): <none>
[13:23:27.307] Packages needed by future strategies (n = 0): <none>
[13:23:27.307] {
[13:23:27.307]     {
[13:23:27.307]         {
[13:23:27.307]             ...future.startTime <- base::Sys.time()
[13:23:27.307]             {
[13:23:27.307]                 {
[13:23:27.307]                   {
[13:23:27.307]                     {
[13:23:27.307]                       base::local({
[13:23:27.307]                         has_future <- base::requireNamespace("future", 
[13:23:27.307]                           quietly = TRUE)
[13:23:27.307]                         if (has_future) {
[13:23:27.307]                           ns <- base::getNamespace("future")
[13:23:27.307]                           version <- ns[[".package"]][["version"]]
[13:23:27.307]                           if (is.null(version)) 
[13:23:27.307]                             version <- utils::packageVersion("future")
[13:23:27.307]                         }
[13:23:27.307]                         else {
[13:23:27.307]                           version <- NULL
[13:23:27.307]                         }
[13:23:27.307]                         if (!has_future || version < "1.8.0") {
[13:23:27.307]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:27.307]                             "", base::R.version$version.string), 
[13:23:27.307]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:27.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:27.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:27.307]                               "release", "version")], collapse = " "), 
[13:23:27.307]                             hostname = base::Sys.info()[["nodename"]])
[13:23:27.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:27.307]                             info)
[13:23:27.307]                           info <- base::paste(info, collapse = "; ")
[13:23:27.307]                           if (!has_future) {
[13:23:27.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:27.307]                               info)
[13:23:27.307]                           }
[13:23:27.307]                           else {
[13:23:27.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:27.307]                               info, version)
[13:23:27.307]                           }
[13:23:27.307]                           base::stop(msg)
[13:23:27.307]                         }
[13:23:27.307]                       })
[13:23:27.307]                     }
[13:23:27.307]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:27.307]                     base::options(mc.cores = 1L)
[13:23:27.307]                   }
[13:23:27.307]                   options(future.plan = NULL)
[13:23:27.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:27.307]                 }
[13:23:27.307]                 ...future.workdir <- getwd()
[13:23:27.307]             }
[13:23:27.307]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:27.307]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:27.307]         }
[13:23:27.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:27.307]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:27.307]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:27.307]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:27.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:27.307]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:27.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:27.307]             base::names(...future.oldOptions))
[13:23:27.307]     }
[13:23:27.307]     if (FALSE) {
[13:23:27.307]     }
[13:23:27.307]     else {
[13:23:27.307]         if (TRUE) {
[13:23:27.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:27.307]                 open = "w")
[13:23:27.307]         }
[13:23:27.307]         else {
[13:23:27.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:27.307]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:27.307]         }
[13:23:27.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:27.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:27.307]             base::sink(type = "output", split = FALSE)
[13:23:27.307]             base::close(...future.stdout)
[13:23:27.307]         }, add = TRUE)
[13:23:27.307]     }
[13:23:27.307]     ...future.frame <- base::sys.nframe()
[13:23:27.307]     ...future.conditions <- base::list()
[13:23:27.307]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:27.307]     if (FALSE) {
[13:23:27.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:27.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:27.307]     }
[13:23:27.307]     ...future.result <- base::tryCatch({
[13:23:27.307]         base::withCallingHandlers({
[13:23:27.307]             ...future.value <- base::withVisible(base::local({
[13:23:27.307]                 withCallingHandlers({
[13:23:27.307]                   {
[13:23:27.307]                     x["a"] <- list(1)
[13:23:27.307]                     x
[13:23:27.307]                   }
[13:23:27.307]                 }, immediateCondition = function(cond) {
[13:23:27.307]                   save_rds <- function (object, pathname, ...) 
[13:23:27.307]                   {
[13:23:27.307]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:27.307]                     if (file_test("-f", pathname_tmp)) {
[13:23:27.307]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.307]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:27.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.307]                         fi_tmp[["mtime"]])
[13:23:27.307]                     }
[13:23:27.307]                     tryCatch({
[13:23:27.307]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:27.307]                     }, error = function(ex) {
[13:23:27.307]                       msg <- conditionMessage(ex)
[13:23:27.307]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.307]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:27.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.307]                         fi_tmp[["mtime"]], msg)
[13:23:27.307]                       ex$message <- msg
[13:23:27.307]                       stop(ex)
[13:23:27.307]                     })
[13:23:27.307]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:27.307]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:27.307]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:27.307]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.307]                       fi <- file.info(pathname)
[13:23:27.307]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:27.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.307]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:27.307]                         fi[["size"]], fi[["mtime"]])
[13:23:27.307]                       stop(msg)
[13:23:27.307]                     }
[13:23:27.307]                     invisible(pathname)
[13:23:27.307]                   }
[13:23:27.307]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:27.307]                     rootPath = tempdir()) 
[13:23:27.307]                   {
[13:23:27.307]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:27.307]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:27.307]                       tmpdir = path, fileext = ".rds")
[13:23:27.307]                     save_rds(obj, file)
[13:23:27.307]                   }
[13:23:27.307]                   saveImmediateCondition(cond, path = "/tmp/Rtmpxi2rDI/.future/immediateConditions")
[13:23:27.307]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.307]                   {
[13:23:27.307]                     inherits <- base::inherits
[13:23:27.307]                     invokeRestart <- base::invokeRestart
[13:23:27.307]                     is.null <- base::is.null
[13:23:27.307]                     muffled <- FALSE
[13:23:27.307]                     if (inherits(cond, "message")) {
[13:23:27.307]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:27.307]                       if (muffled) 
[13:23:27.307]                         invokeRestart("muffleMessage")
[13:23:27.307]                     }
[13:23:27.307]                     else if (inherits(cond, "warning")) {
[13:23:27.307]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:27.307]                       if (muffled) 
[13:23:27.307]                         invokeRestart("muffleWarning")
[13:23:27.307]                     }
[13:23:27.307]                     else if (inherits(cond, "condition")) {
[13:23:27.307]                       if (!is.null(pattern)) {
[13:23:27.307]                         computeRestarts <- base::computeRestarts
[13:23:27.307]                         grepl <- base::grepl
[13:23:27.307]                         restarts <- computeRestarts(cond)
[13:23:27.307]                         for (restart in restarts) {
[13:23:27.307]                           name <- restart$name
[13:23:27.307]                           if (is.null(name)) 
[13:23:27.307]                             next
[13:23:27.307]                           if (!grepl(pattern, name)) 
[13:23:27.307]                             next
[13:23:27.307]                           invokeRestart(restart)
[13:23:27.307]                           muffled <- TRUE
[13:23:27.307]                           break
[13:23:27.307]                         }
[13:23:27.307]                       }
[13:23:27.307]                     }
[13:23:27.307]                     invisible(muffled)
[13:23:27.307]                   }
[13:23:27.307]                   muffleCondition(cond)
[13:23:27.307]                 })
[13:23:27.307]             }))
[13:23:27.307]             future::FutureResult(value = ...future.value$value, 
[13:23:27.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.307]                   ...future.rng), globalenv = if (FALSE) 
[13:23:27.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:27.307]                     ...future.globalenv.names))
[13:23:27.307]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:27.307]         }, condition = base::local({
[13:23:27.307]             c <- base::c
[13:23:27.307]             inherits <- base::inherits
[13:23:27.307]             invokeRestart <- base::invokeRestart
[13:23:27.307]             length <- base::length
[13:23:27.307]             list <- base::list
[13:23:27.307]             seq.int <- base::seq.int
[13:23:27.307]             signalCondition <- base::signalCondition
[13:23:27.307]             sys.calls <- base::sys.calls
[13:23:27.307]             `[[` <- base::`[[`
[13:23:27.307]             `+` <- base::`+`
[13:23:27.307]             `<<-` <- base::`<<-`
[13:23:27.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:27.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:27.307]                   3L)]
[13:23:27.307]             }
[13:23:27.307]             function(cond) {
[13:23:27.307]                 is_error <- inherits(cond, "error")
[13:23:27.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:27.307]                   NULL)
[13:23:27.307]                 if (is_error) {
[13:23:27.307]                   sessionInformation <- function() {
[13:23:27.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:27.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:27.307]                       search = base::search(), system = base::Sys.info())
[13:23:27.307]                   }
[13:23:27.307]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:27.307]                     cond$call), session = sessionInformation(), 
[13:23:27.307]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:27.307]                   signalCondition(cond)
[13:23:27.307]                 }
[13:23:27.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:27.307]                 "immediateCondition"))) {
[13:23:27.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:27.307]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:27.307]                   if (TRUE && !signal) {
[13:23:27.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.307]                     {
[13:23:27.307]                       inherits <- base::inherits
[13:23:27.307]                       invokeRestart <- base::invokeRestart
[13:23:27.307]                       is.null <- base::is.null
[13:23:27.307]                       muffled <- FALSE
[13:23:27.307]                       if (inherits(cond, "message")) {
[13:23:27.307]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.307]                         if (muffled) 
[13:23:27.307]                           invokeRestart("muffleMessage")
[13:23:27.307]                       }
[13:23:27.307]                       else if (inherits(cond, "warning")) {
[13:23:27.307]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.307]                         if (muffled) 
[13:23:27.307]                           invokeRestart("muffleWarning")
[13:23:27.307]                       }
[13:23:27.307]                       else if (inherits(cond, "condition")) {
[13:23:27.307]                         if (!is.null(pattern)) {
[13:23:27.307]                           computeRestarts <- base::computeRestarts
[13:23:27.307]                           grepl <- base::grepl
[13:23:27.307]                           restarts <- computeRestarts(cond)
[13:23:27.307]                           for (restart in restarts) {
[13:23:27.307]                             name <- restart$name
[13:23:27.307]                             if (is.null(name)) 
[13:23:27.307]                               next
[13:23:27.307]                             if (!grepl(pattern, name)) 
[13:23:27.307]                               next
[13:23:27.307]                             invokeRestart(restart)
[13:23:27.307]                             muffled <- TRUE
[13:23:27.307]                             break
[13:23:27.307]                           }
[13:23:27.307]                         }
[13:23:27.307]                       }
[13:23:27.307]                       invisible(muffled)
[13:23:27.307]                     }
[13:23:27.307]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.307]                   }
[13:23:27.307]                 }
[13:23:27.307]                 else {
[13:23:27.307]                   if (TRUE) {
[13:23:27.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.307]                     {
[13:23:27.307]                       inherits <- base::inherits
[13:23:27.307]                       invokeRestart <- base::invokeRestart
[13:23:27.307]                       is.null <- base::is.null
[13:23:27.307]                       muffled <- FALSE
[13:23:27.307]                       if (inherits(cond, "message")) {
[13:23:27.307]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.307]                         if (muffled) 
[13:23:27.307]                           invokeRestart("muffleMessage")
[13:23:27.307]                       }
[13:23:27.307]                       else if (inherits(cond, "warning")) {
[13:23:27.307]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.307]                         if (muffled) 
[13:23:27.307]                           invokeRestart("muffleWarning")
[13:23:27.307]                       }
[13:23:27.307]                       else if (inherits(cond, "condition")) {
[13:23:27.307]                         if (!is.null(pattern)) {
[13:23:27.307]                           computeRestarts <- base::computeRestarts
[13:23:27.307]                           grepl <- base::grepl
[13:23:27.307]                           restarts <- computeRestarts(cond)
[13:23:27.307]                           for (restart in restarts) {
[13:23:27.307]                             name <- restart$name
[13:23:27.307]                             if (is.null(name)) 
[13:23:27.307]                               next
[13:23:27.307]                             if (!grepl(pattern, name)) 
[13:23:27.307]                               next
[13:23:27.307]                             invokeRestart(restart)
[13:23:27.307]                             muffled <- TRUE
[13:23:27.307]                             break
[13:23:27.307]                           }
[13:23:27.307]                         }
[13:23:27.307]                       }
[13:23:27.307]                       invisible(muffled)
[13:23:27.307]                     }
[13:23:27.307]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.307]                   }
[13:23:27.307]                 }
[13:23:27.307]             }
[13:23:27.307]         }))
[13:23:27.307]     }, error = function(ex) {
[13:23:27.307]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:27.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.307]                 ...future.rng), started = ...future.startTime, 
[13:23:27.307]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:27.307]             version = "1.8"), class = "FutureResult")
[13:23:27.307]     }, finally = {
[13:23:27.307]         if (!identical(...future.workdir, getwd())) 
[13:23:27.307]             setwd(...future.workdir)
[13:23:27.307]         {
[13:23:27.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:27.307]                 ...future.oldOptions$nwarnings <- NULL
[13:23:27.307]             }
[13:23:27.307]             base::options(...future.oldOptions)
[13:23:27.307]             if (.Platform$OS.type == "windows") {
[13:23:27.307]                 old_names <- names(...future.oldEnvVars)
[13:23:27.307]                 envs <- base::Sys.getenv()
[13:23:27.307]                 names <- names(envs)
[13:23:27.307]                 common <- intersect(names, old_names)
[13:23:27.307]                 added <- setdiff(names, old_names)
[13:23:27.307]                 removed <- setdiff(old_names, names)
[13:23:27.307]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:27.307]                   envs[common]]
[13:23:27.307]                 NAMES <- toupper(changed)
[13:23:27.307]                 args <- list()
[13:23:27.307]                 for (kk in seq_along(NAMES)) {
[13:23:27.307]                   name <- changed[[kk]]
[13:23:27.307]                   NAME <- NAMES[[kk]]
[13:23:27.307]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.307]                     next
[13:23:27.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.307]                 }
[13:23:27.307]                 NAMES <- toupper(added)
[13:23:27.307]                 for (kk in seq_along(NAMES)) {
[13:23:27.307]                   name <- added[[kk]]
[13:23:27.307]                   NAME <- NAMES[[kk]]
[13:23:27.307]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.307]                     next
[13:23:27.307]                   args[[name]] <- ""
[13:23:27.307]                 }
[13:23:27.307]                 NAMES <- toupper(removed)
[13:23:27.307]                 for (kk in seq_along(NAMES)) {
[13:23:27.307]                   name <- removed[[kk]]
[13:23:27.307]                   NAME <- NAMES[[kk]]
[13:23:27.307]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.307]                     next
[13:23:27.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.307]                 }
[13:23:27.307]                 if (length(args) > 0) 
[13:23:27.307]                   base::do.call(base::Sys.setenv, args = args)
[13:23:27.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:27.307]             }
[13:23:27.307]             else {
[13:23:27.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:27.307]             }
[13:23:27.307]             {
[13:23:27.307]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:27.307]                   0L) {
[13:23:27.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:27.307]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:27.307]                   base::options(opts)
[13:23:27.307]                 }
[13:23:27.307]                 {
[13:23:27.307]                   {
[13:23:27.307]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:27.307]                     NULL
[13:23:27.307]                   }
[13:23:27.307]                   options(future.plan = NULL)
[13:23:27.307]                   if (is.na(NA_character_)) 
[13:23:27.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:27.307]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:27.307]                     envir = parent.frame()) 
[13:23:27.307]                   {
[13:23:27.307]                     default_workers <- missing(workers)
[13:23:27.307]                     if (is.function(workers)) 
[13:23:27.307]                       workers <- workers()
[13:23:27.307]                     workers <- structure(as.integer(workers), 
[13:23:27.307]                       class = class(workers))
[13:23:27.307]                     stop_if_not(is.finite(workers), workers >= 
[13:23:27.307]                       1L)
[13:23:27.307]                     if ((workers == 1L && !inherits(workers, 
[13:23:27.307]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:27.307]                       if (default_workers) 
[13:23:27.307]                         supportsMulticore(warn = TRUE)
[13:23:27.307]                       return(sequential(..., envir = envir))
[13:23:27.307]                     }
[13:23:27.307]                     oopts <- options(mc.cores = workers)
[13:23:27.307]                     on.exit(options(oopts))
[13:23:27.307]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:27.307]                       envir = envir)
[13:23:27.307]                     if (!future$lazy) 
[13:23:27.307]                       future <- run(future)
[13:23:27.307]                     invisible(future)
[13:23:27.307]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:27.307]                 }
[13:23:27.307]             }
[13:23:27.307]         }
[13:23:27.307]     })
[13:23:27.307]     if (TRUE) {
[13:23:27.307]         base::sink(type = "output", split = FALSE)
[13:23:27.307]         if (TRUE) {
[13:23:27.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:27.307]         }
[13:23:27.307]         else {
[13:23:27.307]             ...future.result["stdout"] <- base::list(NULL)
[13:23:27.307]         }
[13:23:27.307]         base::close(...future.stdout)
[13:23:27.307]         ...future.stdout <- NULL
[13:23:27.307]     }
[13:23:27.307]     ...future.result$conditions <- ...future.conditions
[13:23:27.307]     ...future.result$finished <- base::Sys.time()
[13:23:27.307]     ...future.result
[13:23:27.307] }
[13:23:27.310] assign_globals() ...
[13:23:27.310] List of 1
[13:23:27.310]  $ x: list()
[13:23:27.310]  - attr(*, "where")=List of 1
[13:23:27.310]   ..$ x:<environment: R_EmptyEnv> 
[13:23:27.310]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:27.310]  - attr(*, "resolved")= logi TRUE
[13:23:27.310]  - attr(*, "total_size")= num 0
[13:23:27.310]  - attr(*, "already-done")= logi TRUE
[13:23:27.316] - copied ‘x’ to environment
[13:23:27.316] assign_globals() ... done
[13:23:27.317] requestCore(): workers = 2
[13:23:27.319] MulticoreFuture started
[13:23:27.319] - Launch lazy future ... done
[13:23:27.320] run() for ‘MulticoreFuture’ ... done
[13:23:27.320] result() for MulticoreFuture ...
[13:23:27.320] plan(): Setting new future strategy stack:
[13:23:27.320] List of future strategies:
[13:23:27.320] 1. sequential:
[13:23:27.320]    - args: function (..., envir = parent.frame())
[13:23:27.320]    - tweaked: FALSE
[13:23:27.320]    - call: NULL
[13:23:27.321] plan(): nbrOfWorkers() = 1
[13:23:27.323] plan(): Setting new future strategy stack:
[13:23:27.324] List of future strategies:
[13:23:27.324] 1. multicore:
[13:23:27.324]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:27.324]    - tweaked: FALSE
[13:23:27.324]    - call: plan(strategy)
[13:23:27.329] plan(): nbrOfWorkers() = 2
[13:23:27.330] result() for MulticoreFuture ...
[13:23:27.330] result() for MulticoreFuture ... done
[13:23:27.330] result() for MulticoreFuture ... done
[13:23:27.331] result() for MulticoreFuture ...
[13:23:27.331] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:27.332] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:27.332] Searching for globals...
[13:23:27.335] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[13:23:27.335] Searching for globals ... DONE
[13:23:27.335] Resolving globals: TRUE
[13:23:27.336] Resolving any globals that are futures ...
[13:23:27.336] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[13:23:27.336] Resolving any globals that are futures ... DONE
[13:23:27.336] Resolving futures part of globals (recursively) ...
[13:23:27.337] resolve() on list ...
[13:23:27.337]  recursive: 99
[13:23:27.337]  length: 2
[13:23:27.337]  elements: ‘x’, ‘name’
[13:23:27.337]  length: 1 (resolved future 1)
[13:23:27.337]  length: 0 (resolved future 2)
[13:23:27.338] resolve() on list ... DONE
[13:23:27.338] - globals: [2] ‘x’, ‘name’
[13:23:27.338] Resolving futures part of globals (recursively) ... DONE
[13:23:27.338] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:27.339] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[13:23:27.339] - globals: [2] ‘x’, ‘name’
[13:23:27.339] 
[13:23:27.339] getGlobalsAndPackages() ... DONE
[13:23:27.339] run() for ‘Future’ ...
[13:23:27.339] - state: ‘created’
[13:23:27.340] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:27.344] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:27.344] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:27.344]   - Field: ‘label’
[13:23:27.344]   - Field: ‘local’
[13:23:27.344]   - Field: ‘owner’
[13:23:27.345]   - Field: ‘envir’
[13:23:27.345]   - Field: ‘workers’
[13:23:27.345]   - Field: ‘packages’
[13:23:27.345]   - Field: ‘gc’
[13:23:27.345]   - Field: ‘job’
[13:23:27.345]   - Field: ‘conditions’
[13:23:27.345]   - Field: ‘expr’
[13:23:27.345]   - Field: ‘uuid’
[13:23:27.345]   - Field: ‘seed’
[13:23:27.346]   - Field: ‘version’
[13:23:27.346]   - Field: ‘result’
[13:23:27.346]   - Field: ‘asynchronous’
[13:23:27.346]   - Field: ‘calls’
[13:23:27.346]   - Field: ‘globals’
[13:23:27.346]   - Field: ‘stdout’
[13:23:27.346]   - Field: ‘earlySignal’
[13:23:27.346]   - Field: ‘lazy’
[13:23:27.347]   - Field: ‘state’
[13:23:27.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:27.347] - Launch lazy future ...
[13:23:27.347] Packages needed by the future expression (n = 0): <none>
[13:23:27.347] Packages needed by future strategies (n = 0): <none>
[13:23:27.348] {
[13:23:27.348]     {
[13:23:27.348]         {
[13:23:27.348]             ...future.startTime <- base::Sys.time()
[13:23:27.348]             {
[13:23:27.348]                 {
[13:23:27.348]                   {
[13:23:27.348]                     {
[13:23:27.348]                       base::local({
[13:23:27.348]                         has_future <- base::requireNamespace("future", 
[13:23:27.348]                           quietly = TRUE)
[13:23:27.348]                         if (has_future) {
[13:23:27.348]                           ns <- base::getNamespace("future")
[13:23:27.348]                           version <- ns[[".package"]][["version"]]
[13:23:27.348]                           if (is.null(version)) 
[13:23:27.348]                             version <- utils::packageVersion("future")
[13:23:27.348]                         }
[13:23:27.348]                         else {
[13:23:27.348]                           version <- NULL
[13:23:27.348]                         }
[13:23:27.348]                         if (!has_future || version < "1.8.0") {
[13:23:27.348]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:27.348]                             "", base::R.version$version.string), 
[13:23:27.348]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:27.348]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:27.348]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:27.348]                               "release", "version")], collapse = " "), 
[13:23:27.348]                             hostname = base::Sys.info()[["nodename"]])
[13:23:27.348]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:27.348]                             info)
[13:23:27.348]                           info <- base::paste(info, collapse = "; ")
[13:23:27.348]                           if (!has_future) {
[13:23:27.348]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:27.348]                               info)
[13:23:27.348]                           }
[13:23:27.348]                           else {
[13:23:27.348]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:27.348]                               info, version)
[13:23:27.348]                           }
[13:23:27.348]                           base::stop(msg)
[13:23:27.348]                         }
[13:23:27.348]                       })
[13:23:27.348]                     }
[13:23:27.348]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:27.348]                     base::options(mc.cores = 1L)
[13:23:27.348]                   }
[13:23:27.348]                   options(future.plan = NULL)
[13:23:27.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.348]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:27.348]                 }
[13:23:27.348]                 ...future.workdir <- getwd()
[13:23:27.348]             }
[13:23:27.348]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:27.348]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:27.348]         }
[13:23:27.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:27.348]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:27.348]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:27.348]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:27.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:27.348]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:27.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:27.348]             base::names(...future.oldOptions))
[13:23:27.348]     }
[13:23:27.348]     if (FALSE) {
[13:23:27.348]     }
[13:23:27.348]     else {
[13:23:27.348]         if (TRUE) {
[13:23:27.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:27.348]                 open = "w")
[13:23:27.348]         }
[13:23:27.348]         else {
[13:23:27.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:27.348]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:27.348]         }
[13:23:27.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:27.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:27.348]             base::sink(type = "output", split = FALSE)
[13:23:27.348]             base::close(...future.stdout)
[13:23:27.348]         }, add = TRUE)
[13:23:27.348]     }
[13:23:27.348]     ...future.frame <- base::sys.nframe()
[13:23:27.348]     ...future.conditions <- base::list()
[13:23:27.348]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:27.348]     if (FALSE) {
[13:23:27.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:27.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:27.348]     }
[13:23:27.348]     ...future.result <- base::tryCatch({
[13:23:27.348]         base::withCallingHandlers({
[13:23:27.348]             ...future.value <- base::withVisible(base::local({
[13:23:27.348]                 withCallingHandlers({
[13:23:27.348]                   {
[13:23:27.348]                     x[name] <- list(1)
[13:23:27.348]                     x
[13:23:27.348]                   }
[13:23:27.348]                 }, immediateCondition = function(cond) {
[13:23:27.348]                   save_rds <- function (object, pathname, ...) 
[13:23:27.348]                   {
[13:23:27.348]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:27.348]                     if (file_test("-f", pathname_tmp)) {
[13:23:27.348]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.348]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:27.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.348]                         fi_tmp[["mtime"]])
[13:23:27.348]                     }
[13:23:27.348]                     tryCatch({
[13:23:27.348]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:27.348]                     }, error = function(ex) {
[13:23:27.348]                       msg <- conditionMessage(ex)
[13:23:27.348]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.348]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:27.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.348]                         fi_tmp[["mtime"]], msg)
[13:23:27.348]                       ex$message <- msg
[13:23:27.348]                       stop(ex)
[13:23:27.348]                     })
[13:23:27.348]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:27.348]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:27.348]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:27.348]                       fi_tmp <- file.info(pathname_tmp)
[13:23:27.348]                       fi <- file.info(pathname)
[13:23:27.348]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:27.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:27.348]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:27.348]                         fi[["size"]], fi[["mtime"]])
[13:23:27.348]                       stop(msg)
[13:23:27.348]                     }
[13:23:27.348]                     invisible(pathname)
[13:23:27.348]                   }
[13:23:27.348]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:27.348]                     rootPath = tempdir()) 
[13:23:27.348]                   {
[13:23:27.348]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:27.348]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:27.348]                       tmpdir = path, fileext = ".rds")
[13:23:27.348]                     save_rds(obj, file)
[13:23:27.348]                   }
[13:23:27.348]                   saveImmediateCondition(cond, path = "/tmp/Rtmpxi2rDI/.future/immediateConditions")
[13:23:27.348]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.348]                   {
[13:23:27.348]                     inherits <- base::inherits
[13:23:27.348]                     invokeRestart <- base::invokeRestart
[13:23:27.348]                     is.null <- base::is.null
[13:23:27.348]                     muffled <- FALSE
[13:23:27.348]                     if (inherits(cond, "message")) {
[13:23:27.348]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:27.348]                       if (muffled) 
[13:23:27.348]                         invokeRestart("muffleMessage")
[13:23:27.348]                     }
[13:23:27.348]                     else if (inherits(cond, "warning")) {
[13:23:27.348]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:27.348]                       if (muffled) 
[13:23:27.348]                         invokeRestart("muffleWarning")
[13:23:27.348]                     }
[13:23:27.348]                     else if (inherits(cond, "condition")) {
[13:23:27.348]                       if (!is.null(pattern)) {
[13:23:27.348]                         computeRestarts <- base::computeRestarts
[13:23:27.348]                         grepl <- base::grepl
[13:23:27.348]                         restarts <- computeRestarts(cond)
[13:23:27.348]                         for (restart in restarts) {
[13:23:27.348]                           name <- restart$name
[13:23:27.348]                           if (is.null(name)) 
[13:23:27.348]                             next
[13:23:27.348]                           if (!grepl(pattern, name)) 
[13:23:27.348]                             next
[13:23:27.348]                           invokeRestart(restart)
[13:23:27.348]                           muffled <- TRUE
[13:23:27.348]                           break
[13:23:27.348]                         }
[13:23:27.348]                       }
[13:23:27.348]                     }
[13:23:27.348]                     invisible(muffled)
[13:23:27.348]                   }
[13:23:27.348]                   muffleCondition(cond)
[13:23:27.348]                 })
[13:23:27.348]             }))
[13:23:27.348]             future::FutureResult(value = ...future.value$value, 
[13:23:27.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.348]                   ...future.rng), globalenv = if (FALSE) 
[13:23:27.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:27.348]                     ...future.globalenv.names))
[13:23:27.348]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:27.348]         }, condition = base::local({
[13:23:27.348]             c <- base::c
[13:23:27.348]             inherits <- base::inherits
[13:23:27.348]             invokeRestart <- base::invokeRestart
[13:23:27.348]             length <- base::length
[13:23:27.348]             list <- base::list
[13:23:27.348]             seq.int <- base::seq.int
[13:23:27.348]             signalCondition <- base::signalCondition
[13:23:27.348]             sys.calls <- base::sys.calls
[13:23:27.348]             `[[` <- base::`[[`
[13:23:27.348]             `+` <- base::`+`
[13:23:27.348]             `<<-` <- base::`<<-`
[13:23:27.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:27.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:27.348]                   3L)]
[13:23:27.348]             }
[13:23:27.348]             function(cond) {
[13:23:27.348]                 is_error <- inherits(cond, "error")
[13:23:27.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:27.348]                   NULL)
[13:23:27.348]                 if (is_error) {
[13:23:27.348]                   sessionInformation <- function() {
[13:23:27.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:27.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:27.348]                       search = base::search(), system = base::Sys.info())
[13:23:27.348]                   }
[13:23:27.348]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:27.348]                     cond$call), session = sessionInformation(), 
[13:23:27.348]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:27.348]                   signalCondition(cond)
[13:23:27.348]                 }
[13:23:27.348]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:27.348]                 "immediateCondition"))) {
[13:23:27.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:27.348]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:27.348]                   if (TRUE && !signal) {
[13:23:27.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.348]                     {
[13:23:27.348]                       inherits <- base::inherits
[13:23:27.348]                       invokeRestart <- base::invokeRestart
[13:23:27.348]                       is.null <- base::is.null
[13:23:27.348]                       muffled <- FALSE
[13:23:27.348]                       if (inherits(cond, "message")) {
[13:23:27.348]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.348]                         if (muffled) 
[13:23:27.348]                           invokeRestart("muffleMessage")
[13:23:27.348]                       }
[13:23:27.348]                       else if (inherits(cond, "warning")) {
[13:23:27.348]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.348]                         if (muffled) 
[13:23:27.348]                           invokeRestart("muffleWarning")
[13:23:27.348]                       }
[13:23:27.348]                       else if (inherits(cond, "condition")) {
[13:23:27.348]                         if (!is.null(pattern)) {
[13:23:27.348]                           computeRestarts <- base::computeRestarts
[13:23:27.348]                           grepl <- base::grepl
[13:23:27.348]                           restarts <- computeRestarts(cond)
[13:23:27.348]                           for (restart in restarts) {
[13:23:27.348]                             name <- restart$name
[13:23:27.348]                             if (is.null(name)) 
[13:23:27.348]                               next
[13:23:27.348]                             if (!grepl(pattern, name)) 
[13:23:27.348]                               next
[13:23:27.348]                             invokeRestart(restart)
[13:23:27.348]                             muffled <- TRUE
[13:23:27.348]                             break
[13:23:27.348]                           }
[13:23:27.348]                         }
[13:23:27.348]                       }
[13:23:27.348]                       invisible(muffled)
[13:23:27.348]                     }
[13:23:27.348]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.348]                   }
[13:23:27.348]                 }
[13:23:27.348]                 else {
[13:23:27.348]                   if (TRUE) {
[13:23:27.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.348]                     {
[13:23:27.348]                       inherits <- base::inherits
[13:23:27.348]                       invokeRestart <- base::invokeRestart
[13:23:27.348]                       is.null <- base::is.null
[13:23:27.348]                       muffled <- FALSE
[13:23:27.348]                       if (inherits(cond, "message")) {
[13:23:27.348]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.348]                         if (muffled) 
[13:23:27.348]                           invokeRestart("muffleMessage")
[13:23:27.348]                       }
[13:23:27.348]                       else if (inherits(cond, "warning")) {
[13:23:27.348]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.348]                         if (muffled) 
[13:23:27.348]                           invokeRestart("muffleWarning")
[13:23:27.348]                       }
[13:23:27.348]                       else if (inherits(cond, "condition")) {
[13:23:27.348]                         if (!is.null(pattern)) {
[13:23:27.348]                           computeRestarts <- base::computeRestarts
[13:23:27.348]                           grepl <- base::grepl
[13:23:27.348]                           restarts <- computeRestarts(cond)
[13:23:27.348]                           for (restart in restarts) {
[13:23:27.348]                             name <- restart$name
[13:23:27.348]                             if (is.null(name)) 
[13:23:27.348]                               next
[13:23:27.348]                             if (!grepl(pattern, name)) 
[13:23:27.348]                               next
[13:23:27.348]                             invokeRestart(restart)
[13:23:27.348]                             muffled <- TRUE
[13:23:27.348]                             break
[13:23:27.348]                           }
[13:23:27.348]                         }
[13:23:27.348]                       }
[13:23:27.348]                       invisible(muffled)
[13:23:27.348]                     }
[13:23:27.348]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.348]                   }
[13:23:27.348]                 }
[13:23:27.348]             }
[13:23:27.348]         }))
[13:23:27.348]     }, error = function(ex) {
[13:23:27.348]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:27.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.348]                 ...future.rng), started = ...future.startTime, 
[13:23:27.348]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:27.348]             version = "1.8"), class = "FutureResult")
[13:23:27.348]     }, finally = {
[13:23:27.348]         if (!identical(...future.workdir, getwd())) 
[13:23:27.348]             setwd(...future.workdir)
[13:23:27.348]         {
[13:23:27.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:27.348]                 ...future.oldOptions$nwarnings <- NULL
[13:23:27.348]             }
[13:23:27.348]             base::options(...future.oldOptions)
[13:23:27.348]             if (.Platform$OS.type == "windows") {
[13:23:27.348]                 old_names <- names(...future.oldEnvVars)
[13:23:27.348]                 envs <- base::Sys.getenv()
[13:23:27.348]                 names <- names(envs)
[13:23:27.348]                 common <- intersect(names, old_names)
[13:23:27.348]                 added <- setdiff(names, old_names)
[13:23:27.348]                 removed <- setdiff(old_names, names)
[13:23:27.348]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:27.348]                   envs[common]]
[13:23:27.348]                 NAMES <- toupper(changed)
[13:23:27.348]                 args <- list()
[13:23:27.348]                 for (kk in seq_along(NAMES)) {
[13:23:27.348]                   name <- changed[[kk]]
[13:23:27.348]                   NAME <- NAMES[[kk]]
[13:23:27.348]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.348]                     next
[13:23:27.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.348]                 }
[13:23:27.348]                 NAMES <- toupper(added)
[13:23:27.348]                 for (kk in seq_along(NAMES)) {
[13:23:27.348]                   name <- added[[kk]]
[13:23:27.348]                   NAME <- NAMES[[kk]]
[13:23:27.348]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.348]                     next
[13:23:27.348]                   args[[name]] <- ""
[13:23:27.348]                 }
[13:23:27.348]                 NAMES <- toupper(removed)
[13:23:27.348]                 for (kk in seq_along(NAMES)) {
[13:23:27.348]                   name <- removed[[kk]]
[13:23:27.348]                   NAME <- NAMES[[kk]]
[13:23:27.348]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.348]                     next
[13:23:27.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.348]                 }
[13:23:27.348]                 if (length(args) > 0) 
[13:23:27.348]                   base::do.call(base::Sys.setenv, args = args)
[13:23:27.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:27.348]             }
[13:23:27.348]             else {
[13:23:27.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:27.348]             }
[13:23:27.348]             {
[13:23:27.348]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:27.348]                   0L) {
[13:23:27.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:27.348]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:27.348]                   base::options(opts)
[13:23:27.348]                 }
[13:23:27.348]                 {
[13:23:27.348]                   {
[13:23:27.348]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:27.348]                     NULL
[13:23:27.348]                   }
[13:23:27.348]                   options(future.plan = NULL)
[13:23:27.348]                   if (is.na(NA_character_)) 
[13:23:27.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:27.348]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:27.348]                     envir = parent.frame()) 
[13:23:27.348]                   {
[13:23:27.348]                     default_workers <- missing(workers)
[13:23:27.348]                     if (is.function(workers)) 
[13:23:27.348]                       workers <- workers()
[13:23:27.348]                     workers <- structure(as.integer(workers), 
[13:23:27.348]                       class = class(workers))
[13:23:27.348]                     stop_if_not(is.finite(workers), workers >= 
[13:23:27.348]                       1L)
[13:23:27.348]                     if ((workers == 1L && !inherits(workers, 
[13:23:27.348]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:27.348]                       if (default_workers) 
[13:23:27.348]                         supportsMulticore(warn = TRUE)
[13:23:27.348]                       return(sequential(..., envir = envir))
[13:23:27.348]                     }
[13:23:27.348]                     oopts <- options(mc.cores = workers)
[13:23:27.348]                     on.exit(options(oopts))
[13:23:27.348]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:27.348]                       envir = envir)
[13:23:27.348]                     if (!future$lazy) 
[13:23:27.348]                       future <- run(future)
[13:23:27.348]                     invisible(future)
[13:23:27.348]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:27.348]                 }
[13:23:27.348]             }
[13:23:27.348]         }
[13:23:27.348]     })
[13:23:27.348]     if (TRUE) {
[13:23:27.348]         base::sink(type = "output", split = FALSE)
[13:23:27.348]         if (TRUE) {
[13:23:27.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:27.348]         }
[13:23:27.348]         else {
[13:23:27.348]             ...future.result["stdout"] <- base::list(NULL)
[13:23:27.348]         }
[13:23:27.348]         base::close(...future.stdout)
[13:23:27.348]         ...future.stdout <- NULL
[13:23:27.348]     }
[13:23:27.348]     ...future.result$conditions <- ...future.conditions
[13:23:27.348]     ...future.result$finished <- base::Sys.time()
[13:23:27.348]     ...future.result
[13:23:27.348] }
[13:23:27.351] assign_globals() ...
[13:23:27.351] List of 2
[13:23:27.351]  $ x   : list()
[13:23:27.351]  $ name: chr "a"
[13:23:27.351]  - attr(*, "where")=List of 2
[13:23:27.351]   ..$ x   :<environment: R_EmptyEnv> 
[13:23:27.351]   ..$ name:<environment: R_EmptyEnv> 
[13:23:27.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:27.351]  - attr(*, "resolved")= logi TRUE
[13:23:27.351]  - attr(*, "total_size")= num 112
[13:23:27.351]  - attr(*, "already-done")= logi TRUE
[13:23:27.355] - copied ‘x’ to environment
[13:23:27.355] - copied ‘name’ to environment
[13:23:27.355] assign_globals() ... done
[13:23:27.355] requestCore(): workers = 2
[13:23:27.357] MulticoreFuture started
[13:23:27.358] - Launch lazy future ... done
[13:23:27.358] run() for ‘MulticoreFuture’ ... done
[13:23:27.358] result() for MulticoreFuture ...
[13:23:27.358] plan(): Setting new future strategy stack:
[13:23:27.359] List of future strategies:
[13:23:27.359] 1. sequential:
[13:23:27.359]    - args: function (..., envir = parent.frame())
[13:23:27.359]    - tweaked: FALSE
[13:23:27.359]    - call: NULL
[13:23:27.359] plan(): nbrOfWorkers() = 1
[13:23:27.362] plan(): Setting new future strategy stack:
[13:23:27.362] List of future strategies:
[13:23:27.362] 1. multicore:
[13:23:27.362]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:27.362]    - tweaked: FALSE
[13:23:27.362]    - call: plan(strategy)
[13:23:27.367] plan(): nbrOfWorkers() = 2
[13:23:27.368] result() for MulticoreFuture ...
[13:23:27.369] result() for MulticoreFuture ... done
[13:23:27.369] result() for MulticoreFuture ... done
[13:23:27.369] result() for MulticoreFuture ...
[13:23:27.369] result() for MulticoreFuture ... done
$a
[1] 1

- plan('multisession') ...
[13:23:27.370] plan(): Setting new future strategy stack:
[13:23:27.370] List of future strategies:
[13:23:27.370] 1. multisession:
[13:23:27.370]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:27.370]    - tweaked: FALSE
[13:23:27.370]    - call: plan(strategy)
[13:23:27.370] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:23:27.371] multisession:
[13:23:27.371] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:27.371] - tweaked: FALSE
[13:23:27.371] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:27.381] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:27.381] Not searching for globals
[13:23:27.381] - globals: [0] <none>
[13:23:27.381] getGlobalsAndPackages() ... DONE
[13:23:27.382] [local output] makeClusterPSOCK() ...
[13:23:27.429] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:23:27.430] [local output] Base port: 11206
[13:23:27.430] [local output] Getting setup options for 2 cluster nodes ...
[13:23:27.431] [local output]  - Node 1 of 2 ...
[13:23:27.431] [local output] localMachine=TRUE => revtunnel=FALSE

[13:23:27.432] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpxi2rDI/worker.rank=1.parallelly.parent=86691.152a355e60301.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpxi2rDI/worker.rank=1.parallelly.parent=86691.152a355e60301.pid")'’
[13:23:27.628] - Possible to infer worker's PID: TRUE
[13:23:27.628] [local output] Rscript port: 11206

[13:23:27.628] [local output]  - Node 2 of 2 ...
[13:23:27.629] [local output] localMachine=TRUE => revtunnel=FALSE

[13:23:27.629] [local output] Rscript port: 11206

[13:23:27.630] [local output] Getting setup options for 2 cluster nodes ... done
[13:23:27.630] [local output]  - Parallel setup requested for some PSOCK nodes
[13:23:27.630] [local output] Setting up PSOCK nodes in parallel
[13:23:27.630] List of 36
[13:23:27.630]  $ worker          : chr "localhost"
[13:23:27.630]   ..- attr(*, "localhost")= logi TRUE
[13:23:27.630]  $ master          : chr "localhost"
[13:23:27.630]  $ port            : int 11206
[13:23:27.630]  $ connectTimeout  : num 120
[13:23:27.630]  $ timeout         : num 2592000
[13:23:27.630]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:23:27.630]  $ homogeneous     : logi TRUE
[13:23:27.630]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:23:27.630]  $ rscript_envs    : NULL
[13:23:27.630]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:23:27.630]  $ rscript_startup : NULL
[13:23:27.630]  $ rscript_sh      : chr "sh"
[13:23:27.630]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:23:27.630]  $ methods         : logi TRUE
[13:23:27.630]  $ socketOptions   : chr "no-delay"
[13:23:27.630]  $ useXDR          : logi FALSE
[13:23:27.630]  $ outfile         : chr "/dev/null"
[13:23:27.630]  $ renice          : int NA
[13:23:27.630]  $ rshcmd          : NULL
[13:23:27.630]  $ user            : chr(0) 
[13:23:27.630]  $ revtunnel       : logi FALSE
[13:23:27.630]  $ rshlogfile      : NULL
[13:23:27.630]  $ rshopts         : chr(0) 
[13:23:27.630]  $ rank            : int 1
[13:23:27.630]  $ manual          : logi FALSE
[13:23:27.630]  $ dryrun          : logi FALSE
[13:23:27.630]  $ quiet           : logi FALSE
[13:23:27.630]  $ setup_strategy  : chr "parallel"
[13:23:27.630]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:23:27.630]  $ pidfile         : chr "/tmp/Rtmpxi2rDI/worker.rank=1.parallelly.parent=86691.152a355e60301.pid"
[13:23:27.630]  $ rshcmd_label    : NULL
[13:23:27.630]  $ rsh_call        : NULL
[13:23:27.630]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:23:27.630]  $ localMachine    : logi TRUE
[13:23:27.630]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:23:27.630]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:23:27.630]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:23:27.630]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:23:27.630]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:23:27.630]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:23:27.630]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:23:27.630]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:23:27.630]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:23:27.630]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:23:27.630]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:23:27.630]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:23:27.630]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:23:27.630]  $ arguments       :List of 28
[13:23:27.630]   ..$ worker          : chr "localhost"
[13:23:27.630]   ..$ master          : NULL
[13:23:27.630]   ..$ port            : int 11206
[13:23:27.630]   ..$ connectTimeout  : num 120
[13:23:27.630]   ..$ timeout         : num 2592000
[13:23:27.630]   ..$ rscript         : NULL
[13:23:27.630]   ..$ homogeneous     : NULL
[13:23:27.630]   ..$ rscript_args    : NULL
[13:23:27.630]   ..$ rscript_envs    : NULL
[13:23:27.630]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:23:27.630]   ..$ rscript_startup : NULL
[13:23:27.630]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:23:27.630]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:23:27.630]   ..$ methods         : logi TRUE
[13:23:27.630]   ..$ socketOptions   : chr "no-delay"
[13:23:27.630]   ..$ useXDR          : logi FALSE
[13:23:27.630]   ..$ outfile         : chr "/dev/null"
[13:23:27.630]   ..$ renice          : int NA
[13:23:27.630]   ..$ rshcmd          : NULL
[13:23:27.630]   ..$ user            : NULL
[13:23:27.630]   ..$ revtunnel       : logi NA
[13:23:27.630]   ..$ rshlogfile      : NULL
[13:23:27.630]   ..$ rshopts         : NULL
[13:23:27.630]   ..$ rank            : int 1
[13:23:27.630]   ..$ manual          : logi FALSE
[13:23:27.630]   ..$ dryrun          : logi FALSE
[13:23:27.630]   ..$ quiet           : logi FALSE
[13:23:27.630]   ..$ setup_strategy  : chr "parallel"
[13:23:27.630]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:23:27.648] [local output] System call to launch all workers:
[13:23:27.648] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpxi2rDI/worker.rank=1.parallelly.parent=86691.152a355e60301.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11206 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:23:27.648] [local output] Starting PSOCK main server
[13:23:27.654] [local output] Workers launched
[13:23:27.654] [local output] Waiting for workers to connect back
[13:23:27.654]  - [local output] 0 workers out of 2 ready
[13:23:27.909]  - [local output] 0 workers out of 2 ready
[13:23:27.910]  - [local output] 1 workers out of 2 ready
[13:23:27.911]  - [local output] 1 workers out of 2 ready
[13:23:27.912]  - [local output] 2 workers out of 2 ready
[13:23:27.912] [local output] Launching of workers completed
[13:23:27.912] [local output] Collecting session information from workers
[13:23:27.913] [local output]  - Worker #1 of 2
[13:23:27.914] [local output]  - Worker #2 of 2
[13:23:27.914] [local output] makeClusterPSOCK() ... done
[13:23:27.925] Packages needed by the future expression (n = 0): <none>
[13:23:27.925] Packages needed by future strategies (n = 0): <none>
[13:23:27.926] {
[13:23:27.926]     {
[13:23:27.926]         {
[13:23:27.926]             ...future.startTime <- base::Sys.time()
[13:23:27.926]             {
[13:23:27.926]                 {
[13:23:27.926]                   {
[13:23:27.926]                     {
[13:23:27.926]                       base::local({
[13:23:27.926]                         has_future <- base::requireNamespace("future", 
[13:23:27.926]                           quietly = TRUE)
[13:23:27.926]                         if (has_future) {
[13:23:27.926]                           ns <- base::getNamespace("future")
[13:23:27.926]                           version <- ns[[".package"]][["version"]]
[13:23:27.926]                           if (is.null(version)) 
[13:23:27.926]                             version <- utils::packageVersion("future")
[13:23:27.926]                         }
[13:23:27.926]                         else {
[13:23:27.926]                           version <- NULL
[13:23:27.926]                         }
[13:23:27.926]                         if (!has_future || version < "1.8.0") {
[13:23:27.926]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:27.926]                             "", base::R.version$version.string), 
[13:23:27.926]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:27.926]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:27.926]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:27.926]                               "release", "version")], collapse = " "), 
[13:23:27.926]                             hostname = base::Sys.info()[["nodename"]])
[13:23:27.926]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:27.926]                             info)
[13:23:27.926]                           info <- base::paste(info, collapse = "; ")
[13:23:27.926]                           if (!has_future) {
[13:23:27.926]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:27.926]                               info)
[13:23:27.926]                           }
[13:23:27.926]                           else {
[13:23:27.926]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:27.926]                               info, version)
[13:23:27.926]                           }
[13:23:27.926]                           base::stop(msg)
[13:23:27.926]                         }
[13:23:27.926]                       })
[13:23:27.926]                     }
[13:23:27.926]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:27.926]                     base::options(mc.cores = 1L)
[13:23:27.926]                   }
[13:23:27.926]                   options(future.plan = NULL)
[13:23:27.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:27.926]                 }
[13:23:27.926]                 ...future.workdir <- getwd()
[13:23:27.926]             }
[13:23:27.926]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:27.926]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:27.926]         }
[13:23:27.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:27.926]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:27.926]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:27.926]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:27.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:27.926]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:27.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:27.926]             base::names(...future.oldOptions))
[13:23:27.926]     }
[13:23:27.926]     if (FALSE) {
[13:23:27.926]     }
[13:23:27.926]     else {
[13:23:27.926]         if (TRUE) {
[13:23:27.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:27.926]                 open = "w")
[13:23:27.926]         }
[13:23:27.926]         else {
[13:23:27.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:27.926]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:27.926]         }
[13:23:27.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:27.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:27.926]             base::sink(type = "output", split = FALSE)
[13:23:27.926]             base::close(...future.stdout)
[13:23:27.926]         }, add = TRUE)
[13:23:27.926]     }
[13:23:27.926]     ...future.frame <- base::sys.nframe()
[13:23:27.926]     ...future.conditions <- base::list()
[13:23:27.926]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:27.926]     if (FALSE) {
[13:23:27.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:27.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:27.926]     }
[13:23:27.926]     ...future.result <- base::tryCatch({
[13:23:27.926]         base::withCallingHandlers({
[13:23:27.926]             ...future.value <- base::withVisible(base::local({
[13:23:27.926]                 ...future.makeSendCondition <- base::local({
[13:23:27.926]                   sendCondition <- NULL
[13:23:27.926]                   function(frame = 1L) {
[13:23:27.926]                     if (is.function(sendCondition)) 
[13:23:27.926]                       return(sendCondition)
[13:23:27.926]                     ns <- getNamespace("parallel")
[13:23:27.926]                     if (exists("sendData", mode = "function", 
[13:23:27.926]                       envir = ns)) {
[13:23:27.926]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:27.926]                         envir = ns)
[13:23:27.926]                       envir <- sys.frame(frame)
[13:23:27.926]                       master <- NULL
[13:23:27.926]                       while (!identical(envir, .GlobalEnv) && 
[13:23:27.926]                         !identical(envir, emptyenv())) {
[13:23:27.926]                         if (exists("master", mode = "list", envir = envir, 
[13:23:27.926]                           inherits = FALSE)) {
[13:23:27.926]                           master <- get("master", mode = "list", 
[13:23:27.926]                             envir = envir, inherits = FALSE)
[13:23:27.926]                           if (inherits(master, c("SOCKnode", 
[13:23:27.926]                             "SOCK0node"))) {
[13:23:27.926]                             sendCondition <<- function(cond) {
[13:23:27.926]                               data <- list(type = "VALUE", value = cond, 
[13:23:27.926]                                 success = TRUE)
[13:23:27.926]                               parallel_sendData(master, data)
[13:23:27.926]                             }
[13:23:27.926]                             return(sendCondition)
[13:23:27.926]                           }
[13:23:27.926]                         }
[13:23:27.926]                         frame <- frame + 1L
[13:23:27.926]                         envir <- sys.frame(frame)
[13:23:27.926]                       }
[13:23:27.926]                     }
[13:23:27.926]                     sendCondition <<- function(cond) NULL
[13:23:27.926]                   }
[13:23:27.926]                 })
[13:23:27.926]                 withCallingHandlers({
[13:23:27.926]                   NA
[13:23:27.926]                 }, immediateCondition = function(cond) {
[13:23:27.926]                   sendCondition <- ...future.makeSendCondition()
[13:23:27.926]                   sendCondition(cond)
[13:23:27.926]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.926]                   {
[13:23:27.926]                     inherits <- base::inherits
[13:23:27.926]                     invokeRestart <- base::invokeRestart
[13:23:27.926]                     is.null <- base::is.null
[13:23:27.926]                     muffled <- FALSE
[13:23:27.926]                     if (inherits(cond, "message")) {
[13:23:27.926]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:27.926]                       if (muffled) 
[13:23:27.926]                         invokeRestart("muffleMessage")
[13:23:27.926]                     }
[13:23:27.926]                     else if (inherits(cond, "warning")) {
[13:23:27.926]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:27.926]                       if (muffled) 
[13:23:27.926]                         invokeRestart("muffleWarning")
[13:23:27.926]                     }
[13:23:27.926]                     else if (inherits(cond, "condition")) {
[13:23:27.926]                       if (!is.null(pattern)) {
[13:23:27.926]                         computeRestarts <- base::computeRestarts
[13:23:27.926]                         grepl <- base::grepl
[13:23:27.926]                         restarts <- computeRestarts(cond)
[13:23:27.926]                         for (restart in restarts) {
[13:23:27.926]                           name <- restart$name
[13:23:27.926]                           if (is.null(name)) 
[13:23:27.926]                             next
[13:23:27.926]                           if (!grepl(pattern, name)) 
[13:23:27.926]                             next
[13:23:27.926]                           invokeRestart(restart)
[13:23:27.926]                           muffled <- TRUE
[13:23:27.926]                           break
[13:23:27.926]                         }
[13:23:27.926]                       }
[13:23:27.926]                     }
[13:23:27.926]                     invisible(muffled)
[13:23:27.926]                   }
[13:23:27.926]                   muffleCondition(cond)
[13:23:27.926]                 })
[13:23:27.926]             }))
[13:23:27.926]             future::FutureResult(value = ...future.value$value, 
[13:23:27.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.926]                   ...future.rng), globalenv = if (FALSE) 
[13:23:27.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:27.926]                     ...future.globalenv.names))
[13:23:27.926]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:27.926]         }, condition = base::local({
[13:23:27.926]             c <- base::c
[13:23:27.926]             inherits <- base::inherits
[13:23:27.926]             invokeRestart <- base::invokeRestart
[13:23:27.926]             length <- base::length
[13:23:27.926]             list <- base::list
[13:23:27.926]             seq.int <- base::seq.int
[13:23:27.926]             signalCondition <- base::signalCondition
[13:23:27.926]             sys.calls <- base::sys.calls
[13:23:27.926]             `[[` <- base::`[[`
[13:23:27.926]             `+` <- base::`+`
[13:23:27.926]             `<<-` <- base::`<<-`
[13:23:27.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:27.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:27.926]                   3L)]
[13:23:27.926]             }
[13:23:27.926]             function(cond) {
[13:23:27.926]                 is_error <- inherits(cond, "error")
[13:23:27.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:27.926]                   NULL)
[13:23:27.926]                 if (is_error) {
[13:23:27.926]                   sessionInformation <- function() {
[13:23:27.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:27.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:27.926]                       search = base::search(), system = base::Sys.info())
[13:23:27.926]                   }
[13:23:27.926]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:27.926]                     cond$call), session = sessionInformation(), 
[13:23:27.926]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:27.926]                   signalCondition(cond)
[13:23:27.926]                 }
[13:23:27.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:27.926]                 "immediateCondition"))) {
[13:23:27.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:27.926]                   ...future.conditions[[length(...future.conditions) + 
[13:23:27.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:27.926]                   if (TRUE && !signal) {
[13:23:27.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.926]                     {
[13:23:27.926]                       inherits <- base::inherits
[13:23:27.926]                       invokeRestart <- base::invokeRestart
[13:23:27.926]                       is.null <- base::is.null
[13:23:27.926]                       muffled <- FALSE
[13:23:27.926]                       if (inherits(cond, "message")) {
[13:23:27.926]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.926]                         if (muffled) 
[13:23:27.926]                           invokeRestart("muffleMessage")
[13:23:27.926]                       }
[13:23:27.926]                       else if (inherits(cond, "warning")) {
[13:23:27.926]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.926]                         if (muffled) 
[13:23:27.926]                           invokeRestart("muffleWarning")
[13:23:27.926]                       }
[13:23:27.926]                       else if (inherits(cond, "condition")) {
[13:23:27.926]                         if (!is.null(pattern)) {
[13:23:27.926]                           computeRestarts <- base::computeRestarts
[13:23:27.926]                           grepl <- base::grepl
[13:23:27.926]                           restarts <- computeRestarts(cond)
[13:23:27.926]                           for (restart in restarts) {
[13:23:27.926]                             name <- restart$name
[13:23:27.926]                             if (is.null(name)) 
[13:23:27.926]                               next
[13:23:27.926]                             if (!grepl(pattern, name)) 
[13:23:27.926]                               next
[13:23:27.926]                             invokeRestart(restart)
[13:23:27.926]                             muffled <- TRUE
[13:23:27.926]                             break
[13:23:27.926]                           }
[13:23:27.926]                         }
[13:23:27.926]                       }
[13:23:27.926]                       invisible(muffled)
[13:23:27.926]                     }
[13:23:27.926]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.926]                   }
[13:23:27.926]                 }
[13:23:27.926]                 else {
[13:23:27.926]                   if (TRUE) {
[13:23:27.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:27.926]                     {
[13:23:27.926]                       inherits <- base::inherits
[13:23:27.926]                       invokeRestart <- base::invokeRestart
[13:23:27.926]                       is.null <- base::is.null
[13:23:27.926]                       muffled <- FALSE
[13:23:27.926]                       if (inherits(cond, "message")) {
[13:23:27.926]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:27.926]                         if (muffled) 
[13:23:27.926]                           invokeRestart("muffleMessage")
[13:23:27.926]                       }
[13:23:27.926]                       else if (inherits(cond, "warning")) {
[13:23:27.926]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:27.926]                         if (muffled) 
[13:23:27.926]                           invokeRestart("muffleWarning")
[13:23:27.926]                       }
[13:23:27.926]                       else if (inherits(cond, "condition")) {
[13:23:27.926]                         if (!is.null(pattern)) {
[13:23:27.926]                           computeRestarts <- base::computeRestarts
[13:23:27.926]                           grepl <- base::grepl
[13:23:27.926]                           restarts <- computeRestarts(cond)
[13:23:27.926]                           for (restart in restarts) {
[13:23:27.926]                             name <- restart$name
[13:23:27.926]                             if (is.null(name)) 
[13:23:27.926]                               next
[13:23:27.926]                             if (!grepl(pattern, name)) 
[13:23:27.926]                               next
[13:23:27.926]                             invokeRestart(restart)
[13:23:27.926]                             muffled <- TRUE
[13:23:27.926]                             break
[13:23:27.926]                           }
[13:23:27.926]                         }
[13:23:27.926]                       }
[13:23:27.926]                       invisible(muffled)
[13:23:27.926]                     }
[13:23:27.926]                     muffleCondition(cond, pattern = "^muffle")
[13:23:27.926]                   }
[13:23:27.926]                 }
[13:23:27.926]             }
[13:23:27.926]         }))
[13:23:27.926]     }, error = function(ex) {
[13:23:27.926]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:27.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:27.926]                 ...future.rng), started = ...future.startTime, 
[13:23:27.926]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:27.926]             version = "1.8"), class = "FutureResult")
[13:23:27.926]     }, finally = {
[13:23:27.926]         if (!identical(...future.workdir, getwd())) 
[13:23:27.926]             setwd(...future.workdir)
[13:23:27.926]         {
[13:23:27.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:27.926]                 ...future.oldOptions$nwarnings <- NULL
[13:23:27.926]             }
[13:23:27.926]             base::options(...future.oldOptions)
[13:23:27.926]             if (.Platform$OS.type == "windows") {
[13:23:27.926]                 old_names <- names(...future.oldEnvVars)
[13:23:27.926]                 envs <- base::Sys.getenv()
[13:23:27.926]                 names <- names(envs)
[13:23:27.926]                 common <- intersect(names, old_names)
[13:23:27.926]                 added <- setdiff(names, old_names)
[13:23:27.926]                 removed <- setdiff(old_names, names)
[13:23:27.926]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:27.926]                   envs[common]]
[13:23:27.926]                 NAMES <- toupper(changed)
[13:23:27.926]                 args <- list()
[13:23:27.926]                 for (kk in seq_along(NAMES)) {
[13:23:27.926]                   name <- changed[[kk]]
[13:23:27.926]                   NAME <- NAMES[[kk]]
[13:23:27.926]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.926]                     next
[13:23:27.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.926]                 }
[13:23:27.926]                 NAMES <- toupper(added)
[13:23:27.926]                 for (kk in seq_along(NAMES)) {
[13:23:27.926]                   name <- added[[kk]]
[13:23:27.926]                   NAME <- NAMES[[kk]]
[13:23:27.926]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.926]                     next
[13:23:27.926]                   args[[name]] <- ""
[13:23:27.926]                 }
[13:23:27.926]                 NAMES <- toupper(removed)
[13:23:27.926]                 for (kk in seq_along(NAMES)) {
[13:23:27.926]                   name <- removed[[kk]]
[13:23:27.926]                   NAME <- NAMES[[kk]]
[13:23:27.926]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:27.926]                     next
[13:23:27.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:27.926]                 }
[13:23:27.926]                 if (length(args) > 0) 
[13:23:27.926]                   base::do.call(base::Sys.setenv, args = args)
[13:23:27.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:27.926]             }
[13:23:27.926]             else {
[13:23:27.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:27.926]             }
[13:23:27.926]             {
[13:23:27.926]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:27.926]                   0L) {
[13:23:27.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:27.926]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:27.926]                   base::options(opts)
[13:23:27.926]                 }
[13:23:27.926]                 {
[13:23:27.926]                   {
[13:23:27.926]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:27.926]                     NULL
[13:23:27.926]                   }
[13:23:27.926]                   options(future.plan = NULL)
[13:23:27.926]                   if (is.na(NA_character_)) 
[13:23:27.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:27.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:27.926]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:27.926]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:27.926]                     envir = parent.frame()) 
[13:23:27.926]                   {
[13:23:27.926]                     if (is.function(workers)) 
[13:23:27.926]                       workers <- workers()
[13:23:27.926]                     workers <- structure(as.integer(workers), 
[13:23:27.926]                       class = class(workers))
[13:23:27.926]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:27.926]                       workers >= 1)
[13:23:27.926]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:27.926]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:27.926]                     }
[13:23:27.926]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:27.926]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:27.926]                       envir = envir)
[13:23:27.926]                     if (!future$lazy) 
[13:23:27.926]                       future <- run(future)
[13:23:27.926]                     invisible(future)
[13:23:27.926]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:27.926]                 }
[13:23:27.926]             }
[13:23:27.926]         }
[13:23:27.926]     })
[13:23:27.926]     if (TRUE) {
[13:23:27.926]         base::sink(type = "output", split = FALSE)
[13:23:27.926]         if (TRUE) {
[13:23:27.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:27.926]         }
[13:23:27.926]         else {
[13:23:27.926]             ...future.result["stdout"] <- base::list(NULL)
[13:23:27.926]         }
[13:23:27.926]         base::close(...future.stdout)
[13:23:27.926]         ...future.stdout <- NULL
[13:23:27.926]     }
[13:23:27.926]     ...future.result$conditions <- ...future.conditions
[13:23:27.926]     ...future.result$finished <- base::Sys.time()
[13:23:27.926]     ...future.result
[13:23:27.926] }
[13:23:27.982] MultisessionFuture started
[13:23:27.982] result() for ClusterFuture ...
[13:23:27.983] receiveMessageFromWorker() for ClusterFuture ...
[13:23:27.983] - Validating connection of MultisessionFuture
[13:23:28.027] - received message: FutureResult
[13:23:28.028] - Received FutureResult
[13:23:28.028] - Erased future from FutureRegistry
[13:23:28.028] result() for ClusterFuture ...
[13:23:28.028] - result already collected: FutureResult
[13:23:28.028] result() for ClusterFuture ... done
[13:23:28.028] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.028] result() for ClusterFuture ... done
[13:23:28.028] result() for ClusterFuture ...
[13:23:28.029] - result already collected: FutureResult
[13:23:28.029] result() for ClusterFuture ... done
[13:23:28.029] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:23:28.033] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:28.033] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:28.033] Searching for globals...
[13:23:28.036] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:28.036] Searching for globals ... DONE
[13:23:28.036] Resolving globals: TRUE
[13:23:28.037] Resolving any globals that are futures ...
[13:23:28.037] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:28.037] Resolving any globals that are futures ... DONE
[13:23:28.037] Resolving futures part of globals (recursively) ...
[13:23:28.038] resolve() on list ...
[13:23:28.038]  recursive: 99
[13:23:28.038]  length: 1
[13:23:28.038]  elements: ‘x’
[13:23:28.038]  length: 0 (resolved future 1)
[13:23:28.038] resolve() on list ... DONE
[13:23:28.038] - globals: [1] ‘x’
[13:23:28.038] Resolving futures part of globals (recursively) ... DONE
[13:23:28.039] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:28.039] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:28.039] - globals: [1] ‘x’
[13:23:28.039] 
[13:23:28.039] getGlobalsAndPackages() ... DONE
[13:23:28.040] run() for ‘Future’ ...
[13:23:28.040] - state: ‘created’
[13:23:28.040] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:28.055] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:28.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:28.055]   - Field: ‘node’
[13:23:28.055]   - Field: ‘label’
[13:23:28.055]   - Field: ‘local’
[13:23:28.056]   - Field: ‘owner’
[13:23:28.056]   - Field: ‘envir’
[13:23:28.056]   - Field: ‘workers’
[13:23:28.056]   - Field: ‘packages’
[13:23:28.056]   - Field: ‘gc’
[13:23:28.056]   - Field: ‘conditions’
[13:23:28.056]   - Field: ‘persistent’
[13:23:28.056]   - Field: ‘expr’
[13:23:28.056]   - Field: ‘uuid’
[13:23:28.057]   - Field: ‘seed’
[13:23:28.057]   - Field: ‘version’
[13:23:28.057]   - Field: ‘result’
[13:23:28.057]   - Field: ‘asynchronous’
[13:23:28.057]   - Field: ‘calls’
[13:23:28.057]   - Field: ‘globals’
[13:23:28.057]   - Field: ‘stdout’
[13:23:28.057]   - Field: ‘earlySignal’
[13:23:28.057]   - Field: ‘lazy’
[13:23:28.058]   - Field: ‘state’
[13:23:28.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:28.058] - Launch lazy future ...
[13:23:28.058] Packages needed by the future expression (n = 0): <none>
[13:23:28.058] Packages needed by future strategies (n = 0): <none>
[13:23:28.059] {
[13:23:28.059]     {
[13:23:28.059]         {
[13:23:28.059]             ...future.startTime <- base::Sys.time()
[13:23:28.059]             {
[13:23:28.059]                 {
[13:23:28.059]                   {
[13:23:28.059]                     {
[13:23:28.059]                       base::local({
[13:23:28.059]                         has_future <- base::requireNamespace("future", 
[13:23:28.059]                           quietly = TRUE)
[13:23:28.059]                         if (has_future) {
[13:23:28.059]                           ns <- base::getNamespace("future")
[13:23:28.059]                           version <- ns[[".package"]][["version"]]
[13:23:28.059]                           if (is.null(version)) 
[13:23:28.059]                             version <- utils::packageVersion("future")
[13:23:28.059]                         }
[13:23:28.059]                         else {
[13:23:28.059]                           version <- NULL
[13:23:28.059]                         }
[13:23:28.059]                         if (!has_future || version < "1.8.0") {
[13:23:28.059]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:28.059]                             "", base::R.version$version.string), 
[13:23:28.059]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:28.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:28.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:28.059]                               "release", "version")], collapse = " "), 
[13:23:28.059]                             hostname = base::Sys.info()[["nodename"]])
[13:23:28.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:28.059]                             info)
[13:23:28.059]                           info <- base::paste(info, collapse = "; ")
[13:23:28.059]                           if (!has_future) {
[13:23:28.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:28.059]                               info)
[13:23:28.059]                           }
[13:23:28.059]                           else {
[13:23:28.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:28.059]                               info, version)
[13:23:28.059]                           }
[13:23:28.059]                           base::stop(msg)
[13:23:28.059]                         }
[13:23:28.059]                       })
[13:23:28.059]                     }
[13:23:28.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:28.059]                     base::options(mc.cores = 1L)
[13:23:28.059]                   }
[13:23:28.059]                   options(future.plan = NULL)
[13:23:28.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:28.059]                 }
[13:23:28.059]                 ...future.workdir <- getwd()
[13:23:28.059]             }
[13:23:28.059]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:28.059]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:28.059]         }
[13:23:28.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:28.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:28.059]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:28.059]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:28.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:28.059]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:28.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:28.059]             base::names(...future.oldOptions))
[13:23:28.059]     }
[13:23:28.059]     if (FALSE) {
[13:23:28.059]     }
[13:23:28.059]     else {
[13:23:28.059]         if (TRUE) {
[13:23:28.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:28.059]                 open = "w")
[13:23:28.059]         }
[13:23:28.059]         else {
[13:23:28.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:28.059]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:28.059]         }
[13:23:28.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:28.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:28.059]             base::sink(type = "output", split = FALSE)
[13:23:28.059]             base::close(...future.stdout)
[13:23:28.059]         }, add = TRUE)
[13:23:28.059]     }
[13:23:28.059]     ...future.frame <- base::sys.nframe()
[13:23:28.059]     ...future.conditions <- base::list()
[13:23:28.059]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:28.059]     if (FALSE) {
[13:23:28.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:28.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:28.059]     }
[13:23:28.059]     ...future.result <- base::tryCatch({
[13:23:28.059]         base::withCallingHandlers({
[13:23:28.059]             ...future.value <- base::withVisible(base::local({
[13:23:28.059]                 ...future.makeSendCondition <- base::local({
[13:23:28.059]                   sendCondition <- NULL
[13:23:28.059]                   function(frame = 1L) {
[13:23:28.059]                     if (is.function(sendCondition)) 
[13:23:28.059]                       return(sendCondition)
[13:23:28.059]                     ns <- getNamespace("parallel")
[13:23:28.059]                     if (exists("sendData", mode = "function", 
[13:23:28.059]                       envir = ns)) {
[13:23:28.059]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:28.059]                         envir = ns)
[13:23:28.059]                       envir <- sys.frame(frame)
[13:23:28.059]                       master <- NULL
[13:23:28.059]                       while (!identical(envir, .GlobalEnv) && 
[13:23:28.059]                         !identical(envir, emptyenv())) {
[13:23:28.059]                         if (exists("master", mode = "list", envir = envir, 
[13:23:28.059]                           inherits = FALSE)) {
[13:23:28.059]                           master <- get("master", mode = "list", 
[13:23:28.059]                             envir = envir, inherits = FALSE)
[13:23:28.059]                           if (inherits(master, c("SOCKnode", 
[13:23:28.059]                             "SOCK0node"))) {
[13:23:28.059]                             sendCondition <<- function(cond) {
[13:23:28.059]                               data <- list(type = "VALUE", value = cond, 
[13:23:28.059]                                 success = TRUE)
[13:23:28.059]                               parallel_sendData(master, data)
[13:23:28.059]                             }
[13:23:28.059]                             return(sendCondition)
[13:23:28.059]                           }
[13:23:28.059]                         }
[13:23:28.059]                         frame <- frame + 1L
[13:23:28.059]                         envir <- sys.frame(frame)
[13:23:28.059]                       }
[13:23:28.059]                     }
[13:23:28.059]                     sendCondition <<- function(cond) NULL
[13:23:28.059]                   }
[13:23:28.059]                 })
[13:23:28.059]                 withCallingHandlers({
[13:23:28.059]                   {
[13:23:28.059]                     x$a <- 1
[13:23:28.059]                     x
[13:23:28.059]                   }
[13:23:28.059]                 }, immediateCondition = function(cond) {
[13:23:28.059]                   sendCondition <- ...future.makeSendCondition()
[13:23:28.059]                   sendCondition(cond)
[13:23:28.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.059]                   {
[13:23:28.059]                     inherits <- base::inherits
[13:23:28.059]                     invokeRestart <- base::invokeRestart
[13:23:28.059]                     is.null <- base::is.null
[13:23:28.059]                     muffled <- FALSE
[13:23:28.059]                     if (inherits(cond, "message")) {
[13:23:28.059]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:28.059]                       if (muffled) 
[13:23:28.059]                         invokeRestart("muffleMessage")
[13:23:28.059]                     }
[13:23:28.059]                     else if (inherits(cond, "warning")) {
[13:23:28.059]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:28.059]                       if (muffled) 
[13:23:28.059]                         invokeRestart("muffleWarning")
[13:23:28.059]                     }
[13:23:28.059]                     else if (inherits(cond, "condition")) {
[13:23:28.059]                       if (!is.null(pattern)) {
[13:23:28.059]                         computeRestarts <- base::computeRestarts
[13:23:28.059]                         grepl <- base::grepl
[13:23:28.059]                         restarts <- computeRestarts(cond)
[13:23:28.059]                         for (restart in restarts) {
[13:23:28.059]                           name <- restart$name
[13:23:28.059]                           if (is.null(name)) 
[13:23:28.059]                             next
[13:23:28.059]                           if (!grepl(pattern, name)) 
[13:23:28.059]                             next
[13:23:28.059]                           invokeRestart(restart)
[13:23:28.059]                           muffled <- TRUE
[13:23:28.059]                           break
[13:23:28.059]                         }
[13:23:28.059]                       }
[13:23:28.059]                     }
[13:23:28.059]                     invisible(muffled)
[13:23:28.059]                   }
[13:23:28.059]                   muffleCondition(cond)
[13:23:28.059]                 })
[13:23:28.059]             }))
[13:23:28.059]             future::FutureResult(value = ...future.value$value, 
[13:23:28.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.059]                   ...future.rng), globalenv = if (FALSE) 
[13:23:28.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:28.059]                     ...future.globalenv.names))
[13:23:28.059]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:28.059]         }, condition = base::local({
[13:23:28.059]             c <- base::c
[13:23:28.059]             inherits <- base::inherits
[13:23:28.059]             invokeRestart <- base::invokeRestart
[13:23:28.059]             length <- base::length
[13:23:28.059]             list <- base::list
[13:23:28.059]             seq.int <- base::seq.int
[13:23:28.059]             signalCondition <- base::signalCondition
[13:23:28.059]             sys.calls <- base::sys.calls
[13:23:28.059]             `[[` <- base::`[[`
[13:23:28.059]             `+` <- base::`+`
[13:23:28.059]             `<<-` <- base::`<<-`
[13:23:28.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:28.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:28.059]                   3L)]
[13:23:28.059]             }
[13:23:28.059]             function(cond) {
[13:23:28.059]                 is_error <- inherits(cond, "error")
[13:23:28.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:28.059]                   NULL)
[13:23:28.059]                 if (is_error) {
[13:23:28.059]                   sessionInformation <- function() {
[13:23:28.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:28.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:28.059]                       search = base::search(), system = base::Sys.info())
[13:23:28.059]                   }
[13:23:28.059]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:28.059]                     cond$call), session = sessionInformation(), 
[13:23:28.059]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:28.059]                   signalCondition(cond)
[13:23:28.059]                 }
[13:23:28.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:28.059]                 "immediateCondition"))) {
[13:23:28.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:28.059]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:28.059]                   if (TRUE && !signal) {
[13:23:28.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.059]                     {
[13:23:28.059]                       inherits <- base::inherits
[13:23:28.059]                       invokeRestart <- base::invokeRestart
[13:23:28.059]                       is.null <- base::is.null
[13:23:28.059]                       muffled <- FALSE
[13:23:28.059]                       if (inherits(cond, "message")) {
[13:23:28.059]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.059]                         if (muffled) 
[13:23:28.059]                           invokeRestart("muffleMessage")
[13:23:28.059]                       }
[13:23:28.059]                       else if (inherits(cond, "warning")) {
[13:23:28.059]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.059]                         if (muffled) 
[13:23:28.059]                           invokeRestart("muffleWarning")
[13:23:28.059]                       }
[13:23:28.059]                       else if (inherits(cond, "condition")) {
[13:23:28.059]                         if (!is.null(pattern)) {
[13:23:28.059]                           computeRestarts <- base::computeRestarts
[13:23:28.059]                           grepl <- base::grepl
[13:23:28.059]                           restarts <- computeRestarts(cond)
[13:23:28.059]                           for (restart in restarts) {
[13:23:28.059]                             name <- restart$name
[13:23:28.059]                             if (is.null(name)) 
[13:23:28.059]                               next
[13:23:28.059]                             if (!grepl(pattern, name)) 
[13:23:28.059]                               next
[13:23:28.059]                             invokeRestart(restart)
[13:23:28.059]                             muffled <- TRUE
[13:23:28.059]                             break
[13:23:28.059]                           }
[13:23:28.059]                         }
[13:23:28.059]                       }
[13:23:28.059]                       invisible(muffled)
[13:23:28.059]                     }
[13:23:28.059]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.059]                   }
[13:23:28.059]                 }
[13:23:28.059]                 else {
[13:23:28.059]                   if (TRUE) {
[13:23:28.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.059]                     {
[13:23:28.059]                       inherits <- base::inherits
[13:23:28.059]                       invokeRestart <- base::invokeRestart
[13:23:28.059]                       is.null <- base::is.null
[13:23:28.059]                       muffled <- FALSE
[13:23:28.059]                       if (inherits(cond, "message")) {
[13:23:28.059]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.059]                         if (muffled) 
[13:23:28.059]                           invokeRestart("muffleMessage")
[13:23:28.059]                       }
[13:23:28.059]                       else if (inherits(cond, "warning")) {
[13:23:28.059]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.059]                         if (muffled) 
[13:23:28.059]                           invokeRestart("muffleWarning")
[13:23:28.059]                       }
[13:23:28.059]                       else if (inherits(cond, "condition")) {
[13:23:28.059]                         if (!is.null(pattern)) {
[13:23:28.059]                           computeRestarts <- base::computeRestarts
[13:23:28.059]                           grepl <- base::grepl
[13:23:28.059]                           restarts <- computeRestarts(cond)
[13:23:28.059]                           for (restart in restarts) {
[13:23:28.059]                             name <- restart$name
[13:23:28.059]                             if (is.null(name)) 
[13:23:28.059]                               next
[13:23:28.059]                             if (!grepl(pattern, name)) 
[13:23:28.059]                               next
[13:23:28.059]                             invokeRestart(restart)
[13:23:28.059]                             muffled <- TRUE
[13:23:28.059]                             break
[13:23:28.059]                           }
[13:23:28.059]                         }
[13:23:28.059]                       }
[13:23:28.059]                       invisible(muffled)
[13:23:28.059]                     }
[13:23:28.059]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.059]                   }
[13:23:28.059]                 }
[13:23:28.059]             }
[13:23:28.059]         }))
[13:23:28.059]     }, error = function(ex) {
[13:23:28.059]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:28.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.059]                 ...future.rng), started = ...future.startTime, 
[13:23:28.059]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:28.059]             version = "1.8"), class = "FutureResult")
[13:23:28.059]     }, finally = {
[13:23:28.059]         if (!identical(...future.workdir, getwd())) 
[13:23:28.059]             setwd(...future.workdir)
[13:23:28.059]         {
[13:23:28.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:28.059]                 ...future.oldOptions$nwarnings <- NULL
[13:23:28.059]             }
[13:23:28.059]             base::options(...future.oldOptions)
[13:23:28.059]             if (.Platform$OS.type == "windows") {
[13:23:28.059]                 old_names <- names(...future.oldEnvVars)
[13:23:28.059]                 envs <- base::Sys.getenv()
[13:23:28.059]                 names <- names(envs)
[13:23:28.059]                 common <- intersect(names, old_names)
[13:23:28.059]                 added <- setdiff(names, old_names)
[13:23:28.059]                 removed <- setdiff(old_names, names)
[13:23:28.059]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:28.059]                   envs[common]]
[13:23:28.059]                 NAMES <- toupper(changed)
[13:23:28.059]                 args <- list()
[13:23:28.059]                 for (kk in seq_along(NAMES)) {
[13:23:28.059]                   name <- changed[[kk]]
[13:23:28.059]                   NAME <- NAMES[[kk]]
[13:23:28.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.059]                     next
[13:23:28.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.059]                 }
[13:23:28.059]                 NAMES <- toupper(added)
[13:23:28.059]                 for (kk in seq_along(NAMES)) {
[13:23:28.059]                   name <- added[[kk]]
[13:23:28.059]                   NAME <- NAMES[[kk]]
[13:23:28.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.059]                     next
[13:23:28.059]                   args[[name]] <- ""
[13:23:28.059]                 }
[13:23:28.059]                 NAMES <- toupper(removed)
[13:23:28.059]                 for (kk in seq_along(NAMES)) {
[13:23:28.059]                   name <- removed[[kk]]
[13:23:28.059]                   NAME <- NAMES[[kk]]
[13:23:28.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.059]                     next
[13:23:28.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.059]                 }
[13:23:28.059]                 if (length(args) > 0) 
[13:23:28.059]                   base::do.call(base::Sys.setenv, args = args)
[13:23:28.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:28.059]             }
[13:23:28.059]             else {
[13:23:28.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:28.059]             }
[13:23:28.059]             {
[13:23:28.059]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:28.059]                   0L) {
[13:23:28.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:28.059]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:28.059]                   base::options(opts)
[13:23:28.059]                 }
[13:23:28.059]                 {
[13:23:28.059]                   {
[13:23:28.059]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:28.059]                     NULL
[13:23:28.059]                   }
[13:23:28.059]                   options(future.plan = NULL)
[13:23:28.059]                   if (is.na(NA_character_)) 
[13:23:28.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:28.059]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:28.059]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:28.059]                     envir = parent.frame()) 
[13:23:28.059]                   {
[13:23:28.059]                     if (is.function(workers)) 
[13:23:28.059]                       workers <- workers()
[13:23:28.059]                     workers <- structure(as.integer(workers), 
[13:23:28.059]                       class = class(workers))
[13:23:28.059]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:28.059]                       workers >= 1)
[13:23:28.059]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:28.059]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:28.059]                     }
[13:23:28.059]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:28.059]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:28.059]                       envir = envir)
[13:23:28.059]                     if (!future$lazy) 
[13:23:28.059]                       future <- run(future)
[13:23:28.059]                     invisible(future)
[13:23:28.059]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:28.059]                 }
[13:23:28.059]             }
[13:23:28.059]         }
[13:23:28.059]     })
[13:23:28.059]     if (TRUE) {
[13:23:28.059]         base::sink(type = "output", split = FALSE)
[13:23:28.059]         if (TRUE) {
[13:23:28.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:28.059]         }
[13:23:28.059]         else {
[13:23:28.059]             ...future.result["stdout"] <- base::list(NULL)
[13:23:28.059]         }
[13:23:28.059]         base::close(...future.stdout)
[13:23:28.059]         ...future.stdout <- NULL
[13:23:28.059]     }
[13:23:28.059]     ...future.result$conditions <- ...future.conditions
[13:23:28.059]     ...future.result$finished <- base::Sys.time()
[13:23:28.059]     ...future.result
[13:23:28.059] }
[13:23:28.062] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:23:28.062] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:23:28.063] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:23:28.063] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:23:28.063] MultisessionFuture started
[13:23:28.064] - Launch lazy future ... done
[13:23:28.064] run() for ‘MultisessionFuture’ ... done
[13:23:28.064] result() for ClusterFuture ...
[13:23:28.064] receiveMessageFromWorker() for ClusterFuture ...
[13:23:28.064] - Validating connection of MultisessionFuture
[13:23:28.109] - received message: FutureResult
[13:23:28.109] - Received FutureResult
[13:23:28.110] - Erased future from FutureRegistry
[13:23:28.110] result() for ClusterFuture ...
[13:23:28.110] - result already collected: FutureResult
[13:23:28.110] result() for ClusterFuture ... done
[13:23:28.110] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.110] result() for ClusterFuture ... done
[13:23:28.111] result() for ClusterFuture ...
[13:23:28.111] - result already collected: FutureResult
[13:23:28.111] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:28.111] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:28.111] Searching for globals...
[13:23:28.114] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:28.114] Searching for globals ... DONE
[13:23:28.114] Resolving globals: TRUE
[13:23:28.115] Resolving any globals that are futures ...
[13:23:28.115] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:28.115] Resolving any globals that are futures ... DONE
[13:23:28.115] Resolving futures part of globals (recursively) ...
[13:23:28.115] resolve() on list ...
[13:23:28.116]  recursive: 99
[13:23:28.116]  length: 1
[13:23:28.116]  elements: ‘x’
[13:23:28.116]  length: 0 (resolved future 1)
[13:23:28.116] resolve() on list ... DONE
[13:23:28.116] - globals: [1] ‘x’
[13:23:28.116] Resolving futures part of globals (recursively) ... DONE
[13:23:28.117] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:28.117] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:28.117] - globals: [1] ‘x’
[13:23:28.117] 
[13:23:28.117] getGlobalsAndPackages() ... DONE
[13:23:28.118] run() for ‘Future’ ...
[13:23:28.118] - state: ‘created’
[13:23:28.118] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:28.133] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:28.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:28.133]   - Field: ‘node’
[13:23:28.133]   - Field: ‘label’
[13:23:28.133]   - Field: ‘local’
[13:23:28.133]   - Field: ‘owner’
[13:23:28.134]   - Field: ‘envir’
[13:23:28.134]   - Field: ‘workers’
[13:23:28.134]   - Field: ‘packages’
[13:23:28.134]   - Field: ‘gc’
[13:23:28.134]   - Field: ‘conditions’
[13:23:28.134]   - Field: ‘persistent’
[13:23:28.134]   - Field: ‘expr’
[13:23:28.134]   - Field: ‘uuid’
[13:23:28.134]   - Field: ‘seed’
[13:23:28.135]   - Field: ‘version’
[13:23:28.135]   - Field: ‘result’
[13:23:28.135]   - Field: ‘asynchronous’
[13:23:28.135]   - Field: ‘calls’
[13:23:28.135]   - Field: ‘globals’
[13:23:28.135]   - Field: ‘stdout’
[13:23:28.135]   - Field: ‘earlySignal’
[13:23:28.135]   - Field: ‘lazy’
[13:23:28.135]   - Field: ‘state’
[13:23:28.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:28.136] - Launch lazy future ...
[13:23:28.136] Packages needed by the future expression (n = 0): <none>
[13:23:28.136] Packages needed by future strategies (n = 0): <none>
[13:23:28.137] {
[13:23:28.137]     {
[13:23:28.137]         {
[13:23:28.137]             ...future.startTime <- base::Sys.time()
[13:23:28.137]             {
[13:23:28.137]                 {
[13:23:28.137]                   {
[13:23:28.137]                     {
[13:23:28.137]                       base::local({
[13:23:28.137]                         has_future <- base::requireNamespace("future", 
[13:23:28.137]                           quietly = TRUE)
[13:23:28.137]                         if (has_future) {
[13:23:28.137]                           ns <- base::getNamespace("future")
[13:23:28.137]                           version <- ns[[".package"]][["version"]]
[13:23:28.137]                           if (is.null(version)) 
[13:23:28.137]                             version <- utils::packageVersion("future")
[13:23:28.137]                         }
[13:23:28.137]                         else {
[13:23:28.137]                           version <- NULL
[13:23:28.137]                         }
[13:23:28.137]                         if (!has_future || version < "1.8.0") {
[13:23:28.137]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:28.137]                             "", base::R.version$version.string), 
[13:23:28.137]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:28.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:28.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:28.137]                               "release", "version")], collapse = " "), 
[13:23:28.137]                             hostname = base::Sys.info()[["nodename"]])
[13:23:28.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:28.137]                             info)
[13:23:28.137]                           info <- base::paste(info, collapse = "; ")
[13:23:28.137]                           if (!has_future) {
[13:23:28.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:28.137]                               info)
[13:23:28.137]                           }
[13:23:28.137]                           else {
[13:23:28.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:28.137]                               info, version)
[13:23:28.137]                           }
[13:23:28.137]                           base::stop(msg)
[13:23:28.137]                         }
[13:23:28.137]                       })
[13:23:28.137]                     }
[13:23:28.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:28.137]                     base::options(mc.cores = 1L)
[13:23:28.137]                   }
[13:23:28.137]                   options(future.plan = NULL)
[13:23:28.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:28.137]                 }
[13:23:28.137]                 ...future.workdir <- getwd()
[13:23:28.137]             }
[13:23:28.137]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:28.137]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:28.137]         }
[13:23:28.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:28.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:28.137]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:28.137]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:28.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:28.137]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:28.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:28.137]             base::names(...future.oldOptions))
[13:23:28.137]     }
[13:23:28.137]     if (FALSE) {
[13:23:28.137]     }
[13:23:28.137]     else {
[13:23:28.137]         if (TRUE) {
[13:23:28.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:28.137]                 open = "w")
[13:23:28.137]         }
[13:23:28.137]         else {
[13:23:28.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:28.137]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:28.137]         }
[13:23:28.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:28.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:28.137]             base::sink(type = "output", split = FALSE)
[13:23:28.137]             base::close(...future.stdout)
[13:23:28.137]         }, add = TRUE)
[13:23:28.137]     }
[13:23:28.137]     ...future.frame <- base::sys.nframe()
[13:23:28.137]     ...future.conditions <- base::list()
[13:23:28.137]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:28.137]     if (FALSE) {
[13:23:28.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:28.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:28.137]     }
[13:23:28.137]     ...future.result <- base::tryCatch({
[13:23:28.137]         base::withCallingHandlers({
[13:23:28.137]             ...future.value <- base::withVisible(base::local({
[13:23:28.137]                 ...future.makeSendCondition <- base::local({
[13:23:28.137]                   sendCondition <- NULL
[13:23:28.137]                   function(frame = 1L) {
[13:23:28.137]                     if (is.function(sendCondition)) 
[13:23:28.137]                       return(sendCondition)
[13:23:28.137]                     ns <- getNamespace("parallel")
[13:23:28.137]                     if (exists("sendData", mode = "function", 
[13:23:28.137]                       envir = ns)) {
[13:23:28.137]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:28.137]                         envir = ns)
[13:23:28.137]                       envir <- sys.frame(frame)
[13:23:28.137]                       master <- NULL
[13:23:28.137]                       while (!identical(envir, .GlobalEnv) && 
[13:23:28.137]                         !identical(envir, emptyenv())) {
[13:23:28.137]                         if (exists("master", mode = "list", envir = envir, 
[13:23:28.137]                           inherits = FALSE)) {
[13:23:28.137]                           master <- get("master", mode = "list", 
[13:23:28.137]                             envir = envir, inherits = FALSE)
[13:23:28.137]                           if (inherits(master, c("SOCKnode", 
[13:23:28.137]                             "SOCK0node"))) {
[13:23:28.137]                             sendCondition <<- function(cond) {
[13:23:28.137]                               data <- list(type = "VALUE", value = cond, 
[13:23:28.137]                                 success = TRUE)
[13:23:28.137]                               parallel_sendData(master, data)
[13:23:28.137]                             }
[13:23:28.137]                             return(sendCondition)
[13:23:28.137]                           }
[13:23:28.137]                         }
[13:23:28.137]                         frame <- frame + 1L
[13:23:28.137]                         envir <- sys.frame(frame)
[13:23:28.137]                       }
[13:23:28.137]                     }
[13:23:28.137]                     sendCondition <<- function(cond) NULL
[13:23:28.137]                   }
[13:23:28.137]                 })
[13:23:28.137]                 withCallingHandlers({
[13:23:28.137]                   {
[13:23:28.137]                     x$a <- 1
[13:23:28.137]                     x
[13:23:28.137]                   }
[13:23:28.137]                 }, immediateCondition = function(cond) {
[13:23:28.137]                   sendCondition <- ...future.makeSendCondition()
[13:23:28.137]                   sendCondition(cond)
[13:23:28.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.137]                   {
[13:23:28.137]                     inherits <- base::inherits
[13:23:28.137]                     invokeRestart <- base::invokeRestart
[13:23:28.137]                     is.null <- base::is.null
[13:23:28.137]                     muffled <- FALSE
[13:23:28.137]                     if (inherits(cond, "message")) {
[13:23:28.137]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:28.137]                       if (muffled) 
[13:23:28.137]                         invokeRestart("muffleMessage")
[13:23:28.137]                     }
[13:23:28.137]                     else if (inherits(cond, "warning")) {
[13:23:28.137]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:28.137]                       if (muffled) 
[13:23:28.137]                         invokeRestart("muffleWarning")
[13:23:28.137]                     }
[13:23:28.137]                     else if (inherits(cond, "condition")) {
[13:23:28.137]                       if (!is.null(pattern)) {
[13:23:28.137]                         computeRestarts <- base::computeRestarts
[13:23:28.137]                         grepl <- base::grepl
[13:23:28.137]                         restarts <- computeRestarts(cond)
[13:23:28.137]                         for (restart in restarts) {
[13:23:28.137]                           name <- restart$name
[13:23:28.137]                           if (is.null(name)) 
[13:23:28.137]                             next
[13:23:28.137]                           if (!grepl(pattern, name)) 
[13:23:28.137]                             next
[13:23:28.137]                           invokeRestart(restart)
[13:23:28.137]                           muffled <- TRUE
[13:23:28.137]                           break
[13:23:28.137]                         }
[13:23:28.137]                       }
[13:23:28.137]                     }
[13:23:28.137]                     invisible(muffled)
[13:23:28.137]                   }
[13:23:28.137]                   muffleCondition(cond)
[13:23:28.137]                 })
[13:23:28.137]             }))
[13:23:28.137]             future::FutureResult(value = ...future.value$value, 
[13:23:28.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.137]                   ...future.rng), globalenv = if (FALSE) 
[13:23:28.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:28.137]                     ...future.globalenv.names))
[13:23:28.137]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:28.137]         }, condition = base::local({
[13:23:28.137]             c <- base::c
[13:23:28.137]             inherits <- base::inherits
[13:23:28.137]             invokeRestart <- base::invokeRestart
[13:23:28.137]             length <- base::length
[13:23:28.137]             list <- base::list
[13:23:28.137]             seq.int <- base::seq.int
[13:23:28.137]             signalCondition <- base::signalCondition
[13:23:28.137]             sys.calls <- base::sys.calls
[13:23:28.137]             `[[` <- base::`[[`
[13:23:28.137]             `+` <- base::`+`
[13:23:28.137]             `<<-` <- base::`<<-`
[13:23:28.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:28.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:28.137]                   3L)]
[13:23:28.137]             }
[13:23:28.137]             function(cond) {
[13:23:28.137]                 is_error <- inherits(cond, "error")
[13:23:28.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:28.137]                   NULL)
[13:23:28.137]                 if (is_error) {
[13:23:28.137]                   sessionInformation <- function() {
[13:23:28.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:28.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:28.137]                       search = base::search(), system = base::Sys.info())
[13:23:28.137]                   }
[13:23:28.137]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:28.137]                     cond$call), session = sessionInformation(), 
[13:23:28.137]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:28.137]                   signalCondition(cond)
[13:23:28.137]                 }
[13:23:28.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:28.137]                 "immediateCondition"))) {
[13:23:28.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:28.137]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:28.137]                   if (TRUE && !signal) {
[13:23:28.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.137]                     {
[13:23:28.137]                       inherits <- base::inherits
[13:23:28.137]                       invokeRestart <- base::invokeRestart
[13:23:28.137]                       is.null <- base::is.null
[13:23:28.137]                       muffled <- FALSE
[13:23:28.137]                       if (inherits(cond, "message")) {
[13:23:28.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.137]                         if (muffled) 
[13:23:28.137]                           invokeRestart("muffleMessage")
[13:23:28.137]                       }
[13:23:28.137]                       else if (inherits(cond, "warning")) {
[13:23:28.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.137]                         if (muffled) 
[13:23:28.137]                           invokeRestart("muffleWarning")
[13:23:28.137]                       }
[13:23:28.137]                       else if (inherits(cond, "condition")) {
[13:23:28.137]                         if (!is.null(pattern)) {
[13:23:28.137]                           computeRestarts <- base::computeRestarts
[13:23:28.137]                           grepl <- base::grepl
[13:23:28.137]                           restarts <- computeRestarts(cond)
[13:23:28.137]                           for (restart in restarts) {
[13:23:28.137]                             name <- restart$name
[13:23:28.137]                             if (is.null(name)) 
[13:23:28.137]                               next
[13:23:28.137]                             if (!grepl(pattern, name)) 
[13:23:28.137]                               next
[13:23:28.137]                             invokeRestart(restart)
[13:23:28.137]                             muffled <- TRUE
[13:23:28.137]                             break
[13:23:28.137]                           }
[13:23:28.137]                         }
[13:23:28.137]                       }
[13:23:28.137]                       invisible(muffled)
[13:23:28.137]                     }
[13:23:28.137]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.137]                   }
[13:23:28.137]                 }
[13:23:28.137]                 else {
[13:23:28.137]                   if (TRUE) {
[13:23:28.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.137]                     {
[13:23:28.137]                       inherits <- base::inherits
[13:23:28.137]                       invokeRestart <- base::invokeRestart
[13:23:28.137]                       is.null <- base::is.null
[13:23:28.137]                       muffled <- FALSE
[13:23:28.137]                       if (inherits(cond, "message")) {
[13:23:28.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.137]                         if (muffled) 
[13:23:28.137]                           invokeRestart("muffleMessage")
[13:23:28.137]                       }
[13:23:28.137]                       else if (inherits(cond, "warning")) {
[13:23:28.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.137]                         if (muffled) 
[13:23:28.137]                           invokeRestart("muffleWarning")
[13:23:28.137]                       }
[13:23:28.137]                       else if (inherits(cond, "condition")) {
[13:23:28.137]                         if (!is.null(pattern)) {
[13:23:28.137]                           computeRestarts <- base::computeRestarts
[13:23:28.137]                           grepl <- base::grepl
[13:23:28.137]                           restarts <- computeRestarts(cond)
[13:23:28.137]                           for (restart in restarts) {
[13:23:28.137]                             name <- restart$name
[13:23:28.137]                             if (is.null(name)) 
[13:23:28.137]                               next
[13:23:28.137]                             if (!grepl(pattern, name)) 
[13:23:28.137]                               next
[13:23:28.137]                             invokeRestart(restart)
[13:23:28.137]                             muffled <- TRUE
[13:23:28.137]                             break
[13:23:28.137]                           }
[13:23:28.137]                         }
[13:23:28.137]                       }
[13:23:28.137]                       invisible(muffled)
[13:23:28.137]                     }
[13:23:28.137]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.137]                   }
[13:23:28.137]                 }
[13:23:28.137]             }
[13:23:28.137]         }))
[13:23:28.137]     }, error = function(ex) {
[13:23:28.137]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:28.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.137]                 ...future.rng), started = ...future.startTime, 
[13:23:28.137]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:28.137]             version = "1.8"), class = "FutureResult")
[13:23:28.137]     }, finally = {
[13:23:28.137]         if (!identical(...future.workdir, getwd())) 
[13:23:28.137]             setwd(...future.workdir)
[13:23:28.137]         {
[13:23:28.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:28.137]                 ...future.oldOptions$nwarnings <- NULL
[13:23:28.137]             }
[13:23:28.137]             base::options(...future.oldOptions)
[13:23:28.137]             if (.Platform$OS.type == "windows") {
[13:23:28.137]                 old_names <- names(...future.oldEnvVars)
[13:23:28.137]                 envs <- base::Sys.getenv()
[13:23:28.137]                 names <- names(envs)
[13:23:28.137]                 common <- intersect(names, old_names)
[13:23:28.137]                 added <- setdiff(names, old_names)
[13:23:28.137]                 removed <- setdiff(old_names, names)
[13:23:28.137]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:28.137]                   envs[common]]
[13:23:28.137]                 NAMES <- toupper(changed)
[13:23:28.137]                 args <- list()
[13:23:28.137]                 for (kk in seq_along(NAMES)) {
[13:23:28.137]                   name <- changed[[kk]]
[13:23:28.137]                   NAME <- NAMES[[kk]]
[13:23:28.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.137]                     next
[13:23:28.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.137]                 }
[13:23:28.137]                 NAMES <- toupper(added)
[13:23:28.137]                 for (kk in seq_along(NAMES)) {
[13:23:28.137]                   name <- added[[kk]]
[13:23:28.137]                   NAME <- NAMES[[kk]]
[13:23:28.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.137]                     next
[13:23:28.137]                   args[[name]] <- ""
[13:23:28.137]                 }
[13:23:28.137]                 NAMES <- toupper(removed)
[13:23:28.137]                 for (kk in seq_along(NAMES)) {
[13:23:28.137]                   name <- removed[[kk]]
[13:23:28.137]                   NAME <- NAMES[[kk]]
[13:23:28.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.137]                     next
[13:23:28.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.137]                 }
[13:23:28.137]                 if (length(args) > 0) 
[13:23:28.137]                   base::do.call(base::Sys.setenv, args = args)
[13:23:28.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:28.137]             }
[13:23:28.137]             else {
[13:23:28.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:28.137]             }
[13:23:28.137]             {
[13:23:28.137]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:28.137]                   0L) {
[13:23:28.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:28.137]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:28.137]                   base::options(opts)
[13:23:28.137]                 }
[13:23:28.137]                 {
[13:23:28.137]                   {
[13:23:28.137]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:28.137]                     NULL
[13:23:28.137]                   }
[13:23:28.137]                   options(future.plan = NULL)
[13:23:28.137]                   if (is.na(NA_character_)) 
[13:23:28.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:28.137]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:28.137]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:28.137]                     envir = parent.frame()) 
[13:23:28.137]                   {
[13:23:28.137]                     if (is.function(workers)) 
[13:23:28.137]                       workers <- workers()
[13:23:28.137]                     workers <- structure(as.integer(workers), 
[13:23:28.137]                       class = class(workers))
[13:23:28.137]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:28.137]                       workers >= 1)
[13:23:28.137]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:28.137]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:28.137]                     }
[13:23:28.137]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:28.137]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:28.137]                       envir = envir)
[13:23:28.137]                     if (!future$lazy) 
[13:23:28.137]                       future <- run(future)
[13:23:28.137]                     invisible(future)
[13:23:28.137]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:28.137]                 }
[13:23:28.137]             }
[13:23:28.137]         }
[13:23:28.137]     })
[13:23:28.137]     if (TRUE) {
[13:23:28.137]         base::sink(type = "output", split = FALSE)
[13:23:28.137]         if (TRUE) {
[13:23:28.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:28.137]         }
[13:23:28.137]         else {
[13:23:28.137]             ...future.result["stdout"] <- base::list(NULL)
[13:23:28.137]         }
[13:23:28.137]         base::close(...future.stdout)
[13:23:28.137]         ...future.stdout <- NULL
[13:23:28.137]     }
[13:23:28.137]     ...future.result$conditions <- ...future.conditions
[13:23:28.137]     ...future.result$finished <- base::Sys.time()
[13:23:28.137]     ...future.result
[13:23:28.137] }
[13:23:28.140] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:23:28.140] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:23:28.141] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:23:28.141] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:23:28.142] MultisessionFuture started
[13:23:28.142] - Launch lazy future ... done
[13:23:28.142] run() for ‘MultisessionFuture’ ... done
[13:23:28.142] result() for ClusterFuture ...
[13:23:28.142] receiveMessageFromWorker() for ClusterFuture ...
[13:23:28.142] - Validating connection of MultisessionFuture
[13:23:28.189] - received message: FutureResult
[13:23:28.189] - Received FutureResult
[13:23:28.190] - Erased future from FutureRegistry
[13:23:28.190] result() for ClusterFuture ...
[13:23:28.190] - result already collected: FutureResult
[13:23:28.190] result() for ClusterFuture ... done
[13:23:28.190] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.190] result() for ClusterFuture ... done
[13:23:28.190] result() for ClusterFuture ...
[13:23:28.190] - result already collected: FutureResult
[13:23:28.191] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:28.191] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:28.191] Searching for globals...
[13:23:28.194] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:28.194] Searching for globals ... DONE
[13:23:28.194] Resolving globals: TRUE
[13:23:28.194] Resolving any globals that are futures ...
[13:23:28.195] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:28.195] Resolving any globals that are futures ... DONE
[13:23:28.195] Resolving futures part of globals (recursively) ...
[13:23:28.195] resolve() on list ...
[13:23:28.196]  recursive: 99
[13:23:28.196]  length: 1
[13:23:28.196]  elements: ‘x’
[13:23:28.196]  length: 0 (resolved future 1)
[13:23:28.196] resolve() on list ... DONE
[13:23:28.196] - globals: [1] ‘x’
[13:23:28.196] Resolving futures part of globals (recursively) ... DONE
[13:23:28.197] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:28.197] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:28.197] - globals: [1] ‘x’
[13:23:28.197] 
[13:23:28.197] getGlobalsAndPackages() ... DONE
[13:23:28.198] run() for ‘Future’ ...
[13:23:28.198] - state: ‘created’
[13:23:28.198] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:28.217] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:28.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:28.218]   - Field: ‘node’
[13:23:28.218]   - Field: ‘label’
[13:23:28.218]   - Field: ‘local’
[13:23:28.218]   - Field: ‘owner’
[13:23:28.218]   - Field: ‘envir’
[13:23:28.218]   - Field: ‘workers’
[13:23:28.218]   - Field: ‘packages’
[13:23:28.218]   - Field: ‘gc’
[13:23:28.218]   - Field: ‘conditions’
[13:23:28.218]   - Field: ‘persistent’
[13:23:28.219]   - Field: ‘expr’
[13:23:28.219]   - Field: ‘uuid’
[13:23:28.219]   - Field: ‘seed’
[13:23:28.219]   - Field: ‘version’
[13:23:28.219]   - Field: ‘result’
[13:23:28.219]   - Field: ‘asynchronous’
[13:23:28.219]   - Field: ‘calls’
[13:23:28.219]   - Field: ‘globals’
[13:23:28.219]   - Field: ‘stdout’
[13:23:28.219]   - Field: ‘earlySignal’
[13:23:28.219]   - Field: ‘lazy’
[13:23:28.220]   - Field: ‘state’
[13:23:28.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:28.220] - Launch lazy future ...
[13:23:28.220] Packages needed by the future expression (n = 0): <none>
[13:23:28.220] Packages needed by future strategies (n = 0): <none>
[13:23:28.221] {
[13:23:28.221]     {
[13:23:28.221]         {
[13:23:28.221]             ...future.startTime <- base::Sys.time()
[13:23:28.221]             {
[13:23:28.221]                 {
[13:23:28.221]                   {
[13:23:28.221]                     {
[13:23:28.221]                       base::local({
[13:23:28.221]                         has_future <- base::requireNamespace("future", 
[13:23:28.221]                           quietly = TRUE)
[13:23:28.221]                         if (has_future) {
[13:23:28.221]                           ns <- base::getNamespace("future")
[13:23:28.221]                           version <- ns[[".package"]][["version"]]
[13:23:28.221]                           if (is.null(version)) 
[13:23:28.221]                             version <- utils::packageVersion("future")
[13:23:28.221]                         }
[13:23:28.221]                         else {
[13:23:28.221]                           version <- NULL
[13:23:28.221]                         }
[13:23:28.221]                         if (!has_future || version < "1.8.0") {
[13:23:28.221]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:28.221]                             "", base::R.version$version.string), 
[13:23:28.221]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:28.221]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:28.221]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:28.221]                               "release", "version")], collapse = " "), 
[13:23:28.221]                             hostname = base::Sys.info()[["nodename"]])
[13:23:28.221]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:28.221]                             info)
[13:23:28.221]                           info <- base::paste(info, collapse = "; ")
[13:23:28.221]                           if (!has_future) {
[13:23:28.221]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:28.221]                               info)
[13:23:28.221]                           }
[13:23:28.221]                           else {
[13:23:28.221]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:28.221]                               info, version)
[13:23:28.221]                           }
[13:23:28.221]                           base::stop(msg)
[13:23:28.221]                         }
[13:23:28.221]                       })
[13:23:28.221]                     }
[13:23:28.221]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:28.221]                     base::options(mc.cores = 1L)
[13:23:28.221]                   }
[13:23:28.221]                   options(future.plan = NULL)
[13:23:28.221]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.221]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:28.221]                 }
[13:23:28.221]                 ...future.workdir <- getwd()
[13:23:28.221]             }
[13:23:28.221]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:28.221]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:28.221]         }
[13:23:28.221]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:28.221]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:28.221]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:28.221]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:28.221]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:28.221]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:28.221]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:28.221]             base::names(...future.oldOptions))
[13:23:28.221]     }
[13:23:28.221]     if (FALSE) {
[13:23:28.221]     }
[13:23:28.221]     else {
[13:23:28.221]         if (TRUE) {
[13:23:28.221]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:28.221]                 open = "w")
[13:23:28.221]         }
[13:23:28.221]         else {
[13:23:28.221]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:28.221]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:28.221]         }
[13:23:28.221]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:28.221]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:28.221]             base::sink(type = "output", split = FALSE)
[13:23:28.221]             base::close(...future.stdout)
[13:23:28.221]         }, add = TRUE)
[13:23:28.221]     }
[13:23:28.221]     ...future.frame <- base::sys.nframe()
[13:23:28.221]     ...future.conditions <- base::list()
[13:23:28.221]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:28.221]     if (FALSE) {
[13:23:28.221]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:28.221]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:28.221]     }
[13:23:28.221]     ...future.result <- base::tryCatch({
[13:23:28.221]         base::withCallingHandlers({
[13:23:28.221]             ...future.value <- base::withVisible(base::local({
[13:23:28.221]                 ...future.makeSendCondition <- base::local({
[13:23:28.221]                   sendCondition <- NULL
[13:23:28.221]                   function(frame = 1L) {
[13:23:28.221]                     if (is.function(sendCondition)) 
[13:23:28.221]                       return(sendCondition)
[13:23:28.221]                     ns <- getNamespace("parallel")
[13:23:28.221]                     if (exists("sendData", mode = "function", 
[13:23:28.221]                       envir = ns)) {
[13:23:28.221]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:28.221]                         envir = ns)
[13:23:28.221]                       envir <- sys.frame(frame)
[13:23:28.221]                       master <- NULL
[13:23:28.221]                       while (!identical(envir, .GlobalEnv) && 
[13:23:28.221]                         !identical(envir, emptyenv())) {
[13:23:28.221]                         if (exists("master", mode = "list", envir = envir, 
[13:23:28.221]                           inherits = FALSE)) {
[13:23:28.221]                           master <- get("master", mode = "list", 
[13:23:28.221]                             envir = envir, inherits = FALSE)
[13:23:28.221]                           if (inherits(master, c("SOCKnode", 
[13:23:28.221]                             "SOCK0node"))) {
[13:23:28.221]                             sendCondition <<- function(cond) {
[13:23:28.221]                               data <- list(type = "VALUE", value = cond, 
[13:23:28.221]                                 success = TRUE)
[13:23:28.221]                               parallel_sendData(master, data)
[13:23:28.221]                             }
[13:23:28.221]                             return(sendCondition)
[13:23:28.221]                           }
[13:23:28.221]                         }
[13:23:28.221]                         frame <- frame + 1L
[13:23:28.221]                         envir <- sys.frame(frame)
[13:23:28.221]                       }
[13:23:28.221]                     }
[13:23:28.221]                     sendCondition <<- function(cond) NULL
[13:23:28.221]                   }
[13:23:28.221]                 })
[13:23:28.221]                 withCallingHandlers({
[13:23:28.221]                   {
[13:23:28.221]                     x$a <- 1
[13:23:28.221]                     x
[13:23:28.221]                   }
[13:23:28.221]                 }, immediateCondition = function(cond) {
[13:23:28.221]                   sendCondition <- ...future.makeSendCondition()
[13:23:28.221]                   sendCondition(cond)
[13:23:28.221]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.221]                   {
[13:23:28.221]                     inherits <- base::inherits
[13:23:28.221]                     invokeRestart <- base::invokeRestart
[13:23:28.221]                     is.null <- base::is.null
[13:23:28.221]                     muffled <- FALSE
[13:23:28.221]                     if (inherits(cond, "message")) {
[13:23:28.221]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:28.221]                       if (muffled) 
[13:23:28.221]                         invokeRestart("muffleMessage")
[13:23:28.221]                     }
[13:23:28.221]                     else if (inherits(cond, "warning")) {
[13:23:28.221]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:28.221]                       if (muffled) 
[13:23:28.221]                         invokeRestart("muffleWarning")
[13:23:28.221]                     }
[13:23:28.221]                     else if (inherits(cond, "condition")) {
[13:23:28.221]                       if (!is.null(pattern)) {
[13:23:28.221]                         computeRestarts <- base::computeRestarts
[13:23:28.221]                         grepl <- base::grepl
[13:23:28.221]                         restarts <- computeRestarts(cond)
[13:23:28.221]                         for (restart in restarts) {
[13:23:28.221]                           name <- restart$name
[13:23:28.221]                           if (is.null(name)) 
[13:23:28.221]                             next
[13:23:28.221]                           if (!grepl(pattern, name)) 
[13:23:28.221]                             next
[13:23:28.221]                           invokeRestart(restart)
[13:23:28.221]                           muffled <- TRUE
[13:23:28.221]                           break
[13:23:28.221]                         }
[13:23:28.221]                       }
[13:23:28.221]                     }
[13:23:28.221]                     invisible(muffled)
[13:23:28.221]                   }
[13:23:28.221]                   muffleCondition(cond)
[13:23:28.221]                 })
[13:23:28.221]             }))
[13:23:28.221]             future::FutureResult(value = ...future.value$value, 
[13:23:28.221]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.221]                   ...future.rng), globalenv = if (FALSE) 
[13:23:28.221]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:28.221]                     ...future.globalenv.names))
[13:23:28.221]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:28.221]         }, condition = base::local({
[13:23:28.221]             c <- base::c
[13:23:28.221]             inherits <- base::inherits
[13:23:28.221]             invokeRestart <- base::invokeRestart
[13:23:28.221]             length <- base::length
[13:23:28.221]             list <- base::list
[13:23:28.221]             seq.int <- base::seq.int
[13:23:28.221]             signalCondition <- base::signalCondition
[13:23:28.221]             sys.calls <- base::sys.calls
[13:23:28.221]             `[[` <- base::`[[`
[13:23:28.221]             `+` <- base::`+`
[13:23:28.221]             `<<-` <- base::`<<-`
[13:23:28.221]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:28.221]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:28.221]                   3L)]
[13:23:28.221]             }
[13:23:28.221]             function(cond) {
[13:23:28.221]                 is_error <- inherits(cond, "error")
[13:23:28.221]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:28.221]                   NULL)
[13:23:28.221]                 if (is_error) {
[13:23:28.221]                   sessionInformation <- function() {
[13:23:28.221]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:28.221]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:28.221]                       search = base::search(), system = base::Sys.info())
[13:23:28.221]                   }
[13:23:28.221]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.221]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:28.221]                     cond$call), session = sessionInformation(), 
[13:23:28.221]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:28.221]                   signalCondition(cond)
[13:23:28.221]                 }
[13:23:28.221]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:28.221]                 "immediateCondition"))) {
[13:23:28.221]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:28.221]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.221]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:28.221]                   if (TRUE && !signal) {
[13:23:28.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.221]                     {
[13:23:28.221]                       inherits <- base::inherits
[13:23:28.221]                       invokeRestart <- base::invokeRestart
[13:23:28.221]                       is.null <- base::is.null
[13:23:28.221]                       muffled <- FALSE
[13:23:28.221]                       if (inherits(cond, "message")) {
[13:23:28.221]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.221]                         if (muffled) 
[13:23:28.221]                           invokeRestart("muffleMessage")
[13:23:28.221]                       }
[13:23:28.221]                       else if (inherits(cond, "warning")) {
[13:23:28.221]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.221]                         if (muffled) 
[13:23:28.221]                           invokeRestart("muffleWarning")
[13:23:28.221]                       }
[13:23:28.221]                       else if (inherits(cond, "condition")) {
[13:23:28.221]                         if (!is.null(pattern)) {
[13:23:28.221]                           computeRestarts <- base::computeRestarts
[13:23:28.221]                           grepl <- base::grepl
[13:23:28.221]                           restarts <- computeRestarts(cond)
[13:23:28.221]                           for (restart in restarts) {
[13:23:28.221]                             name <- restart$name
[13:23:28.221]                             if (is.null(name)) 
[13:23:28.221]                               next
[13:23:28.221]                             if (!grepl(pattern, name)) 
[13:23:28.221]                               next
[13:23:28.221]                             invokeRestart(restart)
[13:23:28.221]                             muffled <- TRUE
[13:23:28.221]                             break
[13:23:28.221]                           }
[13:23:28.221]                         }
[13:23:28.221]                       }
[13:23:28.221]                       invisible(muffled)
[13:23:28.221]                     }
[13:23:28.221]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.221]                   }
[13:23:28.221]                 }
[13:23:28.221]                 else {
[13:23:28.221]                   if (TRUE) {
[13:23:28.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.221]                     {
[13:23:28.221]                       inherits <- base::inherits
[13:23:28.221]                       invokeRestart <- base::invokeRestart
[13:23:28.221]                       is.null <- base::is.null
[13:23:28.221]                       muffled <- FALSE
[13:23:28.221]                       if (inherits(cond, "message")) {
[13:23:28.221]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.221]                         if (muffled) 
[13:23:28.221]                           invokeRestart("muffleMessage")
[13:23:28.221]                       }
[13:23:28.221]                       else if (inherits(cond, "warning")) {
[13:23:28.221]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.221]                         if (muffled) 
[13:23:28.221]                           invokeRestart("muffleWarning")
[13:23:28.221]                       }
[13:23:28.221]                       else if (inherits(cond, "condition")) {
[13:23:28.221]                         if (!is.null(pattern)) {
[13:23:28.221]                           computeRestarts <- base::computeRestarts
[13:23:28.221]                           grepl <- base::grepl
[13:23:28.221]                           restarts <- computeRestarts(cond)
[13:23:28.221]                           for (restart in restarts) {
[13:23:28.221]                             name <- restart$name
[13:23:28.221]                             if (is.null(name)) 
[13:23:28.221]                               next
[13:23:28.221]                             if (!grepl(pattern, name)) 
[13:23:28.221]                               next
[13:23:28.221]                             invokeRestart(restart)
[13:23:28.221]                             muffled <- TRUE
[13:23:28.221]                             break
[13:23:28.221]                           }
[13:23:28.221]                         }
[13:23:28.221]                       }
[13:23:28.221]                       invisible(muffled)
[13:23:28.221]                     }
[13:23:28.221]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.221]                   }
[13:23:28.221]                 }
[13:23:28.221]             }
[13:23:28.221]         }))
[13:23:28.221]     }, error = function(ex) {
[13:23:28.221]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:28.221]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.221]                 ...future.rng), started = ...future.startTime, 
[13:23:28.221]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:28.221]             version = "1.8"), class = "FutureResult")
[13:23:28.221]     }, finally = {
[13:23:28.221]         if (!identical(...future.workdir, getwd())) 
[13:23:28.221]             setwd(...future.workdir)
[13:23:28.221]         {
[13:23:28.221]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:28.221]                 ...future.oldOptions$nwarnings <- NULL
[13:23:28.221]             }
[13:23:28.221]             base::options(...future.oldOptions)
[13:23:28.221]             if (.Platform$OS.type == "windows") {
[13:23:28.221]                 old_names <- names(...future.oldEnvVars)
[13:23:28.221]                 envs <- base::Sys.getenv()
[13:23:28.221]                 names <- names(envs)
[13:23:28.221]                 common <- intersect(names, old_names)
[13:23:28.221]                 added <- setdiff(names, old_names)
[13:23:28.221]                 removed <- setdiff(old_names, names)
[13:23:28.221]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:28.221]                   envs[common]]
[13:23:28.221]                 NAMES <- toupper(changed)
[13:23:28.221]                 args <- list()
[13:23:28.221]                 for (kk in seq_along(NAMES)) {
[13:23:28.221]                   name <- changed[[kk]]
[13:23:28.221]                   NAME <- NAMES[[kk]]
[13:23:28.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.221]                     next
[13:23:28.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.221]                 }
[13:23:28.221]                 NAMES <- toupper(added)
[13:23:28.221]                 for (kk in seq_along(NAMES)) {
[13:23:28.221]                   name <- added[[kk]]
[13:23:28.221]                   NAME <- NAMES[[kk]]
[13:23:28.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.221]                     next
[13:23:28.221]                   args[[name]] <- ""
[13:23:28.221]                 }
[13:23:28.221]                 NAMES <- toupper(removed)
[13:23:28.221]                 for (kk in seq_along(NAMES)) {
[13:23:28.221]                   name <- removed[[kk]]
[13:23:28.221]                   NAME <- NAMES[[kk]]
[13:23:28.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.221]                     next
[13:23:28.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.221]                 }
[13:23:28.221]                 if (length(args) > 0) 
[13:23:28.221]                   base::do.call(base::Sys.setenv, args = args)
[13:23:28.221]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:28.221]             }
[13:23:28.221]             else {
[13:23:28.221]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:28.221]             }
[13:23:28.221]             {
[13:23:28.221]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:28.221]                   0L) {
[13:23:28.221]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:28.221]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:28.221]                   base::options(opts)
[13:23:28.221]                 }
[13:23:28.221]                 {
[13:23:28.221]                   {
[13:23:28.221]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:28.221]                     NULL
[13:23:28.221]                   }
[13:23:28.221]                   options(future.plan = NULL)
[13:23:28.221]                   if (is.na(NA_character_)) 
[13:23:28.221]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.221]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:28.221]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:28.221]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:28.221]                     envir = parent.frame()) 
[13:23:28.221]                   {
[13:23:28.221]                     if (is.function(workers)) 
[13:23:28.221]                       workers <- workers()
[13:23:28.221]                     workers <- structure(as.integer(workers), 
[13:23:28.221]                       class = class(workers))
[13:23:28.221]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:28.221]                       workers >= 1)
[13:23:28.221]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:28.221]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:28.221]                     }
[13:23:28.221]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:28.221]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:28.221]                       envir = envir)
[13:23:28.221]                     if (!future$lazy) 
[13:23:28.221]                       future <- run(future)
[13:23:28.221]                     invisible(future)
[13:23:28.221]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:28.221]                 }
[13:23:28.221]             }
[13:23:28.221]         }
[13:23:28.221]     })
[13:23:28.221]     if (TRUE) {
[13:23:28.221]         base::sink(type = "output", split = FALSE)
[13:23:28.221]         if (TRUE) {
[13:23:28.221]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:28.221]         }
[13:23:28.221]         else {
[13:23:28.221]             ...future.result["stdout"] <- base::list(NULL)
[13:23:28.221]         }
[13:23:28.221]         base::close(...future.stdout)
[13:23:28.221]         ...future.stdout <- NULL
[13:23:28.221]     }
[13:23:28.221]     ...future.result$conditions <- ...future.conditions
[13:23:28.221]     ...future.result$finished <- base::Sys.time()
[13:23:28.221]     ...future.result
[13:23:28.221] }
[13:23:28.223] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:23:28.224] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:23:28.224] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:23:28.224] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:23:28.225] MultisessionFuture started
[13:23:28.225] - Launch lazy future ... done
[13:23:28.225] run() for ‘MultisessionFuture’ ... done
[13:23:28.225] result() for ClusterFuture ...
[13:23:28.225] receiveMessageFromWorker() for ClusterFuture ...
[13:23:28.225] - Validating connection of MultisessionFuture
[13:23:28.273] - received message: FutureResult
[13:23:28.273] - Received FutureResult
[13:23:28.274] - Erased future from FutureRegistry
[13:23:28.274] result() for ClusterFuture ...
[13:23:28.274] - result already collected: FutureResult
[13:23:28.274] result() for ClusterFuture ... done
[13:23:28.274] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.274] result() for ClusterFuture ... done
[13:23:28.274] result() for ClusterFuture ...
[13:23:28.274] - result already collected: FutureResult
[13:23:28.274] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:28.275] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:28.275] Searching for globals...
[13:23:28.277] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:28.277] Searching for globals ... DONE
[13:23:28.277] Resolving globals: TRUE
[13:23:28.277] Resolving any globals that are futures ...
[13:23:28.277] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:23:28.278] Resolving any globals that are futures ... DONE
[13:23:28.278] Resolving futures part of globals (recursively) ...
[13:23:28.278] resolve() on list ...
[13:23:28.278]  recursive: 99
[13:23:28.278]  length: 1
[13:23:28.278]  elements: ‘x’
[13:23:28.279]  length: 0 (resolved future 1)
[13:23:28.279] resolve() on list ... DONE
[13:23:28.279] - globals: [1] ‘x’
[13:23:28.279] Resolving futures part of globals (recursively) ... DONE
[13:23:28.279] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:28.279] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:28.279] - globals: [1] ‘x’
[13:23:28.280] 
[13:23:28.280] getGlobalsAndPackages() ... DONE
[13:23:28.280] run() for ‘Future’ ...
[13:23:28.280] - state: ‘created’
[13:23:28.280] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:28.294] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:28.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:28.294]   - Field: ‘node’
[13:23:28.295]   - Field: ‘label’
[13:23:28.295]   - Field: ‘local’
[13:23:28.295]   - Field: ‘owner’
[13:23:28.295]   - Field: ‘envir’
[13:23:28.295]   - Field: ‘workers’
[13:23:28.295]   - Field: ‘packages’
[13:23:28.295]   - Field: ‘gc’
[13:23:28.295]   - Field: ‘conditions’
[13:23:28.295]   - Field: ‘persistent’
[13:23:28.295]   - Field: ‘expr’
[13:23:28.296]   - Field: ‘uuid’
[13:23:28.296]   - Field: ‘seed’
[13:23:28.296]   - Field: ‘version’
[13:23:28.296]   - Field: ‘result’
[13:23:28.296]   - Field: ‘asynchronous’
[13:23:28.296]   - Field: ‘calls’
[13:23:28.296]   - Field: ‘globals’
[13:23:28.296]   - Field: ‘stdout’
[13:23:28.296]   - Field: ‘earlySignal’
[13:23:28.296]   - Field: ‘lazy’
[13:23:28.296]   - Field: ‘state’
[13:23:28.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:28.297] - Launch lazy future ...
[13:23:28.297] Packages needed by the future expression (n = 0): <none>
[13:23:28.297] Packages needed by future strategies (n = 0): <none>
[13:23:28.298] {
[13:23:28.298]     {
[13:23:28.298]         {
[13:23:28.298]             ...future.startTime <- base::Sys.time()
[13:23:28.298]             {
[13:23:28.298]                 {
[13:23:28.298]                   {
[13:23:28.298]                     {
[13:23:28.298]                       base::local({
[13:23:28.298]                         has_future <- base::requireNamespace("future", 
[13:23:28.298]                           quietly = TRUE)
[13:23:28.298]                         if (has_future) {
[13:23:28.298]                           ns <- base::getNamespace("future")
[13:23:28.298]                           version <- ns[[".package"]][["version"]]
[13:23:28.298]                           if (is.null(version)) 
[13:23:28.298]                             version <- utils::packageVersion("future")
[13:23:28.298]                         }
[13:23:28.298]                         else {
[13:23:28.298]                           version <- NULL
[13:23:28.298]                         }
[13:23:28.298]                         if (!has_future || version < "1.8.0") {
[13:23:28.298]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:28.298]                             "", base::R.version$version.string), 
[13:23:28.298]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:28.298]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:28.298]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:28.298]                               "release", "version")], collapse = " "), 
[13:23:28.298]                             hostname = base::Sys.info()[["nodename"]])
[13:23:28.298]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:28.298]                             info)
[13:23:28.298]                           info <- base::paste(info, collapse = "; ")
[13:23:28.298]                           if (!has_future) {
[13:23:28.298]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:28.298]                               info)
[13:23:28.298]                           }
[13:23:28.298]                           else {
[13:23:28.298]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:28.298]                               info, version)
[13:23:28.298]                           }
[13:23:28.298]                           base::stop(msg)
[13:23:28.298]                         }
[13:23:28.298]                       })
[13:23:28.298]                     }
[13:23:28.298]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:28.298]                     base::options(mc.cores = 1L)
[13:23:28.298]                   }
[13:23:28.298]                   options(future.plan = NULL)
[13:23:28.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:28.298]                 }
[13:23:28.298]                 ...future.workdir <- getwd()
[13:23:28.298]             }
[13:23:28.298]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:28.298]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:28.298]         }
[13:23:28.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:28.298]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:28.298]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:28.298]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:28.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:28.298]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:28.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:28.298]             base::names(...future.oldOptions))
[13:23:28.298]     }
[13:23:28.298]     if (FALSE) {
[13:23:28.298]     }
[13:23:28.298]     else {
[13:23:28.298]         if (TRUE) {
[13:23:28.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:28.298]                 open = "w")
[13:23:28.298]         }
[13:23:28.298]         else {
[13:23:28.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:28.298]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:28.298]         }
[13:23:28.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:28.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:28.298]             base::sink(type = "output", split = FALSE)
[13:23:28.298]             base::close(...future.stdout)
[13:23:28.298]         }, add = TRUE)
[13:23:28.298]     }
[13:23:28.298]     ...future.frame <- base::sys.nframe()
[13:23:28.298]     ...future.conditions <- base::list()
[13:23:28.298]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:28.298]     if (FALSE) {
[13:23:28.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:28.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:28.298]     }
[13:23:28.298]     ...future.result <- base::tryCatch({
[13:23:28.298]         base::withCallingHandlers({
[13:23:28.298]             ...future.value <- base::withVisible(base::local({
[13:23:28.298]                 ...future.makeSendCondition <- base::local({
[13:23:28.298]                   sendCondition <- NULL
[13:23:28.298]                   function(frame = 1L) {
[13:23:28.298]                     if (is.function(sendCondition)) 
[13:23:28.298]                       return(sendCondition)
[13:23:28.298]                     ns <- getNamespace("parallel")
[13:23:28.298]                     if (exists("sendData", mode = "function", 
[13:23:28.298]                       envir = ns)) {
[13:23:28.298]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:28.298]                         envir = ns)
[13:23:28.298]                       envir <- sys.frame(frame)
[13:23:28.298]                       master <- NULL
[13:23:28.298]                       while (!identical(envir, .GlobalEnv) && 
[13:23:28.298]                         !identical(envir, emptyenv())) {
[13:23:28.298]                         if (exists("master", mode = "list", envir = envir, 
[13:23:28.298]                           inherits = FALSE)) {
[13:23:28.298]                           master <- get("master", mode = "list", 
[13:23:28.298]                             envir = envir, inherits = FALSE)
[13:23:28.298]                           if (inherits(master, c("SOCKnode", 
[13:23:28.298]                             "SOCK0node"))) {
[13:23:28.298]                             sendCondition <<- function(cond) {
[13:23:28.298]                               data <- list(type = "VALUE", value = cond, 
[13:23:28.298]                                 success = TRUE)
[13:23:28.298]                               parallel_sendData(master, data)
[13:23:28.298]                             }
[13:23:28.298]                             return(sendCondition)
[13:23:28.298]                           }
[13:23:28.298]                         }
[13:23:28.298]                         frame <- frame + 1L
[13:23:28.298]                         envir <- sys.frame(frame)
[13:23:28.298]                       }
[13:23:28.298]                     }
[13:23:28.298]                     sendCondition <<- function(cond) NULL
[13:23:28.298]                   }
[13:23:28.298]                 })
[13:23:28.298]                 withCallingHandlers({
[13:23:28.298]                   {
[13:23:28.298]                     x$a <- 1
[13:23:28.298]                     x
[13:23:28.298]                   }
[13:23:28.298]                 }, immediateCondition = function(cond) {
[13:23:28.298]                   sendCondition <- ...future.makeSendCondition()
[13:23:28.298]                   sendCondition(cond)
[13:23:28.298]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.298]                   {
[13:23:28.298]                     inherits <- base::inherits
[13:23:28.298]                     invokeRestart <- base::invokeRestart
[13:23:28.298]                     is.null <- base::is.null
[13:23:28.298]                     muffled <- FALSE
[13:23:28.298]                     if (inherits(cond, "message")) {
[13:23:28.298]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:28.298]                       if (muffled) 
[13:23:28.298]                         invokeRestart("muffleMessage")
[13:23:28.298]                     }
[13:23:28.298]                     else if (inherits(cond, "warning")) {
[13:23:28.298]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:28.298]                       if (muffled) 
[13:23:28.298]                         invokeRestart("muffleWarning")
[13:23:28.298]                     }
[13:23:28.298]                     else if (inherits(cond, "condition")) {
[13:23:28.298]                       if (!is.null(pattern)) {
[13:23:28.298]                         computeRestarts <- base::computeRestarts
[13:23:28.298]                         grepl <- base::grepl
[13:23:28.298]                         restarts <- computeRestarts(cond)
[13:23:28.298]                         for (restart in restarts) {
[13:23:28.298]                           name <- restart$name
[13:23:28.298]                           if (is.null(name)) 
[13:23:28.298]                             next
[13:23:28.298]                           if (!grepl(pattern, name)) 
[13:23:28.298]                             next
[13:23:28.298]                           invokeRestart(restart)
[13:23:28.298]                           muffled <- TRUE
[13:23:28.298]                           break
[13:23:28.298]                         }
[13:23:28.298]                       }
[13:23:28.298]                     }
[13:23:28.298]                     invisible(muffled)
[13:23:28.298]                   }
[13:23:28.298]                   muffleCondition(cond)
[13:23:28.298]                 })
[13:23:28.298]             }))
[13:23:28.298]             future::FutureResult(value = ...future.value$value, 
[13:23:28.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.298]                   ...future.rng), globalenv = if (FALSE) 
[13:23:28.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:28.298]                     ...future.globalenv.names))
[13:23:28.298]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:28.298]         }, condition = base::local({
[13:23:28.298]             c <- base::c
[13:23:28.298]             inherits <- base::inherits
[13:23:28.298]             invokeRestart <- base::invokeRestart
[13:23:28.298]             length <- base::length
[13:23:28.298]             list <- base::list
[13:23:28.298]             seq.int <- base::seq.int
[13:23:28.298]             signalCondition <- base::signalCondition
[13:23:28.298]             sys.calls <- base::sys.calls
[13:23:28.298]             `[[` <- base::`[[`
[13:23:28.298]             `+` <- base::`+`
[13:23:28.298]             `<<-` <- base::`<<-`
[13:23:28.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:28.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:28.298]                   3L)]
[13:23:28.298]             }
[13:23:28.298]             function(cond) {
[13:23:28.298]                 is_error <- inherits(cond, "error")
[13:23:28.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:28.298]                   NULL)
[13:23:28.298]                 if (is_error) {
[13:23:28.298]                   sessionInformation <- function() {
[13:23:28.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:28.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:28.298]                       search = base::search(), system = base::Sys.info())
[13:23:28.298]                   }
[13:23:28.298]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:28.298]                     cond$call), session = sessionInformation(), 
[13:23:28.298]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:28.298]                   signalCondition(cond)
[13:23:28.298]                 }
[13:23:28.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:28.298]                 "immediateCondition"))) {
[13:23:28.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:28.298]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:28.298]                   if (TRUE && !signal) {
[13:23:28.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.298]                     {
[13:23:28.298]                       inherits <- base::inherits
[13:23:28.298]                       invokeRestart <- base::invokeRestart
[13:23:28.298]                       is.null <- base::is.null
[13:23:28.298]                       muffled <- FALSE
[13:23:28.298]                       if (inherits(cond, "message")) {
[13:23:28.298]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.298]                         if (muffled) 
[13:23:28.298]                           invokeRestart("muffleMessage")
[13:23:28.298]                       }
[13:23:28.298]                       else if (inherits(cond, "warning")) {
[13:23:28.298]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.298]                         if (muffled) 
[13:23:28.298]                           invokeRestart("muffleWarning")
[13:23:28.298]                       }
[13:23:28.298]                       else if (inherits(cond, "condition")) {
[13:23:28.298]                         if (!is.null(pattern)) {
[13:23:28.298]                           computeRestarts <- base::computeRestarts
[13:23:28.298]                           grepl <- base::grepl
[13:23:28.298]                           restarts <- computeRestarts(cond)
[13:23:28.298]                           for (restart in restarts) {
[13:23:28.298]                             name <- restart$name
[13:23:28.298]                             if (is.null(name)) 
[13:23:28.298]                               next
[13:23:28.298]                             if (!grepl(pattern, name)) 
[13:23:28.298]                               next
[13:23:28.298]                             invokeRestart(restart)
[13:23:28.298]                             muffled <- TRUE
[13:23:28.298]                             break
[13:23:28.298]                           }
[13:23:28.298]                         }
[13:23:28.298]                       }
[13:23:28.298]                       invisible(muffled)
[13:23:28.298]                     }
[13:23:28.298]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.298]                   }
[13:23:28.298]                 }
[13:23:28.298]                 else {
[13:23:28.298]                   if (TRUE) {
[13:23:28.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.298]                     {
[13:23:28.298]                       inherits <- base::inherits
[13:23:28.298]                       invokeRestart <- base::invokeRestart
[13:23:28.298]                       is.null <- base::is.null
[13:23:28.298]                       muffled <- FALSE
[13:23:28.298]                       if (inherits(cond, "message")) {
[13:23:28.298]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.298]                         if (muffled) 
[13:23:28.298]                           invokeRestart("muffleMessage")
[13:23:28.298]                       }
[13:23:28.298]                       else if (inherits(cond, "warning")) {
[13:23:28.298]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.298]                         if (muffled) 
[13:23:28.298]                           invokeRestart("muffleWarning")
[13:23:28.298]                       }
[13:23:28.298]                       else if (inherits(cond, "condition")) {
[13:23:28.298]                         if (!is.null(pattern)) {
[13:23:28.298]                           computeRestarts <- base::computeRestarts
[13:23:28.298]                           grepl <- base::grepl
[13:23:28.298]                           restarts <- computeRestarts(cond)
[13:23:28.298]                           for (restart in restarts) {
[13:23:28.298]                             name <- restart$name
[13:23:28.298]                             if (is.null(name)) 
[13:23:28.298]                               next
[13:23:28.298]                             if (!grepl(pattern, name)) 
[13:23:28.298]                               next
[13:23:28.298]                             invokeRestart(restart)
[13:23:28.298]                             muffled <- TRUE
[13:23:28.298]                             break
[13:23:28.298]                           }
[13:23:28.298]                         }
[13:23:28.298]                       }
[13:23:28.298]                       invisible(muffled)
[13:23:28.298]                     }
[13:23:28.298]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.298]                   }
[13:23:28.298]                 }
[13:23:28.298]             }
[13:23:28.298]         }))
[13:23:28.298]     }, error = function(ex) {
[13:23:28.298]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:28.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.298]                 ...future.rng), started = ...future.startTime, 
[13:23:28.298]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:28.298]             version = "1.8"), class = "FutureResult")
[13:23:28.298]     }, finally = {
[13:23:28.298]         if (!identical(...future.workdir, getwd())) 
[13:23:28.298]             setwd(...future.workdir)
[13:23:28.298]         {
[13:23:28.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:28.298]                 ...future.oldOptions$nwarnings <- NULL
[13:23:28.298]             }
[13:23:28.298]             base::options(...future.oldOptions)
[13:23:28.298]             if (.Platform$OS.type == "windows") {
[13:23:28.298]                 old_names <- names(...future.oldEnvVars)
[13:23:28.298]                 envs <- base::Sys.getenv()
[13:23:28.298]                 names <- names(envs)
[13:23:28.298]                 common <- intersect(names, old_names)
[13:23:28.298]                 added <- setdiff(names, old_names)
[13:23:28.298]                 removed <- setdiff(old_names, names)
[13:23:28.298]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:28.298]                   envs[common]]
[13:23:28.298]                 NAMES <- toupper(changed)
[13:23:28.298]                 args <- list()
[13:23:28.298]                 for (kk in seq_along(NAMES)) {
[13:23:28.298]                   name <- changed[[kk]]
[13:23:28.298]                   NAME <- NAMES[[kk]]
[13:23:28.298]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.298]                     next
[13:23:28.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.298]                 }
[13:23:28.298]                 NAMES <- toupper(added)
[13:23:28.298]                 for (kk in seq_along(NAMES)) {
[13:23:28.298]                   name <- added[[kk]]
[13:23:28.298]                   NAME <- NAMES[[kk]]
[13:23:28.298]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.298]                     next
[13:23:28.298]                   args[[name]] <- ""
[13:23:28.298]                 }
[13:23:28.298]                 NAMES <- toupper(removed)
[13:23:28.298]                 for (kk in seq_along(NAMES)) {
[13:23:28.298]                   name <- removed[[kk]]
[13:23:28.298]                   NAME <- NAMES[[kk]]
[13:23:28.298]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.298]                     next
[13:23:28.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.298]                 }
[13:23:28.298]                 if (length(args) > 0) 
[13:23:28.298]                   base::do.call(base::Sys.setenv, args = args)
[13:23:28.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:28.298]             }
[13:23:28.298]             else {
[13:23:28.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:28.298]             }
[13:23:28.298]             {
[13:23:28.298]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:28.298]                   0L) {
[13:23:28.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:28.298]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:28.298]                   base::options(opts)
[13:23:28.298]                 }
[13:23:28.298]                 {
[13:23:28.298]                   {
[13:23:28.298]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:28.298]                     NULL
[13:23:28.298]                   }
[13:23:28.298]                   options(future.plan = NULL)
[13:23:28.298]                   if (is.na(NA_character_)) 
[13:23:28.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:28.298]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:28.298]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:28.298]                     envir = parent.frame()) 
[13:23:28.298]                   {
[13:23:28.298]                     if (is.function(workers)) 
[13:23:28.298]                       workers <- workers()
[13:23:28.298]                     workers <- structure(as.integer(workers), 
[13:23:28.298]                       class = class(workers))
[13:23:28.298]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:28.298]                       workers >= 1)
[13:23:28.298]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:28.298]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:28.298]                     }
[13:23:28.298]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:28.298]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:28.298]                       envir = envir)
[13:23:28.298]                     if (!future$lazy) 
[13:23:28.298]                       future <- run(future)
[13:23:28.298]                     invisible(future)
[13:23:28.298]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:28.298]                 }
[13:23:28.298]             }
[13:23:28.298]         }
[13:23:28.298]     })
[13:23:28.298]     if (TRUE) {
[13:23:28.298]         base::sink(type = "output", split = FALSE)
[13:23:28.298]         if (TRUE) {
[13:23:28.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:28.298]         }
[13:23:28.298]         else {
[13:23:28.298]             ...future.result["stdout"] <- base::list(NULL)
[13:23:28.298]         }
[13:23:28.298]         base::close(...future.stdout)
[13:23:28.298]         ...future.stdout <- NULL
[13:23:28.298]     }
[13:23:28.298]     ...future.result$conditions <- ...future.conditions
[13:23:28.298]     ...future.result$finished <- base::Sys.time()
[13:23:28.298]     ...future.result
[13:23:28.298] }
[13:23:28.301] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:23:28.301] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:23:28.301] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:23:28.301] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:23:28.302] MultisessionFuture started
[13:23:28.302] - Launch lazy future ... done
[13:23:28.302] run() for ‘MultisessionFuture’ ... done
[13:23:28.302] result() for ClusterFuture ...
[13:23:28.302] receiveMessageFromWorker() for ClusterFuture ...
[13:23:28.302] - Validating connection of MultisessionFuture
[13:23:28.349] - received message: FutureResult
[13:23:28.349] - Received FutureResult
[13:23:28.350] - Erased future from FutureRegistry
[13:23:28.350] result() for ClusterFuture ...
[13:23:28.350] - result already collected: FutureResult
[13:23:28.350] result() for ClusterFuture ... done
[13:23:28.350] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.350] result() for ClusterFuture ... done
[13:23:28.350] result() for ClusterFuture ...
[13:23:28.350] - result already collected: FutureResult
[13:23:28.350] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:28.351] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:28.351] Searching for globals...
[13:23:28.354] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[13:23:28.354] Searching for globals ... DONE
[13:23:28.354] Resolving globals: TRUE
[13:23:28.354] Resolving any globals that are futures ...
[13:23:28.354] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[13:23:28.354] Resolving any globals that are futures ... DONE
[13:23:28.355] 
[13:23:28.355] 
[13:23:28.355] getGlobalsAndPackages() ... DONE
[13:23:28.355] run() for ‘Future’ ...
[13:23:28.355] - state: ‘created’
[13:23:28.355] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:28.369] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:28.370] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:28.370]   - Field: ‘node’
[13:23:28.370]   - Field: ‘label’
[13:23:28.370]   - Field: ‘local’
[13:23:28.370]   - Field: ‘owner’
[13:23:28.370]   - Field: ‘envir’
[13:23:28.370]   - Field: ‘workers’
[13:23:28.370]   - Field: ‘packages’
[13:23:28.371]   - Field: ‘gc’
[13:23:28.371]   - Field: ‘conditions’
[13:23:28.371]   - Field: ‘persistent’
[13:23:28.371]   - Field: ‘expr’
[13:23:28.371]   - Field: ‘uuid’
[13:23:28.371]   - Field: ‘seed’
[13:23:28.371]   - Field: ‘version’
[13:23:28.371]   - Field: ‘result’
[13:23:28.371]   - Field: ‘asynchronous’
[13:23:28.371]   - Field: ‘calls’
[13:23:28.371]   - Field: ‘globals’
[13:23:28.372]   - Field: ‘stdout’
[13:23:28.372]   - Field: ‘earlySignal’
[13:23:28.372]   - Field: ‘lazy’
[13:23:28.372]   - Field: ‘state’
[13:23:28.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:28.372] - Launch lazy future ...
[13:23:28.372] Packages needed by the future expression (n = 0): <none>
[13:23:28.373] Packages needed by future strategies (n = 0): <none>
[13:23:28.373] {
[13:23:28.373]     {
[13:23:28.373]         {
[13:23:28.373]             ...future.startTime <- base::Sys.time()
[13:23:28.373]             {
[13:23:28.373]                 {
[13:23:28.373]                   {
[13:23:28.373]                     {
[13:23:28.373]                       base::local({
[13:23:28.373]                         has_future <- base::requireNamespace("future", 
[13:23:28.373]                           quietly = TRUE)
[13:23:28.373]                         if (has_future) {
[13:23:28.373]                           ns <- base::getNamespace("future")
[13:23:28.373]                           version <- ns[[".package"]][["version"]]
[13:23:28.373]                           if (is.null(version)) 
[13:23:28.373]                             version <- utils::packageVersion("future")
[13:23:28.373]                         }
[13:23:28.373]                         else {
[13:23:28.373]                           version <- NULL
[13:23:28.373]                         }
[13:23:28.373]                         if (!has_future || version < "1.8.0") {
[13:23:28.373]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:28.373]                             "", base::R.version$version.string), 
[13:23:28.373]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:28.373]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:28.373]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:28.373]                               "release", "version")], collapse = " "), 
[13:23:28.373]                             hostname = base::Sys.info()[["nodename"]])
[13:23:28.373]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:28.373]                             info)
[13:23:28.373]                           info <- base::paste(info, collapse = "; ")
[13:23:28.373]                           if (!has_future) {
[13:23:28.373]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:28.373]                               info)
[13:23:28.373]                           }
[13:23:28.373]                           else {
[13:23:28.373]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:28.373]                               info, version)
[13:23:28.373]                           }
[13:23:28.373]                           base::stop(msg)
[13:23:28.373]                         }
[13:23:28.373]                       })
[13:23:28.373]                     }
[13:23:28.373]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:28.373]                     base::options(mc.cores = 1L)
[13:23:28.373]                   }
[13:23:28.373]                   options(future.plan = NULL)
[13:23:28.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:28.373]                 }
[13:23:28.373]                 ...future.workdir <- getwd()
[13:23:28.373]             }
[13:23:28.373]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:28.373]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:28.373]         }
[13:23:28.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:28.373]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:28.373]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:28.373]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:28.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:28.373]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:28.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:28.373]             base::names(...future.oldOptions))
[13:23:28.373]     }
[13:23:28.373]     if (FALSE) {
[13:23:28.373]     }
[13:23:28.373]     else {
[13:23:28.373]         if (TRUE) {
[13:23:28.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:28.373]                 open = "w")
[13:23:28.373]         }
[13:23:28.373]         else {
[13:23:28.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:28.373]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:28.373]         }
[13:23:28.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:28.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:28.373]             base::sink(type = "output", split = FALSE)
[13:23:28.373]             base::close(...future.stdout)
[13:23:28.373]         }, add = TRUE)
[13:23:28.373]     }
[13:23:28.373]     ...future.frame <- base::sys.nframe()
[13:23:28.373]     ...future.conditions <- base::list()
[13:23:28.373]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:28.373]     if (FALSE) {
[13:23:28.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:28.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:28.373]     }
[13:23:28.373]     ...future.result <- base::tryCatch({
[13:23:28.373]         base::withCallingHandlers({
[13:23:28.373]             ...future.value <- base::withVisible(base::local({
[13:23:28.373]                 ...future.makeSendCondition <- base::local({
[13:23:28.373]                   sendCondition <- NULL
[13:23:28.373]                   function(frame = 1L) {
[13:23:28.373]                     if (is.function(sendCondition)) 
[13:23:28.373]                       return(sendCondition)
[13:23:28.373]                     ns <- getNamespace("parallel")
[13:23:28.373]                     if (exists("sendData", mode = "function", 
[13:23:28.373]                       envir = ns)) {
[13:23:28.373]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:28.373]                         envir = ns)
[13:23:28.373]                       envir <- sys.frame(frame)
[13:23:28.373]                       master <- NULL
[13:23:28.373]                       while (!identical(envir, .GlobalEnv) && 
[13:23:28.373]                         !identical(envir, emptyenv())) {
[13:23:28.373]                         if (exists("master", mode = "list", envir = envir, 
[13:23:28.373]                           inherits = FALSE)) {
[13:23:28.373]                           master <- get("master", mode = "list", 
[13:23:28.373]                             envir = envir, inherits = FALSE)
[13:23:28.373]                           if (inherits(master, c("SOCKnode", 
[13:23:28.373]                             "SOCK0node"))) {
[13:23:28.373]                             sendCondition <<- function(cond) {
[13:23:28.373]                               data <- list(type = "VALUE", value = cond, 
[13:23:28.373]                                 success = TRUE)
[13:23:28.373]                               parallel_sendData(master, data)
[13:23:28.373]                             }
[13:23:28.373]                             return(sendCondition)
[13:23:28.373]                           }
[13:23:28.373]                         }
[13:23:28.373]                         frame <- frame + 1L
[13:23:28.373]                         envir <- sys.frame(frame)
[13:23:28.373]                       }
[13:23:28.373]                     }
[13:23:28.373]                     sendCondition <<- function(cond) NULL
[13:23:28.373]                   }
[13:23:28.373]                 })
[13:23:28.373]                 withCallingHandlers({
[13:23:28.373]                   {
[13:23:28.373]                     x <- list(b = 2)
[13:23:28.373]                     x$a <- 1
[13:23:28.373]                     x
[13:23:28.373]                   }
[13:23:28.373]                 }, immediateCondition = function(cond) {
[13:23:28.373]                   sendCondition <- ...future.makeSendCondition()
[13:23:28.373]                   sendCondition(cond)
[13:23:28.373]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.373]                   {
[13:23:28.373]                     inherits <- base::inherits
[13:23:28.373]                     invokeRestart <- base::invokeRestart
[13:23:28.373]                     is.null <- base::is.null
[13:23:28.373]                     muffled <- FALSE
[13:23:28.373]                     if (inherits(cond, "message")) {
[13:23:28.373]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:28.373]                       if (muffled) 
[13:23:28.373]                         invokeRestart("muffleMessage")
[13:23:28.373]                     }
[13:23:28.373]                     else if (inherits(cond, "warning")) {
[13:23:28.373]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:28.373]                       if (muffled) 
[13:23:28.373]                         invokeRestart("muffleWarning")
[13:23:28.373]                     }
[13:23:28.373]                     else if (inherits(cond, "condition")) {
[13:23:28.373]                       if (!is.null(pattern)) {
[13:23:28.373]                         computeRestarts <- base::computeRestarts
[13:23:28.373]                         grepl <- base::grepl
[13:23:28.373]                         restarts <- computeRestarts(cond)
[13:23:28.373]                         for (restart in restarts) {
[13:23:28.373]                           name <- restart$name
[13:23:28.373]                           if (is.null(name)) 
[13:23:28.373]                             next
[13:23:28.373]                           if (!grepl(pattern, name)) 
[13:23:28.373]                             next
[13:23:28.373]                           invokeRestart(restart)
[13:23:28.373]                           muffled <- TRUE
[13:23:28.373]                           break
[13:23:28.373]                         }
[13:23:28.373]                       }
[13:23:28.373]                     }
[13:23:28.373]                     invisible(muffled)
[13:23:28.373]                   }
[13:23:28.373]                   muffleCondition(cond)
[13:23:28.373]                 })
[13:23:28.373]             }))
[13:23:28.373]             future::FutureResult(value = ...future.value$value, 
[13:23:28.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.373]                   ...future.rng), globalenv = if (FALSE) 
[13:23:28.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:28.373]                     ...future.globalenv.names))
[13:23:28.373]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:28.373]         }, condition = base::local({
[13:23:28.373]             c <- base::c
[13:23:28.373]             inherits <- base::inherits
[13:23:28.373]             invokeRestart <- base::invokeRestart
[13:23:28.373]             length <- base::length
[13:23:28.373]             list <- base::list
[13:23:28.373]             seq.int <- base::seq.int
[13:23:28.373]             signalCondition <- base::signalCondition
[13:23:28.373]             sys.calls <- base::sys.calls
[13:23:28.373]             `[[` <- base::`[[`
[13:23:28.373]             `+` <- base::`+`
[13:23:28.373]             `<<-` <- base::`<<-`
[13:23:28.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:28.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:28.373]                   3L)]
[13:23:28.373]             }
[13:23:28.373]             function(cond) {
[13:23:28.373]                 is_error <- inherits(cond, "error")
[13:23:28.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:28.373]                   NULL)
[13:23:28.373]                 if (is_error) {
[13:23:28.373]                   sessionInformation <- function() {
[13:23:28.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:28.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:28.373]                       search = base::search(), system = base::Sys.info())
[13:23:28.373]                   }
[13:23:28.373]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:28.373]                     cond$call), session = sessionInformation(), 
[13:23:28.373]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:28.373]                   signalCondition(cond)
[13:23:28.373]                 }
[13:23:28.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:28.373]                 "immediateCondition"))) {
[13:23:28.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:28.373]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:28.373]                   if (TRUE && !signal) {
[13:23:28.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.373]                     {
[13:23:28.373]                       inherits <- base::inherits
[13:23:28.373]                       invokeRestart <- base::invokeRestart
[13:23:28.373]                       is.null <- base::is.null
[13:23:28.373]                       muffled <- FALSE
[13:23:28.373]                       if (inherits(cond, "message")) {
[13:23:28.373]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.373]                         if (muffled) 
[13:23:28.373]                           invokeRestart("muffleMessage")
[13:23:28.373]                       }
[13:23:28.373]                       else if (inherits(cond, "warning")) {
[13:23:28.373]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.373]                         if (muffled) 
[13:23:28.373]                           invokeRestart("muffleWarning")
[13:23:28.373]                       }
[13:23:28.373]                       else if (inherits(cond, "condition")) {
[13:23:28.373]                         if (!is.null(pattern)) {
[13:23:28.373]                           computeRestarts <- base::computeRestarts
[13:23:28.373]                           grepl <- base::grepl
[13:23:28.373]                           restarts <- computeRestarts(cond)
[13:23:28.373]                           for (restart in restarts) {
[13:23:28.373]                             name <- restart$name
[13:23:28.373]                             if (is.null(name)) 
[13:23:28.373]                               next
[13:23:28.373]                             if (!grepl(pattern, name)) 
[13:23:28.373]                               next
[13:23:28.373]                             invokeRestart(restart)
[13:23:28.373]                             muffled <- TRUE
[13:23:28.373]                             break
[13:23:28.373]                           }
[13:23:28.373]                         }
[13:23:28.373]                       }
[13:23:28.373]                       invisible(muffled)
[13:23:28.373]                     }
[13:23:28.373]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.373]                   }
[13:23:28.373]                 }
[13:23:28.373]                 else {
[13:23:28.373]                   if (TRUE) {
[13:23:28.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.373]                     {
[13:23:28.373]                       inherits <- base::inherits
[13:23:28.373]                       invokeRestart <- base::invokeRestart
[13:23:28.373]                       is.null <- base::is.null
[13:23:28.373]                       muffled <- FALSE
[13:23:28.373]                       if (inherits(cond, "message")) {
[13:23:28.373]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.373]                         if (muffled) 
[13:23:28.373]                           invokeRestart("muffleMessage")
[13:23:28.373]                       }
[13:23:28.373]                       else if (inherits(cond, "warning")) {
[13:23:28.373]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.373]                         if (muffled) 
[13:23:28.373]                           invokeRestart("muffleWarning")
[13:23:28.373]                       }
[13:23:28.373]                       else if (inherits(cond, "condition")) {
[13:23:28.373]                         if (!is.null(pattern)) {
[13:23:28.373]                           computeRestarts <- base::computeRestarts
[13:23:28.373]                           grepl <- base::grepl
[13:23:28.373]                           restarts <- computeRestarts(cond)
[13:23:28.373]                           for (restart in restarts) {
[13:23:28.373]                             name <- restart$name
[13:23:28.373]                             if (is.null(name)) 
[13:23:28.373]                               next
[13:23:28.373]                             if (!grepl(pattern, name)) 
[13:23:28.373]                               next
[13:23:28.373]                             invokeRestart(restart)
[13:23:28.373]                             muffled <- TRUE
[13:23:28.373]                             break
[13:23:28.373]                           }
[13:23:28.373]                         }
[13:23:28.373]                       }
[13:23:28.373]                       invisible(muffled)
[13:23:28.373]                     }
[13:23:28.373]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.373]                   }
[13:23:28.373]                 }
[13:23:28.373]             }
[13:23:28.373]         }))
[13:23:28.373]     }, error = function(ex) {
[13:23:28.373]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:28.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.373]                 ...future.rng), started = ...future.startTime, 
[13:23:28.373]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:28.373]             version = "1.8"), class = "FutureResult")
[13:23:28.373]     }, finally = {
[13:23:28.373]         if (!identical(...future.workdir, getwd())) 
[13:23:28.373]             setwd(...future.workdir)
[13:23:28.373]         {
[13:23:28.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:28.373]                 ...future.oldOptions$nwarnings <- NULL
[13:23:28.373]             }
[13:23:28.373]             base::options(...future.oldOptions)
[13:23:28.373]             if (.Platform$OS.type == "windows") {
[13:23:28.373]                 old_names <- names(...future.oldEnvVars)
[13:23:28.373]                 envs <- base::Sys.getenv()
[13:23:28.373]                 names <- names(envs)
[13:23:28.373]                 common <- intersect(names, old_names)
[13:23:28.373]                 added <- setdiff(names, old_names)
[13:23:28.373]                 removed <- setdiff(old_names, names)
[13:23:28.373]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:28.373]                   envs[common]]
[13:23:28.373]                 NAMES <- toupper(changed)
[13:23:28.373]                 args <- list()
[13:23:28.373]                 for (kk in seq_along(NAMES)) {
[13:23:28.373]                   name <- changed[[kk]]
[13:23:28.373]                   NAME <- NAMES[[kk]]
[13:23:28.373]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.373]                     next
[13:23:28.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.373]                 }
[13:23:28.373]                 NAMES <- toupper(added)
[13:23:28.373]                 for (kk in seq_along(NAMES)) {
[13:23:28.373]                   name <- added[[kk]]
[13:23:28.373]                   NAME <- NAMES[[kk]]
[13:23:28.373]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.373]                     next
[13:23:28.373]                   args[[name]] <- ""
[13:23:28.373]                 }
[13:23:28.373]                 NAMES <- toupper(removed)
[13:23:28.373]                 for (kk in seq_along(NAMES)) {
[13:23:28.373]                   name <- removed[[kk]]
[13:23:28.373]                   NAME <- NAMES[[kk]]
[13:23:28.373]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.373]                     next
[13:23:28.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.373]                 }
[13:23:28.373]                 if (length(args) > 0) 
[13:23:28.373]                   base::do.call(base::Sys.setenv, args = args)
[13:23:28.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:28.373]             }
[13:23:28.373]             else {
[13:23:28.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:28.373]             }
[13:23:28.373]             {
[13:23:28.373]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:28.373]                   0L) {
[13:23:28.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:28.373]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:28.373]                   base::options(opts)
[13:23:28.373]                 }
[13:23:28.373]                 {
[13:23:28.373]                   {
[13:23:28.373]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:28.373]                     NULL
[13:23:28.373]                   }
[13:23:28.373]                   options(future.plan = NULL)
[13:23:28.373]                   if (is.na(NA_character_)) 
[13:23:28.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:28.373]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:28.373]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:28.373]                     envir = parent.frame()) 
[13:23:28.373]                   {
[13:23:28.373]                     if (is.function(workers)) 
[13:23:28.373]                       workers <- workers()
[13:23:28.373]                     workers <- structure(as.integer(workers), 
[13:23:28.373]                       class = class(workers))
[13:23:28.373]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:28.373]                       workers >= 1)
[13:23:28.373]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:28.373]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:28.373]                     }
[13:23:28.373]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:28.373]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:28.373]                       envir = envir)
[13:23:28.373]                     if (!future$lazy) 
[13:23:28.373]                       future <- run(future)
[13:23:28.373]                     invisible(future)
[13:23:28.373]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:28.373]                 }
[13:23:28.373]             }
[13:23:28.373]         }
[13:23:28.373]     })
[13:23:28.373]     if (TRUE) {
[13:23:28.373]         base::sink(type = "output", split = FALSE)
[13:23:28.373]         if (TRUE) {
[13:23:28.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:28.373]         }
[13:23:28.373]         else {
[13:23:28.373]             ...future.result["stdout"] <- base::list(NULL)
[13:23:28.373]         }
[13:23:28.373]         base::close(...future.stdout)
[13:23:28.373]         ...future.stdout <- NULL
[13:23:28.373]     }
[13:23:28.373]     ...future.result$conditions <- ...future.conditions
[13:23:28.373]     ...future.result$finished <- base::Sys.time()
[13:23:28.373]     ...future.result
[13:23:28.373] }
[13:23:28.376] MultisessionFuture started
[13:23:28.376] - Launch lazy future ... done
[13:23:28.376] run() for ‘MultisessionFuture’ ... done
[13:23:28.377] result() for ClusterFuture ...
[13:23:28.377] receiveMessageFromWorker() for ClusterFuture ...
[13:23:28.377] - Validating connection of MultisessionFuture
[13:23:28.425] - received message: FutureResult
[13:23:28.425] - Received FutureResult
[13:23:28.425] - Erased future from FutureRegistry
[13:23:28.425] result() for ClusterFuture ...
[13:23:28.425] - result already collected: FutureResult
[13:23:28.426] result() for ClusterFuture ... done
[13:23:28.426] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.426] result() for ClusterFuture ... done
[13:23:28.426] result() for ClusterFuture ...
[13:23:28.426] - result already collected: FutureResult
[13:23:28.426] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:28.426] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:28.427] Searching for globals...
[13:23:28.429] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:28.429] Searching for globals ... DONE
[13:23:28.429] Resolving globals: TRUE
[13:23:28.429] Resolving any globals that are futures ...
[13:23:28.429] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:28.429] Resolving any globals that are futures ... DONE
[13:23:28.430] Resolving futures part of globals (recursively) ...
[13:23:28.430] resolve() on list ...
[13:23:28.430]  recursive: 99
[13:23:28.430]  length: 1
[13:23:28.430]  elements: ‘x’
[13:23:28.430]  length: 0 (resolved future 1)
[13:23:28.430] resolve() on list ... DONE
[13:23:28.430] - globals: [1] ‘x’
[13:23:28.431] Resolving futures part of globals (recursively) ... DONE
[13:23:28.431] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:28.431] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:28.431] - globals: [1] ‘x’
[13:23:28.431] 
[13:23:28.431] getGlobalsAndPackages() ... DONE
[13:23:28.432] run() for ‘Future’ ...
[13:23:28.432] - state: ‘created’
[13:23:28.432] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:28.446] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:28.446] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:28.446]   - Field: ‘node’
[13:23:28.446]   - Field: ‘label’
[13:23:28.446]   - Field: ‘local’
[13:23:28.446]   - Field: ‘owner’
[13:23:28.446]   - Field: ‘envir’
[13:23:28.446]   - Field: ‘workers’
[13:23:28.447]   - Field: ‘packages’
[13:23:28.447]   - Field: ‘gc’
[13:23:28.447]   - Field: ‘conditions’
[13:23:28.447]   - Field: ‘persistent’
[13:23:28.447]   - Field: ‘expr’
[13:23:28.447]   - Field: ‘uuid’
[13:23:28.447]   - Field: ‘seed’
[13:23:28.447]   - Field: ‘version’
[13:23:28.447]   - Field: ‘result’
[13:23:28.447]   - Field: ‘asynchronous’
[13:23:28.448]   - Field: ‘calls’
[13:23:28.448]   - Field: ‘globals’
[13:23:28.448]   - Field: ‘stdout’
[13:23:28.448]   - Field: ‘earlySignal’
[13:23:28.448]   - Field: ‘lazy’
[13:23:28.448]   - Field: ‘state’
[13:23:28.448] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:28.448] - Launch lazy future ...
[13:23:28.449] Packages needed by the future expression (n = 0): <none>
[13:23:28.449] Packages needed by future strategies (n = 0): <none>
[13:23:28.449] {
[13:23:28.449]     {
[13:23:28.449]         {
[13:23:28.449]             ...future.startTime <- base::Sys.time()
[13:23:28.449]             {
[13:23:28.449]                 {
[13:23:28.449]                   {
[13:23:28.449]                     {
[13:23:28.449]                       base::local({
[13:23:28.449]                         has_future <- base::requireNamespace("future", 
[13:23:28.449]                           quietly = TRUE)
[13:23:28.449]                         if (has_future) {
[13:23:28.449]                           ns <- base::getNamespace("future")
[13:23:28.449]                           version <- ns[[".package"]][["version"]]
[13:23:28.449]                           if (is.null(version)) 
[13:23:28.449]                             version <- utils::packageVersion("future")
[13:23:28.449]                         }
[13:23:28.449]                         else {
[13:23:28.449]                           version <- NULL
[13:23:28.449]                         }
[13:23:28.449]                         if (!has_future || version < "1.8.0") {
[13:23:28.449]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:28.449]                             "", base::R.version$version.string), 
[13:23:28.449]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:28.449]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:28.449]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:28.449]                               "release", "version")], collapse = " "), 
[13:23:28.449]                             hostname = base::Sys.info()[["nodename"]])
[13:23:28.449]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:28.449]                             info)
[13:23:28.449]                           info <- base::paste(info, collapse = "; ")
[13:23:28.449]                           if (!has_future) {
[13:23:28.449]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:28.449]                               info)
[13:23:28.449]                           }
[13:23:28.449]                           else {
[13:23:28.449]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:28.449]                               info, version)
[13:23:28.449]                           }
[13:23:28.449]                           base::stop(msg)
[13:23:28.449]                         }
[13:23:28.449]                       })
[13:23:28.449]                     }
[13:23:28.449]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:28.449]                     base::options(mc.cores = 1L)
[13:23:28.449]                   }
[13:23:28.449]                   options(future.plan = NULL)
[13:23:28.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:28.449]                 }
[13:23:28.449]                 ...future.workdir <- getwd()
[13:23:28.449]             }
[13:23:28.449]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:28.449]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:28.449]         }
[13:23:28.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:28.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:28.449]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:28.449]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:28.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:28.449]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:28.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:28.449]             base::names(...future.oldOptions))
[13:23:28.449]     }
[13:23:28.449]     if (FALSE) {
[13:23:28.449]     }
[13:23:28.449]     else {
[13:23:28.449]         if (TRUE) {
[13:23:28.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:28.449]                 open = "w")
[13:23:28.449]         }
[13:23:28.449]         else {
[13:23:28.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:28.449]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:28.449]         }
[13:23:28.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:28.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:28.449]             base::sink(type = "output", split = FALSE)
[13:23:28.449]             base::close(...future.stdout)
[13:23:28.449]         }, add = TRUE)
[13:23:28.449]     }
[13:23:28.449]     ...future.frame <- base::sys.nframe()
[13:23:28.449]     ...future.conditions <- base::list()
[13:23:28.449]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:28.449]     if (FALSE) {
[13:23:28.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:28.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:28.449]     }
[13:23:28.449]     ...future.result <- base::tryCatch({
[13:23:28.449]         base::withCallingHandlers({
[13:23:28.449]             ...future.value <- base::withVisible(base::local({
[13:23:28.449]                 ...future.makeSendCondition <- base::local({
[13:23:28.449]                   sendCondition <- NULL
[13:23:28.449]                   function(frame = 1L) {
[13:23:28.449]                     if (is.function(sendCondition)) 
[13:23:28.449]                       return(sendCondition)
[13:23:28.449]                     ns <- getNamespace("parallel")
[13:23:28.449]                     if (exists("sendData", mode = "function", 
[13:23:28.449]                       envir = ns)) {
[13:23:28.449]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:28.449]                         envir = ns)
[13:23:28.449]                       envir <- sys.frame(frame)
[13:23:28.449]                       master <- NULL
[13:23:28.449]                       while (!identical(envir, .GlobalEnv) && 
[13:23:28.449]                         !identical(envir, emptyenv())) {
[13:23:28.449]                         if (exists("master", mode = "list", envir = envir, 
[13:23:28.449]                           inherits = FALSE)) {
[13:23:28.449]                           master <- get("master", mode = "list", 
[13:23:28.449]                             envir = envir, inherits = FALSE)
[13:23:28.449]                           if (inherits(master, c("SOCKnode", 
[13:23:28.449]                             "SOCK0node"))) {
[13:23:28.449]                             sendCondition <<- function(cond) {
[13:23:28.449]                               data <- list(type = "VALUE", value = cond, 
[13:23:28.449]                                 success = TRUE)
[13:23:28.449]                               parallel_sendData(master, data)
[13:23:28.449]                             }
[13:23:28.449]                             return(sendCondition)
[13:23:28.449]                           }
[13:23:28.449]                         }
[13:23:28.449]                         frame <- frame + 1L
[13:23:28.449]                         envir <- sys.frame(frame)
[13:23:28.449]                       }
[13:23:28.449]                     }
[13:23:28.449]                     sendCondition <<- function(cond) NULL
[13:23:28.449]                   }
[13:23:28.449]                 })
[13:23:28.449]                 withCallingHandlers({
[13:23:28.449]                   {
[13:23:28.449]                     x[["a"]] <- 1
[13:23:28.449]                     x
[13:23:28.449]                   }
[13:23:28.449]                 }, immediateCondition = function(cond) {
[13:23:28.449]                   sendCondition <- ...future.makeSendCondition()
[13:23:28.449]                   sendCondition(cond)
[13:23:28.449]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.449]                   {
[13:23:28.449]                     inherits <- base::inherits
[13:23:28.449]                     invokeRestart <- base::invokeRestart
[13:23:28.449]                     is.null <- base::is.null
[13:23:28.449]                     muffled <- FALSE
[13:23:28.449]                     if (inherits(cond, "message")) {
[13:23:28.449]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:28.449]                       if (muffled) 
[13:23:28.449]                         invokeRestart("muffleMessage")
[13:23:28.449]                     }
[13:23:28.449]                     else if (inherits(cond, "warning")) {
[13:23:28.449]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:28.449]                       if (muffled) 
[13:23:28.449]                         invokeRestart("muffleWarning")
[13:23:28.449]                     }
[13:23:28.449]                     else if (inherits(cond, "condition")) {
[13:23:28.449]                       if (!is.null(pattern)) {
[13:23:28.449]                         computeRestarts <- base::computeRestarts
[13:23:28.449]                         grepl <- base::grepl
[13:23:28.449]                         restarts <- computeRestarts(cond)
[13:23:28.449]                         for (restart in restarts) {
[13:23:28.449]                           name <- restart$name
[13:23:28.449]                           if (is.null(name)) 
[13:23:28.449]                             next
[13:23:28.449]                           if (!grepl(pattern, name)) 
[13:23:28.449]                             next
[13:23:28.449]                           invokeRestart(restart)
[13:23:28.449]                           muffled <- TRUE
[13:23:28.449]                           break
[13:23:28.449]                         }
[13:23:28.449]                       }
[13:23:28.449]                     }
[13:23:28.449]                     invisible(muffled)
[13:23:28.449]                   }
[13:23:28.449]                   muffleCondition(cond)
[13:23:28.449]                 })
[13:23:28.449]             }))
[13:23:28.449]             future::FutureResult(value = ...future.value$value, 
[13:23:28.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.449]                   ...future.rng), globalenv = if (FALSE) 
[13:23:28.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:28.449]                     ...future.globalenv.names))
[13:23:28.449]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:28.449]         }, condition = base::local({
[13:23:28.449]             c <- base::c
[13:23:28.449]             inherits <- base::inherits
[13:23:28.449]             invokeRestart <- base::invokeRestart
[13:23:28.449]             length <- base::length
[13:23:28.449]             list <- base::list
[13:23:28.449]             seq.int <- base::seq.int
[13:23:28.449]             signalCondition <- base::signalCondition
[13:23:28.449]             sys.calls <- base::sys.calls
[13:23:28.449]             `[[` <- base::`[[`
[13:23:28.449]             `+` <- base::`+`
[13:23:28.449]             `<<-` <- base::`<<-`
[13:23:28.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:28.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:28.449]                   3L)]
[13:23:28.449]             }
[13:23:28.449]             function(cond) {
[13:23:28.449]                 is_error <- inherits(cond, "error")
[13:23:28.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:28.449]                   NULL)
[13:23:28.449]                 if (is_error) {
[13:23:28.449]                   sessionInformation <- function() {
[13:23:28.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:28.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:28.449]                       search = base::search(), system = base::Sys.info())
[13:23:28.449]                   }
[13:23:28.449]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:28.449]                     cond$call), session = sessionInformation(), 
[13:23:28.449]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:28.449]                   signalCondition(cond)
[13:23:28.449]                 }
[13:23:28.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:28.449]                 "immediateCondition"))) {
[13:23:28.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:28.449]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:28.449]                   if (TRUE && !signal) {
[13:23:28.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.449]                     {
[13:23:28.449]                       inherits <- base::inherits
[13:23:28.449]                       invokeRestart <- base::invokeRestart
[13:23:28.449]                       is.null <- base::is.null
[13:23:28.449]                       muffled <- FALSE
[13:23:28.449]                       if (inherits(cond, "message")) {
[13:23:28.449]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.449]                         if (muffled) 
[13:23:28.449]                           invokeRestart("muffleMessage")
[13:23:28.449]                       }
[13:23:28.449]                       else if (inherits(cond, "warning")) {
[13:23:28.449]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.449]                         if (muffled) 
[13:23:28.449]                           invokeRestart("muffleWarning")
[13:23:28.449]                       }
[13:23:28.449]                       else if (inherits(cond, "condition")) {
[13:23:28.449]                         if (!is.null(pattern)) {
[13:23:28.449]                           computeRestarts <- base::computeRestarts
[13:23:28.449]                           grepl <- base::grepl
[13:23:28.449]                           restarts <- computeRestarts(cond)
[13:23:28.449]                           for (restart in restarts) {
[13:23:28.449]                             name <- restart$name
[13:23:28.449]                             if (is.null(name)) 
[13:23:28.449]                               next
[13:23:28.449]                             if (!grepl(pattern, name)) 
[13:23:28.449]                               next
[13:23:28.449]                             invokeRestart(restart)
[13:23:28.449]                             muffled <- TRUE
[13:23:28.449]                             break
[13:23:28.449]                           }
[13:23:28.449]                         }
[13:23:28.449]                       }
[13:23:28.449]                       invisible(muffled)
[13:23:28.449]                     }
[13:23:28.449]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.449]                   }
[13:23:28.449]                 }
[13:23:28.449]                 else {
[13:23:28.449]                   if (TRUE) {
[13:23:28.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.449]                     {
[13:23:28.449]                       inherits <- base::inherits
[13:23:28.449]                       invokeRestart <- base::invokeRestart
[13:23:28.449]                       is.null <- base::is.null
[13:23:28.449]                       muffled <- FALSE
[13:23:28.449]                       if (inherits(cond, "message")) {
[13:23:28.449]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.449]                         if (muffled) 
[13:23:28.449]                           invokeRestart("muffleMessage")
[13:23:28.449]                       }
[13:23:28.449]                       else if (inherits(cond, "warning")) {
[13:23:28.449]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.449]                         if (muffled) 
[13:23:28.449]                           invokeRestart("muffleWarning")
[13:23:28.449]                       }
[13:23:28.449]                       else if (inherits(cond, "condition")) {
[13:23:28.449]                         if (!is.null(pattern)) {
[13:23:28.449]                           computeRestarts <- base::computeRestarts
[13:23:28.449]                           grepl <- base::grepl
[13:23:28.449]                           restarts <- computeRestarts(cond)
[13:23:28.449]                           for (restart in restarts) {
[13:23:28.449]                             name <- restart$name
[13:23:28.449]                             if (is.null(name)) 
[13:23:28.449]                               next
[13:23:28.449]                             if (!grepl(pattern, name)) 
[13:23:28.449]                               next
[13:23:28.449]                             invokeRestart(restart)
[13:23:28.449]                             muffled <- TRUE
[13:23:28.449]                             break
[13:23:28.449]                           }
[13:23:28.449]                         }
[13:23:28.449]                       }
[13:23:28.449]                       invisible(muffled)
[13:23:28.449]                     }
[13:23:28.449]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.449]                   }
[13:23:28.449]                 }
[13:23:28.449]             }
[13:23:28.449]         }))
[13:23:28.449]     }, error = function(ex) {
[13:23:28.449]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:28.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.449]                 ...future.rng), started = ...future.startTime, 
[13:23:28.449]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:28.449]             version = "1.8"), class = "FutureResult")
[13:23:28.449]     }, finally = {
[13:23:28.449]         if (!identical(...future.workdir, getwd())) 
[13:23:28.449]             setwd(...future.workdir)
[13:23:28.449]         {
[13:23:28.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:28.449]                 ...future.oldOptions$nwarnings <- NULL
[13:23:28.449]             }
[13:23:28.449]             base::options(...future.oldOptions)
[13:23:28.449]             if (.Platform$OS.type == "windows") {
[13:23:28.449]                 old_names <- names(...future.oldEnvVars)
[13:23:28.449]                 envs <- base::Sys.getenv()
[13:23:28.449]                 names <- names(envs)
[13:23:28.449]                 common <- intersect(names, old_names)
[13:23:28.449]                 added <- setdiff(names, old_names)
[13:23:28.449]                 removed <- setdiff(old_names, names)
[13:23:28.449]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:28.449]                   envs[common]]
[13:23:28.449]                 NAMES <- toupper(changed)
[13:23:28.449]                 args <- list()
[13:23:28.449]                 for (kk in seq_along(NAMES)) {
[13:23:28.449]                   name <- changed[[kk]]
[13:23:28.449]                   NAME <- NAMES[[kk]]
[13:23:28.449]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.449]                     next
[13:23:28.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.449]                 }
[13:23:28.449]                 NAMES <- toupper(added)
[13:23:28.449]                 for (kk in seq_along(NAMES)) {
[13:23:28.449]                   name <- added[[kk]]
[13:23:28.449]                   NAME <- NAMES[[kk]]
[13:23:28.449]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.449]                     next
[13:23:28.449]                   args[[name]] <- ""
[13:23:28.449]                 }
[13:23:28.449]                 NAMES <- toupper(removed)
[13:23:28.449]                 for (kk in seq_along(NAMES)) {
[13:23:28.449]                   name <- removed[[kk]]
[13:23:28.449]                   NAME <- NAMES[[kk]]
[13:23:28.449]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.449]                     next
[13:23:28.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.449]                 }
[13:23:28.449]                 if (length(args) > 0) 
[13:23:28.449]                   base::do.call(base::Sys.setenv, args = args)
[13:23:28.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:28.449]             }
[13:23:28.449]             else {
[13:23:28.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:28.449]             }
[13:23:28.449]             {
[13:23:28.449]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:28.449]                   0L) {
[13:23:28.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:28.449]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:28.449]                   base::options(opts)
[13:23:28.449]                 }
[13:23:28.449]                 {
[13:23:28.449]                   {
[13:23:28.449]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:28.449]                     NULL
[13:23:28.449]                   }
[13:23:28.449]                   options(future.plan = NULL)
[13:23:28.449]                   if (is.na(NA_character_)) 
[13:23:28.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:28.449]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:28.449]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:28.449]                     envir = parent.frame()) 
[13:23:28.449]                   {
[13:23:28.449]                     if (is.function(workers)) 
[13:23:28.449]                       workers <- workers()
[13:23:28.449]                     workers <- structure(as.integer(workers), 
[13:23:28.449]                       class = class(workers))
[13:23:28.449]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:28.449]                       workers >= 1)
[13:23:28.449]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:28.449]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:28.449]                     }
[13:23:28.449]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:28.449]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:28.449]                       envir = envir)
[13:23:28.449]                     if (!future$lazy) 
[13:23:28.449]                       future <- run(future)
[13:23:28.449]                     invisible(future)
[13:23:28.449]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:28.449]                 }
[13:23:28.449]             }
[13:23:28.449]         }
[13:23:28.449]     })
[13:23:28.449]     if (TRUE) {
[13:23:28.449]         base::sink(type = "output", split = FALSE)
[13:23:28.449]         if (TRUE) {
[13:23:28.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:28.449]         }
[13:23:28.449]         else {
[13:23:28.449]             ...future.result["stdout"] <- base::list(NULL)
[13:23:28.449]         }
[13:23:28.449]         base::close(...future.stdout)
[13:23:28.449]         ...future.stdout <- NULL
[13:23:28.449]     }
[13:23:28.449]     ...future.result$conditions <- ...future.conditions
[13:23:28.449]     ...future.result$finished <- base::Sys.time()
[13:23:28.449]     ...future.result
[13:23:28.449] }
[13:23:28.452] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:23:28.452] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:23:28.453] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:23:28.453] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:23:28.453] MultisessionFuture started
[13:23:28.454] - Launch lazy future ... done
[13:23:28.454] run() for ‘MultisessionFuture’ ... done
[13:23:28.454] result() for ClusterFuture ...
[13:23:28.454] receiveMessageFromWorker() for ClusterFuture ...
[13:23:28.454] - Validating connection of MultisessionFuture
[13:23:28.501] - received message: FutureResult
[13:23:28.501] - Received FutureResult
[13:23:28.501] - Erased future from FutureRegistry
[13:23:28.502] result() for ClusterFuture ...
[13:23:28.502] - result already collected: FutureResult
[13:23:28.502] result() for ClusterFuture ... done
[13:23:28.502] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.502] result() for ClusterFuture ... done
[13:23:28.502] result() for ClusterFuture ...
[13:23:28.502] - result already collected: FutureResult
[13:23:28.502] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:28.503] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:28.503] Searching for globals...
[13:23:28.505] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:28.505] Searching for globals ... DONE
[13:23:28.505] Resolving globals: TRUE
[13:23:28.505] Resolving any globals that are futures ...
[13:23:28.505] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:28.505] Resolving any globals that are futures ... DONE
[13:23:28.506] Resolving futures part of globals (recursively) ...
[13:23:28.506] resolve() on list ...
[13:23:28.506]  recursive: 99
[13:23:28.506]  length: 1
[13:23:28.506]  elements: ‘x’
[13:23:28.506]  length: 0 (resolved future 1)
[13:23:28.507] resolve() on list ... DONE
[13:23:28.507] - globals: [1] ‘x’
[13:23:28.507] Resolving futures part of globals (recursively) ... DONE
[13:23:28.507] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:28.507] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:28.507] - globals: [1] ‘x’
[13:23:28.507] 
[13:23:28.508] getGlobalsAndPackages() ... DONE
[13:23:28.508] run() for ‘Future’ ...
[13:23:28.508] - state: ‘created’
[13:23:28.508] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:28.522] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:28.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:28.522]   - Field: ‘node’
[13:23:28.522]   - Field: ‘label’
[13:23:28.523]   - Field: ‘local’
[13:23:28.523]   - Field: ‘owner’
[13:23:28.523]   - Field: ‘envir’
[13:23:28.523]   - Field: ‘workers’
[13:23:28.523]   - Field: ‘packages’
[13:23:28.523]   - Field: ‘gc’
[13:23:28.523]   - Field: ‘conditions’
[13:23:28.523]   - Field: ‘persistent’
[13:23:28.523]   - Field: ‘expr’
[13:23:28.523]   - Field: ‘uuid’
[13:23:28.524]   - Field: ‘seed’
[13:23:28.524]   - Field: ‘version’
[13:23:28.524]   - Field: ‘result’
[13:23:28.524]   - Field: ‘asynchronous’
[13:23:28.524]   - Field: ‘calls’
[13:23:28.524]   - Field: ‘globals’
[13:23:28.524]   - Field: ‘stdout’
[13:23:28.524]   - Field: ‘earlySignal’
[13:23:28.524]   - Field: ‘lazy’
[13:23:28.524]   - Field: ‘state’
[13:23:28.525] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:28.525] - Launch lazy future ...
[13:23:28.525] Packages needed by the future expression (n = 0): <none>
[13:23:28.525] Packages needed by future strategies (n = 0): <none>
[13:23:28.526] {
[13:23:28.526]     {
[13:23:28.526]         {
[13:23:28.526]             ...future.startTime <- base::Sys.time()
[13:23:28.526]             {
[13:23:28.526]                 {
[13:23:28.526]                   {
[13:23:28.526]                     {
[13:23:28.526]                       base::local({
[13:23:28.526]                         has_future <- base::requireNamespace("future", 
[13:23:28.526]                           quietly = TRUE)
[13:23:28.526]                         if (has_future) {
[13:23:28.526]                           ns <- base::getNamespace("future")
[13:23:28.526]                           version <- ns[[".package"]][["version"]]
[13:23:28.526]                           if (is.null(version)) 
[13:23:28.526]                             version <- utils::packageVersion("future")
[13:23:28.526]                         }
[13:23:28.526]                         else {
[13:23:28.526]                           version <- NULL
[13:23:28.526]                         }
[13:23:28.526]                         if (!has_future || version < "1.8.0") {
[13:23:28.526]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:28.526]                             "", base::R.version$version.string), 
[13:23:28.526]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:28.526]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:28.526]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:28.526]                               "release", "version")], collapse = " "), 
[13:23:28.526]                             hostname = base::Sys.info()[["nodename"]])
[13:23:28.526]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:28.526]                             info)
[13:23:28.526]                           info <- base::paste(info, collapse = "; ")
[13:23:28.526]                           if (!has_future) {
[13:23:28.526]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:28.526]                               info)
[13:23:28.526]                           }
[13:23:28.526]                           else {
[13:23:28.526]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:28.526]                               info, version)
[13:23:28.526]                           }
[13:23:28.526]                           base::stop(msg)
[13:23:28.526]                         }
[13:23:28.526]                       })
[13:23:28.526]                     }
[13:23:28.526]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:28.526]                     base::options(mc.cores = 1L)
[13:23:28.526]                   }
[13:23:28.526]                   options(future.plan = NULL)
[13:23:28.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:28.526]                 }
[13:23:28.526]                 ...future.workdir <- getwd()
[13:23:28.526]             }
[13:23:28.526]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:28.526]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:28.526]         }
[13:23:28.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:28.526]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:28.526]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:28.526]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:28.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:28.526]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:28.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:28.526]             base::names(...future.oldOptions))
[13:23:28.526]     }
[13:23:28.526]     if (FALSE) {
[13:23:28.526]     }
[13:23:28.526]     else {
[13:23:28.526]         if (TRUE) {
[13:23:28.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:28.526]                 open = "w")
[13:23:28.526]         }
[13:23:28.526]         else {
[13:23:28.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:28.526]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:28.526]         }
[13:23:28.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:28.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:28.526]             base::sink(type = "output", split = FALSE)
[13:23:28.526]             base::close(...future.stdout)
[13:23:28.526]         }, add = TRUE)
[13:23:28.526]     }
[13:23:28.526]     ...future.frame <- base::sys.nframe()
[13:23:28.526]     ...future.conditions <- base::list()
[13:23:28.526]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:28.526]     if (FALSE) {
[13:23:28.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:28.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:28.526]     }
[13:23:28.526]     ...future.result <- base::tryCatch({
[13:23:28.526]         base::withCallingHandlers({
[13:23:28.526]             ...future.value <- base::withVisible(base::local({
[13:23:28.526]                 ...future.makeSendCondition <- base::local({
[13:23:28.526]                   sendCondition <- NULL
[13:23:28.526]                   function(frame = 1L) {
[13:23:28.526]                     if (is.function(sendCondition)) 
[13:23:28.526]                       return(sendCondition)
[13:23:28.526]                     ns <- getNamespace("parallel")
[13:23:28.526]                     if (exists("sendData", mode = "function", 
[13:23:28.526]                       envir = ns)) {
[13:23:28.526]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:28.526]                         envir = ns)
[13:23:28.526]                       envir <- sys.frame(frame)
[13:23:28.526]                       master <- NULL
[13:23:28.526]                       while (!identical(envir, .GlobalEnv) && 
[13:23:28.526]                         !identical(envir, emptyenv())) {
[13:23:28.526]                         if (exists("master", mode = "list", envir = envir, 
[13:23:28.526]                           inherits = FALSE)) {
[13:23:28.526]                           master <- get("master", mode = "list", 
[13:23:28.526]                             envir = envir, inherits = FALSE)
[13:23:28.526]                           if (inherits(master, c("SOCKnode", 
[13:23:28.526]                             "SOCK0node"))) {
[13:23:28.526]                             sendCondition <<- function(cond) {
[13:23:28.526]                               data <- list(type = "VALUE", value = cond, 
[13:23:28.526]                                 success = TRUE)
[13:23:28.526]                               parallel_sendData(master, data)
[13:23:28.526]                             }
[13:23:28.526]                             return(sendCondition)
[13:23:28.526]                           }
[13:23:28.526]                         }
[13:23:28.526]                         frame <- frame + 1L
[13:23:28.526]                         envir <- sys.frame(frame)
[13:23:28.526]                       }
[13:23:28.526]                     }
[13:23:28.526]                     sendCondition <<- function(cond) NULL
[13:23:28.526]                   }
[13:23:28.526]                 })
[13:23:28.526]                 withCallingHandlers({
[13:23:28.526]                   {
[13:23:28.526]                     x[["a"]] <- 1
[13:23:28.526]                     x
[13:23:28.526]                   }
[13:23:28.526]                 }, immediateCondition = function(cond) {
[13:23:28.526]                   sendCondition <- ...future.makeSendCondition()
[13:23:28.526]                   sendCondition(cond)
[13:23:28.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.526]                   {
[13:23:28.526]                     inherits <- base::inherits
[13:23:28.526]                     invokeRestart <- base::invokeRestart
[13:23:28.526]                     is.null <- base::is.null
[13:23:28.526]                     muffled <- FALSE
[13:23:28.526]                     if (inherits(cond, "message")) {
[13:23:28.526]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:28.526]                       if (muffled) 
[13:23:28.526]                         invokeRestart("muffleMessage")
[13:23:28.526]                     }
[13:23:28.526]                     else if (inherits(cond, "warning")) {
[13:23:28.526]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:28.526]                       if (muffled) 
[13:23:28.526]                         invokeRestart("muffleWarning")
[13:23:28.526]                     }
[13:23:28.526]                     else if (inherits(cond, "condition")) {
[13:23:28.526]                       if (!is.null(pattern)) {
[13:23:28.526]                         computeRestarts <- base::computeRestarts
[13:23:28.526]                         grepl <- base::grepl
[13:23:28.526]                         restarts <- computeRestarts(cond)
[13:23:28.526]                         for (restart in restarts) {
[13:23:28.526]                           name <- restart$name
[13:23:28.526]                           if (is.null(name)) 
[13:23:28.526]                             next
[13:23:28.526]                           if (!grepl(pattern, name)) 
[13:23:28.526]                             next
[13:23:28.526]                           invokeRestart(restart)
[13:23:28.526]                           muffled <- TRUE
[13:23:28.526]                           break
[13:23:28.526]                         }
[13:23:28.526]                       }
[13:23:28.526]                     }
[13:23:28.526]                     invisible(muffled)
[13:23:28.526]                   }
[13:23:28.526]                   muffleCondition(cond)
[13:23:28.526]                 })
[13:23:28.526]             }))
[13:23:28.526]             future::FutureResult(value = ...future.value$value, 
[13:23:28.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.526]                   ...future.rng), globalenv = if (FALSE) 
[13:23:28.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:28.526]                     ...future.globalenv.names))
[13:23:28.526]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:28.526]         }, condition = base::local({
[13:23:28.526]             c <- base::c
[13:23:28.526]             inherits <- base::inherits
[13:23:28.526]             invokeRestart <- base::invokeRestart
[13:23:28.526]             length <- base::length
[13:23:28.526]             list <- base::list
[13:23:28.526]             seq.int <- base::seq.int
[13:23:28.526]             signalCondition <- base::signalCondition
[13:23:28.526]             sys.calls <- base::sys.calls
[13:23:28.526]             `[[` <- base::`[[`
[13:23:28.526]             `+` <- base::`+`
[13:23:28.526]             `<<-` <- base::`<<-`
[13:23:28.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:28.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:28.526]                   3L)]
[13:23:28.526]             }
[13:23:28.526]             function(cond) {
[13:23:28.526]                 is_error <- inherits(cond, "error")
[13:23:28.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:28.526]                   NULL)
[13:23:28.526]                 if (is_error) {
[13:23:28.526]                   sessionInformation <- function() {
[13:23:28.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:28.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:28.526]                       search = base::search(), system = base::Sys.info())
[13:23:28.526]                   }
[13:23:28.526]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:28.526]                     cond$call), session = sessionInformation(), 
[13:23:28.526]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:28.526]                   signalCondition(cond)
[13:23:28.526]                 }
[13:23:28.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:28.526]                 "immediateCondition"))) {
[13:23:28.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:28.526]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:28.526]                   if (TRUE && !signal) {
[13:23:28.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.526]                     {
[13:23:28.526]                       inherits <- base::inherits
[13:23:28.526]                       invokeRestart <- base::invokeRestart
[13:23:28.526]                       is.null <- base::is.null
[13:23:28.526]                       muffled <- FALSE
[13:23:28.526]                       if (inherits(cond, "message")) {
[13:23:28.526]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.526]                         if (muffled) 
[13:23:28.526]                           invokeRestart("muffleMessage")
[13:23:28.526]                       }
[13:23:28.526]                       else if (inherits(cond, "warning")) {
[13:23:28.526]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.526]                         if (muffled) 
[13:23:28.526]                           invokeRestart("muffleWarning")
[13:23:28.526]                       }
[13:23:28.526]                       else if (inherits(cond, "condition")) {
[13:23:28.526]                         if (!is.null(pattern)) {
[13:23:28.526]                           computeRestarts <- base::computeRestarts
[13:23:28.526]                           grepl <- base::grepl
[13:23:28.526]                           restarts <- computeRestarts(cond)
[13:23:28.526]                           for (restart in restarts) {
[13:23:28.526]                             name <- restart$name
[13:23:28.526]                             if (is.null(name)) 
[13:23:28.526]                               next
[13:23:28.526]                             if (!grepl(pattern, name)) 
[13:23:28.526]                               next
[13:23:28.526]                             invokeRestart(restart)
[13:23:28.526]                             muffled <- TRUE
[13:23:28.526]                             break
[13:23:28.526]                           }
[13:23:28.526]                         }
[13:23:28.526]                       }
[13:23:28.526]                       invisible(muffled)
[13:23:28.526]                     }
[13:23:28.526]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.526]                   }
[13:23:28.526]                 }
[13:23:28.526]                 else {
[13:23:28.526]                   if (TRUE) {
[13:23:28.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.526]                     {
[13:23:28.526]                       inherits <- base::inherits
[13:23:28.526]                       invokeRestart <- base::invokeRestart
[13:23:28.526]                       is.null <- base::is.null
[13:23:28.526]                       muffled <- FALSE
[13:23:28.526]                       if (inherits(cond, "message")) {
[13:23:28.526]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.526]                         if (muffled) 
[13:23:28.526]                           invokeRestart("muffleMessage")
[13:23:28.526]                       }
[13:23:28.526]                       else if (inherits(cond, "warning")) {
[13:23:28.526]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.526]                         if (muffled) 
[13:23:28.526]                           invokeRestart("muffleWarning")
[13:23:28.526]                       }
[13:23:28.526]                       else if (inherits(cond, "condition")) {
[13:23:28.526]                         if (!is.null(pattern)) {
[13:23:28.526]                           computeRestarts <- base::computeRestarts
[13:23:28.526]                           grepl <- base::grepl
[13:23:28.526]                           restarts <- computeRestarts(cond)
[13:23:28.526]                           for (restart in restarts) {
[13:23:28.526]                             name <- restart$name
[13:23:28.526]                             if (is.null(name)) 
[13:23:28.526]                               next
[13:23:28.526]                             if (!grepl(pattern, name)) 
[13:23:28.526]                               next
[13:23:28.526]                             invokeRestart(restart)
[13:23:28.526]                             muffled <- TRUE
[13:23:28.526]                             break
[13:23:28.526]                           }
[13:23:28.526]                         }
[13:23:28.526]                       }
[13:23:28.526]                       invisible(muffled)
[13:23:28.526]                     }
[13:23:28.526]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.526]                   }
[13:23:28.526]                 }
[13:23:28.526]             }
[13:23:28.526]         }))
[13:23:28.526]     }, error = function(ex) {
[13:23:28.526]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:28.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.526]                 ...future.rng), started = ...future.startTime, 
[13:23:28.526]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:28.526]             version = "1.8"), class = "FutureResult")
[13:23:28.526]     }, finally = {
[13:23:28.526]         if (!identical(...future.workdir, getwd())) 
[13:23:28.526]             setwd(...future.workdir)
[13:23:28.526]         {
[13:23:28.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:28.526]                 ...future.oldOptions$nwarnings <- NULL
[13:23:28.526]             }
[13:23:28.526]             base::options(...future.oldOptions)
[13:23:28.526]             if (.Platform$OS.type == "windows") {
[13:23:28.526]                 old_names <- names(...future.oldEnvVars)
[13:23:28.526]                 envs <- base::Sys.getenv()
[13:23:28.526]                 names <- names(envs)
[13:23:28.526]                 common <- intersect(names, old_names)
[13:23:28.526]                 added <- setdiff(names, old_names)
[13:23:28.526]                 removed <- setdiff(old_names, names)
[13:23:28.526]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:28.526]                   envs[common]]
[13:23:28.526]                 NAMES <- toupper(changed)
[13:23:28.526]                 args <- list()
[13:23:28.526]                 for (kk in seq_along(NAMES)) {
[13:23:28.526]                   name <- changed[[kk]]
[13:23:28.526]                   NAME <- NAMES[[kk]]
[13:23:28.526]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.526]                     next
[13:23:28.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.526]                 }
[13:23:28.526]                 NAMES <- toupper(added)
[13:23:28.526]                 for (kk in seq_along(NAMES)) {
[13:23:28.526]                   name <- added[[kk]]
[13:23:28.526]                   NAME <- NAMES[[kk]]
[13:23:28.526]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.526]                     next
[13:23:28.526]                   args[[name]] <- ""
[13:23:28.526]                 }
[13:23:28.526]                 NAMES <- toupper(removed)
[13:23:28.526]                 for (kk in seq_along(NAMES)) {
[13:23:28.526]                   name <- removed[[kk]]
[13:23:28.526]                   NAME <- NAMES[[kk]]
[13:23:28.526]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.526]                     next
[13:23:28.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.526]                 }
[13:23:28.526]                 if (length(args) > 0) 
[13:23:28.526]                   base::do.call(base::Sys.setenv, args = args)
[13:23:28.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:28.526]             }
[13:23:28.526]             else {
[13:23:28.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:28.526]             }
[13:23:28.526]             {
[13:23:28.526]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:28.526]                   0L) {
[13:23:28.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:28.526]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:28.526]                   base::options(opts)
[13:23:28.526]                 }
[13:23:28.526]                 {
[13:23:28.526]                   {
[13:23:28.526]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:28.526]                     NULL
[13:23:28.526]                   }
[13:23:28.526]                   options(future.plan = NULL)
[13:23:28.526]                   if (is.na(NA_character_)) 
[13:23:28.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:28.526]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:28.526]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:28.526]                     envir = parent.frame()) 
[13:23:28.526]                   {
[13:23:28.526]                     if (is.function(workers)) 
[13:23:28.526]                       workers <- workers()
[13:23:28.526]                     workers <- structure(as.integer(workers), 
[13:23:28.526]                       class = class(workers))
[13:23:28.526]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:28.526]                       workers >= 1)
[13:23:28.526]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:28.526]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:28.526]                     }
[13:23:28.526]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:28.526]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:28.526]                       envir = envir)
[13:23:28.526]                     if (!future$lazy) 
[13:23:28.526]                       future <- run(future)
[13:23:28.526]                     invisible(future)
[13:23:28.526]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:28.526]                 }
[13:23:28.526]             }
[13:23:28.526]         }
[13:23:28.526]     })
[13:23:28.526]     if (TRUE) {
[13:23:28.526]         base::sink(type = "output", split = FALSE)
[13:23:28.526]         if (TRUE) {
[13:23:28.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:28.526]         }
[13:23:28.526]         else {
[13:23:28.526]             ...future.result["stdout"] <- base::list(NULL)
[13:23:28.526]         }
[13:23:28.526]         base::close(...future.stdout)
[13:23:28.526]         ...future.stdout <- NULL
[13:23:28.526]     }
[13:23:28.526]     ...future.result$conditions <- ...future.conditions
[13:23:28.526]     ...future.result$finished <- base::Sys.time()
[13:23:28.526]     ...future.result
[13:23:28.526] }
[13:23:28.528] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:23:28.529] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:23:28.529] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:23:28.529] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:23:28.529] MultisessionFuture started
[13:23:28.530] - Launch lazy future ... done
[13:23:28.530] run() for ‘MultisessionFuture’ ... done
[13:23:28.530] result() for ClusterFuture ...
[13:23:28.530] receiveMessageFromWorker() for ClusterFuture ...
[13:23:28.530] - Validating connection of MultisessionFuture
[13:23:28.577] - received message: FutureResult
[13:23:28.577] - Received FutureResult
[13:23:28.578] - Erased future from FutureRegistry
[13:23:28.578] result() for ClusterFuture ...
[13:23:28.578] - result already collected: FutureResult
[13:23:28.578] result() for ClusterFuture ... done
[13:23:28.578] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.578] result() for ClusterFuture ... done
[13:23:28.578] result() for ClusterFuture ...
[13:23:28.578] - result already collected: FutureResult
[13:23:28.578] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:28.579] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:28.579] Searching for globals...
[13:23:28.582] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:28.582] Searching for globals ... DONE
[13:23:28.582] Resolving globals: TRUE
[13:23:28.582] Resolving any globals that are futures ...
[13:23:28.582] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:23:28.582] Resolving any globals that are futures ... DONE
[13:23:28.583] Resolving futures part of globals (recursively) ...
[13:23:28.583] resolve() on list ...
[13:23:28.583]  recursive: 99
[13:23:28.585]  length: 1
[13:23:28.586]  elements: ‘x’
[13:23:28.586]  length: 0 (resolved future 1)
[13:23:28.586] resolve() on list ... DONE
[13:23:28.586] - globals: [1] ‘x’
[13:23:28.586] Resolving futures part of globals (recursively) ... DONE
[13:23:28.586] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:28.586] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:28.587] - globals: [1] ‘x’
[13:23:28.587] 
[13:23:28.587] getGlobalsAndPackages() ... DONE
[13:23:28.587] run() for ‘Future’ ...
[13:23:28.587] - state: ‘created’
[13:23:28.587] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:28.603] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:28.603] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:28.603]   - Field: ‘node’
[13:23:28.604]   - Field: ‘label’
[13:23:28.604]   - Field: ‘local’
[13:23:28.604]   - Field: ‘owner’
[13:23:28.604]   - Field: ‘envir’
[13:23:28.604]   - Field: ‘workers’
[13:23:28.604]   - Field: ‘packages’
[13:23:28.604]   - Field: ‘gc’
[13:23:28.604]   - Field: ‘conditions’
[13:23:28.605]   - Field: ‘persistent’
[13:23:28.605]   - Field: ‘expr’
[13:23:28.605]   - Field: ‘uuid’
[13:23:28.605]   - Field: ‘seed’
[13:23:28.605]   - Field: ‘version’
[13:23:28.605]   - Field: ‘result’
[13:23:28.605]   - Field: ‘asynchronous’
[13:23:28.605]   - Field: ‘calls’
[13:23:28.606]   - Field: ‘globals’
[13:23:28.606]   - Field: ‘stdout’
[13:23:28.606]   - Field: ‘earlySignal’
[13:23:28.606]   - Field: ‘lazy’
[13:23:28.606]   - Field: ‘state’
[13:23:28.606] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:28.606] - Launch lazy future ...
[13:23:28.607] Packages needed by the future expression (n = 0): <none>
[13:23:28.607] Packages needed by future strategies (n = 0): <none>
[13:23:28.608] {
[13:23:28.608]     {
[13:23:28.608]         {
[13:23:28.608]             ...future.startTime <- base::Sys.time()
[13:23:28.608]             {
[13:23:28.608]                 {
[13:23:28.608]                   {
[13:23:28.608]                     {
[13:23:28.608]                       base::local({
[13:23:28.608]                         has_future <- base::requireNamespace("future", 
[13:23:28.608]                           quietly = TRUE)
[13:23:28.608]                         if (has_future) {
[13:23:28.608]                           ns <- base::getNamespace("future")
[13:23:28.608]                           version <- ns[[".package"]][["version"]]
[13:23:28.608]                           if (is.null(version)) 
[13:23:28.608]                             version <- utils::packageVersion("future")
[13:23:28.608]                         }
[13:23:28.608]                         else {
[13:23:28.608]                           version <- NULL
[13:23:28.608]                         }
[13:23:28.608]                         if (!has_future || version < "1.8.0") {
[13:23:28.608]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:28.608]                             "", base::R.version$version.string), 
[13:23:28.608]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:28.608]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:28.608]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:28.608]                               "release", "version")], collapse = " "), 
[13:23:28.608]                             hostname = base::Sys.info()[["nodename"]])
[13:23:28.608]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:28.608]                             info)
[13:23:28.608]                           info <- base::paste(info, collapse = "; ")
[13:23:28.608]                           if (!has_future) {
[13:23:28.608]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:28.608]                               info)
[13:23:28.608]                           }
[13:23:28.608]                           else {
[13:23:28.608]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:28.608]                               info, version)
[13:23:28.608]                           }
[13:23:28.608]                           base::stop(msg)
[13:23:28.608]                         }
[13:23:28.608]                       })
[13:23:28.608]                     }
[13:23:28.608]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:28.608]                     base::options(mc.cores = 1L)
[13:23:28.608]                   }
[13:23:28.608]                   options(future.plan = NULL)
[13:23:28.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:28.608]                 }
[13:23:28.608]                 ...future.workdir <- getwd()
[13:23:28.608]             }
[13:23:28.608]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:28.608]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:28.608]         }
[13:23:28.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:28.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:28.608]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:28.608]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:28.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:28.608]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:28.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:28.608]             base::names(...future.oldOptions))
[13:23:28.608]     }
[13:23:28.608]     if (FALSE) {
[13:23:28.608]     }
[13:23:28.608]     else {
[13:23:28.608]         if (TRUE) {
[13:23:28.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:28.608]                 open = "w")
[13:23:28.608]         }
[13:23:28.608]         else {
[13:23:28.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:28.608]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:28.608]         }
[13:23:28.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:28.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:28.608]             base::sink(type = "output", split = FALSE)
[13:23:28.608]             base::close(...future.stdout)
[13:23:28.608]         }, add = TRUE)
[13:23:28.608]     }
[13:23:28.608]     ...future.frame <- base::sys.nframe()
[13:23:28.608]     ...future.conditions <- base::list()
[13:23:28.608]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:28.608]     if (FALSE) {
[13:23:28.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:28.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:28.608]     }
[13:23:28.608]     ...future.result <- base::tryCatch({
[13:23:28.608]         base::withCallingHandlers({
[13:23:28.608]             ...future.value <- base::withVisible(base::local({
[13:23:28.608]                 ...future.makeSendCondition <- base::local({
[13:23:28.608]                   sendCondition <- NULL
[13:23:28.608]                   function(frame = 1L) {
[13:23:28.608]                     if (is.function(sendCondition)) 
[13:23:28.608]                       return(sendCondition)
[13:23:28.608]                     ns <- getNamespace("parallel")
[13:23:28.608]                     if (exists("sendData", mode = "function", 
[13:23:28.608]                       envir = ns)) {
[13:23:28.608]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:28.608]                         envir = ns)
[13:23:28.608]                       envir <- sys.frame(frame)
[13:23:28.608]                       master <- NULL
[13:23:28.608]                       while (!identical(envir, .GlobalEnv) && 
[13:23:28.608]                         !identical(envir, emptyenv())) {
[13:23:28.608]                         if (exists("master", mode = "list", envir = envir, 
[13:23:28.608]                           inherits = FALSE)) {
[13:23:28.608]                           master <- get("master", mode = "list", 
[13:23:28.608]                             envir = envir, inherits = FALSE)
[13:23:28.608]                           if (inherits(master, c("SOCKnode", 
[13:23:28.608]                             "SOCK0node"))) {
[13:23:28.608]                             sendCondition <<- function(cond) {
[13:23:28.608]                               data <- list(type = "VALUE", value = cond, 
[13:23:28.608]                                 success = TRUE)
[13:23:28.608]                               parallel_sendData(master, data)
[13:23:28.608]                             }
[13:23:28.608]                             return(sendCondition)
[13:23:28.608]                           }
[13:23:28.608]                         }
[13:23:28.608]                         frame <- frame + 1L
[13:23:28.608]                         envir <- sys.frame(frame)
[13:23:28.608]                       }
[13:23:28.608]                     }
[13:23:28.608]                     sendCondition <<- function(cond) NULL
[13:23:28.608]                   }
[13:23:28.608]                 })
[13:23:28.608]                 withCallingHandlers({
[13:23:28.608]                   {
[13:23:28.608]                     x[["a"]] <- 1
[13:23:28.608]                     x
[13:23:28.608]                   }
[13:23:28.608]                 }, immediateCondition = function(cond) {
[13:23:28.608]                   sendCondition <- ...future.makeSendCondition()
[13:23:28.608]                   sendCondition(cond)
[13:23:28.608]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.608]                   {
[13:23:28.608]                     inherits <- base::inherits
[13:23:28.608]                     invokeRestart <- base::invokeRestart
[13:23:28.608]                     is.null <- base::is.null
[13:23:28.608]                     muffled <- FALSE
[13:23:28.608]                     if (inherits(cond, "message")) {
[13:23:28.608]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:28.608]                       if (muffled) 
[13:23:28.608]                         invokeRestart("muffleMessage")
[13:23:28.608]                     }
[13:23:28.608]                     else if (inherits(cond, "warning")) {
[13:23:28.608]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:28.608]                       if (muffled) 
[13:23:28.608]                         invokeRestart("muffleWarning")
[13:23:28.608]                     }
[13:23:28.608]                     else if (inherits(cond, "condition")) {
[13:23:28.608]                       if (!is.null(pattern)) {
[13:23:28.608]                         computeRestarts <- base::computeRestarts
[13:23:28.608]                         grepl <- base::grepl
[13:23:28.608]                         restarts <- computeRestarts(cond)
[13:23:28.608]                         for (restart in restarts) {
[13:23:28.608]                           name <- restart$name
[13:23:28.608]                           if (is.null(name)) 
[13:23:28.608]                             next
[13:23:28.608]                           if (!grepl(pattern, name)) 
[13:23:28.608]                             next
[13:23:28.608]                           invokeRestart(restart)
[13:23:28.608]                           muffled <- TRUE
[13:23:28.608]                           break
[13:23:28.608]                         }
[13:23:28.608]                       }
[13:23:28.608]                     }
[13:23:28.608]                     invisible(muffled)
[13:23:28.608]                   }
[13:23:28.608]                   muffleCondition(cond)
[13:23:28.608]                 })
[13:23:28.608]             }))
[13:23:28.608]             future::FutureResult(value = ...future.value$value, 
[13:23:28.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.608]                   ...future.rng), globalenv = if (FALSE) 
[13:23:28.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:28.608]                     ...future.globalenv.names))
[13:23:28.608]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:28.608]         }, condition = base::local({
[13:23:28.608]             c <- base::c
[13:23:28.608]             inherits <- base::inherits
[13:23:28.608]             invokeRestart <- base::invokeRestart
[13:23:28.608]             length <- base::length
[13:23:28.608]             list <- base::list
[13:23:28.608]             seq.int <- base::seq.int
[13:23:28.608]             signalCondition <- base::signalCondition
[13:23:28.608]             sys.calls <- base::sys.calls
[13:23:28.608]             `[[` <- base::`[[`
[13:23:28.608]             `+` <- base::`+`
[13:23:28.608]             `<<-` <- base::`<<-`
[13:23:28.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:28.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:28.608]                   3L)]
[13:23:28.608]             }
[13:23:28.608]             function(cond) {
[13:23:28.608]                 is_error <- inherits(cond, "error")
[13:23:28.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:28.608]                   NULL)
[13:23:28.608]                 if (is_error) {
[13:23:28.608]                   sessionInformation <- function() {
[13:23:28.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:28.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:28.608]                       search = base::search(), system = base::Sys.info())
[13:23:28.608]                   }
[13:23:28.608]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:28.608]                     cond$call), session = sessionInformation(), 
[13:23:28.608]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:28.608]                   signalCondition(cond)
[13:23:28.608]                 }
[13:23:28.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:28.608]                 "immediateCondition"))) {
[13:23:28.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:28.608]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:28.608]                   if (TRUE && !signal) {
[13:23:28.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.608]                     {
[13:23:28.608]                       inherits <- base::inherits
[13:23:28.608]                       invokeRestart <- base::invokeRestart
[13:23:28.608]                       is.null <- base::is.null
[13:23:28.608]                       muffled <- FALSE
[13:23:28.608]                       if (inherits(cond, "message")) {
[13:23:28.608]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.608]                         if (muffled) 
[13:23:28.608]                           invokeRestart("muffleMessage")
[13:23:28.608]                       }
[13:23:28.608]                       else if (inherits(cond, "warning")) {
[13:23:28.608]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.608]                         if (muffled) 
[13:23:28.608]                           invokeRestart("muffleWarning")
[13:23:28.608]                       }
[13:23:28.608]                       else if (inherits(cond, "condition")) {
[13:23:28.608]                         if (!is.null(pattern)) {
[13:23:28.608]                           computeRestarts <- base::computeRestarts
[13:23:28.608]                           grepl <- base::grepl
[13:23:28.608]                           restarts <- computeRestarts(cond)
[13:23:28.608]                           for (restart in restarts) {
[13:23:28.608]                             name <- restart$name
[13:23:28.608]                             if (is.null(name)) 
[13:23:28.608]                               next
[13:23:28.608]                             if (!grepl(pattern, name)) 
[13:23:28.608]                               next
[13:23:28.608]                             invokeRestart(restart)
[13:23:28.608]                             muffled <- TRUE
[13:23:28.608]                             break
[13:23:28.608]                           }
[13:23:28.608]                         }
[13:23:28.608]                       }
[13:23:28.608]                       invisible(muffled)
[13:23:28.608]                     }
[13:23:28.608]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.608]                   }
[13:23:28.608]                 }
[13:23:28.608]                 else {
[13:23:28.608]                   if (TRUE) {
[13:23:28.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.608]                     {
[13:23:28.608]                       inherits <- base::inherits
[13:23:28.608]                       invokeRestart <- base::invokeRestart
[13:23:28.608]                       is.null <- base::is.null
[13:23:28.608]                       muffled <- FALSE
[13:23:28.608]                       if (inherits(cond, "message")) {
[13:23:28.608]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.608]                         if (muffled) 
[13:23:28.608]                           invokeRestart("muffleMessage")
[13:23:28.608]                       }
[13:23:28.608]                       else if (inherits(cond, "warning")) {
[13:23:28.608]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.608]                         if (muffled) 
[13:23:28.608]                           invokeRestart("muffleWarning")
[13:23:28.608]                       }
[13:23:28.608]                       else if (inherits(cond, "condition")) {
[13:23:28.608]                         if (!is.null(pattern)) {
[13:23:28.608]                           computeRestarts <- base::computeRestarts
[13:23:28.608]                           grepl <- base::grepl
[13:23:28.608]                           restarts <- computeRestarts(cond)
[13:23:28.608]                           for (restart in restarts) {
[13:23:28.608]                             name <- restart$name
[13:23:28.608]                             if (is.null(name)) 
[13:23:28.608]                               next
[13:23:28.608]                             if (!grepl(pattern, name)) 
[13:23:28.608]                               next
[13:23:28.608]                             invokeRestart(restart)
[13:23:28.608]                             muffled <- TRUE
[13:23:28.608]                             break
[13:23:28.608]                           }
[13:23:28.608]                         }
[13:23:28.608]                       }
[13:23:28.608]                       invisible(muffled)
[13:23:28.608]                     }
[13:23:28.608]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.608]                   }
[13:23:28.608]                 }
[13:23:28.608]             }
[13:23:28.608]         }))
[13:23:28.608]     }, error = function(ex) {
[13:23:28.608]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:28.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.608]                 ...future.rng), started = ...future.startTime, 
[13:23:28.608]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:28.608]             version = "1.8"), class = "FutureResult")
[13:23:28.608]     }, finally = {
[13:23:28.608]         if (!identical(...future.workdir, getwd())) 
[13:23:28.608]             setwd(...future.workdir)
[13:23:28.608]         {
[13:23:28.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:28.608]                 ...future.oldOptions$nwarnings <- NULL
[13:23:28.608]             }
[13:23:28.608]             base::options(...future.oldOptions)
[13:23:28.608]             if (.Platform$OS.type == "windows") {
[13:23:28.608]                 old_names <- names(...future.oldEnvVars)
[13:23:28.608]                 envs <- base::Sys.getenv()
[13:23:28.608]                 names <- names(envs)
[13:23:28.608]                 common <- intersect(names, old_names)
[13:23:28.608]                 added <- setdiff(names, old_names)
[13:23:28.608]                 removed <- setdiff(old_names, names)
[13:23:28.608]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:28.608]                   envs[common]]
[13:23:28.608]                 NAMES <- toupper(changed)
[13:23:28.608]                 args <- list()
[13:23:28.608]                 for (kk in seq_along(NAMES)) {
[13:23:28.608]                   name <- changed[[kk]]
[13:23:28.608]                   NAME <- NAMES[[kk]]
[13:23:28.608]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.608]                     next
[13:23:28.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.608]                 }
[13:23:28.608]                 NAMES <- toupper(added)
[13:23:28.608]                 for (kk in seq_along(NAMES)) {
[13:23:28.608]                   name <- added[[kk]]
[13:23:28.608]                   NAME <- NAMES[[kk]]
[13:23:28.608]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.608]                     next
[13:23:28.608]                   args[[name]] <- ""
[13:23:28.608]                 }
[13:23:28.608]                 NAMES <- toupper(removed)
[13:23:28.608]                 for (kk in seq_along(NAMES)) {
[13:23:28.608]                   name <- removed[[kk]]
[13:23:28.608]                   NAME <- NAMES[[kk]]
[13:23:28.608]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.608]                     next
[13:23:28.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.608]                 }
[13:23:28.608]                 if (length(args) > 0) 
[13:23:28.608]                   base::do.call(base::Sys.setenv, args = args)
[13:23:28.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:28.608]             }
[13:23:28.608]             else {
[13:23:28.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:28.608]             }
[13:23:28.608]             {
[13:23:28.608]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:28.608]                   0L) {
[13:23:28.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:28.608]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:28.608]                   base::options(opts)
[13:23:28.608]                 }
[13:23:28.608]                 {
[13:23:28.608]                   {
[13:23:28.608]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:28.608]                     NULL
[13:23:28.608]                   }
[13:23:28.608]                   options(future.plan = NULL)
[13:23:28.608]                   if (is.na(NA_character_)) 
[13:23:28.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:28.608]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:28.608]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:28.608]                     envir = parent.frame()) 
[13:23:28.608]                   {
[13:23:28.608]                     if (is.function(workers)) 
[13:23:28.608]                       workers <- workers()
[13:23:28.608]                     workers <- structure(as.integer(workers), 
[13:23:28.608]                       class = class(workers))
[13:23:28.608]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:28.608]                       workers >= 1)
[13:23:28.608]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:28.608]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:28.608]                     }
[13:23:28.608]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:28.608]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:28.608]                       envir = envir)
[13:23:28.608]                     if (!future$lazy) 
[13:23:28.608]                       future <- run(future)
[13:23:28.608]                     invisible(future)
[13:23:28.608]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:28.608]                 }
[13:23:28.608]             }
[13:23:28.608]         }
[13:23:28.608]     })
[13:23:28.608]     if (TRUE) {
[13:23:28.608]         base::sink(type = "output", split = FALSE)
[13:23:28.608]         if (TRUE) {
[13:23:28.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:28.608]         }
[13:23:28.608]         else {
[13:23:28.608]             ...future.result["stdout"] <- base::list(NULL)
[13:23:28.608]         }
[13:23:28.608]         base::close(...future.stdout)
[13:23:28.608]         ...future.stdout <- NULL
[13:23:28.608]     }
[13:23:28.608]     ...future.result$conditions <- ...future.conditions
[13:23:28.608]     ...future.result$finished <- base::Sys.time()
[13:23:28.608]     ...future.result
[13:23:28.608] }
[13:23:28.611] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:23:28.611] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:23:28.612] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:23:28.612] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:23:28.612] MultisessionFuture started
[13:23:28.613] - Launch lazy future ... done
[13:23:28.613] run() for ‘MultisessionFuture’ ... done
[13:23:28.613] result() for ClusterFuture ...
[13:23:28.613] receiveMessageFromWorker() for ClusterFuture ...
[13:23:28.613] - Validating connection of MultisessionFuture
[13:23:28.661] - received message: FutureResult
[13:23:28.662] - Received FutureResult
[13:23:28.662] - Erased future from FutureRegistry
[13:23:28.662] result() for ClusterFuture ...
[13:23:28.662] - result already collected: FutureResult
[13:23:28.662] result() for ClusterFuture ... done
[13:23:28.662] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.662] result() for ClusterFuture ... done
[13:23:28.663] result() for ClusterFuture ...
[13:23:28.663] - result already collected: FutureResult
[13:23:28.663] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:28.663] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:28.664] Searching for globals...
[13:23:28.666] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:28.667] Searching for globals ... DONE
[13:23:28.667] Resolving globals: TRUE
[13:23:28.667] Resolving any globals that are futures ...
[13:23:28.667] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:28.667] Resolving any globals that are futures ... DONE
[13:23:28.668] Resolving futures part of globals (recursively) ...
[13:23:28.668] resolve() on list ...
[13:23:28.668]  recursive: 99
[13:23:28.668]  length: 1
[13:23:28.669]  elements: ‘x’
[13:23:28.669]  length: 0 (resolved future 1)
[13:23:28.669] resolve() on list ... DONE
[13:23:28.669] - globals: [1] ‘x’
[13:23:28.669] Resolving futures part of globals (recursively) ... DONE
[13:23:28.669] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:28.670] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:28.670] - globals: [1] ‘x’
[13:23:28.670] 
[13:23:28.670] getGlobalsAndPackages() ... DONE
[13:23:28.671] run() for ‘Future’ ...
[13:23:28.671] - state: ‘created’
[13:23:28.671] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:28.690] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:28.690] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:28.690]   - Field: ‘node’
[13:23:28.690]   - Field: ‘label’
[13:23:28.690]   - Field: ‘local’
[13:23:28.691]   - Field: ‘owner’
[13:23:28.691]   - Field: ‘envir’
[13:23:28.691]   - Field: ‘workers’
[13:23:28.691]   - Field: ‘packages’
[13:23:28.691]   - Field: ‘gc’
[13:23:28.691]   - Field: ‘conditions’
[13:23:28.691]   - Field: ‘persistent’
[13:23:28.691]   - Field: ‘expr’
[13:23:28.692]   - Field: ‘uuid’
[13:23:28.692]   - Field: ‘seed’
[13:23:28.692]   - Field: ‘version’
[13:23:28.692]   - Field: ‘result’
[13:23:28.692]   - Field: ‘asynchronous’
[13:23:28.692]   - Field: ‘calls’
[13:23:28.692]   - Field: ‘globals’
[13:23:28.692]   - Field: ‘stdout’
[13:23:28.692]   - Field: ‘earlySignal’
[13:23:28.693]   - Field: ‘lazy’
[13:23:28.693]   - Field: ‘state’
[13:23:28.693] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:28.693] - Launch lazy future ...
[13:23:28.693] Packages needed by the future expression (n = 0): <none>
[13:23:28.693] Packages needed by future strategies (n = 0): <none>
[13:23:28.694] {
[13:23:28.694]     {
[13:23:28.694]         {
[13:23:28.694]             ...future.startTime <- base::Sys.time()
[13:23:28.694]             {
[13:23:28.694]                 {
[13:23:28.694]                   {
[13:23:28.694]                     {
[13:23:28.694]                       base::local({
[13:23:28.694]                         has_future <- base::requireNamespace("future", 
[13:23:28.694]                           quietly = TRUE)
[13:23:28.694]                         if (has_future) {
[13:23:28.694]                           ns <- base::getNamespace("future")
[13:23:28.694]                           version <- ns[[".package"]][["version"]]
[13:23:28.694]                           if (is.null(version)) 
[13:23:28.694]                             version <- utils::packageVersion("future")
[13:23:28.694]                         }
[13:23:28.694]                         else {
[13:23:28.694]                           version <- NULL
[13:23:28.694]                         }
[13:23:28.694]                         if (!has_future || version < "1.8.0") {
[13:23:28.694]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:28.694]                             "", base::R.version$version.string), 
[13:23:28.694]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:28.694]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:28.694]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:28.694]                               "release", "version")], collapse = " "), 
[13:23:28.694]                             hostname = base::Sys.info()[["nodename"]])
[13:23:28.694]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:28.694]                             info)
[13:23:28.694]                           info <- base::paste(info, collapse = "; ")
[13:23:28.694]                           if (!has_future) {
[13:23:28.694]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:28.694]                               info)
[13:23:28.694]                           }
[13:23:28.694]                           else {
[13:23:28.694]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:28.694]                               info, version)
[13:23:28.694]                           }
[13:23:28.694]                           base::stop(msg)
[13:23:28.694]                         }
[13:23:28.694]                       })
[13:23:28.694]                     }
[13:23:28.694]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:28.694]                     base::options(mc.cores = 1L)
[13:23:28.694]                   }
[13:23:28.694]                   options(future.plan = NULL)
[13:23:28.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:28.694]                 }
[13:23:28.694]                 ...future.workdir <- getwd()
[13:23:28.694]             }
[13:23:28.694]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:28.694]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:28.694]         }
[13:23:28.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:28.694]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:28.694]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:28.694]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:28.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:28.694]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:28.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:28.694]             base::names(...future.oldOptions))
[13:23:28.694]     }
[13:23:28.694]     if (FALSE) {
[13:23:28.694]     }
[13:23:28.694]     else {
[13:23:28.694]         if (TRUE) {
[13:23:28.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:28.694]                 open = "w")
[13:23:28.694]         }
[13:23:28.694]         else {
[13:23:28.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:28.694]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:28.694]         }
[13:23:28.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:28.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:28.694]             base::sink(type = "output", split = FALSE)
[13:23:28.694]             base::close(...future.stdout)
[13:23:28.694]         }, add = TRUE)
[13:23:28.694]     }
[13:23:28.694]     ...future.frame <- base::sys.nframe()
[13:23:28.694]     ...future.conditions <- base::list()
[13:23:28.694]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:28.694]     if (FALSE) {
[13:23:28.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:28.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:28.694]     }
[13:23:28.694]     ...future.result <- base::tryCatch({
[13:23:28.694]         base::withCallingHandlers({
[13:23:28.694]             ...future.value <- base::withVisible(base::local({
[13:23:28.694]                 ...future.makeSendCondition <- base::local({
[13:23:28.694]                   sendCondition <- NULL
[13:23:28.694]                   function(frame = 1L) {
[13:23:28.694]                     if (is.function(sendCondition)) 
[13:23:28.694]                       return(sendCondition)
[13:23:28.694]                     ns <- getNamespace("parallel")
[13:23:28.694]                     if (exists("sendData", mode = "function", 
[13:23:28.694]                       envir = ns)) {
[13:23:28.694]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:28.694]                         envir = ns)
[13:23:28.694]                       envir <- sys.frame(frame)
[13:23:28.694]                       master <- NULL
[13:23:28.694]                       while (!identical(envir, .GlobalEnv) && 
[13:23:28.694]                         !identical(envir, emptyenv())) {
[13:23:28.694]                         if (exists("master", mode = "list", envir = envir, 
[13:23:28.694]                           inherits = FALSE)) {
[13:23:28.694]                           master <- get("master", mode = "list", 
[13:23:28.694]                             envir = envir, inherits = FALSE)
[13:23:28.694]                           if (inherits(master, c("SOCKnode", 
[13:23:28.694]                             "SOCK0node"))) {
[13:23:28.694]                             sendCondition <<- function(cond) {
[13:23:28.694]                               data <- list(type = "VALUE", value = cond, 
[13:23:28.694]                                 success = TRUE)
[13:23:28.694]                               parallel_sendData(master, data)
[13:23:28.694]                             }
[13:23:28.694]                             return(sendCondition)
[13:23:28.694]                           }
[13:23:28.694]                         }
[13:23:28.694]                         frame <- frame + 1L
[13:23:28.694]                         envir <- sys.frame(frame)
[13:23:28.694]                       }
[13:23:28.694]                     }
[13:23:28.694]                     sendCondition <<- function(cond) NULL
[13:23:28.694]                   }
[13:23:28.694]                 })
[13:23:28.694]                 withCallingHandlers({
[13:23:28.694]                   {
[13:23:28.694]                     x["a"] <- list(1)
[13:23:28.694]                     x
[13:23:28.694]                   }
[13:23:28.694]                 }, immediateCondition = function(cond) {
[13:23:28.694]                   sendCondition <- ...future.makeSendCondition()
[13:23:28.694]                   sendCondition(cond)
[13:23:28.694]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.694]                   {
[13:23:28.694]                     inherits <- base::inherits
[13:23:28.694]                     invokeRestart <- base::invokeRestart
[13:23:28.694]                     is.null <- base::is.null
[13:23:28.694]                     muffled <- FALSE
[13:23:28.694]                     if (inherits(cond, "message")) {
[13:23:28.694]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:28.694]                       if (muffled) 
[13:23:28.694]                         invokeRestart("muffleMessage")
[13:23:28.694]                     }
[13:23:28.694]                     else if (inherits(cond, "warning")) {
[13:23:28.694]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:28.694]                       if (muffled) 
[13:23:28.694]                         invokeRestart("muffleWarning")
[13:23:28.694]                     }
[13:23:28.694]                     else if (inherits(cond, "condition")) {
[13:23:28.694]                       if (!is.null(pattern)) {
[13:23:28.694]                         computeRestarts <- base::computeRestarts
[13:23:28.694]                         grepl <- base::grepl
[13:23:28.694]                         restarts <- computeRestarts(cond)
[13:23:28.694]                         for (restart in restarts) {
[13:23:28.694]                           name <- restart$name
[13:23:28.694]                           if (is.null(name)) 
[13:23:28.694]                             next
[13:23:28.694]                           if (!grepl(pattern, name)) 
[13:23:28.694]                             next
[13:23:28.694]                           invokeRestart(restart)
[13:23:28.694]                           muffled <- TRUE
[13:23:28.694]                           break
[13:23:28.694]                         }
[13:23:28.694]                       }
[13:23:28.694]                     }
[13:23:28.694]                     invisible(muffled)
[13:23:28.694]                   }
[13:23:28.694]                   muffleCondition(cond)
[13:23:28.694]                 })
[13:23:28.694]             }))
[13:23:28.694]             future::FutureResult(value = ...future.value$value, 
[13:23:28.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.694]                   ...future.rng), globalenv = if (FALSE) 
[13:23:28.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:28.694]                     ...future.globalenv.names))
[13:23:28.694]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:28.694]         }, condition = base::local({
[13:23:28.694]             c <- base::c
[13:23:28.694]             inherits <- base::inherits
[13:23:28.694]             invokeRestart <- base::invokeRestart
[13:23:28.694]             length <- base::length
[13:23:28.694]             list <- base::list
[13:23:28.694]             seq.int <- base::seq.int
[13:23:28.694]             signalCondition <- base::signalCondition
[13:23:28.694]             sys.calls <- base::sys.calls
[13:23:28.694]             `[[` <- base::`[[`
[13:23:28.694]             `+` <- base::`+`
[13:23:28.694]             `<<-` <- base::`<<-`
[13:23:28.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:28.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:28.694]                   3L)]
[13:23:28.694]             }
[13:23:28.694]             function(cond) {
[13:23:28.694]                 is_error <- inherits(cond, "error")
[13:23:28.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:28.694]                   NULL)
[13:23:28.694]                 if (is_error) {
[13:23:28.694]                   sessionInformation <- function() {
[13:23:28.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:28.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:28.694]                       search = base::search(), system = base::Sys.info())
[13:23:28.694]                   }
[13:23:28.694]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:28.694]                     cond$call), session = sessionInformation(), 
[13:23:28.694]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:28.694]                   signalCondition(cond)
[13:23:28.694]                 }
[13:23:28.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:28.694]                 "immediateCondition"))) {
[13:23:28.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:28.694]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:28.694]                   if (TRUE && !signal) {
[13:23:28.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.694]                     {
[13:23:28.694]                       inherits <- base::inherits
[13:23:28.694]                       invokeRestart <- base::invokeRestart
[13:23:28.694]                       is.null <- base::is.null
[13:23:28.694]                       muffled <- FALSE
[13:23:28.694]                       if (inherits(cond, "message")) {
[13:23:28.694]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.694]                         if (muffled) 
[13:23:28.694]                           invokeRestart("muffleMessage")
[13:23:28.694]                       }
[13:23:28.694]                       else if (inherits(cond, "warning")) {
[13:23:28.694]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.694]                         if (muffled) 
[13:23:28.694]                           invokeRestart("muffleWarning")
[13:23:28.694]                       }
[13:23:28.694]                       else if (inherits(cond, "condition")) {
[13:23:28.694]                         if (!is.null(pattern)) {
[13:23:28.694]                           computeRestarts <- base::computeRestarts
[13:23:28.694]                           grepl <- base::grepl
[13:23:28.694]                           restarts <- computeRestarts(cond)
[13:23:28.694]                           for (restart in restarts) {
[13:23:28.694]                             name <- restart$name
[13:23:28.694]                             if (is.null(name)) 
[13:23:28.694]                               next
[13:23:28.694]                             if (!grepl(pattern, name)) 
[13:23:28.694]                               next
[13:23:28.694]                             invokeRestart(restart)
[13:23:28.694]                             muffled <- TRUE
[13:23:28.694]                             break
[13:23:28.694]                           }
[13:23:28.694]                         }
[13:23:28.694]                       }
[13:23:28.694]                       invisible(muffled)
[13:23:28.694]                     }
[13:23:28.694]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.694]                   }
[13:23:28.694]                 }
[13:23:28.694]                 else {
[13:23:28.694]                   if (TRUE) {
[13:23:28.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.694]                     {
[13:23:28.694]                       inherits <- base::inherits
[13:23:28.694]                       invokeRestart <- base::invokeRestart
[13:23:28.694]                       is.null <- base::is.null
[13:23:28.694]                       muffled <- FALSE
[13:23:28.694]                       if (inherits(cond, "message")) {
[13:23:28.694]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.694]                         if (muffled) 
[13:23:28.694]                           invokeRestart("muffleMessage")
[13:23:28.694]                       }
[13:23:28.694]                       else if (inherits(cond, "warning")) {
[13:23:28.694]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.694]                         if (muffled) 
[13:23:28.694]                           invokeRestart("muffleWarning")
[13:23:28.694]                       }
[13:23:28.694]                       else if (inherits(cond, "condition")) {
[13:23:28.694]                         if (!is.null(pattern)) {
[13:23:28.694]                           computeRestarts <- base::computeRestarts
[13:23:28.694]                           grepl <- base::grepl
[13:23:28.694]                           restarts <- computeRestarts(cond)
[13:23:28.694]                           for (restart in restarts) {
[13:23:28.694]                             name <- restart$name
[13:23:28.694]                             if (is.null(name)) 
[13:23:28.694]                               next
[13:23:28.694]                             if (!grepl(pattern, name)) 
[13:23:28.694]                               next
[13:23:28.694]                             invokeRestart(restart)
[13:23:28.694]                             muffled <- TRUE
[13:23:28.694]                             break
[13:23:28.694]                           }
[13:23:28.694]                         }
[13:23:28.694]                       }
[13:23:28.694]                       invisible(muffled)
[13:23:28.694]                     }
[13:23:28.694]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.694]                   }
[13:23:28.694]                 }
[13:23:28.694]             }
[13:23:28.694]         }))
[13:23:28.694]     }, error = function(ex) {
[13:23:28.694]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:28.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.694]                 ...future.rng), started = ...future.startTime, 
[13:23:28.694]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:28.694]             version = "1.8"), class = "FutureResult")
[13:23:28.694]     }, finally = {
[13:23:28.694]         if (!identical(...future.workdir, getwd())) 
[13:23:28.694]             setwd(...future.workdir)
[13:23:28.694]         {
[13:23:28.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:28.694]                 ...future.oldOptions$nwarnings <- NULL
[13:23:28.694]             }
[13:23:28.694]             base::options(...future.oldOptions)
[13:23:28.694]             if (.Platform$OS.type == "windows") {
[13:23:28.694]                 old_names <- names(...future.oldEnvVars)
[13:23:28.694]                 envs <- base::Sys.getenv()
[13:23:28.694]                 names <- names(envs)
[13:23:28.694]                 common <- intersect(names, old_names)
[13:23:28.694]                 added <- setdiff(names, old_names)
[13:23:28.694]                 removed <- setdiff(old_names, names)
[13:23:28.694]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:28.694]                   envs[common]]
[13:23:28.694]                 NAMES <- toupper(changed)
[13:23:28.694]                 args <- list()
[13:23:28.694]                 for (kk in seq_along(NAMES)) {
[13:23:28.694]                   name <- changed[[kk]]
[13:23:28.694]                   NAME <- NAMES[[kk]]
[13:23:28.694]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.694]                     next
[13:23:28.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.694]                 }
[13:23:28.694]                 NAMES <- toupper(added)
[13:23:28.694]                 for (kk in seq_along(NAMES)) {
[13:23:28.694]                   name <- added[[kk]]
[13:23:28.694]                   NAME <- NAMES[[kk]]
[13:23:28.694]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.694]                     next
[13:23:28.694]                   args[[name]] <- ""
[13:23:28.694]                 }
[13:23:28.694]                 NAMES <- toupper(removed)
[13:23:28.694]                 for (kk in seq_along(NAMES)) {
[13:23:28.694]                   name <- removed[[kk]]
[13:23:28.694]                   NAME <- NAMES[[kk]]
[13:23:28.694]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.694]                     next
[13:23:28.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.694]                 }
[13:23:28.694]                 if (length(args) > 0) 
[13:23:28.694]                   base::do.call(base::Sys.setenv, args = args)
[13:23:28.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:28.694]             }
[13:23:28.694]             else {
[13:23:28.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:28.694]             }
[13:23:28.694]             {
[13:23:28.694]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:28.694]                   0L) {
[13:23:28.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:28.694]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:28.694]                   base::options(opts)
[13:23:28.694]                 }
[13:23:28.694]                 {
[13:23:28.694]                   {
[13:23:28.694]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:28.694]                     NULL
[13:23:28.694]                   }
[13:23:28.694]                   options(future.plan = NULL)
[13:23:28.694]                   if (is.na(NA_character_)) 
[13:23:28.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:28.694]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:28.694]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:28.694]                     envir = parent.frame()) 
[13:23:28.694]                   {
[13:23:28.694]                     if (is.function(workers)) 
[13:23:28.694]                       workers <- workers()
[13:23:28.694]                     workers <- structure(as.integer(workers), 
[13:23:28.694]                       class = class(workers))
[13:23:28.694]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:28.694]                       workers >= 1)
[13:23:28.694]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:28.694]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:28.694]                     }
[13:23:28.694]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:28.694]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:28.694]                       envir = envir)
[13:23:28.694]                     if (!future$lazy) 
[13:23:28.694]                       future <- run(future)
[13:23:28.694]                     invisible(future)
[13:23:28.694]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:28.694]                 }
[13:23:28.694]             }
[13:23:28.694]         }
[13:23:28.694]     })
[13:23:28.694]     if (TRUE) {
[13:23:28.694]         base::sink(type = "output", split = FALSE)
[13:23:28.694]         if (TRUE) {
[13:23:28.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:28.694]         }
[13:23:28.694]         else {
[13:23:28.694]             ...future.result["stdout"] <- base::list(NULL)
[13:23:28.694]         }
[13:23:28.694]         base::close(...future.stdout)
[13:23:28.694]         ...future.stdout <- NULL
[13:23:28.694]     }
[13:23:28.694]     ...future.result$conditions <- ...future.conditions
[13:23:28.694]     ...future.result$finished <- base::Sys.time()
[13:23:28.694]     ...future.result
[13:23:28.694] }
[13:23:28.697] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:23:28.697] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:23:28.697] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:23:28.697] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:23:28.698] MultisessionFuture started
[13:23:28.698] - Launch lazy future ... done
[13:23:28.698] run() for ‘MultisessionFuture’ ... done
[13:23:28.698] result() for ClusterFuture ...
[13:23:28.698] receiveMessageFromWorker() for ClusterFuture ...
[13:23:28.699] - Validating connection of MultisessionFuture
[13:23:28.745] - received message: FutureResult
[13:23:28.745] - Received FutureResult
[13:23:28.745] - Erased future from FutureRegistry
[13:23:28.746] result() for ClusterFuture ...
[13:23:28.746] - result already collected: FutureResult
[13:23:28.746] result() for ClusterFuture ... done
[13:23:28.746] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.746] result() for ClusterFuture ... done
[13:23:28.746] result() for ClusterFuture ...
[13:23:28.746] - result already collected: FutureResult
[13:23:28.746] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:28.747] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:28.747] Searching for globals...
[13:23:28.749] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:28.749] Searching for globals ... DONE
[13:23:28.749] Resolving globals: TRUE
[13:23:28.749] Resolving any globals that are futures ...
[13:23:28.749] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:28.750] Resolving any globals that are futures ... DONE
[13:23:28.750] Resolving futures part of globals (recursively) ...
[13:23:28.750] resolve() on list ...
[13:23:28.750]  recursive: 99
[13:23:28.750]  length: 1
[13:23:28.751]  elements: ‘x’
[13:23:28.751]  length: 0 (resolved future 1)
[13:23:28.751] resolve() on list ... DONE
[13:23:28.751] - globals: [1] ‘x’
[13:23:28.751] Resolving futures part of globals (recursively) ... DONE
[13:23:28.751] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:28.751] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:28.752] - globals: [1] ‘x’
[13:23:28.752] 
[13:23:28.752] getGlobalsAndPackages() ... DONE
[13:23:28.752] run() for ‘Future’ ...
[13:23:28.752] - state: ‘created’
[13:23:28.752] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:28.767] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:28.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:28.767]   - Field: ‘node’
[13:23:28.767]   - Field: ‘label’
[13:23:28.767]   - Field: ‘local’
[13:23:28.767]   - Field: ‘owner’
[13:23:28.767]   - Field: ‘envir’
[13:23:28.767]   - Field: ‘workers’
[13:23:28.768]   - Field: ‘packages’
[13:23:28.768]   - Field: ‘gc’
[13:23:28.768]   - Field: ‘conditions’
[13:23:28.768]   - Field: ‘persistent’
[13:23:28.768]   - Field: ‘expr’
[13:23:28.768]   - Field: ‘uuid’
[13:23:28.768]   - Field: ‘seed’
[13:23:28.768]   - Field: ‘version’
[13:23:28.768]   - Field: ‘result’
[13:23:28.768]   - Field: ‘asynchronous’
[13:23:28.769]   - Field: ‘calls’
[13:23:28.769]   - Field: ‘globals’
[13:23:28.769]   - Field: ‘stdout’
[13:23:28.769]   - Field: ‘earlySignal’
[13:23:28.769]   - Field: ‘lazy’
[13:23:28.769]   - Field: ‘state’
[13:23:28.769] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:28.769] - Launch lazy future ...
[13:23:28.770] Packages needed by the future expression (n = 0): <none>
[13:23:28.770] Packages needed by future strategies (n = 0): <none>
[13:23:28.770] {
[13:23:28.770]     {
[13:23:28.770]         {
[13:23:28.770]             ...future.startTime <- base::Sys.time()
[13:23:28.770]             {
[13:23:28.770]                 {
[13:23:28.770]                   {
[13:23:28.770]                     {
[13:23:28.770]                       base::local({
[13:23:28.770]                         has_future <- base::requireNamespace("future", 
[13:23:28.770]                           quietly = TRUE)
[13:23:28.770]                         if (has_future) {
[13:23:28.770]                           ns <- base::getNamespace("future")
[13:23:28.770]                           version <- ns[[".package"]][["version"]]
[13:23:28.770]                           if (is.null(version)) 
[13:23:28.770]                             version <- utils::packageVersion("future")
[13:23:28.770]                         }
[13:23:28.770]                         else {
[13:23:28.770]                           version <- NULL
[13:23:28.770]                         }
[13:23:28.770]                         if (!has_future || version < "1.8.0") {
[13:23:28.770]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:28.770]                             "", base::R.version$version.string), 
[13:23:28.770]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:28.770]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:28.770]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:28.770]                               "release", "version")], collapse = " "), 
[13:23:28.770]                             hostname = base::Sys.info()[["nodename"]])
[13:23:28.770]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:28.770]                             info)
[13:23:28.770]                           info <- base::paste(info, collapse = "; ")
[13:23:28.770]                           if (!has_future) {
[13:23:28.770]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:28.770]                               info)
[13:23:28.770]                           }
[13:23:28.770]                           else {
[13:23:28.770]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:28.770]                               info, version)
[13:23:28.770]                           }
[13:23:28.770]                           base::stop(msg)
[13:23:28.770]                         }
[13:23:28.770]                       })
[13:23:28.770]                     }
[13:23:28.770]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:28.770]                     base::options(mc.cores = 1L)
[13:23:28.770]                   }
[13:23:28.770]                   options(future.plan = NULL)
[13:23:28.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:28.770]                 }
[13:23:28.770]                 ...future.workdir <- getwd()
[13:23:28.770]             }
[13:23:28.770]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:28.770]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:28.770]         }
[13:23:28.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:28.770]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:28.770]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:28.770]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:28.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:28.770]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:28.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:28.770]             base::names(...future.oldOptions))
[13:23:28.770]     }
[13:23:28.770]     if (FALSE) {
[13:23:28.770]     }
[13:23:28.770]     else {
[13:23:28.770]         if (TRUE) {
[13:23:28.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:28.770]                 open = "w")
[13:23:28.770]         }
[13:23:28.770]         else {
[13:23:28.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:28.770]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:28.770]         }
[13:23:28.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:28.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:28.770]             base::sink(type = "output", split = FALSE)
[13:23:28.770]             base::close(...future.stdout)
[13:23:28.770]         }, add = TRUE)
[13:23:28.770]     }
[13:23:28.770]     ...future.frame <- base::sys.nframe()
[13:23:28.770]     ...future.conditions <- base::list()
[13:23:28.770]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:28.770]     if (FALSE) {
[13:23:28.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:28.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:28.770]     }
[13:23:28.770]     ...future.result <- base::tryCatch({
[13:23:28.770]         base::withCallingHandlers({
[13:23:28.770]             ...future.value <- base::withVisible(base::local({
[13:23:28.770]                 ...future.makeSendCondition <- base::local({
[13:23:28.770]                   sendCondition <- NULL
[13:23:28.770]                   function(frame = 1L) {
[13:23:28.770]                     if (is.function(sendCondition)) 
[13:23:28.770]                       return(sendCondition)
[13:23:28.770]                     ns <- getNamespace("parallel")
[13:23:28.770]                     if (exists("sendData", mode = "function", 
[13:23:28.770]                       envir = ns)) {
[13:23:28.770]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:28.770]                         envir = ns)
[13:23:28.770]                       envir <- sys.frame(frame)
[13:23:28.770]                       master <- NULL
[13:23:28.770]                       while (!identical(envir, .GlobalEnv) && 
[13:23:28.770]                         !identical(envir, emptyenv())) {
[13:23:28.770]                         if (exists("master", mode = "list", envir = envir, 
[13:23:28.770]                           inherits = FALSE)) {
[13:23:28.770]                           master <- get("master", mode = "list", 
[13:23:28.770]                             envir = envir, inherits = FALSE)
[13:23:28.770]                           if (inherits(master, c("SOCKnode", 
[13:23:28.770]                             "SOCK0node"))) {
[13:23:28.770]                             sendCondition <<- function(cond) {
[13:23:28.770]                               data <- list(type = "VALUE", value = cond, 
[13:23:28.770]                                 success = TRUE)
[13:23:28.770]                               parallel_sendData(master, data)
[13:23:28.770]                             }
[13:23:28.770]                             return(sendCondition)
[13:23:28.770]                           }
[13:23:28.770]                         }
[13:23:28.770]                         frame <- frame + 1L
[13:23:28.770]                         envir <- sys.frame(frame)
[13:23:28.770]                       }
[13:23:28.770]                     }
[13:23:28.770]                     sendCondition <<- function(cond) NULL
[13:23:28.770]                   }
[13:23:28.770]                 })
[13:23:28.770]                 withCallingHandlers({
[13:23:28.770]                   {
[13:23:28.770]                     x["a"] <- list(1)
[13:23:28.770]                     x
[13:23:28.770]                   }
[13:23:28.770]                 }, immediateCondition = function(cond) {
[13:23:28.770]                   sendCondition <- ...future.makeSendCondition()
[13:23:28.770]                   sendCondition(cond)
[13:23:28.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.770]                   {
[13:23:28.770]                     inherits <- base::inherits
[13:23:28.770]                     invokeRestart <- base::invokeRestart
[13:23:28.770]                     is.null <- base::is.null
[13:23:28.770]                     muffled <- FALSE
[13:23:28.770]                     if (inherits(cond, "message")) {
[13:23:28.770]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:28.770]                       if (muffled) 
[13:23:28.770]                         invokeRestart("muffleMessage")
[13:23:28.770]                     }
[13:23:28.770]                     else if (inherits(cond, "warning")) {
[13:23:28.770]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:28.770]                       if (muffled) 
[13:23:28.770]                         invokeRestart("muffleWarning")
[13:23:28.770]                     }
[13:23:28.770]                     else if (inherits(cond, "condition")) {
[13:23:28.770]                       if (!is.null(pattern)) {
[13:23:28.770]                         computeRestarts <- base::computeRestarts
[13:23:28.770]                         grepl <- base::grepl
[13:23:28.770]                         restarts <- computeRestarts(cond)
[13:23:28.770]                         for (restart in restarts) {
[13:23:28.770]                           name <- restart$name
[13:23:28.770]                           if (is.null(name)) 
[13:23:28.770]                             next
[13:23:28.770]                           if (!grepl(pattern, name)) 
[13:23:28.770]                             next
[13:23:28.770]                           invokeRestart(restart)
[13:23:28.770]                           muffled <- TRUE
[13:23:28.770]                           break
[13:23:28.770]                         }
[13:23:28.770]                       }
[13:23:28.770]                     }
[13:23:28.770]                     invisible(muffled)
[13:23:28.770]                   }
[13:23:28.770]                   muffleCondition(cond)
[13:23:28.770]                 })
[13:23:28.770]             }))
[13:23:28.770]             future::FutureResult(value = ...future.value$value, 
[13:23:28.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.770]                   ...future.rng), globalenv = if (FALSE) 
[13:23:28.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:28.770]                     ...future.globalenv.names))
[13:23:28.770]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:28.770]         }, condition = base::local({
[13:23:28.770]             c <- base::c
[13:23:28.770]             inherits <- base::inherits
[13:23:28.770]             invokeRestart <- base::invokeRestart
[13:23:28.770]             length <- base::length
[13:23:28.770]             list <- base::list
[13:23:28.770]             seq.int <- base::seq.int
[13:23:28.770]             signalCondition <- base::signalCondition
[13:23:28.770]             sys.calls <- base::sys.calls
[13:23:28.770]             `[[` <- base::`[[`
[13:23:28.770]             `+` <- base::`+`
[13:23:28.770]             `<<-` <- base::`<<-`
[13:23:28.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:28.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:28.770]                   3L)]
[13:23:28.770]             }
[13:23:28.770]             function(cond) {
[13:23:28.770]                 is_error <- inherits(cond, "error")
[13:23:28.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:28.770]                   NULL)
[13:23:28.770]                 if (is_error) {
[13:23:28.770]                   sessionInformation <- function() {
[13:23:28.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:28.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:28.770]                       search = base::search(), system = base::Sys.info())
[13:23:28.770]                   }
[13:23:28.770]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:28.770]                     cond$call), session = sessionInformation(), 
[13:23:28.770]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:28.770]                   signalCondition(cond)
[13:23:28.770]                 }
[13:23:28.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:28.770]                 "immediateCondition"))) {
[13:23:28.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:28.770]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:28.770]                   if (TRUE && !signal) {
[13:23:28.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.770]                     {
[13:23:28.770]                       inherits <- base::inherits
[13:23:28.770]                       invokeRestart <- base::invokeRestart
[13:23:28.770]                       is.null <- base::is.null
[13:23:28.770]                       muffled <- FALSE
[13:23:28.770]                       if (inherits(cond, "message")) {
[13:23:28.770]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.770]                         if (muffled) 
[13:23:28.770]                           invokeRestart("muffleMessage")
[13:23:28.770]                       }
[13:23:28.770]                       else if (inherits(cond, "warning")) {
[13:23:28.770]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.770]                         if (muffled) 
[13:23:28.770]                           invokeRestart("muffleWarning")
[13:23:28.770]                       }
[13:23:28.770]                       else if (inherits(cond, "condition")) {
[13:23:28.770]                         if (!is.null(pattern)) {
[13:23:28.770]                           computeRestarts <- base::computeRestarts
[13:23:28.770]                           grepl <- base::grepl
[13:23:28.770]                           restarts <- computeRestarts(cond)
[13:23:28.770]                           for (restart in restarts) {
[13:23:28.770]                             name <- restart$name
[13:23:28.770]                             if (is.null(name)) 
[13:23:28.770]                               next
[13:23:28.770]                             if (!grepl(pattern, name)) 
[13:23:28.770]                               next
[13:23:28.770]                             invokeRestart(restart)
[13:23:28.770]                             muffled <- TRUE
[13:23:28.770]                             break
[13:23:28.770]                           }
[13:23:28.770]                         }
[13:23:28.770]                       }
[13:23:28.770]                       invisible(muffled)
[13:23:28.770]                     }
[13:23:28.770]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.770]                   }
[13:23:28.770]                 }
[13:23:28.770]                 else {
[13:23:28.770]                   if (TRUE) {
[13:23:28.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.770]                     {
[13:23:28.770]                       inherits <- base::inherits
[13:23:28.770]                       invokeRestart <- base::invokeRestart
[13:23:28.770]                       is.null <- base::is.null
[13:23:28.770]                       muffled <- FALSE
[13:23:28.770]                       if (inherits(cond, "message")) {
[13:23:28.770]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.770]                         if (muffled) 
[13:23:28.770]                           invokeRestart("muffleMessage")
[13:23:28.770]                       }
[13:23:28.770]                       else if (inherits(cond, "warning")) {
[13:23:28.770]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.770]                         if (muffled) 
[13:23:28.770]                           invokeRestart("muffleWarning")
[13:23:28.770]                       }
[13:23:28.770]                       else if (inherits(cond, "condition")) {
[13:23:28.770]                         if (!is.null(pattern)) {
[13:23:28.770]                           computeRestarts <- base::computeRestarts
[13:23:28.770]                           grepl <- base::grepl
[13:23:28.770]                           restarts <- computeRestarts(cond)
[13:23:28.770]                           for (restart in restarts) {
[13:23:28.770]                             name <- restart$name
[13:23:28.770]                             if (is.null(name)) 
[13:23:28.770]                               next
[13:23:28.770]                             if (!grepl(pattern, name)) 
[13:23:28.770]                               next
[13:23:28.770]                             invokeRestart(restart)
[13:23:28.770]                             muffled <- TRUE
[13:23:28.770]                             break
[13:23:28.770]                           }
[13:23:28.770]                         }
[13:23:28.770]                       }
[13:23:28.770]                       invisible(muffled)
[13:23:28.770]                     }
[13:23:28.770]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.770]                   }
[13:23:28.770]                 }
[13:23:28.770]             }
[13:23:28.770]         }))
[13:23:28.770]     }, error = function(ex) {
[13:23:28.770]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:28.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.770]                 ...future.rng), started = ...future.startTime, 
[13:23:28.770]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:28.770]             version = "1.8"), class = "FutureResult")
[13:23:28.770]     }, finally = {
[13:23:28.770]         if (!identical(...future.workdir, getwd())) 
[13:23:28.770]             setwd(...future.workdir)
[13:23:28.770]         {
[13:23:28.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:28.770]                 ...future.oldOptions$nwarnings <- NULL
[13:23:28.770]             }
[13:23:28.770]             base::options(...future.oldOptions)
[13:23:28.770]             if (.Platform$OS.type == "windows") {
[13:23:28.770]                 old_names <- names(...future.oldEnvVars)
[13:23:28.770]                 envs <- base::Sys.getenv()
[13:23:28.770]                 names <- names(envs)
[13:23:28.770]                 common <- intersect(names, old_names)
[13:23:28.770]                 added <- setdiff(names, old_names)
[13:23:28.770]                 removed <- setdiff(old_names, names)
[13:23:28.770]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:28.770]                   envs[common]]
[13:23:28.770]                 NAMES <- toupper(changed)
[13:23:28.770]                 args <- list()
[13:23:28.770]                 for (kk in seq_along(NAMES)) {
[13:23:28.770]                   name <- changed[[kk]]
[13:23:28.770]                   NAME <- NAMES[[kk]]
[13:23:28.770]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.770]                     next
[13:23:28.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.770]                 }
[13:23:28.770]                 NAMES <- toupper(added)
[13:23:28.770]                 for (kk in seq_along(NAMES)) {
[13:23:28.770]                   name <- added[[kk]]
[13:23:28.770]                   NAME <- NAMES[[kk]]
[13:23:28.770]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.770]                     next
[13:23:28.770]                   args[[name]] <- ""
[13:23:28.770]                 }
[13:23:28.770]                 NAMES <- toupper(removed)
[13:23:28.770]                 for (kk in seq_along(NAMES)) {
[13:23:28.770]                   name <- removed[[kk]]
[13:23:28.770]                   NAME <- NAMES[[kk]]
[13:23:28.770]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.770]                     next
[13:23:28.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.770]                 }
[13:23:28.770]                 if (length(args) > 0) 
[13:23:28.770]                   base::do.call(base::Sys.setenv, args = args)
[13:23:28.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:28.770]             }
[13:23:28.770]             else {
[13:23:28.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:28.770]             }
[13:23:28.770]             {
[13:23:28.770]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:28.770]                   0L) {
[13:23:28.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:28.770]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:28.770]                   base::options(opts)
[13:23:28.770]                 }
[13:23:28.770]                 {
[13:23:28.770]                   {
[13:23:28.770]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:28.770]                     NULL
[13:23:28.770]                   }
[13:23:28.770]                   options(future.plan = NULL)
[13:23:28.770]                   if (is.na(NA_character_)) 
[13:23:28.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:28.770]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:28.770]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:28.770]                     envir = parent.frame()) 
[13:23:28.770]                   {
[13:23:28.770]                     if (is.function(workers)) 
[13:23:28.770]                       workers <- workers()
[13:23:28.770]                     workers <- structure(as.integer(workers), 
[13:23:28.770]                       class = class(workers))
[13:23:28.770]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:28.770]                       workers >= 1)
[13:23:28.770]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:28.770]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:28.770]                     }
[13:23:28.770]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:28.770]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:28.770]                       envir = envir)
[13:23:28.770]                     if (!future$lazy) 
[13:23:28.770]                       future <- run(future)
[13:23:28.770]                     invisible(future)
[13:23:28.770]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:28.770]                 }
[13:23:28.770]             }
[13:23:28.770]         }
[13:23:28.770]     })
[13:23:28.770]     if (TRUE) {
[13:23:28.770]         base::sink(type = "output", split = FALSE)
[13:23:28.770]         if (TRUE) {
[13:23:28.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:28.770]         }
[13:23:28.770]         else {
[13:23:28.770]             ...future.result["stdout"] <- base::list(NULL)
[13:23:28.770]         }
[13:23:28.770]         base::close(...future.stdout)
[13:23:28.770]         ...future.stdout <- NULL
[13:23:28.770]     }
[13:23:28.770]     ...future.result$conditions <- ...future.conditions
[13:23:28.770]     ...future.result$finished <- base::Sys.time()
[13:23:28.770]     ...future.result
[13:23:28.770] }
[13:23:28.773] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:23:28.773] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:23:28.773] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:23:28.774] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:23:28.774] MultisessionFuture started
[13:23:28.774] - Launch lazy future ... done
[13:23:28.774] run() for ‘MultisessionFuture’ ... done
[13:23:28.774] result() for ClusterFuture ...
[13:23:28.774] receiveMessageFromWorker() for ClusterFuture ...
[13:23:28.775] - Validating connection of MultisessionFuture
[13:23:28.821] - received message: FutureResult
[13:23:28.821] - Received FutureResult
[13:23:28.821] - Erased future from FutureRegistry
[13:23:28.822] result() for ClusterFuture ...
[13:23:28.822] - result already collected: FutureResult
[13:23:28.822] result() for ClusterFuture ... done
[13:23:28.822] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.822] result() for ClusterFuture ... done
[13:23:28.822] result() for ClusterFuture ...
[13:23:28.822] - result already collected: FutureResult
[13:23:28.822] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:28.823] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:28.823] Searching for globals...
[13:23:28.825] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:28.825] Searching for globals ... DONE
[13:23:28.825] Resolving globals: TRUE
[13:23:28.825] Resolving any globals that are futures ...
[13:23:28.826] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:23:28.826] Resolving any globals that are futures ... DONE
[13:23:28.826] Resolving futures part of globals (recursively) ...
[13:23:28.826] resolve() on list ...
[13:23:28.826]  recursive: 99
[13:23:28.827]  length: 1
[13:23:28.827]  elements: ‘x’
[13:23:28.827]  length: 0 (resolved future 1)
[13:23:28.827] resolve() on list ... DONE
[13:23:28.827] - globals: [1] ‘x’
[13:23:28.827] Resolving futures part of globals (recursively) ... DONE
[13:23:28.827] The total size of the 1 globals is 0 bytes (0 bytes)
[13:23:28.828] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:23:28.828] - globals: [1] ‘x’
[13:23:28.828] 
[13:23:28.828] getGlobalsAndPackages() ... DONE
[13:23:28.828] run() for ‘Future’ ...
[13:23:28.828] - state: ‘created’
[13:23:28.828] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:28.843] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:28.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:28.843]   - Field: ‘node’
[13:23:28.843]   - Field: ‘label’
[13:23:28.843]   - Field: ‘local’
[13:23:28.843]   - Field: ‘owner’
[13:23:28.843]   - Field: ‘envir’
[13:23:28.843]   - Field: ‘workers’
[13:23:28.844]   - Field: ‘packages’
[13:23:28.844]   - Field: ‘gc’
[13:23:28.844]   - Field: ‘conditions’
[13:23:28.844]   - Field: ‘persistent’
[13:23:28.844]   - Field: ‘expr’
[13:23:28.844]   - Field: ‘uuid’
[13:23:28.844]   - Field: ‘seed’
[13:23:28.844]   - Field: ‘version’
[13:23:28.844]   - Field: ‘result’
[13:23:28.845]   - Field: ‘asynchronous’
[13:23:28.845]   - Field: ‘calls’
[13:23:28.845]   - Field: ‘globals’
[13:23:28.845]   - Field: ‘stdout’
[13:23:28.845]   - Field: ‘earlySignal’
[13:23:28.845]   - Field: ‘lazy’
[13:23:28.845]   - Field: ‘state’
[13:23:28.845] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:28.845] - Launch lazy future ...
[13:23:28.846] Packages needed by the future expression (n = 0): <none>
[13:23:28.846] Packages needed by future strategies (n = 0): <none>
[13:23:28.846] {
[13:23:28.846]     {
[13:23:28.846]         {
[13:23:28.846]             ...future.startTime <- base::Sys.time()
[13:23:28.846]             {
[13:23:28.846]                 {
[13:23:28.846]                   {
[13:23:28.846]                     {
[13:23:28.846]                       base::local({
[13:23:28.846]                         has_future <- base::requireNamespace("future", 
[13:23:28.846]                           quietly = TRUE)
[13:23:28.846]                         if (has_future) {
[13:23:28.846]                           ns <- base::getNamespace("future")
[13:23:28.846]                           version <- ns[[".package"]][["version"]]
[13:23:28.846]                           if (is.null(version)) 
[13:23:28.846]                             version <- utils::packageVersion("future")
[13:23:28.846]                         }
[13:23:28.846]                         else {
[13:23:28.846]                           version <- NULL
[13:23:28.846]                         }
[13:23:28.846]                         if (!has_future || version < "1.8.0") {
[13:23:28.846]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:28.846]                             "", base::R.version$version.string), 
[13:23:28.846]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:28.846]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:28.846]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:28.846]                               "release", "version")], collapse = " "), 
[13:23:28.846]                             hostname = base::Sys.info()[["nodename"]])
[13:23:28.846]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:28.846]                             info)
[13:23:28.846]                           info <- base::paste(info, collapse = "; ")
[13:23:28.846]                           if (!has_future) {
[13:23:28.846]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:28.846]                               info)
[13:23:28.846]                           }
[13:23:28.846]                           else {
[13:23:28.846]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:28.846]                               info, version)
[13:23:28.846]                           }
[13:23:28.846]                           base::stop(msg)
[13:23:28.846]                         }
[13:23:28.846]                       })
[13:23:28.846]                     }
[13:23:28.846]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:28.846]                     base::options(mc.cores = 1L)
[13:23:28.846]                   }
[13:23:28.846]                   options(future.plan = NULL)
[13:23:28.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.846]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:28.846]                 }
[13:23:28.846]                 ...future.workdir <- getwd()
[13:23:28.846]             }
[13:23:28.846]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:28.846]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:28.846]         }
[13:23:28.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:28.846]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:28.846]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:28.846]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:28.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:28.846]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:28.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:28.846]             base::names(...future.oldOptions))
[13:23:28.846]     }
[13:23:28.846]     if (FALSE) {
[13:23:28.846]     }
[13:23:28.846]     else {
[13:23:28.846]         if (TRUE) {
[13:23:28.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:28.846]                 open = "w")
[13:23:28.846]         }
[13:23:28.846]         else {
[13:23:28.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:28.846]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:28.846]         }
[13:23:28.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:28.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:28.846]             base::sink(type = "output", split = FALSE)
[13:23:28.846]             base::close(...future.stdout)
[13:23:28.846]         }, add = TRUE)
[13:23:28.846]     }
[13:23:28.846]     ...future.frame <- base::sys.nframe()
[13:23:28.846]     ...future.conditions <- base::list()
[13:23:28.846]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:28.846]     if (FALSE) {
[13:23:28.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:28.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:28.846]     }
[13:23:28.846]     ...future.result <- base::tryCatch({
[13:23:28.846]         base::withCallingHandlers({
[13:23:28.846]             ...future.value <- base::withVisible(base::local({
[13:23:28.846]                 ...future.makeSendCondition <- base::local({
[13:23:28.846]                   sendCondition <- NULL
[13:23:28.846]                   function(frame = 1L) {
[13:23:28.846]                     if (is.function(sendCondition)) 
[13:23:28.846]                       return(sendCondition)
[13:23:28.846]                     ns <- getNamespace("parallel")
[13:23:28.846]                     if (exists("sendData", mode = "function", 
[13:23:28.846]                       envir = ns)) {
[13:23:28.846]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:28.846]                         envir = ns)
[13:23:28.846]                       envir <- sys.frame(frame)
[13:23:28.846]                       master <- NULL
[13:23:28.846]                       while (!identical(envir, .GlobalEnv) && 
[13:23:28.846]                         !identical(envir, emptyenv())) {
[13:23:28.846]                         if (exists("master", mode = "list", envir = envir, 
[13:23:28.846]                           inherits = FALSE)) {
[13:23:28.846]                           master <- get("master", mode = "list", 
[13:23:28.846]                             envir = envir, inherits = FALSE)
[13:23:28.846]                           if (inherits(master, c("SOCKnode", 
[13:23:28.846]                             "SOCK0node"))) {
[13:23:28.846]                             sendCondition <<- function(cond) {
[13:23:28.846]                               data <- list(type = "VALUE", value = cond, 
[13:23:28.846]                                 success = TRUE)
[13:23:28.846]                               parallel_sendData(master, data)
[13:23:28.846]                             }
[13:23:28.846]                             return(sendCondition)
[13:23:28.846]                           }
[13:23:28.846]                         }
[13:23:28.846]                         frame <- frame + 1L
[13:23:28.846]                         envir <- sys.frame(frame)
[13:23:28.846]                       }
[13:23:28.846]                     }
[13:23:28.846]                     sendCondition <<- function(cond) NULL
[13:23:28.846]                   }
[13:23:28.846]                 })
[13:23:28.846]                 withCallingHandlers({
[13:23:28.846]                   {
[13:23:28.846]                     x["a"] <- list(1)
[13:23:28.846]                     x
[13:23:28.846]                   }
[13:23:28.846]                 }, immediateCondition = function(cond) {
[13:23:28.846]                   sendCondition <- ...future.makeSendCondition()
[13:23:28.846]                   sendCondition(cond)
[13:23:28.846]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.846]                   {
[13:23:28.846]                     inherits <- base::inherits
[13:23:28.846]                     invokeRestart <- base::invokeRestart
[13:23:28.846]                     is.null <- base::is.null
[13:23:28.846]                     muffled <- FALSE
[13:23:28.846]                     if (inherits(cond, "message")) {
[13:23:28.846]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:28.846]                       if (muffled) 
[13:23:28.846]                         invokeRestart("muffleMessage")
[13:23:28.846]                     }
[13:23:28.846]                     else if (inherits(cond, "warning")) {
[13:23:28.846]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:28.846]                       if (muffled) 
[13:23:28.846]                         invokeRestart("muffleWarning")
[13:23:28.846]                     }
[13:23:28.846]                     else if (inherits(cond, "condition")) {
[13:23:28.846]                       if (!is.null(pattern)) {
[13:23:28.846]                         computeRestarts <- base::computeRestarts
[13:23:28.846]                         grepl <- base::grepl
[13:23:28.846]                         restarts <- computeRestarts(cond)
[13:23:28.846]                         for (restart in restarts) {
[13:23:28.846]                           name <- restart$name
[13:23:28.846]                           if (is.null(name)) 
[13:23:28.846]                             next
[13:23:28.846]                           if (!grepl(pattern, name)) 
[13:23:28.846]                             next
[13:23:28.846]                           invokeRestart(restart)
[13:23:28.846]                           muffled <- TRUE
[13:23:28.846]                           break
[13:23:28.846]                         }
[13:23:28.846]                       }
[13:23:28.846]                     }
[13:23:28.846]                     invisible(muffled)
[13:23:28.846]                   }
[13:23:28.846]                   muffleCondition(cond)
[13:23:28.846]                 })
[13:23:28.846]             }))
[13:23:28.846]             future::FutureResult(value = ...future.value$value, 
[13:23:28.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.846]                   ...future.rng), globalenv = if (FALSE) 
[13:23:28.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:28.846]                     ...future.globalenv.names))
[13:23:28.846]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:28.846]         }, condition = base::local({
[13:23:28.846]             c <- base::c
[13:23:28.846]             inherits <- base::inherits
[13:23:28.846]             invokeRestart <- base::invokeRestart
[13:23:28.846]             length <- base::length
[13:23:28.846]             list <- base::list
[13:23:28.846]             seq.int <- base::seq.int
[13:23:28.846]             signalCondition <- base::signalCondition
[13:23:28.846]             sys.calls <- base::sys.calls
[13:23:28.846]             `[[` <- base::`[[`
[13:23:28.846]             `+` <- base::`+`
[13:23:28.846]             `<<-` <- base::`<<-`
[13:23:28.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:28.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:28.846]                   3L)]
[13:23:28.846]             }
[13:23:28.846]             function(cond) {
[13:23:28.846]                 is_error <- inherits(cond, "error")
[13:23:28.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:28.846]                   NULL)
[13:23:28.846]                 if (is_error) {
[13:23:28.846]                   sessionInformation <- function() {
[13:23:28.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:28.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:28.846]                       search = base::search(), system = base::Sys.info())
[13:23:28.846]                   }
[13:23:28.846]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:28.846]                     cond$call), session = sessionInformation(), 
[13:23:28.846]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:28.846]                   signalCondition(cond)
[13:23:28.846]                 }
[13:23:28.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:28.846]                 "immediateCondition"))) {
[13:23:28.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:28.846]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:28.846]                   if (TRUE && !signal) {
[13:23:28.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.846]                     {
[13:23:28.846]                       inherits <- base::inherits
[13:23:28.846]                       invokeRestart <- base::invokeRestart
[13:23:28.846]                       is.null <- base::is.null
[13:23:28.846]                       muffled <- FALSE
[13:23:28.846]                       if (inherits(cond, "message")) {
[13:23:28.846]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.846]                         if (muffled) 
[13:23:28.846]                           invokeRestart("muffleMessage")
[13:23:28.846]                       }
[13:23:28.846]                       else if (inherits(cond, "warning")) {
[13:23:28.846]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.846]                         if (muffled) 
[13:23:28.846]                           invokeRestart("muffleWarning")
[13:23:28.846]                       }
[13:23:28.846]                       else if (inherits(cond, "condition")) {
[13:23:28.846]                         if (!is.null(pattern)) {
[13:23:28.846]                           computeRestarts <- base::computeRestarts
[13:23:28.846]                           grepl <- base::grepl
[13:23:28.846]                           restarts <- computeRestarts(cond)
[13:23:28.846]                           for (restart in restarts) {
[13:23:28.846]                             name <- restart$name
[13:23:28.846]                             if (is.null(name)) 
[13:23:28.846]                               next
[13:23:28.846]                             if (!grepl(pattern, name)) 
[13:23:28.846]                               next
[13:23:28.846]                             invokeRestart(restart)
[13:23:28.846]                             muffled <- TRUE
[13:23:28.846]                             break
[13:23:28.846]                           }
[13:23:28.846]                         }
[13:23:28.846]                       }
[13:23:28.846]                       invisible(muffled)
[13:23:28.846]                     }
[13:23:28.846]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.846]                   }
[13:23:28.846]                 }
[13:23:28.846]                 else {
[13:23:28.846]                   if (TRUE) {
[13:23:28.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.846]                     {
[13:23:28.846]                       inherits <- base::inherits
[13:23:28.846]                       invokeRestart <- base::invokeRestart
[13:23:28.846]                       is.null <- base::is.null
[13:23:28.846]                       muffled <- FALSE
[13:23:28.846]                       if (inherits(cond, "message")) {
[13:23:28.846]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.846]                         if (muffled) 
[13:23:28.846]                           invokeRestart("muffleMessage")
[13:23:28.846]                       }
[13:23:28.846]                       else if (inherits(cond, "warning")) {
[13:23:28.846]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.846]                         if (muffled) 
[13:23:28.846]                           invokeRestart("muffleWarning")
[13:23:28.846]                       }
[13:23:28.846]                       else if (inherits(cond, "condition")) {
[13:23:28.846]                         if (!is.null(pattern)) {
[13:23:28.846]                           computeRestarts <- base::computeRestarts
[13:23:28.846]                           grepl <- base::grepl
[13:23:28.846]                           restarts <- computeRestarts(cond)
[13:23:28.846]                           for (restart in restarts) {
[13:23:28.846]                             name <- restart$name
[13:23:28.846]                             if (is.null(name)) 
[13:23:28.846]                               next
[13:23:28.846]                             if (!grepl(pattern, name)) 
[13:23:28.846]                               next
[13:23:28.846]                             invokeRestart(restart)
[13:23:28.846]                             muffled <- TRUE
[13:23:28.846]                             break
[13:23:28.846]                           }
[13:23:28.846]                         }
[13:23:28.846]                       }
[13:23:28.846]                       invisible(muffled)
[13:23:28.846]                     }
[13:23:28.846]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.846]                   }
[13:23:28.846]                 }
[13:23:28.846]             }
[13:23:28.846]         }))
[13:23:28.846]     }, error = function(ex) {
[13:23:28.846]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:28.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.846]                 ...future.rng), started = ...future.startTime, 
[13:23:28.846]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:28.846]             version = "1.8"), class = "FutureResult")
[13:23:28.846]     }, finally = {
[13:23:28.846]         if (!identical(...future.workdir, getwd())) 
[13:23:28.846]             setwd(...future.workdir)
[13:23:28.846]         {
[13:23:28.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:28.846]                 ...future.oldOptions$nwarnings <- NULL
[13:23:28.846]             }
[13:23:28.846]             base::options(...future.oldOptions)
[13:23:28.846]             if (.Platform$OS.type == "windows") {
[13:23:28.846]                 old_names <- names(...future.oldEnvVars)
[13:23:28.846]                 envs <- base::Sys.getenv()
[13:23:28.846]                 names <- names(envs)
[13:23:28.846]                 common <- intersect(names, old_names)
[13:23:28.846]                 added <- setdiff(names, old_names)
[13:23:28.846]                 removed <- setdiff(old_names, names)
[13:23:28.846]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:28.846]                   envs[common]]
[13:23:28.846]                 NAMES <- toupper(changed)
[13:23:28.846]                 args <- list()
[13:23:28.846]                 for (kk in seq_along(NAMES)) {
[13:23:28.846]                   name <- changed[[kk]]
[13:23:28.846]                   NAME <- NAMES[[kk]]
[13:23:28.846]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.846]                     next
[13:23:28.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.846]                 }
[13:23:28.846]                 NAMES <- toupper(added)
[13:23:28.846]                 for (kk in seq_along(NAMES)) {
[13:23:28.846]                   name <- added[[kk]]
[13:23:28.846]                   NAME <- NAMES[[kk]]
[13:23:28.846]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.846]                     next
[13:23:28.846]                   args[[name]] <- ""
[13:23:28.846]                 }
[13:23:28.846]                 NAMES <- toupper(removed)
[13:23:28.846]                 for (kk in seq_along(NAMES)) {
[13:23:28.846]                   name <- removed[[kk]]
[13:23:28.846]                   NAME <- NAMES[[kk]]
[13:23:28.846]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.846]                     next
[13:23:28.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.846]                 }
[13:23:28.846]                 if (length(args) > 0) 
[13:23:28.846]                   base::do.call(base::Sys.setenv, args = args)
[13:23:28.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:28.846]             }
[13:23:28.846]             else {
[13:23:28.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:28.846]             }
[13:23:28.846]             {
[13:23:28.846]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:28.846]                   0L) {
[13:23:28.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:28.846]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:28.846]                   base::options(opts)
[13:23:28.846]                 }
[13:23:28.846]                 {
[13:23:28.846]                   {
[13:23:28.846]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:28.846]                     NULL
[13:23:28.846]                   }
[13:23:28.846]                   options(future.plan = NULL)
[13:23:28.846]                   if (is.na(NA_character_)) 
[13:23:28.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:28.846]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:28.846]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:28.846]                     envir = parent.frame()) 
[13:23:28.846]                   {
[13:23:28.846]                     if (is.function(workers)) 
[13:23:28.846]                       workers <- workers()
[13:23:28.846]                     workers <- structure(as.integer(workers), 
[13:23:28.846]                       class = class(workers))
[13:23:28.846]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:28.846]                       workers >= 1)
[13:23:28.846]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:28.846]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:28.846]                     }
[13:23:28.846]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:28.846]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:28.846]                       envir = envir)
[13:23:28.846]                     if (!future$lazy) 
[13:23:28.846]                       future <- run(future)
[13:23:28.846]                     invisible(future)
[13:23:28.846]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:28.846]                 }
[13:23:28.846]             }
[13:23:28.846]         }
[13:23:28.846]     })
[13:23:28.846]     if (TRUE) {
[13:23:28.846]         base::sink(type = "output", split = FALSE)
[13:23:28.846]         if (TRUE) {
[13:23:28.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:28.846]         }
[13:23:28.846]         else {
[13:23:28.846]             ...future.result["stdout"] <- base::list(NULL)
[13:23:28.846]         }
[13:23:28.846]         base::close(...future.stdout)
[13:23:28.846]         ...future.stdout <- NULL
[13:23:28.846]     }
[13:23:28.846]     ...future.result$conditions <- ...future.conditions
[13:23:28.846]     ...future.result$finished <- base::Sys.time()
[13:23:28.846]     ...future.result
[13:23:28.846] }
[13:23:28.849] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:23:28.849] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:23:28.850] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:23:28.850] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:23:28.850] MultisessionFuture started
[13:23:28.850] - Launch lazy future ... done
[13:23:28.851] run() for ‘MultisessionFuture’ ... done
[13:23:28.851] result() for ClusterFuture ...
[13:23:28.851] receiveMessageFromWorker() for ClusterFuture ...
[13:23:28.851] - Validating connection of MultisessionFuture
[13:23:28.897] - received message: FutureResult
[13:23:28.898] - Received FutureResult
[13:23:28.898] - Erased future from FutureRegistry
[13:23:28.898] result() for ClusterFuture ...
[13:23:28.898] - result already collected: FutureResult
[13:23:28.898] result() for ClusterFuture ... done
[13:23:28.898] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.898] result() for ClusterFuture ... done
[13:23:28.899] result() for ClusterFuture ...
[13:23:28.899] - result already collected: FutureResult
[13:23:28.899] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:28.899] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:28.900] Searching for globals...
[13:23:28.902] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[13:23:28.902] Searching for globals ... DONE
[13:23:28.902] Resolving globals: TRUE
[13:23:28.902] Resolving any globals that are futures ...
[13:23:28.902] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[13:23:28.902] Resolving any globals that are futures ... DONE
[13:23:28.903] Resolving futures part of globals (recursively) ...
[13:23:28.903] resolve() on list ...
[13:23:28.903]  recursive: 99
[13:23:28.903]  length: 2
[13:23:28.903]  elements: ‘x’, ‘name’
[13:23:28.903]  length: 1 (resolved future 1)
[13:23:28.904]  length: 0 (resolved future 2)
[13:23:28.904] resolve() on list ... DONE
[13:23:28.904] - globals: [2] ‘x’, ‘name’
[13:23:28.904] Resolving futures part of globals (recursively) ... DONE
[13:23:28.904] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:28.905] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[13:23:28.905] - globals: [2] ‘x’, ‘name’
[13:23:28.905] 
[13:23:28.905] getGlobalsAndPackages() ... DONE
[13:23:28.905] run() for ‘Future’ ...
[13:23:28.905] - state: ‘created’
[13:23:28.905] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:28.919] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:28.919] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:28.920]   - Field: ‘node’
[13:23:28.920]   - Field: ‘label’
[13:23:28.920]   - Field: ‘local’
[13:23:28.920]   - Field: ‘owner’
[13:23:28.920]   - Field: ‘envir’
[13:23:28.920]   - Field: ‘workers’
[13:23:28.920]   - Field: ‘packages’
[13:23:28.920]   - Field: ‘gc’
[13:23:28.920]   - Field: ‘conditions’
[13:23:28.921]   - Field: ‘persistent’
[13:23:28.921]   - Field: ‘expr’
[13:23:28.921]   - Field: ‘uuid’
[13:23:28.921]   - Field: ‘seed’
[13:23:28.921]   - Field: ‘version’
[13:23:28.921]   - Field: ‘result’
[13:23:28.921]   - Field: ‘asynchronous’
[13:23:28.921]   - Field: ‘calls’
[13:23:28.921]   - Field: ‘globals’
[13:23:28.921]   - Field: ‘stdout’
[13:23:28.921]   - Field: ‘earlySignal’
[13:23:28.922]   - Field: ‘lazy’
[13:23:28.922]   - Field: ‘state’
[13:23:28.922] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:28.922] - Launch lazy future ...
[13:23:28.922] Packages needed by the future expression (n = 0): <none>
[13:23:28.922] Packages needed by future strategies (n = 0): <none>
[13:23:28.923] {
[13:23:28.923]     {
[13:23:28.923]         {
[13:23:28.923]             ...future.startTime <- base::Sys.time()
[13:23:28.923]             {
[13:23:28.923]                 {
[13:23:28.923]                   {
[13:23:28.923]                     {
[13:23:28.923]                       base::local({
[13:23:28.923]                         has_future <- base::requireNamespace("future", 
[13:23:28.923]                           quietly = TRUE)
[13:23:28.923]                         if (has_future) {
[13:23:28.923]                           ns <- base::getNamespace("future")
[13:23:28.923]                           version <- ns[[".package"]][["version"]]
[13:23:28.923]                           if (is.null(version)) 
[13:23:28.923]                             version <- utils::packageVersion("future")
[13:23:28.923]                         }
[13:23:28.923]                         else {
[13:23:28.923]                           version <- NULL
[13:23:28.923]                         }
[13:23:28.923]                         if (!has_future || version < "1.8.0") {
[13:23:28.923]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:28.923]                             "", base::R.version$version.string), 
[13:23:28.923]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:28.923]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:28.923]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:28.923]                               "release", "version")], collapse = " "), 
[13:23:28.923]                             hostname = base::Sys.info()[["nodename"]])
[13:23:28.923]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:28.923]                             info)
[13:23:28.923]                           info <- base::paste(info, collapse = "; ")
[13:23:28.923]                           if (!has_future) {
[13:23:28.923]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:28.923]                               info)
[13:23:28.923]                           }
[13:23:28.923]                           else {
[13:23:28.923]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:28.923]                               info, version)
[13:23:28.923]                           }
[13:23:28.923]                           base::stop(msg)
[13:23:28.923]                         }
[13:23:28.923]                       })
[13:23:28.923]                     }
[13:23:28.923]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:28.923]                     base::options(mc.cores = 1L)
[13:23:28.923]                   }
[13:23:28.923]                   options(future.plan = NULL)
[13:23:28.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:28.923]                 }
[13:23:28.923]                 ...future.workdir <- getwd()
[13:23:28.923]             }
[13:23:28.923]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:28.923]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:28.923]         }
[13:23:28.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:28.923]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:28.923]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:28.923]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:28.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:28.923]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:28.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:28.923]             base::names(...future.oldOptions))
[13:23:28.923]     }
[13:23:28.923]     if (FALSE) {
[13:23:28.923]     }
[13:23:28.923]     else {
[13:23:28.923]         if (TRUE) {
[13:23:28.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:28.923]                 open = "w")
[13:23:28.923]         }
[13:23:28.923]         else {
[13:23:28.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:28.923]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:28.923]         }
[13:23:28.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:28.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:28.923]             base::sink(type = "output", split = FALSE)
[13:23:28.923]             base::close(...future.stdout)
[13:23:28.923]         }, add = TRUE)
[13:23:28.923]     }
[13:23:28.923]     ...future.frame <- base::sys.nframe()
[13:23:28.923]     ...future.conditions <- base::list()
[13:23:28.923]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:28.923]     if (FALSE) {
[13:23:28.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:28.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:28.923]     }
[13:23:28.923]     ...future.result <- base::tryCatch({
[13:23:28.923]         base::withCallingHandlers({
[13:23:28.923]             ...future.value <- base::withVisible(base::local({
[13:23:28.923]                 ...future.makeSendCondition <- base::local({
[13:23:28.923]                   sendCondition <- NULL
[13:23:28.923]                   function(frame = 1L) {
[13:23:28.923]                     if (is.function(sendCondition)) 
[13:23:28.923]                       return(sendCondition)
[13:23:28.923]                     ns <- getNamespace("parallel")
[13:23:28.923]                     if (exists("sendData", mode = "function", 
[13:23:28.923]                       envir = ns)) {
[13:23:28.923]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:28.923]                         envir = ns)
[13:23:28.923]                       envir <- sys.frame(frame)
[13:23:28.923]                       master <- NULL
[13:23:28.923]                       while (!identical(envir, .GlobalEnv) && 
[13:23:28.923]                         !identical(envir, emptyenv())) {
[13:23:28.923]                         if (exists("master", mode = "list", envir = envir, 
[13:23:28.923]                           inherits = FALSE)) {
[13:23:28.923]                           master <- get("master", mode = "list", 
[13:23:28.923]                             envir = envir, inherits = FALSE)
[13:23:28.923]                           if (inherits(master, c("SOCKnode", 
[13:23:28.923]                             "SOCK0node"))) {
[13:23:28.923]                             sendCondition <<- function(cond) {
[13:23:28.923]                               data <- list(type = "VALUE", value = cond, 
[13:23:28.923]                                 success = TRUE)
[13:23:28.923]                               parallel_sendData(master, data)
[13:23:28.923]                             }
[13:23:28.923]                             return(sendCondition)
[13:23:28.923]                           }
[13:23:28.923]                         }
[13:23:28.923]                         frame <- frame + 1L
[13:23:28.923]                         envir <- sys.frame(frame)
[13:23:28.923]                       }
[13:23:28.923]                     }
[13:23:28.923]                     sendCondition <<- function(cond) NULL
[13:23:28.923]                   }
[13:23:28.923]                 })
[13:23:28.923]                 withCallingHandlers({
[13:23:28.923]                   {
[13:23:28.923]                     x[name] <- list(1)
[13:23:28.923]                     x
[13:23:28.923]                   }
[13:23:28.923]                 }, immediateCondition = function(cond) {
[13:23:28.923]                   sendCondition <- ...future.makeSendCondition()
[13:23:28.923]                   sendCondition(cond)
[13:23:28.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.923]                   {
[13:23:28.923]                     inherits <- base::inherits
[13:23:28.923]                     invokeRestart <- base::invokeRestart
[13:23:28.923]                     is.null <- base::is.null
[13:23:28.923]                     muffled <- FALSE
[13:23:28.923]                     if (inherits(cond, "message")) {
[13:23:28.923]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:28.923]                       if (muffled) 
[13:23:28.923]                         invokeRestart("muffleMessage")
[13:23:28.923]                     }
[13:23:28.923]                     else if (inherits(cond, "warning")) {
[13:23:28.923]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:28.923]                       if (muffled) 
[13:23:28.923]                         invokeRestart("muffleWarning")
[13:23:28.923]                     }
[13:23:28.923]                     else if (inherits(cond, "condition")) {
[13:23:28.923]                       if (!is.null(pattern)) {
[13:23:28.923]                         computeRestarts <- base::computeRestarts
[13:23:28.923]                         grepl <- base::grepl
[13:23:28.923]                         restarts <- computeRestarts(cond)
[13:23:28.923]                         for (restart in restarts) {
[13:23:28.923]                           name <- restart$name
[13:23:28.923]                           if (is.null(name)) 
[13:23:28.923]                             next
[13:23:28.923]                           if (!grepl(pattern, name)) 
[13:23:28.923]                             next
[13:23:28.923]                           invokeRestart(restart)
[13:23:28.923]                           muffled <- TRUE
[13:23:28.923]                           break
[13:23:28.923]                         }
[13:23:28.923]                       }
[13:23:28.923]                     }
[13:23:28.923]                     invisible(muffled)
[13:23:28.923]                   }
[13:23:28.923]                   muffleCondition(cond)
[13:23:28.923]                 })
[13:23:28.923]             }))
[13:23:28.923]             future::FutureResult(value = ...future.value$value, 
[13:23:28.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.923]                   ...future.rng), globalenv = if (FALSE) 
[13:23:28.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:28.923]                     ...future.globalenv.names))
[13:23:28.923]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:28.923]         }, condition = base::local({
[13:23:28.923]             c <- base::c
[13:23:28.923]             inherits <- base::inherits
[13:23:28.923]             invokeRestart <- base::invokeRestart
[13:23:28.923]             length <- base::length
[13:23:28.923]             list <- base::list
[13:23:28.923]             seq.int <- base::seq.int
[13:23:28.923]             signalCondition <- base::signalCondition
[13:23:28.923]             sys.calls <- base::sys.calls
[13:23:28.923]             `[[` <- base::`[[`
[13:23:28.923]             `+` <- base::`+`
[13:23:28.923]             `<<-` <- base::`<<-`
[13:23:28.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:28.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:28.923]                   3L)]
[13:23:28.923]             }
[13:23:28.923]             function(cond) {
[13:23:28.923]                 is_error <- inherits(cond, "error")
[13:23:28.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:28.923]                   NULL)
[13:23:28.923]                 if (is_error) {
[13:23:28.923]                   sessionInformation <- function() {
[13:23:28.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:28.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:28.923]                       search = base::search(), system = base::Sys.info())
[13:23:28.923]                   }
[13:23:28.923]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:28.923]                     cond$call), session = sessionInformation(), 
[13:23:28.923]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:28.923]                   signalCondition(cond)
[13:23:28.923]                 }
[13:23:28.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:28.923]                 "immediateCondition"))) {
[13:23:28.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:28.923]                   ...future.conditions[[length(...future.conditions) + 
[13:23:28.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:28.923]                   if (TRUE && !signal) {
[13:23:28.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.923]                     {
[13:23:28.923]                       inherits <- base::inherits
[13:23:28.923]                       invokeRestart <- base::invokeRestart
[13:23:28.923]                       is.null <- base::is.null
[13:23:28.923]                       muffled <- FALSE
[13:23:28.923]                       if (inherits(cond, "message")) {
[13:23:28.923]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.923]                         if (muffled) 
[13:23:28.923]                           invokeRestart("muffleMessage")
[13:23:28.923]                       }
[13:23:28.923]                       else if (inherits(cond, "warning")) {
[13:23:28.923]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.923]                         if (muffled) 
[13:23:28.923]                           invokeRestart("muffleWarning")
[13:23:28.923]                       }
[13:23:28.923]                       else if (inherits(cond, "condition")) {
[13:23:28.923]                         if (!is.null(pattern)) {
[13:23:28.923]                           computeRestarts <- base::computeRestarts
[13:23:28.923]                           grepl <- base::grepl
[13:23:28.923]                           restarts <- computeRestarts(cond)
[13:23:28.923]                           for (restart in restarts) {
[13:23:28.923]                             name <- restart$name
[13:23:28.923]                             if (is.null(name)) 
[13:23:28.923]                               next
[13:23:28.923]                             if (!grepl(pattern, name)) 
[13:23:28.923]                               next
[13:23:28.923]                             invokeRestart(restart)
[13:23:28.923]                             muffled <- TRUE
[13:23:28.923]                             break
[13:23:28.923]                           }
[13:23:28.923]                         }
[13:23:28.923]                       }
[13:23:28.923]                       invisible(muffled)
[13:23:28.923]                     }
[13:23:28.923]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.923]                   }
[13:23:28.923]                 }
[13:23:28.923]                 else {
[13:23:28.923]                   if (TRUE) {
[13:23:28.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:28.923]                     {
[13:23:28.923]                       inherits <- base::inherits
[13:23:28.923]                       invokeRestart <- base::invokeRestart
[13:23:28.923]                       is.null <- base::is.null
[13:23:28.923]                       muffled <- FALSE
[13:23:28.923]                       if (inherits(cond, "message")) {
[13:23:28.923]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:28.923]                         if (muffled) 
[13:23:28.923]                           invokeRestart("muffleMessage")
[13:23:28.923]                       }
[13:23:28.923]                       else if (inherits(cond, "warning")) {
[13:23:28.923]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:28.923]                         if (muffled) 
[13:23:28.923]                           invokeRestart("muffleWarning")
[13:23:28.923]                       }
[13:23:28.923]                       else if (inherits(cond, "condition")) {
[13:23:28.923]                         if (!is.null(pattern)) {
[13:23:28.923]                           computeRestarts <- base::computeRestarts
[13:23:28.923]                           grepl <- base::grepl
[13:23:28.923]                           restarts <- computeRestarts(cond)
[13:23:28.923]                           for (restart in restarts) {
[13:23:28.923]                             name <- restart$name
[13:23:28.923]                             if (is.null(name)) 
[13:23:28.923]                               next
[13:23:28.923]                             if (!grepl(pattern, name)) 
[13:23:28.923]                               next
[13:23:28.923]                             invokeRestart(restart)
[13:23:28.923]                             muffled <- TRUE
[13:23:28.923]                             break
[13:23:28.923]                           }
[13:23:28.923]                         }
[13:23:28.923]                       }
[13:23:28.923]                       invisible(muffled)
[13:23:28.923]                     }
[13:23:28.923]                     muffleCondition(cond, pattern = "^muffle")
[13:23:28.923]                   }
[13:23:28.923]                 }
[13:23:28.923]             }
[13:23:28.923]         }))
[13:23:28.923]     }, error = function(ex) {
[13:23:28.923]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:28.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:28.923]                 ...future.rng), started = ...future.startTime, 
[13:23:28.923]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:28.923]             version = "1.8"), class = "FutureResult")
[13:23:28.923]     }, finally = {
[13:23:28.923]         if (!identical(...future.workdir, getwd())) 
[13:23:28.923]             setwd(...future.workdir)
[13:23:28.923]         {
[13:23:28.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:28.923]                 ...future.oldOptions$nwarnings <- NULL
[13:23:28.923]             }
[13:23:28.923]             base::options(...future.oldOptions)
[13:23:28.923]             if (.Platform$OS.type == "windows") {
[13:23:28.923]                 old_names <- names(...future.oldEnvVars)
[13:23:28.923]                 envs <- base::Sys.getenv()
[13:23:28.923]                 names <- names(envs)
[13:23:28.923]                 common <- intersect(names, old_names)
[13:23:28.923]                 added <- setdiff(names, old_names)
[13:23:28.923]                 removed <- setdiff(old_names, names)
[13:23:28.923]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:28.923]                   envs[common]]
[13:23:28.923]                 NAMES <- toupper(changed)
[13:23:28.923]                 args <- list()
[13:23:28.923]                 for (kk in seq_along(NAMES)) {
[13:23:28.923]                   name <- changed[[kk]]
[13:23:28.923]                   NAME <- NAMES[[kk]]
[13:23:28.923]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.923]                     next
[13:23:28.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.923]                 }
[13:23:28.923]                 NAMES <- toupper(added)
[13:23:28.923]                 for (kk in seq_along(NAMES)) {
[13:23:28.923]                   name <- added[[kk]]
[13:23:28.923]                   NAME <- NAMES[[kk]]
[13:23:28.923]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.923]                     next
[13:23:28.923]                   args[[name]] <- ""
[13:23:28.923]                 }
[13:23:28.923]                 NAMES <- toupper(removed)
[13:23:28.923]                 for (kk in seq_along(NAMES)) {
[13:23:28.923]                   name <- removed[[kk]]
[13:23:28.923]                   NAME <- NAMES[[kk]]
[13:23:28.923]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:28.923]                     next
[13:23:28.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:28.923]                 }
[13:23:28.923]                 if (length(args) > 0) 
[13:23:28.923]                   base::do.call(base::Sys.setenv, args = args)
[13:23:28.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:28.923]             }
[13:23:28.923]             else {
[13:23:28.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:28.923]             }
[13:23:28.923]             {
[13:23:28.923]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:28.923]                   0L) {
[13:23:28.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:28.923]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:28.923]                   base::options(opts)
[13:23:28.923]                 }
[13:23:28.923]                 {
[13:23:28.923]                   {
[13:23:28.923]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:28.923]                     NULL
[13:23:28.923]                   }
[13:23:28.923]                   options(future.plan = NULL)
[13:23:28.923]                   if (is.na(NA_character_)) 
[13:23:28.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:28.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:28.923]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:28.923]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:28.923]                     envir = parent.frame()) 
[13:23:28.923]                   {
[13:23:28.923]                     if (is.function(workers)) 
[13:23:28.923]                       workers <- workers()
[13:23:28.923]                     workers <- structure(as.integer(workers), 
[13:23:28.923]                       class = class(workers))
[13:23:28.923]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:28.923]                       workers >= 1)
[13:23:28.923]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:28.923]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:28.923]                     }
[13:23:28.923]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:28.923]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:28.923]                       envir = envir)
[13:23:28.923]                     if (!future$lazy) 
[13:23:28.923]                       future <- run(future)
[13:23:28.923]                     invisible(future)
[13:23:28.923]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:28.923]                 }
[13:23:28.923]             }
[13:23:28.923]         }
[13:23:28.923]     })
[13:23:28.923]     if (TRUE) {
[13:23:28.923]         base::sink(type = "output", split = FALSE)
[13:23:28.923]         if (TRUE) {
[13:23:28.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:28.923]         }
[13:23:28.923]         else {
[13:23:28.923]             ...future.result["stdout"] <- base::list(NULL)
[13:23:28.923]         }
[13:23:28.923]         base::close(...future.stdout)
[13:23:28.923]         ...future.stdout <- NULL
[13:23:28.923]     }
[13:23:28.923]     ...future.result$conditions <- ...future.conditions
[13:23:28.923]     ...future.result$finished <- base::Sys.time()
[13:23:28.923]     ...future.result
[13:23:28.923] }
[13:23:28.926] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:23:28.926] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:23:28.928] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:23:28.928] Exporting ‘name’ (112 bytes) to cluster node #1 ...
[13:23:28.929] Exporting ‘name’ (112 bytes) to cluster node #1 ... DONE
[13:23:28.929] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:23:28.929] MultisessionFuture started
[13:23:28.929] - Launch lazy future ... done
[13:23:28.930] run() for ‘MultisessionFuture’ ... done
[13:23:28.930] result() for ClusterFuture ...
[13:23:28.930] receiveMessageFromWorker() for ClusterFuture ...
[13:23:28.930] - Validating connection of MultisessionFuture
[13:23:28.977] - received message: FutureResult
[13:23:28.977] - Received FutureResult
[13:23:28.978] - Erased future from FutureRegistry
[13:23:28.978] result() for ClusterFuture ...
[13:23:28.978] - result already collected: FutureResult
[13:23:28.978] result() for ClusterFuture ... done
[13:23:28.978] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:28.978] result() for ClusterFuture ... done
[13:23:28.978] result() for ClusterFuture ...
[13:23:28.978] - result already collected: FutureResult
[13:23:28.979] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[13:23:28.979] plan(): Setting new future strategy stack:
[13:23:28.980] List of future strategies:
[13:23:28.980] 1. FutureStrategy:
[13:23:28.980]    - args: function (..., envir = parent.frame())
[13:23:28.980]    - tweaked: FALSE
[13:23:28.980]    - call: future::plan(oplan)
[13:23:28.980] plan(): nbrOfWorkers() = 1
> 
