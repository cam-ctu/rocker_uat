
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:05:01.130] plan(): Setting new future strategy stack:
[16:05:01.131] List of future strategies:
[16:05:01.131] 1. sequential:
[16:05:01.131]    - args: function (..., envir = parent.frame())
[16:05:01.131]    - tweaked: FALSE
[16:05:01.131]    - call: future::plan("sequential")
[16:05:01.146] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[16:05:01.216] plan(): Setting new future strategy stack:
[16:05:01.217] List of future strategies:
[16:05:01.217] 1. sequential:
[16:05:01.217]    - args: function (..., envir = parent.frame())
[16:05:01.217]    - tweaked: FALSE
[16:05:01.217]    - call: plan(strategy)
[16:05:01.227] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.229] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.229] Searching for globals...
[16:05:01.237] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.237] Searching for globals ... DONE
[16:05:01.237] Resolving globals: TRUE
[16:05:01.237] Resolving any globals that are futures ...
[16:05:01.237] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.237] Resolving any globals that are futures ... DONE
[16:05:01.238] Resolving futures part of globals (recursively) ...
[16:05:01.239] resolve() on list ...
[16:05:01.239]  recursive: 99
[16:05:01.239]  length: 1
[16:05:01.239]  elements: ‘x’
[16:05:01.239]  length: 0 (resolved future 1)
[16:05:01.239] resolve() on list ... DONE
[16:05:01.239] - globals: [1] ‘x’
[16:05:01.240] Resolving futures part of globals (recursively) ... DONE
[16:05:01.240] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.240] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.241] - globals: [1] ‘x’
[16:05:01.241] 
[16:05:01.241] getGlobalsAndPackages() ... DONE
[16:05:01.241] run() for ‘Future’ ...
[16:05:01.242] - state: ‘created’
[16:05:01.242] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:01.242] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:01.242] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:01.242]   - Field: ‘label’
[16:05:01.243]   - Field: ‘local’
[16:05:01.243]   - Field: ‘owner’
[16:05:01.243]   - Field: ‘envir’
[16:05:01.243]   - Field: ‘packages’
[16:05:01.243]   - Field: ‘gc’
[16:05:01.243]   - Field: ‘conditions’
[16:05:01.243]   - Field: ‘expr’
[16:05:01.243]   - Field: ‘uuid’
[16:05:01.243]   - Field: ‘seed’
[16:05:01.243]   - Field: ‘version’
[16:05:01.244]   - Field: ‘result’
[16:05:01.244]   - Field: ‘asynchronous’
[16:05:01.244]   - Field: ‘calls’
[16:05:01.244]   - Field: ‘globals’
[16:05:01.244]   - Field: ‘stdout’
[16:05:01.244]   - Field: ‘earlySignal’
[16:05:01.244]   - Field: ‘lazy’
[16:05:01.244]   - Field: ‘state’
[16:05:01.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:01.244] - Launch lazy future ...
[16:05:01.247] Packages needed by the future expression (n = 0): <none>
[16:05:01.248] Packages needed by future strategies (n = 0): <none>
[16:05:01.248] {
[16:05:01.248]     {
[16:05:01.248]         {
[16:05:01.248]             ...future.startTime <- base::Sys.time()
[16:05:01.248]             {
[16:05:01.248]                 {
[16:05:01.248]                   {
[16:05:01.248]                     base::local({
[16:05:01.248]                       has_future <- base::requireNamespace("future", 
[16:05:01.248]                         quietly = TRUE)
[16:05:01.248]                       if (has_future) {
[16:05:01.248]                         ns <- base::getNamespace("future")
[16:05:01.248]                         version <- ns[[".package"]][["version"]]
[16:05:01.248]                         if (is.null(version)) 
[16:05:01.248]                           version <- utils::packageVersion("future")
[16:05:01.248]                       }
[16:05:01.248]                       else {
[16:05:01.248]                         version <- NULL
[16:05:01.248]                       }
[16:05:01.248]                       if (!has_future || version < "1.8.0") {
[16:05:01.248]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.248]                           "", base::R.version$version.string), 
[16:05:01.248]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:01.248]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.248]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.248]                             "release", "version")], collapse = " "), 
[16:05:01.248]                           hostname = base::Sys.info()[["nodename"]])
[16:05:01.248]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.248]                           info)
[16:05:01.248]                         info <- base::paste(info, collapse = "; ")
[16:05:01.248]                         if (!has_future) {
[16:05:01.248]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.248]                             info)
[16:05:01.248]                         }
[16:05:01.248]                         else {
[16:05:01.248]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.248]                             info, version)
[16:05:01.248]                         }
[16:05:01.248]                         base::stop(msg)
[16:05:01.248]                       }
[16:05:01.248]                     })
[16:05:01.248]                   }
[16:05:01.248]                   options(future.plan = NULL)
[16:05:01.248]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.248]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.248]                 }
[16:05:01.248]                 ...future.workdir <- getwd()
[16:05:01.248]             }
[16:05:01.248]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.248]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.248]         }
[16:05:01.248]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.248]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.248]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.248]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.248]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.248]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.248]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.248]             base::names(...future.oldOptions))
[16:05:01.248]     }
[16:05:01.248]     if (FALSE) {
[16:05:01.248]     }
[16:05:01.248]     else {
[16:05:01.248]         if (TRUE) {
[16:05:01.248]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.248]                 open = "w")
[16:05:01.248]         }
[16:05:01.248]         else {
[16:05:01.248]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.248]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.248]         }
[16:05:01.248]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.248]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.248]             base::sink(type = "output", split = FALSE)
[16:05:01.248]             base::close(...future.stdout)
[16:05:01.248]         }, add = TRUE)
[16:05:01.248]     }
[16:05:01.248]     ...future.frame <- base::sys.nframe()
[16:05:01.248]     ...future.conditions <- base::list()
[16:05:01.248]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.248]     if (FALSE) {
[16:05:01.248]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.248]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.248]     }
[16:05:01.248]     ...future.result <- base::tryCatch({
[16:05:01.248]         base::withCallingHandlers({
[16:05:01.248]             ...future.value <- base::withVisible(base::local({
[16:05:01.248]                 x$a <- 1
[16:05:01.248]                 x
[16:05:01.248]             }))
[16:05:01.248]             future::FutureResult(value = ...future.value$value, 
[16:05:01.248]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.248]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.248]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.248]                     ...future.globalenv.names))
[16:05:01.248]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.248]         }, condition = base::local({
[16:05:01.248]             c <- base::c
[16:05:01.248]             inherits <- base::inherits
[16:05:01.248]             invokeRestart <- base::invokeRestart
[16:05:01.248]             length <- base::length
[16:05:01.248]             list <- base::list
[16:05:01.248]             seq.int <- base::seq.int
[16:05:01.248]             signalCondition <- base::signalCondition
[16:05:01.248]             sys.calls <- base::sys.calls
[16:05:01.248]             `[[` <- base::`[[`
[16:05:01.248]             `+` <- base::`+`
[16:05:01.248]             `<<-` <- base::`<<-`
[16:05:01.248]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.248]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.248]                   3L)]
[16:05:01.248]             }
[16:05:01.248]             function(cond) {
[16:05:01.248]                 is_error <- inherits(cond, "error")
[16:05:01.248]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.248]                   NULL)
[16:05:01.248]                 if (is_error) {
[16:05:01.248]                   sessionInformation <- function() {
[16:05:01.248]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.248]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.248]                       search = base::search(), system = base::Sys.info())
[16:05:01.248]                   }
[16:05:01.248]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.248]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.248]                     cond$call), session = sessionInformation(), 
[16:05:01.248]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.248]                   signalCondition(cond)
[16:05:01.248]                 }
[16:05:01.248]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.248]                 "immediateCondition"))) {
[16:05:01.248]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.248]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.248]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.248]                   if (TRUE && !signal) {
[16:05:01.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.248]                     {
[16:05:01.248]                       inherits <- base::inherits
[16:05:01.248]                       invokeRestart <- base::invokeRestart
[16:05:01.248]                       is.null <- base::is.null
[16:05:01.248]                       muffled <- FALSE
[16:05:01.248]                       if (inherits(cond, "message")) {
[16:05:01.248]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.248]                         if (muffled) 
[16:05:01.248]                           invokeRestart("muffleMessage")
[16:05:01.248]                       }
[16:05:01.248]                       else if (inherits(cond, "warning")) {
[16:05:01.248]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.248]                         if (muffled) 
[16:05:01.248]                           invokeRestart("muffleWarning")
[16:05:01.248]                       }
[16:05:01.248]                       else if (inherits(cond, "condition")) {
[16:05:01.248]                         if (!is.null(pattern)) {
[16:05:01.248]                           computeRestarts <- base::computeRestarts
[16:05:01.248]                           grepl <- base::grepl
[16:05:01.248]                           restarts <- computeRestarts(cond)
[16:05:01.248]                           for (restart in restarts) {
[16:05:01.248]                             name <- restart$name
[16:05:01.248]                             if (is.null(name)) 
[16:05:01.248]                               next
[16:05:01.248]                             if (!grepl(pattern, name)) 
[16:05:01.248]                               next
[16:05:01.248]                             invokeRestart(restart)
[16:05:01.248]                             muffled <- TRUE
[16:05:01.248]                             break
[16:05:01.248]                           }
[16:05:01.248]                         }
[16:05:01.248]                       }
[16:05:01.248]                       invisible(muffled)
[16:05:01.248]                     }
[16:05:01.248]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.248]                   }
[16:05:01.248]                 }
[16:05:01.248]                 else {
[16:05:01.248]                   if (TRUE) {
[16:05:01.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.248]                     {
[16:05:01.248]                       inherits <- base::inherits
[16:05:01.248]                       invokeRestart <- base::invokeRestart
[16:05:01.248]                       is.null <- base::is.null
[16:05:01.248]                       muffled <- FALSE
[16:05:01.248]                       if (inherits(cond, "message")) {
[16:05:01.248]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.248]                         if (muffled) 
[16:05:01.248]                           invokeRestart("muffleMessage")
[16:05:01.248]                       }
[16:05:01.248]                       else if (inherits(cond, "warning")) {
[16:05:01.248]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.248]                         if (muffled) 
[16:05:01.248]                           invokeRestart("muffleWarning")
[16:05:01.248]                       }
[16:05:01.248]                       else if (inherits(cond, "condition")) {
[16:05:01.248]                         if (!is.null(pattern)) {
[16:05:01.248]                           computeRestarts <- base::computeRestarts
[16:05:01.248]                           grepl <- base::grepl
[16:05:01.248]                           restarts <- computeRestarts(cond)
[16:05:01.248]                           for (restart in restarts) {
[16:05:01.248]                             name <- restart$name
[16:05:01.248]                             if (is.null(name)) 
[16:05:01.248]                               next
[16:05:01.248]                             if (!grepl(pattern, name)) 
[16:05:01.248]                               next
[16:05:01.248]                             invokeRestart(restart)
[16:05:01.248]                             muffled <- TRUE
[16:05:01.248]                             break
[16:05:01.248]                           }
[16:05:01.248]                         }
[16:05:01.248]                       }
[16:05:01.248]                       invisible(muffled)
[16:05:01.248]                     }
[16:05:01.248]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.248]                   }
[16:05:01.248]                 }
[16:05:01.248]             }
[16:05:01.248]         }))
[16:05:01.248]     }, error = function(ex) {
[16:05:01.248]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.248]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.248]                 ...future.rng), started = ...future.startTime, 
[16:05:01.248]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.248]             version = "1.8"), class = "FutureResult")
[16:05:01.248]     }, finally = {
[16:05:01.248]         if (!identical(...future.workdir, getwd())) 
[16:05:01.248]             setwd(...future.workdir)
[16:05:01.248]         {
[16:05:01.248]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.248]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.248]             }
[16:05:01.248]             base::options(...future.oldOptions)
[16:05:01.248]             if (.Platform$OS.type == "windows") {
[16:05:01.248]                 old_names <- names(...future.oldEnvVars)
[16:05:01.248]                 envs <- base::Sys.getenv()
[16:05:01.248]                 names <- names(envs)
[16:05:01.248]                 common <- intersect(names, old_names)
[16:05:01.248]                 added <- setdiff(names, old_names)
[16:05:01.248]                 removed <- setdiff(old_names, names)
[16:05:01.248]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.248]                   envs[common]]
[16:05:01.248]                 NAMES <- toupper(changed)
[16:05:01.248]                 args <- list()
[16:05:01.248]                 for (kk in seq_along(NAMES)) {
[16:05:01.248]                   name <- changed[[kk]]
[16:05:01.248]                   NAME <- NAMES[[kk]]
[16:05:01.248]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.248]                     next
[16:05:01.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.248]                 }
[16:05:01.248]                 NAMES <- toupper(added)
[16:05:01.248]                 for (kk in seq_along(NAMES)) {
[16:05:01.248]                   name <- added[[kk]]
[16:05:01.248]                   NAME <- NAMES[[kk]]
[16:05:01.248]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.248]                     next
[16:05:01.248]                   args[[name]] <- ""
[16:05:01.248]                 }
[16:05:01.248]                 NAMES <- toupper(removed)
[16:05:01.248]                 for (kk in seq_along(NAMES)) {
[16:05:01.248]                   name <- removed[[kk]]
[16:05:01.248]                   NAME <- NAMES[[kk]]
[16:05:01.248]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.248]                     next
[16:05:01.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.248]                 }
[16:05:01.248]                 if (length(args) > 0) 
[16:05:01.248]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.248]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.248]             }
[16:05:01.248]             else {
[16:05:01.248]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.248]             }
[16:05:01.248]             {
[16:05:01.248]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.248]                   0L) {
[16:05:01.248]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.248]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.248]                   base::options(opts)
[16:05:01.248]                 }
[16:05:01.248]                 {
[16:05:01.248]                   {
[16:05:01.248]                     NULL
[16:05:01.248]                     RNGkind("Mersenne-Twister")
[16:05:01.248]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:01.248]                       inherits = FALSE)
[16:05:01.248]                   }
[16:05:01.248]                   options(future.plan = NULL)
[16:05:01.248]                   if (is.na(NA_character_)) 
[16:05:01.248]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.248]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.248]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:01.248]                   {
[16:05:01.248]                     future <- SequentialFuture(..., envir = envir)
[16:05:01.248]                     if (!future$lazy) 
[16:05:01.248]                       future <- run(future)
[16:05:01.248]                     invisible(future)
[16:05:01.248]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.248]                 }
[16:05:01.248]             }
[16:05:01.248]         }
[16:05:01.248]     })
[16:05:01.248]     if (TRUE) {
[16:05:01.248]         base::sink(type = "output", split = FALSE)
[16:05:01.248]         if (TRUE) {
[16:05:01.248]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.248]         }
[16:05:01.248]         else {
[16:05:01.248]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.248]         }
[16:05:01.248]         base::close(...future.stdout)
[16:05:01.248]         ...future.stdout <- NULL
[16:05:01.248]     }
[16:05:01.248]     ...future.result$conditions <- ...future.conditions
[16:05:01.248]     ...future.result$finished <- base::Sys.time()
[16:05:01.248]     ...future.result
[16:05:01.248] }
[16:05:01.250] assign_globals() ...
[16:05:01.251] List of 1
[16:05:01.251]  $ x: list()
[16:05:01.251]  - attr(*, "where")=List of 1
[16:05:01.251]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.251]  - attr(*, "resolved")= logi TRUE
[16:05:01.251]  - attr(*, "total_size")= num 0
[16:05:01.251]  - attr(*, "already-done")= logi TRUE
[16:05:01.253] - copied ‘x’ to environment
[16:05:01.253] assign_globals() ... done
[16:05:01.254] plan(): Setting new future strategy stack:
[16:05:01.254] List of future strategies:
[16:05:01.254] 1. sequential:
[16:05:01.254]    - args: function (..., envir = parent.frame())
[16:05:01.254]    - tweaked: FALSE
[16:05:01.254]    - call: NULL
[16:05:01.254] plan(): nbrOfWorkers() = 1
[16:05:01.255] plan(): Setting new future strategy stack:
[16:05:01.255] List of future strategies:
[16:05:01.255] 1. sequential:
[16:05:01.255]    - args: function (..., envir = parent.frame())
[16:05:01.255]    - tweaked: FALSE
[16:05:01.255]    - call: plan(strategy)
[16:05:01.256] plan(): nbrOfWorkers() = 1
[16:05:01.256] SequentialFuture started (and completed)
[16:05:01.257] - Launch lazy future ... done
[16:05:01.257] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.257] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.258] Searching for globals...
[16:05:01.259] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.260] Searching for globals ... DONE
[16:05:01.260] Resolving globals: TRUE
[16:05:01.260] Resolving any globals that are futures ...
[16:05:01.260] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.260] Resolving any globals that are futures ... DONE
[16:05:01.260] Resolving futures part of globals (recursively) ...
[16:05:01.261] resolve() on list ...
[16:05:01.261]  recursive: 99
[16:05:01.261]  length: 1
[16:05:01.261]  elements: ‘x’
[16:05:01.261]  length: 0 (resolved future 1)
[16:05:01.261] resolve() on list ... DONE
[16:05:01.261] - globals: [1] ‘x’
[16:05:01.261] Resolving futures part of globals (recursively) ... DONE
[16:05:01.261] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.262] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.262] - globals: [1] ‘x’
[16:05:01.262] 
[16:05:01.262] getGlobalsAndPackages() ... DONE
[16:05:01.262] run() for ‘Future’ ...
[16:05:01.262] - state: ‘created’
[16:05:01.263] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:01.263] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:01.263] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:01.263]   - Field: ‘label’
[16:05:01.263]   - Field: ‘local’
[16:05:01.263]   - Field: ‘owner’
[16:05:01.263]   - Field: ‘envir’
[16:05:01.264]   - Field: ‘packages’
[16:05:01.264]   - Field: ‘gc’
[16:05:01.264]   - Field: ‘conditions’
[16:05:01.264]   - Field: ‘expr’
[16:05:01.264]   - Field: ‘uuid’
[16:05:01.264]   - Field: ‘seed’
[16:05:01.264]   - Field: ‘version’
[16:05:01.264]   - Field: ‘result’
[16:05:01.264]   - Field: ‘asynchronous’
[16:05:01.264]   - Field: ‘calls’
[16:05:01.264]   - Field: ‘globals’
[16:05:01.265]   - Field: ‘stdout’
[16:05:01.265]   - Field: ‘earlySignal’
[16:05:01.265]   - Field: ‘lazy’
[16:05:01.265]   - Field: ‘state’
[16:05:01.265] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:01.265] - Launch lazy future ...
[16:05:01.265] Packages needed by the future expression (n = 0): <none>
[16:05:01.265] Packages needed by future strategies (n = 0): <none>
[16:05:01.266] {
[16:05:01.266]     {
[16:05:01.266]         {
[16:05:01.266]             ...future.startTime <- base::Sys.time()
[16:05:01.266]             {
[16:05:01.266]                 {
[16:05:01.266]                   {
[16:05:01.266]                     base::local({
[16:05:01.266]                       has_future <- base::requireNamespace("future", 
[16:05:01.266]                         quietly = TRUE)
[16:05:01.266]                       if (has_future) {
[16:05:01.266]                         ns <- base::getNamespace("future")
[16:05:01.266]                         version <- ns[[".package"]][["version"]]
[16:05:01.266]                         if (is.null(version)) 
[16:05:01.266]                           version <- utils::packageVersion("future")
[16:05:01.266]                       }
[16:05:01.266]                       else {
[16:05:01.266]                         version <- NULL
[16:05:01.266]                       }
[16:05:01.266]                       if (!has_future || version < "1.8.0") {
[16:05:01.266]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.266]                           "", base::R.version$version.string), 
[16:05:01.266]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:01.266]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.266]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.266]                             "release", "version")], collapse = " "), 
[16:05:01.266]                           hostname = base::Sys.info()[["nodename"]])
[16:05:01.266]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.266]                           info)
[16:05:01.266]                         info <- base::paste(info, collapse = "; ")
[16:05:01.266]                         if (!has_future) {
[16:05:01.266]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.266]                             info)
[16:05:01.266]                         }
[16:05:01.266]                         else {
[16:05:01.266]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.266]                             info, version)
[16:05:01.266]                         }
[16:05:01.266]                         base::stop(msg)
[16:05:01.266]                       }
[16:05:01.266]                     })
[16:05:01.266]                   }
[16:05:01.266]                   options(future.plan = NULL)
[16:05:01.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.266]                 }
[16:05:01.266]                 ...future.workdir <- getwd()
[16:05:01.266]             }
[16:05:01.266]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.266]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.266]         }
[16:05:01.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.266]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.266]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.266]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.266]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.266]             base::names(...future.oldOptions))
[16:05:01.266]     }
[16:05:01.266]     if (FALSE) {
[16:05:01.266]     }
[16:05:01.266]     else {
[16:05:01.266]         if (TRUE) {
[16:05:01.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.266]                 open = "w")
[16:05:01.266]         }
[16:05:01.266]         else {
[16:05:01.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.266]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.266]         }
[16:05:01.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.266]             base::sink(type = "output", split = FALSE)
[16:05:01.266]             base::close(...future.stdout)
[16:05:01.266]         }, add = TRUE)
[16:05:01.266]     }
[16:05:01.266]     ...future.frame <- base::sys.nframe()
[16:05:01.266]     ...future.conditions <- base::list()
[16:05:01.266]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.266]     if (FALSE) {
[16:05:01.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.266]     }
[16:05:01.266]     ...future.result <- base::tryCatch({
[16:05:01.266]         base::withCallingHandlers({
[16:05:01.266]             ...future.value <- base::withVisible(base::local({
[16:05:01.266]                 x$a <- 1
[16:05:01.266]                 x
[16:05:01.266]             }))
[16:05:01.266]             future::FutureResult(value = ...future.value$value, 
[16:05:01.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.266]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.266]                     ...future.globalenv.names))
[16:05:01.266]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.266]         }, condition = base::local({
[16:05:01.266]             c <- base::c
[16:05:01.266]             inherits <- base::inherits
[16:05:01.266]             invokeRestart <- base::invokeRestart
[16:05:01.266]             length <- base::length
[16:05:01.266]             list <- base::list
[16:05:01.266]             seq.int <- base::seq.int
[16:05:01.266]             signalCondition <- base::signalCondition
[16:05:01.266]             sys.calls <- base::sys.calls
[16:05:01.266]             `[[` <- base::`[[`
[16:05:01.266]             `+` <- base::`+`
[16:05:01.266]             `<<-` <- base::`<<-`
[16:05:01.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.266]                   3L)]
[16:05:01.266]             }
[16:05:01.266]             function(cond) {
[16:05:01.266]                 is_error <- inherits(cond, "error")
[16:05:01.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.266]                   NULL)
[16:05:01.266]                 if (is_error) {
[16:05:01.266]                   sessionInformation <- function() {
[16:05:01.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.266]                       search = base::search(), system = base::Sys.info())
[16:05:01.266]                   }
[16:05:01.266]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.266]                     cond$call), session = sessionInformation(), 
[16:05:01.266]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.266]                   signalCondition(cond)
[16:05:01.266]                 }
[16:05:01.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.266]                 "immediateCondition"))) {
[16:05:01.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.266]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.266]                   if (TRUE && !signal) {
[16:05:01.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.266]                     {
[16:05:01.266]                       inherits <- base::inherits
[16:05:01.266]                       invokeRestart <- base::invokeRestart
[16:05:01.266]                       is.null <- base::is.null
[16:05:01.266]                       muffled <- FALSE
[16:05:01.266]                       if (inherits(cond, "message")) {
[16:05:01.266]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.266]                         if (muffled) 
[16:05:01.266]                           invokeRestart("muffleMessage")
[16:05:01.266]                       }
[16:05:01.266]                       else if (inherits(cond, "warning")) {
[16:05:01.266]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.266]                         if (muffled) 
[16:05:01.266]                           invokeRestart("muffleWarning")
[16:05:01.266]                       }
[16:05:01.266]                       else if (inherits(cond, "condition")) {
[16:05:01.266]                         if (!is.null(pattern)) {
[16:05:01.266]                           computeRestarts <- base::computeRestarts
[16:05:01.266]                           grepl <- base::grepl
[16:05:01.266]                           restarts <- computeRestarts(cond)
[16:05:01.266]                           for (restart in restarts) {
[16:05:01.266]                             name <- restart$name
[16:05:01.266]                             if (is.null(name)) 
[16:05:01.266]                               next
[16:05:01.266]                             if (!grepl(pattern, name)) 
[16:05:01.266]                               next
[16:05:01.266]                             invokeRestart(restart)
[16:05:01.266]                             muffled <- TRUE
[16:05:01.266]                             break
[16:05:01.266]                           }
[16:05:01.266]                         }
[16:05:01.266]                       }
[16:05:01.266]                       invisible(muffled)
[16:05:01.266]                     }
[16:05:01.266]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.266]                   }
[16:05:01.266]                 }
[16:05:01.266]                 else {
[16:05:01.266]                   if (TRUE) {
[16:05:01.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.266]                     {
[16:05:01.266]                       inherits <- base::inherits
[16:05:01.266]                       invokeRestart <- base::invokeRestart
[16:05:01.266]                       is.null <- base::is.null
[16:05:01.266]                       muffled <- FALSE
[16:05:01.266]                       if (inherits(cond, "message")) {
[16:05:01.266]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.266]                         if (muffled) 
[16:05:01.266]                           invokeRestart("muffleMessage")
[16:05:01.266]                       }
[16:05:01.266]                       else if (inherits(cond, "warning")) {
[16:05:01.266]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.266]                         if (muffled) 
[16:05:01.266]                           invokeRestart("muffleWarning")
[16:05:01.266]                       }
[16:05:01.266]                       else if (inherits(cond, "condition")) {
[16:05:01.266]                         if (!is.null(pattern)) {
[16:05:01.266]                           computeRestarts <- base::computeRestarts
[16:05:01.266]                           grepl <- base::grepl
[16:05:01.266]                           restarts <- computeRestarts(cond)
[16:05:01.266]                           for (restart in restarts) {
[16:05:01.266]                             name <- restart$name
[16:05:01.266]                             if (is.null(name)) 
[16:05:01.266]                               next
[16:05:01.266]                             if (!grepl(pattern, name)) 
[16:05:01.266]                               next
[16:05:01.266]                             invokeRestart(restart)
[16:05:01.266]                             muffled <- TRUE
[16:05:01.266]                             break
[16:05:01.266]                           }
[16:05:01.266]                         }
[16:05:01.266]                       }
[16:05:01.266]                       invisible(muffled)
[16:05:01.266]                     }
[16:05:01.266]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.266]                   }
[16:05:01.266]                 }
[16:05:01.266]             }
[16:05:01.266]         }))
[16:05:01.266]     }, error = function(ex) {
[16:05:01.266]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.266]                 ...future.rng), started = ...future.startTime, 
[16:05:01.266]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.266]             version = "1.8"), class = "FutureResult")
[16:05:01.266]     }, finally = {
[16:05:01.266]         if (!identical(...future.workdir, getwd())) 
[16:05:01.266]             setwd(...future.workdir)
[16:05:01.266]         {
[16:05:01.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.266]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.266]             }
[16:05:01.266]             base::options(...future.oldOptions)
[16:05:01.266]             if (.Platform$OS.type == "windows") {
[16:05:01.266]                 old_names <- names(...future.oldEnvVars)
[16:05:01.266]                 envs <- base::Sys.getenv()
[16:05:01.266]                 names <- names(envs)
[16:05:01.266]                 common <- intersect(names, old_names)
[16:05:01.266]                 added <- setdiff(names, old_names)
[16:05:01.266]                 removed <- setdiff(old_names, names)
[16:05:01.266]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.266]                   envs[common]]
[16:05:01.266]                 NAMES <- toupper(changed)
[16:05:01.266]                 args <- list()
[16:05:01.266]                 for (kk in seq_along(NAMES)) {
[16:05:01.266]                   name <- changed[[kk]]
[16:05:01.266]                   NAME <- NAMES[[kk]]
[16:05:01.266]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.266]                     next
[16:05:01.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.266]                 }
[16:05:01.266]                 NAMES <- toupper(added)
[16:05:01.266]                 for (kk in seq_along(NAMES)) {
[16:05:01.266]                   name <- added[[kk]]
[16:05:01.266]                   NAME <- NAMES[[kk]]
[16:05:01.266]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.266]                     next
[16:05:01.266]                   args[[name]] <- ""
[16:05:01.266]                 }
[16:05:01.266]                 NAMES <- toupper(removed)
[16:05:01.266]                 for (kk in seq_along(NAMES)) {
[16:05:01.266]                   name <- removed[[kk]]
[16:05:01.266]                   NAME <- NAMES[[kk]]
[16:05:01.266]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.266]                     next
[16:05:01.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.266]                 }
[16:05:01.266]                 if (length(args) > 0) 
[16:05:01.266]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.266]             }
[16:05:01.266]             else {
[16:05:01.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.266]             }
[16:05:01.266]             {
[16:05:01.266]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.266]                   0L) {
[16:05:01.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.266]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.266]                   base::options(opts)
[16:05:01.266]                 }
[16:05:01.266]                 {
[16:05:01.266]                   {
[16:05:01.266]                     NULL
[16:05:01.266]                     RNGkind("Mersenne-Twister")
[16:05:01.266]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:01.266]                       inherits = FALSE)
[16:05:01.266]                   }
[16:05:01.266]                   options(future.plan = NULL)
[16:05:01.266]                   if (is.na(NA_character_)) 
[16:05:01.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.266]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:01.266]                   {
[16:05:01.266]                     future <- SequentialFuture(..., envir = envir)
[16:05:01.266]                     if (!future$lazy) 
[16:05:01.266]                       future <- run(future)
[16:05:01.266]                     invisible(future)
[16:05:01.266]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.266]                 }
[16:05:01.266]             }
[16:05:01.266]         }
[16:05:01.266]     })
[16:05:01.266]     if (TRUE) {
[16:05:01.266]         base::sink(type = "output", split = FALSE)
[16:05:01.266]         if (TRUE) {
[16:05:01.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.266]         }
[16:05:01.266]         else {
[16:05:01.266]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.266]         }
[16:05:01.266]         base::close(...future.stdout)
[16:05:01.266]         ...future.stdout <- NULL
[16:05:01.266]     }
[16:05:01.266]     ...future.result$conditions <- ...future.conditions
[16:05:01.266]     ...future.result$finished <- base::Sys.time()
[16:05:01.266]     ...future.result
[16:05:01.266] }
[16:05:01.267] assign_globals() ...
[16:05:01.267] List of 1
[16:05:01.267]  $ x: list()
[16:05:01.267]  - attr(*, "where")=List of 1
[16:05:01.267]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.267]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.267]  - attr(*, "resolved")= logi TRUE
[16:05:01.267]  - attr(*, "total_size")= num 0
[16:05:01.267]  - attr(*, "already-done")= logi TRUE
[16:05:01.270] - copied ‘x’ to environment
[16:05:01.270] assign_globals() ... done
[16:05:01.270] plan(): Setting new future strategy stack:
[16:05:01.270] List of future strategies:
[16:05:01.270] 1. sequential:
[16:05:01.270]    - args: function (..., envir = parent.frame())
[16:05:01.270]    - tweaked: FALSE
[16:05:01.270]    - call: NULL
[16:05:01.271] plan(): nbrOfWorkers() = 1
[16:05:01.271] plan(): Setting new future strategy stack:
[16:05:01.272] List of future strategies:
[16:05:01.272] 1. sequential:
[16:05:01.272]    - args: function (..., envir = parent.frame())
[16:05:01.272]    - tweaked: FALSE
[16:05:01.272]    - call: plan(strategy)
[16:05:01.272] plan(): nbrOfWorkers() = 1
[16:05:01.272] SequentialFuture started (and completed)
[16:05:01.272] - Launch lazy future ... done
[16:05:01.272] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.274] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.274] Searching for globals...
[16:05:01.276] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.276] Searching for globals ... DONE
[16:05:01.276] Resolving globals: TRUE
[16:05:01.276] Resolving any globals that are futures ...
[16:05:01.276] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.276] Resolving any globals that are futures ... DONE
[16:05:01.276] Resolving futures part of globals (recursively) ...
[16:05:01.277] resolve() on list ...
[16:05:01.277]  recursive: 99
[16:05:01.277]  length: 1
[16:05:01.277]  elements: ‘x’
[16:05:01.277]  length: 0 (resolved future 1)
[16:05:01.277] resolve() on list ... DONE
[16:05:01.277] - globals: [1] ‘x’
[16:05:01.277] Resolving futures part of globals (recursively) ... DONE
[16:05:01.278] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.278] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.280] - globals: [1] ‘x’
[16:05:01.280] 
[16:05:01.280] getGlobalsAndPackages() ... DONE
[16:05:01.280] run() for ‘Future’ ...
[16:05:01.280] - state: ‘created’
[16:05:01.281] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:01.281] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:01.281] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:01.281]   - Field: ‘label’
[16:05:01.281]   - Field: ‘local’
[16:05:01.281]   - Field: ‘owner’
[16:05:01.281]   - Field: ‘envir’
[16:05:01.281]   - Field: ‘packages’
[16:05:01.282]   - Field: ‘gc’
[16:05:01.282]   - Field: ‘conditions’
[16:05:01.282]   - Field: ‘expr’
[16:05:01.282]   - Field: ‘uuid’
[16:05:01.282]   - Field: ‘seed’
[16:05:01.282]   - Field: ‘version’
[16:05:01.282]   - Field: ‘result’
[16:05:01.282]   - Field: ‘asynchronous’
[16:05:01.282]   - Field: ‘calls’
[16:05:01.282]   - Field: ‘globals’
[16:05:01.283]   - Field: ‘stdout’
[16:05:01.283]   - Field: ‘earlySignal’
[16:05:01.283]   - Field: ‘lazy’
[16:05:01.283]   - Field: ‘state’
[16:05:01.283] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:01.283] - Launch lazy future ...
[16:05:01.283] Packages needed by the future expression (n = 0): <none>
[16:05:01.283] Packages needed by future strategies (n = 0): <none>
[16:05:01.284] {
[16:05:01.284]     {
[16:05:01.284]         {
[16:05:01.284]             ...future.startTime <- base::Sys.time()
[16:05:01.284]             {
[16:05:01.284]                 {
[16:05:01.284]                   {
[16:05:01.284]                     base::local({
[16:05:01.284]                       has_future <- base::requireNamespace("future", 
[16:05:01.284]                         quietly = TRUE)
[16:05:01.284]                       if (has_future) {
[16:05:01.284]                         ns <- base::getNamespace("future")
[16:05:01.284]                         version <- ns[[".package"]][["version"]]
[16:05:01.284]                         if (is.null(version)) 
[16:05:01.284]                           version <- utils::packageVersion("future")
[16:05:01.284]                       }
[16:05:01.284]                       else {
[16:05:01.284]                         version <- NULL
[16:05:01.284]                       }
[16:05:01.284]                       if (!has_future || version < "1.8.0") {
[16:05:01.284]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.284]                           "", base::R.version$version.string), 
[16:05:01.284]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:01.284]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.284]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.284]                             "release", "version")], collapse = " "), 
[16:05:01.284]                           hostname = base::Sys.info()[["nodename"]])
[16:05:01.284]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.284]                           info)
[16:05:01.284]                         info <- base::paste(info, collapse = "; ")
[16:05:01.284]                         if (!has_future) {
[16:05:01.284]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.284]                             info)
[16:05:01.284]                         }
[16:05:01.284]                         else {
[16:05:01.284]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.284]                             info, version)
[16:05:01.284]                         }
[16:05:01.284]                         base::stop(msg)
[16:05:01.284]                       }
[16:05:01.284]                     })
[16:05:01.284]                   }
[16:05:01.284]                   options(future.plan = NULL)
[16:05:01.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.284]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.284]                 }
[16:05:01.284]                 ...future.workdir <- getwd()
[16:05:01.284]             }
[16:05:01.284]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.284]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.284]         }
[16:05:01.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.284]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.284]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.284]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.284]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.284]             base::names(...future.oldOptions))
[16:05:01.284]     }
[16:05:01.284]     if (FALSE) {
[16:05:01.284]     }
[16:05:01.284]     else {
[16:05:01.284]         if (TRUE) {
[16:05:01.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.284]                 open = "w")
[16:05:01.284]         }
[16:05:01.284]         else {
[16:05:01.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.284]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.284]         }
[16:05:01.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.284]             base::sink(type = "output", split = FALSE)
[16:05:01.284]             base::close(...future.stdout)
[16:05:01.284]         }, add = TRUE)
[16:05:01.284]     }
[16:05:01.284]     ...future.frame <- base::sys.nframe()
[16:05:01.284]     ...future.conditions <- base::list()
[16:05:01.284]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.284]     if (FALSE) {
[16:05:01.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.284]     }
[16:05:01.284]     ...future.result <- base::tryCatch({
[16:05:01.284]         base::withCallingHandlers({
[16:05:01.284]             ...future.value <- base::withVisible(base::local({
[16:05:01.284]                 x$a <- 1
[16:05:01.284]                 x
[16:05:01.284]             }))
[16:05:01.284]             future::FutureResult(value = ...future.value$value, 
[16:05:01.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.284]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.284]                     ...future.globalenv.names))
[16:05:01.284]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.284]         }, condition = base::local({
[16:05:01.284]             c <- base::c
[16:05:01.284]             inherits <- base::inherits
[16:05:01.284]             invokeRestart <- base::invokeRestart
[16:05:01.284]             length <- base::length
[16:05:01.284]             list <- base::list
[16:05:01.284]             seq.int <- base::seq.int
[16:05:01.284]             signalCondition <- base::signalCondition
[16:05:01.284]             sys.calls <- base::sys.calls
[16:05:01.284]             `[[` <- base::`[[`
[16:05:01.284]             `+` <- base::`+`
[16:05:01.284]             `<<-` <- base::`<<-`
[16:05:01.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.284]                   3L)]
[16:05:01.284]             }
[16:05:01.284]             function(cond) {
[16:05:01.284]                 is_error <- inherits(cond, "error")
[16:05:01.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.284]                   NULL)
[16:05:01.284]                 if (is_error) {
[16:05:01.284]                   sessionInformation <- function() {
[16:05:01.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.284]                       search = base::search(), system = base::Sys.info())
[16:05:01.284]                   }
[16:05:01.284]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.284]                     cond$call), session = sessionInformation(), 
[16:05:01.284]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.284]                   signalCondition(cond)
[16:05:01.284]                 }
[16:05:01.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.284]                 "immediateCondition"))) {
[16:05:01.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.284]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.284]                   if (TRUE && !signal) {
[16:05:01.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.284]                     {
[16:05:01.284]                       inherits <- base::inherits
[16:05:01.284]                       invokeRestart <- base::invokeRestart
[16:05:01.284]                       is.null <- base::is.null
[16:05:01.284]                       muffled <- FALSE
[16:05:01.284]                       if (inherits(cond, "message")) {
[16:05:01.284]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.284]                         if (muffled) 
[16:05:01.284]                           invokeRestart("muffleMessage")
[16:05:01.284]                       }
[16:05:01.284]                       else if (inherits(cond, "warning")) {
[16:05:01.284]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.284]                         if (muffled) 
[16:05:01.284]                           invokeRestart("muffleWarning")
[16:05:01.284]                       }
[16:05:01.284]                       else if (inherits(cond, "condition")) {
[16:05:01.284]                         if (!is.null(pattern)) {
[16:05:01.284]                           computeRestarts <- base::computeRestarts
[16:05:01.284]                           grepl <- base::grepl
[16:05:01.284]                           restarts <- computeRestarts(cond)
[16:05:01.284]                           for (restart in restarts) {
[16:05:01.284]                             name <- restart$name
[16:05:01.284]                             if (is.null(name)) 
[16:05:01.284]                               next
[16:05:01.284]                             if (!grepl(pattern, name)) 
[16:05:01.284]                               next
[16:05:01.284]                             invokeRestart(restart)
[16:05:01.284]                             muffled <- TRUE
[16:05:01.284]                             break
[16:05:01.284]                           }
[16:05:01.284]                         }
[16:05:01.284]                       }
[16:05:01.284]                       invisible(muffled)
[16:05:01.284]                     }
[16:05:01.284]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.284]                   }
[16:05:01.284]                 }
[16:05:01.284]                 else {
[16:05:01.284]                   if (TRUE) {
[16:05:01.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.284]                     {
[16:05:01.284]                       inherits <- base::inherits
[16:05:01.284]                       invokeRestart <- base::invokeRestart
[16:05:01.284]                       is.null <- base::is.null
[16:05:01.284]                       muffled <- FALSE
[16:05:01.284]                       if (inherits(cond, "message")) {
[16:05:01.284]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.284]                         if (muffled) 
[16:05:01.284]                           invokeRestart("muffleMessage")
[16:05:01.284]                       }
[16:05:01.284]                       else if (inherits(cond, "warning")) {
[16:05:01.284]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.284]                         if (muffled) 
[16:05:01.284]                           invokeRestart("muffleWarning")
[16:05:01.284]                       }
[16:05:01.284]                       else if (inherits(cond, "condition")) {
[16:05:01.284]                         if (!is.null(pattern)) {
[16:05:01.284]                           computeRestarts <- base::computeRestarts
[16:05:01.284]                           grepl <- base::grepl
[16:05:01.284]                           restarts <- computeRestarts(cond)
[16:05:01.284]                           for (restart in restarts) {
[16:05:01.284]                             name <- restart$name
[16:05:01.284]                             if (is.null(name)) 
[16:05:01.284]                               next
[16:05:01.284]                             if (!grepl(pattern, name)) 
[16:05:01.284]                               next
[16:05:01.284]                             invokeRestart(restart)
[16:05:01.284]                             muffled <- TRUE
[16:05:01.284]                             break
[16:05:01.284]                           }
[16:05:01.284]                         }
[16:05:01.284]                       }
[16:05:01.284]                       invisible(muffled)
[16:05:01.284]                     }
[16:05:01.284]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.284]                   }
[16:05:01.284]                 }
[16:05:01.284]             }
[16:05:01.284]         }))
[16:05:01.284]     }, error = function(ex) {
[16:05:01.284]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.284]                 ...future.rng), started = ...future.startTime, 
[16:05:01.284]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.284]             version = "1.8"), class = "FutureResult")
[16:05:01.284]     }, finally = {
[16:05:01.284]         if (!identical(...future.workdir, getwd())) 
[16:05:01.284]             setwd(...future.workdir)
[16:05:01.284]         {
[16:05:01.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.284]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.284]             }
[16:05:01.284]             base::options(...future.oldOptions)
[16:05:01.284]             if (.Platform$OS.type == "windows") {
[16:05:01.284]                 old_names <- names(...future.oldEnvVars)
[16:05:01.284]                 envs <- base::Sys.getenv()
[16:05:01.284]                 names <- names(envs)
[16:05:01.284]                 common <- intersect(names, old_names)
[16:05:01.284]                 added <- setdiff(names, old_names)
[16:05:01.284]                 removed <- setdiff(old_names, names)
[16:05:01.284]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.284]                   envs[common]]
[16:05:01.284]                 NAMES <- toupper(changed)
[16:05:01.284]                 args <- list()
[16:05:01.284]                 for (kk in seq_along(NAMES)) {
[16:05:01.284]                   name <- changed[[kk]]
[16:05:01.284]                   NAME <- NAMES[[kk]]
[16:05:01.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.284]                     next
[16:05:01.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.284]                 }
[16:05:01.284]                 NAMES <- toupper(added)
[16:05:01.284]                 for (kk in seq_along(NAMES)) {
[16:05:01.284]                   name <- added[[kk]]
[16:05:01.284]                   NAME <- NAMES[[kk]]
[16:05:01.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.284]                     next
[16:05:01.284]                   args[[name]] <- ""
[16:05:01.284]                 }
[16:05:01.284]                 NAMES <- toupper(removed)
[16:05:01.284]                 for (kk in seq_along(NAMES)) {
[16:05:01.284]                   name <- removed[[kk]]
[16:05:01.284]                   NAME <- NAMES[[kk]]
[16:05:01.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.284]                     next
[16:05:01.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.284]                 }
[16:05:01.284]                 if (length(args) > 0) 
[16:05:01.284]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.284]             }
[16:05:01.284]             else {
[16:05:01.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.284]             }
[16:05:01.284]             {
[16:05:01.284]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.284]                   0L) {
[16:05:01.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.284]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.284]                   base::options(opts)
[16:05:01.284]                 }
[16:05:01.284]                 {
[16:05:01.284]                   {
[16:05:01.284]                     NULL
[16:05:01.284]                     RNGkind("Mersenne-Twister")
[16:05:01.284]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:01.284]                       inherits = FALSE)
[16:05:01.284]                   }
[16:05:01.284]                   options(future.plan = NULL)
[16:05:01.284]                   if (is.na(NA_character_)) 
[16:05:01.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.284]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:01.284]                   {
[16:05:01.284]                     future <- SequentialFuture(..., envir = envir)
[16:05:01.284]                     if (!future$lazy) 
[16:05:01.284]                       future <- run(future)
[16:05:01.284]                     invisible(future)
[16:05:01.284]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.284]                 }
[16:05:01.284]             }
[16:05:01.284]         }
[16:05:01.284]     })
[16:05:01.284]     if (TRUE) {
[16:05:01.284]         base::sink(type = "output", split = FALSE)
[16:05:01.284]         if (TRUE) {
[16:05:01.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.284]         }
[16:05:01.284]         else {
[16:05:01.284]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.284]         }
[16:05:01.284]         base::close(...future.stdout)
[16:05:01.284]         ...future.stdout <- NULL
[16:05:01.284]     }
[16:05:01.284]     ...future.result$conditions <- ...future.conditions
[16:05:01.284]     ...future.result$finished <- base::Sys.time()
[16:05:01.284]     ...future.result
[16:05:01.284] }
[16:05:01.285] assign_globals() ...
[16:05:01.285] List of 1
[16:05:01.285]  $ x: list()
[16:05:01.285]  - attr(*, "where")=List of 1
[16:05:01.285]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.285]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.285]  - attr(*, "resolved")= logi TRUE
[16:05:01.285]  - attr(*, "total_size")= num 0
[16:05:01.285]  - attr(*, "already-done")= logi TRUE
[16:05:01.288] - copied ‘x’ to environment
[16:05:01.288] assign_globals() ... done
[16:05:01.288] plan(): Setting new future strategy stack:
[16:05:01.288] List of future strategies:
[16:05:01.288] 1. sequential:
[16:05:01.288]    - args: function (..., envir = parent.frame())
[16:05:01.288]    - tweaked: FALSE
[16:05:01.288]    - call: NULL
[16:05:01.289] plan(): nbrOfWorkers() = 1
[16:05:01.289] plan(): Setting new future strategy stack:
[16:05:01.289] List of future strategies:
[16:05:01.289] 1. sequential:
[16:05:01.289]    - args: function (..., envir = parent.frame())
[16:05:01.289]    - tweaked: FALSE
[16:05:01.289]    - call: plan(strategy)
[16:05:01.290] plan(): nbrOfWorkers() = 1
[16:05:01.290] SequentialFuture started (and completed)
[16:05:01.290] - Launch lazy future ... done
[16:05:01.290] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.291] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.291] Searching for globals...
[16:05:01.293] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.293] Searching for globals ... DONE
[16:05:01.293] Resolving globals: TRUE
[16:05:01.293] Resolving any globals that are futures ...
[16:05:01.293] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.293] Resolving any globals that are futures ... DONE
[16:05:01.294] Resolving futures part of globals (recursively) ...
[16:05:01.294] resolve() on list ...
[16:05:01.294]  recursive: 99
[16:05:01.294]  length: 1
[16:05:01.294]  elements: ‘x’
[16:05:01.294]  length: 0 (resolved future 1)
[16:05:01.294] resolve() on list ... DONE
[16:05:01.294] - globals: [1] ‘x’
[16:05:01.294] Resolving futures part of globals (recursively) ... DONE
[16:05:01.295] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.295] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.295] - globals: [1] ‘x’
[16:05:01.295] 
[16:05:01.295] getGlobalsAndPackages() ... DONE
[16:05:01.296] run() for ‘Future’ ...
[16:05:01.296] - state: ‘created’
[16:05:01.296] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:01.296] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:01.296] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:01.296]   - Field: ‘label’
[16:05:01.296]   - Field: ‘local’
[16:05:01.296]   - Field: ‘owner’
[16:05:01.297]   - Field: ‘envir’
[16:05:01.297]   - Field: ‘packages’
[16:05:01.297]   - Field: ‘gc’
[16:05:01.297]   - Field: ‘conditions’
[16:05:01.297]   - Field: ‘expr’
[16:05:01.297]   - Field: ‘uuid’
[16:05:01.297]   - Field: ‘seed’
[16:05:01.297]   - Field: ‘version’
[16:05:01.297]   - Field: ‘result’
[16:05:01.297]   - Field: ‘asynchronous’
[16:05:01.297]   - Field: ‘calls’
[16:05:01.298]   - Field: ‘globals’
[16:05:01.298]   - Field: ‘stdout’
[16:05:01.298]   - Field: ‘earlySignal’
[16:05:01.298]   - Field: ‘lazy’
[16:05:01.298]   - Field: ‘state’
[16:05:01.298] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:01.298] - Launch lazy future ...
[16:05:01.298] Packages needed by the future expression (n = 0): <none>
[16:05:01.298] Packages needed by future strategies (n = 0): <none>
[16:05:01.299] {
[16:05:01.299]     {
[16:05:01.299]         {
[16:05:01.299]             ...future.startTime <- base::Sys.time()
[16:05:01.299]             {
[16:05:01.299]                 {
[16:05:01.299]                   {
[16:05:01.299]                     base::local({
[16:05:01.299]                       has_future <- base::requireNamespace("future", 
[16:05:01.299]                         quietly = TRUE)
[16:05:01.299]                       if (has_future) {
[16:05:01.299]                         ns <- base::getNamespace("future")
[16:05:01.299]                         version <- ns[[".package"]][["version"]]
[16:05:01.299]                         if (is.null(version)) 
[16:05:01.299]                           version <- utils::packageVersion("future")
[16:05:01.299]                       }
[16:05:01.299]                       else {
[16:05:01.299]                         version <- NULL
[16:05:01.299]                       }
[16:05:01.299]                       if (!has_future || version < "1.8.0") {
[16:05:01.299]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.299]                           "", base::R.version$version.string), 
[16:05:01.299]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:01.299]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.299]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.299]                             "release", "version")], collapse = " "), 
[16:05:01.299]                           hostname = base::Sys.info()[["nodename"]])
[16:05:01.299]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.299]                           info)
[16:05:01.299]                         info <- base::paste(info, collapse = "; ")
[16:05:01.299]                         if (!has_future) {
[16:05:01.299]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.299]                             info)
[16:05:01.299]                         }
[16:05:01.299]                         else {
[16:05:01.299]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.299]                             info, version)
[16:05:01.299]                         }
[16:05:01.299]                         base::stop(msg)
[16:05:01.299]                       }
[16:05:01.299]                     })
[16:05:01.299]                   }
[16:05:01.299]                   options(future.plan = NULL)
[16:05:01.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.299]                 }
[16:05:01.299]                 ...future.workdir <- getwd()
[16:05:01.299]             }
[16:05:01.299]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.299]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.299]         }
[16:05:01.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.299]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.299]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.299]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.299]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.299]             base::names(...future.oldOptions))
[16:05:01.299]     }
[16:05:01.299]     if (FALSE) {
[16:05:01.299]     }
[16:05:01.299]     else {
[16:05:01.299]         if (TRUE) {
[16:05:01.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.299]                 open = "w")
[16:05:01.299]         }
[16:05:01.299]         else {
[16:05:01.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.299]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.299]         }
[16:05:01.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.299]             base::sink(type = "output", split = FALSE)
[16:05:01.299]             base::close(...future.stdout)
[16:05:01.299]         }, add = TRUE)
[16:05:01.299]     }
[16:05:01.299]     ...future.frame <- base::sys.nframe()
[16:05:01.299]     ...future.conditions <- base::list()
[16:05:01.299]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.299]     if (FALSE) {
[16:05:01.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.299]     }
[16:05:01.299]     ...future.result <- base::tryCatch({
[16:05:01.299]         base::withCallingHandlers({
[16:05:01.299]             ...future.value <- base::withVisible(base::local({
[16:05:01.299]                 x$a <- 1
[16:05:01.299]                 x
[16:05:01.299]             }))
[16:05:01.299]             future::FutureResult(value = ...future.value$value, 
[16:05:01.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.299]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.299]                     ...future.globalenv.names))
[16:05:01.299]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.299]         }, condition = base::local({
[16:05:01.299]             c <- base::c
[16:05:01.299]             inherits <- base::inherits
[16:05:01.299]             invokeRestart <- base::invokeRestart
[16:05:01.299]             length <- base::length
[16:05:01.299]             list <- base::list
[16:05:01.299]             seq.int <- base::seq.int
[16:05:01.299]             signalCondition <- base::signalCondition
[16:05:01.299]             sys.calls <- base::sys.calls
[16:05:01.299]             `[[` <- base::`[[`
[16:05:01.299]             `+` <- base::`+`
[16:05:01.299]             `<<-` <- base::`<<-`
[16:05:01.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.299]                   3L)]
[16:05:01.299]             }
[16:05:01.299]             function(cond) {
[16:05:01.299]                 is_error <- inherits(cond, "error")
[16:05:01.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.299]                   NULL)
[16:05:01.299]                 if (is_error) {
[16:05:01.299]                   sessionInformation <- function() {
[16:05:01.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.299]                       search = base::search(), system = base::Sys.info())
[16:05:01.299]                   }
[16:05:01.299]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.299]                     cond$call), session = sessionInformation(), 
[16:05:01.299]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.299]                   signalCondition(cond)
[16:05:01.299]                 }
[16:05:01.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.299]                 "immediateCondition"))) {
[16:05:01.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.299]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.299]                   if (TRUE && !signal) {
[16:05:01.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.299]                     {
[16:05:01.299]                       inherits <- base::inherits
[16:05:01.299]                       invokeRestart <- base::invokeRestart
[16:05:01.299]                       is.null <- base::is.null
[16:05:01.299]                       muffled <- FALSE
[16:05:01.299]                       if (inherits(cond, "message")) {
[16:05:01.299]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.299]                         if (muffled) 
[16:05:01.299]                           invokeRestart("muffleMessage")
[16:05:01.299]                       }
[16:05:01.299]                       else if (inherits(cond, "warning")) {
[16:05:01.299]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.299]                         if (muffled) 
[16:05:01.299]                           invokeRestart("muffleWarning")
[16:05:01.299]                       }
[16:05:01.299]                       else if (inherits(cond, "condition")) {
[16:05:01.299]                         if (!is.null(pattern)) {
[16:05:01.299]                           computeRestarts <- base::computeRestarts
[16:05:01.299]                           grepl <- base::grepl
[16:05:01.299]                           restarts <- computeRestarts(cond)
[16:05:01.299]                           for (restart in restarts) {
[16:05:01.299]                             name <- restart$name
[16:05:01.299]                             if (is.null(name)) 
[16:05:01.299]                               next
[16:05:01.299]                             if (!grepl(pattern, name)) 
[16:05:01.299]                               next
[16:05:01.299]                             invokeRestart(restart)
[16:05:01.299]                             muffled <- TRUE
[16:05:01.299]                             break
[16:05:01.299]                           }
[16:05:01.299]                         }
[16:05:01.299]                       }
[16:05:01.299]                       invisible(muffled)
[16:05:01.299]                     }
[16:05:01.299]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.299]                   }
[16:05:01.299]                 }
[16:05:01.299]                 else {
[16:05:01.299]                   if (TRUE) {
[16:05:01.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.299]                     {
[16:05:01.299]                       inherits <- base::inherits
[16:05:01.299]                       invokeRestart <- base::invokeRestart
[16:05:01.299]                       is.null <- base::is.null
[16:05:01.299]                       muffled <- FALSE
[16:05:01.299]                       if (inherits(cond, "message")) {
[16:05:01.299]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.299]                         if (muffled) 
[16:05:01.299]                           invokeRestart("muffleMessage")
[16:05:01.299]                       }
[16:05:01.299]                       else if (inherits(cond, "warning")) {
[16:05:01.299]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.299]                         if (muffled) 
[16:05:01.299]                           invokeRestart("muffleWarning")
[16:05:01.299]                       }
[16:05:01.299]                       else if (inherits(cond, "condition")) {
[16:05:01.299]                         if (!is.null(pattern)) {
[16:05:01.299]                           computeRestarts <- base::computeRestarts
[16:05:01.299]                           grepl <- base::grepl
[16:05:01.299]                           restarts <- computeRestarts(cond)
[16:05:01.299]                           for (restart in restarts) {
[16:05:01.299]                             name <- restart$name
[16:05:01.299]                             if (is.null(name)) 
[16:05:01.299]                               next
[16:05:01.299]                             if (!grepl(pattern, name)) 
[16:05:01.299]                               next
[16:05:01.299]                             invokeRestart(restart)
[16:05:01.299]                             muffled <- TRUE
[16:05:01.299]                             break
[16:05:01.299]                           }
[16:05:01.299]                         }
[16:05:01.299]                       }
[16:05:01.299]                       invisible(muffled)
[16:05:01.299]                     }
[16:05:01.299]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.299]                   }
[16:05:01.299]                 }
[16:05:01.299]             }
[16:05:01.299]         }))
[16:05:01.299]     }, error = function(ex) {
[16:05:01.299]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.299]                 ...future.rng), started = ...future.startTime, 
[16:05:01.299]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.299]             version = "1.8"), class = "FutureResult")
[16:05:01.299]     }, finally = {
[16:05:01.299]         if (!identical(...future.workdir, getwd())) 
[16:05:01.299]             setwd(...future.workdir)
[16:05:01.299]         {
[16:05:01.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.299]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.299]             }
[16:05:01.299]             base::options(...future.oldOptions)
[16:05:01.299]             if (.Platform$OS.type == "windows") {
[16:05:01.299]                 old_names <- names(...future.oldEnvVars)
[16:05:01.299]                 envs <- base::Sys.getenv()
[16:05:01.299]                 names <- names(envs)
[16:05:01.299]                 common <- intersect(names, old_names)
[16:05:01.299]                 added <- setdiff(names, old_names)
[16:05:01.299]                 removed <- setdiff(old_names, names)
[16:05:01.299]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.299]                   envs[common]]
[16:05:01.299]                 NAMES <- toupper(changed)
[16:05:01.299]                 args <- list()
[16:05:01.299]                 for (kk in seq_along(NAMES)) {
[16:05:01.299]                   name <- changed[[kk]]
[16:05:01.299]                   NAME <- NAMES[[kk]]
[16:05:01.299]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.299]                     next
[16:05:01.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.299]                 }
[16:05:01.299]                 NAMES <- toupper(added)
[16:05:01.299]                 for (kk in seq_along(NAMES)) {
[16:05:01.299]                   name <- added[[kk]]
[16:05:01.299]                   NAME <- NAMES[[kk]]
[16:05:01.299]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.299]                     next
[16:05:01.299]                   args[[name]] <- ""
[16:05:01.299]                 }
[16:05:01.299]                 NAMES <- toupper(removed)
[16:05:01.299]                 for (kk in seq_along(NAMES)) {
[16:05:01.299]                   name <- removed[[kk]]
[16:05:01.299]                   NAME <- NAMES[[kk]]
[16:05:01.299]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.299]                     next
[16:05:01.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.299]                 }
[16:05:01.299]                 if (length(args) > 0) 
[16:05:01.299]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.299]             }
[16:05:01.299]             else {
[16:05:01.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.299]             }
[16:05:01.299]             {
[16:05:01.299]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.299]                   0L) {
[16:05:01.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.299]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.299]                   base::options(opts)
[16:05:01.299]                 }
[16:05:01.299]                 {
[16:05:01.299]                   {
[16:05:01.299]                     NULL
[16:05:01.299]                     RNGkind("Mersenne-Twister")
[16:05:01.299]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:01.299]                       inherits = FALSE)
[16:05:01.299]                   }
[16:05:01.299]                   options(future.plan = NULL)
[16:05:01.299]                   if (is.na(NA_character_)) 
[16:05:01.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.299]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:01.299]                   {
[16:05:01.299]                     future <- SequentialFuture(..., envir = envir)
[16:05:01.299]                     if (!future$lazy) 
[16:05:01.299]                       future <- run(future)
[16:05:01.299]                     invisible(future)
[16:05:01.299]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.299]                 }
[16:05:01.299]             }
[16:05:01.299]         }
[16:05:01.299]     })
[16:05:01.299]     if (TRUE) {
[16:05:01.299]         base::sink(type = "output", split = FALSE)
[16:05:01.299]         if (TRUE) {
[16:05:01.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.299]         }
[16:05:01.299]         else {
[16:05:01.299]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.299]         }
[16:05:01.299]         base::close(...future.stdout)
[16:05:01.299]         ...future.stdout <- NULL
[16:05:01.299]     }
[16:05:01.299]     ...future.result$conditions <- ...future.conditions
[16:05:01.299]     ...future.result$finished <- base::Sys.time()
[16:05:01.299]     ...future.result
[16:05:01.299] }
[16:05:01.300] assign_globals() ...
[16:05:01.300] List of 1
[16:05:01.300]  $ x: list()
[16:05:01.300]  - attr(*, "where")=List of 1
[16:05:01.300]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.300]  - attr(*, "resolved")= logi TRUE
[16:05:01.300]  - attr(*, "total_size")= num 0
[16:05:01.300]  - attr(*, "already-done")= logi TRUE
[16:05:01.303] - copied ‘x’ to environment
[16:05:01.303] assign_globals() ... done
[16:05:01.303] plan(): Setting new future strategy stack:
[16:05:01.303] List of future strategies:
[16:05:01.303] 1. sequential:
[16:05:01.303]    - args: function (..., envir = parent.frame())
[16:05:01.303]    - tweaked: FALSE
[16:05:01.303]    - call: NULL
[16:05:01.304] plan(): nbrOfWorkers() = 1
[16:05:01.304] plan(): Setting new future strategy stack:
[16:05:01.304] List of future strategies:
[16:05:01.304] 1. sequential:
[16:05:01.304]    - args: function (..., envir = parent.frame())
[16:05:01.304]    - tweaked: FALSE
[16:05:01.304]    - call: plan(strategy)
[16:05:01.305] plan(): nbrOfWorkers() = 1
[16:05:01.305] SequentialFuture started (and completed)
[16:05:01.305] - Launch lazy future ... done
[16:05:01.305] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.306] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.306] Searching for globals...
[16:05:01.310] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[16:05:01.310] Searching for globals ... DONE
[16:05:01.310] Resolving globals: TRUE
[16:05:01.310] Resolving any globals that are futures ...
[16:05:01.310] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[16:05:01.310] Resolving any globals that are futures ... DONE
[16:05:01.311] 
[16:05:01.311] 
[16:05:01.311] getGlobalsAndPackages() ... DONE
[16:05:01.311] run() for ‘Future’ ...
[16:05:01.311] - state: ‘created’
[16:05:01.311] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:01.312] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:01.312] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:01.312]   - Field: ‘label’
[16:05:01.312]   - Field: ‘local’
[16:05:01.312]   - Field: ‘owner’
[16:05:01.312]   - Field: ‘envir’
[16:05:01.312]   - Field: ‘packages’
[16:05:01.312]   - Field: ‘gc’
[16:05:01.312]   - Field: ‘conditions’
[16:05:01.312]   - Field: ‘expr’
[16:05:01.313]   - Field: ‘uuid’
[16:05:01.313]   - Field: ‘seed’
[16:05:01.313]   - Field: ‘version’
[16:05:01.313]   - Field: ‘result’
[16:05:01.313]   - Field: ‘asynchronous’
[16:05:01.313]   - Field: ‘calls’
[16:05:01.313]   - Field: ‘globals’
[16:05:01.313]   - Field: ‘stdout’
[16:05:01.313]   - Field: ‘earlySignal’
[16:05:01.313]   - Field: ‘lazy’
[16:05:01.313]   - Field: ‘state’
[16:05:01.314] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:01.314] - Launch lazy future ...
[16:05:01.314] Packages needed by the future expression (n = 0): <none>
[16:05:01.314] Packages needed by future strategies (n = 0): <none>
[16:05:01.314] {
[16:05:01.314]     {
[16:05:01.314]         {
[16:05:01.314]             ...future.startTime <- base::Sys.time()
[16:05:01.314]             {
[16:05:01.314]                 {
[16:05:01.314]                   {
[16:05:01.314]                     base::local({
[16:05:01.314]                       has_future <- base::requireNamespace("future", 
[16:05:01.314]                         quietly = TRUE)
[16:05:01.314]                       if (has_future) {
[16:05:01.314]                         ns <- base::getNamespace("future")
[16:05:01.314]                         version <- ns[[".package"]][["version"]]
[16:05:01.314]                         if (is.null(version)) 
[16:05:01.314]                           version <- utils::packageVersion("future")
[16:05:01.314]                       }
[16:05:01.314]                       else {
[16:05:01.314]                         version <- NULL
[16:05:01.314]                       }
[16:05:01.314]                       if (!has_future || version < "1.8.0") {
[16:05:01.314]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.314]                           "", base::R.version$version.string), 
[16:05:01.314]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:01.314]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.314]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.314]                             "release", "version")], collapse = " "), 
[16:05:01.314]                           hostname = base::Sys.info()[["nodename"]])
[16:05:01.314]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.314]                           info)
[16:05:01.314]                         info <- base::paste(info, collapse = "; ")
[16:05:01.314]                         if (!has_future) {
[16:05:01.314]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.314]                             info)
[16:05:01.314]                         }
[16:05:01.314]                         else {
[16:05:01.314]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.314]                             info, version)
[16:05:01.314]                         }
[16:05:01.314]                         base::stop(msg)
[16:05:01.314]                       }
[16:05:01.314]                     })
[16:05:01.314]                   }
[16:05:01.314]                   options(future.plan = NULL)
[16:05:01.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.314]                 }
[16:05:01.314]                 ...future.workdir <- getwd()
[16:05:01.314]             }
[16:05:01.314]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.314]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.314]         }
[16:05:01.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.314]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.314]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.314]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.314]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.314]             base::names(...future.oldOptions))
[16:05:01.314]     }
[16:05:01.314]     if (FALSE) {
[16:05:01.314]     }
[16:05:01.314]     else {
[16:05:01.314]         if (TRUE) {
[16:05:01.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.314]                 open = "w")
[16:05:01.314]         }
[16:05:01.314]         else {
[16:05:01.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.314]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.314]         }
[16:05:01.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.314]             base::sink(type = "output", split = FALSE)
[16:05:01.314]             base::close(...future.stdout)
[16:05:01.314]         }, add = TRUE)
[16:05:01.314]     }
[16:05:01.314]     ...future.frame <- base::sys.nframe()
[16:05:01.314]     ...future.conditions <- base::list()
[16:05:01.314]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.314]     if (FALSE) {
[16:05:01.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.314]     }
[16:05:01.314]     ...future.result <- base::tryCatch({
[16:05:01.314]         base::withCallingHandlers({
[16:05:01.314]             ...future.value <- base::withVisible(base::local({
[16:05:01.314]                 x <- list(b = 2)
[16:05:01.314]                 x$a <- 1
[16:05:01.314]                 x
[16:05:01.314]             }))
[16:05:01.314]             future::FutureResult(value = ...future.value$value, 
[16:05:01.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.314]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.314]                     ...future.globalenv.names))
[16:05:01.314]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.314]         }, condition = base::local({
[16:05:01.314]             c <- base::c
[16:05:01.314]             inherits <- base::inherits
[16:05:01.314]             invokeRestart <- base::invokeRestart
[16:05:01.314]             length <- base::length
[16:05:01.314]             list <- base::list
[16:05:01.314]             seq.int <- base::seq.int
[16:05:01.314]             signalCondition <- base::signalCondition
[16:05:01.314]             sys.calls <- base::sys.calls
[16:05:01.314]             `[[` <- base::`[[`
[16:05:01.314]             `+` <- base::`+`
[16:05:01.314]             `<<-` <- base::`<<-`
[16:05:01.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.314]                   3L)]
[16:05:01.314]             }
[16:05:01.314]             function(cond) {
[16:05:01.314]                 is_error <- inherits(cond, "error")
[16:05:01.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.314]                   NULL)
[16:05:01.314]                 if (is_error) {
[16:05:01.314]                   sessionInformation <- function() {
[16:05:01.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.314]                       search = base::search(), system = base::Sys.info())
[16:05:01.314]                   }
[16:05:01.314]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.314]                     cond$call), session = sessionInformation(), 
[16:05:01.314]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.314]                   signalCondition(cond)
[16:05:01.314]                 }
[16:05:01.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.314]                 "immediateCondition"))) {
[16:05:01.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.314]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.314]                   if (TRUE && !signal) {
[16:05:01.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.314]                     {
[16:05:01.314]                       inherits <- base::inherits
[16:05:01.314]                       invokeRestart <- base::invokeRestart
[16:05:01.314]                       is.null <- base::is.null
[16:05:01.314]                       muffled <- FALSE
[16:05:01.314]                       if (inherits(cond, "message")) {
[16:05:01.314]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.314]                         if (muffled) 
[16:05:01.314]                           invokeRestart("muffleMessage")
[16:05:01.314]                       }
[16:05:01.314]                       else if (inherits(cond, "warning")) {
[16:05:01.314]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.314]                         if (muffled) 
[16:05:01.314]                           invokeRestart("muffleWarning")
[16:05:01.314]                       }
[16:05:01.314]                       else if (inherits(cond, "condition")) {
[16:05:01.314]                         if (!is.null(pattern)) {
[16:05:01.314]                           computeRestarts <- base::computeRestarts
[16:05:01.314]                           grepl <- base::grepl
[16:05:01.314]                           restarts <- computeRestarts(cond)
[16:05:01.314]                           for (restart in restarts) {
[16:05:01.314]                             name <- restart$name
[16:05:01.314]                             if (is.null(name)) 
[16:05:01.314]                               next
[16:05:01.314]                             if (!grepl(pattern, name)) 
[16:05:01.314]                               next
[16:05:01.314]                             invokeRestart(restart)
[16:05:01.314]                             muffled <- TRUE
[16:05:01.314]                             break
[16:05:01.314]                           }
[16:05:01.314]                         }
[16:05:01.314]                       }
[16:05:01.314]                       invisible(muffled)
[16:05:01.314]                     }
[16:05:01.314]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.314]                   }
[16:05:01.314]                 }
[16:05:01.314]                 else {
[16:05:01.314]                   if (TRUE) {
[16:05:01.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.314]                     {
[16:05:01.314]                       inherits <- base::inherits
[16:05:01.314]                       invokeRestart <- base::invokeRestart
[16:05:01.314]                       is.null <- base::is.null
[16:05:01.314]                       muffled <- FALSE
[16:05:01.314]                       if (inherits(cond, "message")) {
[16:05:01.314]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.314]                         if (muffled) 
[16:05:01.314]                           invokeRestart("muffleMessage")
[16:05:01.314]                       }
[16:05:01.314]                       else if (inherits(cond, "warning")) {
[16:05:01.314]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.314]                         if (muffled) 
[16:05:01.314]                           invokeRestart("muffleWarning")
[16:05:01.314]                       }
[16:05:01.314]                       else if (inherits(cond, "condition")) {
[16:05:01.314]                         if (!is.null(pattern)) {
[16:05:01.314]                           computeRestarts <- base::computeRestarts
[16:05:01.314]                           grepl <- base::grepl
[16:05:01.314]                           restarts <- computeRestarts(cond)
[16:05:01.314]                           for (restart in restarts) {
[16:05:01.314]                             name <- restart$name
[16:05:01.314]                             if (is.null(name)) 
[16:05:01.314]                               next
[16:05:01.314]                             if (!grepl(pattern, name)) 
[16:05:01.314]                               next
[16:05:01.314]                             invokeRestart(restart)
[16:05:01.314]                             muffled <- TRUE
[16:05:01.314]                             break
[16:05:01.314]                           }
[16:05:01.314]                         }
[16:05:01.314]                       }
[16:05:01.314]                       invisible(muffled)
[16:05:01.314]                     }
[16:05:01.314]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.314]                   }
[16:05:01.314]                 }
[16:05:01.314]             }
[16:05:01.314]         }))
[16:05:01.314]     }, error = function(ex) {
[16:05:01.314]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.314]                 ...future.rng), started = ...future.startTime, 
[16:05:01.314]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.314]             version = "1.8"), class = "FutureResult")
[16:05:01.314]     }, finally = {
[16:05:01.314]         if (!identical(...future.workdir, getwd())) 
[16:05:01.314]             setwd(...future.workdir)
[16:05:01.314]         {
[16:05:01.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.314]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.314]             }
[16:05:01.314]             base::options(...future.oldOptions)
[16:05:01.314]             if (.Platform$OS.type == "windows") {
[16:05:01.314]                 old_names <- names(...future.oldEnvVars)
[16:05:01.314]                 envs <- base::Sys.getenv()
[16:05:01.314]                 names <- names(envs)
[16:05:01.314]                 common <- intersect(names, old_names)
[16:05:01.314]                 added <- setdiff(names, old_names)
[16:05:01.314]                 removed <- setdiff(old_names, names)
[16:05:01.314]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.314]                   envs[common]]
[16:05:01.314]                 NAMES <- toupper(changed)
[16:05:01.314]                 args <- list()
[16:05:01.314]                 for (kk in seq_along(NAMES)) {
[16:05:01.314]                   name <- changed[[kk]]
[16:05:01.314]                   NAME <- NAMES[[kk]]
[16:05:01.314]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.314]                     next
[16:05:01.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.314]                 }
[16:05:01.314]                 NAMES <- toupper(added)
[16:05:01.314]                 for (kk in seq_along(NAMES)) {
[16:05:01.314]                   name <- added[[kk]]
[16:05:01.314]                   NAME <- NAMES[[kk]]
[16:05:01.314]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.314]                     next
[16:05:01.314]                   args[[name]] <- ""
[16:05:01.314]                 }
[16:05:01.314]                 NAMES <- toupper(removed)
[16:05:01.314]                 for (kk in seq_along(NAMES)) {
[16:05:01.314]                   name <- removed[[kk]]
[16:05:01.314]                   NAME <- NAMES[[kk]]
[16:05:01.314]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.314]                     next
[16:05:01.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.314]                 }
[16:05:01.314]                 if (length(args) > 0) 
[16:05:01.314]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.314]             }
[16:05:01.314]             else {
[16:05:01.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.314]             }
[16:05:01.314]             {
[16:05:01.314]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.314]                   0L) {
[16:05:01.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.314]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.314]                   base::options(opts)
[16:05:01.314]                 }
[16:05:01.314]                 {
[16:05:01.314]                   {
[16:05:01.314]                     NULL
[16:05:01.314]                     RNGkind("Mersenne-Twister")
[16:05:01.314]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:01.314]                       inherits = FALSE)
[16:05:01.314]                   }
[16:05:01.314]                   options(future.plan = NULL)
[16:05:01.314]                   if (is.na(NA_character_)) 
[16:05:01.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.314]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:01.314]                   {
[16:05:01.314]                     future <- SequentialFuture(..., envir = envir)
[16:05:01.314]                     if (!future$lazy) 
[16:05:01.314]                       future <- run(future)
[16:05:01.314]                     invisible(future)
[16:05:01.314]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.314]                 }
[16:05:01.314]             }
[16:05:01.314]         }
[16:05:01.314]     })
[16:05:01.314]     if (TRUE) {
[16:05:01.314]         base::sink(type = "output", split = FALSE)
[16:05:01.314]         if (TRUE) {
[16:05:01.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.314]         }
[16:05:01.314]         else {
[16:05:01.314]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.314]         }
[16:05:01.314]         base::close(...future.stdout)
[16:05:01.314]         ...future.stdout <- NULL
[16:05:01.314]     }
[16:05:01.314]     ...future.result$conditions <- ...future.conditions
[16:05:01.314]     ...future.result$finished <- base::Sys.time()
[16:05:01.314]     ...future.result
[16:05:01.314] }
[16:05:01.316] plan(): Setting new future strategy stack:
[16:05:01.316] List of future strategies:
[16:05:01.316] 1. sequential:
[16:05:01.316]    - args: function (..., envir = parent.frame())
[16:05:01.316]    - tweaked: FALSE
[16:05:01.316]    - call: NULL
[16:05:01.317] plan(): nbrOfWorkers() = 1
[16:05:01.317] plan(): Setting new future strategy stack:
[16:05:01.317] List of future strategies:
[16:05:01.317] 1. sequential:
[16:05:01.317]    - args: function (..., envir = parent.frame())
[16:05:01.317]    - tweaked: FALSE
[16:05:01.317]    - call: plan(strategy)
[16:05:01.318] plan(): nbrOfWorkers() = 1
[16:05:01.318] SequentialFuture started (and completed)
[16:05:01.318] - Launch lazy future ... done
[16:05:01.318] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.318] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.319] Searching for globals...
[16:05:01.320] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:01.321] Searching for globals ... DONE
[16:05:01.321] Resolving globals: TRUE
[16:05:01.321] Resolving any globals that are futures ...
[16:05:01.321] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:01.321] Resolving any globals that are futures ... DONE
[16:05:01.321] Resolving futures part of globals (recursively) ...
[16:05:01.322] resolve() on list ...
[16:05:01.322]  recursive: 99
[16:05:01.322]  length: 1
[16:05:01.322]  elements: ‘x’
[16:05:01.322]  length: 0 (resolved future 1)
[16:05:01.322] resolve() on list ... DONE
[16:05:01.322] - globals: [1] ‘x’
[16:05:01.322] Resolving futures part of globals (recursively) ... DONE
[16:05:01.322] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.323] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.323] - globals: [1] ‘x’
[16:05:01.323] 
[16:05:01.323] getGlobalsAndPackages() ... DONE
[16:05:01.323] run() for ‘Future’ ...
[16:05:01.323] - state: ‘created’
[16:05:01.323] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:01.324] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:01.324] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:01.324]   - Field: ‘label’
[16:05:01.324]   - Field: ‘local’
[16:05:01.324]   - Field: ‘owner’
[16:05:01.324]   - Field: ‘envir’
[16:05:01.324]   - Field: ‘packages’
[16:05:01.324]   - Field: ‘gc’
[16:05:01.325]   - Field: ‘conditions’
[16:05:01.325]   - Field: ‘expr’
[16:05:01.325]   - Field: ‘uuid’
[16:05:01.325]   - Field: ‘seed’
[16:05:01.325]   - Field: ‘version’
[16:05:01.325]   - Field: ‘result’
[16:05:01.325]   - Field: ‘asynchronous’
[16:05:01.325]   - Field: ‘calls’
[16:05:01.325]   - Field: ‘globals’
[16:05:01.325]   - Field: ‘stdout’
[16:05:01.325]   - Field: ‘earlySignal’
[16:05:01.326]   - Field: ‘lazy’
[16:05:01.326]   - Field: ‘state’
[16:05:01.326] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:01.326] - Launch lazy future ...
[16:05:01.326] Packages needed by the future expression (n = 0): <none>
[16:05:01.326] Packages needed by future strategies (n = 0): <none>
[16:05:01.327] {
[16:05:01.327]     {
[16:05:01.327]         {
[16:05:01.327]             ...future.startTime <- base::Sys.time()
[16:05:01.327]             {
[16:05:01.327]                 {
[16:05:01.327]                   {
[16:05:01.327]                     base::local({
[16:05:01.327]                       has_future <- base::requireNamespace("future", 
[16:05:01.327]                         quietly = TRUE)
[16:05:01.327]                       if (has_future) {
[16:05:01.327]                         ns <- base::getNamespace("future")
[16:05:01.327]                         version <- ns[[".package"]][["version"]]
[16:05:01.327]                         if (is.null(version)) 
[16:05:01.327]                           version <- utils::packageVersion("future")
[16:05:01.327]                       }
[16:05:01.327]                       else {
[16:05:01.327]                         version <- NULL
[16:05:01.327]                       }
[16:05:01.327]                       if (!has_future || version < "1.8.0") {
[16:05:01.327]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.327]                           "", base::R.version$version.string), 
[16:05:01.327]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:01.327]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.327]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.327]                             "release", "version")], collapse = " "), 
[16:05:01.327]                           hostname = base::Sys.info()[["nodename"]])
[16:05:01.327]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.327]                           info)
[16:05:01.327]                         info <- base::paste(info, collapse = "; ")
[16:05:01.327]                         if (!has_future) {
[16:05:01.327]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.327]                             info)
[16:05:01.327]                         }
[16:05:01.327]                         else {
[16:05:01.327]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.327]                             info, version)
[16:05:01.327]                         }
[16:05:01.327]                         base::stop(msg)
[16:05:01.327]                       }
[16:05:01.327]                     })
[16:05:01.327]                   }
[16:05:01.327]                   options(future.plan = NULL)
[16:05:01.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.327]                 }
[16:05:01.327]                 ...future.workdir <- getwd()
[16:05:01.327]             }
[16:05:01.327]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.327]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.327]         }
[16:05:01.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.327]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.327]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.327]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.327]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.327]             base::names(...future.oldOptions))
[16:05:01.327]     }
[16:05:01.327]     if (FALSE) {
[16:05:01.327]     }
[16:05:01.327]     else {
[16:05:01.327]         if (TRUE) {
[16:05:01.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.327]                 open = "w")
[16:05:01.327]         }
[16:05:01.327]         else {
[16:05:01.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.327]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.327]         }
[16:05:01.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.327]             base::sink(type = "output", split = FALSE)
[16:05:01.327]             base::close(...future.stdout)
[16:05:01.327]         }, add = TRUE)
[16:05:01.327]     }
[16:05:01.327]     ...future.frame <- base::sys.nframe()
[16:05:01.327]     ...future.conditions <- base::list()
[16:05:01.327]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.327]     if (FALSE) {
[16:05:01.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.327]     }
[16:05:01.327]     ...future.result <- base::tryCatch({
[16:05:01.327]         base::withCallingHandlers({
[16:05:01.327]             ...future.value <- base::withVisible(base::local({
[16:05:01.327]                 x[["a"]] <- 1
[16:05:01.327]                 x
[16:05:01.327]             }))
[16:05:01.327]             future::FutureResult(value = ...future.value$value, 
[16:05:01.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.327]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.327]                     ...future.globalenv.names))
[16:05:01.327]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.327]         }, condition = base::local({
[16:05:01.327]             c <- base::c
[16:05:01.327]             inherits <- base::inherits
[16:05:01.327]             invokeRestart <- base::invokeRestart
[16:05:01.327]             length <- base::length
[16:05:01.327]             list <- base::list
[16:05:01.327]             seq.int <- base::seq.int
[16:05:01.327]             signalCondition <- base::signalCondition
[16:05:01.327]             sys.calls <- base::sys.calls
[16:05:01.327]             `[[` <- base::`[[`
[16:05:01.327]             `+` <- base::`+`
[16:05:01.327]             `<<-` <- base::`<<-`
[16:05:01.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.327]                   3L)]
[16:05:01.327]             }
[16:05:01.327]             function(cond) {
[16:05:01.327]                 is_error <- inherits(cond, "error")
[16:05:01.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.327]                   NULL)
[16:05:01.327]                 if (is_error) {
[16:05:01.327]                   sessionInformation <- function() {
[16:05:01.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.327]                       search = base::search(), system = base::Sys.info())
[16:05:01.327]                   }
[16:05:01.327]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.327]                     cond$call), session = sessionInformation(), 
[16:05:01.327]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.327]                   signalCondition(cond)
[16:05:01.327]                 }
[16:05:01.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.327]                 "immediateCondition"))) {
[16:05:01.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.327]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.327]                   if (TRUE && !signal) {
[16:05:01.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.327]                     {
[16:05:01.327]                       inherits <- base::inherits
[16:05:01.327]                       invokeRestart <- base::invokeRestart
[16:05:01.327]                       is.null <- base::is.null
[16:05:01.327]                       muffled <- FALSE
[16:05:01.327]                       if (inherits(cond, "message")) {
[16:05:01.327]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.327]                         if (muffled) 
[16:05:01.327]                           invokeRestart("muffleMessage")
[16:05:01.327]                       }
[16:05:01.327]                       else if (inherits(cond, "warning")) {
[16:05:01.327]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.327]                         if (muffled) 
[16:05:01.327]                           invokeRestart("muffleWarning")
[16:05:01.327]                       }
[16:05:01.327]                       else if (inherits(cond, "condition")) {
[16:05:01.327]                         if (!is.null(pattern)) {
[16:05:01.327]                           computeRestarts <- base::computeRestarts
[16:05:01.327]                           grepl <- base::grepl
[16:05:01.327]                           restarts <- computeRestarts(cond)
[16:05:01.327]                           for (restart in restarts) {
[16:05:01.327]                             name <- restart$name
[16:05:01.327]                             if (is.null(name)) 
[16:05:01.327]                               next
[16:05:01.327]                             if (!grepl(pattern, name)) 
[16:05:01.327]                               next
[16:05:01.327]                             invokeRestart(restart)
[16:05:01.327]                             muffled <- TRUE
[16:05:01.327]                             break
[16:05:01.327]                           }
[16:05:01.327]                         }
[16:05:01.327]                       }
[16:05:01.327]                       invisible(muffled)
[16:05:01.327]                     }
[16:05:01.327]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.327]                   }
[16:05:01.327]                 }
[16:05:01.327]                 else {
[16:05:01.327]                   if (TRUE) {
[16:05:01.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.327]                     {
[16:05:01.327]                       inherits <- base::inherits
[16:05:01.327]                       invokeRestart <- base::invokeRestart
[16:05:01.327]                       is.null <- base::is.null
[16:05:01.327]                       muffled <- FALSE
[16:05:01.327]                       if (inherits(cond, "message")) {
[16:05:01.327]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.327]                         if (muffled) 
[16:05:01.327]                           invokeRestart("muffleMessage")
[16:05:01.327]                       }
[16:05:01.327]                       else if (inherits(cond, "warning")) {
[16:05:01.327]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.327]                         if (muffled) 
[16:05:01.327]                           invokeRestart("muffleWarning")
[16:05:01.327]                       }
[16:05:01.327]                       else if (inherits(cond, "condition")) {
[16:05:01.327]                         if (!is.null(pattern)) {
[16:05:01.327]                           computeRestarts <- base::computeRestarts
[16:05:01.327]                           grepl <- base::grepl
[16:05:01.327]                           restarts <- computeRestarts(cond)
[16:05:01.327]                           for (restart in restarts) {
[16:05:01.327]                             name <- restart$name
[16:05:01.327]                             if (is.null(name)) 
[16:05:01.327]                               next
[16:05:01.327]                             if (!grepl(pattern, name)) 
[16:05:01.327]                               next
[16:05:01.327]                             invokeRestart(restart)
[16:05:01.327]                             muffled <- TRUE
[16:05:01.327]                             break
[16:05:01.327]                           }
[16:05:01.327]                         }
[16:05:01.327]                       }
[16:05:01.327]                       invisible(muffled)
[16:05:01.327]                     }
[16:05:01.327]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.327]                   }
[16:05:01.327]                 }
[16:05:01.327]             }
[16:05:01.327]         }))
[16:05:01.327]     }, error = function(ex) {
[16:05:01.327]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.327]                 ...future.rng), started = ...future.startTime, 
[16:05:01.327]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.327]             version = "1.8"), class = "FutureResult")
[16:05:01.327]     }, finally = {
[16:05:01.327]         if (!identical(...future.workdir, getwd())) 
[16:05:01.327]             setwd(...future.workdir)
[16:05:01.327]         {
[16:05:01.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.327]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.327]             }
[16:05:01.327]             base::options(...future.oldOptions)
[16:05:01.327]             if (.Platform$OS.type == "windows") {
[16:05:01.327]                 old_names <- names(...future.oldEnvVars)
[16:05:01.327]                 envs <- base::Sys.getenv()
[16:05:01.327]                 names <- names(envs)
[16:05:01.327]                 common <- intersect(names, old_names)
[16:05:01.327]                 added <- setdiff(names, old_names)
[16:05:01.327]                 removed <- setdiff(old_names, names)
[16:05:01.327]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.327]                   envs[common]]
[16:05:01.327]                 NAMES <- toupper(changed)
[16:05:01.327]                 args <- list()
[16:05:01.327]                 for (kk in seq_along(NAMES)) {
[16:05:01.327]                   name <- changed[[kk]]
[16:05:01.327]                   NAME <- NAMES[[kk]]
[16:05:01.327]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.327]                     next
[16:05:01.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.327]                 }
[16:05:01.327]                 NAMES <- toupper(added)
[16:05:01.327]                 for (kk in seq_along(NAMES)) {
[16:05:01.327]                   name <- added[[kk]]
[16:05:01.327]                   NAME <- NAMES[[kk]]
[16:05:01.327]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.327]                     next
[16:05:01.327]                   args[[name]] <- ""
[16:05:01.327]                 }
[16:05:01.327]                 NAMES <- toupper(removed)
[16:05:01.327]                 for (kk in seq_along(NAMES)) {
[16:05:01.327]                   name <- removed[[kk]]
[16:05:01.327]                   NAME <- NAMES[[kk]]
[16:05:01.327]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.327]                     next
[16:05:01.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.327]                 }
[16:05:01.327]                 if (length(args) > 0) 
[16:05:01.327]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.327]             }
[16:05:01.327]             else {
[16:05:01.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.327]             }
[16:05:01.327]             {
[16:05:01.327]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.327]                   0L) {
[16:05:01.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.327]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.327]                   base::options(opts)
[16:05:01.327]                 }
[16:05:01.327]                 {
[16:05:01.327]                   {
[16:05:01.327]                     NULL
[16:05:01.327]                     RNGkind("Mersenne-Twister")
[16:05:01.327]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:01.327]                       inherits = FALSE)
[16:05:01.327]                   }
[16:05:01.327]                   options(future.plan = NULL)
[16:05:01.327]                   if (is.na(NA_character_)) 
[16:05:01.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.327]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:01.327]                   {
[16:05:01.327]                     future <- SequentialFuture(..., envir = envir)
[16:05:01.327]                     if (!future$lazy) 
[16:05:01.327]                       future <- run(future)
[16:05:01.327]                     invisible(future)
[16:05:01.327]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.327]                 }
[16:05:01.327]             }
[16:05:01.327]         }
[16:05:01.327]     })
[16:05:01.327]     if (TRUE) {
[16:05:01.327]         base::sink(type = "output", split = FALSE)
[16:05:01.327]         if (TRUE) {
[16:05:01.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.327]         }
[16:05:01.327]         else {
[16:05:01.327]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.327]         }
[16:05:01.327]         base::close(...future.stdout)
[16:05:01.327]         ...future.stdout <- NULL
[16:05:01.327]     }
[16:05:01.327]     ...future.result$conditions <- ...future.conditions
[16:05:01.327]     ...future.result$finished <- base::Sys.time()
[16:05:01.327]     ...future.result
[16:05:01.327] }
[16:05:01.328] assign_globals() ...
[16:05:01.328] List of 1
[16:05:01.328]  $ x: list()
[16:05:01.328]  - attr(*, "where")=List of 1
[16:05:01.328]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.328]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.328]  - attr(*, "resolved")= logi TRUE
[16:05:01.328]  - attr(*, "total_size")= num 0
[16:05:01.328]  - attr(*, "already-done")= logi TRUE
[16:05:01.331] - copied ‘x’ to environment
[16:05:01.331] assign_globals() ... done
[16:05:01.331] plan(): Setting new future strategy stack:
[16:05:01.331] List of future strategies:
[16:05:01.331] 1. sequential:
[16:05:01.331]    - args: function (..., envir = parent.frame())
[16:05:01.331]    - tweaked: FALSE
[16:05:01.331]    - call: NULL
[16:05:01.331] plan(): nbrOfWorkers() = 1
[16:05:01.332] plan(): Setting new future strategy stack:
[16:05:01.332] List of future strategies:
[16:05:01.332] 1. sequential:
[16:05:01.332]    - args: function (..., envir = parent.frame())
[16:05:01.332]    - tweaked: FALSE
[16:05:01.332]    - call: plan(strategy)
[16:05:01.332] plan(): nbrOfWorkers() = 1
[16:05:01.333] SequentialFuture started (and completed)
[16:05:01.333] - Launch lazy future ... done
[16:05:01.333] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.333] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.333] Searching for globals...
[16:05:01.337] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:01.337] Searching for globals ... DONE
[16:05:01.337] Resolving globals: TRUE
[16:05:01.337] Resolving any globals that are futures ...
[16:05:01.337] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:01.337] Resolving any globals that are futures ... DONE
[16:05:01.338] Resolving futures part of globals (recursively) ...
[16:05:01.338] resolve() on list ...
[16:05:01.338]  recursive: 99
[16:05:01.338]  length: 1
[16:05:01.338]  elements: ‘x’
[16:05:01.338]  length: 0 (resolved future 1)
[16:05:01.338] resolve() on list ... DONE
[16:05:01.339] - globals: [1] ‘x’
[16:05:01.339] Resolving futures part of globals (recursively) ... DONE
[16:05:01.339] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.339] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.339] - globals: [1] ‘x’
[16:05:01.339] 
[16:05:01.339] getGlobalsAndPackages() ... DONE
[16:05:01.340] run() for ‘Future’ ...
[16:05:01.340] - state: ‘created’
[16:05:01.340] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:01.340] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:01.340] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:01.340]   - Field: ‘label’
[16:05:01.340]   - Field: ‘local’
[16:05:01.341]   - Field: ‘owner’
[16:05:01.341]   - Field: ‘envir’
[16:05:01.341]   - Field: ‘packages’
[16:05:01.341]   - Field: ‘gc’
[16:05:01.341]   - Field: ‘conditions’
[16:05:01.341]   - Field: ‘expr’
[16:05:01.341]   - Field: ‘uuid’
[16:05:01.341]   - Field: ‘seed’
[16:05:01.341]   - Field: ‘version’
[16:05:01.341]   - Field: ‘result’
[16:05:01.341]   - Field: ‘asynchronous’
[16:05:01.342]   - Field: ‘calls’
[16:05:01.342]   - Field: ‘globals’
[16:05:01.342]   - Field: ‘stdout’
[16:05:01.342]   - Field: ‘earlySignal’
[16:05:01.342]   - Field: ‘lazy’
[16:05:01.342]   - Field: ‘state’
[16:05:01.342] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:01.342] - Launch lazy future ...
[16:05:01.342] Packages needed by the future expression (n = 0): <none>
[16:05:01.342] Packages needed by future strategies (n = 0): <none>
[16:05:01.343] {
[16:05:01.343]     {
[16:05:01.343]         {
[16:05:01.343]             ...future.startTime <- base::Sys.time()
[16:05:01.343]             {
[16:05:01.343]                 {
[16:05:01.343]                   {
[16:05:01.343]                     base::local({
[16:05:01.343]                       has_future <- base::requireNamespace("future", 
[16:05:01.343]                         quietly = TRUE)
[16:05:01.343]                       if (has_future) {
[16:05:01.343]                         ns <- base::getNamespace("future")
[16:05:01.343]                         version <- ns[[".package"]][["version"]]
[16:05:01.343]                         if (is.null(version)) 
[16:05:01.343]                           version <- utils::packageVersion("future")
[16:05:01.343]                       }
[16:05:01.343]                       else {
[16:05:01.343]                         version <- NULL
[16:05:01.343]                       }
[16:05:01.343]                       if (!has_future || version < "1.8.0") {
[16:05:01.343]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.343]                           "", base::R.version$version.string), 
[16:05:01.343]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:01.343]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.343]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.343]                             "release", "version")], collapse = " "), 
[16:05:01.343]                           hostname = base::Sys.info()[["nodename"]])
[16:05:01.343]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.343]                           info)
[16:05:01.343]                         info <- base::paste(info, collapse = "; ")
[16:05:01.343]                         if (!has_future) {
[16:05:01.343]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.343]                             info)
[16:05:01.343]                         }
[16:05:01.343]                         else {
[16:05:01.343]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.343]                             info, version)
[16:05:01.343]                         }
[16:05:01.343]                         base::stop(msg)
[16:05:01.343]                       }
[16:05:01.343]                     })
[16:05:01.343]                   }
[16:05:01.343]                   options(future.plan = NULL)
[16:05:01.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.343]                 }
[16:05:01.343]                 ...future.workdir <- getwd()
[16:05:01.343]             }
[16:05:01.343]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.343]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.343]         }
[16:05:01.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.343]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.343]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.343]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.343]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.343]             base::names(...future.oldOptions))
[16:05:01.343]     }
[16:05:01.343]     if (FALSE) {
[16:05:01.343]     }
[16:05:01.343]     else {
[16:05:01.343]         if (TRUE) {
[16:05:01.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.343]                 open = "w")
[16:05:01.343]         }
[16:05:01.343]         else {
[16:05:01.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.343]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.343]         }
[16:05:01.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.343]             base::sink(type = "output", split = FALSE)
[16:05:01.343]             base::close(...future.stdout)
[16:05:01.343]         }, add = TRUE)
[16:05:01.343]     }
[16:05:01.343]     ...future.frame <- base::sys.nframe()
[16:05:01.343]     ...future.conditions <- base::list()
[16:05:01.343]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.343]     if (FALSE) {
[16:05:01.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.343]     }
[16:05:01.343]     ...future.result <- base::tryCatch({
[16:05:01.343]         base::withCallingHandlers({
[16:05:01.343]             ...future.value <- base::withVisible(base::local({
[16:05:01.343]                 x[["a"]] <- 1
[16:05:01.343]                 x
[16:05:01.343]             }))
[16:05:01.343]             future::FutureResult(value = ...future.value$value, 
[16:05:01.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.343]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.343]                     ...future.globalenv.names))
[16:05:01.343]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.343]         }, condition = base::local({
[16:05:01.343]             c <- base::c
[16:05:01.343]             inherits <- base::inherits
[16:05:01.343]             invokeRestart <- base::invokeRestart
[16:05:01.343]             length <- base::length
[16:05:01.343]             list <- base::list
[16:05:01.343]             seq.int <- base::seq.int
[16:05:01.343]             signalCondition <- base::signalCondition
[16:05:01.343]             sys.calls <- base::sys.calls
[16:05:01.343]             `[[` <- base::`[[`
[16:05:01.343]             `+` <- base::`+`
[16:05:01.343]             `<<-` <- base::`<<-`
[16:05:01.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.343]                   3L)]
[16:05:01.343]             }
[16:05:01.343]             function(cond) {
[16:05:01.343]                 is_error <- inherits(cond, "error")
[16:05:01.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.343]                   NULL)
[16:05:01.343]                 if (is_error) {
[16:05:01.343]                   sessionInformation <- function() {
[16:05:01.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.343]                       search = base::search(), system = base::Sys.info())
[16:05:01.343]                   }
[16:05:01.343]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.343]                     cond$call), session = sessionInformation(), 
[16:05:01.343]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.343]                   signalCondition(cond)
[16:05:01.343]                 }
[16:05:01.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.343]                 "immediateCondition"))) {
[16:05:01.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.343]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.343]                   if (TRUE && !signal) {
[16:05:01.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.343]                     {
[16:05:01.343]                       inherits <- base::inherits
[16:05:01.343]                       invokeRestart <- base::invokeRestart
[16:05:01.343]                       is.null <- base::is.null
[16:05:01.343]                       muffled <- FALSE
[16:05:01.343]                       if (inherits(cond, "message")) {
[16:05:01.343]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.343]                         if (muffled) 
[16:05:01.343]                           invokeRestart("muffleMessage")
[16:05:01.343]                       }
[16:05:01.343]                       else if (inherits(cond, "warning")) {
[16:05:01.343]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.343]                         if (muffled) 
[16:05:01.343]                           invokeRestart("muffleWarning")
[16:05:01.343]                       }
[16:05:01.343]                       else if (inherits(cond, "condition")) {
[16:05:01.343]                         if (!is.null(pattern)) {
[16:05:01.343]                           computeRestarts <- base::computeRestarts
[16:05:01.343]                           grepl <- base::grepl
[16:05:01.343]                           restarts <- computeRestarts(cond)
[16:05:01.343]                           for (restart in restarts) {
[16:05:01.343]                             name <- restart$name
[16:05:01.343]                             if (is.null(name)) 
[16:05:01.343]                               next
[16:05:01.343]                             if (!grepl(pattern, name)) 
[16:05:01.343]                               next
[16:05:01.343]                             invokeRestart(restart)
[16:05:01.343]                             muffled <- TRUE
[16:05:01.343]                             break
[16:05:01.343]                           }
[16:05:01.343]                         }
[16:05:01.343]                       }
[16:05:01.343]                       invisible(muffled)
[16:05:01.343]                     }
[16:05:01.343]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.343]                   }
[16:05:01.343]                 }
[16:05:01.343]                 else {
[16:05:01.343]                   if (TRUE) {
[16:05:01.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.343]                     {
[16:05:01.343]                       inherits <- base::inherits
[16:05:01.343]                       invokeRestart <- base::invokeRestart
[16:05:01.343]                       is.null <- base::is.null
[16:05:01.343]                       muffled <- FALSE
[16:05:01.343]                       if (inherits(cond, "message")) {
[16:05:01.343]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.343]                         if (muffled) 
[16:05:01.343]                           invokeRestart("muffleMessage")
[16:05:01.343]                       }
[16:05:01.343]                       else if (inherits(cond, "warning")) {
[16:05:01.343]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.343]                         if (muffled) 
[16:05:01.343]                           invokeRestart("muffleWarning")
[16:05:01.343]                       }
[16:05:01.343]                       else if (inherits(cond, "condition")) {
[16:05:01.343]                         if (!is.null(pattern)) {
[16:05:01.343]                           computeRestarts <- base::computeRestarts
[16:05:01.343]                           grepl <- base::grepl
[16:05:01.343]                           restarts <- computeRestarts(cond)
[16:05:01.343]                           for (restart in restarts) {
[16:05:01.343]                             name <- restart$name
[16:05:01.343]                             if (is.null(name)) 
[16:05:01.343]                               next
[16:05:01.343]                             if (!grepl(pattern, name)) 
[16:05:01.343]                               next
[16:05:01.343]                             invokeRestart(restart)
[16:05:01.343]                             muffled <- TRUE
[16:05:01.343]                             break
[16:05:01.343]                           }
[16:05:01.343]                         }
[16:05:01.343]                       }
[16:05:01.343]                       invisible(muffled)
[16:05:01.343]                     }
[16:05:01.343]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.343]                   }
[16:05:01.343]                 }
[16:05:01.343]             }
[16:05:01.343]         }))
[16:05:01.343]     }, error = function(ex) {
[16:05:01.343]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.343]                 ...future.rng), started = ...future.startTime, 
[16:05:01.343]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.343]             version = "1.8"), class = "FutureResult")
[16:05:01.343]     }, finally = {
[16:05:01.343]         if (!identical(...future.workdir, getwd())) 
[16:05:01.343]             setwd(...future.workdir)
[16:05:01.343]         {
[16:05:01.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.343]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.343]             }
[16:05:01.343]             base::options(...future.oldOptions)
[16:05:01.343]             if (.Platform$OS.type == "windows") {
[16:05:01.343]                 old_names <- names(...future.oldEnvVars)
[16:05:01.343]                 envs <- base::Sys.getenv()
[16:05:01.343]                 names <- names(envs)
[16:05:01.343]                 common <- intersect(names, old_names)
[16:05:01.343]                 added <- setdiff(names, old_names)
[16:05:01.343]                 removed <- setdiff(old_names, names)
[16:05:01.343]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.343]                   envs[common]]
[16:05:01.343]                 NAMES <- toupper(changed)
[16:05:01.343]                 args <- list()
[16:05:01.343]                 for (kk in seq_along(NAMES)) {
[16:05:01.343]                   name <- changed[[kk]]
[16:05:01.343]                   NAME <- NAMES[[kk]]
[16:05:01.343]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.343]                     next
[16:05:01.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.343]                 }
[16:05:01.343]                 NAMES <- toupper(added)
[16:05:01.343]                 for (kk in seq_along(NAMES)) {
[16:05:01.343]                   name <- added[[kk]]
[16:05:01.343]                   NAME <- NAMES[[kk]]
[16:05:01.343]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.343]                     next
[16:05:01.343]                   args[[name]] <- ""
[16:05:01.343]                 }
[16:05:01.343]                 NAMES <- toupper(removed)
[16:05:01.343]                 for (kk in seq_along(NAMES)) {
[16:05:01.343]                   name <- removed[[kk]]
[16:05:01.343]                   NAME <- NAMES[[kk]]
[16:05:01.343]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.343]                     next
[16:05:01.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.343]                 }
[16:05:01.343]                 if (length(args) > 0) 
[16:05:01.343]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.343]             }
[16:05:01.343]             else {
[16:05:01.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.343]             }
[16:05:01.343]             {
[16:05:01.343]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.343]                   0L) {
[16:05:01.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.343]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.343]                   base::options(opts)
[16:05:01.343]                 }
[16:05:01.343]                 {
[16:05:01.343]                   {
[16:05:01.343]                     NULL
[16:05:01.343]                     RNGkind("Mersenne-Twister")
[16:05:01.343]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:01.343]                       inherits = FALSE)
[16:05:01.343]                   }
[16:05:01.343]                   options(future.plan = NULL)
[16:05:01.343]                   if (is.na(NA_character_)) 
[16:05:01.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.343]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:01.343]                   {
[16:05:01.343]                     future <- SequentialFuture(..., envir = envir)
[16:05:01.343]                     if (!future$lazy) 
[16:05:01.343]                       future <- run(future)
[16:05:01.343]                     invisible(future)
[16:05:01.343]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.343]                 }
[16:05:01.343]             }
[16:05:01.343]         }
[16:05:01.343]     })
[16:05:01.343]     if (TRUE) {
[16:05:01.343]         base::sink(type = "output", split = FALSE)
[16:05:01.343]         if (TRUE) {
[16:05:01.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.343]         }
[16:05:01.343]         else {
[16:05:01.343]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.343]         }
[16:05:01.343]         base::close(...future.stdout)
[16:05:01.343]         ...future.stdout <- NULL
[16:05:01.343]     }
[16:05:01.343]     ...future.result$conditions <- ...future.conditions
[16:05:01.343]     ...future.result$finished <- base::Sys.time()
[16:05:01.343]     ...future.result
[16:05:01.343] }
[16:05:01.344] assign_globals() ...
[16:05:01.345] List of 1
[16:05:01.345]  $ x: list()
[16:05:01.345]  - attr(*, "where")=List of 1
[16:05:01.345]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.345]  - attr(*, "resolved")= logi TRUE
[16:05:01.345]  - attr(*, "total_size")= num 0
[16:05:01.345]  - attr(*, "already-done")= logi TRUE
[16:05:01.347] - copied ‘x’ to environment
[16:05:01.347] assign_globals() ... done
[16:05:01.347] plan(): Setting new future strategy stack:
[16:05:01.347] List of future strategies:
[16:05:01.347] 1. sequential:
[16:05:01.347]    - args: function (..., envir = parent.frame())
[16:05:01.347]    - tweaked: FALSE
[16:05:01.347]    - call: NULL
[16:05:01.348] plan(): nbrOfWorkers() = 1
[16:05:01.348] plan(): Setting new future strategy stack:
[16:05:01.348] List of future strategies:
[16:05:01.348] 1. sequential:
[16:05:01.348]    - args: function (..., envir = parent.frame())
[16:05:01.348]    - tweaked: FALSE
[16:05:01.348]    - call: plan(strategy)
[16:05:01.349] plan(): nbrOfWorkers() = 1
[16:05:01.349] SequentialFuture started (and completed)
[16:05:01.349] - Launch lazy future ... done
[16:05:01.349] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.350] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.350] Searching for globals...
[16:05:01.352] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:01.352] Searching for globals ... DONE
[16:05:01.352] Resolving globals: TRUE
[16:05:01.352] Resolving any globals that are futures ...
[16:05:01.352] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:01.352] Resolving any globals that are futures ... DONE
[16:05:01.353] Resolving futures part of globals (recursively) ...
[16:05:01.353] resolve() on list ...
[16:05:01.353]  recursive: 99
[16:05:01.353]  length: 1
[16:05:01.353]  elements: ‘x’
[16:05:01.353]  length: 0 (resolved future 1)
[16:05:01.353] resolve() on list ... DONE
[16:05:01.353] - globals: [1] ‘x’
[16:05:01.353] Resolving futures part of globals (recursively) ... DONE
[16:05:01.354] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.354] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.354] - globals: [1] ‘x’
[16:05:01.354] 
[16:05:01.354] getGlobalsAndPackages() ... DONE
[16:05:01.354] run() for ‘Future’ ...
[16:05:01.355] - state: ‘created’
[16:05:01.355] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:01.355] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:01.355] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:01.355]   - Field: ‘label’
[16:05:01.355]   - Field: ‘local’
[16:05:01.355]   - Field: ‘owner’
[16:05:01.356]   - Field: ‘envir’
[16:05:01.356]   - Field: ‘packages’
[16:05:01.356]   - Field: ‘gc’
[16:05:01.356]   - Field: ‘conditions’
[16:05:01.356]   - Field: ‘expr’
[16:05:01.356]   - Field: ‘uuid’
[16:05:01.356]   - Field: ‘seed’
[16:05:01.356]   - Field: ‘version’
[16:05:01.356]   - Field: ‘result’
[16:05:01.356]   - Field: ‘asynchronous’
[16:05:01.356]   - Field: ‘calls’
[16:05:01.357]   - Field: ‘globals’
[16:05:01.357]   - Field: ‘stdout’
[16:05:01.357]   - Field: ‘earlySignal’
[16:05:01.357]   - Field: ‘lazy’
[16:05:01.357]   - Field: ‘state’
[16:05:01.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:01.357] - Launch lazy future ...
[16:05:01.357] Packages needed by the future expression (n = 0): <none>
[16:05:01.357] Packages needed by future strategies (n = 0): <none>
[16:05:01.358] {
[16:05:01.358]     {
[16:05:01.358]         {
[16:05:01.358]             ...future.startTime <- base::Sys.time()
[16:05:01.358]             {
[16:05:01.358]                 {
[16:05:01.358]                   {
[16:05:01.358]                     base::local({
[16:05:01.358]                       has_future <- base::requireNamespace("future", 
[16:05:01.358]                         quietly = TRUE)
[16:05:01.358]                       if (has_future) {
[16:05:01.358]                         ns <- base::getNamespace("future")
[16:05:01.358]                         version <- ns[[".package"]][["version"]]
[16:05:01.358]                         if (is.null(version)) 
[16:05:01.358]                           version <- utils::packageVersion("future")
[16:05:01.358]                       }
[16:05:01.358]                       else {
[16:05:01.358]                         version <- NULL
[16:05:01.358]                       }
[16:05:01.358]                       if (!has_future || version < "1.8.0") {
[16:05:01.358]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.358]                           "", base::R.version$version.string), 
[16:05:01.358]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:01.358]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.358]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.358]                             "release", "version")], collapse = " "), 
[16:05:01.358]                           hostname = base::Sys.info()[["nodename"]])
[16:05:01.358]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.358]                           info)
[16:05:01.358]                         info <- base::paste(info, collapse = "; ")
[16:05:01.358]                         if (!has_future) {
[16:05:01.358]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.358]                             info)
[16:05:01.358]                         }
[16:05:01.358]                         else {
[16:05:01.358]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.358]                             info, version)
[16:05:01.358]                         }
[16:05:01.358]                         base::stop(msg)
[16:05:01.358]                       }
[16:05:01.358]                     })
[16:05:01.358]                   }
[16:05:01.358]                   options(future.plan = NULL)
[16:05:01.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.358]                 }
[16:05:01.358]                 ...future.workdir <- getwd()
[16:05:01.358]             }
[16:05:01.358]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.358]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.358]         }
[16:05:01.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.358]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.358]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.358]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.358]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.358]             base::names(...future.oldOptions))
[16:05:01.358]     }
[16:05:01.358]     if (FALSE) {
[16:05:01.358]     }
[16:05:01.358]     else {
[16:05:01.358]         if (TRUE) {
[16:05:01.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.358]                 open = "w")
[16:05:01.358]         }
[16:05:01.358]         else {
[16:05:01.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.358]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.358]         }
[16:05:01.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.358]             base::sink(type = "output", split = FALSE)
[16:05:01.358]             base::close(...future.stdout)
[16:05:01.358]         }, add = TRUE)
[16:05:01.358]     }
[16:05:01.358]     ...future.frame <- base::sys.nframe()
[16:05:01.358]     ...future.conditions <- base::list()
[16:05:01.358]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.358]     if (FALSE) {
[16:05:01.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.358]     }
[16:05:01.358]     ...future.result <- base::tryCatch({
[16:05:01.358]         base::withCallingHandlers({
[16:05:01.358]             ...future.value <- base::withVisible(base::local({
[16:05:01.358]                 x[["a"]] <- 1
[16:05:01.358]                 x
[16:05:01.358]             }))
[16:05:01.358]             future::FutureResult(value = ...future.value$value, 
[16:05:01.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.358]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.358]                     ...future.globalenv.names))
[16:05:01.358]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.358]         }, condition = base::local({
[16:05:01.358]             c <- base::c
[16:05:01.358]             inherits <- base::inherits
[16:05:01.358]             invokeRestart <- base::invokeRestart
[16:05:01.358]             length <- base::length
[16:05:01.358]             list <- base::list
[16:05:01.358]             seq.int <- base::seq.int
[16:05:01.358]             signalCondition <- base::signalCondition
[16:05:01.358]             sys.calls <- base::sys.calls
[16:05:01.358]             `[[` <- base::`[[`
[16:05:01.358]             `+` <- base::`+`
[16:05:01.358]             `<<-` <- base::`<<-`
[16:05:01.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.358]                   3L)]
[16:05:01.358]             }
[16:05:01.358]             function(cond) {
[16:05:01.358]                 is_error <- inherits(cond, "error")
[16:05:01.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.358]                   NULL)
[16:05:01.358]                 if (is_error) {
[16:05:01.358]                   sessionInformation <- function() {
[16:05:01.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.358]                       search = base::search(), system = base::Sys.info())
[16:05:01.358]                   }
[16:05:01.358]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.358]                     cond$call), session = sessionInformation(), 
[16:05:01.358]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.358]                   signalCondition(cond)
[16:05:01.358]                 }
[16:05:01.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.358]                 "immediateCondition"))) {
[16:05:01.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.358]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.358]                   if (TRUE && !signal) {
[16:05:01.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.358]                     {
[16:05:01.358]                       inherits <- base::inherits
[16:05:01.358]                       invokeRestart <- base::invokeRestart
[16:05:01.358]                       is.null <- base::is.null
[16:05:01.358]                       muffled <- FALSE
[16:05:01.358]                       if (inherits(cond, "message")) {
[16:05:01.358]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.358]                         if (muffled) 
[16:05:01.358]                           invokeRestart("muffleMessage")
[16:05:01.358]                       }
[16:05:01.358]                       else if (inherits(cond, "warning")) {
[16:05:01.358]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.358]                         if (muffled) 
[16:05:01.358]                           invokeRestart("muffleWarning")
[16:05:01.358]                       }
[16:05:01.358]                       else if (inherits(cond, "condition")) {
[16:05:01.358]                         if (!is.null(pattern)) {
[16:05:01.358]                           computeRestarts <- base::computeRestarts
[16:05:01.358]                           grepl <- base::grepl
[16:05:01.358]                           restarts <- computeRestarts(cond)
[16:05:01.358]                           for (restart in restarts) {
[16:05:01.358]                             name <- restart$name
[16:05:01.358]                             if (is.null(name)) 
[16:05:01.358]                               next
[16:05:01.358]                             if (!grepl(pattern, name)) 
[16:05:01.358]                               next
[16:05:01.358]                             invokeRestart(restart)
[16:05:01.358]                             muffled <- TRUE
[16:05:01.358]                             break
[16:05:01.358]                           }
[16:05:01.358]                         }
[16:05:01.358]                       }
[16:05:01.358]                       invisible(muffled)
[16:05:01.358]                     }
[16:05:01.358]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.358]                   }
[16:05:01.358]                 }
[16:05:01.358]                 else {
[16:05:01.358]                   if (TRUE) {
[16:05:01.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.358]                     {
[16:05:01.358]                       inherits <- base::inherits
[16:05:01.358]                       invokeRestart <- base::invokeRestart
[16:05:01.358]                       is.null <- base::is.null
[16:05:01.358]                       muffled <- FALSE
[16:05:01.358]                       if (inherits(cond, "message")) {
[16:05:01.358]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.358]                         if (muffled) 
[16:05:01.358]                           invokeRestart("muffleMessage")
[16:05:01.358]                       }
[16:05:01.358]                       else if (inherits(cond, "warning")) {
[16:05:01.358]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.358]                         if (muffled) 
[16:05:01.358]                           invokeRestart("muffleWarning")
[16:05:01.358]                       }
[16:05:01.358]                       else if (inherits(cond, "condition")) {
[16:05:01.358]                         if (!is.null(pattern)) {
[16:05:01.358]                           computeRestarts <- base::computeRestarts
[16:05:01.358]                           grepl <- base::grepl
[16:05:01.358]                           restarts <- computeRestarts(cond)
[16:05:01.358]                           for (restart in restarts) {
[16:05:01.358]                             name <- restart$name
[16:05:01.358]                             if (is.null(name)) 
[16:05:01.358]                               next
[16:05:01.358]                             if (!grepl(pattern, name)) 
[16:05:01.358]                               next
[16:05:01.358]                             invokeRestart(restart)
[16:05:01.358]                             muffled <- TRUE
[16:05:01.358]                             break
[16:05:01.358]                           }
[16:05:01.358]                         }
[16:05:01.358]                       }
[16:05:01.358]                       invisible(muffled)
[16:05:01.358]                     }
[16:05:01.358]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.358]                   }
[16:05:01.358]                 }
[16:05:01.358]             }
[16:05:01.358]         }))
[16:05:01.358]     }, error = function(ex) {
[16:05:01.358]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.358]                 ...future.rng), started = ...future.startTime, 
[16:05:01.358]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.358]             version = "1.8"), class = "FutureResult")
[16:05:01.358]     }, finally = {
[16:05:01.358]         if (!identical(...future.workdir, getwd())) 
[16:05:01.358]             setwd(...future.workdir)
[16:05:01.358]         {
[16:05:01.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.358]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.358]             }
[16:05:01.358]             base::options(...future.oldOptions)
[16:05:01.358]             if (.Platform$OS.type == "windows") {
[16:05:01.358]                 old_names <- names(...future.oldEnvVars)
[16:05:01.358]                 envs <- base::Sys.getenv()
[16:05:01.358]                 names <- names(envs)
[16:05:01.358]                 common <- intersect(names, old_names)
[16:05:01.358]                 added <- setdiff(names, old_names)
[16:05:01.358]                 removed <- setdiff(old_names, names)
[16:05:01.358]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.358]                   envs[common]]
[16:05:01.358]                 NAMES <- toupper(changed)
[16:05:01.358]                 args <- list()
[16:05:01.358]                 for (kk in seq_along(NAMES)) {
[16:05:01.358]                   name <- changed[[kk]]
[16:05:01.358]                   NAME <- NAMES[[kk]]
[16:05:01.358]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.358]                     next
[16:05:01.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.358]                 }
[16:05:01.358]                 NAMES <- toupper(added)
[16:05:01.358]                 for (kk in seq_along(NAMES)) {
[16:05:01.358]                   name <- added[[kk]]
[16:05:01.358]                   NAME <- NAMES[[kk]]
[16:05:01.358]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.358]                     next
[16:05:01.358]                   args[[name]] <- ""
[16:05:01.358]                 }
[16:05:01.358]                 NAMES <- toupper(removed)
[16:05:01.358]                 for (kk in seq_along(NAMES)) {
[16:05:01.358]                   name <- removed[[kk]]
[16:05:01.358]                   NAME <- NAMES[[kk]]
[16:05:01.358]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.358]                     next
[16:05:01.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.358]                 }
[16:05:01.358]                 if (length(args) > 0) 
[16:05:01.358]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.358]             }
[16:05:01.358]             else {
[16:05:01.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.358]             }
[16:05:01.358]             {
[16:05:01.358]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.358]                   0L) {
[16:05:01.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.358]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.358]                   base::options(opts)
[16:05:01.358]                 }
[16:05:01.358]                 {
[16:05:01.358]                   {
[16:05:01.358]                     NULL
[16:05:01.358]                     RNGkind("Mersenne-Twister")
[16:05:01.358]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:01.358]                       inherits = FALSE)
[16:05:01.358]                   }
[16:05:01.358]                   options(future.plan = NULL)
[16:05:01.358]                   if (is.na(NA_character_)) 
[16:05:01.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.358]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:01.358]                   {
[16:05:01.358]                     future <- SequentialFuture(..., envir = envir)
[16:05:01.358]                     if (!future$lazy) 
[16:05:01.358]                       future <- run(future)
[16:05:01.358]                     invisible(future)
[16:05:01.358]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.358]                 }
[16:05:01.358]             }
[16:05:01.358]         }
[16:05:01.358]     })
[16:05:01.358]     if (TRUE) {
[16:05:01.358]         base::sink(type = "output", split = FALSE)
[16:05:01.358]         if (TRUE) {
[16:05:01.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.358]         }
[16:05:01.358]         else {
[16:05:01.358]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.358]         }
[16:05:01.358]         base::close(...future.stdout)
[16:05:01.358]         ...future.stdout <- NULL
[16:05:01.358]     }
[16:05:01.358]     ...future.result$conditions <- ...future.conditions
[16:05:01.358]     ...future.result$finished <- base::Sys.time()
[16:05:01.358]     ...future.result
[16:05:01.358] }
[16:05:01.360] assign_globals() ...
[16:05:01.360] List of 1
[16:05:01.360]  $ x: list()
[16:05:01.360]  - attr(*, "where")=List of 1
[16:05:01.360]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.360]  - attr(*, "resolved")= logi TRUE
[16:05:01.360]  - attr(*, "total_size")= num 0
[16:05:01.360]  - attr(*, "already-done")= logi TRUE
[16:05:01.362] - copied ‘x’ to environment
[16:05:01.364] assign_globals() ... done
[16:05:01.364] plan(): Setting new future strategy stack:
[16:05:01.364] List of future strategies:
[16:05:01.364] 1. sequential:
[16:05:01.364]    - args: function (..., envir = parent.frame())
[16:05:01.364]    - tweaked: FALSE
[16:05:01.364]    - call: NULL
[16:05:01.365] plan(): nbrOfWorkers() = 1
[16:05:01.366] plan(): Setting new future strategy stack:
[16:05:01.366] List of future strategies:
[16:05:01.366] 1. sequential:
[16:05:01.366]    - args: function (..., envir = parent.frame())
[16:05:01.366]    - tweaked: FALSE
[16:05:01.366]    - call: plan(strategy)
[16:05:01.366] plan(): nbrOfWorkers() = 1
[16:05:01.366] SequentialFuture started (and completed)
[16:05:01.366] - Launch lazy future ... done
[16:05:01.366] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.367] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.367] Searching for globals...
[16:05:01.369] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:01.369] Searching for globals ... DONE
[16:05:01.369] Resolving globals: TRUE
[16:05:01.369] Resolving any globals that are futures ...
[16:05:01.369] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:01.370] Resolving any globals that are futures ... DONE
[16:05:01.370] Resolving futures part of globals (recursively) ...
[16:05:01.370] resolve() on list ...
[16:05:01.370]  recursive: 99
[16:05:01.370]  length: 1
[16:05:01.370]  elements: ‘x’
[16:05:01.371]  length: 0 (resolved future 1)
[16:05:01.371] resolve() on list ... DONE
[16:05:01.371] - globals: [1] ‘x’
[16:05:01.371] Resolving futures part of globals (recursively) ... DONE
[16:05:01.371] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.371] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.371] - globals: [1] ‘x’
[16:05:01.372] 
[16:05:01.372] getGlobalsAndPackages() ... DONE
[16:05:01.372] run() for ‘Future’ ...
[16:05:01.372] - state: ‘created’
[16:05:01.372] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:01.372] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:01.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:01.373]   - Field: ‘label’
[16:05:01.373]   - Field: ‘local’
[16:05:01.373]   - Field: ‘owner’
[16:05:01.373]   - Field: ‘envir’
[16:05:01.373]   - Field: ‘packages’
[16:05:01.373]   - Field: ‘gc’
[16:05:01.373]   - Field: ‘conditions’
[16:05:01.373]   - Field: ‘expr’
[16:05:01.373]   - Field: ‘uuid’
[16:05:01.373]   - Field: ‘seed’
[16:05:01.374]   - Field: ‘version’
[16:05:01.374]   - Field: ‘result’
[16:05:01.374]   - Field: ‘asynchronous’
[16:05:01.374]   - Field: ‘calls’
[16:05:01.374]   - Field: ‘globals’
[16:05:01.374]   - Field: ‘stdout’
[16:05:01.374]   - Field: ‘earlySignal’
[16:05:01.374]   - Field: ‘lazy’
[16:05:01.374]   - Field: ‘state’
[16:05:01.374] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:01.374] - Launch lazy future ...
[16:05:01.375] Packages needed by the future expression (n = 0): <none>
[16:05:01.375] Packages needed by future strategies (n = 0): <none>
[16:05:01.375] {
[16:05:01.375]     {
[16:05:01.375]         {
[16:05:01.375]             ...future.startTime <- base::Sys.time()
[16:05:01.375]             {
[16:05:01.375]                 {
[16:05:01.375]                   {
[16:05:01.375]                     base::local({
[16:05:01.375]                       has_future <- base::requireNamespace("future", 
[16:05:01.375]                         quietly = TRUE)
[16:05:01.375]                       if (has_future) {
[16:05:01.375]                         ns <- base::getNamespace("future")
[16:05:01.375]                         version <- ns[[".package"]][["version"]]
[16:05:01.375]                         if (is.null(version)) 
[16:05:01.375]                           version <- utils::packageVersion("future")
[16:05:01.375]                       }
[16:05:01.375]                       else {
[16:05:01.375]                         version <- NULL
[16:05:01.375]                       }
[16:05:01.375]                       if (!has_future || version < "1.8.0") {
[16:05:01.375]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.375]                           "", base::R.version$version.string), 
[16:05:01.375]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:01.375]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.375]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.375]                             "release", "version")], collapse = " "), 
[16:05:01.375]                           hostname = base::Sys.info()[["nodename"]])
[16:05:01.375]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.375]                           info)
[16:05:01.375]                         info <- base::paste(info, collapse = "; ")
[16:05:01.375]                         if (!has_future) {
[16:05:01.375]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.375]                             info)
[16:05:01.375]                         }
[16:05:01.375]                         else {
[16:05:01.375]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.375]                             info, version)
[16:05:01.375]                         }
[16:05:01.375]                         base::stop(msg)
[16:05:01.375]                       }
[16:05:01.375]                     })
[16:05:01.375]                   }
[16:05:01.375]                   options(future.plan = NULL)
[16:05:01.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.375]                 }
[16:05:01.375]                 ...future.workdir <- getwd()
[16:05:01.375]             }
[16:05:01.375]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.375]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.375]         }
[16:05:01.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.375]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.375]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.375]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.375]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.375]             base::names(...future.oldOptions))
[16:05:01.375]     }
[16:05:01.375]     if (FALSE) {
[16:05:01.375]     }
[16:05:01.375]     else {
[16:05:01.375]         if (TRUE) {
[16:05:01.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.375]                 open = "w")
[16:05:01.375]         }
[16:05:01.375]         else {
[16:05:01.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.375]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.375]         }
[16:05:01.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.375]             base::sink(type = "output", split = FALSE)
[16:05:01.375]             base::close(...future.stdout)
[16:05:01.375]         }, add = TRUE)
[16:05:01.375]     }
[16:05:01.375]     ...future.frame <- base::sys.nframe()
[16:05:01.375]     ...future.conditions <- base::list()
[16:05:01.375]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.375]     if (FALSE) {
[16:05:01.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.375]     }
[16:05:01.375]     ...future.result <- base::tryCatch({
[16:05:01.375]         base::withCallingHandlers({
[16:05:01.375]             ...future.value <- base::withVisible(base::local({
[16:05:01.375]                 x["a"] <- list(1)
[16:05:01.375]                 x
[16:05:01.375]             }))
[16:05:01.375]             future::FutureResult(value = ...future.value$value, 
[16:05:01.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.375]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.375]                     ...future.globalenv.names))
[16:05:01.375]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.375]         }, condition = base::local({
[16:05:01.375]             c <- base::c
[16:05:01.375]             inherits <- base::inherits
[16:05:01.375]             invokeRestart <- base::invokeRestart
[16:05:01.375]             length <- base::length
[16:05:01.375]             list <- base::list
[16:05:01.375]             seq.int <- base::seq.int
[16:05:01.375]             signalCondition <- base::signalCondition
[16:05:01.375]             sys.calls <- base::sys.calls
[16:05:01.375]             `[[` <- base::`[[`
[16:05:01.375]             `+` <- base::`+`
[16:05:01.375]             `<<-` <- base::`<<-`
[16:05:01.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.375]                   3L)]
[16:05:01.375]             }
[16:05:01.375]             function(cond) {
[16:05:01.375]                 is_error <- inherits(cond, "error")
[16:05:01.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.375]                   NULL)
[16:05:01.375]                 if (is_error) {
[16:05:01.375]                   sessionInformation <- function() {
[16:05:01.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.375]                       search = base::search(), system = base::Sys.info())
[16:05:01.375]                   }
[16:05:01.375]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.375]                     cond$call), session = sessionInformation(), 
[16:05:01.375]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.375]                   signalCondition(cond)
[16:05:01.375]                 }
[16:05:01.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.375]                 "immediateCondition"))) {
[16:05:01.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.375]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.375]                   if (TRUE && !signal) {
[16:05:01.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.375]                     {
[16:05:01.375]                       inherits <- base::inherits
[16:05:01.375]                       invokeRestart <- base::invokeRestart
[16:05:01.375]                       is.null <- base::is.null
[16:05:01.375]                       muffled <- FALSE
[16:05:01.375]                       if (inherits(cond, "message")) {
[16:05:01.375]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.375]                         if (muffled) 
[16:05:01.375]                           invokeRestart("muffleMessage")
[16:05:01.375]                       }
[16:05:01.375]                       else if (inherits(cond, "warning")) {
[16:05:01.375]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.375]                         if (muffled) 
[16:05:01.375]                           invokeRestart("muffleWarning")
[16:05:01.375]                       }
[16:05:01.375]                       else if (inherits(cond, "condition")) {
[16:05:01.375]                         if (!is.null(pattern)) {
[16:05:01.375]                           computeRestarts <- base::computeRestarts
[16:05:01.375]                           grepl <- base::grepl
[16:05:01.375]                           restarts <- computeRestarts(cond)
[16:05:01.375]                           for (restart in restarts) {
[16:05:01.375]                             name <- restart$name
[16:05:01.375]                             if (is.null(name)) 
[16:05:01.375]                               next
[16:05:01.375]                             if (!grepl(pattern, name)) 
[16:05:01.375]                               next
[16:05:01.375]                             invokeRestart(restart)
[16:05:01.375]                             muffled <- TRUE
[16:05:01.375]                             break
[16:05:01.375]                           }
[16:05:01.375]                         }
[16:05:01.375]                       }
[16:05:01.375]                       invisible(muffled)
[16:05:01.375]                     }
[16:05:01.375]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.375]                   }
[16:05:01.375]                 }
[16:05:01.375]                 else {
[16:05:01.375]                   if (TRUE) {
[16:05:01.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.375]                     {
[16:05:01.375]                       inherits <- base::inherits
[16:05:01.375]                       invokeRestart <- base::invokeRestart
[16:05:01.375]                       is.null <- base::is.null
[16:05:01.375]                       muffled <- FALSE
[16:05:01.375]                       if (inherits(cond, "message")) {
[16:05:01.375]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.375]                         if (muffled) 
[16:05:01.375]                           invokeRestart("muffleMessage")
[16:05:01.375]                       }
[16:05:01.375]                       else if (inherits(cond, "warning")) {
[16:05:01.375]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.375]                         if (muffled) 
[16:05:01.375]                           invokeRestart("muffleWarning")
[16:05:01.375]                       }
[16:05:01.375]                       else if (inherits(cond, "condition")) {
[16:05:01.375]                         if (!is.null(pattern)) {
[16:05:01.375]                           computeRestarts <- base::computeRestarts
[16:05:01.375]                           grepl <- base::grepl
[16:05:01.375]                           restarts <- computeRestarts(cond)
[16:05:01.375]                           for (restart in restarts) {
[16:05:01.375]                             name <- restart$name
[16:05:01.375]                             if (is.null(name)) 
[16:05:01.375]                               next
[16:05:01.375]                             if (!grepl(pattern, name)) 
[16:05:01.375]                               next
[16:05:01.375]                             invokeRestart(restart)
[16:05:01.375]                             muffled <- TRUE
[16:05:01.375]                             break
[16:05:01.375]                           }
[16:05:01.375]                         }
[16:05:01.375]                       }
[16:05:01.375]                       invisible(muffled)
[16:05:01.375]                     }
[16:05:01.375]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.375]                   }
[16:05:01.375]                 }
[16:05:01.375]             }
[16:05:01.375]         }))
[16:05:01.375]     }, error = function(ex) {
[16:05:01.375]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.375]                 ...future.rng), started = ...future.startTime, 
[16:05:01.375]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.375]             version = "1.8"), class = "FutureResult")
[16:05:01.375]     }, finally = {
[16:05:01.375]         if (!identical(...future.workdir, getwd())) 
[16:05:01.375]             setwd(...future.workdir)
[16:05:01.375]         {
[16:05:01.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.375]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.375]             }
[16:05:01.375]             base::options(...future.oldOptions)
[16:05:01.375]             if (.Platform$OS.type == "windows") {
[16:05:01.375]                 old_names <- names(...future.oldEnvVars)
[16:05:01.375]                 envs <- base::Sys.getenv()
[16:05:01.375]                 names <- names(envs)
[16:05:01.375]                 common <- intersect(names, old_names)
[16:05:01.375]                 added <- setdiff(names, old_names)
[16:05:01.375]                 removed <- setdiff(old_names, names)
[16:05:01.375]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.375]                   envs[common]]
[16:05:01.375]                 NAMES <- toupper(changed)
[16:05:01.375]                 args <- list()
[16:05:01.375]                 for (kk in seq_along(NAMES)) {
[16:05:01.375]                   name <- changed[[kk]]
[16:05:01.375]                   NAME <- NAMES[[kk]]
[16:05:01.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.375]                     next
[16:05:01.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.375]                 }
[16:05:01.375]                 NAMES <- toupper(added)
[16:05:01.375]                 for (kk in seq_along(NAMES)) {
[16:05:01.375]                   name <- added[[kk]]
[16:05:01.375]                   NAME <- NAMES[[kk]]
[16:05:01.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.375]                     next
[16:05:01.375]                   args[[name]] <- ""
[16:05:01.375]                 }
[16:05:01.375]                 NAMES <- toupper(removed)
[16:05:01.375]                 for (kk in seq_along(NAMES)) {
[16:05:01.375]                   name <- removed[[kk]]
[16:05:01.375]                   NAME <- NAMES[[kk]]
[16:05:01.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.375]                     next
[16:05:01.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.375]                 }
[16:05:01.375]                 if (length(args) > 0) 
[16:05:01.375]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.375]             }
[16:05:01.375]             else {
[16:05:01.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.375]             }
[16:05:01.375]             {
[16:05:01.375]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.375]                   0L) {
[16:05:01.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.375]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.375]                   base::options(opts)
[16:05:01.375]                 }
[16:05:01.375]                 {
[16:05:01.375]                   {
[16:05:01.375]                     NULL
[16:05:01.375]                     RNGkind("Mersenne-Twister")
[16:05:01.375]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:01.375]                       inherits = FALSE)
[16:05:01.375]                   }
[16:05:01.375]                   options(future.plan = NULL)
[16:05:01.375]                   if (is.na(NA_character_)) 
[16:05:01.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.375]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:01.375]                   {
[16:05:01.375]                     future <- SequentialFuture(..., envir = envir)
[16:05:01.375]                     if (!future$lazy) 
[16:05:01.375]                       future <- run(future)
[16:05:01.375]                     invisible(future)
[16:05:01.375]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.375]                 }
[16:05:01.375]             }
[16:05:01.375]         }
[16:05:01.375]     })
[16:05:01.375]     if (TRUE) {
[16:05:01.375]         base::sink(type = "output", split = FALSE)
[16:05:01.375]         if (TRUE) {
[16:05:01.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.375]         }
[16:05:01.375]         else {
[16:05:01.375]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.375]         }
[16:05:01.375]         base::close(...future.stdout)
[16:05:01.375]         ...future.stdout <- NULL
[16:05:01.375]     }
[16:05:01.375]     ...future.result$conditions <- ...future.conditions
[16:05:01.375]     ...future.result$finished <- base::Sys.time()
[16:05:01.375]     ...future.result
[16:05:01.375] }
[16:05:01.377] assign_globals() ...
[16:05:01.377] List of 1
[16:05:01.377]  $ x: list()
[16:05:01.377]  - attr(*, "where")=List of 1
[16:05:01.377]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.377]  - attr(*, "resolved")= logi TRUE
[16:05:01.377]  - attr(*, "total_size")= num 0
[16:05:01.377]  - attr(*, "already-done")= logi TRUE
[16:05:01.379] - copied ‘x’ to environment
[16:05:01.379] assign_globals() ... done
[16:05:01.380] plan(): Setting new future strategy stack:
[16:05:01.380] List of future strategies:
[16:05:01.380] 1. sequential:
[16:05:01.380]    - args: function (..., envir = parent.frame())
[16:05:01.380]    - tweaked: FALSE
[16:05:01.380]    - call: NULL
[16:05:01.380] plan(): nbrOfWorkers() = 1
[16:05:01.381] plan(): Setting new future strategy stack:
[16:05:01.381] List of future strategies:
[16:05:01.381] 1. sequential:
[16:05:01.381]    - args: function (..., envir = parent.frame())
[16:05:01.381]    - tweaked: FALSE
[16:05:01.381]    - call: plan(strategy)
[16:05:01.381] plan(): nbrOfWorkers() = 1
[16:05:01.381] SequentialFuture started (and completed)
[16:05:01.382] - Launch lazy future ... done
[16:05:01.382] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.382] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.382] Searching for globals...
[16:05:01.384] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:01.384] Searching for globals ... DONE
[16:05:01.384] Resolving globals: TRUE
[16:05:01.385] Resolving any globals that are futures ...
[16:05:01.385] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:01.385] Resolving any globals that are futures ... DONE
[16:05:01.385] Resolving futures part of globals (recursively) ...
[16:05:01.385] resolve() on list ...
[16:05:01.385]  recursive: 99
[16:05:01.386]  length: 1
[16:05:01.386]  elements: ‘x’
[16:05:01.386]  length: 0 (resolved future 1)
[16:05:01.386] resolve() on list ... DONE
[16:05:01.386] - globals: [1] ‘x’
[16:05:01.386] Resolving futures part of globals (recursively) ... DONE
[16:05:01.386] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.386] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.387] - globals: [1] ‘x’
[16:05:01.387] 
[16:05:01.387] getGlobalsAndPackages() ... DONE
[16:05:01.387] run() for ‘Future’ ...
[16:05:01.387] - state: ‘created’
[16:05:01.387] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:01.388] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:01.388] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:01.388]   - Field: ‘label’
[16:05:01.388]   - Field: ‘local’
[16:05:01.388]   - Field: ‘owner’
[16:05:01.388]   - Field: ‘envir’
[16:05:01.388]   - Field: ‘packages’
[16:05:01.388]   - Field: ‘gc’
[16:05:01.388]   - Field: ‘conditions’
[16:05:01.388]   - Field: ‘expr’
[16:05:01.389]   - Field: ‘uuid’
[16:05:01.389]   - Field: ‘seed’
[16:05:01.389]   - Field: ‘version’
[16:05:01.389]   - Field: ‘result’
[16:05:01.389]   - Field: ‘asynchronous’
[16:05:01.391]   - Field: ‘calls’
[16:05:01.391]   - Field: ‘globals’
[16:05:01.391]   - Field: ‘stdout’
[16:05:01.391]   - Field: ‘earlySignal’
[16:05:01.391]   - Field: ‘lazy’
[16:05:01.391]   - Field: ‘state’
[16:05:01.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:01.391] - Launch lazy future ...
[16:05:01.392] Packages needed by the future expression (n = 0): <none>
[16:05:01.392] Packages needed by future strategies (n = 0): <none>
[16:05:01.392] {
[16:05:01.392]     {
[16:05:01.392]         {
[16:05:01.392]             ...future.startTime <- base::Sys.time()
[16:05:01.392]             {
[16:05:01.392]                 {
[16:05:01.392]                   {
[16:05:01.392]                     base::local({
[16:05:01.392]                       has_future <- base::requireNamespace("future", 
[16:05:01.392]                         quietly = TRUE)
[16:05:01.392]                       if (has_future) {
[16:05:01.392]                         ns <- base::getNamespace("future")
[16:05:01.392]                         version <- ns[[".package"]][["version"]]
[16:05:01.392]                         if (is.null(version)) 
[16:05:01.392]                           version <- utils::packageVersion("future")
[16:05:01.392]                       }
[16:05:01.392]                       else {
[16:05:01.392]                         version <- NULL
[16:05:01.392]                       }
[16:05:01.392]                       if (!has_future || version < "1.8.0") {
[16:05:01.392]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.392]                           "", base::R.version$version.string), 
[16:05:01.392]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:01.392]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.392]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.392]                             "release", "version")], collapse = " "), 
[16:05:01.392]                           hostname = base::Sys.info()[["nodename"]])
[16:05:01.392]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.392]                           info)
[16:05:01.392]                         info <- base::paste(info, collapse = "; ")
[16:05:01.392]                         if (!has_future) {
[16:05:01.392]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.392]                             info)
[16:05:01.392]                         }
[16:05:01.392]                         else {
[16:05:01.392]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.392]                             info, version)
[16:05:01.392]                         }
[16:05:01.392]                         base::stop(msg)
[16:05:01.392]                       }
[16:05:01.392]                     })
[16:05:01.392]                   }
[16:05:01.392]                   options(future.plan = NULL)
[16:05:01.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.392]                 }
[16:05:01.392]                 ...future.workdir <- getwd()
[16:05:01.392]             }
[16:05:01.392]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.392]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.392]         }
[16:05:01.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.392]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.392]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.392]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.392]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.392]             base::names(...future.oldOptions))
[16:05:01.392]     }
[16:05:01.392]     if (FALSE) {
[16:05:01.392]     }
[16:05:01.392]     else {
[16:05:01.392]         if (TRUE) {
[16:05:01.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.392]                 open = "w")
[16:05:01.392]         }
[16:05:01.392]         else {
[16:05:01.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.392]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.392]         }
[16:05:01.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.392]             base::sink(type = "output", split = FALSE)
[16:05:01.392]             base::close(...future.stdout)
[16:05:01.392]         }, add = TRUE)
[16:05:01.392]     }
[16:05:01.392]     ...future.frame <- base::sys.nframe()
[16:05:01.392]     ...future.conditions <- base::list()
[16:05:01.392]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.392]     if (FALSE) {
[16:05:01.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.392]     }
[16:05:01.392]     ...future.result <- base::tryCatch({
[16:05:01.392]         base::withCallingHandlers({
[16:05:01.392]             ...future.value <- base::withVisible(base::local({
[16:05:01.392]                 x["a"] <- list(1)
[16:05:01.392]                 x
[16:05:01.392]             }))
[16:05:01.392]             future::FutureResult(value = ...future.value$value, 
[16:05:01.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.392]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.392]                     ...future.globalenv.names))
[16:05:01.392]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.392]         }, condition = base::local({
[16:05:01.392]             c <- base::c
[16:05:01.392]             inherits <- base::inherits
[16:05:01.392]             invokeRestart <- base::invokeRestart
[16:05:01.392]             length <- base::length
[16:05:01.392]             list <- base::list
[16:05:01.392]             seq.int <- base::seq.int
[16:05:01.392]             signalCondition <- base::signalCondition
[16:05:01.392]             sys.calls <- base::sys.calls
[16:05:01.392]             `[[` <- base::`[[`
[16:05:01.392]             `+` <- base::`+`
[16:05:01.392]             `<<-` <- base::`<<-`
[16:05:01.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.392]                   3L)]
[16:05:01.392]             }
[16:05:01.392]             function(cond) {
[16:05:01.392]                 is_error <- inherits(cond, "error")
[16:05:01.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.392]                   NULL)
[16:05:01.392]                 if (is_error) {
[16:05:01.392]                   sessionInformation <- function() {
[16:05:01.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.392]                       search = base::search(), system = base::Sys.info())
[16:05:01.392]                   }
[16:05:01.392]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.392]                     cond$call), session = sessionInformation(), 
[16:05:01.392]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.392]                   signalCondition(cond)
[16:05:01.392]                 }
[16:05:01.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.392]                 "immediateCondition"))) {
[16:05:01.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.392]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.392]                   if (TRUE && !signal) {
[16:05:01.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.392]                     {
[16:05:01.392]                       inherits <- base::inherits
[16:05:01.392]                       invokeRestart <- base::invokeRestart
[16:05:01.392]                       is.null <- base::is.null
[16:05:01.392]                       muffled <- FALSE
[16:05:01.392]                       if (inherits(cond, "message")) {
[16:05:01.392]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.392]                         if (muffled) 
[16:05:01.392]                           invokeRestart("muffleMessage")
[16:05:01.392]                       }
[16:05:01.392]                       else if (inherits(cond, "warning")) {
[16:05:01.392]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.392]                         if (muffled) 
[16:05:01.392]                           invokeRestart("muffleWarning")
[16:05:01.392]                       }
[16:05:01.392]                       else if (inherits(cond, "condition")) {
[16:05:01.392]                         if (!is.null(pattern)) {
[16:05:01.392]                           computeRestarts <- base::computeRestarts
[16:05:01.392]                           grepl <- base::grepl
[16:05:01.392]                           restarts <- computeRestarts(cond)
[16:05:01.392]                           for (restart in restarts) {
[16:05:01.392]                             name <- restart$name
[16:05:01.392]                             if (is.null(name)) 
[16:05:01.392]                               next
[16:05:01.392]                             if (!grepl(pattern, name)) 
[16:05:01.392]                               next
[16:05:01.392]                             invokeRestart(restart)
[16:05:01.392]                             muffled <- TRUE
[16:05:01.392]                             break
[16:05:01.392]                           }
[16:05:01.392]                         }
[16:05:01.392]                       }
[16:05:01.392]                       invisible(muffled)
[16:05:01.392]                     }
[16:05:01.392]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.392]                   }
[16:05:01.392]                 }
[16:05:01.392]                 else {
[16:05:01.392]                   if (TRUE) {
[16:05:01.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.392]                     {
[16:05:01.392]                       inherits <- base::inherits
[16:05:01.392]                       invokeRestart <- base::invokeRestart
[16:05:01.392]                       is.null <- base::is.null
[16:05:01.392]                       muffled <- FALSE
[16:05:01.392]                       if (inherits(cond, "message")) {
[16:05:01.392]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.392]                         if (muffled) 
[16:05:01.392]                           invokeRestart("muffleMessage")
[16:05:01.392]                       }
[16:05:01.392]                       else if (inherits(cond, "warning")) {
[16:05:01.392]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.392]                         if (muffled) 
[16:05:01.392]                           invokeRestart("muffleWarning")
[16:05:01.392]                       }
[16:05:01.392]                       else if (inherits(cond, "condition")) {
[16:05:01.392]                         if (!is.null(pattern)) {
[16:05:01.392]                           computeRestarts <- base::computeRestarts
[16:05:01.392]                           grepl <- base::grepl
[16:05:01.392]                           restarts <- computeRestarts(cond)
[16:05:01.392]                           for (restart in restarts) {
[16:05:01.392]                             name <- restart$name
[16:05:01.392]                             if (is.null(name)) 
[16:05:01.392]                               next
[16:05:01.392]                             if (!grepl(pattern, name)) 
[16:05:01.392]                               next
[16:05:01.392]                             invokeRestart(restart)
[16:05:01.392]                             muffled <- TRUE
[16:05:01.392]                             break
[16:05:01.392]                           }
[16:05:01.392]                         }
[16:05:01.392]                       }
[16:05:01.392]                       invisible(muffled)
[16:05:01.392]                     }
[16:05:01.392]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.392]                   }
[16:05:01.392]                 }
[16:05:01.392]             }
[16:05:01.392]         }))
[16:05:01.392]     }, error = function(ex) {
[16:05:01.392]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.392]                 ...future.rng), started = ...future.startTime, 
[16:05:01.392]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.392]             version = "1.8"), class = "FutureResult")
[16:05:01.392]     }, finally = {
[16:05:01.392]         if (!identical(...future.workdir, getwd())) 
[16:05:01.392]             setwd(...future.workdir)
[16:05:01.392]         {
[16:05:01.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.392]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.392]             }
[16:05:01.392]             base::options(...future.oldOptions)
[16:05:01.392]             if (.Platform$OS.type == "windows") {
[16:05:01.392]                 old_names <- names(...future.oldEnvVars)
[16:05:01.392]                 envs <- base::Sys.getenv()
[16:05:01.392]                 names <- names(envs)
[16:05:01.392]                 common <- intersect(names, old_names)
[16:05:01.392]                 added <- setdiff(names, old_names)
[16:05:01.392]                 removed <- setdiff(old_names, names)
[16:05:01.392]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.392]                   envs[common]]
[16:05:01.392]                 NAMES <- toupper(changed)
[16:05:01.392]                 args <- list()
[16:05:01.392]                 for (kk in seq_along(NAMES)) {
[16:05:01.392]                   name <- changed[[kk]]
[16:05:01.392]                   NAME <- NAMES[[kk]]
[16:05:01.392]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.392]                     next
[16:05:01.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.392]                 }
[16:05:01.392]                 NAMES <- toupper(added)
[16:05:01.392]                 for (kk in seq_along(NAMES)) {
[16:05:01.392]                   name <- added[[kk]]
[16:05:01.392]                   NAME <- NAMES[[kk]]
[16:05:01.392]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.392]                     next
[16:05:01.392]                   args[[name]] <- ""
[16:05:01.392]                 }
[16:05:01.392]                 NAMES <- toupper(removed)
[16:05:01.392]                 for (kk in seq_along(NAMES)) {
[16:05:01.392]                   name <- removed[[kk]]
[16:05:01.392]                   NAME <- NAMES[[kk]]
[16:05:01.392]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.392]                     next
[16:05:01.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.392]                 }
[16:05:01.392]                 if (length(args) > 0) 
[16:05:01.392]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.392]             }
[16:05:01.392]             else {
[16:05:01.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.392]             }
[16:05:01.392]             {
[16:05:01.392]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.392]                   0L) {
[16:05:01.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.392]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.392]                   base::options(opts)
[16:05:01.392]                 }
[16:05:01.392]                 {
[16:05:01.392]                   {
[16:05:01.392]                     NULL
[16:05:01.392]                     RNGkind("Mersenne-Twister")
[16:05:01.392]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:01.392]                       inherits = FALSE)
[16:05:01.392]                   }
[16:05:01.392]                   options(future.plan = NULL)
[16:05:01.392]                   if (is.na(NA_character_)) 
[16:05:01.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.392]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:01.392]                   {
[16:05:01.392]                     future <- SequentialFuture(..., envir = envir)
[16:05:01.392]                     if (!future$lazy) 
[16:05:01.392]                       future <- run(future)
[16:05:01.392]                     invisible(future)
[16:05:01.392]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.392]                 }
[16:05:01.392]             }
[16:05:01.392]         }
[16:05:01.392]     })
[16:05:01.392]     if (TRUE) {
[16:05:01.392]         base::sink(type = "output", split = FALSE)
[16:05:01.392]         if (TRUE) {
[16:05:01.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.392]         }
[16:05:01.392]         else {
[16:05:01.392]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.392]         }
[16:05:01.392]         base::close(...future.stdout)
[16:05:01.392]         ...future.stdout <- NULL
[16:05:01.392]     }
[16:05:01.392]     ...future.result$conditions <- ...future.conditions
[16:05:01.392]     ...future.result$finished <- base::Sys.time()
[16:05:01.392]     ...future.result
[16:05:01.392] }
[16:05:01.394] assign_globals() ...
[16:05:01.394] List of 1
[16:05:01.394]  $ x: list()
[16:05:01.394]  - attr(*, "where")=List of 1
[16:05:01.394]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.394]  - attr(*, "resolved")= logi TRUE
[16:05:01.394]  - attr(*, "total_size")= num 0
[16:05:01.394]  - attr(*, "already-done")= logi TRUE
[16:05:01.396] - copied ‘x’ to environment
[16:05:01.396] assign_globals() ... done
[16:05:01.397] plan(): Setting new future strategy stack:
[16:05:01.397] List of future strategies:
[16:05:01.397] 1. sequential:
[16:05:01.397]    - args: function (..., envir = parent.frame())
[16:05:01.397]    - tweaked: FALSE
[16:05:01.397]    - call: NULL
[16:05:01.397] plan(): nbrOfWorkers() = 1
[16:05:01.398] plan(): Setting new future strategy stack:
[16:05:01.398] List of future strategies:
[16:05:01.398] 1. sequential:
[16:05:01.398]    - args: function (..., envir = parent.frame())
[16:05:01.398]    - tweaked: FALSE
[16:05:01.398]    - call: plan(strategy)
[16:05:01.398] plan(): nbrOfWorkers() = 1
[16:05:01.398] SequentialFuture started (and completed)
[16:05:01.398] - Launch lazy future ... done
[16:05:01.399] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.399] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.399] Searching for globals...
[16:05:01.401] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:01.401] Searching for globals ... DONE
[16:05:01.401] Resolving globals: TRUE
[16:05:01.402] Resolving any globals that are futures ...
[16:05:01.402] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:01.402] Resolving any globals that are futures ... DONE
[16:05:01.402] Resolving futures part of globals (recursively) ...
[16:05:01.402] resolve() on list ...
[16:05:01.402]  recursive: 99
[16:05:01.402]  length: 1
[16:05:01.403]  elements: ‘x’
[16:05:01.403]  length: 0 (resolved future 1)
[16:05:01.403] resolve() on list ... DONE
[16:05:01.403] - globals: [1] ‘x’
[16:05:01.403] Resolving futures part of globals (recursively) ... DONE
[16:05:01.403] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.404] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.404] - globals: [1] ‘x’
[16:05:01.404] 
[16:05:01.404] getGlobalsAndPackages() ... DONE
[16:05:01.404] run() for ‘Future’ ...
[16:05:01.404] - state: ‘created’
[16:05:01.404] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:01.405] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:01.405] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:01.405]   - Field: ‘label’
[16:05:01.405]   - Field: ‘local’
[16:05:01.405]   - Field: ‘owner’
[16:05:01.405]   - Field: ‘envir’
[16:05:01.405]   - Field: ‘packages’
[16:05:01.405]   - Field: ‘gc’
[16:05:01.405]   - Field: ‘conditions’
[16:05:01.405]   - Field: ‘expr’
[16:05:01.406]   - Field: ‘uuid’
[16:05:01.406]   - Field: ‘seed’
[16:05:01.406]   - Field: ‘version’
[16:05:01.406]   - Field: ‘result’
[16:05:01.406]   - Field: ‘asynchronous’
[16:05:01.406]   - Field: ‘calls’
[16:05:01.406]   - Field: ‘globals’
[16:05:01.406]   - Field: ‘stdout’
[16:05:01.406]   - Field: ‘earlySignal’
[16:05:01.406]   - Field: ‘lazy’
[16:05:01.406]   - Field: ‘state’
[16:05:01.407] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:01.407] - Launch lazy future ...
[16:05:01.407] Packages needed by the future expression (n = 0): <none>
[16:05:01.407] Packages needed by future strategies (n = 0): <none>
[16:05:01.407] {
[16:05:01.407]     {
[16:05:01.407]         {
[16:05:01.407]             ...future.startTime <- base::Sys.time()
[16:05:01.407]             {
[16:05:01.407]                 {
[16:05:01.407]                   {
[16:05:01.407]                     base::local({
[16:05:01.407]                       has_future <- base::requireNamespace("future", 
[16:05:01.407]                         quietly = TRUE)
[16:05:01.407]                       if (has_future) {
[16:05:01.407]                         ns <- base::getNamespace("future")
[16:05:01.407]                         version <- ns[[".package"]][["version"]]
[16:05:01.407]                         if (is.null(version)) 
[16:05:01.407]                           version <- utils::packageVersion("future")
[16:05:01.407]                       }
[16:05:01.407]                       else {
[16:05:01.407]                         version <- NULL
[16:05:01.407]                       }
[16:05:01.407]                       if (!has_future || version < "1.8.0") {
[16:05:01.407]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.407]                           "", base::R.version$version.string), 
[16:05:01.407]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:01.407]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.407]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.407]                             "release", "version")], collapse = " "), 
[16:05:01.407]                           hostname = base::Sys.info()[["nodename"]])
[16:05:01.407]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.407]                           info)
[16:05:01.407]                         info <- base::paste(info, collapse = "; ")
[16:05:01.407]                         if (!has_future) {
[16:05:01.407]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.407]                             info)
[16:05:01.407]                         }
[16:05:01.407]                         else {
[16:05:01.407]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.407]                             info, version)
[16:05:01.407]                         }
[16:05:01.407]                         base::stop(msg)
[16:05:01.407]                       }
[16:05:01.407]                     })
[16:05:01.407]                   }
[16:05:01.407]                   options(future.plan = NULL)
[16:05:01.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.407]                 }
[16:05:01.407]                 ...future.workdir <- getwd()
[16:05:01.407]             }
[16:05:01.407]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.407]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.407]         }
[16:05:01.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.407]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.407]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.407]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.407]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.407]             base::names(...future.oldOptions))
[16:05:01.407]     }
[16:05:01.407]     if (FALSE) {
[16:05:01.407]     }
[16:05:01.407]     else {
[16:05:01.407]         if (TRUE) {
[16:05:01.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.407]                 open = "w")
[16:05:01.407]         }
[16:05:01.407]         else {
[16:05:01.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.407]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.407]         }
[16:05:01.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.407]             base::sink(type = "output", split = FALSE)
[16:05:01.407]             base::close(...future.stdout)
[16:05:01.407]         }, add = TRUE)
[16:05:01.407]     }
[16:05:01.407]     ...future.frame <- base::sys.nframe()
[16:05:01.407]     ...future.conditions <- base::list()
[16:05:01.407]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.407]     if (FALSE) {
[16:05:01.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.407]     }
[16:05:01.407]     ...future.result <- base::tryCatch({
[16:05:01.407]         base::withCallingHandlers({
[16:05:01.407]             ...future.value <- base::withVisible(base::local({
[16:05:01.407]                 x["a"] <- list(1)
[16:05:01.407]                 x
[16:05:01.407]             }))
[16:05:01.407]             future::FutureResult(value = ...future.value$value, 
[16:05:01.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.407]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.407]                     ...future.globalenv.names))
[16:05:01.407]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.407]         }, condition = base::local({
[16:05:01.407]             c <- base::c
[16:05:01.407]             inherits <- base::inherits
[16:05:01.407]             invokeRestart <- base::invokeRestart
[16:05:01.407]             length <- base::length
[16:05:01.407]             list <- base::list
[16:05:01.407]             seq.int <- base::seq.int
[16:05:01.407]             signalCondition <- base::signalCondition
[16:05:01.407]             sys.calls <- base::sys.calls
[16:05:01.407]             `[[` <- base::`[[`
[16:05:01.407]             `+` <- base::`+`
[16:05:01.407]             `<<-` <- base::`<<-`
[16:05:01.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.407]                   3L)]
[16:05:01.407]             }
[16:05:01.407]             function(cond) {
[16:05:01.407]                 is_error <- inherits(cond, "error")
[16:05:01.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.407]                   NULL)
[16:05:01.407]                 if (is_error) {
[16:05:01.407]                   sessionInformation <- function() {
[16:05:01.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.407]                       search = base::search(), system = base::Sys.info())
[16:05:01.407]                   }
[16:05:01.407]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.407]                     cond$call), session = sessionInformation(), 
[16:05:01.407]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.407]                   signalCondition(cond)
[16:05:01.407]                 }
[16:05:01.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.407]                 "immediateCondition"))) {
[16:05:01.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.407]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.407]                   if (TRUE && !signal) {
[16:05:01.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.407]                     {
[16:05:01.407]                       inherits <- base::inherits
[16:05:01.407]                       invokeRestart <- base::invokeRestart
[16:05:01.407]                       is.null <- base::is.null
[16:05:01.407]                       muffled <- FALSE
[16:05:01.407]                       if (inherits(cond, "message")) {
[16:05:01.407]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.407]                         if (muffled) 
[16:05:01.407]                           invokeRestart("muffleMessage")
[16:05:01.407]                       }
[16:05:01.407]                       else if (inherits(cond, "warning")) {
[16:05:01.407]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.407]                         if (muffled) 
[16:05:01.407]                           invokeRestart("muffleWarning")
[16:05:01.407]                       }
[16:05:01.407]                       else if (inherits(cond, "condition")) {
[16:05:01.407]                         if (!is.null(pattern)) {
[16:05:01.407]                           computeRestarts <- base::computeRestarts
[16:05:01.407]                           grepl <- base::grepl
[16:05:01.407]                           restarts <- computeRestarts(cond)
[16:05:01.407]                           for (restart in restarts) {
[16:05:01.407]                             name <- restart$name
[16:05:01.407]                             if (is.null(name)) 
[16:05:01.407]                               next
[16:05:01.407]                             if (!grepl(pattern, name)) 
[16:05:01.407]                               next
[16:05:01.407]                             invokeRestart(restart)
[16:05:01.407]                             muffled <- TRUE
[16:05:01.407]                             break
[16:05:01.407]                           }
[16:05:01.407]                         }
[16:05:01.407]                       }
[16:05:01.407]                       invisible(muffled)
[16:05:01.407]                     }
[16:05:01.407]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.407]                   }
[16:05:01.407]                 }
[16:05:01.407]                 else {
[16:05:01.407]                   if (TRUE) {
[16:05:01.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.407]                     {
[16:05:01.407]                       inherits <- base::inherits
[16:05:01.407]                       invokeRestart <- base::invokeRestart
[16:05:01.407]                       is.null <- base::is.null
[16:05:01.407]                       muffled <- FALSE
[16:05:01.407]                       if (inherits(cond, "message")) {
[16:05:01.407]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.407]                         if (muffled) 
[16:05:01.407]                           invokeRestart("muffleMessage")
[16:05:01.407]                       }
[16:05:01.407]                       else if (inherits(cond, "warning")) {
[16:05:01.407]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.407]                         if (muffled) 
[16:05:01.407]                           invokeRestart("muffleWarning")
[16:05:01.407]                       }
[16:05:01.407]                       else if (inherits(cond, "condition")) {
[16:05:01.407]                         if (!is.null(pattern)) {
[16:05:01.407]                           computeRestarts <- base::computeRestarts
[16:05:01.407]                           grepl <- base::grepl
[16:05:01.407]                           restarts <- computeRestarts(cond)
[16:05:01.407]                           for (restart in restarts) {
[16:05:01.407]                             name <- restart$name
[16:05:01.407]                             if (is.null(name)) 
[16:05:01.407]                               next
[16:05:01.407]                             if (!grepl(pattern, name)) 
[16:05:01.407]                               next
[16:05:01.407]                             invokeRestart(restart)
[16:05:01.407]                             muffled <- TRUE
[16:05:01.407]                             break
[16:05:01.407]                           }
[16:05:01.407]                         }
[16:05:01.407]                       }
[16:05:01.407]                       invisible(muffled)
[16:05:01.407]                     }
[16:05:01.407]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.407]                   }
[16:05:01.407]                 }
[16:05:01.407]             }
[16:05:01.407]         }))
[16:05:01.407]     }, error = function(ex) {
[16:05:01.407]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.407]                 ...future.rng), started = ...future.startTime, 
[16:05:01.407]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.407]             version = "1.8"), class = "FutureResult")
[16:05:01.407]     }, finally = {
[16:05:01.407]         if (!identical(...future.workdir, getwd())) 
[16:05:01.407]             setwd(...future.workdir)
[16:05:01.407]         {
[16:05:01.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.407]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.407]             }
[16:05:01.407]             base::options(...future.oldOptions)
[16:05:01.407]             if (.Platform$OS.type == "windows") {
[16:05:01.407]                 old_names <- names(...future.oldEnvVars)
[16:05:01.407]                 envs <- base::Sys.getenv()
[16:05:01.407]                 names <- names(envs)
[16:05:01.407]                 common <- intersect(names, old_names)
[16:05:01.407]                 added <- setdiff(names, old_names)
[16:05:01.407]                 removed <- setdiff(old_names, names)
[16:05:01.407]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.407]                   envs[common]]
[16:05:01.407]                 NAMES <- toupper(changed)
[16:05:01.407]                 args <- list()
[16:05:01.407]                 for (kk in seq_along(NAMES)) {
[16:05:01.407]                   name <- changed[[kk]]
[16:05:01.407]                   NAME <- NAMES[[kk]]
[16:05:01.407]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.407]                     next
[16:05:01.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.407]                 }
[16:05:01.407]                 NAMES <- toupper(added)
[16:05:01.407]                 for (kk in seq_along(NAMES)) {
[16:05:01.407]                   name <- added[[kk]]
[16:05:01.407]                   NAME <- NAMES[[kk]]
[16:05:01.407]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.407]                     next
[16:05:01.407]                   args[[name]] <- ""
[16:05:01.407]                 }
[16:05:01.407]                 NAMES <- toupper(removed)
[16:05:01.407]                 for (kk in seq_along(NAMES)) {
[16:05:01.407]                   name <- removed[[kk]]
[16:05:01.407]                   NAME <- NAMES[[kk]]
[16:05:01.407]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.407]                     next
[16:05:01.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.407]                 }
[16:05:01.407]                 if (length(args) > 0) 
[16:05:01.407]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.407]             }
[16:05:01.407]             else {
[16:05:01.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.407]             }
[16:05:01.407]             {
[16:05:01.407]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.407]                   0L) {
[16:05:01.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.407]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.407]                   base::options(opts)
[16:05:01.407]                 }
[16:05:01.407]                 {
[16:05:01.407]                   {
[16:05:01.407]                     NULL
[16:05:01.407]                     RNGkind("Mersenne-Twister")
[16:05:01.407]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:01.407]                       inherits = FALSE)
[16:05:01.407]                   }
[16:05:01.407]                   options(future.plan = NULL)
[16:05:01.407]                   if (is.na(NA_character_)) 
[16:05:01.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.407]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:01.407]                   {
[16:05:01.407]                     future <- SequentialFuture(..., envir = envir)
[16:05:01.407]                     if (!future$lazy) 
[16:05:01.407]                       future <- run(future)
[16:05:01.407]                     invisible(future)
[16:05:01.407]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.407]                 }
[16:05:01.407]             }
[16:05:01.407]         }
[16:05:01.407]     })
[16:05:01.407]     if (TRUE) {
[16:05:01.407]         base::sink(type = "output", split = FALSE)
[16:05:01.407]         if (TRUE) {
[16:05:01.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.407]         }
[16:05:01.407]         else {
[16:05:01.407]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.407]         }
[16:05:01.407]         base::close(...future.stdout)
[16:05:01.407]         ...future.stdout <- NULL
[16:05:01.407]     }
[16:05:01.407]     ...future.result$conditions <- ...future.conditions
[16:05:01.407]     ...future.result$finished <- base::Sys.time()
[16:05:01.407]     ...future.result
[16:05:01.407] }
[16:05:01.409] assign_globals() ...
[16:05:01.409] List of 1
[16:05:01.409]  $ x: list()
[16:05:01.409]  - attr(*, "where")=List of 1
[16:05:01.409]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.409]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.409]  - attr(*, "resolved")= logi TRUE
[16:05:01.409]  - attr(*, "total_size")= num 0
[16:05:01.409]  - attr(*, "already-done")= logi TRUE
[16:05:01.411] - copied ‘x’ to environment
[16:05:01.411] assign_globals() ... done
[16:05:01.412] plan(): Setting new future strategy stack:
[16:05:01.412] List of future strategies:
[16:05:01.412] 1. sequential:
[16:05:01.412]    - args: function (..., envir = parent.frame())
[16:05:01.412]    - tweaked: FALSE
[16:05:01.412]    - call: NULL
[16:05:01.412] plan(): nbrOfWorkers() = 1
[16:05:01.413] plan(): Setting new future strategy stack:
[16:05:01.413] List of future strategies:
[16:05:01.413] 1. sequential:
[16:05:01.413]    - args: function (..., envir = parent.frame())
[16:05:01.413]    - tweaked: FALSE
[16:05:01.413]    - call: plan(strategy)
[16:05:01.413] plan(): nbrOfWorkers() = 1
[16:05:01.413] SequentialFuture started (and completed)
[16:05:01.414] - Launch lazy future ... done
[16:05:01.414] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.414] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.414] Searching for globals...
[16:05:01.418] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[16:05:01.418] Searching for globals ... DONE
[16:05:01.418] Resolving globals: TRUE
[16:05:01.418] Resolving any globals that are futures ...
[16:05:01.418] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[16:05:01.418] Resolving any globals that are futures ... DONE
[16:05:01.419] Resolving futures part of globals (recursively) ...
[16:05:01.419] resolve() on list ...
[16:05:01.419]  recursive: 99
[16:05:01.419]  length: 2
[16:05:01.419]  elements: ‘x’, ‘name’
[16:05:01.420]  length: 1 (resolved future 1)
[16:05:01.420]  length: 0 (resolved future 2)
[16:05:01.420] resolve() on list ... DONE
[16:05:01.420] - globals: [2] ‘x’, ‘name’
[16:05:01.420] Resolving futures part of globals (recursively) ... DONE
[16:05:01.420] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:01.420] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[16:05:01.421] - globals: [2] ‘x’, ‘name’
[16:05:01.421] 
[16:05:01.421] getGlobalsAndPackages() ... DONE
[16:05:01.421] run() for ‘Future’ ...
[16:05:01.421] - state: ‘created’
[16:05:01.421] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:01.421] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:01.422] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:01.422]   - Field: ‘label’
[16:05:01.422]   - Field: ‘local’
[16:05:01.422]   - Field: ‘owner’
[16:05:01.422]   - Field: ‘envir’
[16:05:01.422]   - Field: ‘packages’
[16:05:01.422]   - Field: ‘gc’
[16:05:01.422]   - Field: ‘conditions’
[16:05:01.422]   - Field: ‘expr’
[16:05:01.422]   - Field: ‘uuid’
[16:05:01.423]   - Field: ‘seed’
[16:05:01.423]   - Field: ‘version’
[16:05:01.423]   - Field: ‘result’
[16:05:01.423]   - Field: ‘asynchronous’
[16:05:01.423]   - Field: ‘calls’
[16:05:01.423]   - Field: ‘globals’
[16:05:01.423]   - Field: ‘stdout’
[16:05:01.423]   - Field: ‘earlySignal’
[16:05:01.423]   - Field: ‘lazy’
[16:05:01.423]   - Field: ‘state’
[16:05:01.423] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:01.424] - Launch lazy future ...
[16:05:01.424] Packages needed by the future expression (n = 0): <none>
[16:05:01.424] Packages needed by future strategies (n = 0): <none>
[16:05:01.424] {
[16:05:01.424]     {
[16:05:01.424]         {
[16:05:01.424]             ...future.startTime <- base::Sys.time()
[16:05:01.424]             {
[16:05:01.424]                 {
[16:05:01.424]                   {
[16:05:01.424]                     base::local({
[16:05:01.424]                       has_future <- base::requireNamespace("future", 
[16:05:01.424]                         quietly = TRUE)
[16:05:01.424]                       if (has_future) {
[16:05:01.424]                         ns <- base::getNamespace("future")
[16:05:01.424]                         version <- ns[[".package"]][["version"]]
[16:05:01.424]                         if (is.null(version)) 
[16:05:01.424]                           version <- utils::packageVersion("future")
[16:05:01.424]                       }
[16:05:01.424]                       else {
[16:05:01.424]                         version <- NULL
[16:05:01.424]                       }
[16:05:01.424]                       if (!has_future || version < "1.8.0") {
[16:05:01.424]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.424]                           "", base::R.version$version.string), 
[16:05:01.424]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:01.424]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.424]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.424]                             "release", "version")], collapse = " "), 
[16:05:01.424]                           hostname = base::Sys.info()[["nodename"]])
[16:05:01.424]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.424]                           info)
[16:05:01.424]                         info <- base::paste(info, collapse = "; ")
[16:05:01.424]                         if (!has_future) {
[16:05:01.424]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.424]                             info)
[16:05:01.424]                         }
[16:05:01.424]                         else {
[16:05:01.424]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.424]                             info, version)
[16:05:01.424]                         }
[16:05:01.424]                         base::stop(msg)
[16:05:01.424]                       }
[16:05:01.424]                     })
[16:05:01.424]                   }
[16:05:01.424]                   options(future.plan = NULL)
[16:05:01.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.424]                 }
[16:05:01.424]                 ...future.workdir <- getwd()
[16:05:01.424]             }
[16:05:01.424]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.424]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.424]         }
[16:05:01.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.424]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.424]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.424]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.424]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.424]             base::names(...future.oldOptions))
[16:05:01.424]     }
[16:05:01.424]     if (FALSE) {
[16:05:01.424]     }
[16:05:01.424]     else {
[16:05:01.424]         if (TRUE) {
[16:05:01.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.424]                 open = "w")
[16:05:01.424]         }
[16:05:01.424]         else {
[16:05:01.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.424]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.424]         }
[16:05:01.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.424]             base::sink(type = "output", split = FALSE)
[16:05:01.424]             base::close(...future.stdout)
[16:05:01.424]         }, add = TRUE)
[16:05:01.424]     }
[16:05:01.424]     ...future.frame <- base::sys.nframe()
[16:05:01.424]     ...future.conditions <- base::list()
[16:05:01.424]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.424]     if (FALSE) {
[16:05:01.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.424]     }
[16:05:01.424]     ...future.result <- base::tryCatch({
[16:05:01.424]         base::withCallingHandlers({
[16:05:01.424]             ...future.value <- base::withVisible(base::local({
[16:05:01.424]                 x[name] <- list(1)
[16:05:01.424]                 x
[16:05:01.424]             }))
[16:05:01.424]             future::FutureResult(value = ...future.value$value, 
[16:05:01.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.424]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.424]                     ...future.globalenv.names))
[16:05:01.424]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.424]         }, condition = base::local({
[16:05:01.424]             c <- base::c
[16:05:01.424]             inherits <- base::inherits
[16:05:01.424]             invokeRestart <- base::invokeRestart
[16:05:01.424]             length <- base::length
[16:05:01.424]             list <- base::list
[16:05:01.424]             seq.int <- base::seq.int
[16:05:01.424]             signalCondition <- base::signalCondition
[16:05:01.424]             sys.calls <- base::sys.calls
[16:05:01.424]             `[[` <- base::`[[`
[16:05:01.424]             `+` <- base::`+`
[16:05:01.424]             `<<-` <- base::`<<-`
[16:05:01.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.424]                   3L)]
[16:05:01.424]             }
[16:05:01.424]             function(cond) {
[16:05:01.424]                 is_error <- inherits(cond, "error")
[16:05:01.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.424]                   NULL)
[16:05:01.424]                 if (is_error) {
[16:05:01.424]                   sessionInformation <- function() {
[16:05:01.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.424]                       search = base::search(), system = base::Sys.info())
[16:05:01.424]                   }
[16:05:01.424]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.424]                     cond$call), session = sessionInformation(), 
[16:05:01.424]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.424]                   signalCondition(cond)
[16:05:01.424]                 }
[16:05:01.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.424]                 "immediateCondition"))) {
[16:05:01.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.424]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.424]                   if (TRUE && !signal) {
[16:05:01.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.424]                     {
[16:05:01.424]                       inherits <- base::inherits
[16:05:01.424]                       invokeRestart <- base::invokeRestart
[16:05:01.424]                       is.null <- base::is.null
[16:05:01.424]                       muffled <- FALSE
[16:05:01.424]                       if (inherits(cond, "message")) {
[16:05:01.424]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.424]                         if (muffled) 
[16:05:01.424]                           invokeRestart("muffleMessage")
[16:05:01.424]                       }
[16:05:01.424]                       else if (inherits(cond, "warning")) {
[16:05:01.424]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.424]                         if (muffled) 
[16:05:01.424]                           invokeRestart("muffleWarning")
[16:05:01.424]                       }
[16:05:01.424]                       else if (inherits(cond, "condition")) {
[16:05:01.424]                         if (!is.null(pattern)) {
[16:05:01.424]                           computeRestarts <- base::computeRestarts
[16:05:01.424]                           grepl <- base::grepl
[16:05:01.424]                           restarts <- computeRestarts(cond)
[16:05:01.424]                           for (restart in restarts) {
[16:05:01.424]                             name <- restart$name
[16:05:01.424]                             if (is.null(name)) 
[16:05:01.424]                               next
[16:05:01.424]                             if (!grepl(pattern, name)) 
[16:05:01.424]                               next
[16:05:01.424]                             invokeRestart(restart)
[16:05:01.424]                             muffled <- TRUE
[16:05:01.424]                             break
[16:05:01.424]                           }
[16:05:01.424]                         }
[16:05:01.424]                       }
[16:05:01.424]                       invisible(muffled)
[16:05:01.424]                     }
[16:05:01.424]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.424]                   }
[16:05:01.424]                 }
[16:05:01.424]                 else {
[16:05:01.424]                   if (TRUE) {
[16:05:01.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.424]                     {
[16:05:01.424]                       inherits <- base::inherits
[16:05:01.424]                       invokeRestart <- base::invokeRestart
[16:05:01.424]                       is.null <- base::is.null
[16:05:01.424]                       muffled <- FALSE
[16:05:01.424]                       if (inherits(cond, "message")) {
[16:05:01.424]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.424]                         if (muffled) 
[16:05:01.424]                           invokeRestart("muffleMessage")
[16:05:01.424]                       }
[16:05:01.424]                       else if (inherits(cond, "warning")) {
[16:05:01.424]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.424]                         if (muffled) 
[16:05:01.424]                           invokeRestart("muffleWarning")
[16:05:01.424]                       }
[16:05:01.424]                       else if (inherits(cond, "condition")) {
[16:05:01.424]                         if (!is.null(pattern)) {
[16:05:01.424]                           computeRestarts <- base::computeRestarts
[16:05:01.424]                           grepl <- base::grepl
[16:05:01.424]                           restarts <- computeRestarts(cond)
[16:05:01.424]                           for (restart in restarts) {
[16:05:01.424]                             name <- restart$name
[16:05:01.424]                             if (is.null(name)) 
[16:05:01.424]                               next
[16:05:01.424]                             if (!grepl(pattern, name)) 
[16:05:01.424]                               next
[16:05:01.424]                             invokeRestart(restart)
[16:05:01.424]                             muffled <- TRUE
[16:05:01.424]                             break
[16:05:01.424]                           }
[16:05:01.424]                         }
[16:05:01.424]                       }
[16:05:01.424]                       invisible(muffled)
[16:05:01.424]                     }
[16:05:01.424]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.424]                   }
[16:05:01.424]                 }
[16:05:01.424]             }
[16:05:01.424]         }))
[16:05:01.424]     }, error = function(ex) {
[16:05:01.424]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.424]                 ...future.rng), started = ...future.startTime, 
[16:05:01.424]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.424]             version = "1.8"), class = "FutureResult")
[16:05:01.424]     }, finally = {
[16:05:01.424]         if (!identical(...future.workdir, getwd())) 
[16:05:01.424]             setwd(...future.workdir)
[16:05:01.424]         {
[16:05:01.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.424]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.424]             }
[16:05:01.424]             base::options(...future.oldOptions)
[16:05:01.424]             if (.Platform$OS.type == "windows") {
[16:05:01.424]                 old_names <- names(...future.oldEnvVars)
[16:05:01.424]                 envs <- base::Sys.getenv()
[16:05:01.424]                 names <- names(envs)
[16:05:01.424]                 common <- intersect(names, old_names)
[16:05:01.424]                 added <- setdiff(names, old_names)
[16:05:01.424]                 removed <- setdiff(old_names, names)
[16:05:01.424]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.424]                   envs[common]]
[16:05:01.424]                 NAMES <- toupper(changed)
[16:05:01.424]                 args <- list()
[16:05:01.424]                 for (kk in seq_along(NAMES)) {
[16:05:01.424]                   name <- changed[[kk]]
[16:05:01.424]                   NAME <- NAMES[[kk]]
[16:05:01.424]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.424]                     next
[16:05:01.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.424]                 }
[16:05:01.424]                 NAMES <- toupper(added)
[16:05:01.424]                 for (kk in seq_along(NAMES)) {
[16:05:01.424]                   name <- added[[kk]]
[16:05:01.424]                   NAME <- NAMES[[kk]]
[16:05:01.424]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.424]                     next
[16:05:01.424]                   args[[name]] <- ""
[16:05:01.424]                 }
[16:05:01.424]                 NAMES <- toupper(removed)
[16:05:01.424]                 for (kk in seq_along(NAMES)) {
[16:05:01.424]                   name <- removed[[kk]]
[16:05:01.424]                   NAME <- NAMES[[kk]]
[16:05:01.424]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.424]                     next
[16:05:01.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.424]                 }
[16:05:01.424]                 if (length(args) > 0) 
[16:05:01.424]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.424]             }
[16:05:01.424]             else {
[16:05:01.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.424]             }
[16:05:01.424]             {
[16:05:01.424]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.424]                   0L) {
[16:05:01.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.424]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.424]                   base::options(opts)
[16:05:01.424]                 }
[16:05:01.424]                 {
[16:05:01.424]                   {
[16:05:01.424]                     NULL
[16:05:01.424]                     RNGkind("Mersenne-Twister")
[16:05:01.424]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:01.424]                       inherits = FALSE)
[16:05:01.424]                   }
[16:05:01.424]                   options(future.plan = NULL)
[16:05:01.424]                   if (is.na(NA_character_)) 
[16:05:01.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.424]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:01.424]                   {
[16:05:01.424]                     future <- SequentialFuture(..., envir = envir)
[16:05:01.424]                     if (!future$lazy) 
[16:05:01.424]                       future <- run(future)
[16:05:01.424]                     invisible(future)
[16:05:01.424]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.424]                 }
[16:05:01.424]             }
[16:05:01.424]         }
[16:05:01.424]     })
[16:05:01.424]     if (TRUE) {
[16:05:01.424]         base::sink(type = "output", split = FALSE)
[16:05:01.424]         if (TRUE) {
[16:05:01.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.424]         }
[16:05:01.424]         else {
[16:05:01.424]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.424]         }
[16:05:01.424]         base::close(...future.stdout)
[16:05:01.424]         ...future.stdout <- NULL
[16:05:01.424]     }
[16:05:01.424]     ...future.result$conditions <- ...future.conditions
[16:05:01.424]     ...future.result$finished <- base::Sys.time()
[16:05:01.424]     ...future.result
[16:05:01.424] }
[16:05:01.426] assign_globals() ...
[16:05:01.426] List of 2
[16:05:01.426]  $ x   : list()
[16:05:01.426]  $ name: chr "a"
[16:05:01.426]  - attr(*, "where")=List of 2
[16:05:01.426]   ..$ x   :<environment: R_EmptyEnv> 
[16:05:01.426]   ..$ name:<environment: R_EmptyEnv> 
[16:05:01.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.426]  - attr(*, "resolved")= logi TRUE
[16:05:01.426]  - attr(*, "total_size")= num 112
[16:05:01.426]  - attr(*, "already-done")= logi TRUE
[16:05:01.429] - copied ‘x’ to environment
[16:05:01.429] - copied ‘name’ to environment
[16:05:01.429] assign_globals() ... done
[16:05:01.429] plan(): Setting new future strategy stack:
[16:05:01.429] List of future strategies:
[16:05:01.429] 1. sequential:
[16:05:01.429]    - args: function (..., envir = parent.frame())
[16:05:01.429]    - tweaked: FALSE
[16:05:01.429]    - call: NULL
[16:05:01.430] plan(): nbrOfWorkers() = 1
[16:05:01.430] plan(): Setting new future strategy stack:
[16:05:01.430] List of future strategies:
[16:05:01.430] 1. sequential:
[16:05:01.430]    - args: function (..., envir = parent.frame())
[16:05:01.430]    - tweaked: FALSE
[16:05:01.430]    - call: plan(strategy)
[16:05:01.431] plan(): nbrOfWorkers() = 1
[16:05:01.431] SequentialFuture started (and completed)
[16:05:01.431] - Launch lazy future ... done
[16:05:01.431] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[16:05:01.440] plan(): Setting new future strategy stack:
[16:05:01.440] List of future strategies:
[16:05:01.440] 1. multicore:
[16:05:01.440]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.440]    - tweaked: FALSE
[16:05:01.440]    - call: plan(strategy)
[16:05:01.444] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.444] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.444] Searching for globals...
[16:05:01.448] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.448] Searching for globals ... DONE
[16:05:01.448] Resolving globals: TRUE
[16:05:01.448] Resolving any globals that are futures ...
[16:05:01.448] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.448] Resolving any globals that are futures ... DONE
[16:05:01.449] Resolving futures part of globals (recursively) ...
[16:05:01.449] resolve() on list ...
[16:05:01.449]  recursive: 99
[16:05:01.449]  length: 1
[16:05:01.449]  elements: ‘x’
[16:05:01.449]  length: 0 (resolved future 1)
[16:05:01.449] resolve() on list ... DONE
[16:05:01.450] - globals: [1] ‘x’
[16:05:01.450] Resolving futures part of globals (recursively) ... DONE
[16:05:01.450] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.450] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.450] - globals: [1] ‘x’
[16:05:01.450] 
[16:05:01.450] getGlobalsAndPackages() ... DONE
[16:05:01.451] run() for ‘Future’ ...
[16:05:01.451] - state: ‘created’
[16:05:01.451] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:01.454] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:01.454] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:01.455]   - Field: ‘label’
[16:05:01.455]   - Field: ‘local’
[16:05:01.455]   - Field: ‘owner’
[16:05:01.455]   - Field: ‘envir’
[16:05:01.455]   - Field: ‘workers’
[16:05:01.455]   - Field: ‘packages’
[16:05:01.455]   - Field: ‘gc’
[16:05:01.455]   - Field: ‘job’
[16:05:01.455]   - Field: ‘conditions’
[16:05:01.456]   - Field: ‘expr’
[16:05:01.456]   - Field: ‘uuid’
[16:05:01.456]   - Field: ‘seed’
[16:05:01.456]   - Field: ‘version’
[16:05:01.456]   - Field: ‘result’
[16:05:01.456]   - Field: ‘asynchronous’
[16:05:01.456]   - Field: ‘calls’
[16:05:01.456]   - Field: ‘globals’
[16:05:01.456]   - Field: ‘stdout’
[16:05:01.456]   - Field: ‘earlySignal’
[16:05:01.456]   - Field: ‘lazy’
[16:05:01.457]   - Field: ‘state’
[16:05:01.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:01.457] - Launch lazy future ...
[16:05:01.458] Packages needed by the future expression (n = 0): <none>
[16:05:01.458] Packages needed by future strategies (n = 0): <none>
[16:05:01.458] {
[16:05:01.458]     {
[16:05:01.458]         {
[16:05:01.458]             ...future.startTime <- base::Sys.time()
[16:05:01.458]             {
[16:05:01.458]                 {
[16:05:01.458]                   {
[16:05:01.458]                     {
[16:05:01.458]                       base::local({
[16:05:01.458]                         has_future <- base::requireNamespace("future", 
[16:05:01.458]                           quietly = TRUE)
[16:05:01.458]                         if (has_future) {
[16:05:01.458]                           ns <- base::getNamespace("future")
[16:05:01.458]                           version <- ns[[".package"]][["version"]]
[16:05:01.458]                           if (is.null(version)) 
[16:05:01.458]                             version <- utils::packageVersion("future")
[16:05:01.458]                         }
[16:05:01.458]                         else {
[16:05:01.458]                           version <- NULL
[16:05:01.458]                         }
[16:05:01.458]                         if (!has_future || version < "1.8.0") {
[16:05:01.458]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.458]                             "", base::R.version$version.string), 
[16:05:01.458]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:01.458]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.458]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.458]                               "release", "version")], collapse = " "), 
[16:05:01.458]                             hostname = base::Sys.info()[["nodename"]])
[16:05:01.458]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.458]                             info)
[16:05:01.458]                           info <- base::paste(info, collapse = "; ")
[16:05:01.458]                           if (!has_future) {
[16:05:01.458]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.458]                               info)
[16:05:01.458]                           }
[16:05:01.458]                           else {
[16:05:01.458]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.458]                               info, version)
[16:05:01.458]                           }
[16:05:01.458]                           base::stop(msg)
[16:05:01.458]                         }
[16:05:01.458]                       })
[16:05:01.458]                     }
[16:05:01.458]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:01.458]                     base::options(mc.cores = 1L)
[16:05:01.458]                   }
[16:05:01.458]                   options(future.plan = NULL)
[16:05:01.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.458]                 }
[16:05:01.458]                 ...future.workdir <- getwd()
[16:05:01.458]             }
[16:05:01.458]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.458]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.458]         }
[16:05:01.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.458]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.458]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.458]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.458]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.458]             base::names(...future.oldOptions))
[16:05:01.458]     }
[16:05:01.458]     if (FALSE) {
[16:05:01.458]     }
[16:05:01.458]     else {
[16:05:01.458]         if (TRUE) {
[16:05:01.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.458]                 open = "w")
[16:05:01.458]         }
[16:05:01.458]         else {
[16:05:01.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.458]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.458]         }
[16:05:01.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.458]             base::sink(type = "output", split = FALSE)
[16:05:01.458]             base::close(...future.stdout)
[16:05:01.458]         }, add = TRUE)
[16:05:01.458]     }
[16:05:01.458]     ...future.frame <- base::sys.nframe()
[16:05:01.458]     ...future.conditions <- base::list()
[16:05:01.458]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.458]     if (FALSE) {
[16:05:01.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.458]     }
[16:05:01.458]     ...future.result <- base::tryCatch({
[16:05:01.458]         base::withCallingHandlers({
[16:05:01.458]             ...future.value <- base::withVisible(base::local({
[16:05:01.458]                 withCallingHandlers({
[16:05:01.458]                   {
[16:05:01.458]                     x$a <- 1
[16:05:01.458]                     x
[16:05:01.458]                   }
[16:05:01.458]                 }, immediateCondition = function(cond) {
[16:05:01.458]                   save_rds <- function (object, pathname, ...) 
[16:05:01.458]                   {
[16:05:01.458]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:01.458]                     if (file_test("-f", pathname_tmp)) {
[16:05:01.458]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.458]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:01.458]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.458]                         fi_tmp[["mtime"]])
[16:05:01.458]                     }
[16:05:01.458]                     tryCatch({
[16:05:01.458]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:01.458]                     }, error = function(ex) {
[16:05:01.458]                       msg <- conditionMessage(ex)
[16:05:01.458]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.458]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:01.458]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.458]                         fi_tmp[["mtime"]], msg)
[16:05:01.458]                       ex$message <- msg
[16:05:01.458]                       stop(ex)
[16:05:01.458]                     })
[16:05:01.458]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:01.458]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:01.458]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:01.458]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.458]                       fi <- file.info(pathname)
[16:05:01.458]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:01.458]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.458]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:01.458]                         fi[["size"]], fi[["mtime"]])
[16:05:01.458]                       stop(msg)
[16:05:01.458]                     }
[16:05:01.458]                     invisible(pathname)
[16:05:01.458]                   }
[16:05:01.458]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:01.458]                     rootPath = tempdir()) 
[16:05:01.458]                   {
[16:05:01.458]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:01.458]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:01.458]                       tmpdir = path, fileext = ".rds")
[16:05:01.458]                     save_rds(obj, file)
[16:05:01.458]                   }
[16:05:01.458]                   saveImmediateCondition(cond, path = "/tmp/Rtmpsnomsu/.future/immediateConditions")
[16:05:01.458]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.458]                   {
[16:05:01.458]                     inherits <- base::inherits
[16:05:01.458]                     invokeRestart <- base::invokeRestart
[16:05:01.458]                     is.null <- base::is.null
[16:05:01.458]                     muffled <- FALSE
[16:05:01.458]                     if (inherits(cond, "message")) {
[16:05:01.458]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:01.458]                       if (muffled) 
[16:05:01.458]                         invokeRestart("muffleMessage")
[16:05:01.458]                     }
[16:05:01.458]                     else if (inherits(cond, "warning")) {
[16:05:01.458]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:01.458]                       if (muffled) 
[16:05:01.458]                         invokeRestart("muffleWarning")
[16:05:01.458]                     }
[16:05:01.458]                     else if (inherits(cond, "condition")) {
[16:05:01.458]                       if (!is.null(pattern)) {
[16:05:01.458]                         computeRestarts <- base::computeRestarts
[16:05:01.458]                         grepl <- base::grepl
[16:05:01.458]                         restarts <- computeRestarts(cond)
[16:05:01.458]                         for (restart in restarts) {
[16:05:01.458]                           name <- restart$name
[16:05:01.458]                           if (is.null(name)) 
[16:05:01.458]                             next
[16:05:01.458]                           if (!grepl(pattern, name)) 
[16:05:01.458]                             next
[16:05:01.458]                           invokeRestart(restart)
[16:05:01.458]                           muffled <- TRUE
[16:05:01.458]                           break
[16:05:01.458]                         }
[16:05:01.458]                       }
[16:05:01.458]                     }
[16:05:01.458]                     invisible(muffled)
[16:05:01.458]                   }
[16:05:01.458]                   muffleCondition(cond)
[16:05:01.458]                 })
[16:05:01.458]             }))
[16:05:01.458]             future::FutureResult(value = ...future.value$value, 
[16:05:01.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.458]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.458]                     ...future.globalenv.names))
[16:05:01.458]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.458]         }, condition = base::local({
[16:05:01.458]             c <- base::c
[16:05:01.458]             inherits <- base::inherits
[16:05:01.458]             invokeRestart <- base::invokeRestart
[16:05:01.458]             length <- base::length
[16:05:01.458]             list <- base::list
[16:05:01.458]             seq.int <- base::seq.int
[16:05:01.458]             signalCondition <- base::signalCondition
[16:05:01.458]             sys.calls <- base::sys.calls
[16:05:01.458]             `[[` <- base::`[[`
[16:05:01.458]             `+` <- base::`+`
[16:05:01.458]             `<<-` <- base::`<<-`
[16:05:01.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.458]                   3L)]
[16:05:01.458]             }
[16:05:01.458]             function(cond) {
[16:05:01.458]                 is_error <- inherits(cond, "error")
[16:05:01.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.458]                   NULL)
[16:05:01.458]                 if (is_error) {
[16:05:01.458]                   sessionInformation <- function() {
[16:05:01.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.458]                       search = base::search(), system = base::Sys.info())
[16:05:01.458]                   }
[16:05:01.458]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.458]                     cond$call), session = sessionInformation(), 
[16:05:01.458]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.458]                   signalCondition(cond)
[16:05:01.458]                 }
[16:05:01.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.458]                 "immediateCondition"))) {
[16:05:01.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.458]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.458]                   if (TRUE && !signal) {
[16:05:01.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.458]                     {
[16:05:01.458]                       inherits <- base::inherits
[16:05:01.458]                       invokeRestart <- base::invokeRestart
[16:05:01.458]                       is.null <- base::is.null
[16:05:01.458]                       muffled <- FALSE
[16:05:01.458]                       if (inherits(cond, "message")) {
[16:05:01.458]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.458]                         if (muffled) 
[16:05:01.458]                           invokeRestart("muffleMessage")
[16:05:01.458]                       }
[16:05:01.458]                       else if (inherits(cond, "warning")) {
[16:05:01.458]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.458]                         if (muffled) 
[16:05:01.458]                           invokeRestart("muffleWarning")
[16:05:01.458]                       }
[16:05:01.458]                       else if (inherits(cond, "condition")) {
[16:05:01.458]                         if (!is.null(pattern)) {
[16:05:01.458]                           computeRestarts <- base::computeRestarts
[16:05:01.458]                           grepl <- base::grepl
[16:05:01.458]                           restarts <- computeRestarts(cond)
[16:05:01.458]                           for (restart in restarts) {
[16:05:01.458]                             name <- restart$name
[16:05:01.458]                             if (is.null(name)) 
[16:05:01.458]                               next
[16:05:01.458]                             if (!grepl(pattern, name)) 
[16:05:01.458]                               next
[16:05:01.458]                             invokeRestart(restart)
[16:05:01.458]                             muffled <- TRUE
[16:05:01.458]                             break
[16:05:01.458]                           }
[16:05:01.458]                         }
[16:05:01.458]                       }
[16:05:01.458]                       invisible(muffled)
[16:05:01.458]                     }
[16:05:01.458]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.458]                   }
[16:05:01.458]                 }
[16:05:01.458]                 else {
[16:05:01.458]                   if (TRUE) {
[16:05:01.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.458]                     {
[16:05:01.458]                       inherits <- base::inherits
[16:05:01.458]                       invokeRestart <- base::invokeRestart
[16:05:01.458]                       is.null <- base::is.null
[16:05:01.458]                       muffled <- FALSE
[16:05:01.458]                       if (inherits(cond, "message")) {
[16:05:01.458]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.458]                         if (muffled) 
[16:05:01.458]                           invokeRestart("muffleMessage")
[16:05:01.458]                       }
[16:05:01.458]                       else if (inherits(cond, "warning")) {
[16:05:01.458]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.458]                         if (muffled) 
[16:05:01.458]                           invokeRestart("muffleWarning")
[16:05:01.458]                       }
[16:05:01.458]                       else if (inherits(cond, "condition")) {
[16:05:01.458]                         if (!is.null(pattern)) {
[16:05:01.458]                           computeRestarts <- base::computeRestarts
[16:05:01.458]                           grepl <- base::grepl
[16:05:01.458]                           restarts <- computeRestarts(cond)
[16:05:01.458]                           for (restart in restarts) {
[16:05:01.458]                             name <- restart$name
[16:05:01.458]                             if (is.null(name)) 
[16:05:01.458]                               next
[16:05:01.458]                             if (!grepl(pattern, name)) 
[16:05:01.458]                               next
[16:05:01.458]                             invokeRestart(restart)
[16:05:01.458]                             muffled <- TRUE
[16:05:01.458]                             break
[16:05:01.458]                           }
[16:05:01.458]                         }
[16:05:01.458]                       }
[16:05:01.458]                       invisible(muffled)
[16:05:01.458]                     }
[16:05:01.458]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.458]                   }
[16:05:01.458]                 }
[16:05:01.458]             }
[16:05:01.458]         }))
[16:05:01.458]     }, error = function(ex) {
[16:05:01.458]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.458]                 ...future.rng), started = ...future.startTime, 
[16:05:01.458]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.458]             version = "1.8"), class = "FutureResult")
[16:05:01.458]     }, finally = {
[16:05:01.458]         if (!identical(...future.workdir, getwd())) 
[16:05:01.458]             setwd(...future.workdir)
[16:05:01.458]         {
[16:05:01.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.458]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.458]             }
[16:05:01.458]             base::options(...future.oldOptions)
[16:05:01.458]             if (.Platform$OS.type == "windows") {
[16:05:01.458]                 old_names <- names(...future.oldEnvVars)
[16:05:01.458]                 envs <- base::Sys.getenv()
[16:05:01.458]                 names <- names(envs)
[16:05:01.458]                 common <- intersect(names, old_names)
[16:05:01.458]                 added <- setdiff(names, old_names)
[16:05:01.458]                 removed <- setdiff(old_names, names)
[16:05:01.458]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.458]                   envs[common]]
[16:05:01.458]                 NAMES <- toupper(changed)
[16:05:01.458]                 args <- list()
[16:05:01.458]                 for (kk in seq_along(NAMES)) {
[16:05:01.458]                   name <- changed[[kk]]
[16:05:01.458]                   NAME <- NAMES[[kk]]
[16:05:01.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.458]                     next
[16:05:01.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.458]                 }
[16:05:01.458]                 NAMES <- toupper(added)
[16:05:01.458]                 for (kk in seq_along(NAMES)) {
[16:05:01.458]                   name <- added[[kk]]
[16:05:01.458]                   NAME <- NAMES[[kk]]
[16:05:01.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.458]                     next
[16:05:01.458]                   args[[name]] <- ""
[16:05:01.458]                 }
[16:05:01.458]                 NAMES <- toupper(removed)
[16:05:01.458]                 for (kk in seq_along(NAMES)) {
[16:05:01.458]                   name <- removed[[kk]]
[16:05:01.458]                   NAME <- NAMES[[kk]]
[16:05:01.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.458]                     next
[16:05:01.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.458]                 }
[16:05:01.458]                 if (length(args) > 0) 
[16:05:01.458]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.458]             }
[16:05:01.458]             else {
[16:05:01.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.458]             }
[16:05:01.458]             {
[16:05:01.458]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.458]                   0L) {
[16:05:01.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.458]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.458]                   base::options(opts)
[16:05:01.458]                 }
[16:05:01.458]                 {
[16:05:01.458]                   {
[16:05:01.458]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:01.458]                     NULL
[16:05:01.458]                   }
[16:05:01.458]                   options(future.plan = NULL)
[16:05:01.458]                   if (is.na(NA_character_)) 
[16:05:01.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.458]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:01.458]                     envir = parent.frame()) 
[16:05:01.458]                   {
[16:05:01.458]                     default_workers <- missing(workers)
[16:05:01.458]                     if (is.function(workers)) 
[16:05:01.458]                       workers <- workers()
[16:05:01.458]                     workers <- structure(as.integer(workers), 
[16:05:01.458]                       class = class(workers))
[16:05:01.458]                     stop_if_not(is.finite(workers), workers >= 
[16:05:01.458]                       1L)
[16:05:01.458]                     if ((workers == 1L && !inherits(workers, 
[16:05:01.458]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:01.458]                       if (default_workers) 
[16:05:01.458]                         supportsMulticore(warn = TRUE)
[16:05:01.458]                       return(sequential(..., envir = envir))
[16:05:01.458]                     }
[16:05:01.458]                     oopts <- options(mc.cores = workers)
[16:05:01.458]                     on.exit(options(oopts))
[16:05:01.458]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:01.458]                       envir = envir)
[16:05:01.458]                     if (!future$lazy) 
[16:05:01.458]                       future <- run(future)
[16:05:01.458]                     invisible(future)
[16:05:01.458]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.458]                 }
[16:05:01.458]             }
[16:05:01.458]         }
[16:05:01.458]     })
[16:05:01.458]     if (TRUE) {
[16:05:01.458]         base::sink(type = "output", split = FALSE)
[16:05:01.458]         if (TRUE) {
[16:05:01.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.458]         }
[16:05:01.458]         else {
[16:05:01.458]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.458]         }
[16:05:01.458]         base::close(...future.stdout)
[16:05:01.458]         ...future.stdout <- NULL
[16:05:01.458]     }
[16:05:01.458]     ...future.result$conditions <- ...future.conditions
[16:05:01.458]     ...future.result$finished <- base::Sys.time()
[16:05:01.458]     ...future.result
[16:05:01.458] }
[16:05:01.461] assign_globals() ...
[16:05:01.461] List of 1
[16:05:01.461]  $ x: list()
[16:05:01.461]  - attr(*, "where")=List of 1
[16:05:01.461]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.461]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.461]  - attr(*, "resolved")= logi TRUE
[16:05:01.461]  - attr(*, "total_size")= num 0
[16:05:01.461]  - attr(*, "already-done")= logi TRUE
[16:05:01.463] - copied ‘x’ to environment
[16:05:01.463] assign_globals() ... done
[16:05:01.463] requestCore(): workers = 2
[16:05:01.466] MulticoreFuture started
[16:05:01.467] - Launch lazy future ... done
[16:05:01.467] run() for ‘MulticoreFuture’ ... done
[16:05:01.467] plan(): Setting new future strategy stack:
[16:05:01.467] List of future strategies:
[16:05:01.467] 1. sequential:
[16:05:01.467]    - args: function (..., envir = parent.frame())
[16:05:01.467]    - tweaked: FALSE
[16:05:01.467]    - call: NULL
[16:05:01.468] plan(): nbrOfWorkers() = 1
[16:05:01.468] result() for MulticoreFuture ...
[16:05:01.470] plan(): Setting new future strategy stack:
[16:05:01.470] List of future strategies:
[16:05:01.470] 1. multicore:
[16:05:01.470]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.470]    - tweaked: FALSE
[16:05:01.470]    - call: plan(strategy)
[16:05:01.475] plan(): nbrOfWorkers() = 2
[16:05:01.480] result() for MulticoreFuture ...
[16:05:01.480] result() for MulticoreFuture ... done
[16:05:01.480] result() for MulticoreFuture ... done
[16:05:01.481] result() for MulticoreFuture ...
[16:05:01.481] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.481] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.481] Searching for globals...
[16:05:01.484] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.484] Searching for globals ... DONE
[16:05:01.484] Resolving globals: TRUE
[16:05:01.484] Resolving any globals that are futures ...
[16:05:01.484] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.484] Resolving any globals that are futures ... DONE
[16:05:01.485] Resolving futures part of globals (recursively) ...
[16:05:01.485] resolve() on list ...
[16:05:01.485]  recursive: 99
[16:05:01.485]  length: 1
[16:05:01.486]  elements: ‘x’
[16:05:01.486]  length: 0 (resolved future 1)
[16:05:01.486] resolve() on list ... DONE
[16:05:01.486] - globals: [1] ‘x’
[16:05:01.486] Resolving futures part of globals (recursively) ... DONE
[16:05:01.486] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.487] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.487] - globals: [1] ‘x’
[16:05:01.487] 
[16:05:01.487] getGlobalsAndPackages() ... DONE
[16:05:01.487] run() for ‘Future’ ...
[16:05:01.488] - state: ‘created’
[16:05:01.488] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:01.492] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:01.492] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:01.492]   - Field: ‘label’
[16:05:01.492]   - Field: ‘local’
[16:05:01.492]   - Field: ‘owner’
[16:05:01.492]   - Field: ‘envir’
[16:05:01.493]   - Field: ‘workers’
[16:05:01.493]   - Field: ‘packages’
[16:05:01.493]   - Field: ‘gc’
[16:05:01.495]   - Field: ‘job’
[16:05:01.496]   - Field: ‘conditions’
[16:05:01.496]   - Field: ‘expr’
[16:05:01.496]   - Field: ‘uuid’
[16:05:01.496]   - Field: ‘seed’
[16:05:01.496]   - Field: ‘version’
[16:05:01.496]   - Field: ‘result’
[16:05:01.496]   - Field: ‘asynchronous’
[16:05:01.497]   - Field: ‘calls’
[16:05:01.497]   - Field: ‘globals’
[16:05:01.497]   - Field: ‘stdout’
[16:05:01.497]   - Field: ‘earlySignal’
[16:05:01.497]   - Field: ‘lazy’
[16:05:01.497]   - Field: ‘state’
[16:05:01.497] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:01.497] - Launch lazy future ...
[16:05:01.498] Packages needed by the future expression (n = 0): <none>
[16:05:01.498] Packages needed by future strategies (n = 0): <none>
[16:05:01.499] {
[16:05:01.499]     {
[16:05:01.499]         {
[16:05:01.499]             ...future.startTime <- base::Sys.time()
[16:05:01.499]             {
[16:05:01.499]                 {
[16:05:01.499]                   {
[16:05:01.499]                     {
[16:05:01.499]                       base::local({
[16:05:01.499]                         has_future <- base::requireNamespace("future", 
[16:05:01.499]                           quietly = TRUE)
[16:05:01.499]                         if (has_future) {
[16:05:01.499]                           ns <- base::getNamespace("future")
[16:05:01.499]                           version <- ns[[".package"]][["version"]]
[16:05:01.499]                           if (is.null(version)) 
[16:05:01.499]                             version <- utils::packageVersion("future")
[16:05:01.499]                         }
[16:05:01.499]                         else {
[16:05:01.499]                           version <- NULL
[16:05:01.499]                         }
[16:05:01.499]                         if (!has_future || version < "1.8.0") {
[16:05:01.499]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.499]                             "", base::R.version$version.string), 
[16:05:01.499]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:01.499]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.499]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.499]                               "release", "version")], collapse = " "), 
[16:05:01.499]                             hostname = base::Sys.info()[["nodename"]])
[16:05:01.499]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.499]                             info)
[16:05:01.499]                           info <- base::paste(info, collapse = "; ")
[16:05:01.499]                           if (!has_future) {
[16:05:01.499]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.499]                               info)
[16:05:01.499]                           }
[16:05:01.499]                           else {
[16:05:01.499]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.499]                               info, version)
[16:05:01.499]                           }
[16:05:01.499]                           base::stop(msg)
[16:05:01.499]                         }
[16:05:01.499]                       })
[16:05:01.499]                     }
[16:05:01.499]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:01.499]                     base::options(mc.cores = 1L)
[16:05:01.499]                   }
[16:05:01.499]                   options(future.plan = NULL)
[16:05:01.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.499]                 }
[16:05:01.499]                 ...future.workdir <- getwd()
[16:05:01.499]             }
[16:05:01.499]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.499]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.499]         }
[16:05:01.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.499]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.499]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.499]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.499]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.499]             base::names(...future.oldOptions))
[16:05:01.499]     }
[16:05:01.499]     if (FALSE) {
[16:05:01.499]     }
[16:05:01.499]     else {
[16:05:01.499]         if (TRUE) {
[16:05:01.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.499]                 open = "w")
[16:05:01.499]         }
[16:05:01.499]         else {
[16:05:01.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.499]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.499]         }
[16:05:01.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.499]             base::sink(type = "output", split = FALSE)
[16:05:01.499]             base::close(...future.stdout)
[16:05:01.499]         }, add = TRUE)
[16:05:01.499]     }
[16:05:01.499]     ...future.frame <- base::sys.nframe()
[16:05:01.499]     ...future.conditions <- base::list()
[16:05:01.499]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.499]     if (FALSE) {
[16:05:01.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.499]     }
[16:05:01.499]     ...future.result <- base::tryCatch({
[16:05:01.499]         base::withCallingHandlers({
[16:05:01.499]             ...future.value <- base::withVisible(base::local({
[16:05:01.499]                 withCallingHandlers({
[16:05:01.499]                   {
[16:05:01.499]                     x$a <- 1
[16:05:01.499]                     x
[16:05:01.499]                   }
[16:05:01.499]                 }, immediateCondition = function(cond) {
[16:05:01.499]                   save_rds <- function (object, pathname, ...) 
[16:05:01.499]                   {
[16:05:01.499]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:01.499]                     if (file_test("-f", pathname_tmp)) {
[16:05:01.499]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.499]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:01.499]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.499]                         fi_tmp[["mtime"]])
[16:05:01.499]                     }
[16:05:01.499]                     tryCatch({
[16:05:01.499]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:01.499]                     }, error = function(ex) {
[16:05:01.499]                       msg <- conditionMessage(ex)
[16:05:01.499]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.499]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:01.499]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.499]                         fi_tmp[["mtime"]], msg)
[16:05:01.499]                       ex$message <- msg
[16:05:01.499]                       stop(ex)
[16:05:01.499]                     })
[16:05:01.499]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:01.499]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:01.499]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:01.499]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.499]                       fi <- file.info(pathname)
[16:05:01.499]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:01.499]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.499]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:01.499]                         fi[["size"]], fi[["mtime"]])
[16:05:01.499]                       stop(msg)
[16:05:01.499]                     }
[16:05:01.499]                     invisible(pathname)
[16:05:01.499]                   }
[16:05:01.499]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:01.499]                     rootPath = tempdir()) 
[16:05:01.499]                   {
[16:05:01.499]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:01.499]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:01.499]                       tmpdir = path, fileext = ".rds")
[16:05:01.499]                     save_rds(obj, file)
[16:05:01.499]                   }
[16:05:01.499]                   saveImmediateCondition(cond, path = "/tmp/Rtmpsnomsu/.future/immediateConditions")
[16:05:01.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.499]                   {
[16:05:01.499]                     inherits <- base::inherits
[16:05:01.499]                     invokeRestart <- base::invokeRestart
[16:05:01.499]                     is.null <- base::is.null
[16:05:01.499]                     muffled <- FALSE
[16:05:01.499]                     if (inherits(cond, "message")) {
[16:05:01.499]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:01.499]                       if (muffled) 
[16:05:01.499]                         invokeRestart("muffleMessage")
[16:05:01.499]                     }
[16:05:01.499]                     else if (inherits(cond, "warning")) {
[16:05:01.499]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:01.499]                       if (muffled) 
[16:05:01.499]                         invokeRestart("muffleWarning")
[16:05:01.499]                     }
[16:05:01.499]                     else if (inherits(cond, "condition")) {
[16:05:01.499]                       if (!is.null(pattern)) {
[16:05:01.499]                         computeRestarts <- base::computeRestarts
[16:05:01.499]                         grepl <- base::grepl
[16:05:01.499]                         restarts <- computeRestarts(cond)
[16:05:01.499]                         for (restart in restarts) {
[16:05:01.499]                           name <- restart$name
[16:05:01.499]                           if (is.null(name)) 
[16:05:01.499]                             next
[16:05:01.499]                           if (!grepl(pattern, name)) 
[16:05:01.499]                             next
[16:05:01.499]                           invokeRestart(restart)
[16:05:01.499]                           muffled <- TRUE
[16:05:01.499]                           break
[16:05:01.499]                         }
[16:05:01.499]                       }
[16:05:01.499]                     }
[16:05:01.499]                     invisible(muffled)
[16:05:01.499]                   }
[16:05:01.499]                   muffleCondition(cond)
[16:05:01.499]                 })
[16:05:01.499]             }))
[16:05:01.499]             future::FutureResult(value = ...future.value$value, 
[16:05:01.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.499]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.499]                     ...future.globalenv.names))
[16:05:01.499]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.499]         }, condition = base::local({
[16:05:01.499]             c <- base::c
[16:05:01.499]             inherits <- base::inherits
[16:05:01.499]             invokeRestart <- base::invokeRestart
[16:05:01.499]             length <- base::length
[16:05:01.499]             list <- base::list
[16:05:01.499]             seq.int <- base::seq.int
[16:05:01.499]             signalCondition <- base::signalCondition
[16:05:01.499]             sys.calls <- base::sys.calls
[16:05:01.499]             `[[` <- base::`[[`
[16:05:01.499]             `+` <- base::`+`
[16:05:01.499]             `<<-` <- base::`<<-`
[16:05:01.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.499]                   3L)]
[16:05:01.499]             }
[16:05:01.499]             function(cond) {
[16:05:01.499]                 is_error <- inherits(cond, "error")
[16:05:01.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.499]                   NULL)
[16:05:01.499]                 if (is_error) {
[16:05:01.499]                   sessionInformation <- function() {
[16:05:01.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.499]                       search = base::search(), system = base::Sys.info())
[16:05:01.499]                   }
[16:05:01.499]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.499]                     cond$call), session = sessionInformation(), 
[16:05:01.499]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.499]                   signalCondition(cond)
[16:05:01.499]                 }
[16:05:01.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.499]                 "immediateCondition"))) {
[16:05:01.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.499]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.499]                   if (TRUE && !signal) {
[16:05:01.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.499]                     {
[16:05:01.499]                       inherits <- base::inherits
[16:05:01.499]                       invokeRestart <- base::invokeRestart
[16:05:01.499]                       is.null <- base::is.null
[16:05:01.499]                       muffled <- FALSE
[16:05:01.499]                       if (inherits(cond, "message")) {
[16:05:01.499]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.499]                         if (muffled) 
[16:05:01.499]                           invokeRestart("muffleMessage")
[16:05:01.499]                       }
[16:05:01.499]                       else if (inherits(cond, "warning")) {
[16:05:01.499]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.499]                         if (muffled) 
[16:05:01.499]                           invokeRestart("muffleWarning")
[16:05:01.499]                       }
[16:05:01.499]                       else if (inherits(cond, "condition")) {
[16:05:01.499]                         if (!is.null(pattern)) {
[16:05:01.499]                           computeRestarts <- base::computeRestarts
[16:05:01.499]                           grepl <- base::grepl
[16:05:01.499]                           restarts <- computeRestarts(cond)
[16:05:01.499]                           for (restart in restarts) {
[16:05:01.499]                             name <- restart$name
[16:05:01.499]                             if (is.null(name)) 
[16:05:01.499]                               next
[16:05:01.499]                             if (!grepl(pattern, name)) 
[16:05:01.499]                               next
[16:05:01.499]                             invokeRestart(restart)
[16:05:01.499]                             muffled <- TRUE
[16:05:01.499]                             break
[16:05:01.499]                           }
[16:05:01.499]                         }
[16:05:01.499]                       }
[16:05:01.499]                       invisible(muffled)
[16:05:01.499]                     }
[16:05:01.499]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.499]                   }
[16:05:01.499]                 }
[16:05:01.499]                 else {
[16:05:01.499]                   if (TRUE) {
[16:05:01.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.499]                     {
[16:05:01.499]                       inherits <- base::inherits
[16:05:01.499]                       invokeRestart <- base::invokeRestart
[16:05:01.499]                       is.null <- base::is.null
[16:05:01.499]                       muffled <- FALSE
[16:05:01.499]                       if (inherits(cond, "message")) {
[16:05:01.499]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.499]                         if (muffled) 
[16:05:01.499]                           invokeRestart("muffleMessage")
[16:05:01.499]                       }
[16:05:01.499]                       else if (inherits(cond, "warning")) {
[16:05:01.499]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.499]                         if (muffled) 
[16:05:01.499]                           invokeRestart("muffleWarning")
[16:05:01.499]                       }
[16:05:01.499]                       else if (inherits(cond, "condition")) {
[16:05:01.499]                         if (!is.null(pattern)) {
[16:05:01.499]                           computeRestarts <- base::computeRestarts
[16:05:01.499]                           grepl <- base::grepl
[16:05:01.499]                           restarts <- computeRestarts(cond)
[16:05:01.499]                           for (restart in restarts) {
[16:05:01.499]                             name <- restart$name
[16:05:01.499]                             if (is.null(name)) 
[16:05:01.499]                               next
[16:05:01.499]                             if (!grepl(pattern, name)) 
[16:05:01.499]                               next
[16:05:01.499]                             invokeRestart(restart)
[16:05:01.499]                             muffled <- TRUE
[16:05:01.499]                             break
[16:05:01.499]                           }
[16:05:01.499]                         }
[16:05:01.499]                       }
[16:05:01.499]                       invisible(muffled)
[16:05:01.499]                     }
[16:05:01.499]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.499]                   }
[16:05:01.499]                 }
[16:05:01.499]             }
[16:05:01.499]         }))
[16:05:01.499]     }, error = function(ex) {
[16:05:01.499]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.499]                 ...future.rng), started = ...future.startTime, 
[16:05:01.499]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.499]             version = "1.8"), class = "FutureResult")
[16:05:01.499]     }, finally = {
[16:05:01.499]         if (!identical(...future.workdir, getwd())) 
[16:05:01.499]             setwd(...future.workdir)
[16:05:01.499]         {
[16:05:01.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.499]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.499]             }
[16:05:01.499]             base::options(...future.oldOptions)
[16:05:01.499]             if (.Platform$OS.type == "windows") {
[16:05:01.499]                 old_names <- names(...future.oldEnvVars)
[16:05:01.499]                 envs <- base::Sys.getenv()
[16:05:01.499]                 names <- names(envs)
[16:05:01.499]                 common <- intersect(names, old_names)
[16:05:01.499]                 added <- setdiff(names, old_names)
[16:05:01.499]                 removed <- setdiff(old_names, names)
[16:05:01.499]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.499]                   envs[common]]
[16:05:01.499]                 NAMES <- toupper(changed)
[16:05:01.499]                 args <- list()
[16:05:01.499]                 for (kk in seq_along(NAMES)) {
[16:05:01.499]                   name <- changed[[kk]]
[16:05:01.499]                   NAME <- NAMES[[kk]]
[16:05:01.499]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.499]                     next
[16:05:01.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.499]                 }
[16:05:01.499]                 NAMES <- toupper(added)
[16:05:01.499]                 for (kk in seq_along(NAMES)) {
[16:05:01.499]                   name <- added[[kk]]
[16:05:01.499]                   NAME <- NAMES[[kk]]
[16:05:01.499]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.499]                     next
[16:05:01.499]                   args[[name]] <- ""
[16:05:01.499]                 }
[16:05:01.499]                 NAMES <- toupper(removed)
[16:05:01.499]                 for (kk in seq_along(NAMES)) {
[16:05:01.499]                   name <- removed[[kk]]
[16:05:01.499]                   NAME <- NAMES[[kk]]
[16:05:01.499]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.499]                     next
[16:05:01.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.499]                 }
[16:05:01.499]                 if (length(args) > 0) 
[16:05:01.499]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.499]             }
[16:05:01.499]             else {
[16:05:01.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.499]             }
[16:05:01.499]             {
[16:05:01.499]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.499]                   0L) {
[16:05:01.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.499]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.499]                   base::options(opts)
[16:05:01.499]                 }
[16:05:01.499]                 {
[16:05:01.499]                   {
[16:05:01.499]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:01.499]                     NULL
[16:05:01.499]                   }
[16:05:01.499]                   options(future.plan = NULL)
[16:05:01.499]                   if (is.na(NA_character_)) 
[16:05:01.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.499]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:01.499]                     envir = parent.frame()) 
[16:05:01.499]                   {
[16:05:01.499]                     default_workers <- missing(workers)
[16:05:01.499]                     if (is.function(workers)) 
[16:05:01.499]                       workers <- workers()
[16:05:01.499]                     workers <- structure(as.integer(workers), 
[16:05:01.499]                       class = class(workers))
[16:05:01.499]                     stop_if_not(is.finite(workers), workers >= 
[16:05:01.499]                       1L)
[16:05:01.499]                     if ((workers == 1L && !inherits(workers, 
[16:05:01.499]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:01.499]                       if (default_workers) 
[16:05:01.499]                         supportsMulticore(warn = TRUE)
[16:05:01.499]                       return(sequential(..., envir = envir))
[16:05:01.499]                     }
[16:05:01.499]                     oopts <- options(mc.cores = workers)
[16:05:01.499]                     on.exit(options(oopts))
[16:05:01.499]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:01.499]                       envir = envir)
[16:05:01.499]                     if (!future$lazy) 
[16:05:01.499]                       future <- run(future)
[16:05:01.499]                     invisible(future)
[16:05:01.499]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.499]                 }
[16:05:01.499]             }
[16:05:01.499]         }
[16:05:01.499]     })
[16:05:01.499]     if (TRUE) {
[16:05:01.499]         base::sink(type = "output", split = FALSE)
[16:05:01.499]         if (TRUE) {
[16:05:01.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.499]         }
[16:05:01.499]         else {
[16:05:01.499]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.499]         }
[16:05:01.499]         base::close(...future.stdout)
[16:05:01.499]         ...future.stdout <- NULL
[16:05:01.499]     }
[16:05:01.499]     ...future.result$conditions <- ...future.conditions
[16:05:01.499]     ...future.result$finished <- base::Sys.time()
[16:05:01.499]     ...future.result
[16:05:01.499] }
[16:05:01.501] assign_globals() ...
[16:05:01.501] List of 1
[16:05:01.501]  $ x: list()
[16:05:01.501]  - attr(*, "where")=List of 1
[16:05:01.501]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.501]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.501]  - attr(*, "resolved")= logi TRUE
[16:05:01.501]  - attr(*, "total_size")= num 0
[16:05:01.501]  - attr(*, "already-done")= logi TRUE
[16:05:01.504] - copied ‘x’ to environment
[16:05:01.504] assign_globals() ... done
[16:05:01.505] requestCore(): workers = 2
[16:05:01.506] MulticoreFuture started
[16:05:01.507] - Launch lazy future ... done
[16:05:01.507] run() for ‘MulticoreFuture’ ... done
[16:05:01.507] result() for MulticoreFuture ...
[16:05:01.508] plan(): Setting new future strategy stack:
[16:05:01.508] List of future strategies:
[16:05:01.508] 1. sequential:
[16:05:01.508]    - args: function (..., envir = parent.frame())
[16:05:01.508]    - tweaked: FALSE
[16:05:01.508]    - call: NULL
[16:05:01.509] plan(): nbrOfWorkers() = 1
[16:05:01.511] plan(): Setting new future strategy stack:
[16:05:01.511] List of future strategies:
[16:05:01.511] 1. multicore:
[16:05:01.511]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.511]    - tweaked: FALSE
[16:05:01.511]    - call: plan(strategy)
[16:05:01.516] plan(): nbrOfWorkers() = 2
[16:05:01.517] result() for MulticoreFuture ...
[16:05:01.517] result() for MulticoreFuture ... done
[16:05:01.517] result() for MulticoreFuture ... done
[16:05:01.518] result() for MulticoreFuture ...
[16:05:01.518] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.519] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.519] Searching for globals...
[16:05:01.521] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.522] Searching for globals ... DONE
[16:05:01.522] Resolving globals: TRUE
[16:05:01.522] Resolving any globals that are futures ...
[16:05:01.522] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.522] Resolving any globals that are futures ... DONE
[16:05:01.523] Resolving futures part of globals (recursively) ...
[16:05:01.523] resolve() on list ...
[16:05:01.523]  recursive: 99
[16:05:01.523]  length: 1
[16:05:01.523]  elements: ‘x’
[16:05:01.524]  length: 0 (resolved future 1)
[16:05:01.524] resolve() on list ... DONE
[16:05:01.524] - globals: [1] ‘x’
[16:05:01.524] Resolving futures part of globals (recursively) ... DONE
[16:05:01.524] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.525] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.525] - globals: [1] ‘x’
[16:05:01.525] 
[16:05:01.525] getGlobalsAndPackages() ... DONE
[16:05:01.525] run() for ‘Future’ ...
[16:05:01.525] - state: ‘created’
[16:05:01.526] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:01.530] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:01.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:01.530]   - Field: ‘label’
[16:05:01.530]   - Field: ‘local’
[16:05:01.530]   - Field: ‘owner’
[16:05:01.530]   - Field: ‘envir’
[16:05:01.530]   - Field: ‘workers’
[16:05:01.531]   - Field: ‘packages’
[16:05:01.531]   - Field: ‘gc’
[16:05:01.531]   - Field: ‘job’
[16:05:01.531]   - Field: ‘conditions’
[16:05:01.531]   - Field: ‘expr’
[16:05:01.531]   - Field: ‘uuid’
[16:05:01.531]   - Field: ‘seed’
[16:05:01.531]   - Field: ‘version’
[16:05:01.532]   - Field: ‘result’
[16:05:01.532]   - Field: ‘asynchronous’
[16:05:01.532]   - Field: ‘calls’
[16:05:01.532]   - Field: ‘globals’
[16:05:01.532]   - Field: ‘stdout’
[16:05:01.532]   - Field: ‘earlySignal’
[16:05:01.532]   - Field: ‘lazy’
[16:05:01.532]   - Field: ‘state’
[16:05:01.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:01.533] - Launch lazy future ...
[16:05:01.533] Packages needed by the future expression (n = 0): <none>
[16:05:01.533] Packages needed by future strategies (n = 0): <none>
[16:05:01.534] {
[16:05:01.534]     {
[16:05:01.534]         {
[16:05:01.534]             ...future.startTime <- base::Sys.time()
[16:05:01.534]             {
[16:05:01.534]                 {
[16:05:01.534]                   {
[16:05:01.534]                     {
[16:05:01.534]                       base::local({
[16:05:01.534]                         has_future <- base::requireNamespace("future", 
[16:05:01.534]                           quietly = TRUE)
[16:05:01.534]                         if (has_future) {
[16:05:01.534]                           ns <- base::getNamespace("future")
[16:05:01.534]                           version <- ns[[".package"]][["version"]]
[16:05:01.534]                           if (is.null(version)) 
[16:05:01.534]                             version <- utils::packageVersion("future")
[16:05:01.534]                         }
[16:05:01.534]                         else {
[16:05:01.534]                           version <- NULL
[16:05:01.534]                         }
[16:05:01.534]                         if (!has_future || version < "1.8.0") {
[16:05:01.534]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.534]                             "", base::R.version$version.string), 
[16:05:01.534]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:01.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.534]                               "release", "version")], collapse = " "), 
[16:05:01.534]                             hostname = base::Sys.info()[["nodename"]])
[16:05:01.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.534]                             info)
[16:05:01.534]                           info <- base::paste(info, collapse = "; ")
[16:05:01.534]                           if (!has_future) {
[16:05:01.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.534]                               info)
[16:05:01.534]                           }
[16:05:01.534]                           else {
[16:05:01.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.534]                               info, version)
[16:05:01.534]                           }
[16:05:01.534]                           base::stop(msg)
[16:05:01.534]                         }
[16:05:01.534]                       })
[16:05:01.534]                     }
[16:05:01.534]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:01.534]                     base::options(mc.cores = 1L)
[16:05:01.534]                   }
[16:05:01.534]                   options(future.plan = NULL)
[16:05:01.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.534]                 }
[16:05:01.534]                 ...future.workdir <- getwd()
[16:05:01.534]             }
[16:05:01.534]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.534]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.534]         }
[16:05:01.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.534]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.534]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.534]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.534]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.534]             base::names(...future.oldOptions))
[16:05:01.534]     }
[16:05:01.534]     if (FALSE) {
[16:05:01.534]     }
[16:05:01.534]     else {
[16:05:01.534]         if (TRUE) {
[16:05:01.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.534]                 open = "w")
[16:05:01.534]         }
[16:05:01.534]         else {
[16:05:01.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.534]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.534]         }
[16:05:01.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.534]             base::sink(type = "output", split = FALSE)
[16:05:01.534]             base::close(...future.stdout)
[16:05:01.534]         }, add = TRUE)
[16:05:01.534]     }
[16:05:01.534]     ...future.frame <- base::sys.nframe()
[16:05:01.534]     ...future.conditions <- base::list()
[16:05:01.534]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.534]     if (FALSE) {
[16:05:01.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.534]     }
[16:05:01.534]     ...future.result <- base::tryCatch({
[16:05:01.534]         base::withCallingHandlers({
[16:05:01.534]             ...future.value <- base::withVisible(base::local({
[16:05:01.534]                 withCallingHandlers({
[16:05:01.534]                   {
[16:05:01.534]                     x$a <- 1
[16:05:01.534]                     x
[16:05:01.534]                   }
[16:05:01.534]                 }, immediateCondition = function(cond) {
[16:05:01.534]                   save_rds <- function (object, pathname, ...) 
[16:05:01.534]                   {
[16:05:01.534]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:01.534]                     if (file_test("-f", pathname_tmp)) {
[16:05:01.534]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.534]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:01.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.534]                         fi_tmp[["mtime"]])
[16:05:01.534]                     }
[16:05:01.534]                     tryCatch({
[16:05:01.534]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:01.534]                     }, error = function(ex) {
[16:05:01.534]                       msg <- conditionMessage(ex)
[16:05:01.534]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.534]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:01.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.534]                         fi_tmp[["mtime"]], msg)
[16:05:01.534]                       ex$message <- msg
[16:05:01.534]                       stop(ex)
[16:05:01.534]                     })
[16:05:01.534]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:01.534]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:01.534]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:01.534]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.534]                       fi <- file.info(pathname)
[16:05:01.534]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:01.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.534]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:01.534]                         fi[["size"]], fi[["mtime"]])
[16:05:01.534]                       stop(msg)
[16:05:01.534]                     }
[16:05:01.534]                     invisible(pathname)
[16:05:01.534]                   }
[16:05:01.534]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:01.534]                     rootPath = tempdir()) 
[16:05:01.534]                   {
[16:05:01.534]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:01.534]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:01.534]                       tmpdir = path, fileext = ".rds")
[16:05:01.534]                     save_rds(obj, file)
[16:05:01.534]                   }
[16:05:01.534]                   saveImmediateCondition(cond, path = "/tmp/Rtmpsnomsu/.future/immediateConditions")
[16:05:01.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.534]                   {
[16:05:01.534]                     inherits <- base::inherits
[16:05:01.534]                     invokeRestart <- base::invokeRestart
[16:05:01.534]                     is.null <- base::is.null
[16:05:01.534]                     muffled <- FALSE
[16:05:01.534]                     if (inherits(cond, "message")) {
[16:05:01.534]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:01.534]                       if (muffled) 
[16:05:01.534]                         invokeRestart("muffleMessage")
[16:05:01.534]                     }
[16:05:01.534]                     else if (inherits(cond, "warning")) {
[16:05:01.534]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:01.534]                       if (muffled) 
[16:05:01.534]                         invokeRestart("muffleWarning")
[16:05:01.534]                     }
[16:05:01.534]                     else if (inherits(cond, "condition")) {
[16:05:01.534]                       if (!is.null(pattern)) {
[16:05:01.534]                         computeRestarts <- base::computeRestarts
[16:05:01.534]                         grepl <- base::grepl
[16:05:01.534]                         restarts <- computeRestarts(cond)
[16:05:01.534]                         for (restart in restarts) {
[16:05:01.534]                           name <- restart$name
[16:05:01.534]                           if (is.null(name)) 
[16:05:01.534]                             next
[16:05:01.534]                           if (!grepl(pattern, name)) 
[16:05:01.534]                             next
[16:05:01.534]                           invokeRestart(restart)
[16:05:01.534]                           muffled <- TRUE
[16:05:01.534]                           break
[16:05:01.534]                         }
[16:05:01.534]                       }
[16:05:01.534]                     }
[16:05:01.534]                     invisible(muffled)
[16:05:01.534]                   }
[16:05:01.534]                   muffleCondition(cond)
[16:05:01.534]                 })
[16:05:01.534]             }))
[16:05:01.534]             future::FutureResult(value = ...future.value$value, 
[16:05:01.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.534]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.534]                     ...future.globalenv.names))
[16:05:01.534]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.534]         }, condition = base::local({
[16:05:01.534]             c <- base::c
[16:05:01.534]             inherits <- base::inherits
[16:05:01.534]             invokeRestart <- base::invokeRestart
[16:05:01.534]             length <- base::length
[16:05:01.534]             list <- base::list
[16:05:01.534]             seq.int <- base::seq.int
[16:05:01.534]             signalCondition <- base::signalCondition
[16:05:01.534]             sys.calls <- base::sys.calls
[16:05:01.534]             `[[` <- base::`[[`
[16:05:01.534]             `+` <- base::`+`
[16:05:01.534]             `<<-` <- base::`<<-`
[16:05:01.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.534]                   3L)]
[16:05:01.534]             }
[16:05:01.534]             function(cond) {
[16:05:01.534]                 is_error <- inherits(cond, "error")
[16:05:01.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.534]                   NULL)
[16:05:01.534]                 if (is_error) {
[16:05:01.534]                   sessionInformation <- function() {
[16:05:01.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.534]                       search = base::search(), system = base::Sys.info())
[16:05:01.534]                   }
[16:05:01.534]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.534]                     cond$call), session = sessionInformation(), 
[16:05:01.534]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.534]                   signalCondition(cond)
[16:05:01.534]                 }
[16:05:01.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.534]                 "immediateCondition"))) {
[16:05:01.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.534]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.534]                   if (TRUE && !signal) {
[16:05:01.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.534]                     {
[16:05:01.534]                       inherits <- base::inherits
[16:05:01.534]                       invokeRestart <- base::invokeRestart
[16:05:01.534]                       is.null <- base::is.null
[16:05:01.534]                       muffled <- FALSE
[16:05:01.534]                       if (inherits(cond, "message")) {
[16:05:01.534]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.534]                         if (muffled) 
[16:05:01.534]                           invokeRestart("muffleMessage")
[16:05:01.534]                       }
[16:05:01.534]                       else if (inherits(cond, "warning")) {
[16:05:01.534]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.534]                         if (muffled) 
[16:05:01.534]                           invokeRestart("muffleWarning")
[16:05:01.534]                       }
[16:05:01.534]                       else if (inherits(cond, "condition")) {
[16:05:01.534]                         if (!is.null(pattern)) {
[16:05:01.534]                           computeRestarts <- base::computeRestarts
[16:05:01.534]                           grepl <- base::grepl
[16:05:01.534]                           restarts <- computeRestarts(cond)
[16:05:01.534]                           for (restart in restarts) {
[16:05:01.534]                             name <- restart$name
[16:05:01.534]                             if (is.null(name)) 
[16:05:01.534]                               next
[16:05:01.534]                             if (!grepl(pattern, name)) 
[16:05:01.534]                               next
[16:05:01.534]                             invokeRestart(restart)
[16:05:01.534]                             muffled <- TRUE
[16:05:01.534]                             break
[16:05:01.534]                           }
[16:05:01.534]                         }
[16:05:01.534]                       }
[16:05:01.534]                       invisible(muffled)
[16:05:01.534]                     }
[16:05:01.534]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.534]                   }
[16:05:01.534]                 }
[16:05:01.534]                 else {
[16:05:01.534]                   if (TRUE) {
[16:05:01.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.534]                     {
[16:05:01.534]                       inherits <- base::inherits
[16:05:01.534]                       invokeRestart <- base::invokeRestart
[16:05:01.534]                       is.null <- base::is.null
[16:05:01.534]                       muffled <- FALSE
[16:05:01.534]                       if (inherits(cond, "message")) {
[16:05:01.534]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.534]                         if (muffled) 
[16:05:01.534]                           invokeRestart("muffleMessage")
[16:05:01.534]                       }
[16:05:01.534]                       else if (inherits(cond, "warning")) {
[16:05:01.534]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.534]                         if (muffled) 
[16:05:01.534]                           invokeRestart("muffleWarning")
[16:05:01.534]                       }
[16:05:01.534]                       else if (inherits(cond, "condition")) {
[16:05:01.534]                         if (!is.null(pattern)) {
[16:05:01.534]                           computeRestarts <- base::computeRestarts
[16:05:01.534]                           grepl <- base::grepl
[16:05:01.534]                           restarts <- computeRestarts(cond)
[16:05:01.534]                           for (restart in restarts) {
[16:05:01.534]                             name <- restart$name
[16:05:01.534]                             if (is.null(name)) 
[16:05:01.534]                               next
[16:05:01.534]                             if (!grepl(pattern, name)) 
[16:05:01.534]                               next
[16:05:01.534]                             invokeRestart(restart)
[16:05:01.534]                             muffled <- TRUE
[16:05:01.534]                             break
[16:05:01.534]                           }
[16:05:01.534]                         }
[16:05:01.534]                       }
[16:05:01.534]                       invisible(muffled)
[16:05:01.534]                     }
[16:05:01.534]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.534]                   }
[16:05:01.534]                 }
[16:05:01.534]             }
[16:05:01.534]         }))
[16:05:01.534]     }, error = function(ex) {
[16:05:01.534]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.534]                 ...future.rng), started = ...future.startTime, 
[16:05:01.534]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.534]             version = "1.8"), class = "FutureResult")
[16:05:01.534]     }, finally = {
[16:05:01.534]         if (!identical(...future.workdir, getwd())) 
[16:05:01.534]             setwd(...future.workdir)
[16:05:01.534]         {
[16:05:01.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.534]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.534]             }
[16:05:01.534]             base::options(...future.oldOptions)
[16:05:01.534]             if (.Platform$OS.type == "windows") {
[16:05:01.534]                 old_names <- names(...future.oldEnvVars)
[16:05:01.534]                 envs <- base::Sys.getenv()
[16:05:01.534]                 names <- names(envs)
[16:05:01.534]                 common <- intersect(names, old_names)
[16:05:01.534]                 added <- setdiff(names, old_names)
[16:05:01.534]                 removed <- setdiff(old_names, names)
[16:05:01.534]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.534]                   envs[common]]
[16:05:01.534]                 NAMES <- toupper(changed)
[16:05:01.534]                 args <- list()
[16:05:01.534]                 for (kk in seq_along(NAMES)) {
[16:05:01.534]                   name <- changed[[kk]]
[16:05:01.534]                   NAME <- NAMES[[kk]]
[16:05:01.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.534]                     next
[16:05:01.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.534]                 }
[16:05:01.534]                 NAMES <- toupper(added)
[16:05:01.534]                 for (kk in seq_along(NAMES)) {
[16:05:01.534]                   name <- added[[kk]]
[16:05:01.534]                   NAME <- NAMES[[kk]]
[16:05:01.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.534]                     next
[16:05:01.534]                   args[[name]] <- ""
[16:05:01.534]                 }
[16:05:01.534]                 NAMES <- toupper(removed)
[16:05:01.534]                 for (kk in seq_along(NAMES)) {
[16:05:01.534]                   name <- removed[[kk]]
[16:05:01.534]                   NAME <- NAMES[[kk]]
[16:05:01.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.534]                     next
[16:05:01.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.534]                 }
[16:05:01.534]                 if (length(args) > 0) 
[16:05:01.534]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.534]             }
[16:05:01.534]             else {
[16:05:01.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.534]             }
[16:05:01.534]             {
[16:05:01.534]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.534]                   0L) {
[16:05:01.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.534]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.534]                   base::options(opts)
[16:05:01.534]                 }
[16:05:01.534]                 {
[16:05:01.534]                   {
[16:05:01.534]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:01.534]                     NULL
[16:05:01.534]                   }
[16:05:01.534]                   options(future.plan = NULL)
[16:05:01.534]                   if (is.na(NA_character_)) 
[16:05:01.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.534]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:01.534]                     envir = parent.frame()) 
[16:05:01.534]                   {
[16:05:01.534]                     default_workers <- missing(workers)
[16:05:01.534]                     if (is.function(workers)) 
[16:05:01.534]                       workers <- workers()
[16:05:01.534]                     workers <- structure(as.integer(workers), 
[16:05:01.534]                       class = class(workers))
[16:05:01.534]                     stop_if_not(is.finite(workers), workers >= 
[16:05:01.534]                       1L)
[16:05:01.534]                     if ((workers == 1L && !inherits(workers, 
[16:05:01.534]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:01.534]                       if (default_workers) 
[16:05:01.534]                         supportsMulticore(warn = TRUE)
[16:05:01.534]                       return(sequential(..., envir = envir))
[16:05:01.534]                     }
[16:05:01.534]                     oopts <- options(mc.cores = workers)
[16:05:01.534]                     on.exit(options(oopts))
[16:05:01.534]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:01.534]                       envir = envir)
[16:05:01.534]                     if (!future$lazy) 
[16:05:01.534]                       future <- run(future)
[16:05:01.534]                     invisible(future)
[16:05:01.534]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.534]                 }
[16:05:01.534]             }
[16:05:01.534]         }
[16:05:01.534]     })
[16:05:01.534]     if (TRUE) {
[16:05:01.534]         base::sink(type = "output", split = FALSE)
[16:05:01.534]         if (TRUE) {
[16:05:01.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.534]         }
[16:05:01.534]         else {
[16:05:01.534]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.534]         }
[16:05:01.534]         base::close(...future.stdout)
[16:05:01.534]         ...future.stdout <- NULL
[16:05:01.534]     }
[16:05:01.534]     ...future.result$conditions <- ...future.conditions
[16:05:01.534]     ...future.result$finished <- base::Sys.time()
[16:05:01.534]     ...future.result
[16:05:01.534] }
[16:05:01.536] assign_globals() ...
[16:05:01.536] List of 1
[16:05:01.536]  $ x: list()
[16:05:01.536]  - attr(*, "where")=List of 1
[16:05:01.536]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.536]  - attr(*, "resolved")= logi TRUE
[16:05:01.536]  - attr(*, "total_size")= num 0
[16:05:01.536]  - attr(*, "already-done")= logi TRUE
[16:05:01.539] - copied ‘x’ to environment
[16:05:01.540] assign_globals() ... done
[16:05:01.540] requestCore(): workers = 2
[16:05:01.542] MulticoreFuture started
[16:05:01.542] - Launch lazy future ... done
[16:05:01.542] run() for ‘MulticoreFuture’ ... done
[16:05:01.543] result() for MulticoreFuture ...
[16:05:01.543] plan(): Setting new future strategy stack:
[16:05:01.543] List of future strategies:
[16:05:01.543] 1. sequential:
[16:05:01.543]    - args: function (..., envir = parent.frame())
[16:05:01.543]    - tweaked: FALSE
[16:05:01.543]    - call: NULL
[16:05:01.544] plan(): nbrOfWorkers() = 1
[16:05:01.546] plan(): Setting new future strategy stack:
[16:05:01.546] List of future strategies:
[16:05:01.546] 1. multicore:
[16:05:01.546]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.546]    - tweaked: FALSE
[16:05:01.546]    - call: plan(strategy)
[16:05:01.555] plan(): nbrOfWorkers() = 2
[16:05:01.556] result() for MulticoreFuture ...
[16:05:01.556] result() for MulticoreFuture ... done
[16:05:01.556] result() for MulticoreFuture ... done
[16:05:01.556] result() for MulticoreFuture ...
[16:05:01.556] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.557] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.557] Searching for globals...
[16:05:01.562] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.563] Searching for globals ... DONE
[16:05:01.563] Resolving globals: TRUE
[16:05:01.563] Resolving any globals that are futures ...
[16:05:01.563] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:01.563] Resolving any globals that are futures ... DONE
[16:05:01.564] Resolving futures part of globals (recursively) ...
[16:05:01.564] resolve() on list ...
[16:05:01.564]  recursive: 99
[16:05:01.564]  length: 1
[16:05:01.564]  elements: ‘x’
[16:05:01.565]  length: 0 (resolved future 1)
[16:05:01.565] resolve() on list ... DONE
[16:05:01.565] - globals: [1] ‘x’
[16:05:01.565] Resolving futures part of globals (recursively) ... DONE
[16:05:01.565] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.566] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.566] - globals: [1] ‘x’
[16:05:01.566] 
[16:05:01.566] getGlobalsAndPackages() ... DONE
[16:05:01.566] run() for ‘Future’ ...
[16:05:01.567] - state: ‘created’
[16:05:01.567] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:01.571] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:01.571] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:01.571]   - Field: ‘label’
[16:05:01.571]   - Field: ‘local’
[16:05:01.571]   - Field: ‘owner’
[16:05:01.571]   - Field: ‘envir’
[16:05:01.571]   - Field: ‘workers’
[16:05:01.572]   - Field: ‘packages’
[16:05:01.572]   - Field: ‘gc’
[16:05:01.572]   - Field: ‘job’
[16:05:01.572]   - Field: ‘conditions’
[16:05:01.572]   - Field: ‘expr’
[16:05:01.572]   - Field: ‘uuid’
[16:05:01.572]   - Field: ‘seed’
[16:05:01.572]   - Field: ‘version’
[16:05:01.573]   - Field: ‘result’
[16:05:01.573]   - Field: ‘asynchronous’
[16:05:01.573]   - Field: ‘calls’
[16:05:01.573]   - Field: ‘globals’
[16:05:01.573]   - Field: ‘stdout’
[16:05:01.573]   - Field: ‘earlySignal’
[16:05:01.573]   - Field: ‘lazy’
[16:05:01.573]   - Field: ‘state’
[16:05:01.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:01.574] - Launch lazy future ...
[16:05:01.574] Packages needed by the future expression (n = 0): <none>
[16:05:01.574] Packages needed by future strategies (n = 0): <none>
[16:05:01.575] {
[16:05:01.575]     {
[16:05:01.575]         {
[16:05:01.575]             ...future.startTime <- base::Sys.time()
[16:05:01.575]             {
[16:05:01.575]                 {
[16:05:01.575]                   {
[16:05:01.575]                     {
[16:05:01.575]                       base::local({
[16:05:01.575]                         has_future <- base::requireNamespace("future", 
[16:05:01.575]                           quietly = TRUE)
[16:05:01.575]                         if (has_future) {
[16:05:01.575]                           ns <- base::getNamespace("future")
[16:05:01.575]                           version <- ns[[".package"]][["version"]]
[16:05:01.575]                           if (is.null(version)) 
[16:05:01.575]                             version <- utils::packageVersion("future")
[16:05:01.575]                         }
[16:05:01.575]                         else {
[16:05:01.575]                           version <- NULL
[16:05:01.575]                         }
[16:05:01.575]                         if (!has_future || version < "1.8.0") {
[16:05:01.575]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.575]                             "", base::R.version$version.string), 
[16:05:01.575]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:01.575]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.575]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.575]                               "release", "version")], collapse = " "), 
[16:05:01.575]                             hostname = base::Sys.info()[["nodename"]])
[16:05:01.575]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.575]                             info)
[16:05:01.575]                           info <- base::paste(info, collapse = "; ")
[16:05:01.575]                           if (!has_future) {
[16:05:01.575]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.575]                               info)
[16:05:01.575]                           }
[16:05:01.575]                           else {
[16:05:01.575]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.575]                               info, version)
[16:05:01.575]                           }
[16:05:01.575]                           base::stop(msg)
[16:05:01.575]                         }
[16:05:01.575]                       })
[16:05:01.575]                     }
[16:05:01.575]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:01.575]                     base::options(mc.cores = 1L)
[16:05:01.575]                   }
[16:05:01.575]                   options(future.plan = NULL)
[16:05:01.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.575]                 }
[16:05:01.575]                 ...future.workdir <- getwd()
[16:05:01.575]             }
[16:05:01.575]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.575]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.575]         }
[16:05:01.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.575]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.575]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.575]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.575]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.575]             base::names(...future.oldOptions))
[16:05:01.575]     }
[16:05:01.575]     if (FALSE) {
[16:05:01.575]     }
[16:05:01.575]     else {
[16:05:01.575]         if (TRUE) {
[16:05:01.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.575]                 open = "w")
[16:05:01.575]         }
[16:05:01.575]         else {
[16:05:01.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.575]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.575]         }
[16:05:01.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.575]             base::sink(type = "output", split = FALSE)
[16:05:01.575]             base::close(...future.stdout)
[16:05:01.575]         }, add = TRUE)
[16:05:01.575]     }
[16:05:01.575]     ...future.frame <- base::sys.nframe()
[16:05:01.575]     ...future.conditions <- base::list()
[16:05:01.575]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.575]     if (FALSE) {
[16:05:01.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.575]     }
[16:05:01.575]     ...future.result <- base::tryCatch({
[16:05:01.575]         base::withCallingHandlers({
[16:05:01.575]             ...future.value <- base::withVisible(base::local({
[16:05:01.575]                 withCallingHandlers({
[16:05:01.575]                   {
[16:05:01.575]                     x$a <- 1
[16:05:01.575]                     x
[16:05:01.575]                   }
[16:05:01.575]                 }, immediateCondition = function(cond) {
[16:05:01.575]                   save_rds <- function (object, pathname, ...) 
[16:05:01.575]                   {
[16:05:01.575]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:01.575]                     if (file_test("-f", pathname_tmp)) {
[16:05:01.575]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.575]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:01.575]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.575]                         fi_tmp[["mtime"]])
[16:05:01.575]                     }
[16:05:01.575]                     tryCatch({
[16:05:01.575]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:01.575]                     }, error = function(ex) {
[16:05:01.575]                       msg <- conditionMessage(ex)
[16:05:01.575]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.575]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:01.575]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.575]                         fi_tmp[["mtime"]], msg)
[16:05:01.575]                       ex$message <- msg
[16:05:01.575]                       stop(ex)
[16:05:01.575]                     })
[16:05:01.575]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:01.575]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:01.575]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:01.575]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.575]                       fi <- file.info(pathname)
[16:05:01.575]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:01.575]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.575]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:01.575]                         fi[["size"]], fi[["mtime"]])
[16:05:01.575]                       stop(msg)
[16:05:01.575]                     }
[16:05:01.575]                     invisible(pathname)
[16:05:01.575]                   }
[16:05:01.575]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:01.575]                     rootPath = tempdir()) 
[16:05:01.575]                   {
[16:05:01.575]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:01.575]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:01.575]                       tmpdir = path, fileext = ".rds")
[16:05:01.575]                     save_rds(obj, file)
[16:05:01.575]                   }
[16:05:01.575]                   saveImmediateCondition(cond, path = "/tmp/Rtmpsnomsu/.future/immediateConditions")
[16:05:01.575]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.575]                   {
[16:05:01.575]                     inherits <- base::inherits
[16:05:01.575]                     invokeRestart <- base::invokeRestart
[16:05:01.575]                     is.null <- base::is.null
[16:05:01.575]                     muffled <- FALSE
[16:05:01.575]                     if (inherits(cond, "message")) {
[16:05:01.575]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:01.575]                       if (muffled) 
[16:05:01.575]                         invokeRestart("muffleMessage")
[16:05:01.575]                     }
[16:05:01.575]                     else if (inherits(cond, "warning")) {
[16:05:01.575]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:01.575]                       if (muffled) 
[16:05:01.575]                         invokeRestart("muffleWarning")
[16:05:01.575]                     }
[16:05:01.575]                     else if (inherits(cond, "condition")) {
[16:05:01.575]                       if (!is.null(pattern)) {
[16:05:01.575]                         computeRestarts <- base::computeRestarts
[16:05:01.575]                         grepl <- base::grepl
[16:05:01.575]                         restarts <- computeRestarts(cond)
[16:05:01.575]                         for (restart in restarts) {
[16:05:01.575]                           name <- restart$name
[16:05:01.575]                           if (is.null(name)) 
[16:05:01.575]                             next
[16:05:01.575]                           if (!grepl(pattern, name)) 
[16:05:01.575]                             next
[16:05:01.575]                           invokeRestart(restart)
[16:05:01.575]                           muffled <- TRUE
[16:05:01.575]                           break
[16:05:01.575]                         }
[16:05:01.575]                       }
[16:05:01.575]                     }
[16:05:01.575]                     invisible(muffled)
[16:05:01.575]                   }
[16:05:01.575]                   muffleCondition(cond)
[16:05:01.575]                 })
[16:05:01.575]             }))
[16:05:01.575]             future::FutureResult(value = ...future.value$value, 
[16:05:01.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.575]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.575]                     ...future.globalenv.names))
[16:05:01.575]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.575]         }, condition = base::local({
[16:05:01.575]             c <- base::c
[16:05:01.575]             inherits <- base::inherits
[16:05:01.575]             invokeRestart <- base::invokeRestart
[16:05:01.575]             length <- base::length
[16:05:01.575]             list <- base::list
[16:05:01.575]             seq.int <- base::seq.int
[16:05:01.575]             signalCondition <- base::signalCondition
[16:05:01.575]             sys.calls <- base::sys.calls
[16:05:01.575]             `[[` <- base::`[[`
[16:05:01.575]             `+` <- base::`+`
[16:05:01.575]             `<<-` <- base::`<<-`
[16:05:01.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.575]                   3L)]
[16:05:01.575]             }
[16:05:01.575]             function(cond) {
[16:05:01.575]                 is_error <- inherits(cond, "error")
[16:05:01.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.575]                   NULL)
[16:05:01.575]                 if (is_error) {
[16:05:01.575]                   sessionInformation <- function() {
[16:05:01.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.575]                       search = base::search(), system = base::Sys.info())
[16:05:01.575]                   }
[16:05:01.575]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.575]                     cond$call), session = sessionInformation(), 
[16:05:01.575]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.575]                   signalCondition(cond)
[16:05:01.575]                 }
[16:05:01.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.575]                 "immediateCondition"))) {
[16:05:01.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.575]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.575]                   if (TRUE && !signal) {
[16:05:01.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.575]                     {
[16:05:01.575]                       inherits <- base::inherits
[16:05:01.575]                       invokeRestart <- base::invokeRestart
[16:05:01.575]                       is.null <- base::is.null
[16:05:01.575]                       muffled <- FALSE
[16:05:01.575]                       if (inherits(cond, "message")) {
[16:05:01.575]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.575]                         if (muffled) 
[16:05:01.575]                           invokeRestart("muffleMessage")
[16:05:01.575]                       }
[16:05:01.575]                       else if (inherits(cond, "warning")) {
[16:05:01.575]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.575]                         if (muffled) 
[16:05:01.575]                           invokeRestart("muffleWarning")
[16:05:01.575]                       }
[16:05:01.575]                       else if (inherits(cond, "condition")) {
[16:05:01.575]                         if (!is.null(pattern)) {
[16:05:01.575]                           computeRestarts <- base::computeRestarts
[16:05:01.575]                           grepl <- base::grepl
[16:05:01.575]                           restarts <- computeRestarts(cond)
[16:05:01.575]                           for (restart in restarts) {
[16:05:01.575]                             name <- restart$name
[16:05:01.575]                             if (is.null(name)) 
[16:05:01.575]                               next
[16:05:01.575]                             if (!grepl(pattern, name)) 
[16:05:01.575]                               next
[16:05:01.575]                             invokeRestart(restart)
[16:05:01.575]                             muffled <- TRUE
[16:05:01.575]                             break
[16:05:01.575]                           }
[16:05:01.575]                         }
[16:05:01.575]                       }
[16:05:01.575]                       invisible(muffled)
[16:05:01.575]                     }
[16:05:01.575]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.575]                   }
[16:05:01.575]                 }
[16:05:01.575]                 else {
[16:05:01.575]                   if (TRUE) {
[16:05:01.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.575]                     {
[16:05:01.575]                       inherits <- base::inherits
[16:05:01.575]                       invokeRestart <- base::invokeRestart
[16:05:01.575]                       is.null <- base::is.null
[16:05:01.575]                       muffled <- FALSE
[16:05:01.575]                       if (inherits(cond, "message")) {
[16:05:01.575]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.575]                         if (muffled) 
[16:05:01.575]                           invokeRestart("muffleMessage")
[16:05:01.575]                       }
[16:05:01.575]                       else if (inherits(cond, "warning")) {
[16:05:01.575]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.575]                         if (muffled) 
[16:05:01.575]                           invokeRestart("muffleWarning")
[16:05:01.575]                       }
[16:05:01.575]                       else if (inherits(cond, "condition")) {
[16:05:01.575]                         if (!is.null(pattern)) {
[16:05:01.575]                           computeRestarts <- base::computeRestarts
[16:05:01.575]                           grepl <- base::grepl
[16:05:01.575]                           restarts <- computeRestarts(cond)
[16:05:01.575]                           for (restart in restarts) {
[16:05:01.575]                             name <- restart$name
[16:05:01.575]                             if (is.null(name)) 
[16:05:01.575]                               next
[16:05:01.575]                             if (!grepl(pattern, name)) 
[16:05:01.575]                               next
[16:05:01.575]                             invokeRestart(restart)
[16:05:01.575]                             muffled <- TRUE
[16:05:01.575]                             break
[16:05:01.575]                           }
[16:05:01.575]                         }
[16:05:01.575]                       }
[16:05:01.575]                       invisible(muffled)
[16:05:01.575]                     }
[16:05:01.575]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.575]                   }
[16:05:01.575]                 }
[16:05:01.575]             }
[16:05:01.575]         }))
[16:05:01.575]     }, error = function(ex) {
[16:05:01.575]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.575]                 ...future.rng), started = ...future.startTime, 
[16:05:01.575]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.575]             version = "1.8"), class = "FutureResult")
[16:05:01.575]     }, finally = {
[16:05:01.575]         if (!identical(...future.workdir, getwd())) 
[16:05:01.575]             setwd(...future.workdir)
[16:05:01.575]         {
[16:05:01.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.575]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.575]             }
[16:05:01.575]             base::options(...future.oldOptions)
[16:05:01.575]             if (.Platform$OS.type == "windows") {
[16:05:01.575]                 old_names <- names(...future.oldEnvVars)
[16:05:01.575]                 envs <- base::Sys.getenv()
[16:05:01.575]                 names <- names(envs)
[16:05:01.575]                 common <- intersect(names, old_names)
[16:05:01.575]                 added <- setdiff(names, old_names)
[16:05:01.575]                 removed <- setdiff(old_names, names)
[16:05:01.575]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.575]                   envs[common]]
[16:05:01.575]                 NAMES <- toupper(changed)
[16:05:01.575]                 args <- list()
[16:05:01.575]                 for (kk in seq_along(NAMES)) {
[16:05:01.575]                   name <- changed[[kk]]
[16:05:01.575]                   NAME <- NAMES[[kk]]
[16:05:01.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.575]                     next
[16:05:01.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.575]                 }
[16:05:01.575]                 NAMES <- toupper(added)
[16:05:01.575]                 for (kk in seq_along(NAMES)) {
[16:05:01.575]                   name <- added[[kk]]
[16:05:01.575]                   NAME <- NAMES[[kk]]
[16:05:01.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.575]                     next
[16:05:01.575]                   args[[name]] <- ""
[16:05:01.575]                 }
[16:05:01.575]                 NAMES <- toupper(removed)
[16:05:01.575]                 for (kk in seq_along(NAMES)) {
[16:05:01.575]                   name <- removed[[kk]]
[16:05:01.575]                   NAME <- NAMES[[kk]]
[16:05:01.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.575]                     next
[16:05:01.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.575]                 }
[16:05:01.575]                 if (length(args) > 0) 
[16:05:01.575]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.575]             }
[16:05:01.575]             else {
[16:05:01.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.575]             }
[16:05:01.575]             {
[16:05:01.575]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.575]                   0L) {
[16:05:01.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.575]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.575]                   base::options(opts)
[16:05:01.575]                 }
[16:05:01.575]                 {
[16:05:01.575]                   {
[16:05:01.575]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:01.575]                     NULL
[16:05:01.575]                   }
[16:05:01.575]                   options(future.plan = NULL)
[16:05:01.575]                   if (is.na(NA_character_)) 
[16:05:01.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.575]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:01.575]                     envir = parent.frame()) 
[16:05:01.575]                   {
[16:05:01.575]                     default_workers <- missing(workers)
[16:05:01.575]                     if (is.function(workers)) 
[16:05:01.575]                       workers <- workers()
[16:05:01.575]                     workers <- structure(as.integer(workers), 
[16:05:01.575]                       class = class(workers))
[16:05:01.575]                     stop_if_not(is.finite(workers), workers >= 
[16:05:01.575]                       1L)
[16:05:01.575]                     if ((workers == 1L && !inherits(workers, 
[16:05:01.575]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:01.575]                       if (default_workers) 
[16:05:01.575]                         supportsMulticore(warn = TRUE)
[16:05:01.575]                       return(sequential(..., envir = envir))
[16:05:01.575]                     }
[16:05:01.575]                     oopts <- options(mc.cores = workers)
[16:05:01.575]                     on.exit(options(oopts))
[16:05:01.575]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:01.575]                       envir = envir)
[16:05:01.575]                     if (!future$lazy) 
[16:05:01.575]                       future <- run(future)
[16:05:01.575]                     invisible(future)
[16:05:01.575]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.575]                 }
[16:05:01.575]             }
[16:05:01.575]         }
[16:05:01.575]     })
[16:05:01.575]     if (TRUE) {
[16:05:01.575]         base::sink(type = "output", split = FALSE)
[16:05:01.575]         if (TRUE) {
[16:05:01.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.575]         }
[16:05:01.575]         else {
[16:05:01.575]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.575]         }
[16:05:01.575]         base::close(...future.stdout)
[16:05:01.575]         ...future.stdout <- NULL
[16:05:01.575]     }
[16:05:01.575]     ...future.result$conditions <- ...future.conditions
[16:05:01.575]     ...future.result$finished <- base::Sys.time()
[16:05:01.575]     ...future.result
[16:05:01.575] }
[16:05:01.577] assign_globals() ...
[16:05:01.577] List of 1
[16:05:01.577]  $ x: list()
[16:05:01.577]  - attr(*, "where")=List of 1
[16:05:01.577]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.577]  - attr(*, "resolved")= logi TRUE
[16:05:01.577]  - attr(*, "total_size")= num 0
[16:05:01.577]  - attr(*, "already-done")= logi TRUE
[16:05:01.580] - copied ‘x’ to environment
[16:05:01.580] assign_globals() ... done
[16:05:01.581] requestCore(): workers = 2
[16:05:01.582] MulticoreFuture started
[16:05:01.583] - Launch lazy future ... done
[16:05:01.583] run() for ‘MulticoreFuture’ ... done
[16:05:01.583] result() for MulticoreFuture ...
[16:05:01.584] plan(): Setting new future strategy stack:
[16:05:01.584] List of future strategies:
[16:05:01.584] 1. sequential:
[16:05:01.584]    - args: function (..., envir = parent.frame())
[16:05:01.584]    - tweaked: FALSE
[16:05:01.584]    - call: NULL
[16:05:01.585] plan(): nbrOfWorkers() = 1
[16:05:01.587] plan(): Setting new future strategy stack:
[16:05:01.587] List of future strategies:
[16:05:01.587] 1. multicore:
[16:05:01.587]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.587]    - tweaked: FALSE
[16:05:01.587]    - call: plan(strategy)
[16:05:01.592] plan(): nbrOfWorkers() = 2
[16:05:01.593] result() for MulticoreFuture ...
[16:05:01.593] result() for MulticoreFuture ... done
[16:05:01.593] result() for MulticoreFuture ... done
[16:05:01.593] result() for MulticoreFuture ...
[16:05:01.593] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.594] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.594] Searching for globals...
[16:05:01.598] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[16:05:01.598] Searching for globals ... DONE
[16:05:01.598] Resolving globals: TRUE
[16:05:01.598] Resolving any globals that are futures ...
[16:05:01.598] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[16:05:01.598] Resolving any globals that are futures ... DONE
[16:05:01.599] 
[16:05:01.599] 
[16:05:01.599] getGlobalsAndPackages() ... DONE
[16:05:01.599] run() for ‘Future’ ...
[16:05:01.600] - state: ‘created’
[16:05:01.600] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:01.604] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:01.604] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:01.604]   - Field: ‘label’
[16:05:01.604]   - Field: ‘local’
[16:05:01.604]   - Field: ‘owner’
[16:05:01.605]   - Field: ‘envir’
[16:05:01.605]   - Field: ‘workers’
[16:05:01.605]   - Field: ‘packages’
[16:05:01.605]   - Field: ‘gc’
[16:05:01.605]   - Field: ‘job’
[16:05:01.605]   - Field: ‘conditions’
[16:05:01.605]   - Field: ‘expr’
[16:05:01.605]   - Field: ‘uuid’
[16:05:01.606]   - Field: ‘seed’
[16:05:01.606]   - Field: ‘version’
[16:05:01.606]   - Field: ‘result’
[16:05:01.606]   - Field: ‘asynchronous’
[16:05:01.606]   - Field: ‘calls’
[16:05:01.606]   - Field: ‘globals’
[16:05:01.606]   - Field: ‘stdout’
[16:05:01.606]   - Field: ‘earlySignal’
[16:05:01.606]   - Field: ‘lazy’
[16:05:01.607]   - Field: ‘state’
[16:05:01.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:01.607] - Launch lazy future ...
[16:05:01.609] Packages needed by the future expression (n = 0): <none>
[16:05:01.609] Packages needed by future strategies (n = 0): <none>
[16:05:01.610] {
[16:05:01.610]     {
[16:05:01.610]         {
[16:05:01.610]             ...future.startTime <- base::Sys.time()
[16:05:01.610]             {
[16:05:01.610]                 {
[16:05:01.610]                   {
[16:05:01.610]                     {
[16:05:01.610]                       base::local({
[16:05:01.610]                         has_future <- base::requireNamespace("future", 
[16:05:01.610]                           quietly = TRUE)
[16:05:01.610]                         if (has_future) {
[16:05:01.610]                           ns <- base::getNamespace("future")
[16:05:01.610]                           version <- ns[[".package"]][["version"]]
[16:05:01.610]                           if (is.null(version)) 
[16:05:01.610]                             version <- utils::packageVersion("future")
[16:05:01.610]                         }
[16:05:01.610]                         else {
[16:05:01.610]                           version <- NULL
[16:05:01.610]                         }
[16:05:01.610]                         if (!has_future || version < "1.8.0") {
[16:05:01.610]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.610]                             "", base::R.version$version.string), 
[16:05:01.610]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:01.610]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.610]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.610]                               "release", "version")], collapse = " "), 
[16:05:01.610]                             hostname = base::Sys.info()[["nodename"]])
[16:05:01.610]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.610]                             info)
[16:05:01.610]                           info <- base::paste(info, collapse = "; ")
[16:05:01.610]                           if (!has_future) {
[16:05:01.610]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.610]                               info)
[16:05:01.610]                           }
[16:05:01.610]                           else {
[16:05:01.610]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.610]                               info, version)
[16:05:01.610]                           }
[16:05:01.610]                           base::stop(msg)
[16:05:01.610]                         }
[16:05:01.610]                       })
[16:05:01.610]                     }
[16:05:01.610]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:01.610]                     base::options(mc.cores = 1L)
[16:05:01.610]                   }
[16:05:01.610]                   options(future.plan = NULL)
[16:05:01.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.610]                 }
[16:05:01.610]                 ...future.workdir <- getwd()
[16:05:01.610]             }
[16:05:01.610]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.610]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.610]         }
[16:05:01.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.610]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.610]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.610]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.610]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.610]             base::names(...future.oldOptions))
[16:05:01.610]     }
[16:05:01.610]     if (FALSE) {
[16:05:01.610]     }
[16:05:01.610]     else {
[16:05:01.610]         if (TRUE) {
[16:05:01.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.610]                 open = "w")
[16:05:01.610]         }
[16:05:01.610]         else {
[16:05:01.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.610]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.610]         }
[16:05:01.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.610]             base::sink(type = "output", split = FALSE)
[16:05:01.610]             base::close(...future.stdout)
[16:05:01.610]         }, add = TRUE)
[16:05:01.610]     }
[16:05:01.610]     ...future.frame <- base::sys.nframe()
[16:05:01.610]     ...future.conditions <- base::list()
[16:05:01.610]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.610]     if (FALSE) {
[16:05:01.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.610]     }
[16:05:01.610]     ...future.result <- base::tryCatch({
[16:05:01.610]         base::withCallingHandlers({
[16:05:01.610]             ...future.value <- base::withVisible(base::local({
[16:05:01.610]                 withCallingHandlers({
[16:05:01.610]                   {
[16:05:01.610]                     x <- list(b = 2)
[16:05:01.610]                     x$a <- 1
[16:05:01.610]                     x
[16:05:01.610]                   }
[16:05:01.610]                 }, immediateCondition = function(cond) {
[16:05:01.610]                   save_rds <- function (object, pathname, ...) 
[16:05:01.610]                   {
[16:05:01.610]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:01.610]                     if (file_test("-f", pathname_tmp)) {
[16:05:01.610]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.610]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:01.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.610]                         fi_tmp[["mtime"]])
[16:05:01.610]                     }
[16:05:01.610]                     tryCatch({
[16:05:01.610]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:01.610]                     }, error = function(ex) {
[16:05:01.610]                       msg <- conditionMessage(ex)
[16:05:01.610]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.610]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:01.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.610]                         fi_tmp[["mtime"]], msg)
[16:05:01.610]                       ex$message <- msg
[16:05:01.610]                       stop(ex)
[16:05:01.610]                     })
[16:05:01.610]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:01.610]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:01.610]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:01.610]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.610]                       fi <- file.info(pathname)
[16:05:01.610]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:01.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.610]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:01.610]                         fi[["size"]], fi[["mtime"]])
[16:05:01.610]                       stop(msg)
[16:05:01.610]                     }
[16:05:01.610]                     invisible(pathname)
[16:05:01.610]                   }
[16:05:01.610]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:01.610]                     rootPath = tempdir()) 
[16:05:01.610]                   {
[16:05:01.610]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:01.610]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:01.610]                       tmpdir = path, fileext = ".rds")
[16:05:01.610]                     save_rds(obj, file)
[16:05:01.610]                   }
[16:05:01.610]                   saveImmediateCondition(cond, path = "/tmp/Rtmpsnomsu/.future/immediateConditions")
[16:05:01.610]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.610]                   {
[16:05:01.610]                     inherits <- base::inherits
[16:05:01.610]                     invokeRestart <- base::invokeRestart
[16:05:01.610]                     is.null <- base::is.null
[16:05:01.610]                     muffled <- FALSE
[16:05:01.610]                     if (inherits(cond, "message")) {
[16:05:01.610]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:01.610]                       if (muffled) 
[16:05:01.610]                         invokeRestart("muffleMessage")
[16:05:01.610]                     }
[16:05:01.610]                     else if (inherits(cond, "warning")) {
[16:05:01.610]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:01.610]                       if (muffled) 
[16:05:01.610]                         invokeRestart("muffleWarning")
[16:05:01.610]                     }
[16:05:01.610]                     else if (inherits(cond, "condition")) {
[16:05:01.610]                       if (!is.null(pattern)) {
[16:05:01.610]                         computeRestarts <- base::computeRestarts
[16:05:01.610]                         grepl <- base::grepl
[16:05:01.610]                         restarts <- computeRestarts(cond)
[16:05:01.610]                         for (restart in restarts) {
[16:05:01.610]                           name <- restart$name
[16:05:01.610]                           if (is.null(name)) 
[16:05:01.610]                             next
[16:05:01.610]                           if (!grepl(pattern, name)) 
[16:05:01.610]                             next
[16:05:01.610]                           invokeRestart(restart)
[16:05:01.610]                           muffled <- TRUE
[16:05:01.610]                           break
[16:05:01.610]                         }
[16:05:01.610]                       }
[16:05:01.610]                     }
[16:05:01.610]                     invisible(muffled)
[16:05:01.610]                   }
[16:05:01.610]                   muffleCondition(cond)
[16:05:01.610]                 })
[16:05:01.610]             }))
[16:05:01.610]             future::FutureResult(value = ...future.value$value, 
[16:05:01.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.610]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.610]                     ...future.globalenv.names))
[16:05:01.610]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.610]         }, condition = base::local({
[16:05:01.610]             c <- base::c
[16:05:01.610]             inherits <- base::inherits
[16:05:01.610]             invokeRestart <- base::invokeRestart
[16:05:01.610]             length <- base::length
[16:05:01.610]             list <- base::list
[16:05:01.610]             seq.int <- base::seq.int
[16:05:01.610]             signalCondition <- base::signalCondition
[16:05:01.610]             sys.calls <- base::sys.calls
[16:05:01.610]             `[[` <- base::`[[`
[16:05:01.610]             `+` <- base::`+`
[16:05:01.610]             `<<-` <- base::`<<-`
[16:05:01.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.610]                   3L)]
[16:05:01.610]             }
[16:05:01.610]             function(cond) {
[16:05:01.610]                 is_error <- inherits(cond, "error")
[16:05:01.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.610]                   NULL)
[16:05:01.610]                 if (is_error) {
[16:05:01.610]                   sessionInformation <- function() {
[16:05:01.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.610]                       search = base::search(), system = base::Sys.info())
[16:05:01.610]                   }
[16:05:01.610]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.610]                     cond$call), session = sessionInformation(), 
[16:05:01.610]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.610]                   signalCondition(cond)
[16:05:01.610]                 }
[16:05:01.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.610]                 "immediateCondition"))) {
[16:05:01.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.610]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.610]                   if (TRUE && !signal) {
[16:05:01.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.610]                     {
[16:05:01.610]                       inherits <- base::inherits
[16:05:01.610]                       invokeRestart <- base::invokeRestart
[16:05:01.610]                       is.null <- base::is.null
[16:05:01.610]                       muffled <- FALSE
[16:05:01.610]                       if (inherits(cond, "message")) {
[16:05:01.610]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.610]                         if (muffled) 
[16:05:01.610]                           invokeRestart("muffleMessage")
[16:05:01.610]                       }
[16:05:01.610]                       else if (inherits(cond, "warning")) {
[16:05:01.610]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.610]                         if (muffled) 
[16:05:01.610]                           invokeRestart("muffleWarning")
[16:05:01.610]                       }
[16:05:01.610]                       else if (inherits(cond, "condition")) {
[16:05:01.610]                         if (!is.null(pattern)) {
[16:05:01.610]                           computeRestarts <- base::computeRestarts
[16:05:01.610]                           grepl <- base::grepl
[16:05:01.610]                           restarts <- computeRestarts(cond)
[16:05:01.610]                           for (restart in restarts) {
[16:05:01.610]                             name <- restart$name
[16:05:01.610]                             if (is.null(name)) 
[16:05:01.610]                               next
[16:05:01.610]                             if (!grepl(pattern, name)) 
[16:05:01.610]                               next
[16:05:01.610]                             invokeRestart(restart)
[16:05:01.610]                             muffled <- TRUE
[16:05:01.610]                             break
[16:05:01.610]                           }
[16:05:01.610]                         }
[16:05:01.610]                       }
[16:05:01.610]                       invisible(muffled)
[16:05:01.610]                     }
[16:05:01.610]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.610]                   }
[16:05:01.610]                 }
[16:05:01.610]                 else {
[16:05:01.610]                   if (TRUE) {
[16:05:01.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.610]                     {
[16:05:01.610]                       inherits <- base::inherits
[16:05:01.610]                       invokeRestart <- base::invokeRestart
[16:05:01.610]                       is.null <- base::is.null
[16:05:01.610]                       muffled <- FALSE
[16:05:01.610]                       if (inherits(cond, "message")) {
[16:05:01.610]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.610]                         if (muffled) 
[16:05:01.610]                           invokeRestart("muffleMessage")
[16:05:01.610]                       }
[16:05:01.610]                       else if (inherits(cond, "warning")) {
[16:05:01.610]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.610]                         if (muffled) 
[16:05:01.610]                           invokeRestart("muffleWarning")
[16:05:01.610]                       }
[16:05:01.610]                       else if (inherits(cond, "condition")) {
[16:05:01.610]                         if (!is.null(pattern)) {
[16:05:01.610]                           computeRestarts <- base::computeRestarts
[16:05:01.610]                           grepl <- base::grepl
[16:05:01.610]                           restarts <- computeRestarts(cond)
[16:05:01.610]                           for (restart in restarts) {
[16:05:01.610]                             name <- restart$name
[16:05:01.610]                             if (is.null(name)) 
[16:05:01.610]                               next
[16:05:01.610]                             if (!grepl(pattern, name)) 
[16:05:01.610]                               next
[16:05:01.610]                             invokeRestart(restart)
[16:05:01.610]                             muffled <- TRUE
[16:05:01.610]                             break
[16:05:01.610]                           }
[16:05:01.610]                         }
[16:05:01.610]                       }
[16:05:01.610]                       invisible(muffled)
[16:05:01.610]                     }
[16:05:01.610]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.610]                   }
[16:05:01.610]                 }
[16:05:01.610]             }
[16:05:01.610]         }))
[16:05:01.610]     }, error = function(ex) {
[16:05:01.610]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.610]                 ...future.rng), started = ...future.startTime, 
[16:05:01.610]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.610]             version = "1.8"), class = "FutureResult")
[16:05:01.610]     }, finally = {
[16:05:01.610]         if (!identical(...future.workdir, getwd())) 
[16:05:01.610]             setwd(...future.workdir)
[16:05:01.610]         {
[16:05:01.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.610]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.610]             }
[16:05:01.610]             base::options(...future.oldOptions)
[16:05:01.610]             if (.Platform$OS.type == "windows") {
[16:05:01.610]                 old_names <- names(...future.oldEnvVars)
[16:05:01.610]                 envs <- base::Sys.getenv()
[16:05:01.610]                 names <- names(envs)
[16:05:01.610]                 common <- intersect(names, old_names)
[16:05:01.610]                 added <- setdiff(names, old_names)
[16:05:01.610]                 removed <- setdiff(old_names, names)
[16:05:01.610]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.610]                   envs[common]]
[16:05:01.610]                 NAMES <- toupper(changed)
[16:05:01.610]                 args <- list()
[16:05:01.610]                 for (kk in seq_along(NAMES)) {
[16:05:01.610]                   name <- changed[[kk]]
[16:05:01.610]                   NAME <- NAMES[[kk]]
[16:05:01.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.610]                     next
[16:05:01.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.610]                 }
[16:05:01.610]                 NAMES <- toupper(added)
[16:05:01.610]                 for (kk in seq_along(NAMES)) {
[16:05:01.610]                   name <- added[[kk]]
[16:05:01.610]                   NAME <- NAMES[[kk]]
[16:05:01.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.610]                     next
[16:05:01.610]                   args[[name]] <- ""
[16:05:01.610]                 }
[16:05:01.610]                 NAMES <- toupper(removed)
[16:05:01.610]                 for (kk in seq_along(NAMES)) {
[16:05:01.610]                   name <- removed[[kk]]
[16:05:01.610]                   NAME <- NAMES[[kk]]
[16:05:01.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.610]                     next
[16:05:01.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.610]                 }
[16:05:01.610]                 if (length(args) > 0) 
[16:05:01.610]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.610]             }
[16:05:01.610]             else {
[16:05:01.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.610]             }
[16:05:01.610]             {
[16:05:01.610]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.610]                   0L) {
[16:05:01.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.610]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.610]                   base::options(opts)
[16:05:01.610]                 }
[16:05:01.610]                 {
[16:05:01.610]                   {
[16:05:01.610]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:01.610]                     NULL
[16:05:01.610]                   }
[16:05:01.610]                   options(future.plan = NULL)
[16:05:01.610]                   if (is.na(NA_character_)) 
[16:05:01.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.610]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:01.610]                     envir = parent.frame()) 
[16:05:01.610]                   {
[16:05:01.610]                     default_workers <- missing(workers)
[16:05:01.610]                     if (is.function(workers)) 
[16:05:01.610]                       workers <- workers()
[16:05:01.610]                     workers <- structure(as.integer(workers), 
[16:05:01.610]                       class = class(workers))
[16:05:01.610]                     stop_if_not(is.finite(workers), workers >= 
[16:05:01.610]                       1L)
[16:05:01.610]                     if ((workers == 1L && !inherits(workers, 
[16:05:01.610]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:01.610]                       if (default_workers) 
[16:05:01.610]                         supportsMulticore(warn = TRUE)
[16:05:01.610]                       return(sequential(..., envir = envir))
[16:05:01.610]                     }
[16:05:01.610]                     oopts <- options(mc.cores = workers)
[16:05:01.610]                     on.exit(options(oopts))
[16:05:01.610]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:01.610]                       envir = envir)
[16:05:01.610]                     if (!future$lazy) 
[16:05:01.610]                       future <- run(future)
[16:05:01.610]                     invisible(future)
[16:05:01.610]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.610]                 }
[16:05:01.610]             }
[16:05:01.610]         }
[16:05:01.610]     })
[16:05:01.610]     if (TRUE) {
[16:05:01.610]         base::sink(type = "output", split = FALSE)
[16:05:01.610]         if (TRUE) {
[16:05:01.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.610]         }
[16:05:01.610]         else {
[16:05:01.610]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.610]         }
[16:05:01.610]         base::close(...future.stdout)
[16:05:01.610]         ...future.stdout <- NULL
[16:05:01.610]     }
[16:05:01.610]     ...future.result$conditions <- ...future.conditions
[16:05:01.610]     ...future.result$finished <- base::Sys.time()
[16:05:01.610]     ...future.result
[16:05:01.610] }
[16:05:01.613] requestCore(): workers = 2
[16:05:01.615] MulticoreFuture started
[16:05:01.615] - Launch lazy future ... done
[16:05:01.615] run() for ‘MulticoreFuture’ ... done
[16:05:01.616] plan(): Setting new future strategy stack:
[16:05:01.616] result() for MulticoreFuture ...
[16:05:01.616] List of future strategies:
[16:05:01.616] 1. sequential:
[16:05:01.616]    - args: function (..., envir = parent.frame())
[16:05:01.616]    - tweaked: FALSE
[16:05:01.616]    - call: NULL
[16:05:01.617] plan(): nbrOfWorkers() = 1
[16:05:01.619] plan(): Setting new future strategy stack:
[16:05:01.619] List of future strategies:
[16:05:01.619] 1. multicore:
[16:05:01.619]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.619]    - tweaked: FALSE
[16:05:01.619]    - call: plan(strategy)
[16:05:01.625] plan(): nbrOfWorkers() = 2
[16:05:01.626] result() for MulticoreFuture ...
[16:05:01.626] result() for MulticoreFuture ... done
[16:05:01.626] result() for MulticoreFuture ... done
[16:05:01.626] result() for MulticoreFuture ...
[16:05:01.626] result() for MulticoreFuture ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.627] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.627] Searching for globals...
[16:05:01.630] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:01.630] Searching for globals ... DONE
[16:05:01.630] Resolving globals: TRUE
[16:05:01.630] Resolving any globals that are futures ...
[16:05:01.630] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:01.631] Resolving any globals that are futures ... DONE
[16:05:01.631] Resolving futures part of globals (recursively) ...
[16:05:01.632] resolve() on list ...
[16:05:01.632]  recursive: 99
[16:05:01.632]  length: 1
[16:05:01.632]  elements: ‘x’
[16:05:01.632]  length: 0 (resolved future 1)
[16:05:01.632] resolve() on list ... DONE
[16:05:01.632] - globals: [1] ‘x’
[16:05:01.632] Resolving futures part of globals (recursively) ... DONE
[16:05:01.633] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.633] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.633] - globals: [1] ‘x’
[16:05:01.633] 
[16:05:01.633] getGlobalsAndPackages() ... DONE
[16:05:01.634] run() for ‘Future’ ...
[16:05:01.634] - state: ‘created’
[16:05:01.634] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:01.638] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:01.638] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:01.638]   - Field: ‘label’
[16:05:01.638]   - Field: ‘local’
[16:05:01.639]   - Field: ‘owner’
[16:05:01.639]   - Field: ‘envir’
[16:05:01.639]   - Field: ‘workers’
[16:05:01.639]   - Field: ‘packages’
[16:05:01.639]   - Field: ‘gc’
[16:05:01.639]   - Field: ‘job’
[16:05:01.639]   - Field: ‘conditions’
[16:05:01.639]   - Field: ‘expr’
[16:05:01.640]   - Field: ‘uuid’
[16:05:01.640]   - Field: ‘seed’
[16:05:01.640]   - Field: ‘version’
[16:05:01.640]   - Field: ‘result’
[16:05:01.640]   - Field: ‘asynchronous’
[16:05:01.640]   - Field: ‘calls’
[16:05:01.640]   - Field: ‘globals’
[16:05:01.640]   - Field: ‘stdout’
[16:05:01.640]   - Field: ‘earlySignal’
[16:05:01.641]   - Field: ‘lazy’
[16:05:01.641]   - Field: ‘state’
[16:05:01.641] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:01.641] - Launch lazy future ...
[16:05:01.641] Packages needed by the future expression (n = 0): <none>
[16:05:01.641] Packages needed by future strategies (n = 0): <none>
[16:05:01.642] {
[16:05:01.642]     {
[16:05:01.642]         {
[16:05:01.642]             ...future.startTime <- base::Sys.time()
[16:05:01.642]             {
[16:05:01.642]                 {
[16:05:01.642]                   {
[16:05:01.642]                     {
[16:05:01.642]                       base::local({
[16:05:01.642]                         has_future <- base::requireNamespace("future", 
[16:05:01.642]                           quietly = TRUE)
[16:05:01.642]                         if (has_future) {
[16:05:01.642]                           ns <- base::getNamespace("future")
[16:05:01.642]                           version <- ns[[".package"]][["version"]]
[16:05:01.642]                           if (is.null(version)) 
[16:05:01.642]                             version <- utils::packageVersion("future")
[16:05:01.642]                         }
[16:05:01.642]                         else {
[16:05:01.642]                           version <- NULL
[16:05:01.642]                         }
[16:05:01.642]                         if (!has_future || version < "1.8.0") {
[16:05:01.642]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.642]                             "", base::R.version$version.string), 
[16:05:01.642]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:01.642]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.642]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.642]                               "release", "version")], collapse = " "), 
[16:05:01.642]                             hostname = base::Sys.info()[["nodename"]])
[16:05:01.642]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.642]                             info)
[16:05:01.642]                           info <- base::paste(info, collapse = "; ")
[16:05:01.642]                           if (!has_future) {
[16:05:01.642]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.642]                               info)
[16:05:01.642]                           }
[16:05:01.642]                           else {
[16:05:01.642]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.642]                               info, version)
[16:05:01.642]                           }
[16:05:01.642]                           base::stop(msg)
[16:05:01.642]                         }
[16:05:01.642]                       })
[16:05:01.642]                     }
[16:05:01.642]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:01.642]                     base::options(mc.cores = 1L)
[16:05:01.642]                   }
[16:05:01.642]                   options(future.plan = NULL)
[16:05:01.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.642]                 }
[16:05:01.642]                 ...future.workdir <- getwd()
[16:05:01.642]             }
[16:05:01.642]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.642]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.642]         }
[16:05:01.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.642]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.642]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.642]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.642]             base::names(...future.oldOptions))
[16:05:01.642]     }
[16:05:01.642]     if (FALSE) {
[16:05:01.642]     }
[16:05:01.642]     else {
[16:05:01.642]         if (TRUE) {
[16:05:01.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.642]                 open = "w")
[16:05:01.642]         }
[16:05:01.642]         else {
[16:05:01.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.642]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.642]         }
[16:05:01.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.642]             base::sink(type = "output", split = FALSE)
[16:05:01.642]             base::close(...future.stdout)
[16:05:01.642]         }, add = TRUE)
[16:05:01.642]     }
[16:05:01.642]     ...future.frame <- base::sys.nframe()
[16:05:01.642]     ...future.conditions <- base::list()
[16:05:01.642]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.642]     if (FALSE) {
[16:05:01.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.642]     }
[16:05:01.642]     ...future.result <- base::tryCatch({
[16:05:01.642]         base::withCallingHandlers({
[16:05:01.642]             ...future.value <- base::withVisible(base::local({
[16:05:01.642]                 withCallingHandlers({
[16:05:01.642]                   {
[16:05:01.642]                     x[["a"]] <- 1
[16:05:01.642]                     x
[16:05:01.642]                   }
[16:05:01.642]                 }, immediateCondition = function(cond) {
[16:05:01.642]                   save_rds <- function (object, pathname, ...) 
[16:05:01.642]                   {
[16:05:01.642]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:01.642]                     if (file_test("-f", pathname_tmp)) {
[16:05:01.642]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.642]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:01.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.642]                         fi_tmp[["mtime"]])
[16:05:01.642]                     }
[16:05:01.642]                     tryCatch({
[16:05:01.642]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:01.642]                     }, error = function(ex) {
[16:05:01.642]                       msg <- conditionMessage(ex)
[16:05:01.642]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.642]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:01.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.642]                         fi_tmp[["mtime"]], msg)
[16:05:01.642]                       ex$message <- msg
[16:05:01.642]                       stop(ex)
[16:05:01.642]                     })
[16:05:01.642]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:01.642]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:01.642]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:01.642]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.642]                       fi <- file.info(pathname)
[16:05:01.642]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:01.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.642]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:01.642]                         fi[["size"]], fi[["mtime"]])
[16:05:01.642]                       stop(msg)
[16:05:01.642]                     }
[16:05:01.642]                     invisible(pathname)
[16:05:01.642]                   }
[16:05:01.642]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:01.642]                     rootPath = tempdir()) 
[16:05:01.642]                   {
[16:05:01.642]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:01.642]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:01.642]                       tmpdir = path, fileext = ".rds")
[16:05:01.642]                     save_rds(obj, file)
[16:05:01.642]                   }
[16:05:01.642]                   saveImmediateCondition(cond, path = "/tmp/Rtmpsnomsu/.future/immediateConditions")
[16:05:01.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.642]                   {
[16:05:01.642]                     inherits <- base::inherits
[16:05:01.642]                     invokeRestart <- base::invokeRestart
[16:05:01.642]                     is.null <- base::is.null
[16:05:01.642]                     muffled <- FALSE
[16:05:01.642]                     if (inherits(cond, "message")) {
[16:05:01.642]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:01.642]                       if (muffled) 
[16:05:01.642]                         invokeRestart("muffleMessage")
[16:05:01.642]                     }
[16:05:01.642]                     else if (inherits(cond, "warning")) {
[16:05:01.642]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:01.642]                       if (muffled) 
[16:05:01.642]                         invokeRestart("muffleWarning")
[16:05:01.642]                     }
[16:05:01.642]                     else if (inherits(cond, "condition")) {
[16:05:01.642]                       if (!is.null(pattern)) {
[16:05:01.642]                         computeRestarts <- base::computeRestarts
[16:05:01.642]                         grepl <- base::grepl
[16:05:01.642]                         restarts <- computeRestarts(cond)
[16:05:01.642]                         for (restart in restarts) {
[16:05:01.642]                           name <- restart$name
[16:05:01.642]                           if (is.null(name)) 
[16:05:01.642]                             next
[16:05:01.642]                           if (!grepl(pattern, name)) 
[16:05:01.642]                             next
[16:05:01.642]                           invokeRestart(restart)
[16:05:01.642]                           muffled <- TRUE
[16:05:01.642]                           break
[16:05:01.642]                         }
[16:05:01.642]                       }
[16:05:01.642]                     }
[16:05:01.642]                     invisible(muffled)
[16:05:01.642]                   }
[16:05:01.642]                   muffleCondition(cond)
[16:05:01.642]                 })
[16:05:01.642]             }))
[16:05:01.642]             future::FutureResult(value = ...future.value$value, 
[16:05:01.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.642]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.642]                     ...future.globalenv.names))
[16:05:01.642]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.642]         }, condition = base::local({
[16:05:01.642]             c <- base::c
[16:05:01.642]             inherits <- base::inherits
[16:05:01.642]             invokeRestart <- base::invokeRestart
[16:05:01.642]             length <- base::length
[16:05:01.642]             list <- base::list
[16:05:01.642]             seq.int <- base::seq.int
[16:05:01.642]             signalCondition <- base::signalCondition
[16:05:01.642]             sys.calls <- base::sys.calls
[16:05:01.642]             `[[` <- base::`[[`
[16:05:01.642]             `+` <- base::`+`
[16:05:01.642]             `<<-` <- base::`<<-`
[16:05:01.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.642]                   3L)]
[16:05:01.642]             }
[16:05:01.642]             function(cond) {
[16:05:01.642]                 is_error <- inherits(cond, "error")
[16:05:01.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.642]                   NULL)
[16:05:01.642]                 if (is_error) {
[16:05:01.642]                   sessionInformation <- function() {
[16:05:01.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.642]                       search = base::search(), system = base::Sys.info())
[16:05:01.642]                   }
[16:05:01.642]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.642]                     cond$call), session = sessionInformation(), 
[16:05:01.642]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.642]                   signalCondition(cond)
[16:05:01.642]                 }
[16:05:01.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.642]                 "immediateCondition"))) {
[16:05:01.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.642]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.642]                   if (TRUE && !signal) {
[16:05:01.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.642]                     {
[16:05:01.642]                       inherits <- base::inherits
[16:05:01.642]                       invokeRestart <- base::invokeRestart
[16:05:01.642]                       is.null <- base::is.null
[16:05:01.642]                       muffled <- FALSE
[16:05:01.642]                       if (inherits(cond, "message")) {
[16:05:01.642]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.642]                         if (muffled) 
[16:05:01.642]                           invokeRestart("muffleMessage")
[16:05:01.642]                       }
[16:05:01.642]                       else if (inherits(cond, "warning")) {
[16:05:01.642]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.642]                         if (muffled) 
[16:05:01.642]                           invokeRestart("muffleWarning")
[16:05:01.642]                       }
[16:05:01.642]                       else if (inherits(cond, "condition")) {
[16:05:01.642]                         if (!is.null(pattern)) {
[16:05:01.642]                           computeRestarts <- base::computeRestarts
[16:05:01.642]                           grepl <- base::grepl
[16:05:01.642]                           restarts <- computeRestarts(cond)
[16:05:01.642]                           for (restart in restarts) {
[16:05:01.642]                             name <- restart$name
[16:05:01.642]                             if (is.null(name)) 
[16:05:01.642]                               next
[16:05:01.642]                             if (!grepl(pattern, name)) 
[16:05:01.642]                               next
[16:05:01.642]                             invokeRestart(restart)
[16:05:01.642]                             muffled <- TRUE
[16:05:01.642]                             break
[16:05:01.642]                           }
[16:05:01.642]                         }
[16:05:01.642]                       }
[16:05:01.642]                       invisible(muffled)
[16:05:01.642]                     }
[16:05:01.642]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.642]                   }
[16:05:01.642]                 }
[16:05:01.642]                 else {
[16:05:01.642]                   if (TRUE) {
[16:05:01.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.642]                     {
[16:05:01.642]                       inherits <- base::inherits
[16:05:01.642]                       invokeRestart <- base::invokeRestart
[16:05:01.642]                       is.null <- base::is.null
[16:05:01.642]                       muffled <- FALSE
[16:05:01.642]                       if (inherits(cond, "message")) {
[16:05:01.642]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.642]                         if (muffled) 
[16:05:01.642]                           invokeRestart("muffleMessage")
[16:05:01.642]                       }
[16:05:01.642]                       else if (inherits(cond, "warning")) {
[16:05:01.642]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.642]                         if (muffled) 
[16:05:01.642]                           invokeRestart("muffleWarning")
[16:05:01.642]                       }
[16:05:01.642]                       else if (inherits(cond, "condition")) {
[16:05:01.642]                         if (!is.null(pattern)) {
[16:05:01.642]                           computeRestarts <- base::computeRestarts
[16:05:01.642]                           grepl <- base::grepl
[16:05:01.642]                           restarts <- computeRestarts(cond)
[16:05:01.642]                           for (restart in restarts) {
[16:05:01.642]                             name <- restart$name
[16:05:01.642]                             if (is.null(name)) 
[16:05:01.642]                               next
[16:05:01.642]                             if (!grepl(pattern, name)) 
[16:05:01.642]                               next
[16:05:01.642]                             invokeRestart(restart)
[16:05:01.642]                             muffled <- TRUE
[16:05:01.642]                             break
[16:05:01.642]                           }
[16:05:01.642]                         }
[16:05:01.642]                       }
[16:05:01.642]                       invisible(muffled)
[16:05:01.642]                     }
[16:05:01.642]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.642]                   }
[16:05:01.642]                 }
[16:05:01.642]             }
[16:05:01.642]         }))
[16:05:01.642]     }, error = function(ex) {
[16:05:01.642]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.642]                 ...future.rng), started = ...future.startTime, 
[16:05:01.642]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.642]             version = "1.8"), class = "FutureResult")
[16:05:01.642]     }, finally = {
[16:05:01.642]         if (!identical(...future.workdir, getwd())) 
[16:05:01.642]             setwd(...future.workdir)
[16:05:01.642]         {
[16:05:01.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.642]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.642]             }
[16:05:01.642]             base::options(...future.oldOptions)
[16:05:01.642]             if (.Platform$OS.type == "windows") {
[16:05:01.642]                 old_names <- names(...future.oldEnvVars)
[16:05:01.642]                 envs <- base::Sys.getenv()
[16:05:01.642]                 names <- names(envs)
[16:05:01.642]                 common <- intersect(names, old_names)
[16:05:01.642]                 added <- setdiff(names, old_names)
[16:05:01.642]                 removed <- setdiff(old_names, names)
[16:05:01.642]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.642]                   envs[common]]
[16:05:01.642]                 NAMES <- toupper(changed)
[16:05:01.642]                 args <- list()
[16:05:01.642]                 for (kk in seq_along(NAMES)) {
[16:05:01.642]                   name <- changed[[kk]]
[16:05:01.642]                   NAME <- NAMES[[kk]]
[16:05:01.642]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.642]                     next
[16:05:01.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.642]                 }
[16:05:01.642]                 NAMES <- toupper(added)
[16:05:01.642]                 for (kk in seq_along(NAMES)) {
[16:05:01.642]                   name <- added[[kk]]
[16:05:01.642]                   NAME <- NAMES[[kk]]
[16:05:01.642]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.642]                     next
[16:05:01.642]                   args[[name]] <- ""
[16:05:01.642]                 }
[16:05:01.642]                 NAMES <- toupper(removed)
[16:05:01.642]                 for (kk in seq_along(NAMES)) {
[16:05:01.642]                   name <- removed[[kk]]
[16:05:01.642]                   NAME <- NAMES[[kk]]
[16:05:01.642]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.642]                     next
[16:05:01.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.642]                 }
[16:05:01.642]                 if (length(args) > 0) 
[16:05:01.642]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.642]             }
[16:05:01.642]             else {
[16:05:01.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.642]             }
[16:05:01.642]             {
[16:05:01.642]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.642]                   0L) {
[16:05:01.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.642]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.642]                   base::options(opts)
[16:05:01.642]                 }
[16:05:01.642]                 {
[16:05:01.642]                   {
[16:05:01.642]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:01.642]                     NULL
[16:05:01.642]                   }
[16:05:01.642]                   options(future.plan = NULL)
[16:05:01.642]                   if (is.na(NA_character_)) 
[16:05:01.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.642]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:01.642]                     envir = parent.frame()) 
[16:05:01.642]                   {
[16:05:01.642]                     default_workers <- missing(workers)
[16:05:01.642]                     if (is.function(workers)) 
[16:05:01.642]                       workers <- workers()
[16:05:01.642]                     workers <- structure(as.integer(workers), 
[16:05:01.642]                       class = class(workers))
[16:05:01.642]                     stop_if_not(is.finite(workers), workers >= 
[16:05:01.642]                       1L)
[16:05:01.642]                     if ((workers == 1L && !inherits(workers, 
[16:05:01.642]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:01.642]                       if (default_workers) 
[16:05:01.642]                         supportsMulticore(warn = TRUE)
[16:05:01.642]                       return(sequential(..., envir = envir))
[16:05:01.642]                     }
[16:05:01.642]                     oopts <- options(mc.cores = workers)
[16:05:01.642]                     on.exit(options(oopts))
[16:05:01.642]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:01.642]                       envir = envir)
[16:05:01.642]                     if (!future$lazy) 
[16:05:01.642]                       future <- run(future)
[16:05:01.642]                     invisible(future)
[16:05:01.642]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.642]                 }
[16:05:01.642]             }
[16:05:01.642]         }
[16:05:01.642]     })
[16:05:01.642]     if (TRUE) {
[16:05:01.642]         base::sink(type = "output", split = FALSE)
[16:05:01.642]         if (TRUE) {
[16:05:01.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.642]         }
[16:05:01.642]         else {
[16:05:01.642]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.642]         }
[16:05:01.642]         base::close(...future.stdout)
[16:05:01.642]         ...future.stdout <- NULL
[16:05:01.642]     }
[16:05:01.642]     ...future.result$conditions <- ...future.conditions
[16:05:01.642]     ...future.result$finished <- base::Sys.time()
[16:05:01.642]     ...future.result
[16:05:01.642] }
[16:05:01.645] assign_globals() ...
[16:05:01.645] List of 1
[16:05:01.645]  $ x: list()
[16:05:01.645]  - attr(*, "where")=List of 1
[16:05:01.645]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.645]  - attr(*, "resolved")= logi TRUE
[16:05:01.645]  - attr(*, "total_size")= num 0
[16:05:01.645]  - attr(*, "already-done")= logi TRUE
[16:05:01.648] - copied ‘x’ to environment
[16:05:01.648] assign_globals() ... done
[16:05:01.648] requestCore(): workers = 2
[16:05:01.650] MulticoreFuture started
[16:05:01.650] - Launch lazy future ... done
[16:05:01.651] run() for ‘MulticoreFuture’ ... done
[16:05:01.651] result() for MulticoreFuture ...
[16:05:01.651] plan(): Setting new future strategy stack:
[16:05:01.651] List of future strategies:
[16:05:01.651] 1. sequential:
[16:05:01.651]    - args: function (..., envir = parent.frame())
[16:05:01.651]    - tweaked: FALSE
[16:05:01.651]    - call: NULL
[16:05:01.652] plan(): nbrOfWorkers() = 1
[16:05:01.654] plan(): Setting new future strategy stack:
[16:05:01.654] List of future strategies:
[16:05:01.654] 1. multicore:
[16:05:01.654]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.654]    - tweaked: FALSE
[16:05:01.654]    - call: plan(strategy)
[16:05:01.660] plan(): nbrOfWorkers() = 2
[16:05:01.660] result() for MulticoreFuture ...
[16:05:01.661] result() for MulticoreFuture ... done
[16:05:01.661] result() for MulticoreFuture ... done
[16:05:01.661] result() for MulticoreFuture ...
[16:05:01.661] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.661] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.662] Searching for globals...
[16:05:01.664] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:01.665] Searching for globals ... DONE
[16:05:01.665] Resolving globals: TRUE
[16:05:01.665] Resolving any globals that are futures ...
[16:05:01.665] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:01.665] Resolving any globals that are futures ... DONE
[16:05:01.666] Resolving futures part of globals (recursively) ...
[16:05:01.666] resolve() on list ...
[16:05:01.666]  recursive: 99
[16:05:01.666]  length: 1
[16:05:01.666]  elements: ‘x’
[16:05:01.666]  length: 0 (resolved future 1)
[16:05:01.667] resolve() on list ... DONE
[16:05:01.667] - globals: [1] ‘x’
[16:05:01.667] Resolving futures part of globals (recursively) ... DONE
[16:05:01.667] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.667] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.668] - globals: [1] ‘x’
[16:05:01.668] 
[16:05:01.668] getGlobalsAndPackages() ... DONE
[16:05:01.671] run() for ‘Future’ ...
[16:05:01.671] - state: ‘created’
[16:05:01.671] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:01.676] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:01.676] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:01.676]   - Field: ‘label’
[16:05:01.676]   - Field: ‘local’
[16:05:01.676]   - Field: ‘owner’
[16:05:01.676]   - Field: ‘envir’
[16:05:01.676]   - Field: ‘workers’
[16:05:01.677]   - Field: ‘packages’
[16:05:01.677]   - Field: ‘gc’
[16:05:01.677]   - Field: ‘job’
[16:05:01.677]   - Field: ‘conditions’
[16:05:01.677]   - Field: ‘expr’
[16:05:01.677]   - Field: ‘uuid’
[16:05:01.677]   - Field: ‘seed’
[16:05:01.677]   - Field: ‘version’
[16:05:01.677]   - Field: ‘result’
[16:05:01.678]   - Field: ‘asynchronous’
[16:05:01.678]   - Field: ‘calls’
[16:05:01.678]   - Field: ‘globals’
[16:05:01.678]   - Field: ‘stdout’
[16:05:01.678]   - Field: ‘earlySignal’
[16:05:01.678]   - Field: ‘lazy’
[16:05:01.678]   - Field: ‘state’
[16:05:01.678] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:01.679] - Launch lazy future ...
[16:05:01.679] Packages needed by the future expression (n = 0): <none>
[16:05:01.679] Packages needed by future strategies (n = 0): <none>
[16:05:01.680] {
[16:05:01.680]     {
[16:05:01.680]         {
[16:05:01.680]             ...future.startTime <- base::Sys.time()
[16:05:01.680]             {
[16:05:01.680]                 {
[16:05:01.680]                   {
[16:05:01.680]                     {
[16:05:01.680]                       base::local({
[16:05:01.680]                         has_future <- base::requireNamespace("future", 
[16:05:01.680]                           quietly = TRUE)
[16:05:01.680]                         if (has_future) {
[16:05:01.680]                           ns <- base::getNamespace("future")
[16:05:01.680]                           version <- ns[[".package"]][["version"]]
[16:05:01.680]                           if (is.null(version)) 
[16:05:01.680]                             version <- utils::packageVersion("future")
[16:05:01.680]                         }
[16:05:01.680]                         else {
[16:05:01.680]                           version <- NULL
[16:05:01.680]                         }
[16:05:01.680]                         if (!has_future || version < "1.8.0") {
[16:05:01.680]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.680]                             "", base::R.version$version.string), 
[16:05:01.680]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:01.680]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.680]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.680]                               "release", "version")], collapse = " "), 
[16:05:01.680]                             hostname = base::Sys.info()[["nodename"]])
[16:05:01.680]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.680]                             info)
[16:05:01.680]                           info <- base::paste(info, collapse = "; ")
[16:05:01.680]                           if (!has_future) {
[16:05:01.680]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.680]                               info)
[16:05:01.680]                           }
[16:05:01.680]                           else {
[16:05:01.680]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.680]                               info, version)
[16:05:01.680]                           }
[16:05:01.680]                           base::stop(msg)
[16:05:01.680]                         }
[16:05:01.680]                       })
[16:05:01.680]                     }
[16:05:01.680]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:01.680]                     base::options(mc.cores = 1L)
[16:05:01.680]                   }
[16:05:01.680]                   options(future.plan = NULL)
[16:05:01.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.680]                 }
[16:05:01.680]                 ...future.workdir <- getwd()
[16:05:01.680]             }
[16:05:01.680]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.680]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.680]         }
[16:05:01.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.680]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.680]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.680]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.680]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.680]             base::names(...future.oldOptions))
[16:05:01.680]     }
[16:05:01.680]     if (FALSE) {
[16:05:01.680]     }
[16:05:01.680]     else {
[16:05:01.680]         if (TRUE) {
[16:05:01.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.680]                 open = "w")
[16:05:01.680]         }
[16:05:01.680]         else {
[16:05:01.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.680]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.680]         }
[16:05:01.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.680]             base::sink(type = "output", split = FALSE)
[16:05:01.680]             base::close(...future.stdout)
[16:05:01.680]         }, add = TRUE)
[16:05:01.680]     }
[16:05:01.680]     ...future.frame <- base::sys.nframe()
[16:05:01.680]     ...future.conditions <- base::list()
[16:05:01.680]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.680]     if (FALSE) {
[16:05:01.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.680]     }
[16:05:01.680]     ...future.result <- base::tryCatch({
[16:05:01.680]         base::withCallingHandlers({
[16:05:01.680]             ...future.value <- base::withVisible(base::local({
[16:05:01.680]                 withCallingHandlers({
[16:05:01.680]                   {
[16:05:01.680]                     x[["a"]] <- 1
[16:05:01.680]                     x
[16:05:01.680]                   }
[16:05:01.680]                 }, immediateCondition = function(cond) {
[16:05:01.680]                   save_rds <- function (object, pathname, ...) 
[16:05:01.680]                   {
[16:05:01.680]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:01.680]                     if (file_test("-f", pathname_tmp)) {
[16:05:01.680]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.680]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:01.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.680]                         fi_tmp[["mtime"]])
[16:05:01.680]                     }
[16:05:01.680]                     tryCatch({
[16:05:01.680]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:01.680]                     }, error = function(ex) {
[16:05:01.680]                       msg <- conditionMessage(ex)
[16:05:01.680]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.680]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:01.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.680]                         fi_tmp[["mtime"]], msg)
[16:05:01.680]                       ex$message <- msg
[16:05:01.680]                       stop(ex)
[16:05:01.680]                     })
[16:05:01.680]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:01.680]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:01.680]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:01.680]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.680]                       fi <- file.info(pathname)
[16:05:01.680]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:01.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.680]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:01.680]                         fi[["size"]], fi[["mtime"]])
[16:05:01.680]                       stop(msg)
[16:05:01.680]                     }
[16:05:01.680]                     invisible(pathname)
[16:05:01.680]                   }
[16:05:01.680]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:01.680]                     rootPath = tempdir()) 
[16:05:01.680]                   {
[16:05:01.680]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:01.680]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:01.680]                       tmpdir = path, fileext = ".rds")
[16:05:01.680]                     save_rds(obj, file)
[16:05:01.680]                   }
[16:05:01.680]                   saveImmediateCondition(cond, path = "/tmp/Rtmpsnomsu/.future/immediateConditions")
[16:05:01.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.680]                   {
[16:05:01.680]                     inherits <- base::inherits
[16:05:01.680]                     invokeRestart <- base::invokeRestart
[16:05:01.680]                     is.null <- base::is.null
[16:05:01.680]                     muffled <- FALSE
[16:05:01.680]                     if (inherits(cond, "message")) {
[16:05:01.680]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:01.680]                       if (muffled) 
[16:05:01.680]                         invokeRestart("muffleMessage")
[16:05:01.680]                     }
[16:05:01.680]                     else if (inherits(cond, "warning")) {
[16:05:01.680]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:01.680]                       if (muffled) 
[16:05:01.680]                         invokeRestart("muffleWarning")
[16:05:01.680]                     }
[16:05:01.680]                     else if (inherits(cond, "condition")) {
[16:05:01.680]                       if (!is.null(pattern)) {
[16:05:01.680]                         computeRestarts <- base::computeRestarts
[16:05:01.680]                         grepl <- base::grepl
[16:05:01.680]                         restarts <- computeRestarts(cond)
[16:05:01.680]                         for (restart in restarts) {
[16:05:01.680]                           name <- restart$name
[16:05:01.680]                           if (is.null(name)) 
[16:05:01.680]                             next
[16:05:01.680]                           if (!grepl(pattern, name)) 
[16:05:01.680]                             next
[16:05:01.680]                           invokeRestart(restart)
[16:05:01.680]                           muffled <- TRUE
[16:05:01.680]                           break
[16:05:01.680]                         }
[16:05:01.680]                       }
[16:05:01.680]                     }
[16:05:01.680]                     invisible(muffled)
[16:05:01.680]                   }
[16:05:01.680]                   muffleCondition(cond)
[16:05:01.680]                 })
[16:05:01.680]             }))
[16:05:01.680]             future::FutureResult(value = ...future.value$value, 
[16:05:01.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.680]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.680]                     ...future.globalenv.names))
[16:05:01.680]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.680]         }, condition = base::local({
[16:05:01.680]             c <- base::c
[16:05:01.680]             inherits <- base::inherits
[16:05:01.680]             invokeRestart <- base::invokeRestart
[16:05:01.680]             length <- base::length
[16:05:01.680]             list <- base::list
[16:05:01.680]             seq.int <- base::seq.int
[16:05:01.680]             signalCondition <- base::signalCondition
[16:05:01.680]             sys.calls <- base::sys.calls
[16:05:01.680]             `[[` <- base::`[[`
[16:05:01.680]             `+` <- base::`+`
[16:05:01.680]             `<<-` <- base::`<<-`
[16:05:01.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.680]                   3L)]
[16:05:01.680]             }
[16:05:01.680]             function(cond) {
[16:05:01.680]                 is_error <- inherits(cond, "error")
[16:05:01.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.680]                   NULL)
[16:05:01.680]                 if (is_error) {
[16:05:01.680]                   sessionInformation <- function() {
[16:05:01.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.680]                       search = base::search(), system = base::Sys.info())
[16:05:01.680]                   }
[16:05:01.680]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.680]                     cond$call), session = sessionInformation(), 
[16:05:01.680]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.680]                   signalCondition(cond)
[16:05:01.680]                 }
[16:05:01.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.680]                 "immediateCondition"))) {
[16:05:01.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.680]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.680]                   if (TRUE && !signal) {
[16:05:01.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.680]                     {
[16:05:01.680]                       inherits <- base::inherits
[16:05:01.680]                       invokeRestart <- base::invokeRestart
[16:05:01.680]                       is.null <- base::is.null
[16:05:01.680]                       muffled <- FALSE
[16:05:01.680]                       if (inherits(cond, "message")) {
[16:05:01.680]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.680]                         if (muffled) 
[16:05:01.680]                           invokeRestart("muffleMessage")
[16:05:01.680]                       }
[16:05:01.680]                       else if (inherits(cond, "warning")) {
[16:05:01.680]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.680]                         if (muffled) 
[16:05:01.680]                           invokeRestart("muffleWarning")
[16:05:01.680]                       }
[16:05:01.680]                       else if (inherits(cond, "condition")) {
[16:05:01.680]                         if (!is.null(pattern)) {
[16:05:01.680]                           computeRestarts <- base::computeRestarts
[16:05:01.680]                           grepl <- base::grepl
[16:05:01.680]                           restarts <- computeRestarts(cond)
[16:05:01.680]                           for (restart in restarts) {
[16:05:01.680]                             name <- restart$name
[16:05:01.680]                             if (is.null(name)) 
[16:05:01.680]                               next
[16:05:01.680]                             if (!grepl(pattern, name)) 
[16:05:01.680]                               next
[16:05:01.680]                             invokeRestart(restart)
[16:05:01.680]                             muffled <- TRUE
[16:05:01.680]                             break
[16:05:01.680]                           }
[16:05:01.680]                         }
[16:05:01.680]                       }
[16:05:01.680]                       invisible(muffled)
[16:05:01.680]                     }
[16:05:01.680]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.680]                   }
[16:05:01.680]                 }
[16:05:01.680]                 else {
[16:05:01.680]                   if (TRUE) {
[16:05:01.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.680]                     {
[16:05:01.680]                       inherits <- base::inherits
[16:05:01.680]                       invokeRestart <- base::invokeRestart
[16:05:01.680]                       is.null <- base::is.null
[16:05:01.680]                       muffled <- FALSE
[16:05:01.680]                       if (inherits(cond, "message")) {
[16:05:01.680]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.680]                         if (muffled) 
[16:05:01.680]                           invokeRestart("muffleMessage")
[16:05:01.680]                       }
[16:05:01.680]                       else if (inherits(cond, "warning")) {
[16:05:01.680]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.680]                         if (muffled) 
[16:05:01.680]                           invokeRestart("muffleWarning")
[16:05:01.680]                       }
[16:05:01.680]                       else if (inherits(cond, "condition")) {
[16:05:01.680]                         if (!is.null(pattern)) {
[16:05:01.680]                           computeRestarts <- base::computeRestarts
[16:05:01.680]                           grepl <- base::grepl
[16:05:01.680]                           restarts <- computeRestarts(cond)
[16:05:01.680]                           for (restart in restarts) {
[16:05:01.680]                             name <- restart$name
[16:05:01.680]                             if (is.null(name)) 
[16:05:01.680]                               next
[16:05:01.680]                             if (!grepl(pattern, name)) 
[16:05:01.680]                               next
[16:05:01.680]                             invokeRestart(restart)
[16:05:01.680]                             muffled <- TRUE
[16:05:01.680]                             break
[16:05:01.680]                           }
[16:05:01.680]                         }
[16:05:01.680]                       }
[16:05:01.680]                       invisible(muffled)
[16:05:01.680]                     }
[16:05:01.680]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.680]                   }
[16:05:01.680]                 }
[16:05:01.680]             }
[16:05:01.680]         }))
[16:05:01.680]     }, error = function(ex) {
[16:05:01.680]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.680]                 ...future.rng), started = ...future.startTime, 
[16:05:01.680]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.680]             version = "1.8"), class = "FutureResult")
[16:05:01.680]     }, finally = {
[16:05:01.680]         if (!identical(...future.workdir, getwd())) 
[16:05:01.680]             setwd(...future.workdir)
[16:05:01.680]         {
[16:05:01.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.680]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.680]             }
[16:05:01.680]             base::options(...future.oldOptions)
[16:05:01.680]             if (.Platform$OS.type == "windows") {
[16:05:01.680]                 old_names <- names(...future.oldEnvVars)
[16:05:01.680]                 envs <- base::Sys.getenv()
[16:05:01.680]                 names <- names(envs)
[16:05:01.680]                 common <- intersect(names, old_names)
[16:05:01.680]                 added <- setdiff(names, old_names)
[16:05:01.680]                 removed <- setdiff(old_names, names)
[16:05:01.680]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.680]                   envs[common]]
[16:05:01.680]                 NAMES <- toupper(changed)
[16:05:01.680]                 args <- list()
[16:05:01.680]                 for (kk in seq_along(NAMES)) {
[16:05:01.680]                   name <- changed[[kk]]
[16:05:01.680]                   NAME <- NAMES[[kk]]
[16:05:01.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.680]                     next
[16:05:01.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.680]                 }
[16:05:01.680]                 NAMES <- toupper(added)
[16:05:01.680]                 for (kk in seq_along(NAMES)) {
[16:05:01.680]                   name <- added[[kk]]
[16:05:01.680]                   NAME <- NAMES[[kk]]
[16:05:01.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.680]                     next
[16:05:01.680]                   args[[name]] <- ""
[16:05:01.680]                 }
[16:05:01.680]                 NAMES <- toupper(removed)
[16:05:01.680]                 for (kk in seq_along(NAMES)) {
[16:05:01.680]                   name <- removed[[kk]]
[16:05:01.680]                   NAME <- NAMES[[kk]]
[16:05:01.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.680]                     next
[16:05:01.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.680]                 }
[16:05:01.680]                 if (length(args) > 0) 
[16:05:01.680]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.680]             }
[16:05:01.680]             else {
[16:05:01.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.680]             }
[16:05:01.680]             {
[16:05:01.680]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.680]                   0L) {
[16:05:01.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.680]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.680]                   base::options(opts)
[16:05:01.680]                 }
[16:05:01.680]                 {
[16:05:01.680]                   {
[16:05:01.680]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:01.680]                     NULL
[16:05:01.680]                   }
[16:05:01.680]                   options(future.plan = NULL)
[16:05:01.680]                   if (is.na(NA_character_)) 
[16:05:01.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.680]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:01.680]                     envir = parent.frame()) 
[16:05:01.680]                   {
[16:05:01.680]                     default_workers <- missing(workers)
[16:05:01.680]                     if (is.function(workers)) 
[16:05:01.680]                       workers <- workers()
[16:05:01.680]                     workers <- structure(as.integer(workers), 
[16:05:01.680]                       class = class(workers))
[16:05:01.680]                     stop_if_not(is.finite(workers), workers >= 
[16:05:01.680]                       1L)
[16:05:01.680]                     if ((workers == 1L && !inherits(workers, 
[16:05:01.680]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:01.680]                       if (default_workers) 
[16:05:01.680]                         supportsMulticore(warn = TRUE)
[16:05:01.680]                       return(sequential(..., envir = envir))
[16:05:01.680]                     }
[16:05:01.680]                     oopts <- options(mc.cores = workers)
[16:05:01.680]                     on.exit(options(oopts))
[16:05:01.680]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:01.680]                       envir = envir)
[16:05:01.680]                     if (!future$lazy) 
[16:05:01.680]                       future <- run(future)
[16:05:01.680]                     invisible(future)
[16:05:01.680]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.680]                 }
[16:05:01.680]             }
[16:05:01.680]         }
[16:05:01.680]     })
[16:05:01.680]     if (TRUE) {
[16:05:01.680]         base::sink(type = "output", split = FALSE)
[16:05:01.680]         if (TRUE) {
[16:05:01.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.680]         }
[16:05:01.680]         else {
[16:05:01.680]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.680]         }
[16:05:01.680]         base::close(...future.stdout)
[16:05:01.680]         ...future.stdout <- NULL
[16:05:01.680]     }
[16:05:01.680]     ...future.result$conditions <- ...future.conditions
[16:05:01.680]     ...future.result$finished <- base::Sys.time()
[16:05:01.680]     ...future.result
[16:05:01.680] }
[16:05:01.682] assign_globals() ...
[16:05:01.682] List of 1
[16:05:01.682]  $ x: list()
[16:05:01.682]  - attr(*, "where")=List of 1
[16:05:01.682]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.682]  - attr(*, "resolved")= logi TRUE
[16:05:01.682]  - attr(*, "total_size")= num 0
[16:05:01.682]  - attr(*, "already-done")= logi TRUE
[16:05:01.685] - copied ‘x’ to environment
[16:05:01.685] assign_globals() ... done
[16:05:01.686] requestCore(): workers = 2
[16:05:01.688] MulticoreFuture started
[16:05:01.688] - Launch lazy future ... done
[16:05:01.688] run() for ‘MulticoreFuture’ ... done
[16:05:01.689] result() for MulticoreFuture ...
[16:05:01.689] plan(): Setting new future strategy stack:
[16:05:01.689] List of future strategies:
[16:05:01.689] 1. sequential:
[16:05:01.689]    - args: function (..., envir = parent.frame())
[16:05:01.689]    - tweaked: FALSE
[16:05:01.689]    - call: NULL
[16:05:01.690] plan(): nbrOfWorkers() = 1
[16:05:01.692] plan(): Setting new future strategy stack:
[16:05:01.692] List of future strategies:
[16:05:01.692] 1. multicore:
[16:05:01.692]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.692]    - tweaked: FALSE
[16:05:01.692]    - call: plan(strategy)
[16:05:01.698] plan(): nbrOfWorkers() = 2
[16:05:01.699] result() for MulticoreFuture ...
[16:05:01.699] result() for MulticoreFuture ... done
[16:05:01.699] result() for MulticoreFuture ... done
[16:05:01.699] result() for MulticoreFuture ...
[16:05:01.699] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.700] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.700] Searching for globals...
[16:05:01.703] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:01.703] Searching for globals ... DONE
[16:05:01.703] Resolving globals: TRUE
[16:05:01.704] Resolving any globals that are futures ...
[16:05:01.704] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:01.704] Resolving any globals that are futures ... DONE
[16:05:01.704] Resolving futures part of globals (recursively) ...
[16:05:01.705] resolve() on list ...
[16:05:01.705]  recursive: 99
[16:05:01.705]  length: 1
[16:05:01.705]  elements: ‘x’
[16:05:01.705]  length: 0 (resolved future 1)
[16:05:01.705] resolve() on list ... DONE
[16:05:01.705] - globals: [1] ‘x’
[16:05:01.706] Resolving futures part of globals (recursively) ... DONE
[16:05:01.706] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.706] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.706] - globals: [1] ‘x’
[16:05:01.706] 
[16:05:01.707] getGlobalsAndPackages() ... DONE
[16:05:01.707] run() for ‘Future’ ...
[16:05:01.707] - state: ‘created’
[16:05:01.707] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:01.711] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:01.711] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:01.712]   - Field: ‘label’
[16:05:01.712]   - Field: ‘local’
[16:05:01.712]   - Field: ‘owner’
[16:05:01.712]   - Field: ‘envir’
[16:05:01.712]   - Field: ‘workers’
[16:05:01.712]   - Field: ‘packages’
[16:05:01.712]   - Field: ‘gc’
[16:05:01.712]   - Field: ‘job’
[16:05:01.712]   - Field: ‘conditions’
[16:05:01.713]   - Field: ‘expr’
[16:05:01.713]   - Field: ‘uuid’
[16:05:01.713]   - Field: ‘seed’
[16:05:01.713]   - Field: ‘version’
[16:05:01.713]   - Field: ‘result’
[16:05:01.713]   - Field: ‘asynchronous’
[16:05:01.713]   - Field: ‘calls’
[16:05:01.713]   - Field: ‘globals’
[16:05:01.713]   - Field: ‘stdout’
[16:05:01.714]   - Field: ‘earlySignal’
[16:05:01.714]   - Field: ‘lazy’
[16:05:01.714]   - Field: ‘state’
[16:05:01.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:01.714] - Launch lazy future ...
[16:05:01.714] Packages needed by the future expression (n = 0): <none>
[16:05:01.715] Packages needed by future strategies (n = 0): <none>
[16:05:01.715] {
[16:05:01.715]     {
[16:05:01.715]         {
[16:05:01.715]             ...future.startTime <- base::Sys.time()
[16:05:01.715]             {
[16:05:01.715]                 {
[16:05:01.715]                   {
[16:05:01.715]                     {
[16:05:01.715]                       base::local({
[16:05:01.715]                         has_future <- base::requireNamespace("future", 
[16:05:01.715]                           quietly = TRUE)
[16:05:01.715]                         if (has_future) {
[16:05:01.715]                           ns <- base::getNamespace("future")
[16:05:01.715]                           version <- ns[[".package"]][["version"]]
[16:05:01.715]                           if (is.null(version)) 
[16:05:01.715]                             version <- utils::packageVersion("future")
[16:05:01.715]                         }
[16:05:01.715]                         else {
[16:05:01.715]                           version <- NULL
[16:05:01.715]                         }
[16:05:01.715]                         if (!has_future || version < "1.8.0") {
[16:05:01.715]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.715]                             "", base::R.version$version.string), 
[16:05:01.715]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:01.715]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.715]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.715]                               "release", "version")], collapse = " "), 
[16:05:01.715]                             hostname = base::Sys.info()[["nodename"]])
[16:05:01.715]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.715]                             info)
[16:05:01.715]                           info <- base::paste(info, collapse = "; ")
[16:05:01.715]                           if (!has_future) {
[16:05:01.715]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.715]                               info)
[16:05:01.715]                           }
[16:05:01.715]                           else {
[16:05:01.715]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.715]                               info, version)
[16:05:01.715]                           }
[16:05:01.715]                           base::stop(msg)
[16:05:01.715]                         }
[16:05:01.715]                       })
[16:05:01.715]                     }
[16:05:01.715]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:01.715]                     base::options(mc.cores = 1L)
[16:05:01.715]                   }
[16:05:01.715]                   options(future.plan = NULL)
[16:05:01.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.715]                 }
[16:05:01.715]                 ...future.workdir <- getwd()
[16:05:01.715]             }
[16:05:01.715]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.715]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.715]         }
[16:05:01.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.715]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.715]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.715]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.715]             base::names(...future.oldOptions))
[16:05:01.715]     }
[16:05:01.715]     if (FALSE) {
[16:05:01.715]     }
[16:05:01.715]     else {
[16:05:01.715]         if (TRUE) {
[16:05:01.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.715]                 open = "w")
[16:05:01.715]         }
[16:05:01.715]         else {
[16:05:01.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.715]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.715]         }
[16:05:01.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.715]             base::sink(type = "output", split = FALSE)
[16:05:01.715]             base::close(...future.stdout)
[16:05:01.715]         }, add = TRUE)
[16:05:01.715]     }
[16:05:01.715]     ...future.frame <- base::sys.nframe()
[16:05:01.715]     ...future.conditions <- base::list()
[16:05:01.715]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.715]     if (FALSE) {
[16:05:01.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.715]     }
[16:05:01.715]     ...future.result <- base::tryCatch({
[16:05:01.715]         base::withCallingHandlers({
[16:05:01.715]             ...future.value <- base::withVisible(base::local({
[16:05:01.715]                 withCallingHandlers({
[16:05:01.715]                   {
[16:05:01.715]                     x[["a"]] <- 1
[16:05:01.715]                     x
[16:05:01.715]                   }
[16:05:01.715]                 }, immediateCondition = function(cond) {
[16:05:01.715]                   save_rds <- function (object, pathname, ...) 
[16:05:01.715]                   {
[16:05:01.715]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:01.715]                     if (file_test("-f", pathname_tmp)) {
[16:05:01.715]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.715]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:01.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.715]                         fi_tmp[["mtime"]])
[16:05:01.715]                     }
[16:05:01.715]                     tryCatch({
[16:05:01.715]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:01.715]                     }, error = function(ex) {
[16:05:01.715]                       msg <- conditionMessage(ex)
[16:05:01.715]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.715]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:01.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.715]                         fi_tmp[["mtime"]], msg)
[16:05:01.715]                       ex$message <- msg
[16:05:01.715]                       stop(ex)
[16:05:01.715]                     })
[16:05:01.715]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:01.715]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:01.715]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:01.715]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.715]                       fi <- file.info(pathname)
[16:05:01.715]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:01.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.715]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:01.715]                         fi[["size"]], fi[["mtime"]])
[16:05:01.715]                       stop(msg)
[16:05:01.715]                     }
[16:05:01.715]                     invisible(pathname)
[16:05:01.715]                   }
[16:05:01.715]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:01.715]                     rootPath = tempdir()) 
[16:05:01.715]                   {
[16:05:01.715]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:01.715]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:01.715]                       tmpdir = path, fileext = ".rds")
[16:05:01.715]                     save_rds(obj, file)
[16:05:01.715]                   }
[16:05:01.715]                   saveImmediateCondition(cond, path = "/tmp/Rtmpsnomsu/.future/immediateConditions")
[16:05:01.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.715]                   {
[16:05:01.715]                     inherits <- base::inherits
[16:05:01.715]                     invokeRestart <- base::invokeRestart
[16:05:01.715]                     is.null <- base::is.null
[16:05:01.715]                     muffled <- FALSE
[16:05:01.715]                     if (inherits(cond, "message")) {
[16:05:01.715]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:01.715]                       if (muffled) 
[16:05:01.715]                         invokeRestart("muffleMessage")
[16:05:01.715]                     }
[16:05:01.715]                     else if (inherits(cond, "warning")) {
[16:05:01.715]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:01.715]                       if (muffled) 
[16:05:01.715]                         invokeRestart("muffleWarning")
[16:05:01.715]                     }
[16:05:01.715]                     else if (inherits(cond, "condition")) {
[16:05:01.715]                       if (!is.null(pattern)) {
[16:05:01.715]                         computeRestarts <- base::computeRestarts
[16:05:01.715]                         grepl <- base::grepl
[16:05:01.715]                         restarts <- computeRestarts(cond)
[16:05:01.715]                         for (restart in restarts) {
[16:05:01.715]                           name <- restart$name
[16:05:01.715]                           if (is.null(name)) 
[16:05:01.715]                             next
[16:05:01.715]                           if (!grepl(pattern, name)) 
[16:05:01.715]                             next
[16:05:01.715]                           invokeRestart(restart)
[16:05:01.715]                           muffled <- TRUE
[16:05:01.715]                           break
[16:05:01.715]                         }
[16:05:01.715]                       }
[16:05:01.715]                     }
[16:05:01.715]                     invisible(muffled)
[16:05:01.715]                   }
[16:05:01.715]                   muffleCondition(cond)
[16:05:01.715]                 })
[16:05:01.715]             }))
[16:05:01.715]             future::FutureResult(value = ...future.value$value, 
[16:05:01.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.715]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.715]                     ...future.globalenv.names))
[16:05:01.715]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.715]         }, condition = base::local({
[16:05:01.715]             c <- base::c
[16:05:01.715]             inherits <- base::inherits
[16:05:01.715]             invokeRestart <- base::invokeRestart
[16:05:01.715]             length <- base::length
[16:05:01.715]             list <- base::list
[16:05:01.715]             seq.int <- base::seq.int
[16:05:01.715]             signalCondition <- base::signalCondition
[16:05:01.715]             sys.calls <- base::sys.calls
[16:05:01.715]             `[[` <- base::`[[`
[16:05:01.715]             `+` <- base::`+`
[16:05:01.715]             `<<-` <- base::`<<-`
[16:05:01.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.715]                   3L)]
[16:05:01.715]             }
[16:05:01.715]             function(cond) {
[16:05:01.715]                 is_error <- inherits(cond, "error")
[16:05:01.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.715]                   NULL)
[16:05:01.715]                 if (is_error) {
[16:05:01.715]                   sessionInformation <- function() {
[16:05:01.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.715]                       search = base::search(), system = base::Sys.info())
[16:05:01.715]                   }
[16:05:01.715]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.715]                     cond$call), session = sessionInformation(), 
[16:05:01.715]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.715]                   signalCondition(cond)
[16:05:01.715]                 }
[16:05:01.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.715]                 "immediateCondition"))) {
[16:05:01.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.715]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.715]                   if (TRUE && !signal) {
[16:05:01.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.715]                     {
[16:05:01.715]                       inherits <- base::inherits
[16:05:01.715]                       invokeRestart <- base::invokeRestart
[16:05:01.715]                       is.null <- base::is.null
[16:05:01.715]                       muffled <- FALSE
[16:05:01.715]                       if (inherits(cond, "message")) {
[16:05:01.715]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.715]                         if (muffled) 
[16:05:01.715]                           invokeRestart("muffleMessage")
[16:05:01.715]                       }
[16:05:01.715]                       else if (inherits(cond, "warning")) {
[16:05:01.715]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.715]                         if (muffled) 
[16:05:01.715]                           invokeRestart("muffleWarning")
[16:05:01.715]                       }
[16:05:01.715]                       else if (inherits(cond, "condition")) {
[16:05:01.715]                         if (!is.null(pattern)) {
[16:05:01.715]                           computeRestarts <- base::computeRestarts
[16:05:01.715]                           grepl <- base::grepl
[16:05:01.715]                           restarts <- computeRestarts(cond)
[16:05:01.715]                           for (restart in restarts) {
[16:05:01.715]                             name <- restart$name
[16:05:01.715]                             if (is.null(name)) 
[16:05:01.715]                               next
[16:05:01.715]                             if (!grepl(pattern, name)) 
[16:05:01.715]                               next
[16:05:01.715]                             invokeRestart(restart)
[16:05:01.715]                             muffled <- TRUE
[16:05:01.715]                             break
[16:05:01.715]                           }
[16:05:01.715]                         }
[16:05:01.715]                       }
[16:05:01.715]                       invisible(muffled)
[16:05:01.715]                     }
[16:05:01.715]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.715]                   }
[16:05:01.715]                 }
[16:05:01.715]                 else {
[16:05:01.715]                   if (TRUE) {
[16:05:01.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.715]                     {
[16:05:01.715]                       inherits <- base::inherits
[16:05:01.715]                       invokeRestart <- base::invokeRestart
[16:05:01.715]                       is.null <- base::is.null
[16:05:01.715]                       muffled <- FALSE
[16:05:01.715]                       if (inherits(cond, "message")) {
[16:05:01.715]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.715]                         if (muffled) 
[16:05:01.715]                           invokeRestart("muffleMessage")
[16:05:01.715]                       }
[16:05:01.715]                       else if (inherits(cond, "warning")) {
[16:05:01.715]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.715]                         if (muffled) 
[16:05:01.715]                           invokeRestart("muffleWarning")
[16:05:01.715]                       }
[16:05:01.715]                       else if (inherits(cond, "condition")) {
[16:05:01.715]                         if (!is.null(pattern)) {
[16:05:01.715]                           computeRestarts <- base::computeRestarts
[16:05:01.715]                           grepl <- base::grepl
[16:05:01.715]                           restarts <- computeRestarts(cond)
[16:05:01.715]                           for (restart in restarts) {
[16:05:01.715]                             name <- restart$name
[16:05:01.715]                             if (is.null(name)) 
[16:05:01.715]                               next
[16:05:01.715]                             if (!grepl(pattern, name)) 
[16:05:01.715]                               next
[16:05:01.715]                             invokeRestart(restart)
[16:05:01.715]                             muffled <- TRUE
[16:05:01.715]                             break
[16:05:01.715]                           }
[16:05:01.715]                         }
[16:05:01.715]                       }
[16:05:01.715]                       invisible(muffled)
[16:05:01.715]                     }
[16:05:01.715]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.715]                   }
[16:05:01.715]                 }
[16:05:01.715]             }
[16:05:01.715]         }))
[16:05:01.715]     }, error = function(ex) {
[16:05:01.715]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.715]                 ...future.rng), started = ...future.startTime, 
[16:05:01.715]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.715]             version = "1.8"), class = "FutureResult")
[16:05:01.715]     }, finally = {
[16:05:01.715]         if (!identical(...future.workdir, getwd())) 
[16:05:01.715]             setwd(...future.workdir)
[16:05:01.715]         {
[16:05:01.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.715]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.715]             }
[16:05:01.715]             base::options(...future.oldOptions)
[16:05:01.715]             if (.Platform$OS.type == "windows") {
[16:05:01.715]                 old_names <- names(...future.oldEnvVars)
[16:05:01.715]                 envs <- base::Sys.getenv()
[16:05:01.715]                 names <- names(envs)
[16:05:01.715]                 common <- intersect(names, old_names)
[16:05:01.715]                 added <- setdiff(names, old_names)
[16:05:01.715]                 removed <- setdiff(old_names, names)
[16:05:01.715]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.715]                   envs[common]]
[16:05:01.715]                 NAMES <- toupper(changed)
[16:05:01.715]                 args <- list()
[16:05:01.715]                 for (kk in seq_along(NAMES)) {
[16:05:01.715]                   name <- changed[[kk]]
[16:05:01.715]                   NAME <- NAMES[[kk]]
[16:05:01.715]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.715]                     next
[16:05:01.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.715]                 }
[16:05:01.715]                 NAMES <- toupper(added)
[16:05:01.715]                 for (kk in seq_along(NAMES)) {
[16:05:01.715]                   name <- added[[kk]]
[16:05:01.715]                   NAME <- NAMES[[kk]]
[16:05:01.715]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.715]                     next
[16:05:01.715]                   args[[name]] <- ""
[16:05:01.715]                 }
[16:05:01.715]                 NAMES <- toupper(removed)
[16:05:01.715]                 for (kk in seq_along(NAMES)) {
[16:05:01.715]                   name <- removed[[kk]]
[16:05:01.715]                   NAME <- NAMES[[kk]]
[16:05:01.715]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.715]                     next
[16:05:01.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.715]                 }
[16:05:01.715]                 if (length(args) > 0) 
[16:05:01.715]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.715]             }
[16:05:01.715]             else {
[16:05:01.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.715]             }
[16:05:01.715]             {
[16:05:01.715]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.715]                   0L) {
[16:05:01.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.715]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.715]                   base::options(opts)
[16:05:01.715]                 }
[16:05:01.715]                 {
[16:05:01.715]                   {
[16:05:01.715]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:01.715]                     NULL
[16:05:01.715]                   }
[16:05:01.715]                   options(future.plan = NULL)
[16:05:01.715]                   if (is.na(NA_character_)) 
[16:05:01.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.715]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:01.715]                     envir = parent.frame()) 
[16:05:01.715]                   {
[16:05:01.715]                     default_workers <- missing(workers)
[16:05:01.715]                     if (is.function(workers)) 
[16:05:01.715]                       workers <- workers()
[16:05:01.715]                     workers <- structure(as.integer(workers), 
[16:05:01.715]                       class = class(workers))
[16:05:01.715]                     stop_if_not(is.finite(workers), workers >= 
[16:05:01.715]                       1L)
[16:05:01.715]                     if ((workers == 1L && !inherits(workers, 
[16:05:01.715]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:01.715]                       if (default_workers) 
[16:05:01.715]                         supportsMulticore(warn = TRUE)
[16:05:01.715]                       return(sequential(..., envir = envir))
[16:05:01.715]                     }
[16:05:01.715]                     oopts <- options(mc.cores = workers)
[16:05:01.715]                     on.exit(options(oopts))
[16:05:01.715]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:01.715]                       envir = envir)
[16:05:01.715]                     if (!future$lazy) 
[16:05:01.715]                       future <- run(future)
[16:05:01.715]                     invisible(future)
[16:05:01.715]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.715]                 }
[16:05:01.715]             }
[16:05:01.715]         }
[16:05:01.715]     })
[16:05:01.715]     if (TRUE) {
[16:05:01.715]         base::sink(type = "output", split = FALSE)
[16:05:01.715]         if (TRUE) {
[16:05:01.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.715]         }
[16:05:01.715]         else {
[16:05:01.715]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.715]         }
[16:05:01.715]         base::close(...future.stdout)
[16:05:01.715]         ...future.stdout <- NULL
[16:05:01.715]     }
[16:05:01.715]     ...future.result$conditions <- ...future.conditions
[16:05:01.715]     ...future.result$finished <- base::Sys.time()
[16:05:01.715]     ...future.result
[16:05:01.715] }
[16:05:01.718] assign_globals() ...
[16:05:01.718] List of 1
[16:05:01.718]  $ x: list()
[16:05:01.718]  - attr(*, "where")=List of 1
[16:05:01.718]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.718]  - attr(*, "resolved")= logi TRUE
[16:05:01.718]  - attr(*, "total_size")= num 0
[16:05:01.718]  - attr(*, "already-done")= logi TRUE
[16:05:01.723] - copied ‘x’ to environment
[16:05:01.724] assign_globals() ... done
[16:05:01.724] requestCore(): workers = 2
[16:05:01.726] MulticoreFuture started
[16:05:01.726] - Launch lazy future ... done
[16:05:01.726] run() for ‘MulticoreFuture’ ... done
[16:05:01.727] plan(): Setting new future strategy stack:
[16:05:01.727] result() for MulticoreFuture ...
[16:05:01.727] List of future strategies:
[16:05:01.727] 1. sequential:
[16:05:01.727]    - args: function (..., envir = parent.frame())
[16:05:01.727]    - tweaked: FALSE
[16:05:01.727]    - call: NULL
[16:05:01.728] plan(): nbrOfWorkers() = 1
[16:05:01.731] plan(): Setting new future strategy stack:
[16:05:01.731] List of future strategies:
[16:05:01.731] 1. multicore:
[16:05:01.731]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.731]    - tweaked: FALSE
[16:05:01.731]    - call: plan(strategy)
[16:05:01.736] plan(): nbrOfWorkers() = 2
[16:05:01.737] result() for MulticoreFuture ...
[16:05:01.737] result() for MulticoreFuture ... done
[16:05:01.737] result() for MulticoreFuture ... done
[16:05:01.737] result() for MulticoreFuture ...
[16:05:01.738] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.738] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.739] Searching for globals...
[16:05:01.742] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:01.742] Searching for globals ... DONE
[16:05:01.742] Resolving globals: TRUE
[16:05:01.742] Resolving any globals that are futures ...
[16:05:01.743] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:01.743] Resolving any globals that are futures ... DONE
[16:05:01.743] Resolving futures part of globals (recursively) ...
[16:05:01.744] resolve() on list ...
[16:05:01.744]  recursive: 99
[16:05:01.744]  length: 1
[16:05:01.744]  elements: ‘x’
[16:05:01.744]  length: 0 (resolved future 1)
[16:05:01.744] resolve() on list ... DONE
[16:05:01.744] - globals: [1] ‘x’
[16:05:01.744] Resolving futures part of globals (recursively) ... DONE
[16:05:01.745] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.745] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.745] - globals: [1] ‘x’
[16:05:01.745] 
[16:05:01.745] getGlobalsAndPackages() ... DONE
[16:05:01.746] run() for ‘Future’ ...
[16:05:01.746] - state: ‘created’
[16:05:01.746] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:01.750] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:01.750] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:01.750]   - Field: ‘label’
[16:05:01.751]   - Field: ‘local’
[16:05:01.751]   - Field: ‘owner’
[16:05:01.751]   - Field: ‘envir’
[16:05:01.751]   - Field: ‘workers’
[16:05:01.751]   - Field: ‘packages’
[16:05:01.751]   - Field: ‘gc’
[16:05:01.751]   - Field: ‘job’
[16:05:01.751]   - Field: ‘conditions’
[16:05:01.752]   - Field: ‘expr’
[16:05:01.752]   - Field: ‘uuid’
[16:05:01.752]   - Field: ‘seed’
[16:05:01.752]   - Field: ‘version’
[16:05:01.752]   - Field: ‘result’
[16:05:01.752]   - Field: ‘asynchronous’
[16:05:01.752]   - Field: ‘calls’
[16:05:01.752]   - Field: ‘globals’
[16:05:01.753]   - Field: ‘stdout’
[16:05:01.753]   - Field: ‘earlySignal’
[16:05:01.753]   - Field: ‘lazy’
[16:05:01.753]   - Field: ‘state’
[16:05:01.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:01.753] - Launch lazy future ...
[16:05:01.753] Packages needed by the future expression (n = 0): <none>
[16:05:01.754] Packages needed by future strategies (n = 0): <none>
[16:05:01.754] {
[16:05:01.754]     {
[16:05:01.754]         {
[16:05:01.754]             ...future.startTime <- base::Sys.time()
[16:05:01.754]             {
[16:05:01.754]                 {
[16:05:01.754]                   {
[16:05:01.754]                     {
[16:05:01.754]                       base::local({
[16:05:01.754]                         has_future <- base::requireNamespace("future", 
[16:05:01.754]                           quietly = TRUE)
[16:05:01.754]                         if (has_future) {
[16:05:01.754]                           ns <- base::getNamespace("future")
[16:05:01.754]                           version <- ns[[".package"]][["version"]]
[16:05:01.754]                           if (is.null(version)) 
[16:05:01.754]                             version <- utils::packageVersion("future")
[16:05:01.754]                         }
[16:05:01.754]                         else {
[16:05:01.754]                           version <- NULL
[16:05:01.754]                         }
[16:05:01.754]                         if (!has_future || version < "1.8.0") {
[16:05:01.754]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.754]                             "", base::R.version$version.string), 
[16:05:01.754]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:01.754]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.754]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.754]                               "release", "version")], collapse = " "), 
[16:05:01.754]                             hostname = base::Sys.info()[["nodename"]])
[16:05:01.754]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.754]                             info)
[16:05:01.754]                           info <- base::paste(info, collapse = "; ")
[16:05:01.754]                           if (!has_future) {
[16:05:01.754]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.754]                               info)
[16:05:01.754]                           }
[16:05:01.754]                           else {
[16:05:01.754]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.754]                               info, version)
[16:05:01.754]                           }
[16:05:01.754]                           base::stop(msg)
[16:05:01.754]                         }
[16:05:01.754]                       })
[16:05:01.754]                     }
[16:05:01.754]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:01.754]                     base::options(mc.cores = 1L)
[16:05:01.754]                   }
[16:05:01.754]                   options(future.plan = NULL)
[16:05:01.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.754]                 }
[16:05:01.754]                 ...future.workdir <- getwd()
[16:05:01.754]             }
[16:05:01.754]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.754]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.754]         }
[16:05:01.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.754]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.754]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.754]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.754]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.754]             base::names(...future.oldOptions))
[16:05:01.754]     }
[16:05:01.754]     if (FALSE) {
[16:05:01.754]     }
[16:05:01.754]     else {
[16:05:01.754]         if (TRUE) {
[16:05:01.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.754]                 open = "w")
[16:05:01.754]         }
[16:05:01.754]         else {
[16:05:01.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.754]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.754]         }
[16:05:01.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.754]             base::sink(type = "output", split = FALSE)
[16:05:01.754]             base::close(...future.stdout)
[16:05:01.754]         }, add = TRUE)
[16:05:01.754]     }
[16:05:01.754]     ...future.frame <- base::sys.nframe()
[16:05:01.754]     ...future.conditions <- base::list()
[16:05:01.754]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.754]     if (FALSE) {
[16:05:01.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.754]     }
[16:05:01.754]     ...future.result <- base::tryCatch({
[16:05:01.754]         base::withCallingHandlers({
[16:05:01.754]             ...future.value <- base::withVisible(base::local({
[16:05:01.754]                 withCallingHandlers({
[16:05:01.754]                   {
[16:05:01.754]                     x["a"] <- list(1)
[16:05:01.754]                     x
[16:05:01.754]                   }
[16:05:01.754]                 }, immediateCondition = function(cond) {
[16:05:01.754]                   save_rds <- function (object, pathname, ...) 
[16:05:01.754]                   {
[16:05:01.754]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:01.754]                     if (file_test("-f", pathname_tmp)) {
[16:05:01.754]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.754]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:01.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.754]                         fi_tmp[["mtime"]])
[16:05:01.754]                     }
[16:05:01.754]                     tryCatch({
[16:05:01.754]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:01.754]                     }, error = function(ex) {
[16:05:01.754]                       msg <- conditionMessage(ex)
[16:05:01.754]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.754]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:01.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.754]                         fi_tmp[["mtime"]], msg)
[16:05:01.754]                       ex$message <- msg
[16:05:01.754]                       stop(ex)
[16:05:01.754]                     })
[16:05:01.754]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:01.754]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:01.754]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:01.754]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.754]                       fi <- file.info(pathname)
[16:05:01.754]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:01.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.754]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:01.754]                         fi[["size"]], fi[["mtime"]])
[16:05:01.754]                       stop(msg)
[16:05:01.754]                     }
[16:05:01.754]                     invisible(pathname)
[16:05:01.754]                   }
[16:05:01.754]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:01.754]                     rootPath = tempdir()) 
[16:05:01.754]                   {
[16:05:01.754]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:01.754]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:01.754]                       tmpdir = path, fileext = ".rds")
[16:05:01.754]                     save_rds(obj, file)
[16:05:01.754]                   }
[16:05:01.754]                   saveImmediateCondition(cond, path = "/tmp/Rtmpsnomsu/.future/immediateConditions")
[16:05:01.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.754]                   {
[16:05:01.754]                     inherits <- base::inherits
[16:05:01.754]                     invokeRestart <- base::invokeRestart
[16:05:01.754]                     is.null <- base::is.null
[16:05:01.754]                     muffled <- FALSE
[16:05:01.754]                     if (inherits(cond, "message")) {
[16:05:01.754]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:01.754]                       if (muffled) 
[16:05:01.754]                         invokeRestart("muffleMessage")
[16:05:01.754]                     }
[16:05:01.754]                     else if (inherits(cond, "warning")) {
[16:05:01.754]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:01.754]                       if (muffled) 
[16:05:01.754]                         invokeRestart("muffleWarning")
[16:05:01.754]                     }
[16:05:01.754]                     else if (inherits(cond, "condition")) {
[16:05:01.754]                       if (!is.null(pattern)) {
[16:05:01.754]                         computeRestarts <- base::computeRestarts
[16:05:01.754]                         grepl <- base::grepl
[16:05:01.754]                         restarts <- computeRestarts(cond)
[16:05:01.754]                         for (restart in restarts) {
[16:05:01.754]                           name <- restart$name
[16:05:01.754]                           if (is.null(name)) 
[16:05:01.754]                             next
[16:05:01.754]                           if (!grepl(pattern, name)) 
[16:05:01.754]                             next
[16:05:01.754]                           invokeRestart(restart)
[16:05:01.754]                           muffled <- TRUE
[16:05:01.754]                           break
[16:05:01.754]                         }
[16:05:01.754]                       }
[16:05:01.754]                     }
[16:05:01.754]                     invisible(muffled)
[16:05:01.754]                   }
[16:05:01.754]                   muffleCondition(cond)
[16:05:01.754]                 })
[16:05:01.754]             }))
[16:05:01.754]             future::FutureResult(value = ...future.value$value, 
[16:05:01.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.754]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.754]                     ...future.globalenv.names))
[16:05:01.754]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.754]         }, condition = base::local({
[16:05:01.754]             c <- base::c
[16:05:01.754]             inherits <- base::inherits
[16:05:01.754]             invokeRestart <- base::invokeRestart
[16:05:01.754]             length <- base::length
[16:05:01.754]             list <- base::list
[16:05:01.754]             seq.int <- base::seq.int
[16:05:01.754]             signalCondition <- base::signalCondition
[16:05:01.754]             sys.calls <- base::sys.calls
[16:05:01.754]             `[[` <- base::`[[`
[16:05:01.754]             `+` <- base::`+`
[16:05:01.754]             `<<-` <- base::`<<-`
[16:05:01.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.754]                   3L)]
[16:05:01.754]             }
[16:05:01.754]             function(cond) {
[16:05:01.754]                 is_error <- inherits(cond, "error")
[16:05:01.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.754]                   NULL)
[16:05:01.754]                 if (is_error) {
[16:05:01.754]                   sessionInformation <- function() {
[16:05:01.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.754]                       search = base::search(), system = base::Sys.info())
[16:05:01.754]                   }
[16:05:01.754]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.754]                     cond$call), session = sessionInformation(), 
[16:05:01.754]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.754]                   signalCondition(cond)
[16:05:01.754]                 }
[16:05:01.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.754]                 "immediateCondition"))) {
[16:05:01.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.754]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.754]                   if (TRUE && !signal) {
[16:05:01.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.754]                     {
[16:05:01.754]                       inherits <- base::inherits
[16:05:01.754]                       invokeRestart <- base::invokeRestart
[16:05:01.754]                       is.null <- base::is.null
[16:05:01.754]                       muffled <- FALSE
[16:05:01.754]                       if (inherits(cond, "message")) {
[16:05:01.754]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.754]                         if (muffled) 
[16:05:01.754]                           invokeRestart("muffleMessage")
[16:05:01.754]                       }
[16:05:01.754]                       else if (inherits(cond, "warning")) {
[16:05:01.754]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.754]                         if (muffled) 
[16:05:01.754]                           invokeRestart("muffleWarning")
[16:05:01.754]                       }
[16:05:01.754]                       else if (inherits(cond, "condition")) {
[16:05:01.754]                         if (!is.null(pattern)) {
[16:05:01.754]                           computeRestarts <- base::computeRestarts
[16:05:01.754]                           grepl <- base::grepl
[16:05:01.754]                           restarts <- computeRestarts(cond)
[16:05:01.754]                           for (restart in restarts) {
[16:05:01.754]                             name <- restart$name
[16:05:01.754]                             if (is.null(name)) 
[16:05:01.754]                               next
[16:05:01.754]                             if (!grepl(pattern, name)) 
[16:05:01.754]                               next
[16:05:01.754]                             invokeRestart(restart)
[16:05:01.754]                             muffled <- TRUE
[16:05:01.754]                             break
[16:05:01.754]                           }
[16:05:01.754]                         }
[16:05:01.754]                       }
[16:05:01.754]                       invisible(muffled)
[16:05:01.754]                     }
[16:05:01.754]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.754]                   }
[16:05:01.754]                 }
[16:05:01.754]                 else {
[16:05:01.754]                   if (TRUE) {
[16:05:01.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.754]                     {
[16:05:01.754]                       inherits <- base::inherits
[16:05:01.754]                       invokeRestart <- base::invokeRestart
[16:05:01.754]                       is.null <- base::is.null
[16:05:01.754]                       muffled <- FALSE
[16:05:01.754]                       if (inherits(cond, "message")) {
[16:05:01.754]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.754]                         if (muffled) 
[16:05:01.754]                           invokeRestart("muffleMessage")
[16:05:01.754]                       }
[16:05:01.754]                       else if (inherits(cond, "warning")) {
[16:05:01.754]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.754]                         if (muffled) 
[16:05:01.754]                           invokeRestart("muffleWarning")
[16:05:01.754]                       }
[16:05:01.754]                       else if (inherits(cond, "condition")) {
[16:05:01.754]                         if (!is.null(pattern)) {
[16:05:01.754]                           computeRestarts <- base::computeRestarts
[16:05:01.754]                           grepl <- base::grepl
[16:05:01.754]                           restarts <- computeRestarts(cond)
[16:05:01.754]                           for (restart in restarts) {
[16:05:01.754]                             name <- restart$name
[16:05:01.754]                             if (is.null(name)) 
[16:05:01.754]                               next
[16:05:01.754]                             if (!grepl(pattern, name)) 
[16:05:01.754]                               next
[16:05:01.754]                             invokeRestart(restart)
[16:05:01.754]                             muffled <- TRUE
[16:05:01.754]                             break
[16:05:01.754]                           }
[16:05:01.754]                         }
[16:05:01.754]                       }
[16:05:01.754]                       invisible(muffled)
[16:05:01.754]                     }
[16:05:01.754]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.754]                   }
[16:05:01.754]                 }
[16:05:01.754]             }
[16:05:01.754]         }))
[16:05:01.754]     }, error = function(ex) {
[16:05:01.754]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.754]                 ...future.rng), started = ...future.startTime, 
[16:05:01.754]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.754]             version = "1.8"), class = "FutureResult")
[16:05:01.754]     }, finally = {
[16:05:01.754]         if (!identical(...future.workdir, getwd())) 
[16:05:01.754]             setwd(...future.workdir)
[16:05:01.754]         {
[16:05:01.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.754]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.754]             }
[16:05:01.754]             base::options(...future.oldOptions)
[16:05:01.754]             if (.Platform$OS.type == "windows") {
[16:05:01.754]                 old_names <- names(...future.oldEnvVars)
[16:05:01.754]                 envs <- base::Sys.getenv()
[16:05:01.754]                 names <- names(envs)
[16:05:01.754]                 common <- intersect(names, old_names)
[16:05:01.754]                 added <- setdiff(names, old_names)
[16:05:01.754]                 removed <- setdiff(old_names, names)
[16:05:01.754]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.754]                   envs[common]]
[16:05:01.754]                 NAMES <- toupper(changed)
[16:05:01.754]                 args <- list()
[16:05:01.754]                 for (kk in seq_along(NAMES)) {
[16:05:01.754]                   name <- changed[[kk]]
[16:05:01.754]                   NAME <- NAMES[[kk]]
[16:05:01.754]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.754]                     next
[16:05:01.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.754]                 }
[16:05:01.754]                 NAMES <- toupper(added)
[16:05:01.754]                 for (kk in seq_along(NAMES)) {
[16:05:01.754]                   name <- added[[kk]]
[16:05:01.754]                   NAME <- NAMES[[kk]]
[16:05:01.754]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.754]                     next
[16:05:01.754]                   args[[name]] <- ""
[16:05:01.754]                 }
[16:05:01.754]                 NAMES <- toupper(removed)
[16:05:01.754]                 for (kk in seq_along(NAMES)) {
[16:05:01.754]                   name <- removed[[kk]]
[16:05:01.754]                   NAME <- NAMES[[kk]]
[16:05:01.754]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.754]                     next
[16:05:01.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.754]                 }
[16:05:01.754]                 if (length(args) > 0) 
[16:05:01.754]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.754]             }
[16:05:01.754]             else {
[16:05:01.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.754]             }
[16:05:01.754]             {
[16:05:01.754]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.754]                   0L) {
[16:05:01.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.754]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.754]                   base::options(opts)
[16:05:01.754]                 }
[16:05:01.754]                 {
[16:05:01.754]                   {
[16:05:01.754]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:01.754]                     NULL
[16:05:01.754]                   }
[16:05:01.754]                   options(future.plan = NULL)
[16:05:01.754]                   if (is.na(NA_character_)) 
[16:05:01.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.754]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:01.754]                     envir = parent.frame()) 
[16:05:01.754]                   {
[16:05:01.754]                     default_workers <- missing(workers)
[16:05:01.754]                     if (is.function(workers)) 
[16:05:01.754]                       workers <- workers()
[16:05:01.754]                     workers <- structure(as.integer(workers), 
[16:05:01.754]                       class = class(workers))
[16:05:01.754]                     stop_if_not(is.finite(workers), workers >= 
[16:05:01.754]                       1L)
[16:05:01.754]                     if ((workers == 1L && !inherits(workers, 
[16:05:01.754]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:01.754]                       if (default_workers) 
[16:05:01.754]                         supportsMulticore(warn = TRUE)
[16:05:01.754]                       return(sequential(..., envir = envir))
[16:05:01.754]                     }
[16:05:01.754]                     oopts <- options(mc.cores = workers)
[16:05:01.754]                     on.exit(options(oopts))
[16:05:01.754]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:01.754]                       envir = envir)
[16:05:01.754]                     if (!future$lazy) 
[16:05:01.754]                       future <- run(future)
[16:05:01.754]                     invisible(future)
[16:05:01.754]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.754]                 }
[16:05:01.754]             }
[16:05:01.754]         }
[16:05:01.754]     })
[16:05:01.754]     if (TRUE) {
[16:05:01.754]         base::sink(type = "output", split = FALSE)
[16:05:01.754]         if (TRUE) {
[16:05:01.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.754]         }
[16:05:01.754]         else {
[16:05:01.754]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.754]         }
[16:05:01.754]         base::close(...future.stdout)
[16:05:01.754]         ...future.stdout <- NULL
[16:05:01.754]     }
[16:05:01.754]     ...future.result$conditions <- ...future.conditions
[16:05:01.754]     ...future.result$finished <- base::Sys.time()
[16:05:01.754]     ...future.result
[16:05:01.754] }
[16:05:01.757] assign_globals() ...
[16:05:01.757] List of 1
[16:05:01.757]  $ x: list()
[16:05:01.757]  - attr(*, "where")=List of 1
[16:05:01.757]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.757]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.757]  - attr(*, "resolved")= logi TRUE
[16:05:01.757]  - attr(*, "total_size")= num 0
[16:05:01.757]  - attr(*, "already-done")= logi TRUE
[16:05:01.760] - copied ‘x’ to environment
[16:05:01.760] assign_globals() ... done
[16:05:01.760] requestCore(): workers = 2
[16:05:01.762] MulticoreFuture started
[16:05:01.763] - Launch lazy future ... done
[16:05:01.763] run() for ‘MulticoreFuture’ ... done
[16:05:01.763] result() for MulticoreFuture ...
[16:05:01.764] plan(): Setting new future strategy stack:
[16:05:01.764] List of future strategies:
[16:05:01.764] 1. sequential:
[16:05:01.764]    - args: function (..., envir = parent.frame())
[16:05:01.764]    - tweaked: FALSE
[16:05:01.764]    - call: NULL
[16:05:01.765] plan(): nbrOfWorkers() = 1
[16:05:01.768] plan(): Setting new future strategy stack:
[16:05:01.768] List of future strategies:
[16:05:01.768] 1. multicore:
[16:05:01.768]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.768]    - tweaked: FALSE
[16:05:01.768]    - call: plan(strategy)
[16:05:01.774] plan(): nbrOfWorkers() = 2
[16:05:01.775] result() for MulticoreFuture ...
[16:05:01.775] result() for MulticoreFuture ... done
[16:05:01.775] result() for MulticoreFuture ... done
[16:05:01.775] result() for MulticoreFuture ...
[16:05:01.775] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.776] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.776] Searching for globals...
[16:05:01.779] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:01.779] Searching for globals ... DONE
[16:05:01.779] Resolving globals: TRUE
[16:05:01.779] Resolving any globals that are futures ...
[16:05:01.780] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:01.780] Resolving any globals that are futures ... DONE
[16:05:01.780] Resolving futures part of globals (recursively) ...
[16:05:01.781] resolve() on list ...
[16:05:01.781]  recursive: 99
[16:05:01.781]  length: 1
[16:05:01.781]  elements: ‘x’
[16:05:01.781]  length: 0 (resolved future 1)
[16:05:01.781] resolve() on list ... DONE
[16:05:01.781] - globals: [1] ‘x’
[16:05:01.781] Resolving futures part of globals (recursively) ... DONE
[16:05:01.782] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.782] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.782] - globals: [1] ‘x’
[16:05:01.782] 
[16:05:01.782] getGlobalsAndPackages() ... DONE
[16:05:01.785] run() for ‘Future’ ...
[16:05:01.786] - state: ‘created’
[16:05:01.786] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:01.790] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:01.790] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:01.790]   - Field: ‘label’
[16:05:01.790]   - Field: ‘local’
[16:05:01.791]   - Field: ‘owner’
[16:05:01.791]   - Field: ‘envir’
[16:05:01.791]   - Field: ‘workers’
[16:05:01.791]   - Field: ‘packages’
[16:05:01.791]   - Field: ‘gc’
[16:05:01.791]   - Field: ‘job’
[16:05:01.791]   - Field: ‘conditions’
[16:05:01.792]   - Field: ‘expr’
[16:05:01.792]   - Field: ‘uuid’
[16:05:01.792]   - Field: ‘seed’
[16:05:01.792]   - Field: ‘version’
[16:05:01.792]   - Field: ‘result’
[16:05:01.792]   - Field: ‘asynchronous’
[16:05:01.792]   - Field: ‘calls’
[16:05:01.792]   - Field: ‘globals’
[16:05:01.793]   - Field: ‘stdout’
[16:05:01.793]   - Field: ‘earlySignal’
[16:05:01.793]   - Field: ‘lazy’
[16:05:01.793]   - Field: ‘state’
[16:05:01.793] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:01.793] - Launch lazy future ...
[16:05:01.794] Packages needed by the future expression (n = 0): <none>
[16:05:01.794] Packages needed by future strategies (n = 0): <none>
[16:05:01.794] {
[16:05:01.794]     {
[16:05:01.794]         {
[16:05:01.794]             ...future.startTime <- base::Sys.time()
[16:05:01.794]             {
[16:05:01.794]                 {
[16:05:01.794]                   {
[16:05:01.794]                     {
[16:05:01.794]                       base::local({
[16:05:01.794]                         has_future <- base::requireNamespace("future", 
[16:05:01.794]                           quietly = TRUE)
[16:05:01.794]                         if (has_future) {
[16:05:01.794]                           ns <- base::getNamespace("future")
[16:05:01.794]                           version <- ns[[".package"]][["version"]]
[16:05:01.794]                           if (is.null(version)) 
[16:05:01.794]                             version <- utils::packageVersion("future")
[16:05:01.794]                         }
[16:05:01.794]                         else {
[16:05:01.794]                           version <- NULL
[16:05:01.794]                         }
[16:05:01.794]                         if (!has_future || version < "1.8.0") {
[16:05:01.794]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.794]                             "", base::R.version$version.string), 
[16:05:01.794]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:01.794]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.794]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.794]                               "release", "version")], collapse = " "), 
[16:05:01.794]                             hostname = base::Sys.info()[["nodename"]])
[16:05:01.794]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.794]                             info)
[16:05:01.794]                           info <- base::paste(info, collapse = "; ")
[16:05:01.794]                           if (!has_future) {
[16:05:01.794]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.794]                               info)
[16:05:01.794]                           }
[16:05:01.794]                           else {
[16:05:01.794]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.794]                               info, version)
[16:05:01.794]                           }
[16:05:01.794]                           base::stop(msg)
[16:05:01.794]                         }
[16:05:01.794]                       })
[16:05:01.794]                     }
[16:05:01.794]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:01.794]                     base::options(mc.cores = 1L)
[16:05:01.794]                   }
[16:05:01.794]                   options(future.plan = NULL)
[16:05:01.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.794]                 }
[16:05:01.794]                 ...future.workdir <- getwd()
[16:05:01.794]             }
[16:05:01.794]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.794]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.794]         }
[16:05:01.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.794]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.794]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.794]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.794]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.794]             base::names(...future.oldOptions))
[16:05:01.794]     }
[16:05:01.794]     if (FALSE) {
[16:05:01.794]     }
[16:05:01.794]     else {
[16:05:01.794]         if (TRUE) {
[16:05:01.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.794]                 open = "w")
[16:05:01.794]         }
[16:05:01.794]         else {
[16:05:01.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.794]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.794]         }
[16:05:01.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.794]             base::sink(type = "output", split = FALSE)
[16:05:01.794]             base::close(...future.stdout)
[16:05:01.794]         }, add = TRUE)
[16:05:01.794]     }
[16:05:01.794]     ...future.frame <- base::sys.nframe()
[16:05:01.794]     ...future.conditions <- base::list()
[16:05:01.794]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.794]     if (FALSE) {
[16:05:01.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.794]     }
[16:05:01.794]     ...future.result <- base::tryCatch({
[16:05:01.794]         base::withCallingHandlers({
[16:05:01.794]             ...future.value <- base::withVisible(base::local({
[16:05:01.794]                 withCallingHandlers({
[16:05:01.794]                   {
[16:05:01.794]                     x["a"] <- list(1)
[16:05:01.794]                     x
[16:05:01.794]                   }
[16:05:01.794]                 }, immediateCondition = function(cond) {
[16:05:01.794]                   save_rds <- function (object, pathname, ...) 
[16:05:01.794]                   {
[16:05:01.794]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:01.794]                     if (file_test("-f", pathname_tmp)) {
[16:05:01.794]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.794]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:01.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.794]                         fi_tmp[["mtime"]])
[16:05:01.794]                     }
[16:05:01.794]                     tryCatch({
[16:05:01.794]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:01.794]                     }, error = function(ex) {
[16:05:01.794]                       msg <- conditionMessage(ex)
[16:05:01.794]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.794]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:01.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.794]                         fi_tmp[["mtime"]], msg)
[16:05:01.794]                       ex$message <- msg
[16:05:01.794]                       stop(ex)
[16:05:01.794]                     })
[16:05:01.794]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:01.794]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:01.794]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:01.794]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.794]                       fi <- file.info(pathname)
[16:05:01.794]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:01.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.794]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:01.794]                         fi[["size"]], fi[["mtime"]])
[16:05:01.794]                       stop(msg)
[16:05:01.794]                     }
[16:05:01.794]                     invisible(pathname)
[16:05:01.794]                   }
[16:05:01.794]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:01.794]                     rootPath = tempdir()) 
[16:05:01.794]                   {
[16:05:01.794]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:01.794]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:01.794]                       tmpdir = path, fileext = ".rds")
[16:05:01.794]                     save_rds(obj, file)
[16:05:01.794]                   }
[16:05:01.794]                   saveImmediateCondition(cond, path = "/tmp/Rtmpsnomsu/.future/immediateConditions")
[16:05:01.794]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.794]                   {
[16:05:01.794]                     inherits <- base::inherits
[16:05:01.794]                     invokeRestart <- base::invokeRestart
[16:05:01.794]                     is.null <- base::is.null
[16:05:01.794]                     muffled <- FALSE
[16:05:01.794]                     if (inherits(cond, "message")) {
[16:05:01.794]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:01.794]                       if (muffled) 
[16:05:01.794]                         invokeRestart("muffleMessage")
[16:05:01.794]                     }
[16:05:01.794]                     else if (inherits(cond, "warning")) {
[16:05:01.794]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:01.794]                       if (muffled) 
[16:05:01.794]                         invokeRestart("muffleWarning")
[16:05:01.794]                     }
[16:05:01.794]                     else if (inherits(cond, "condition")) {
[16:05:01.794]                       if (!is.null(pattern)) {
[16:05:01.794]                         computeRestarts <- base::computeRestarts
[16:05:01.794]                         grepl <- base::grepl
[16:05:01.794]                         restarts <- computeRestarts(cond)
[16:05:01.794]                         for (restart in restarts) {
[16:05:01.794]                           name <- restart$name
[16:05:01.794]                           if (is.null(name)) 
[16:05:01.794]                             next
[16:05:01.794]                           if (!grepl(pattern, name)) 
[16:05:01.794]                             next
[16:05:01.794]                           invokeRestart(restart)
[16:05:01.794]                           muffled <- TRUE
[16:05:01.794]                           break
[16:05:01.794]                         }
[16:05:01.794]                       }
[16:05:01.794]                     }
[16:05:01.794]                     invisible(muffled)
[16:05:01.794]                   }
[16:05:01.794]                   muffleCondition(cond)
[16:05:01.794]                 })
[16:05:01.794]             }))
[16:05:01.794]             future::FutureResult(value = ...future.value$value, 
[16:05:01.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.794]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.794]                     ...future.globalenv.names))
[16:05:01.794]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.794]         }, condition = base::local({
[16:05:01.794]             c <- base::c
[16:05:01.794]             inherits <- base::inherits
[16:05:01.794]             invokeRestart <- base::invokeRestart
[16:05:01.794]             length <- base::length
[16:05:01.794]             list <- base::list
[16:05:01.794]             seq.int <- base::seq.int
[16:05:01.794]             signalCondition <- base::signalCondition
[16:05:01.794]             sys.calls <- base::sys.calls
[16:05:01.794]             `[[` <- base::`[[`
[16:05:01.794]             `+` <- base::`+`
[16:05:01.794]             `<<-` <- base::`<<-`
[16:05:01.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.794]                   3L)]
[16:05:01.794]             }
[16:05:01.794]             function(cond) {
[16:05:01.794]                 is_error <- inherits(cond, "error")
[16:05:01.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.794]                   NULL)
[16:05:01.794]                 if (is_error) {
[16:05:01.794]                   sessionInformation <- function() {
[16:05:01.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.794]                       search = base::search(), system = base::Sys.info())
[16:05:01.794]                   }
[16:05:01.794]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.794]                     cond$call), session = sessionInformation(), 
[16:05:01.794]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.794]                   signalCondition(cond)
[16:05:01.794]                 }
[16:05:01.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.794]                 "immediateCondition"))) {
[16:05:01.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.794]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.794]                   if (TRUE && !signal) {
[16:05:01.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.794]                     {
[16:05:01.794]                       inherits <- base::inherits
[16:05:01.794]                       invokeRestart <- base::invokeRestart
[16:05:01.794]                       is.null <- base::is.null
[16:05:01.794]                       muffled <- FALSE
[16:05:01.794]                       if (inherits(cond, "message")) {
[16:05:01.794]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.794]                         if (muffled) 
[16:05:01.794]                           invokeRestart("muffleMessage")
[16:05:01.794]                       }
[16:05:01.794]                       else if (inherits(cond, "warning")) {
[16:05:01.794]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.794]                         if (muffled) 
[16:05:01.794]                           invokeRestart("muffleWarning")
[16:05:01.794]                       }
[16:05:01.794]                       else if (inherits(cond, "condition")) {
[16:05:01.794]                         if (!is.null(pattern)) {
[16:05:01.794]                           computeRestarts <- base::computeRestarts
[16:05:01.794]                           grepl <- base::grepl
[16:05:01.794]                           restarts <- computeRestarts(cond)
[16:05:01.794]                           for (restart in restarts) {
[16:05:01.794]                             name <- restart$name
[16:05:01.794]                             if (is.null(name)) 
[16:05:01.794]                               next
[16:05:01.794]                             if (!grepl(pattern, name)) 
[16:05:01.794]                               next
[16:05:01.794]                             invokeRestart(restart)
[16:05:01.794]                             muffled <- TRUE
[16:05:01.794]                             break
[16:05:01.794]                           }
[16:05:01.794]                         }
[16:05:01.794]                       }
[16:05:01.794]                       invisible(muffled)
[16:05:01.794]                     }
[16:05:01.794]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.794]                   }
[16:05:01.794]                 }
[16:05:01.794]                 else {
[16:05:01.794]                   if (TRUE) {
[16:05:01.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.794]                     {
[16:05:01.794]                       inherits <- base::inherits
[16:05:01.794]                       invokeRestart <- base::invokeRestart
[16:05:01.794]                       is.null <- base::is.null
[16:05:01.794]                       muffled <- FALSE
[16:05:01.794]                       if (inherits(cond, "message")) {
[16:05:01.794]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.794]                         if (muffled) 
[16:05:01.794]                           invokeRestart("muffleMessage")
[16:05:01.794]                       }
[16:05:01.794]                       else if (inherits(cond, "warning")) {
[16:05:01.794]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.794]                         if (muffled) 
[16:05:01.794]                           invokeRestart("muffleWarning")
[16:05:01.794]                       }
[16:05:01.794]                       else if (inherits(cond, "condition")) {
[16:05:01.794]                         if (!is.null(pattern)) {
[16:05:01.794]                           computeRestarts <- base::computeRestarts
[16:05:01.794]                           grepl <- base::grepl
[16:05:01.794]                           restarts <- computeRestarts(cond)
[16:05:01.794]                           for (restart in restarts) {
[16:05:01.794]                             name <- restart$name
[16:05:01.794]                             if (is.null(name)) 
[16:05:01.794]                               next
[16:05:01.794]                             if (!grepl(pattern, name)) 
[16:05:01.794]                               next
[16:05:01.794]                             invokeRestart(restart)
[16:05:01.794]                             muffled <- TRUE
[16:05:01.794]                             break
[16:05:01.794]                           }
[16:05:01.794]                         }
[16:05:01.794]                       }
[16:05:01.794]                       invisible(muffled)
[16:05:01.794]                     }
[16:05:01.794]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.794]                   }
[16:05:01.794]                 }
[16:05:01.794]             }
[16:05:01.794]         }))
[16:05:01.794]     }, error = function(ex) {
[16:05:01.794]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.794]                 ...future.rng), started = ...future.startTime, 
[16:05:01.794]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.794]             version = "1.8"), class = "FutureResult")
[16:05:01.794]     }, finally = {
[16:05:01.794]         if (!identical(...future.workdir, getwd())) 
[16:05:01.794]             setwd(...future.workdir)
[16:05:01.794]         {
[16:05:01.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.794]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.794]             }
[16:05:01.794]             base::options(...future.oldOptions)
[16:05:01.794]             if (.Platform$OS.type == "windows") {
[16:05:01.794]                 old_names <- names(...future.oldEnvVars)
[16:05:01.794]                 envs <- base::Sys.getenv()
[16:05:01.794]                 names <- names(envs)
[16:05:01.794]                 common <- intersect(names, old_names)
[16:05:01.794]                 added <- setdiff(names, old_names)
[16:05:01.794]                 removed <- setdiff(old_names, names)
[16:05:01.794]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.794]                   envs[common]]
[16:05:01.794]                 NAMES <- toupper(changed)
[16:05:01.794]                 args <- list()
[16:05:01.794]                 for (kk in seq_along(NAMES)) {
[16:05:01.794]                   name <- changed[[kk]]
[16:05:01.794]                   NAME <- NAMES[[kk]]
[16:05:01.794]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.794]                     next
[16:05:01.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.794]                 }
[16:05:01.794]                 NAMES <- toupper(added)
[16:05:01.794]                 for (kk in seq_along(NAMES)) {
[16:05:01.794]                   name <- added[[kk]]
[16:05:01.794]                   NAME <- NAMES[[kk]]
[16:05:01.794]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.794]                     next
[16:05:01.794]                   args[[name]] <- ""
[16:05:01.794]                 }
[16:05:01.794]                 NAMES <- toupper(removed)
[16:05:01.794]                 for (kk in seq_along(NAMES)) {
[16:05:01.794]                   name <- removed[[kk]]
[16:05:01.794]                   NAME <- NAMES[[kk]]
[16:05:01.794]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.794]                     next
[16:05:01.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.794]                 }
[16:05:01.794]                 if (length(args) > 0) 
[16:05:01.794]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.794]             }
[16:05:01.794]             else {
[16:05:01.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.794]             }
[16:05:01.794]             {
[16:05:01.794]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.794]                   0L) {
[16:05:01.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.794]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.794]                   base::options(opts)
[16:05:01.794]                 }
[16:05:01.794]                 {
[16:05:01.794]                   {
[16:05:01.794]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:01.794]                     NULL
[16:05:01.794]                   }
[16:05:01.794]                   options(future.plan = NULL)
[16:05:01.794]                   if (is.na(NA_character_)) 
[16:05:01.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.794]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:01.794]                     envir = parent.frame()) 
[16:05:01.794]                   {
[16:05:01.794]                     default_workers <- missing(workers)
[16:05:01.794]                     if (is.function(workers)) 
[16:05:01.794]                       workers <- workers()
[16:05:01.794]                     workers <- structure(as.integer(workers), 
[16:05:01.794]                       class = class(workers))
[16:05:01.794]                     stop_if_not(is.finite(workers), workers >= 
[16:05:01.794]                       1L)
[16:05:01.794]                     if ((workers == 1L && !inherits(workers, 
[16:05:01.794]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:01.794]                       if (default_workers) 
[16:05:01.794]                         supportsMulticore(warn = TRUE)
[16:05:01.794]                       return(sequential(..., envir = envir))
[16:05:01.794]                     }
[16:05:01.794]                     oopts <- options(mc.cores = workers)
[16:05:01.794]                     on.exit(options(oopts))
[16:05:01.794]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:01.794]                       envir = envir)
[16:05:01.794]                     if (!future$lazy) 
[16:05:01.794]                       future <- run(future)
[16:05:01.794]                     invisible(future)
[16:05:01.794]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.794]                 }
[16:05:01.794]             }
[16:05:01.794]         }
[16:05:01.794]     })
[16:05:01.794]     if (TRUE) {
[16:05:01.794]         base::sink(type = "output", split = FALSE)
[16:05:01.794]         if (TRUE) {
[16:05:01.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.794]         }
[16:05:01.794]         else {
[16:05:01.794]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.794]         }
[16:05:01.794]         base::close(...future.stdout)
[16:05:01.794]         ...future.stdout <- NULL
[16:05:01.794]     }
[16:05:01.794]     ...future.result$conditions <- ...future.conditions
[16:05:01.794]     ...future.result$finished <- base::Sys.time()
[16:05:01.794]     ...future.result
[16:05:01.794] }
[16:05:01.797] assign_globals() ...
[16:05:01.797] List of 1
[16:05:01.797]  $ x: list()
[16:05:01.797]  - attr(*, "where")=List of 1
[16:05:01.797]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.797]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.797]  - attr(*, "resolved")= logi TRUE
[16:05:01.797]  - attr(*, "total_size")= num 0
[16:05:01.797]  - attr(*, "already-done")= logi TRUE
[16:05:01.800] - copied ‘x’ to environment
[16:05:01.800] assign_globals() ... done
[16:05:01.800] requestCore(): workers = 2
[16:05:01.802] MulticoreFuture started
[16:05:01.802] - Launch lazy future ... done
[16:05:01.803] run() for ‘MulticoreFuture’ ... done
[16:05:01.803] result() for MulticoreFuture ...
[16:05:01.803] plan(): Setting new future strategy stack:
[16:05:01.804] List of future strategies:
[16:05:01.804] 1. sequential:
[16:05:01.804]    - args: function (..., envir = parent.frame())
[16:05:01.804]    - tweaked: FALSE
[16:05:01.804]    - call: NULL
[16:05:01.804] plan(): nbrOfWorkers() = 1
[16:05:01.807] plan(): Setting new future strategy stack:
[16:05:01.807] List of future strategies:
[16:05:01.807] 1. multicore:
[16:05:01.807]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.807]    - tweaked: FALSE
[16:05:01.807]    - call: plan(strategy)
[16:05:01.812] plan(): nbrOfWorkers() = 2
[16:05:01.813] result() for MulticoreFuture ...
[16:05:01.813] result() for MulticoreFuture ... done
[16:05:01.813] result() for MulticoreFuture ... done
[16:05:01.813] result() for MulticoreFuture ...
[16:05:01.813] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.814] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.814] Searching for globals...
[16:05:01.817] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:01.818] Searching for globals ... DONE
[16:05:01.818] Resolving globals: TRUE
[16:05:01.818] Resolving any globals that are futures ...
[16:05:01.818] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:01.818] Resolving any globals that are futures ... DONE
[16:05:01.819] Resolving futures part of globals (recursively) ...
[16:05:01.819] resolve() on list ...
[16:05:01.819]  recursive: 99
[16:05:01.819]  length: 1
[16:05:01.819]  elements: ‘x’
[16:05:01.820]  length: 0 (resolved future 1)
[16:05:01.820] resolve() on list ... DONE
[16:05:01.820] - globals: [1] ‘x’
[16:05:01.820] Resolving futures part of globals (recursively) ... DONE
[16:05:01.820] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:01.821] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:01.821] - globals: [1] ‘x’
[16:05:01.821] 
[16:05:01.821] getGlobalsAndPackages() ... DONE
[16:05:01.821] run() for ‘Future’ ...
[16:05:01.821] - state: ‘created’
[16:05:01.822] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:01.826] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:01.826] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:01.826]   - Field: ‘label’
[16:05:01.826]   - Field: ‘local’
[16:05:01.826]   - Field: ‘owner’
[16:05:01.827]   - Field: ‘envir’
[16:05:01.827]   - Field: ‘workers’
[16:05:01.827]   - Field: ‘packages’
[16:05:01.827]   - Field: ‘gc’
[16:05:01.827]   - Field: ‘job’
[16:05:01.827]   - Field: ‘conditions’
[16:05:01.827]   - Field: ‘expr’
[16:05:01.827]   - Field: ‘uuid’
[16:05:01.827]   - Field: ‘seed’
[16:05:01.828]   - Field: ‘version’
[16:05:01.828]   - Field: ‘result’
[16:05:01.828]   - Field: ‘asynchronous’
[16:05:01.828]   - Field: ‘calls’
[16:05:01.828]   - Field: ‘globals’
[16:05:01.828]   - Field: ‘stdout’
[16:05:01.828]   - Field: ‘earlySignal’
[16:05:01.828]   - Field: ‘lazy’
[16:05:01.829]   - Field: ‘state’
[16:05:01.829] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:01.829] - Launch lazy future ...
[16:05:01.829] Packages needed by the future expression (n = 0): <none>
[16:05:01.829] Packages needed by future strategies (n = 0): <none>
[16:05:01.830] {
[16:05:01.830]     {
[16:05:01.830]         {
[16:05:01.830]             ...future.startTime <- base::Sys.time()
[16:05:01.830]             {
[16:05:01.830]                 {
[16:05:01.830]                   {
[16:05:01.830]                     {
[16:05:01.830]                       base::local({
[16:05:01.830]                         has_future <- base::requireNamespace("future", 
[16:05:01.830]                           quietly = TRUE)
[16:05:01.830]                         if (has_future) {
[16:05:01.830]                           ns <- base::getNamespace("future")
[16:05:01.830]                           version <- ns[[".package"]][["version"]]
[16:05:01.830]                           if (is.null(version)) 
[16:05:01.830]                             version <- utils::packageVersion("future")
[16:05:01.830]                         }
[16:05:01.830]                         else {
[16:05:01.830]                           version <- NULL
[16:05:01.830]                         }
[16:05:01.830]                         if (!has_future || version < "1.8.0") {
[16:05:01.830]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.830]                             "", base::R.version$version.string), 
[16:05:01.830]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:01.830]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.830]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.830]                               "release", "version")], collapse = " "), 
[16:05:01.830]                             hostname = base::Sys.info()[["nodename"]])
[16:05:01.830]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.830]                             info)
[16:05:01.830]                           info <- base::paste(info, collapse = "; ")
[16:05:01.830]                           if (!has_future) {
[16:05:01.830]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.830]                               info)
[16:05:01.830]                           }
[16:05:01.830]                           else {
[16:05:01.830]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.830]                               info, version)
[16:05:01.830]                           }
[16:05:01.830]                           base::stop(msg)
[16:05:01.830]                         }
[16:05:01.830]                       })
[16:05:01.830]                     }
[16:05:01.830]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:01.830]                     base::options(mc.cores = 1L)
[16:05:01.830]                   }
[16:05:01.830]                   options(future.plan = NULL)
[16:05:01.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.830]                 }
[16:05:01.830]                 ...future.workdir <- getwd()
[16:05:01.830]             }
[16:05:01.830]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.830]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.830]         }
[16:05:01.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.830]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.830]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.830]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.830]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.830]             base::names(...future.oldOptions))
[16:05:01.830]     }
[16:05:01.830]     if (FALSE) {
[16:05:01.830]     }
[16:05:01.830]     else {
[16:05:01.830]         if (TRUE) {
[16:05:01.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.830]                 open = "w")
[16:05:01.830]         }
[16:05:01.830]         else {
[16:05:01.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.830]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.830]         }
[16:05:01.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.830]             base::sink(type = "output", split = FALSE)
[16:05:01.830]             base::close(...future.stdout)
[16:05:01.830]         }, add = TRUE)
[16:05:01.830]     }
[16:05:01.830]     ...future.frame <- base::sys.nframe()
[16:05:01.830]     ...future.conditions <- base::list()
[16:05:01.830]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.830]     if (FALSE) {
[16:05:01.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.830]     }
[16:05:01.830]     ...future.result <- base::tryCatch({
[16:05:01.830]         base::withCallingHandlers({
[16:05:01.830]             ...future.value <- base::withVisible(base::local({
[16:05:01.830]                 withCallingHandlers({
[16:05:01.830]                   {
[16:05:01.830]                     x["a"] <- list(1)
[16:05:01.830]                     x
[16:05:01.830]                   }
[16:05:01.830]                 }, immediateCondition = function(cond) {
[16:05:01.830]                   save_rds <- function (object, pathname, ...) 
[16:05:01.830]                   {
[16:05:01.830]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:01.830]                     if (file_test("-f", pathname_tmp)) {
[16:05:01.830]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.830]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:01.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.830]                         fi_tmp[["mtime"]])
[16:05:01.830]                     }
[16:05:01.830]                     tryCatch({
[16:05:01.830]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:01.830]                     }, error = function(ex) {
[16:05:01.830]                       msg <- conditionMessage(ex)
[16:05:01.830]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.830]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:01.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.830]                         fi_tmp[["mtime"]], msg)
[16:05:01.830]                       ex$message <- msg
[16:05:01.830]                       stop(ex)
[16:05:01.830]                     })
[16:05:01.830]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:01.830]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:01.830]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:01.830]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.830]                       fi <- file.info(pathname)
[16:05:01.830]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:01.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.830]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:01.830]                         fi[["size"]], fi[["mtime"]])
[16:05:01.830]                       stop(msg)
[16:05:01.830]                     }
[16:05:01.830]                     invisible(pathname)
[16:05:01.830]                   }
[16:05:01.830]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:01.830]                     rootPath = tempdir()) 
[16:05:01.830]                   {
[16:05:01.830]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:01.830]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:01.830]                       tmpdir = path, fileext = ".rds")
[16:05:01.830]                     save_rds(obj, file)
[16:05:01.830]                   }
[16:05:01.830]                   saveImmediateCondition(cond, path = "/tmp/Rtmpsnomsu/.future/immediateConditions")
[16:05:01.830]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.830]                   {
[16:05:01.830]                     inherits <- base::inherits
[16:05:01.830]                     invokeRestart <- base::invokeRestart
[16:05:01.830]                     is.null <- base::is.null
[16:05:01.830]                     muffled <- FALSE
[16:05:01.830]                     if (inherits(cond, "message")) {
[16:05:01.830]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:01.830]                       if (muffled) 
[16:05:01.830]                         invokeRestart("muffleMessage")
[16:05:01.830]                     }
[16:05:01.830]                     else if (inherits(cond, "warning")) {
[16:05:01.830]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:01.830]                       if (muffled) 
[16:05:01.830]                         invokeRestart("muffleWarning")
[16:05:01.830]                     }
[16:05:01.830]                     else if (inherits(cond, "condition")) {
[16:05:01.830]                       if (!is.null(pattern)) {
[16:05:01.830]                         computeRestarts <- base::computeRestarts
[16:05:01.830]                         grepl <- base::grepl
[16:05:01.830]                         restarts <- computeRestarts(cond)
[16:05:01.830]                         for (restart in restarts) {
[16:05:01.830]                           name <- restart$name
[16:05:01.830]                           if (is.null(name)) 
[16:05:01.830]                             next
[16:05:01.830]                           if (!grepl(pattern, name)) 
[16:05:01.830]                             next
[16:05:01.830]                           invokeRestart(restart)
[16:05:01.830]                           muffled <- TRUE
[16:05:01.830]                           break
[16:05:01.830]                         }
[16:05:01.830]                       }
[16:05:01.830]                     }
[16:05:01.830]                     invisible(muffled)
[16:05:01.830]                   }
[16:05:01.830]                   muffleCondition(cond)
[16:05:01.830]                 })
[16:05:01.830]             }))
[16:05:01.830]             future::FutureResult(value = ...future.value$value, 
[16:05:01.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.830]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.830]                     ...future.globalenv.names))
[16:05:01.830]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.830]         }, condition = base::local({
[16:05:01.830]             c <- base::c
[16:05:01.830]             inherits <- base::inherits
[16:05:01.830]             invokeRestart <- base::invokeRestart
[16:05:01.830]             length <- base::length
[16:05:01.830]             list <- base::list
[16:05:01.830]             seq.int <- base::seq.int
[16:05:01.830]             signalCondition <- base::signalCondition
[16:05:01.830]             sys.calls <- base::sys.calls
[16:05:01.830]             `[[` <- base::`[[`
[16:05:01.830]             `+` <- base::`+`
[16:05:01.830]             `<<-` <- base::`<<-`
[16:05:01.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.830]                   3L)]
[16:05:01.830]             }
[16:05:01.830]             function(cond) {
[16:05:01.830]                 is_error <- inherits(cond, "error")
[16:05:01.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.830]                   NULL)
[16:05:01.830]                 if (is_error) {
[16:05:01.830]                   sessionInformation <- function() {
[16:05:01.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.830]                       search = base::search(), system = base::Sys.info())
[16:05:01.830]                   }
[16:05:01.830]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.830]                     cond$call), session = sessionInformation(), 
[16:05:01.830]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.830]                   signalCondition(cond)
[16:05:01.830]                 }
[16:05:01.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.830]                 "immediateCondition"))) {
[16:05:01.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.830]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.830]                   if (TRUE && !signal) {
[16:05:01.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.830]                     {
[16:05:01.830]                       inherits <- base::inherits
[16:05:01.830]                       invokeRestart <- base::invokeRestart
[16:05:01.830]                       is.null <- base::is.null
[16:05:01.830]                       muffled <- FALSE
[16:05:01.830]                       if (inherits(cond, "message")) {
[16:05:01.830]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.830]                         if (muffled) 
[16:05:01.830]                           invokeRestart("muffleMessage")
[16:05:01.830]                       }
[16:05:01.830]                       else if (inherits(cond, "warning")) {
[16:05:01.830]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.830]                         if (muffled) 
[16:05:01.830]                           invokeRestart("muffleWarning")
[16:05:01.830]                       }
[16:05:01.830]                       else if (inherits(cond, "condition")) {
[16:05:01.830]                         if (!is.null(pattern)) {
[16:05:01.830]                           computeRestarts <- base::computeRestarts
[16:05:01.830]                           grepl <- base::grepl
[16:05:01.830]                           restarts <- computeRestarts(cond)
[16:05:01.830]                           for (restart in restarts) {
[16:05:01.830]                             name <- restart$name
[16:05:01.830]                             if (is.null(name)) 
[16:05:01.830]                               next
[16:05:01.830]                             if (!grepl(pattern, name)) 
[16:05:01.830]                               next
[16:05:01.830]                             invokeRestart(restart)
[16:05:01.830]                             muffled <- TRUE
[16:05:01.830]                             break
[16:05:01.830]                           }
[16:05:01.830]                         }
[16:05:01.830]                       }
[16:05:01.830]                       invisible(muffled)
[16:05:01.830]                     }
[16:05:01.830]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.830]                   }
[16:05:01.830]                 }
[16:05:01.830]                 else {
[16:05:01.830]                   if (TRUE) {
[16:05:01.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.830]                     {
[16:05:01.830]                       inherits <- base::inherits
[16:05:01.830]                       invokeRestart <- base::invokeRestart
[16:05:01.830]                       is.null <- base::is.null
[16:05:01.830]                       muffled <- FALSE
[16:05:01.830]                       if (inherits(cond, "message")) {
[16:05:01.830]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.830]                         if (muffled) 
[16:05:01.830]                           invokeRestart("muffleMessage")
[16:05:01.830]                       }
[16:05:01.830]                       else if (inherits(cond, "warning")) {
[16:05:01.830]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.830]                         if (muffled) 
[16:05:01.830]                           invokeRestart("muffleWarning")
[16:05:01.830]                       }
[16:05:01.830]                       else if (inherits(cond, "condition")) {
[16:05:01.830]                         if (!is.null(pattern)) {
[16:05:01.830]                           computeRestarts <- base::computeRestarts
[16:05:01.830]                           grepl <- base::grepl
[16:05:01.830]                           restarts <- computeRestarts(cond)
[16:05:01.830]                           for (restart in restarts) {
[16:05:01.830]                             name <- restart$name
[16:05:01.830]                             if (is.null(name)) 
[16:05:01.830]                               next
[16:05:01.830]                             if (!grepl(pattern, name)) 
[16:05:01.830]                               next
[16:05:01.830]                             invokeRestart(restart)
[16:05:01.830]                             muffled <- TRUE
[16:05:01.830]                             break
[16:05:01.830]                           }
[16:05:01.830]                         }
[16:05:01.830]                       }
[16:05:01.830]                       invisible(muffled)
[16:05:01.830]                     }
[16:05:01.830]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.830]                   }
[16:05:01.830]                 }
[16:05:01.830]             }
[16:05:01.830]         }))
[16:05:01.830]     }, error = function(ex) {
[16:05:01.830]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.830]                 ...future.rng), started = ...future.startTime, 
[16:05:01.830]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.830]             version = "1.8"), class = "FutureResult")
[16:05:01.830]     }, finally = {
[16:05:01.830]         if (!identical(...future.workdir, getwd())) 
[16:05:01.830]             setwd(...future.workdir)
[16:05:01.830]         {
[16:05:01.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.830]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.830]             }
[16:05:01.830]             base::options(...future.oldOptions)
[16:05:01.830]             if (.Platform$OS.type == "windows") {
[16:05:01.830]                 old_names <- names(...future.oldEnvVars)
[16:05:01.830]                 envs <- base::Sys.getenv()
[16:05:01.830]                 names <- names(envs)
[16:05:01.830]                 common <- intersect(names, old_names)
[16:05:01.830]                 added <- setdiff(names, old_names)
[16:05:01.830]                 removed <- setdiff(old_names, names)
[16:05:01.830]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.830]                   envs[common]]
[16:05:01.830]                 NAMES <- toupper(changed)
[16:05:01.830]                 args <- list()
[16:05:01.830]                 for (kk in seq_along(NAMES)) {
[16:05:01.830]                   name <- changed[[kk]]
[16:05:01.830]                   NAME <- NAMES[[kk]]
[16:05:01.830]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.830]                     next
[16:05:01.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.830]                 }
[16:05:01.830]                 NAMES <- toupper(added)
[16:05:01.830]                 for (kk in seq_along(NAMES)) {
[16:05:01.830]                   name <- added[[kk]]
[16:05:01.830]                   NAME <- NAMES[[kk]]
[16:05:01.830]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.830]                     next
[16:05:01.830]                   args[[name]] <- ""
[16:05:01.830]                 }
[16:05:01.830]                 NAMES <- toupper(removed)
[16:05:01.830]                 for (kk in seq_along(NAMES)) {
[16:05:01.830]                   name <- removed[[kk]]
[16:05:01.830]                   NAME <- NAMES[[kk]]
[16:05:01.830]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.830]                     next
[16:05:01.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.830]                 }
[16:05:01.830]                 if (length(args) > 0) 
[16:05:01.830]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.830]             }
[16:05:01.830]             else {
[16:05:01.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.830]             }
[16:05:01.830]             {
[16:05:01.830]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.830]                   0L) {
[16:05:01.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.830]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.830]                   base::options(opts)
[16:05:01.830]                 }
[16:05:01.830]                 {
[16:05:01.830]                   {
[16:05:01.830]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:01.830]                     NULL
[16:05:01.830]                   }
[16:05:01.830]                   options(future.plan = NULL)
[16:05:01.830]                   if (is.na(NA_character_)) 
[16:05:01.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.830]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:01.830]                     envir = parent.frame()) 
[16:05:01.830]                   {
[16:05:01.830]                     default_workers <- missing(workers)
[16:05:01.830]                     if (is.function(workers)) 
[16:05:01.830]                       workers <- workers()
[16:05:01.830]                     workers <- structure(as.integer(workers), 
[16:05:01.830]                       class = class(workers))
[16:05:01.830]                     stop_if_not(is.finite(workers), workers >= 
[16:05:01.830]                       1L)
[16:05:01.830]                     if ((workers == 1L && !inherits(workers, 
[16:05:01.830]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:01.830]                       if (default_workers) 
[16:05:01.830]                         supportsMulticore(warn = TRUE)
[16:05:01.830]                       return(sequential(..., envir = envir))
[16:05:01.830]                     }
[16:05:01.830]                     oopts <- options(mc.cores = workers)
[16:05:01.830]                     on.exit(options(oopts))
[16:05:01.830]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:01.830]                       envir = envir)
[16:05:01.830]                     if (!future$lazy) 
[16:05:01.830]                       future <- run(future)
[16:05:01.830]                     invisible(future)
[16:05:01.830]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.830]                 }
[16:05:01.830]             }
[16:05:01.830]         }
[16:05:01.830]     })
[16:05:01.830]     if (TRUE) {
[16:05:01.830]         base::sink(type = "output", split = FALSE)
[16:05:01.830]         if (TRUE) {
[16:05:01.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.830]         }
[16:05:01.830]         else {
[16:05:01.830]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.830]         }
[16:05:01.830]         base::close(...future.stdout)
[16:05:01.830]         ...future.stdout <- NULL
[16:05:01.830]     }
[16:05:01.830]     ...future.result$conditions <- ...future.conditions
[16:05:01.830]     ...future.result$finished <- base::Sys.time()
[16:05:01.830]     ...future.result
[16:05:01.830] }
[16:05:01.833] assign_globals() ...
[16:05:01.833] List of 1
[16:05:01.833]  $ x: list()
[16:05:01.833]  - attr(*, "where")=List of 1
[16:05:01.833]   ..$ x:<environment: R_EmptyEnv> 
[16:05:01.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.833]  - attr(*, "resolved")= logi TRUE
[16:05:01.833]  - attr(*, "total_size")= num 0
[16:05:01.833]  - attr(*, "already-done")= logi TRUE
[16:05:01.838] - copied ‘x’ to environment
[16:05:01.839] assign_globals() ... done
[16:05:01.839] requestCore(): workers = 2
[16:05:01.841] MulticoreFuture started
[16:05:01.841] - Launch lazy future ... done
[16:05:01.842] run() for ‘MulticoreFuture’ ... done
[16:05:01.842] result() for MulticoreFuture ...
[16:05:01.842] plan(): Setting new future strategy stack:
[16:05:01.843] List of future strategies:
[16:05:01.843] 1. sequential:
[16:05:01.843]    - args: function (..., envir = parent.frame())
[16:05:01.843]    - tweaked: FALSE
[16:05:01.843]    - call: NULL
[16:05:01.844] plan(): nbrOfWorkers() = 1
[16:05:01.846] plan(): Setting new future strategy stack:
[16:05:01.846] List of future strategies:
[16:05:01.846] 1. multicore:
[16:05:01.846]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.846]    - tweaked: FALSE
[16:05:01.846]    - call: plan(strategy)
[16:05:01.852] plan(): nbrOfWorkers() = 2
[16:05:01.852] result() for MulticoreFuture ...
[16:05:01.853] result() for MulticoreFuture ... done
[16:05:01.853] result() for MulticoreFuture ... done
[16:05:01.853] result() for MulticoreFuture ...
[16:05:01.853] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.854] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.854] Searching for globals...
[16:05:01.857] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[16:05:01.858] Searching for globals ... DONE
[16:05:01.858] Resolving globals: TRUE
[16:05:01.858] Resolving any globals that are futures ...
[16:05:01.858] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[16:05:01.858] Resolving any globals that are futures ... DONE
[16:05:01.859] Resolving futures part of globals (recursively) ...
[16:05:01.859] resolve() on list ...
[16:05:01.859]  recursive: 99
[16:05:01.859]  length: 2
[16:05:01.859]  elements: ‘x’, ‘name’
[16:05:01.860]  length: 1 (resolved future 1)
[16:05:01.860]  length: 0 (resolved future 2)
[16:05:01.860] resolve() on list ... DONE
[16:05:01.860] - globals: [2] ‘x’, ‘name’
[16:05:01.860] Resolving futures part of globals (recursively) ... DONE
[16:05:01.860] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:01.861] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[16:05:01.861] - globals: [2] ‘x’, ‘name’
[16:05:01.861] 
[16:05:01.861] getGlobalsAndPackages() ... DONE
[16:05:01.862] run() for ‘Future’ ...
[16:05:01.862] - state: ‘created’
[16:05:01.862] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:01.866] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:01.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:01.867]   - Field: ‘label’
[16:05:01.867]   - Field: ‘local’
[16:05:01.867]   - Field: ‘owner’
[16:05:01.867]   - Field: ‘envir’
[16:05:01.867]   - Field: ‘workers’
[16:05:01.867]   - Field: ‘packages’
[16:05:01.868]   - Field: ‘gc’
[16:05:01.868]   - Field: ‘job’
[16:05:01.868]   - Field: ‘conditions’
[16:05:01.868]   - Field: ‘expr’
[16:05:01.868]   - Field: ‘uuid’
[16:05:01.868]   - Field: ‘seed’
[16:05:01.868]   - Field: ‘version’
[16:05:01.869]   - Field: ‘result’
[16:05:01.869]   - Field: ‘asynchronous’
[16:05:01.869]   - Field: ‘calls’
[16:05:01.869]   - Field: ‘globals’
[16:05:01.869]   - Field: ‘stdout’
[16:05:01.869]   - Field: ‘earlySignal’
[16:05:01.869]   - Field: ‘lazy’
[16:05:01.869]   - Field: ‘state’
[16:05:01.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:01.870] - Launch lazy future ...
[16:05:01.870] Packages needed by the future expression (n = 0): <none>
[16:05:01.870] Packages needed by future strategies (n = 0): <none>
[16:05:01.871] {
[16:05:01.871]     {
[16:05:01.871]         {
[16:05:01.871]             ...future.startTime <- base::Sys.time()
[16:05:01.871]             {
[16:05:01.871]                 {
[16:05:01.871]                   {
[16:05:01.871]                     {
[16:05:01.871]                       base::local({
[16:05:01.871]                         has_future <- base::requireNamespace("future", 
[16:05:01.871]                           quietly = TRUE)
[16:05:01.871]                         if (has_future) {
[16:05:01.871]                           ns <- base::getNamespace("future")
[16:05:01.871]                           version <- ns[[".package"]][["version"]]
[16:05:01.871]                           if (is.null(version)) 
[16:05:01.871]                             version <- utils::packageVersion("future")
[16:05:01.871]                         }
[16:05:01.871]                         else {
[16:05:01.871]                           version <- NULL
[16:05:01.871]                         }
[16:05:01.871]                         if (!has_future || version < "1.8.0") {
[16:05:01.871]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:01.871]                             "", base::R.version$version.string), 
[16:05:01.871]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:01.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:01.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:01.871]                               "release", "version")], collapse = " "), 
[16:05:01.871]                             hostname = base::Sys.info()[["nodename"]])
[16:05:01.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:01.871]                             info)
[16:05:01.871]                           info <- base::paste(info, collapse = "; ")
[16:05:01.871]                           if (!has_future) {
[16:05:01.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:01.871]                               info)
[16:05:01.871]                           }
[16:05:01.871]                           else {
[16:05:01.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:01.871]                               info, version)
[16:05:01.871]                           }
[16:05:01.871]                           base::stop(msg)
[16:05:01.871]                         }
[16:05:01.871]                       })
[16:05:01.871]                     }
[16:05:01.871]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:01.871]                     base::options(mc.cores = 1L)
[16:05:01.871]                   }
[16:05:01.871]                   options(future.plan = NULL)
[16:05:01.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:01.871]                 }
[16:05:01.871]                 ...future.workdir <- getwd()
[16:05:01.871]             }
[16:05:01.871]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:01.871]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:01.871]         }
[16:05:01.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:01.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:01.871]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:01.871]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:01.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:01.871]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:01.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:01.871]             base::names(...future.oldOptions))
[16:05:01.871]     }
[16:05:01.871]     if (FALSE) {
[16:05:01.871]     }
[16:05:01.871]     else {
[16:05:01.871]         if (TRUE) {
[16:05:01.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:01.871]                 open = "w")
[16:05:01.871]         }
[16:05:01.871]         else {
[16:05:01.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:01.871]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:01.871]         }
[16:05:01.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:01.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:01.871]             base::sink(type = "output", split = FALSE)
[16:05:01.871]             base::close(...future.stdout)
[16:05:01.871]         }, add = TRUE)
[16:05:01.871]     }
[16:05:01.871]     ...future.frame <- base::sys.nframe()
[16:05:01.871]     ...future.conditions <- base::list()
[16:05:01.871]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:01.871]     if (FALSE) {
[16:05:01.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:01.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:01.871]     }
[16:05:01.871]     ...future.result <- base::tryCatch({
[16:05:01.871]         base::withCallingHandlers({
[16:05:01.871]             ...future.value <- base::withVisible(base::local({
[16:05:01.871]                 withCallingHandlers({
[16:05:01.871]                   {
[16:05:01.871]                     x[name] <- list(1)
[16:05:01.871]                     x
[16:05:01.871]                   }
[16:05:01.871]                 }, immediateCondition = function(cond) {
[16:05:01.871]                   save_rds <- function (object, pathname, ...) 
[16:05:01.871]                   {
[16:05:01.871]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:01.871]                     if (file_test("-f", pathname_tmp)) {
[16:05:01.871]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.871]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:01.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.871]                         fi_tmp[["mtime"]])
[16:05:01.871]                     }
[16:05:01.871]                     tryCatch({
[16:05:01.871]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:01.871]                     }, error = function(ex) {
[16:05:01.871]                       msg <- conditionMessage(ex)
[16:05:01.871]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.871]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:01.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.871]                         fi_tmp[["mtime"]], msg)
[16:05:01.871]                       ex$message <- msg
[16:05:01.871]                       stop(ex)
[16:05:01.871]                     })
[16:05:01.871]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:01.871]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:01.871]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:01.871]                       fi_tmp <- file.info(pathname_tmp)
[16:05:01.871]                       fi <- file.info(pathname)
[16:05:01.871]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:01.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:01.871]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:01.871]                         fi[["size"]], fi[["mtime"]])
[16:05:01.871]                       stop(msg)
[16:05:01.871]                     }
[16:05:01.871]                     invisible(pathname)
[16:05:01.871]                   }
[16:05:01.871]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:01.871]                     rootPath = tempdir()) 
[16:05:01.871]                   {
[16:05:01.871]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:01.871]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:01.871]                       tmpdir = path, fileext = ".rds")
[16:05:01.871]                     save_rds(obj, file)
[16:05:01.871]                   }
[16:05:01.871]                   saveImmediateCondition(cond, path = "/tmp/Rtmpsnomsu/.future/immediateConditions")
[16:05:01.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.871]                   {
[16:05:01.871]                     inherits <- base::inherits
[16:05:01.871]                     invokeRestart <- base::invokeRestart
[16:05:01.871]                     is.null <- base::is.null
[16:05:01.871]                     muffled <- FALSE
[16:05:01.871]                     if (inherits(cond, "message")) {
[16:05:01.871]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:01.871]                       if (muffled) 
[16:05:01.871]                         invokeRestart("muffleMessage")
[16:05:01.871]                     }
[16:05:01.871]                     else if (inherits(cond, "warning")) {
[16:05:01.871]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:01.871]                       if (muffled) 
[16:05:01.871]                         invokeRestart("muffleWarning")
[16:05:01.871]                     }
[16:05:01.871]                     else if (inherits(cond, "condition")) {
[16:05:01.871]                       if (!is.null(pattern)) {
[16:05:01.871]                         computeRestarts <- base::computeRestarts
[16:05:01.871]                         grepl <- base::grepl
[16:05:01.871]                         restarts <- computeRestarts(cond)
[16:05:01.871]                         for (restart in restarts) {
[16:05:01.871]                           name <- restart$name
[16:05:01.871]                           if (is.null(name)) 
[16:05:01.871]                             next
[16:05:01.871]                           if (!grepl(pattern, name)) 
[16:05:01.871]                             next
[16:05:01.871]                           invokeRestart(restart)
[16:05:01.871]                           muffled <- TRUE
[16:05:01.871]                           break
[16:05:01.871]                         }
[16:05:01.871]                       }
[16:05:01.871]                     }
[16:05:01.871]                     invisible(muffled)
[16:05:01.871]                   }
[16:05:01.871]                   muffleCondition(cond)
[16:05:01.871]                 })
[16:05:01.871]             }))
[16:05:01.871]             future::FutureResult(value = ...future.value$value, 
[16:05:01.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.871]                   ...future.rng), globalenv = if (FALSE) 
[16:05:01.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:01.871]                     ...future.globalenv.names))
[16:05:01.871]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:01.871]         }, condition = base::local({
[16:05:01.871]             c <- base::c
[16:05:01.871]             inherits <- base::inherits
[16:05:01.871]             invokeRestart <- base::invokeRestart
[16:05:01.871]             length <- base::length
[16:05:01.871]             list <- base::list
[16:05:01.871]             seq.int <- base::seq.int
[16:05:01.871]             signalCondition <- base::signalCondition
[16:05:01.871]             sys.calls <- base::sys.calls
[16:05:01.871]             `[[` <- base::`[[`
[16:05:01.871]             `+` <- base::`+`
[16:05:01.871]             `<<-` <- base::`<<-`
[16:05:01.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:01.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:01.871]                   3L)]
[16:05:01.871]             }
[16:05:01.871]             function(cond) {
[16:05:01.871]                 is_error <- inherits(cond, "error")
[16:05:01.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:01.871]                   NULL)
[16:05:01.871]                 if (is_error) {
[16:05:01.871]                   sessionInformation <- function() {
[16:05:01.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:01.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:01.871]                       search = base::search(), system = base::Sys.info())
[16:05:01.871]                   }
[16:05:01.871]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:01.871]                     cond$call), session = sessionInformation(), 
[16:05:01.871]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:01.871]                   signalCondition(cond)
[16:05:01.871]                 }
[16:05:01.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:01.871]                 "immediateCondition"))) {
[16:05:01.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:01.871]                   ...future.conditions[[length(...future.conditions) + 
[16:05:01.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:01.871]                   if (TRUE && !signal) {
[16:05:01.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.871]                     {
[16:05:01.871]                       inherits <- base::inherits
[16:05:01.871]                       invokeRestart <- base::invokeRestart
[16:05:01.871]                       is.null <- base::is.null
[16:05:01.871]                       muffled <- FALSE
[16:05:01.871]                       if (inherits(cond, "message")) {
[16:05:01.871]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.871]                         if (muffled) 
[16:05:01.871]                           invokeRestart("muffleMessage")
[16:05:01.871]                       }
[16:05:01.871]                       else if (inherits(cond, "warning")) {
[16:05:01.871]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.871]                         if (muffled) 
[16:05:01.871]                           invokeRestart("muffleWarning")
[16:05:01.871]                       }
[16:05:01.871]                       else if (inherits(cond, "condition")) {
[16:05:01.871]                         if (!is.null(pattern)) {
[16:05:01.871]                           computeRestarts <- base::computeRestarts
[16:05:01.871]                           grepl <- base::grepl
[16:05:01.871]                           restarts <- computeRestarts(cond)
[16:05:01.871]                           for (restart in restarts) {
[16:05:01.871]                             name <- restart$name
[16:05:01.871]                             if (is.null(name)) 
[16:05:01.871]                               next
[16:05:01.871]                             if (!grepl(pattern, name)) 
[16:05:01.871]                               next
[16:05:01.871]                             invokeRestart(restart)
[16:05:01.871]                             muffled <- TRUE
[16:05:01.871]                             break
[16:05:01.871]                           }
[16:05:01.871]                         }
[16:05:01.871]                       }
[16:05:01.871]                       invisible(muffled)
[16:05:01.871]                     }
[16:05:01.871]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.871]                   }
[16:05:01.871]                 }
[16:05:01.871]                 else {
[16:05:01.871]                   if (TRUE) {
[16:05:01.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:01.871]                     {
[16:05:01.871]                       inherits <- base::inherits
[16:05:01.871]                       invokeRestart <- base::invokeRestart
[16:05:01.871]                       is.null <- base::is.null
[16:05:01.871]                       muffled <- FALSE
[16:05:01.871]                       if (inherits(cond, "message")) {
[16:05:01.871]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:01.871]                         if (muffled) 
[16:05:01.871]                           invokeRestart("muffleMessage")
[16:05:01.871]                       }
[16:05:01.871]                       else if (inherits(cond, "warning")) {
[16:05:01.871]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:01.871]                         if (muffled) 
[16:05:01.871]                           invokeRestart("muffleWarning")
[16:05:01.871]                       }
[16:05:01.871]                       else if (inherits(cond, "condition")) {
[16:05:01.871]                         if (!is.null(pattern)) {
[16:05:01.871]                           computeRestarts <- base::computeRestarts
[16:05:01.871]                           grepl <- base::grepl
[16:05:01.871]                           restarts <- computeRestarts(cond)
[16:05:01.871]                           for (restart in restarts) {
[16:05:01.871]                             name <- restart$name
[16:05:01.871]                             if (is.null(name)) 
[16:05:01.871]                               next
[16:05:01.871]                             if (!grepl(pattern, name)) 
[16:05:01.871]                               next
[16:05:01.871]                             invokeRestart(restart)
[16:05:01.871]                             muffled <- TRUE
[16:05:01.871]                             break
[16:05:01.871]                           }
[16:05:01.871]                         }
[16:05:01.871]                       }
[16:05:01.871]                       invisible(muffled)
[16:05:01.871]                     }
[16:05:01.871]                     muffleCondition(cond, pattern = "^muffle")
[16:05:01.871]                   }
[16:05:01.871]                 }
[16:05:01.871]             }
[16:05:01.871]         }))
[16:05:01.871]     }, error = function(ex) {
[16:05:01.871]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:01.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:01.871]                 ...future.rng), started = ...future.startTime, 
[16:05:01.871]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:01.871]             version = "1.8"), class = "FutureResult")
[16:05:01.871]     }, finally = {
[16:05:01.871]         if (!identical(...future.workdir, getwd())) 
[16:05:01.871]             setwd(...future.workdir)
[16:05:01.871]         {
[16:05:01.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:01.871]                 ...future.oldOptions$nwarnings <- NULL
[16:05:01.871]             }
[16:05:01.871]             base::options(...future.oldOptions)
[16:05:01.871]             if (.Platform$OS.type == "windows") {
[16:05:01.871]                 old_names <- names(...future.oldEnvVars)
[16:05:01.871]                 envs <- base::Sys.getenv()
[16:05:01.871]                 names <- names(envs)
[16:05:01.871]                 common <- intersect(names, old_names)
[16:05:01.871]                 added <- setdiff(names, old_names)
[16:05:01.871]                 removed <- setdiff(old_names, names)
[16:05:01.871]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:01.871]                   envs[common]]
[16:05:01.871]                 NAMES <- toupper(changed)
[16:05:01.871]                 args <- list()
[16:05:01.871]                 for (kk in seq_along(NAMES)) {
[16:05:01.871]                   name <- changed[[kk]]
[16:05:01.871]                   NAME <- NAMES[[kk]]
[16:05:01.871]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.871]                     next
[16:05:01.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.871]                 }
[16:05:01.871]                 NAMES <- toupper(added)
[16:05:01.871]                 for (kk in seq_along(NAMES)) {
[16:05:01.871]                   name <- added[[kk]]
[16:05:01.871]                   NAME <- NAMES[[kk]]
[16:05:01.871]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.871]                     next
[16:05:01.871]                   args[[name]] <- ""
[16:05:01.871]                 }
[16:05:01.871]                 NAMES <- toupper(removed)
[16:05:01.871]                 for (kk in seq_along(NAMES)) {
[16:05:01.871]                   name <- removed[[kk]]
[16:05:01.871]                   NAME <- NAMES[[kk]]
[16:05:01.871]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:01.871]                     next
[16:05:01.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:01.871]                 }
[16:05:01.871]                 if (length(args) > 0) 
[16:05:01.871]                   base::do.call(base::Sys.setenv, args = args)
[16:05:01.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:01.871]             }
[16:05:01.871]             else {
[16:05:01.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:01.871]             }
[16:05:01.871]             {
[16:05:01.871]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:01.871]                   0L) {
[16:05:01.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:01.871]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:01.871]                   base::options(opts)
[16:05:01.871]                 }
[16:05:01.871]                 {
[16:05:01.871]                   {
[16:05:01.871]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:01.871]                     NULL
[16:05:01.871]                   }
[16:05:01.871]                   options(future.plan = NULL)
[16:05:01.871]                   if (is.na(NA_character_)) 
[16:05:01.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:01.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:01.871]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:01.871]                     envir = parent.frame()) 
[16:05:01.871]                   {
[16:05:01.871]                     default_workers <- missing(workers)
[16:05:01.871]                     if (is.function(workers)) 
[16:05:01.871]                       workers <- workers()
[16:05:01.871]                     workers <- structure(as.integer(workers), 
[16:05:01.871]                       class = class(workers))
[16:05:01.871]                     stop_if_not(is.finite(workers), workers >= 
[16:05:01.871]                       1L)
[16:05:01.871]                     if ((workers == 1L && !inherits(workers, 
[16:05:01.871]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:01.871]                       if (default_workers) 
[16:05:01.871]                         supportsMulticore(warn = TRUE)
[16:05:01.871]                       return(sequential(..., envir = envir))
[16:05:01.871]                     }
[16:05:01.871]                     oopts <- options(mc.cores = workers)
[16:05:01.871]                     on.exit(options(oopts))
[16:05:01.871]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:01.871]                       envir = envir)
[16:05:01.871]                     if (!future$lazy) 
[16:05:01.871]                       future <- run(future)
[16:05:01.871]                     invisible(future)
[16:05:01.871]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:01.871]                 }
[16:05:01.871]             }
[16:05:01.871]         }
[16:05:01.871]     })
[16:05:01.871]     if (TRUE) {
[16:05:01.871]         base::sink(type = "output", split = FALSE)
[16:05:01.871]         if (TRUE) {
[16:05:01.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:01.871]         }
[16:05:01.871]         else {
[16:05:01.871]             ...future.result["stdout"] <- base::list(NULL)
[16:05:01.871]         }
[16:05:01.871]         base::close(...future.stdout)
[16:05:01.871]         ...future.stdout <- NULL
[16:05:01.871]     }
[16:05:01.871]     ...future.result$conditions <- ...future.conditions
[16:05:01.871]     ...future.result$finished <- base::Sys.time()
[16:05:01.871]     ...future.result
[16:05:01.871] }
[16:05:01.874] assign_globals() ...
[16:05:01.874] List of 2
[16:05:01.874]  $ x   : list()
[16:05:01.874]  $ name: chr "a"
[16:05:01.874]  - attr(*, "where")=List of 2
[16:05:01.874]   ..$ x   :<environment: R_EmptyEnv> 
[16:05:01.874]   ..$ name:<environment: R_EmptyEnv> 
[16:05:01.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:01.874]  - attr(*, "resolved")= logi TRUE
[16:05:01.874]  - attr(*, "total_size")= num 112
[16:05:01.874]  - attr(*, "already-done")= logi TRUE
[16:05:01.877] - copied ‘x’ to environment
[16:05:01.878] - copied ‘name’ to environment
[16:05:01.878] assign_globals() ... done
[16:05:01.878] requestCore(): workers = 2
[16:05:01.880] MulticoreFuture started
[16:05:01.880] - Launch lazy future ... done
[16:05:01.880] run() for ‘MulticoreFuture’ ... done
[16:05:01.881] result() for MulticoreFuture ...
[16:05:01.881] plan(): Setting new future strategy stack:
[16:05:01.881] List of future strategies:
[16:05:01.881] 1. sequential:
[16:05:01.881]    - args: function (..., envir = parent.frame())
[16:05:01.881]    - tweaked: FALSE
[16:05:01.881]    - call: NULL
[16:05:01.882] plan(): nbrOfWorkers() = 1
[16:05:01.884] plan(): Setting new future strategy stack:
[16:05:01.884] List of future strategies:
[16:05:01.884] 1. multicore:
[16:05:01.884]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:01.884]    - tweaked: FALSE
[16:05:01.884]    - call: plan(strategy)
[16:05:01.889] plan(): nbrOfWorkers() = 2
[16:05:01.890] result() for MulticoreFuture ...
[16:05:01.890] result() for MulticoreFuture ... done
[16:05:01.891] result() for MulticoreFuture ... done
[16:05:01.891] result() for MulticoreFuture ...
[16:05:01.891] result() for MulticoreFuture ... done
$a
[1] 1

- plan('multisession') ...
[16:05:01.892] plan(): Setting new future strategy stack:
[16:05:01.892] List of future strategies:
[16:05:01.892] 1. multisession:
[16:05:01.892]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:01.892]    - tweaked: FALSE
[16:05:01.892]    - call: plan(strategy)
[16:05:01.892] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:05:01.892] multisession:
[16:05:01.892] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:01.892] - tweaked: FALSE
[16:05:01.892] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:01.900] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:01.903] Not searching for globals
[16:05:01.904] - globals: [0] <none>
[16:05:01.904] getGlobalsAndPackages() ... DONE
[16:05:01.904] [local output] makeClusterPSOCK() ...
[16:05:01.950] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:05:01.952] [local output] Base port: 11351
[16:05:01.952] [local output] Getting setup options for 2 cluster nodes ...
[16:05:01.952] [local output]  - Node 1 of 2 ...
[16:05:01.952] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:01.953] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpsnomsu/worker.rank=1.parallelly.parent=85585.14e5130756642.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpsnomsu/worker.rank=1.parallelly.parent=85585.14e5130756642.pid")'’
[16:05:02.145] - Possible to infer worker's PID: TRUE
[16:05:02.145] [local output] Rscript port: 11351

[16:05:02.145] [local output]  - Node 2 of 2 ...
[16:05:02.146] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:02.146] [local output] Rscript port: 11351

[16:05:02.147] [local output] Getting setup options for 2 cluster nodes ... done
[16:05:02.147] [local output]  - Parallel setup requested for some PSOCK nodes
[16:05:02.147] [local output] Setting up PSOCK nodes in parallel
[16:05:02.147] List of 36
[16:05:02.147]  $ worker          : chr "localhost"
[16:05:02.147]   ..- attr(*, "localhost")= logi TRUE
[16:05:02.147]  $ master          : chr "localhost"
[16:05:02.147]  $ port            : int 11351
[16:05:02.147]  $ connectTimeout  : num 120
[16:05:02.147]  $ timeout         : num 2592000
[16:05:02.147]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:05:02.147]  $ homogeneous     : logi TRUE
[16:05:02.147]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:05:02.147]  $ rscript_envs    : NULL
[16:05:02.147]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:02.147]  $ rscript_startup : NULL
[16:05:02.147]  $ rscript_sh      : chr "sh"
[16:05:02.147]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:02.147]  $ methods         : logi TRUE
[16:05:02.147]  $ socketOptions   : chr "no-delay"
[16:05:02.147]  $ useXDR          : logi FALSE
[16:05:02.147]  $ outfile         : chr "/dev/null"
[16:05:02.147]  $ renice          : int NA
[16:05:02.147]  $ rshcmd          : NULL
[16:05:02.147]  $ user            : chr(0) 
[16:05:02.147]  $ revtunnel       : logi FALSE
[16:05:02.147]  $ rshlogfile      : NULL
[16:05:02.147]  $ rshopts         : chr(0) 
[16:05:02.147]  $ rank            : int 1
[16:05:02.147]  $ manual          : logi FALSE
[16:05:02.147]  $ dryrun          : logi FALSE
[16:05:02.147]  $ quiet           : logi FALSE
[16:05:02.147]  $ setup_strategy  : chr "parallel"
[16:05:02.147]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:02.147]  $ pidfile         : chr "/tmp/Rtmpsnomsu/worker.rank=1.parallelly.parent=85585.14e5130756642.pid"
[16:05:02.147]  $ rshcmd_label    : NULL
[16:05:02.147]  $ rsh_call        : NULL
[16:05:02.147]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:02.147]  $ localMachine    : logi TRUE
[16:05:02.147]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:05:02.147]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:05:02.147]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:05:02.147]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:05:02.147]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:05:02.147]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:05:02.147]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:05:02.147]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:05:02.147]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:05:02.147]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:05:02.147]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:05:02.147]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:05:02.147]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:05:02.147]  $ arguments       :List of 28
[16:05:02.147]   ..$ worker          : chr "localhost"
[16:05:02.147]   ..$ master          : NULL
[16:05:02.147]   ..$ port            : int 11351
[16:05:02.147]   ..$ connectTimeout  : num 120
[16:05:02.147]   ..$ timeout         : num 2592000
[16:05:02.147]   ..$ rscript         : NULL
[16:05:02.147]   ..$ homogeneous     : NULL
[16:05:02.147]   ..$ rscript_args    : NULL
[16:05:02.147]   ..$ rscript_envs    : NULL
[16:05:02.147]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:02.147]   ..$ rscript_startup : NULL
[16:05:02.147]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:05:02.147]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:02.147]   ..$ methods         : logi TRUE
[16:05:02.147]   ..$ socketOptions   : chr "no-delay"
[16:05:02.147]   ..$ useXDR          : logi FALSE
[16:05:02.147]   ..$ outfile         : chr "/dev/null"
[16:05:02.147]   ..$ renice          : int NA
[16:05:02.147]   ..$ rshcmd          : NULL
[16:05:02.147]   ..$ user            : NULL
[16:05:02.147]   ..$ revtunnel       : logi NA
[16:05:02.147]   ..$ rshlogfile      : NULL
[16:05:02.147]   ..$ rshopts         : NULL
[16:05:02.147]   ..$ rank            : int 1
[16:05:02.147]   ..$ manual          : logi FALSE
[16:05:02.147]   ..$ dryrun          : logi FALSE
[16:05:02.147]   ..$ quiet           : logi FALSE
[16:05:02.147]   ..$ setup_strategy  : chr "parallel"
[16:05:02.147]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:05:02.164] [local output] System call to launch all workers:
[16:05:02.164] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpsnomsu/worker.rank=1.parallelly.parent=85585.14e5130756642.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11351 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:05:02.165] [local output] Starting PSOCK main server
[16:05:02.170] [local output] Workers launched
[16:05:02.170] [local output] Waiting for workers to connect back
[16:05:02.171]  - [local output] 0 workers out of 2 ready
[16:05:02.377]  - [local output] 0 workers out of 2 ready
[16:05:02.377]  - [local output] 1 workers out of 2 ready
[16:05:02.444]  - [local output] 1 workers out of 2 ready
[16:05:02.445]  - [local output] 2 workers out of 2 ready
[16:05:02.445] [local output] Launching of workers completed
[16:05:02.445] [local output] Collecting session information from workers
[16:05:02.446] [local output]  - Worker #1 of 2
[16:05:02.447] [local output]  - Worker #2 of 2
[16:05:02.447] [local output] makeClusterPSOCK() ... done
[16:05:02.461] Packages needed by the future expression (n = 0): <none>
[16:05:02.461] Packages needed by future strategies (n = 0): <none>
[16:05:02.462] {
[16:05:02.462]     {
[16:05:02.462]         {
[16:05:02.462]             ...future.startTime <- base::Sys.time()
[16:05:02.462]             {
[16:05:02.462]                 {
[16:05:02.462]                   {
[16:05:02.462]                     {
[16:05:02.462]                       base::local({
[16:05:02.462]                         has_future <- base::requireNamespace("future", 
[16:05:02.462]                           quietly = TRUE)
[16:05:02.462]                         if (has_future) {
[16:05:02.462]                           ns <- base::getNamespace("future")
[16:05:02.462]                           version <- ns[[".package"]][["version"]]
[16:05:02.462]                           if (is.null(version)) 
[16:05:02.462]                             version <- utils::packageVersion("future")
[16:05:02.462]                         }
[16:05:02.462]                         else {
[16:05:02.462]                           version <- NULL
[16:05:02.462]                         }
[16:05:02.462]                         if (!has_future || version < "1.8.0") {
[16:05:02.462]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:02.462]                             "", base::R.version$version.string), 
[16:05:02.462]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:02.462]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:02.462]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:02.462]                               "release", "version")], collapse = " "), 
[16:05:02.462]                             hostname = base::Sys.info()[["nodename"]])
[16:05:02.462]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:02.462]                             info)
[16:05:02.462]                           info <- base::paste(info, collapse = "; ")
[16:05:02.462]                           if (!has_future) {
[16:05:02.462]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:02.462]                               info)
[16:05:02.462]                           }
[16:05:02.462]                           else {
[16:05:02.462]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:02.462]                               info, version)
[16:05:02.462]                           }
[16:05:02.462]                           base::stop(msg)
[16:05:02.462]                         }
[16:05:02.462]                       })
[16:05:02.462]                     }
[16:05:02.462]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:02.462]                     base::options(mc.cores = 1L)
[16:05:02.462]                   }
[16:05:02.462]                   options(future.plan = NULL)
[16:05:02.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:02.462]                 }
[16:05:02.462]                 ...future.workdir <- getwd()
[16:05:02.462]             }
[16:05:02.462]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:02.462]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:02.462]         }
[16:05:02.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:02.462]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:02.462]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:02.462]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:02.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:02.462]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:02.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:02.462]             base::names(...future.oldOptions))
[16:05:02.462]     }
[16:05:02.462]     if (FALSE) {
[16:05:02.462]     }
[16:05:02.462]     else {
[16:05:02.462]         if (TRUE) {
[16:05:02.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:02.462]                 open = "w")
[16:05:02.462]         }
[16:05:02.462]         else {
[16:05:02.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:02.462]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:02.462]         }
[16:05:02.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:02.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:02.462]             base::sink(type = "output", split = FALSE)
[16:05:02.462]             base::close(...future.stdout)
[16:05:02.462]         }, add = TRUE)
[16:05:02.462]     }
[16:05:02.462]     ...future.frame <- base::sys.nframe()
[16:05:02.462]     ...future.conditions <- base::list()
[16:05:02.462]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:02.462]     if (FALSE) {
[16:05:02.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:02.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:02.462]     }
[16:05:02.462]     ...future.result <- base::tryCatch({
[16:05:02.462]         base::withCallingHandlers({
[16:05:02.462]             ...future.value <- base::withVisible(base::local({
[16:05:02.462]                 ...future.makeSendCondition <- base::local({
[16:05:02.462]                   sendCondition <- NULL
[16:05:02.462]                   function(frame = 1L) {
[16:05:02.462]                     if (is.function(sendCondition)) 
[16:05:02.462]                       return(sendCondition)
[16:05:02.462]                     ns <- getNamespace("parallel")
[16:05:02.462]                     if (exists("sendData", mode = "function", 
[16:05:02.462]                       envir = ns)) {
[16:05:02.462]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:02.462]                         envir = ns)
[16:05:02.462]                       envir <- sys.frame(frame)
[16:05:02.462]                       master <- NULL
[16:05:02.462]                       while (!identical(envir, .GlobalEnv) && 
[16:05:02.462]                         !identical(envir, emptyenv())) {
[16:05:02.462]                         if (exists("master", mode = "list", envir = envir, 
[16:05:02.462]                           inherits = FALSE)) {
[16:05:02.462]                           master <- get("master", mode = "list", 
[16:05:02.462]                             envir = envir, inherits = FALSE)
[16:05:02.462]                           if (inherits(master, c("SOCKnode", 
[16:05:02.462]                             "SOCK0node"))) {
[16:05:02.462]                             sendCondition <<- function(cond) {
[16:05:02.462]                               data <- list(type = "VALUE", value = cond, 
[16:05:02.462]                                 success = TRUE)
[16:05:02.462]                               parallel_sendData(master, data)
[16:05:02.462]                             }
[16:05:02.462]                             return(sendCondition)
[16:05:02.462]                           }
[16:05:02.462]                         }
[16:05:02.462]                         frame <- frame + 1L
[16:05:02.462]                         envir <- sys.frame(frame)
[16:05:02.462]                       }
[16:05:02.462]                     }
[16:05:02.462]                     sendCondition <<- function(cond) NULL
[16:05:02.462]                   }
[16:05:02.462]                 })
[16:05:02.462]                 withCallingHandlers({
[16:05:02.462]                   NA
[16:05:02.462]                 }, immediateCondition = function(cond) {
[16:05:02.462]                   sendCondition <- ...future.makeSendCondition()
[16:05:02.462]                   sendCondition(cond)
[16:05:02.462]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.462]                   {
[16:05:02.462]                     inherits <- base::inherits
[16:05:02.462]                     invokeRestart <- base::invokeRestart
[16:05:02.462]                     is.null <- base::is.null
[16:05:02.462]                     muffled <- FALSE
[16:05:02.462]                     if (inherits(cond, "message")) {
[16:05:02.462]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:02.462]                       if (muffled) 
[16:05:02.462]                         invokeRestart("muffleMessage")
[16:05:02.462]                     }
[16:05:02.462]                     else if (inherits(cond, "warning")) {
[16:05:02.462]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:02.462]                       if (muffled) 
[16:05:02.462]                         invokeRestart("muffleWarning")
[16:05:02.462]                     }
[16:05:02.462]                     else if (inherits(cond, "condition")) {
[16:05:02.462]                       if (!is.null(pattern)) {
[16:05:02.462]                         computeRestarts <- base::computeRestarts
[16:05:02.462]                         grepl <- base::grepl
[16:05:02.462]                         restarts <- computeRestarts(cond)
[16:05:02.462]                         for (restart in restarts) {
[16:05:02.462]                           name <- restart$name
[16:05:02.462]                           if (is.null(name)) 
[16:05:02.462]                             next
[16:05:02.462]                           if (!grepl(pattern, name)) 
[16:05:02.462]                             next
[16:05:02.462]                           invokeRestart(restart)
[16:05:02.462]                           muffled <- TRUE
[16:05:02.462]                           break
[16:05:02.462]                         }
[16:05:02.462]                       }
[16:05:02.462]                     }
[16:05:02.462]                     invisible(muffled)
[16:05:02.462]                   }
[16:05:02.462]                   muffleCondition(cond)
[16:05:02.462]                 })
[16:05:02.462]             }))
[16:05:02.462]             future::FutureResult(value = ...future.value$value, 
[16:05:02.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.462]                   ...future.rng), globalenv = if (FALSE) 
[16:05:02.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:02.462]                     ...future.globalenv.names))
[16:05:02.462]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:02.462]         }, condition = base::local({
[16:05:02.462]             c <- base::c
[16:05:02.462]             inherits <- base::inherits
[16:05:02.462]             invokeRestart <- base::invokeRestart
[16:05:02.462]             length <- base::length
[16:05:02.462]             list <- base::list
[16:05:02.462]             seq.int <- base::seq.int
[16:05:02.462]             signalCondition <- base::signalCondition
[16:05:02.462]             sys.calls <- base::sys.calls
[16:05:02.462]             `[[` <- base::`[[`
[16:05:02.462]             `+` <- base::`+`
[16:05:02.462]             `<<-` <- base::`<<-`
[16:05:02.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:02.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:02.462]                   3L)]
[16:05:02.462]             }
[16:05:02.462]             function(cond) {
[16:05:02.462]                 is_error <- inherits(cond, "error")
[16:05:02.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:02.462]                   NULL)
[16:05:02.462]                 if (is_error) {
[16:05:02.462]                   sessionInformation <- function() {
[16:05:02.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:02.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:02.462]                       search = base::search(), system = base::Sys.info())
[16:05:02.462]                   }
[16:05:02.462]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:02.462]                     cond$call), session = sessionInformation(), 
[16:05:02.462]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:02.462]                   signalCondition(cond)
[16:05:02.462]                 }
[16:05:02.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:02.462]                 "immediateCondition"))) {
[16:05:02.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:02.462]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:02.462]                   if (TRUE && !signal) {
[16:05:02.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.462]                     {
[16:05:02.462]                       inherits <- base::inherits
[16:05:02.462]                       invokeRestart <- base::invokeRestart
[16:05:02.462]                       is.null <- base::is.null
[16:05:02.462]                       muffled <- FALSE
[16:05:02.462]                       if (inherits(cond, "message")) {
[16:05:02.462]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.462]                         if (muffled) 
[16:05:02.462]                           invokeRestart("muffleMessage")
[16:05:02.462]                       }
[16:05:02.462]                       else if (inherits(cond, "warning")) {
[16:05:02.462]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.462]                         if (muffled) 
[16:05:02.462]                           invokeRestart("muffleWarning")
[16:05:02.462]                       }
[16:05:02.462]                       else if (inherits(cond, "condition")) {
[16:05:02.462]                         if (!is.null(pattern)) {
[16:05:02.462]                           computeRestarts <- base::computeRestarts
[16:05:02.462]                           grepl <- base::grepl
[16:05:02.462]                           restarts <- computeRestarts(cond)
[16:05:02.462]                           for (restart in restarts) {
[16:05:02.462]                             name <- restart$name
[16:05:02.462]                             if (is.null(name)) 
[16:05:02.462]                               next
[16:05:02.462]                             if (!grepl(pattern, name)) 
[16:05:02.462]                               next
[16:05:02.462]                             invokeRestart(restart)
[16:05:02.462]                             muffled <- TRUE
[16:05:02.462]                             break
[16:05:02.462]                           }
[16:05:02.462]                         }
[16:05:02.462]                       }
[16:05:02.462]                       invisible(muffled)
[16:05:02.462]                     }
[16:05:02.462]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.462]                   }
[16:05:02.462]                 }
[16:05:02.462]                 else {
[16:05:02.462]                   if (TRUE) {
[16:05:02.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.462]                     {
[16:05:02.462]                       inherits <- base::inherits
[16:05:02.462]                       invokeRestart <- base::invokeRestart
[16:05:02.462]                       is.null <- base::is.null
[16:05:02.462]                       muffled <- FALSE
[16:05:02.462]                       if (inherits(cond, "message")) {
[16:05:02.462]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.462]                         if (muffled) 
[16:05:02.462]                           invokeRestart("muffleMessage")
[16:05:02.462]                       }
[16:05:02.462]                       else if (inherits(cond, "warning")) {
[16:05:02.462]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.462]                         if (muffled) 
[16:05:02.462]                           invokeRestart("muffleWarning")
[16:05:02.462]                       }
[16:05:02.462]                       else if (inherits(cond, "condition")) {
[16:05:02.462]                         if (!is.null(pattern)) {
[16:05:02.462]                           computeRestarts <- base::computeRestarts
[16:05:02.462]                           grepl <- base::grepl
[16:05:02.462]                           restarts <- computeRestarts(cond)
[16:05:02.462]                           for (restart in restarts) {
[16:05:02.462]                             name <- restart$name
[16:05:02.462]                             if (is.null(name)) 
[16:05:02.462]                               next
[16:05:02.462]                             if (!grepl(pattern, name)) 
[16:05:02.462]                               next
[16:05:02.462]                             invokeRestart(restart)
[16:05:02.462]                             muffled <- TRUE
[16:05:02.462]                             break
[16:05:02.462]                           }
[16:05:02.462]                         }
[16:05:02.462]                       }
[16:05:02.462]                       invisible(muffled)
[16:05:02.462]                     }
[16:05:02.462]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.462]                   }
[16:05:02.462]                 }
[16:05:02.462]             }
[16:05:02.462]         }))
[16:05:02.462]     }, error = function(ex) {
[16:05:02.462]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:02.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.462]                 ...future.rng), started = ...future.startTime, 
[16:05:02.462]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:02.462]             version = "1.8"), class = "FutureResult")
[16:05:02.462]     }, finally = {
[16:05:02.462]         if (!identical(...future.workdir, getwd())) 
[16:05:02.462]             setwd(...future.workdir)
[16:05:02.462]         {
[16:05:02.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:02.462]                 ...future.oldOptions$nwarnings <- NULL
[16:05:02.462]             }
[16:05:02.462]             base::options(...future.oldOptions)
[16:05:02.462]             if (.Platform$OS.type == "windows") {
[16:05:02.462]                 old_names <- names(...future.oldEnvVars)
[16:05:02.462]                 envs <- base::Sys.getenv()
[16:05:02.462]                 names <- names(envs)
[16:05:02.462]                 common <- intersect(names, old_names)
[16:05:02.462]                 added <- setdiff(names, old_names)
[16:05:02.462]                 removed <- setdiff(old_names, names)
[16:05:02.462]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:02.462]                   envs[common]]
[16:05:02.462]                 NAMES <- toupper(changed)
[16:05:02.462]                 args <- list()
[16:05:02.462]                 for (kk in seq_along(NAMES)) {
[16:05:02.462]                   name <- changed[[kk]]
[16:05:02.462]                   NAME <- NAMES[[kk]]
[16:05:02.462]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.462]                     next
[16:05:02.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.462]                 }
[16:05:02.462]                 NAMES <- toupper(added)
[16:05:02.462]                 for (kk in seq_along(NAMES)) {
[16:05:02.462]                   name <- added[[kk]]
[16:05:02.462]                   NAME <- NAMES[[kk]]
[16:05:02.462]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.462]                     next
[16:05:02.462]                   args[[name]] <- ""
[16:05:02.462]                 }
[16:05:02.462]                 NAMES <- toupper(removed)
[16:05:02.462]                 for (kk in seq_along(NAMES)) {
[16:05:02.462]                   name <- removed[[kk]]
[16:05:02.462]                   NAME <- NAMES[[kk]]
[16:05:02.462]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.462]                     next
[16:05:02.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.462]                 }
[16:05:02.462]                 if (length(args) > 0) 
[16:05:02.462]                   base::do.call(base::Sys.setenv, args = args)
[16:05:02.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:02.462]             }
[16:05:02.462]             else {
[16:05:02.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:02.462]             }
[16:05:02.462]             {
[16:05:02.462]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:02.462]                   0L) {
[16:05:02.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:02.462]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:02.462]                   base::options(opts)
[16:05:02.462]                 }
[16:05:02.462]                 {
[16:05:02.462]                   {
[16:05:02.462]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:02.462]                     NULL
[16:05:02.462]                   }
[16:05:02.462]                   options(future.plan = NULL)
[16:05:02.462]                   if (is.na(NA_character_)) 
[16:05:02.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:02.462]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:02.462]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:02.462]                     envir = parent.frame()) 
[16:05:02.462]                   {
[16:05:02.462]                     if (is.function(workers)) 
[16:05:02.462]                       workers <- workers()
[16:05:02.462]                     workers <- structure(as.integer(workers), 
[16:05:02.462]                       class = class(workers))
[16:05:02.462]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:02.462]                       workers >= 1)
[16:05:02.462]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:02.462]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:02.462]                     }
[16:05:02.462]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:02.462]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:02.462]                       envir = envir)
[16:05:02.462]                     if (!future$lazy) 
[16:05:02.462]                       future <- run(future)
[16:05:02.462]                     invisible(future)
[16:05:02.462]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:02.462]                 }
[16:05:02.462]             }
[16:05:02.462]         }
[16:05:02.462]     })
[16:05:02.462]     if (TRUE) {
[16:05:02.462]         base::sink(type = "output", split = FALSE)
[16:05:02.462]         if (TRUE) {
[16:05:02.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:02.462]         }
[16:05:02.462]         else {
[16:05:02.462]             ...future.result["stdout"] <- base::list(NULL)
[16:05:02.462]         }
[16:05:02.462]         base::close(...future.stdout)
[16:05:02.462]         ...future.stdout <- NULL
[16:05:02.462]     }
[16:05:02.462]     ...future.result$conditions <- ...future.conditions
[16:05:02.462]     ...future.result$finished <- base::Sys.time()
[16:05:02.462]     ...future.result
[16:05:02.462] }
[16:05:02.522] MultisessionFuture started
[16:05:02.522] result() for ClusterFuture ...
[16:05:02.523] receiveMessageFromWorker() for ClusterFuture ...
[16:05:02.523] - Validating connection of MultisessionFuture
[16:05:02.566] - received message: FutureResult
[16:05:02.566] - Received FutureResult
[16:05:02.566] - Erased future from FutureRegistry
[16:05:02.567] result() for ClusterFuture ...
[16:05:02.567] - result already collected: FutureResult
[16:05:02.567] result() for ClusterFuture ... done
[16:05:02.567] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:02.567] result() for ClusterFuture ... done
[16:05:02.567] result() for ClusterFuture ...
[16:05:02.567] - result already collected: FutureResult
[16:05:02.567] result() for ClusterFuture ... done
[16:05:02.568] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:05:02.572] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:02.572] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:02.572] Searching for globals...
[16:05:02.575] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:02.575] Searching for globals ... DONE
[16:05:02.575] Resolving globals: TRUE
[16:05:02.575] Resolving any globals that are futures ...
[16:05:02.575] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:02.575] Resolving any globals that are futures ... DONE
[16:05:02.576] Resolving futures part of globals (recursively) ...
[16:05:02.576] resolve() on list ...
[16:05:02.576]  recursive: 99
[16:05:02.576]  length: 1
[16:05:02.576]  elements: ‘x’
[16:05:02.577]  length: 0 (resolved future 1)
[16:05:02.577] resolve() on list ... DONE
[16:05:02.577] - globals: [1] ‘x’
[16:05:02.577] Resolving futures part of globals (recursively) ... DONE
[16:05:02.577] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:02.578] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:02.578] - globals: [1] ‘x’
[16:05:02.578] 
[16:05:02.578] getGlobalsAndPackages() ... DONE
[16:05:02.578] run() for ‘Future’ ...
[16:05:02.578] - state: ‘created’
[16:05:02.579] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:02.593] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:02.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:02.593]   - Field: ‘node’
[16:05:02.593]   - Field: ‘label’
[16:05:02.593]   - Field: ‘local’
[16:05:02.593]   - Field: ‘owner’
[16:05:02.594]   - Field: ‘envir’
[16:05:02.594]   - Field: ‘workers’
[16:05:02.594]   - Field: ‘packages’
[16:05:02.594]   - Field: ‘gc’
[16:05:02.594]   - Field: ‘conditions’
[16:05:02.594]   - Field: ‘persistent’
[16:05:02.594]   - Field: ‘expr’
[16:05:02.594]   - Field: ‘uuid’
[16:05:02.594]   - Field: ‘seed’
[16:05:02.595]   - Field: ‘version’
[16:05:02.595]   - Field: ‘result’
[16:05:02.595]   - Field: ‘asynchronous’
[16:05:02.595]   - Field: ‘calls’
[16:05:02.595]   - Field: ‘globals’
[16:05:02.595]   - Field: ‘stdout’
[16:05:02.595]   - Field: ‘earlySignal’
[16:05:02.595]   - Field: ‘lazy’
[16:05:02.596]   - Field: ‘state’
[16:05:02.596] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:02.596] - Launch lazy future ...
[16:05:02.596] Packages needed by the future expression (n = 0): <none>
[16:05:02.596] Packages needed by future strategies (n = 0): <none>
[16:05:02.597] {
[16:05:02.597]     {
[16:05:02.597]         {
[16:05:02.597]             ...future.startTime <- base::Sys.time()
[16:05:02.597]             {
[16:05:02.597]                 {
[16:05:02.597]                   {
[16:05:02.597]                     {
[16:05:02.597]                       base::local({
[16:05:02.597]                         has_future <- base::requireNamespace("future", 
[16:05:02.597]                           quietly = TRUE)
[16:05:02.597]                         if (has_future) {
[16:05:02.597]                           ns <- base::getNamespace("future")
[16:05:02.597]                           version <- ns[[".package"]][["version"]]
[16:05:02.597]                           if (is.null(version)) 
[16:05:02.597]                             version <- utils::packageVersion("future")
[16:05:02.597]                         }
[16:05:02.597]                         else {
[16:05:02.597]                           version <- NULL
[16:05:02.597]                         }
[16:05:02.597]                         if (!has_future || version < "1.8.0") {
[16:05:02.597]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:02.597]                             "", base::R.version$version.string), 
[16:05:02.597]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:02.597]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:02.597]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:02.597]                               "release", "version")], collapse = " "), 
[16:05:02.597]                             hostname = base::Sys.info()[["nodename"]])
[16:05:02.597]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:02.597]                             info)
[16:05:02.597]                           info <- base::paste(info, collapse = "; ")
[16:05:02.597]                           if (!has_future) {
[16:05:02.597]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:02.597]                               info)
[16:05:02.597]                           }
[16:05:02.597]                           else {
[16:05:02.597]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:02.597]                               info, version)
[16:05:02.597]                           }
[16:05:02.597]                           base::stop(msg)
[16:05:02.597]                         }
[16:05:02.597]                       })
[16:05:02.597]                     }
[16:05:02.597]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:02.597]                     base::options(mc.cores = 1L)
[16:05:02.597]                   }
[16:05:02.597]                   options(future.plan = NULL)
[16:05:02.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:02.597]                 }
[16:05:02.597]                 ...future.workdir <- getwd()
[16:05:02.597]             }
[16:05:02.597]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:02.597]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:02.597]         }
[16:05:02.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:02.597]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:02.597]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:02.597]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:02.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:02.597]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:02.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:02.597]             base::names(...future.oldOptions))
[16:05:02.597]     }
[16:05:02.597]     if (FALSE) {
[16:05:02.597]     }
[16:05:02.597]     else {
[16:05:02.597]         if (TRUE) {
[16:05:02.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:02.597]                 open = "w")
[16:05:02.597]         }
[16:05:02.597]         else {
[16:05:02.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:02.597]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:02.597]         }
[16:05:02.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:02.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:02.597]             base::sink(type = "output", split = FALSE)
[16:05:02.597]             base::close(...future.stdout)
[16:05:02.597]         }, add = TRUE)
[16:05:02.597]     }
[16:05:02.597]     ...future.frame <- base::sys.nframe()
[16:05:02.597]     ...future.conditions <- base::list()
[16:05:02.597]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:02.597]     if (FALSE) {
[16:05:02.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:02.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:02.597]     }
[16:05:02.597]     ...future.result <- base::tryCatch({
[16:05:02.597]         base::withCallingHandlers({
[16:05:02.597]             ...future.value <- base::withVisible(base::local({
[16:05:02.597]                 ...future.makeSendCondition <- base::local({
[16:05:02.597]                   sendCondition <- NULL
[16:05:02.597]                   function(frame = 1L) {
[16:05:02.597]                     if (is.function(sendCondition)) 
[16:05:02.597]                       return(sendCondition)
[16:05:02.597]                     ns <- getNamespace("parallel")
[16:05:02.597]                     if (exists("sendData", mode = "function", 
[16:05:02.597]                       envir = ns)) {
[16:05:02.597]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:02.597]                         envir = ns)
[16:05:02.597]                       envir <- sys.frame(frame)
[16:05:02.597]                       master <- NULL
[16:05:02.597]                       while (!identical(envir, .GlobalEnv) && 
[16:05:02.597]                         !identical(envir, emptyenv())) {
[16:05:02.597]                         if (exists("master", mode = "list", envir = envir, 
[16:05:02.597]                           inherits = FALSE)) {
[16:05:02.597]                           master <- get("master", mode = "list", 
[16:05:02.597]                             envir = envir, inherits = FALSE)
[16:05:02.597]                           if (inherits(master, c("SOCKnode", 
[16:05:02.597]                             "SOCK0node"))) {
[16:05:02.597]                             sendCondition <<- function(cond) {
[16:05:02.597]                               data <- list(type = "VALUE", value = cond, 
[16:05:02.597]                                 success = TRUE)
[16:05:02.597]                               parallel_sendData(master, data)
[16:05:02.597]                             }
[16:05:02.597]                             return(sendCondition)
[16:05:02.597]                           }
[16:05:02.597]                         }
[16:05:02.597]                         frame <- frame + 1L
[16:05:02.597]                         envir <- sys.frame(frame)
[16:05:02.597]                       }
[16:05:02.597]                     }
[16:05:02.597]                     sendCondition <<- function(cond) NULL
[16:05:02.597]                   }
[16:05:02.597]                 })
[16:05:02.597]                 withCallingHandlers({
[16:05:02.597]                   {
[16:05:02.597]                     x$a <- 1
[16:05:02.597]                     x
[16:05:02.597]                   }
[16:05:02.597]                 }, immediateCondition = function(cond) {
[16:05:02.597]                   sendCondition <- ...future.makeSendCondition()
[16:05:02.597]                   sendCondition(cond)
[16:05:02.597]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.597]                   {
[16:05:02.597]                     inherits <- base::inherits
[16:05:02.597]                     invokeRestart <- base::invokeRestart
[16:05:02.597]                     is.null <- base::is.null
[16:05:02.597]                     muffled <- FALSE
[16:05:02.597]                     if (inherits(cond, "message")) {
[16:05:02.597]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:02.597]                       if (muffled) 
[16:05:02.597]                         invokeRestart("muffleMessage")
[16:05:02.597]                     }
[16:05:02.597]                     else if (inherits(cond, "warning")) {
[16:05:02.597]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:02.597]                       if (muffled) 
[16:05:02.597]                         invokeRestart("muffleWarning")
[16:05:02.597]                     }
[16:05:02.597]                     else if (inherits(cond, "condition")) {
[16:05:02.597]                       if (!is.null(pattern)) {
[16:05:02.597]                         computeRestarts <- base::computeRestarts
[16:05:02.597]                         grepl <- base::grepl
[16:05:02.597]                         restarts <- computeRestarts(cond)
[16:05:02.597]                         for (restart in restarts) {
[16:05:02.597]                           name <- restart$name
[16:05:02.597]                           if (is.null(name)) 
[16:05:02.597]                             next
[16:05:02.597]                           if (!grepl(pattern, name)) 
[16:05:02.597]                             next
[16:05:02.597]                           invokeRestart(restart)
[16:05:02.597]                           muffled <- TRUE
[16:05:02.597]                           break
[16:05:02.597]                         }
[16:05:02.597]                       }
[16:05:02.597]                     }
[16:05:02.597]                     invisible(muffled)
[16:05:02.597]                   }
[16:05:02.597]                   muffleCondition(cond)
[16:05:02.597]                 })
[16:05:02.597]             }))
[16:05:02.597]             future::FutureResult(value = ...future.value$value, 
[16:05:02.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.597]                   ...future.rng), globalenv = if (FALSE) 
[16:05:02.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:02.597]                     ...future.globalenv.names))
[16:05:02.597]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:02.597]         }, condition = base::local({
[16:05:02.597]             c <- base::c
[16:05:02.597]             inherits <- base::inherits
[16:05:02.597]             invokeRestart <- base::invokeRestart
[16:05:02.597]             length <- base::length
[16:05:02.597]             list <- base::list
[16:05:02.597]             seq.int <- base::seq.int
[16:05:02.597]             signalCondition <- base::signalCondition
[16:05:02.597]             sys.calls <- base::sys.calls
[16:05:02.597]             `[[` <- base::`[[`
[16:05:02.597]             `+` <- base::`+`
[16:05:02.597]             `<<-` <- base::`<<-`
[16:05:02.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:02.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:02.597]                   3L)]
[16:05:02.597]             }
[16:05:02.597]             function(cond) {
[16:05:02.597]                 is_error <- inherits(cond, "error")
[16:05:02.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:02.597]                   NULL)
[16:05:02.597]                 if (is_error) {
[16:05:02.597]                   sessionInformation <- function() {
[16:05:02.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:02.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:02.597]                       search = base::search(), system = base::Sys.info())
[16:05:02.597]                   }
[16:05:02.597]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:02.597]                     cond$call), session = sessionInformation(), 
[16:05:02.597]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:02.597]                   signalCondition(cond)
[16:05:02.597]                 }
[16:05:02.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:02.597]                 "immediateCondition"))) {
[16:05:02.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:02.597]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:02.597]                   if (TRUE && !signal) {
[16:05:02.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.597]                     {
[16:05:02.597]                       inherits <- base::inherits
[16:05:02.597]                       invokeRestart <- base::invokeRestart
[16:05:02.597]                       is.null <- base::is.null
[16:05:02.597]                       muffled <- FALSE
[16:05:02.597]                       if (inherits(cond, "message")) {
[16:05:02.597]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.597]                         if (muffled) 
[16:05:02.597]                           invokeRestart("muffleMessage")
[16:05:02.597]                       }
[16:05:02.597]                       else if (inherits(cond, "warning")) {
[16:05:02.597]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.597]                         if (muffled) 
[16:05:02.597]                           invokeRestart("muffleWarning")
[16:05:02.597]                       }
[16:05:02.597]                       else if (inherits(cond, "condition")) {
[16:05:02.597]                         if (!is.null(pattern)) {
[16:05:02.597]                           computeRestarts <- base::computeRestarts
[16:05:02.597]                           grepl <- base::grepl
[16:05:02.597]                           restarts <- computeRestarts(cond)
[16:05:02.597]                           for (restart in restarts) {
[16:05:02.597]                             name <- restart$name
[16:05:02.597]                             if (is.null(name)) 
[16:05:02.597]                               next
[16:05:02.597]                             if (!grepl(pattern, name)) 
[16:05:02.597]                               next
[16:05:02.597]                             invokeRestart(restart)
[16:05:02.597]                             muffled <- TRUE
[16:05:02.597]                             break
[16:05:02.597]                           }
[16:05:02.597]                         }
[16:05:02.597]                       }
[16:05:02.597]                       invisible(muffled)
[16:05:02.597]                     }
[16:05:02.597]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.597]                   }
[16:05:02.597]                 }
[16:05:02.597]                 else {
[16:05:02.597]                   if (TRUE) {
[16:05:02.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.597]                     {
[16:05:02.597]                       inherits <- base::inherits
[16:05:02.597]                       invokeRestart <- base::invokeRestart
[16:05:02.597]                       is.null <- base::is.null
[16:05:02.597]                       muffled <- FALSE
[16:05:02.597]                       if (inherits(cond, "message")) {
[16:05:02.597]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.597]                         if (muffled) 
[16:05:02.597]                           invokeRestart("muffleMessage")
[16:05:02.597]                       }
[16:05:02.597]                       else if (inherits(cond, "warning")) {
[16:05:02.597]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.597]                         if (muffled) 
[16:05:02.597]                           invokeRestart("muffleWarning")
[16:05:02.597]                       }
[16:05:02.597]                       else if (inherits(cond, "condition")) {
[16:05:02.597]                         if (!is.null(pattern)) {
[16:05:02.597]                           computeRestarts <- base::computeRestarts
[16:05:02.597]                           grepl <- base::grepl
[16:05:02.597]                           restarts <- computeRestarts(cond)
[16:05:02.597]                           for (restart in restarts) {
[16:05:02.597]                             name <- restart$name
[16:05:02.597]                             if (is.null(name)) 
[16:05:02.597]                               next
[16:05:02.597]                             if (!grepl(pattern, name)) 
[16:05:02.597]                               next
[16:05:02.597]                             invokeRestart(restart)
[16:05:02.597]                             muffled <- TRUE
[16:05:02.597]                             break
[16:05:02.597]                           }
[16:05:02.597]                         }
[16:05:02.597]                       }
[16:05:02.597]                       invisible(muffled)
[16:05:02.597]                     }
[16:05:02.597]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.597]                   }
[16:05:02.597]                 }
[16:05:02.597]             }
[16:05:02.597]         }))
[16:05:02.597]     }, error = function(ex) {
[16:05:02.597]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:02.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.597]                 ...future.rng), started = ...future.startTime, 
[16:05:02.597]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:02.597]             version = "1.8"), class = "FutureResult")
[16:05:02.597]     }, finally = {
[16:05:02.597]         if (!identical(...future.workdir, getwd())) 
[16:05:02.597]             setwd(...future.workdir)
[16:05:02.597]         {
[16:05:02.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:02.597]                 ...future.oldOptions$nwarnings <- NULL
[16:05:02.597]             }
[16:05:02.597]             base::options(...future.oldOptions)
[16:05:02.597]             if (.Platform$OS.type == "windows") {
[16:05:02.597]                 old_names <- names(...future.oldEnvVars)
[16:05:02.597]                 envs <- base::Sys.getenv()
[16:05:02.597]                 names <- names(envs)
[16:05:02.597]                 common <- intersect(names, old_names)
[16:05:02.597]                 added <- setdiff(names, old_names)
[16:05:02.597]                 removed <- setdiff(old_names, names)
[16:05:02.597]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:02.597]                   envs[common]]
[16:05:02.597]                 NAMES <- toupper(changed)
[16:05:02.597]                 args <- list()
[16:05:02.597]                 for (kk in seq_along(NAMES)) {
[16:05:02.597]                   name <- changed[[kk]]
[16:05:02.597]                   NAME <- NAMES[[kk]]
[16:05:02.597]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.597]                     next
[16:05:02.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.597]                 }
[16:05:02.597]                 NAMES <- toupper(added)
[16:05:02.597]                 for (kk in seq_along(NAMES)) {
[16:05:02.597]                   name <- added[[kk]]
[16:05:02.597]                   NAME <- NAMES[[kk]]
[16:05:02.597]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.597]                     next
[16:05:02.597]                   args[[name]] <- ""
[16:05:02.597]                 }
[16:05:02.597]                 NAMES <- toupper(removed)
[16:05:02.597]                 for (kk in seq_along(NAMES)) {
[16:05:02.597]                   name <- removed[[kk]]
[16:05:02.597]                   NAME <- NAMES[[kk]]
[16:05:02.597]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.597]                     next
[16:05:02.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.597]                 }
[16:05:02.597]                 if (length(args) > 0) 
[16:05:02.597]                   base::do.call(base::Sys.setenv, args = args)
[16:05:02.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:02.597]             }
[16:05:02.597]             else {
[16:05:02.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:02.597]             }
[16:05:02.597]             {
[16:05:02.597]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:02.597]                   0L) {
[16:05:02.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:02.597]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:02.597]                   base::options(opts)
[16:05:02.597]                 }
[16:05:02.597]                 {
[16:05:02.597]                   {
[16:05:02.597]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:02.597]                     NULL
[16:05:02.597]                   }
[16:05:02.597]                   options(future.plan = NULL)
[16:05:02.597]                   if (is.na(NA_character_)) 
[16:05:02.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:02.597]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:02.597]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:02.597]                     envir = parent.frame()) 
[16:05:02.597]                   {
[16:05:02.597]                     if (is.function(workers)) 
[16:05:02.597]                       workers <- workers()
[16:05:02.597]                     workers <- structure(as.integer(workers), 
[16:05:02.597]                       class = class(workers))
[16:05:02.597]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:02.597]                       workers >= 1)
[16:05:02.597]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:02.597]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:02.597]                     }
[16:05:02.597]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:02.597]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:02.597]                       envir = envir)
[16:05:02.597]                     if (!future$lazy) 
[16:05:02.597]                       future <- run(future)
[16:05:02.597]                     invisible(future)
[16:05:02.597]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:02.597]                 }
[16:05:02.597]             }
[16:05:02.597]         }
[16:05:02.597]     })
[16:05:02.597]     if (TRUE) {
[16:05:02.597]         base::sink(type = "output", split = FALSE)
[16:05:02.597]         if (TRUE) {
[16:05:02.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:02.597]         }
[16:05:02.597]         else {
[16:05:02.597]             ...future.result["stdout"] <- base::list(NULL)
[16:05:02.597]         }
[16:05:02.597]         base::close(...future.stdout)
[16:05:02.597]         ...future.stdout <- NULL
[16:05:02.597]     }
[16:05:02.597]     ...future.result$conditions <- ...future.conditions
[16:05:02.597]     ...future.result$finished <- base::Sys.time()
[16:05:02.597]     ...future.result
[16:05:02.597] }
[16:05:02.600] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:05:02.600] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:05:02.601] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:05:02.601] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:05:02.601] MultisessionFuture started
[16:05:02.602] - Launch lazy future ... done
[16:05:02.602] run() for ‘MultisessionFuture’ ... done
[16:05:02.602] result() for ClusterFuture ...
[16:05:02.602] receiveMessageFromWorker() for ClusterFuture ...
[16:05:02.602] - Validating connection of MultisessionFuture
[16:05:02.648] - received message: FutureResult
[16:05:02.648] - Received FutureResult
[16:05:02.648] - Erased future from FutureRegistry
[16:05:02.648] result() for ClusterFuture ...
[16:05:02.649] - result already collected: FutureResult
[16:05:02.649] result() for ClusterFuture ... done
[16:05:02.649] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:02.649] result() for ClusterFuture ... done
[16:05:02.649] result() for ClusterFuture ...
[16:05:02.649] - result already collected: FutureResult
[16:05:02.649] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:02.650] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:02.650] Searching for globals...
[16:05:02.652] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:02.653] Searching for globals ... DONE
[16:05:02.653] Resolving globals: TRUE
[16:05:02.653] Resolving any globals that are futures ...
[16:05:02.653] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:02.653] Resolving any globals that are futures ... DONE
[16:05:02.654] Resolving futures part of globals (recursively) ...
[16:05:02.654] resolve() on list ...
[16:05:02.654]  recursive: 99
[16:05:02.654]  length: 1
[16:05:02.654]  elements: ‘x’
[16:05:02.654]  length: 0 (resolved future 1)
[16:05:02.655] resolve() on list ... DONE
[16:05:02.655] - globals: [1] ‘x’
[16:05:02.655] Resolving futures part of globals (recursively) ... DONE
[16:05:02.655] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:02.655] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:02.656] - globals: [1] ‘x’
[16:05:02.656] 
[16:05:02.656] getGlobalsAndPackages() ... DONE
[16:05:02.656] run() for ‘Future’ ...
[16:05:02.656] - state: ‘created’
[16:05:02.656] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:02.671] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:02.671] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:02.671]   - Field: ‘node’
[16:05:02.671]   - Field: ‘label’
[16:05:02.671]   - Field: ‘local’
[16:05:02.671]   - Field: ‘owner’
[16:05:02.671]   - Field: ‘envir’
[16:05:02.672]   - Field: ‘workers’
[16:05:02.672]   - Field: ‘packages’
[16:05:02.672]   - Field: ‘gc’
[16:05:02.672]   - Field: ‘conditions’
[16:05:02.672]   - Field: ‘persistent’
[16:05:02.672]   - Field: ‘expr’
[16:05:02.672]   - Field: ‘uuid’
[16:05:02.672]   - Field: ‘seed’
[16:05:02.672]   - Field: ‘version’
[16:05:02.673]   - Field: ‘result’
[16:05:02.673]   - Field: ‘asynchronous’
[16:05:02.673]   - Field: ‘calls’
[16:05:02.673]   - Field: ‘globals’
[16:05:02.673]   - Field: ‘stdout’
[16:05:02.673]   - Field: ‘earlySignal’
[16:05:02.673]   - Field: ‘lazy’
[16:05:02.673]   - Field: ‘state’
[16:05:02.674] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:02.674] - Launch lazy future ...
[16:05:02.674] Packages needed by the future expression (n = 0): <none>
[16:05:02.674] Packages needed by future strategies (n = 0): <none>
[16:05:02.675] {
[16:05:02.675]     {
[16:05:02.675]         {
[16:05:02.675]             ...future.startTime <- base::Sys.time()
[16:05:02.675]             {
[16:05:02.675]                 {
[16:05:02.675]                   {
[16:05:02.675]                     {
[16:05:02.675]                       base::local({
[16:05:02.675]                         has_future <- base::requireNamespace("future", 
[16:05:02.675]                           quietly = TRUE)
[16:05:02.675]                         if (has_future) {
[16:05:02.675]                           ns <- base::getNamespace("future")
[16:05:02.675]                           version <- ns[[".package"]][["version"]]
[16:05:02.675]                           if (is.null(version)) 
[16:05:02.675]                             version <- utils::packageVersion("future")
[16:05:02.675]                         }
[16:05:02.675]                         else {
[16:05:02.675]                           version <- NULL
[16:05:02.675]                         }
[16:05:02.675]                         if (!has_future || version < "1.8.0") {
[16:05:02.675]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:02.675]                             "", base::R.version$version.string), 
[16:05:02.675]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:02.675]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:02.675]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:02.675]                               "release", "version")], collapse = " "), 
[16:05:02.675]                             hostname = base::Sys.info()[["nodename"]])
[16:05:02.675]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:02.675]                             info)
[16:05:02.675]                           info <- base::paste(info, collapse = "; ")
[16:05:02.675]                           if (!has_future) {
[16:05:02.675]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:02.675]                               info)
[16:05:02.675]                           }
[16:05:02.675]                           else {
[16:05:02.675]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:02.675]                               info, version)
[16:05:02.675]                           }
[16:05:02.675]                           base::stop(msg)
[16:05:02.675]                         }
[16:05:02.675]                       })
[16:05:02.675]                     }
[16:05:02.675]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:02.675]                     base::options(mc.cores = 1L)
[16:05:02.675]                   }
[16:05:02.675]                   options(future.plan = NULL)
[16:05:02.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:02.675]                 }
[16:05:02.675]                 ...future.workdir <- getwd()
[16:05:02.675]             }
[16:05:02.675]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:02.675]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:02.675]         }
[16:05:02.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:02.675]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:02.675]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:02.675]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:02.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:02.675]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:02.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:02.675]             base::names(...future.oldOptions))
[16:05:02.675]     }
[16:05:02.675]     if (FALSE) {
[16:05:02.675]     }
[16:05:02.675]     else {
[16:05:02.675]         if (TRUE) {
[16:05:02.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:02.675]                 open = "w")
[16:05:02.675]         }
[16:05:02.675]         else {
[16:05:02.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:02.675]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:02.675]         }
[16:05:02.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:02.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:02.675]             base::sink(type = "output", split = FALSE)
[16:05:02.675]             base::close(...future.stdout)
[16:05:02.675]         }, add = TRUE)
[16:05:02.675]     }
[16:05:02.675]     ...future.frame <- base::sys.nframe()
[16:05:02.675]     ...future.conditions <- base::list()
[16:05:02.675]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:02.675]     if (FALSE) {
[16:05:02.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:02.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:02.675]     }
[16:05:02.675]     ...future.result <- base::tryCatch({
[16:05:02.675]         base::withCallingHandlers({
[16:05:02.675]             ...future.value <- base::withVisible(base::local({
[16:05:02.675]                 ...future.makeSendCondition <- base::local({
[16:05:02.675]                   sendCondition <- NULL
[16:05:02.675]                   function(frame = 1L) {
[16:05:02.675]                     if (is.function(sendCondition)) 
[16:05:02.675]                       return(sendCondition)
[16:05:02.675]                     ns <- getNamespace("parallel")
[16:05:02.675]                     if (exists("sendData", mode = "function", 
[16:05:02.675]                       envir = ns)) {
[16:05:02.675]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:02.675]                         envir = ns)
[16:05:02.675]                       envir <- sys.frame(frame)
[16:05:02.675]                       master <- NULL
[16:05:02.675]                       while (!identical(envir, .GlobalEnv) && 
[16:05:02.675]                         !identical(envir, emptyenv())) {
[16:05:02.675]                         if (exists("master", mode = "list", envir = envir, 
[16:05:02.675]                           inherits = FALSE)) {
[16:05:02.675]                           master <- get("master", mode = "list", 
[16:05:02.675]                             envir = envir, inherits = FALSE)
[16:05:02.675]                           if (inherits(master, c("SOCKnode", 
[16:05:02.675]                             "SOCK0node"))) {
[16:05:02.675]                             sendCondition <<- function(cond) {
[16:05:02.675]                               data <- list(type = "VALUE", value = cond, 
[16:05:02.675]                                 success = TRUE)
[16:05:02.675]                               parallel_sendData(master, data)
[16:05:02.675]                             }
[16:05:02.675]                             return(sendCondition)
[16:05:02.675]                           }
[16:05:02.675]                         }
[16:05:02.675]                         frame <- frame + 1L
[16:05:02.675]                         envir <- sys.frame(frame)
[16:05:02.675]                       }
[16:05:02.675]                     }
[16:05:02.675]                     sendCondition <<- function(cond) NULL
[16:05:02.675]                   }
[16:05:02.675]                 })
[16:05:02.675]                 withCallingHandlers({
[16:05:02.675]                   {
[16:05:02.675]                     x$a <- 1
[16:05:02.675]                     x
[16:05:02.675]                   }
[16:05:02.675]                 }, immediateCondition = function(cond) {
[16:05:02.675]                   sendCondition <- ...future.makeSendCondition()
[16:05:02.675]                   sendCondition(cond)
[16:05:02.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.675]                   {
[16:05:02.675]                     inherits <- base::inherits
[16:05:02.675]                     invokeRestart <- base::invokeRestart
[16:05:02.675]                     is.null <- base::is.null
[16:05:02.675]                     muffled <- FALSE
[16:05:02.675]                     if (inherits(cond, "message")) {
[16:05:02.675]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:02.675]                       if (muffled) 
[16:05:02.675]                         invokeRestart("muffleMessage")
[16:05:02.675]                     }
[16:05:02.675]                     else if (inherits(cond, "warning")) {
[16:05:02.675]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:02.675]                       if (muffled) 
[16:05:02.675]                         invokeRestart("muffleWarning")
[16:05:02.675]                     }
[16:05:02.675]                     else if (inherits(cond, "condition")) {
[16:05:02.675]                       if (!is.null(pattern)) {
[16:05:02.675]                         computeRestarts <- base::computeRestarts
[16:05:02.675]                         grepl <- base::grepl
[16:05:02.675]                         restarts <- computeRestarts(cond)
[16:05:02.675]                         for (restart in restarts) {
[16:05:02.675]                           name <- restart$name
[16:05:02.675]                           if (is.null(name)) 
[16:05:02.675]                             next
[16:05:02.675]                           if (!grepl(pattern, name)) 
[16:05:02.675]                             next
[16:05:02.675]                           invokeRestart(restart)
[16:05:02.675]                           muffled <- TRUE
[16:05:02.675]                           break
[16:05:02.675]                         }
[16:05:02.675]                       }
[16:05:02.675]                     }
[16:05:02.675]                     invisible(muffled)
[16:05:02.675]                   }
[16:05:02.675]                   muffleCondition(cond)
[16:05:02.675]                 })
[16:05:02.675]             }))
[16:05:02.675]             future::FutureResult(value = ...future.value$value, 
[16:05:02.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.675]                   ...future.rng), globalenv = if (FALSE) 
[16:05:02.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:02.675]                     ...future.globalenv.names))
[16:05:02.675]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:02.675]         }, condition = base::local({
[16:05:02.675]             c <- base::c
[16:05:02.675]             inherits <- base::inherits
[16:05:02.675]             invokeRestart <- base::invokeRestart
[16:05:02.675]             length <- base::length
[16:05:02.675]             list <- base::list
[16:05:02.675]             seq.int <- base::seq.int
[16:05:02.675]             signalCondition <- base::signalCondition
[16:05:02.675]             sys.calls <- base::sys.calls
[16:05:02.675]             `[[` <- base::`[[`
[16:05:02.675]             `+` <- base::`+`
[16:05:02.675]             `<<-` <- base::`<<-`
[16:05:02.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:02.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:02.675]                   3L)]
[16:05:02.675]             }
[16:05:02.675]             function(cond) {
[16:05:02.675]                 is_error <- inherits(cond, "error")
[16:05:02.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:02.675]                   NULL)
[16:05:02.675]                 if (is_error) {
[16:05:02.675]                   sessionInformation <- function() {
[16:05:02.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:02.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:02.675]                       search = base::search(), system = base::Sys.info())
[16:05:02.675]                   }
[16:05:02.675]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:02.675]                     cond$call), session = sessionInformation(), 
[16:05:02.675]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:02.675]                   signalCondition(cond)
[16:05:02.675]                 }
[16:05:02.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:02.675]                 "immediateCondition"))) {
[16:05:02.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:02.675]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:02.675]                   if (TRUE && !signal) {
[16:05:02.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.675]                     {
[16:05:02.675]                       inherits <- base::inherits
[16:05:02.675]                       invokeRestart <- base::invokeRestart
[16:05:02.675]                       is.null <- base::is.null
[16:05:02.675]                       muffled <- FALSE
[16:05:02.675]                       if (inherits(cond, "message")) {
[16:05:02.675]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.675]                         if (muffled) 
[16:05:02.675]                           invokeRestart("muffleMessage")
[16:05:02.675]                       }
[16:05:02.675]                       else if (inherits(cond, "warning")) {
[16:05:02.675]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.675]                         if (muffled) 
[16:05:02.675]                           invokeRestart("muffleWarning")
[16:05:02.675]                       }
[16:05:02.675]                       else if (inherits(cond, "condition")) {
[16:05:02.675]                         if (!is.null(pattern)) {
[16:05:02.675]                           computeRestarts <- base::computeRestarts
[16:05:02.675]                           grepl <- base::grepl
[16:05:02.675]                           restarts <- computeRestarts(cond)
[16:05:02.675]                           for (restart in restarts) {
[16:05:02.675]                             name <- restart$name
[16:05:02.675]                             if (is.null(name)) 
[16:05:02.675]                               next
[16:05:02.675]                             if (!grepl(pattern, name)) 
[16:05:02.675]                               next
[16:05:02.675]                             invokeRestart(restart)
[16:05:02.675]                             muffled <- TRUE
[16:05:02.675]                             break
[16:05:02.675]                           }
[16:05:02.675]                         }
[16:05:02.675]                       }
[16:05:02.675]                       invisible(muffled)
[16:05:02.675]                     }
[16:05:02.675]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.675]                   }
[16:05:02.675]                 }
[16:05:02.675]                 else {
[16:05:02.675]                   if (TRUE) {
[16:05:02.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.675]                     {
[16:05:02.675]                       inherits <- base::inherits
[16:05:02.675]                       invokeRestart <- base::invokeRestart
[16:05:02.675]                       is.null <- base::is.null
[16:05:02.675]                       muffled <- FALSE
[16:05:02.675]                       if (inherits(cond, "message")) {
[16:05:02.675]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.675]                         if (muffled) 
[16:05:02.675]                           invokeRestart("muffleMessage")
[16:05:02.675]                       }
[16:05:02.675]                       else if (inherits(cond, "warning")) {
[16:05:02.675]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.675]                         if (muffled) 
[16:05:02.675]                           invokeRestart("muffleWarning")
[16:05:02.675]                       }
[16:05:02.675]                       else if (inherits(cond, "condition")) {
[16:05:02.675]                         if (!is.null(pattern)) {
[16:05:02.675]                           computeRestarts <- base::computeRestarts
[16:05:02.675]                           grepl <- base::grepl
[16:05:02.675]                           restarts <- computeRestarts(cond)
[16:05:02.675]                           for (restart in restarts) {
[16:05:02.675]                             name <- restart$name
[16:05:02.675]                             if (is.null(name)) 
[16:05:02.675]                               next
[16:05:02.675]                             if (!grepl(pattern, name)) 
[16:05:02.675]                               next
[16:05:02.675]                             invokeRestart(restart)
[16:05:02.675]                             muffled <- TRUE
[16:05:02.675]                             break
[16:05:02.675]                           }
[16:05:02.675]                         }
[16:05:02.675]                       }
[16:05:02.675]                       invisible(muffled)
[16:05:02.675]                     }
[16:05:02.675]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.675]                   }
[16:05:02.675]                 }
[16:05:02.675]             }
[16:05:02.675]         }))
[16:05:02.675]     }, error = function(ex) {
[16:05:02.675]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:02.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.675]                 ...future.rng), started = ...future.startTime, 
[16:05:02.675]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:02.675]             version = "1.8"), class = "FutureResult")
[16:05:02.675]     }, finally = {
[16:05:02.675]         if (!identical(...future.workdir, getwd())) 
[16:05:02.675]             setwd(...future.workdir)
[16:05:02.675]         {
[16:05:02.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:02.675]                 ...future.oldOptions$nwarnings <- NULL
[16:05:02.675]             }
[16:05:02.675]             base::options(...future.oldOptions)
[16:05:02.675]             if (.Platform$OS.type == "windows") {
[16:05:02.675]                 old_names <- names(...future.oldEnvVars)
[16:05:02.675]                 envs <- base::Sys.getenv()
[16:05:02.675]                 names <- names(envs)
[16:05:02.675]                 common <- intersect(names, old_names)
[16:05:02.675]                 added <- setdiff(names, old_names)
[16:05:02.675]                 removed <- setdiff(old_names, names)
[16:05:02.675]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:02.675]                   envs[common]]
[16:05:02.675]                 NAMES <- toupper(changed)
[16:05:02.675]                 args <- list()
[16:05:02.675]                 for (kk in seq_along(NAMES)) {
[16:05:02.675]                   name <- changed[[kk]]
[16:05:02.675]                   NAME <- NAMES[[kk]]
[16:05:02.675]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.675]                     next
[16:05:02.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.675]                 }
[16:05:02.675]                 NAMES <- toupper(added)
[16:05:02.675]                 for (kk in seq_along(NAMES)) {
[16:05:02.675]                   name <- added[[kk]]
[16:05:02.675]                   NAME <- NAMES[[kk]]
[16:05:02.675]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.675]                     next
[16:05:02.675]                   args[[name]] <- ""
[16:05:02.675]                 }
[16:05:02.675]                 NAMES <- toupper(removed)
[16:05:02.675]                 for (kk in seq_along(NAMES)) {
[16:05:02.675]                   name <- removed[[kk]]
[16:05:02.675]                   NAME <- NAMES[[kk]]
[16:05:02.675]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.675]                     next
[16:05:02.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.675]                 }
[16:05:02.675]                 if (length(args) > 0) 
[16:05:02.675]                   base::do.call(base::Sys.setenv, args = args)
[16:05:02.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:02.675]             }
[16:05:02.675]             else {
[16:05:02.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:02.675]             }
[16:05:02.675]             {
[16:05:02.675]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:02.675]                   0L) {
[16:05:02.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:02.675]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:02.675]                   base::options(opts)
[16:05:02.675]                 }
[16:05:02.675]                 {
[16:05:02.675]                   {
[16:05:02.675]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:02.675]                     NULL
[16:05:02.675]                   }
[16:05:02.675]                   options(future.plan = NULL)
[16:05:02.675]                   if (is.na(NA_character_)) 
[16:05:02.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:02.675]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:02.675]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:02.675]                     envir = parent.frame()) 
[16:05:02.675]                   {
[16:05:02.675]                     if (is.function(workers)) 
[16:05:02.675]                       workers <- workers()
[16:05:02.675]                     workers <- structure(as.integer(workers), 
[16:05:02.675]                       class = class(workers))
[16:05:02.675]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:02.675]                       workers >= 1)
[16:05:02.675]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:02.675]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:02.675]                     }
[16:05:02.675]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:02.675]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:02.675]                       envir = envir)
[16:05:02.675]                     if (!future$lazy) 
[16:05:02.675]                       future <- run(future)
[16:05:02.675]                     invisible(future)
[16:05:02.675]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:02.675]                 }
[16:05:02.675]             }
[16:05:02.675]         }
[16:05:02.675]     })
[16:05:02.675]     if (TRUE) {
[16:05:02.675]         base::sink(type = "output", split = FALSE)
[16:05:02.675]         if (TRUE) {
[16:05:02.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:02.675]         }
[16:05:02.675]         else {
[16:05:02.675]             ...future.result["stdout"] <- base::list(NULL)
[16:05:02.675]         }
[16:05:02.675]         base::close(...future.stdout)
[16:05:02.675]         ...future.stdout <- NULL
[16:05:02.675]     }
[16:05:02.675]     ...future.result$conditions <- ...future.conditions
[16:05:02.675]     ...future.result$finished <- base::Sys.time()
[16:05:02.675]     ...future.result
[16:05:02.675] }
[16:05:02.678] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:05:02.678] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:05:02.678] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:05:02.678] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:05:02.679] MultisessionFuture started
[16:05:02.679] - Launch lazy future ... done
[16:05:02.680] run() for ‘MultisessionFuture’ ... done
[16:05:02.680] result() for ClusterFuture ...
[16:05:02.680] receiveMessageFromWorker() for ClusterFuture ...
[16:05:02.680] - Validating connection of MultisessionFuture
[16:05:02.728] - received message: FutureResult
[16:05:02.728] - Received FutureResult
[16:05:02.728] - Erased future from FutureRegistry
[16:05:02.729] result() for ClusterFuture ...
[16:05:02.729] - result already collected: FutureResult
[16:05:02.729] result() for ClusterFuture ... done
[16:05:02.729] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:02.729] result() for ClusterFuture ... done
[16:05:02.729] result() for ClusterFuture ...
[16:05:02.729] - result already collected: FutureResult
[16:05:02.729] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:02.730] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:02.730] Searching for globals...
[16:05:02.733] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:02.733] Searching for globals ... DONE
[16:05:02.733] Resolving globals: TRUE
[16:05:02.733] Resolving any globals that are futures ...
[16:05:02.733] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:02.733] Resolving any globals that are futures ... DONE
[16:05:02.734] Resolving futures part of globals (recursively) ...
[16:05:02.734] resolve() on list ...
[16:05:02.734]  recursive: 99
[16:05:02.734]  length: 1
[16:05:02.735]  elements: ‘x’
[16:05:02.735]  length: 0 (resolved future 1)
[16:05:02.735] resolve() on list ... DONE
[16:05:02.735] - globals: [1] ‘x’
[16:05:02.735] Resolving futures part of globals (recursively) ... DONE
[16:05:02.735] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:02.736] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:02.736] - globals: [1] ‘x’
[16:05:02.736] 
[16:05:02.736] getGlobalsAndPackages() ... DONE
[16:05:02.736] run() for ‘Future’ ...
[16:05:02.737] - state: ‘created’
[16:05:02.737] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:02.755] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:02.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:02.755]   - Field: ‘node’
[16:05:02.755]   - Field: ‘label’
[16:05:02.755]   - Field: ‘local’
[16:05:02.755]   - Field: ‘owner’
[16:05:02.756]   - Field: ‘envir’
[16:05:02.756]   - Field: ‘workers’
[16:05:02.756]   - Field: ‘packages’
[16:05:02.756]   - Field: ‘gc’
[16:05:02.756]   - Field: ‘conditions’
[16:05:02.756]   - Field: ‘persistent’
[16:05:02.756]   - Field: ‘expr’
[16:05:02.756]   - Field: ‘uuid’
[16:05:02.756]   - Field: ‘seed’
[16:05:02.756]   - Field: ‘version’
[16:05:02.756]   - Field: ‘result’
[16:05:02.757]   - Field: ‘asynchronous’
[16:05:02.757]   - Field: ‘calls’
[16:05:02.757]   - Field: ‘globals’
[16:05:02.757]   - Field: ‘stdout’
[16:05:02.757]   - Field: ‘earlySignal’
[16:05:02.757]   - Field: ‘lazy’
[16:05:02.757]   - Field: ‘state’
[16:05:02.757] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:02.757] - Launch lazy future ...
[16:05:02.758] Packages needed by the future expression (n = 0): <none>
[16:05:02.758] Packages needed by future strategies (n = 0): <none>
[16:05:02.758] {
[16:05:02.758]     {
[16:05:02.758]         {
[16:05:02.758]             ...future.startTime <- base::Sys.time()
[16:05:02.758]             {
[16:05:02.758]                 {
[16:05:02.758]                   {
[16:05:02.758]                     {
[16:05:02.758]                       base::local({
[16:05:02.758]                         has_future <- base::requireNamespace("future", 
[16:05:02.758]                           quietly = TRUE)
[16:05:02.758]                         if (has_future) {
[16:05:02.758]                           ns <- base::getNamespace("future")
[16:05:02.758]                           version <- ns[[".package"]][["version"]]
[16:05:02.758]                           if (is.null(version)) 
[16:05:02.758]                             version <- utils::packageVersion("future")
[16:05:02.758]                         }
[16:05:02.758]                         else {
[16:05:02.758]                           version <- NULL
[16:05:02.758]                         }
[16:05:02.758]                         if (!has_future || version < "1.8.0") {
[16:05:02.758]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:02.758]                             "", base::R.version$version.string), 
[16:05:02.758]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:02.758]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:02.758]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:02.758]                               "release", "version")], collapse = " "), 
[16:05:02.758]                             hostname = base::Sys.info()[["nodename"]])
[16:05:02.758]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:02.758]                             info)
[16:05:02.758]                           info <- base::paste(info, collapse = "; ")
[16:05:02.758]                           if (!has_future) {
[16:05:02.758]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:02.758]                               info)
[16:05:02.758]                           }
[16:05:02.758]                           else {
[16:05:02.758]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:02.758]                               info, version)
[16:05:02.758]                           }
[16:05:02.758]                           base::stop(msg)
[16:05:02.758]                         }
[16:05:02.758]                       })
[16:05:02.758]                     }
[16:05:02.758]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:02.758]                     base::options(mc.cores = 1L)
[16:05:02.758]                   }
[16:05:02.758]                   options(future.plan = NULL)
[16:05:02.758]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.758]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:02.758]                 }
[16:05:02.758]                 ...future.workdir <- getwd()
[16:05:02.758]             }
[16:05:02.758]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:02.758]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:02.758]         }
[16:05:02.758]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:02.758]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:02.758]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:02.758]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:02.758]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:02.758]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:02.758]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:02.758]             base::names(...future.oldOptions))
[16:05:02.758]     }
[16:05:02.758]     if (FALSE) {
[16:05:02.758]     }
[16:05:02.758]     else {
[16:05:02.758]         if (TRUE) {
[16:05:02.758]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:02.758]                 open = "w")
[16:05:02.758]         }
[16:05:02.758]         else {
[16:05:02.758]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:02.758]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:02.758]         }
[16:05:02.758]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:02.758]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:02.758]             base::sink(type = "output", split = FALSE)
[16:05:02.758]             base::close(...future.stdout)
[16:05:02.758]         }, add = TRUE)
[16:05:02.758]     }
[16:05:02.758]     ...future.frame <- base::sys.nframe()
[16:05:02.758]     ...future.conditions <- base::list()
[16:05:02.758]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:02.758]     if (FALSE) {
[16:05:02.758]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:02.758]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:02.758]     }
[16:05:02.758]     ...future.result <- base::tryCatch({
[16:05:02.758]         base::withCallingHandlers({
[16:05:02.758]             ...future.value <- base::withVisible(base::local({
[16:05:02.758]                 ...future.makeSendCondition <- base::local({
[16:05:02.758]                   sendCondition <- NULL
[16:05:02.758]                   function(frame = 1L) {
[16:05:02.758]                     if (is.function(sendCondition)) 
[16:05:02.758]                       return(sendCondition)
[16:05:02.758]                     ns <- getNamespace("parallel")
[16:05:02.758]                     if (exists("sendData", mode = "function", 
[16:05:02.758]                       envir = ns)) {
[16:05:02.758]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:02.758]                         envir = ns)
[16:05:02.758]                       envir <- sys.frame(frame)
[16:05:02.758]                       master <- NULL
[16:05:02.758]                       while (!identical(envir, .GlobalEnv) && 
[16:05:02.758]                         !identical(envir, emptyenv())) {
[16:05:02.758]                         if (exists("master", mode = "list", envir = envir, 
[16:05:02.758]                           inherits = FALSE)) {
[16:05:02.758]                           master <- get("master", mode = "list", 
[16:05:02.758]                             envir = envir, inherits = FALSE)
[16:05:02.758]                           if (inherits(master, c("SOCKnode", 
[16:05:02.758]                             "SOCK0node"))) {
[16:05:02.758]                             sendCondition <<- function(cond) {
[16:05:02.758]                               data <- list(type = "VALUE", value = cond, 
[16:05:02.758]                                 success = TRUE)
[16:05:02.758]                               parallel_sendData(master, data)
[16:05:02.758]                             }
[16:05:02.758]                             return(sendCondition)
[16:05:02.758]                           }
[16:05:02.758]                         }
[16:05:02.758]                         frame <- frame + 1L
[16:05:02.758]                         envir <- sys.frame(frame)
[16:05:02.758]                       }
[16:05:02.758]                     }
[16:05:02.758]                     sendCondition <<- function(cond) NULL
[16:05:02.758]                   }
[16:05:02.758]                 })
[16:05:02.758]                 withCallingHandlers({
[16:05:02.758]                   {
[16:05:02.758]                     x$a <- 1
[16:05:02.758]                     x
[16:05:02.758]                   }
[16:05:02.758]                 }, immediateCondition = function(cond) {
[16:05:02.758]                   sendCondition <- ...future.makeSendCondition()
[16:05:02.758]                   sendCondition(cond)
[16:05:02.758]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.758]                   {
[16:05:02.758]                     inherits <- base::inherits
[16:05:02.758]                     invokeRestart <- base::invokeRestart
[16:05:02.758]                     is.null <- base::is.null
[16:05:02.758]                     muffled <- FALSE
[16:05:02.758]                     if (inherits(cond, "message")) {
[16:05:02.758]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:02.758]                       if (muffled) 
[16:05:02.758]                         invokeRestart("muffleMessage")
[16:05:02.758]                     }
[16:05:02.758]                     else if (inherits(cond, "warning")) {
[16:05:02.758]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:02.758]                       if (muffled) 
[16:05:02.758]                         invokeRestart("muffleWarning")
[16:05:02.758]                     }
[16:05:02.758]                     else if (inherits(cond, "condition")) {
[16:05:02.758]                       if (!is.null(pattern)) {
[16:05:02.758]                         computeRestarts <- base::computeRestarts
[16:05:02.758]                         grepl <- base::grepl
[16:05:02.758]                         restarts <- computeRestarts(cond)
[16:05:02.758]                         for (restart in restarts) {
[16:05:02.758]                           name <- restart$name
[16:05:02.758]                           if (is.null(name)) 
[16:05:02.758]                             next
[16:05:02.758]                           if (!grepl(pattern, name)) 
[16:05:02.758]                             next
[16:05:02.758]                           invokeRestart(restart)
[16:05:02.758]                           muffled <- TRUE
[16:05:02.758]                           break
[16:05:02.758]                         }
[16:05:02.758]                       }
[16:05:02.758]                     }
[16:05:02.758]                     invisible(muffled)
[16:05:02.758]                   }
[16:05:02.758]                   muffleCondition(cond)
[16:05:02.758]                 })
[16:05:02.758]             }))
[16:05:02.758]             future::FutureResult(value = ...future.value$value, 
[16:05:02.758]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.758]                   ...future.rng), globalenv = if (FALSE) 
[16:05:02.758]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:02.758]                     ...future.globalenv.names))
[16:05:02.758]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:02.758]         }, condition = base::local({
[16:05:02.758]             c <- base::c
[16:05:02.758]             inherits <- base::inherits
[16:05:02.758]             invokeRestart <- base::invokeRestart
[16:05:02.758]             length <- base::length
[16:05:02.758]             list <- base::list
[16:05:02.758]             seq.int <- base::seq.int
[16:05:02.758]             signalCondition <- base::signalCondition
[16:05:02.758]             sys.calls <- base::sys.calls
[16:05:02.758]             `[[` <- base::`[[`
[16:05:02.758]             `+` <- base::`+`
[16:05:02.758]             `<<-` <- base::`<<-`
[16:05:02.758]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:02.758]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:02.758]                   3L)]
[16:05:02.758]             }
[16:05:02.758]             function(cond) {
[16:05:02.758]                 is_error <- inherits(cond, "error")
[16:05:02.758]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:02.758]                   NULL)
[16:05:02.758]                 if (is_error) {
[16:05:02.758]                   sessionInformation <- function() {
[16:05:02.758]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:02.758]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:02.758]                       search = base::search(), system = base::Sys.info())
[16:05:02.758]                   }
[16:05:02.758]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.758]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:02.758]                     cond$call), session = sessionInformation(), 
[16:05:02.758]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:02.758]                   signalCondition(cond)
[16:05:02.758]                 }
[16:05:02.758]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:02.758]                 "immediateCondition"))) {
[16:05:02.758]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:02.758]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.758]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:02.758]                   if (TRUE && !signal) {
[16:05:02.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.758]                     {
[16:05:02.758]                       inherits <- base::inherits
[16:05:02.758]                       invokeRestart <- base::invokeRestart
[16:05:02.758]                       is.null <- base::is.null
[16:05:02.758]                       muffled <- FALSE
[16:05:02.758]                       if (inherits(cond, "message")) {
[16:05:02.758]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.758]                         if (muffled) 
[16:05:02.758]                           invokeRestart("muffleMessage")
[16:05:02.758]                       }
[16:05:02.758]                       else if (inherits(cond, "warning")) {
[16:05:02.758]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.758]                         if (muffled) 
[16:05:02.758]                           invokeRestart("muffleWarning")
[16:05:02.758]                       }
[16:05:02.758]                       else if (inherits(cond, "condition")) {
[16:05:02.758]                         if (!is.null(pattern)) {
[16:05:02.758]                           computeRestarts <- base::computeRestarts
[16:05:02.758]                           grepl <- base::grepl
[16:05:02.758]                           restarts <- computeRestarts(cond)
[16:05:02.758]                           for (restart in restarts) {
[16:05:02.758]                             name <- restart$name
[16:05:02.758]                             if (is.null(name)) 
[16:05:02.758]                               next
[16:05:02.758]                             if (!grepl(pattern, name)) 
[16:05:02.758]                               next
[16:05:02.758]                             invokeRestart(restart)
[16:05:02.758]                             muffled <- TRUE
[16:05:02.758]                             break
[16:05:02.758]                           }
[16:05:02.758]                         }
[16:05:02.758]                       }
[16:05:02.758]                       invisible(muffled)
[16:05:02.758]                     }
[16:05:02.758]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.758]                   }
[16:05:02.758]                 }
[16:05:02.758]                 else {
[16:05:02.758]                   if (TRUE) {
[16:05:02.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.758]                     {
[16:05:02.758]                       inherits <- base::inherits
[16:05:02.758]                       invokeRestart <- base::invokeRestart
[16:05:02.758]                       is.null <- base::is.null
[16:05:02.758]                       muffled <- FALSE
[16:05:02.758]                       if (inherits(cond, "message")) {
[16:05:02.758]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.758]                         if (muffled) 
[16:05:02.758]                           invokeRestart("muffleMessage")
[16:05:02.758]                       }
[16:05:02.758]                       else if (inherits(cond, "warning")) {
[16:05:02.758]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.758]                         if (muffled) 
[16:05:02.758]                           invokeRestart("muffleWarning")
[16:05:02.758]                       }
[16:05:02.758]                       else if (inherits(cond, "condition")) {
[16:05:02.758]                         if (!is.null(pattern)) {
[16:05:02.758]                           computeRestarts <- base::computeRestarts
[16:05:02.758]                           grepl <- base::grepl
[16:05:02.758]                           restarts <- computeRestarts(cond)
[16:05:02.758]                           for (restart in restarts) {
[16:05:02.758]                             name <- restart$name
[16:05:02.758]                             if (is.null(name)) 
[16:05:02.758]                               next
[16:05:02.758]                             if (!grepl(pattern, name)) 
[16:05:02.758]                               next
[16:05:02.758]                             invokeRestart(restart)
[16:05:02.758]                             muffled <- TRUE
[16:05:02.758]                             break
[16:05:02.758]                           }
[16:05:02.758]                         }
[16:05:02.758]                       }
[16:05:02.758]                       invisible(muffled)
[16:05:02.758]                     }
[16:05:02.758]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.758]                   }
[16:05:02.758]                 }
[16:05:02.758]             }
[16:05:02.758]         }))
[16:05:02.758]     }, error = function(ex) {
[16:05:02.758]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:02.758]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.758]                 ...future.rng), started = ...future.startTime, 
[16:05:02.758]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:02.758]             version = "1.8"), class = "FutureResult")
[16:05:02.758]     }, finally = {
[16:05:02.758]         if (!identical(...future.workdir, getwd())) 
[16:05:02.758]             setwd(...future.workdir)
[16:05:02.758]         {
[16:05:02.758]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:02.758]                 ...future.oldOptions$nwarnings <- NULL
[16:05:02.758]             }
[16:05:02.758]             base::options(...future.oldOptions)
[16:05:02.758]             if (.Platform$OS.type == "windows") {
[16:05:02.758]                 old_names <- names(...future.oldEnvVars)
[16:05:02.758]                 envs <- base::Sys.getenv()
[16:05:02.758]                 names <- names(envs)
[16:05:02.758]                 common <- intersect(names, old_names)
[16:05:02.758]                 added <- setdiff(names, old_names)
[16:05:02.758]                 removed <- setdiff(old_names, names)
[16:05:02.758]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:02.758]                   envs[common]]
[16:05:02.758]                 NAMES <- toupper(changed)
[16:05:02.758]                 args <- list()
[16:05:02.758]                 for (kk in seq_along(NAMES)) {
[16:05:02.758]                   name <- changed[[kk]]
[16:05:02.758]                   NAME <- NAMES[[kk]]
[16:05:02.758]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.758]                     next
[16:05:02.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.758]                 }
[16:05:02.758]                 NAMES <- toupper(added)
[16:05:02.758]                 for (kk in seq_along(NAMES)) {
[16:05:02.758]                   name <- added[[kk]]
[16:05:02.758]                   NAME <- NAMES[[kk]]
[16:05:02.758]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.758]                     next
[16:05:02.758]                   args[[name]] <- ""
[16:05:02.758]                 }
[16:05:02.758]                 NAMES <- toupper(removed)
[16:05:02.758]                 for (kk in seq_along(NAMES)) {
[16:05:02.758]                   name <- removed[[kk]]
[16:05:02.758]                   NAME <- NAMES[[kk]]
[16:05:02.758]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.758]                     next
[16:05:02.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.758]                 }
[16:05:02.758]                 if (length(args) > 0) 
[16:05:02.758]                   base::do.call(base::Sys.setenv, args = args)
[16:05:02.758]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:02.758]             }
[16:05:02.758]             else {
[16:05:02.758]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:02.758]             }
[16:05:02.758]             {
[16:05:02.758]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:02.758]                   0L) {
[16:05:02.758]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:02.758]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:02.758]                   base::options(opts)
[16:05:02.758]                 }
[16:05:02.758]                 {
[16:05:02.758]                   {
[16:05:02.758]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:02.758]                     NULL
[16:05:02.758]                   }
[16:05:02.758]                   options(future.plan = NULL)
[16:05:02.758]                   if (is.na(NA_character_)) 
[16:05:02.758]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.758]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:02.758]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:02.758]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:02.758]                     envir = parent.frame()) 
[16:05:02.758]                   {
[16:05:02.758]                     if (is.function(workers)) 
[16:05:02.758]                       workers <- workers()
[16:05:02.758]                     workers <- structure(as.integer(workers), 
[16:05:02.758]                       class = class(workers))
[16:05:02.758]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:02.758]                       workers >= 1)
[16:05:02.758]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:02.758]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:02.758]                     }
[16:05:02.758]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:02.758]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:02.758]                       envir = envir)
[16:05:02.758]                     if (!future$lazy) 
[16:05:02.758]                       future <- run(future)
[16:05:02.758]                     invisible(future)
[16:05:02.758]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:02.758]                 }
[16:05:02.758]             }
[16:05:02.758]         }
[16:05:02.758]     })
[16:05:02.758]     if (TRUE) {
[16:05:02.758]         base::sink(type = "output", split = FALSE)
[16:05:02.758]         if (TRUE) {
[16:05:02.758]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:02.758]         }
[16:05:02.758]         else {
[16:05:02.758]             ...future.result["stdout"] <- base::list(NULL)
[16:05:02.758]         }
[16:05:02.758]         base::close(...future.stdout)
[16:05:02.758]         ...future.stdout <- NULL
[16:05:02.758]     }
[16:05:02.758]     ...future.result$conditions <- ...future.conditions
[16:05:02.758]     ...future.result$finished <- base::Sys.time()
[16:05:02.758]     ...future.result
[16:05:02.758] }
[16:05:02.761] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:05:02.761] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:05:02.761] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:05:02.761] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:05:02.762] MultisessionFuture started
[16:05:02.762] - Launch lazy future ... done
[16:05:02.762] run() for ‘MultisessionFuture’ ... done
[16:05:02.763] result() for ClusterFuture ...
[16:05:02.763] receiveMessageFromWorker() for ClusterFuture ...
[16:05:02.763] - Validating connection of MultisessionFuture
[16:05:02.808] - received message: FutureResult
[16:05:02.808] - Received FutureResult
[16:05:02.808] - Erased future from FutureRegistry
[16:05:02.808] result() for ClusterFuture ...
[16:05:02.808] - result already collected: FutureResult
[16:05:02.808] result() for ClusterFuture ... done
[16:05:02.809] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:02.809] result() for ClusterFuture ... done
[16:05:02.809] result() for ClusterFuture ...
[16:05:02.809] - result already collected: FutureResult
[16:05:02.809] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:02.809] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:02.810] Searching for globals...
[16:05:02.812] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:02.812] Searching for globals ... DONE
[16:05:02.812] Resolving globals: TRUE
[16:05:02.812] Resolving any globals that are futures ...
[16:05:02.812] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:05:02.812] Resolving any globals that are futures ... DONE
[16:05:02.812] Resolving futures part of globals (recursively) ...
[16:05:02.813] resolve() on list ...
[16:05:02.813]  recursive: 99
[16:05:02.813]  length: 1
[16:05:02.813]  elements: ‘x’
[16:05:02.813]  length: 0 (resolved future 1)
[16:05:02.813] resolve() on list ... DONE
[16:05:02.813] - globals: [1] ‘x’
[16:05:02.813] Resolving futures part of globals (recursively) ... DONE
[16:05:02.813] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:02.814] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:02.814] - globals: [1] ‘x’
[16:05:02.814] 
[16:05:02.814] getGlobalsAndPackages() ... DONE
[16:05:02.814] run() for ‘Future’ ...
[16:05:02.815] - state: ‘created’
[16:05:02.815] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:02.828] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:02.828] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:02.828]   - Field: ‘node’
[16:05:02.828]   - Field: ‘label’
[16:05:02.829]   - Field: ‘local’
[16:05:02.829]   - Field: ‘owner’
[16:05:02.829]   - Field: ‘envir’
[16:05:02.829]   - Field: ‘workers’
[16:05:02.829]   - Field: ‘packages’
[16:05:02.829]   - Field: ‘gc’
[16:05:02.829]   - Field: ‘conditions’
[16:05:02.829]   - Field: ‘persistent’
[16:05:02.829]   - Field: ‘expr’
[16:05:02.829]   - Field: ‘uuid’
[16:05:02.830]   - Field: ‘seed’
[16:05:02.830]   - Field: ‘version’
[16:05:02.830]   - Field: ‘result’
[16:05:02.830]   - Field: ‘asynchronous’
[16:05:02.830]   - Field: ‘calls’
[16:05:02.830]   - Field: ‘globals’
[16:05:02.830]   - Field: ‘stdout’
[16:05:02.830]   - Field: ‘earlySignal’
[16:05:02.830]   - Field: ‘lazy’
[16:05:02.830]   - Field: ‘state’
[16:05:02.830] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:02.831] - Launch lazy future ...
[16:05:02.831] Packages needed by the future expression (n = 0): <none>
[16:05:02.831] Packages needed by future strategies (n = 0): <none>
[16:05:02.831] {
[16:05:02.831]     {
[16:05:02.831]         {
[16:05:02.831]             ...future.startTime <- base::Sys.time()
[16:05:02.831]             {
[16:05:02.831]                 {
[16:05:02.831]                   {
[16:05:02.831]                     {
[16:05:02.831]                       base::local({
[16:05:02.831]                         has_future <- base::requireNamespace("future", 
[16:05:02.831]                           quietly = TRUE)
[16:05:02.831]                         if (has_future) {
[16:05:02.831]                           ns <- base::getNamespace("future")
[16:05:02.831]                           version <- ns[[".package"]][["version"]]
[16:05:02.831]                           if (is.null(version)) 
[16:05:02.831]                             version <- utils::packageVersion("future")
[16:05:02.831]                         }
[16:05:02.831]                         else {
[16:05:02.831]                           version <- NULL
[16:05:02.831]                         }
[16:05:02.831]                         if (!has_future || version < "1.8.0") {
[16:05:02.831]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:02.831]                             "", base::R.version$version.string), 
[16:05:02.831]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:02.831]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:02.831]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:02.831]                               "release", "version")], collapse = " "), 
[16:05:02.831]                             hostname = base::Sys.info()[["nodename"]])
[16:05:02.831]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:02.831]                             info)
[16:05:02.831]                           info <- base::paste(info, collapse = "; ")
[16:05:02.831]                           if (!has_future) {
[16:05:02.831]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:02.831]                               info)
[16:05:02.831]                           }
[16:05:02.831]                           else {
[16:05:02.831]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:02.831]                               info, version)
[16:05:02.831]                           }
[16:05:02.831]                           base::stop(msg)
[16:05:02.831]                         }
[16:05:02.831]                       })
[16:05:02.831]                     }
[16:05:02.831]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:02.831]                     base::options(mc.cores = 1L)
[16:05:02.831]                   }
[16:05:02.831]                   options(future.plan = NULL)
[16:05:02.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:02.831]                 }
[16:05:02.831]                 ...future.workdir <- getwd()
[16:05:02.831]             }
[16:05:02.831]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:02.831]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:02.831]         }
[16:05:02.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:02.831]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:02.831]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:02.831]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:02.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:02.831]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:02.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:02.831]             base::names(...future.oldOptions))
[16:05:02.831]     }
[16:05:02.831]     if (FALSE) {
[16:05:02.831]     }
[16:05:02.831]     else {
[16:05:02.831]         if (TRUE) {
[16:05:02.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:02.831]                 open = "w")
[16:05:02.831]         }
[16:05:02.831]         else {
[16:05:02.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:02.831]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:02.831]         }
[16:05:02.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:02.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:02.831]             base::sink(type = "output", split = FALSE)
[16:05:02.831]             base::close(...future.stdout)
[16:05:02.831]         }, add = TRUE)
[16:05:02.831]     }
[16:05:02.831]     ...future.frame <- base::sys.nframe()
[16:05:02.831]     ...future.conditions <- base::list()
[16:05:02.831]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:02.831]     if (FALSE) {
[16:05:02.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:02.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:02.831]     }
[16:05:02.831]     ...future.result <- base::tryCatch({
[16:05:02.831]         base::withCallingHandlers({
[16:05:02.831]             ...future.value <- base::withVisible(base::local({
[16:05:02.831]                 ...future.makeSendCondition <- base::local({
[16:05:02.831]                   sendCondition <- NULL
[16:05:02.831]                   function(frame = 1L) {
[16:05:02.831]                     if (is.function(sendCondition)) 
[16:05:02.831]                       return(sendCondition)
[16:05:02.831]                     ns <- getNamespace("parallel")
[16:05:02.831]                     if (exists("sendData", mode = "function", 
[16:05:02.831]                       envir = ns)) {
[16:05:02.831]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:02.831]                         envir = ns)
[16:05:02.831]                       envir <- sys.frame(frame)
[16:05:02.831]                       master <- NULL
[16:05:02.831]                       while (!identical(envir, .GlobalEnv) && 
[16:05:02.831]                         !identical(envir, emptyenv())) {
[16:05:02.831]                         if (exists("master", mode = "list", envir = envir, 
[16:05:02.831]                           inherits = FALSE)) {
[16:05:02.831]                           master <- get("master", mode = "list", 
[16:05:02.831]                             envir = envir, inherits = FALSE)
[16:05:02.831]                           if (inherits(master, c("SOCKnode", 
[16:05:02.831]                             "SOCK0node"))) {
[16:05:02.831]                             sendCondition <<- function(cond) {
[16:05:02.831]                               data <- list(type = "VALUE", value = cond, 
[16:05:02.831]                                 success = TRUE)
[16:05:02.831]                               parallel_sendData(master, data)
[16:05:02.831]                             }
[16:05:02.831]                             return(sendCondition)
[16:05:02.831]                           }
[16:05:02.831]                         }
[16:05:02.831]                         frame <- frame + 1L
[16:05:02.831]                         envir <- sys.frame(frame)
[16:05:02.831]                       }
[16:05:02.831]                     }
[16:05:02.831]                     sendCondition <<- function(cond) NULL
[16:05:02.831]                   }
[16:05:02.831]                 })
[16:05:02.831]                 withCallingHandlers({
[16:05:02.831]                   {
[16:05:02.831]                     x$a <- 1
[16:05:02.831]                     x
[16:05:02.831]                   }
[16:05:02.831]                 }, immediateCondition = function(cond) {
[16:05:02.831]                   sendCondition <- ...future.makeSendCondition()
[16:05:02.831]                   sendCondition(cond)
[16:05:02.831]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.831]                   {
[16:05:02.831]                     inherits <- base::inherits
[16:05:02.831]                     invokeRestart <- base::invokeRestart
[16:05:02.831]                     is.null <- base::is.null
[16:05:02.831]                     muffled <- FALSE
[16:05:02.831]                     if (inherits(cond, "message")) {
[16:05:02.831]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:02.831]                       if (muffled) 
[16:05:02.831]                         invokeRestart("muffleMessage")
[16:05:02.831]                     }
[16:05:02.831]                     else if (inherits(cond, "warning")) {
[16:05:02.831]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:02.831]                       if (muffled) 
[16:05:02.831]                         invokeRestart("muffleWarning")
[16:05:02.831]                     }
[16:05:02.831]                     else if (inherits(cond, "condition")) {
[16:05:02.831]                       if (!is.null(pattern)) {
[16:05:02.831]                         computeRestarts <- base::computeRestarts
[16:05:02.831]                         grepl <- base::grepl
[16:05:02.831]                         restarts <- computeRestarts(cond)
[16:05:02.831]                         for (restart in restarts) {
[16:05:02.831]                           name <- restart$name
[16:05:02.831]                           if (is.null(name)) 
[16:05:02.831]                             next
[16:05:02.831]                           if (!grepl(pattern, name)) 
[16:05:02.831]                             next
[16:05:02.831]                           invokeRestart(restart)
[16:05:02.831]                           muffled <- TRUE
[16:05:02.831]                           break
[16:05:02.831]                         }
[16:05:02.831]                       }
[16:05:02.831]                     }
[16:05:02.831]                     invisible(muffled)
[16:05:02.831]                   }
[16:05:02.831]                   muffleCondition(cond)
[16:05:02.831]                 })
[16:05:02.831]             }))
[16:05:02.831]             future::FutureResult(value = ...future.value$value, 
[16:05:02.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.831]                   ...future.rng), globalenv = if (FALSE) 
[16:05:02.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:02.831]                     ...future.globalenv.names))
[16:05:02.831]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:02.831]         }, condition = base::local({
[16:05:02.831]             c <- base::c
[16:05:02.831]             inherits <- base::inherits
[16:05:02.831]             invokeRestart <- base::invokeRestart
[16:05:02.831]             length <- base::length
[16:05:02.831]             list <- base::list
[16:05:02.831]             seq.int <- base::seq.int
[16:05:02.831]             signalCondition <- base::signalCondition
[16:05:02.831]             sys.calls <- base::sys.calls
[16:05:02.831]             `[[` <- base::`[[`
[16:05:02.831]             `+` <- base::`+`
[16:05:02.831]             `<<-` <- base::`<<-`
[16:05:02.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:02.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:02.831]                   3L)]
[16:05:02.831]             }
[16:05:02.831]             function(cond) {
[16:05:02.831]                 is_error <- inherits(cond, "error")
[16:05:02.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:02.831]                   NULL)
[16:05:02.831]                 if (is_error) {
[16:05:02.831]                   sessionInformation <- function() {
[16:05:02.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:02.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:02.831]                       search = base::search(), system = base::Sys.info())
[16:05:02.831]                   }
[16:05:02.831]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:02.831]                     cond$call), session = sessionInformation(), 
[16:05:02.831]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:02.831]                   signalCondition(cond)
[16:05:02.831]                 }
[16:05:02.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:02.831]                 "immediateCondition"))) {
[16:05:02.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:02.831]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:02.831]                   if (TRUE && !signal) {
[16:05:02.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.831]                     {
[16:05:02.831]                       inherits <- base::inherits
[16:05:02.831]                       invokeRestart <- base::invokeRestart
[16:05:02.831]                       is.null <- base::is.null
[16:05:02.831]                       muffled <- FALSE
[16:05:02.831]                       if (inherits(cond, "message")) {
[16:05:02.831]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.831]                         if (muffled) 
[16:05:02.831]                           invokeRestart("muffleMessage")
[16:05:02.831]                       }
[16:05:02.831]                       else if (inherits(cond, "warning")) {
[16:05:02.831]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.831]                         if (muffled) 
[16:05:02.831]                           invokeRestart("muffleWarning")
[16:05:02.831]                       }
[16:05:02.831]                       else if (inherits(cond, "condition")) {
[16:05:02.831]                         if (!is.null(pattern)) {
[16:05:02.831]                           computeRestarts <- base::computeRestarts
[16:05:02.831]                           grepl <- base::grepl
[16:05:02.831]                           restarts <- computeRestarts(cond)
[16:05:02.831]                           for (restart in restarts) {
[16:05:02.831]                             name <- restart$name
[16:05:02.831]                             if (is.null(name)) 
[16:05:02.831]                               next
[16:05:02.831]                             if (!grepl(pattern, name)) 
[16:05:02.831]                               next
[16:05:02.831]                             invokeRestart(restart)
[16:05:02.831]                             muffled <- TRUE
[16:05:02.831]                             break
[16:05:02.831]                           }
[16:05:02.831]                         }
[16:05:02.831]                       }
[16:05:02.831]                       invisible(muffled)
[16:05:02.831]                     }
[16:05:02.831]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.831]                   }
[16:05:02.831]                 }
[16:05:02.831]                 else {
[16:05:02.831]                   if (TRUE) {
[16:05:02.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.831]                     {
[16:05:02.831]                       inherits <- base::inherits
[16:05:02.831]                       invokeRestart <- base::invokeRestart
[16:05:02.831]                       is.null <- base::is.null
[16:05:02.831]                       muffled <- FALSE
[16:05:02.831]                       if (inherits(cond, "message")) {
[16:05:02.831]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.831]                         if (muffled) 
[16:05:02.831]                           invokeRestart("muffleMessage")
[16:05:02.831]                       }
[16:05:02.831]                       else if (inherits(cond, "warning")) {
[16:05:02.831]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.831]                         if (muffled) 
[16:05:02.831]                           invokeRestart("muffleWarning")
[16:05:02.831]                       }
[16:05:02.831]                       else if (inherits(cond, "condition")) {
[16:05:02.831]                         if (!is.null(pattern)) {
[16:05:02.831]                           computeRestarts <- base::computeRestarts
[16:05:02.831]                           grepl <- base::grepl
[16:05:02.831]                           restarts <- computeRestarts(cond)
[16:05:02.831]                           for (restart in restarts) {
[16:05:02.831]                             name <- restart$name
[16:05:02.831]                             if (is.null(name)) 
[16:05:02.831]                               next
[16:05:02.831]                             if (!grepl(pattern, name)) 
[16:05:02.831]                               next
[16:05:02.831]                             invokeRestart(restart)
[16:05:02.831]                             muffled <- TRUE
[16:05:02.831]                             break
[16:05:02.831]                           }
[16:05:02.831]                         }
[16:05:02.831]                       }
[16:05:02.831]                       invisible(muffled)
[16:05:02.831]                     }
[16:05:02.831]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.831]                   }
[16:05:02.831]                 }
[16:05:02.831]             }
[16:05:02.831]         }))
[16:05:02.831]     }, error = function(ex) {
[16:05:02.831]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:02.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.831]                 ...future.rng), started = ...future.startTime, 
[16:05:02.831]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:02.831]             version = "1.8"), class = "FutureResult")
[16:05:02.831]     }, finally = {
[16:05:02.831]         if (!identical(...future.workdir, getwd())) 
[16:05:02.831]             setwd(...future.workdir)
[16:05:02.831]         {
[16:05:02.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:02.831]                 ...future.oldOptions$nwarnings <- NULL
[16:05:02.831]             }
[16:05:02.831]             base::options(...future.oldOptions)
[16:05:02.831]             if (.Platform$OS.type == "windows") {
[16:05:02.831]                 old_names <- names(...future.oldEnvVars)
[16:05:02.831]                 envs <- base::Sys.getenv()
[16:05:02.831]                 names <- names(envs)
[16:05:02.831]                 common <- intersect(names, old_names)
[16:05:02.831]                 added <- setdiff(names, old_names)
[16:05:02.831]                 removed <- setdiff(old_names, names)
[16:05:02.831]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:02.831]                   envs[common]]
[16:05:02.831]                 NAMES <- toupper(changed)
[16:05:02.831]                 args <- list()
[16:05:02.831]                 for (kk in seq_along(NAMES)) {
[16:05:02.831]                   name <- changed[[kk]]
[16:05:02.831]                   NAME <- NAMES[[kk]]
[16:05:02.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.831]                     next
[16:05:02.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.831]                 }
[16:05:02.831]                 NAMES <- toupper(added)
[16:05:02.831]                 for (kk in seq_along(NAMES)) {
[16:05:02.831]                   name <- added[[kk]]
[16:05:02.831]                   NAME <- NAMES[[kk]]
[16:05:02.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.831]                     next
[16:05:02.831]                   args[[name]] <- ""
[16:05:02.831]                 }
[16:05:02.831]                 NAMES <- toupper(removed)
[16:05:02.831]                 for (kk in seq_along(NAMES)) {
[16:05:02.831]                   name <- removed[[kk]]
[16:05:02.831]                   NAME <- NAMES[[kk]]
[16:05:02.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.831]                     next
[16:05:02.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.831]                 }
[16:05:02.831]                 if (length(args) > 0) 
[16:05:02.831]                   base::do.call(base::Sys.setenv, args = args)
[16:05:02.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:02.831]             }
[16:05:02.831]             else {
[16:05:02.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:02.831]             }
[16:05:02.831]             {
[16:05:02.831]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:02.831]                   0L) {
[16:05:02.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:02.831]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:02.831]                   base::options(opts)
[16:05:02.831]                 }
[16:05:02.831]                 {
[16:05:02.831]                   {
[16:05:02.831]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:02.831]                     NULL
[16:05:02.831]                   }
[16:05:02.831]                   options(future.plan = NULL)
[16:05:02.831]                   if (is.na(NA_character_)) 
[16:05:02.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:02.831]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:02.831]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:02.831]                     envir = parent.frame()) 
[16:05:02.831]                   {
[16:05:02.831]                     if (is.function(workers)) 
[16:05:02.831]                       workers <- workers()
[16:05:02.831]                     workers <- structure(as.integer(workers), 
[16:05:02.831]                       class = class(workers))
[16:05:02.831]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:02.831]                       workers >= 1)
[16:05:02.831]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:02.831]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:02.831]                     }
[16:05:02.831]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:02.831]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:02.831]                       envir = envir)
[16:05:02.831]                     if (!future$lazy) 
[16:05:02.831]                       future <- run(future)
[16:05:02.831]                     invisible(future)
[16:05:02.831]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:02.831]                 }
[16:05:02.831]             }
[16:05:02.831]         }
[16:05:02.831]     })
[16:05:02.831]     if (TRUE) {
[16:05:02.831]         base::sink(type = "output", split = FALSE)
[16:05:02.831]         if (TRUE) {
[16:05:02.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:02.831]         }
[16:05:02.831]         else {
[16:05:02.831]             ...future.result["stdout"] <- base::list(NULL)
[16:05:02.831]         }
[16:05:02.831]         base::close(...future.stdout)
[16:05:02.831]         ...future.stdout <- NULL
[16:05:02.831]     }
[16:05:02.831]     ...future.result$conditions <- ...future.conditions
[16:05:02.831]     ...future.result$finished <- base::Sys.time()
[16:05:02.831]     ...future.result
[16:05:02.831] }
[16:05:02.834] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:05:02.834] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:05:02.835] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:05:02.835] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:05:02.835] MultisessionFuture started
[16:05:02.835] - Launch lazy future ... done
[16:05:02.835] run() for ‘MultisessionFuture’ ... done
[16:05:02.836] result() for ClusterFuture ...
[16:05:02.836] receiveMessageFromWorker() for ClusterFuture ...
[16:05:02.836] - Validating connection of MultisessionFuture
[16:05:02.884] - received message: FutureResult
[16:05:02.884] - Received FutureResult
[16:05:02.884] - Erased future from FutureRegistry
[16:05:02.884] result() for ClusterFuture ...
[16:05:02.885] - result already collected: FutureResult
[16:05:02.885] result() for ClusterFuture ... done
[16:05:02.885] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:02.885] result() for ClusterFuture ... done
[16:05:02.885] result() for ClusterFuture ...
[16:05:02.885] - result already collected: FutureResult
[16:05:02.885] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:02.886] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:02.886] Searching for globals...
[16:05:02.889] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[16:05:02.889] Searching for globals ... DONE
[16:05:02.889] Resolving globals: TRUE
[16:05:02.889] Resolving any globals that are futures ...
[16:05:02.889] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[16:05:02.889] Resolving any globals that are futures ... DONE
[16:05:02.890] 
[16:05:02.890] 
[16:05:02.890] getGlobalsAndPackages() ... DONE
[16:05:02.890] run() for ‘Future’ ...
[16:05:02.890] - state: ‘created’
[16:05:02.890] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:02.904] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:02.904] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:02.904]   - Field: ‘node’
[16:05:02.904]   - Field: ‘label’
[16:05:02.905]   - Field: ‘local’
[16:05:02.905]   - Field: ‘owner’
[16:05:02.905]   - Field: ‘envir’
[16:05:02.905]   - Field: ‘workers’
[16:05:02.905]   - Field: ‘packages’
[16:05:02.905]   - Field: ‘gc’
[16:05:02.905]   - Field: ‘conditions’
[16:05:02.905]   - Field: ‘persistent’
[16:05:02.905]   - Field: ‘expr’
[16:05:02.905]   - Field: ‘uuid’
[16:05:02.906]   - Field: ‘seed’
[16:05:02.906]   - Field: ‘version’
[16:05:02.906]   - Field: ‘result’
[16:05:02.906]   - Field: ‘asynchronous’
[16:05:02.906]   - Field: ‘calls’
[16:05:02.906]   - Field: ‘globals’
[16:05:02.906]   - Field: ‘stdout’
[16:05:02.906]   - Field: ‘earlySignal’
[16:05:02.906]   - Field: ‘lazy’
[16:05:02.906]   - Field: ‘state’
[16:05:02.907] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:02.907] - Launch lazy future ...
[16:05:02.907] Packages needed by the future expression (n = 0): <none>
[16:05:02.907] Packages needed by future strategies (n = 0): <none>
[16:05:02.907] {
[16:05:02.907]     {
[16:05:02.907]         {
[16:05:02.907]             ...future.startTime <- base::Sys.time()
[16:05:02.907]             {
[16:05:02.907]                 {
[16:05:02.907]                   {
[16:05:02.907]                     {
[16:05:02.907]                       base::local({
[16:05:02.907]                         has_future <- base::requireNamespace("future", 
[16:05:02.907]                           quietly = TRUE)
[16:05:02.907]                         if (has_future) {
[16:05:02.907]                           ns <- base::getNamespace("future")
[16:05:02.907]                           version <- ns[[".package"]][["version"]]
[16:05:02.907]                           if (is.null(version)) 
[16:05:02.907]                             version <- utils::packageVersion("future")
[16:05:02.907]                         }
[16:05:02.907]                         else {
[16:05:02.907]                           version <- NULL
[16:05:02.907]                         }
[16:05:02.907]                         if (!has_future || version < "1.8.0") {
[16:05:02.907]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:02.907]                             "", base::R.version$version.string), 
[16:05:02.907]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:02.907]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:02.907]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:02.907]                               "release", "version")], collapse = " "), 
[16:05:02.907]                             hostname = base::Sys.info()[["nodename"]])
[16:05:02.907]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:02.907]                             info)
[16:05:02.907]                           info <- base::paste(info, collapse = "; ")
[16:05:02.907]                           if (!has_future) {
[16:05:02.907]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:02.907]                               info)
[16:05:02.907]                           }
[16:05:02.907]                           else {
[16:05:02.907]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:02.907]                               info, version)
[16:05:02.907]                           }
[16:05:02.907]                           base::stop(msg)
[16:05:02.907]                         }
[16:05:02.907]                       })
[16:05:02.907]                     }
[16:05:02.907]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:02.907]                     base::options(mc.cores = 1L)
[16:05:02.907]                   }
[16:05:02.907]                   options(future.plan = NULL)
[16:05:02.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:02.907]                 }
[16:05:02.907]                 ...future.workdir <- getwd()
[16:05:02.907]             }
[16:05:02.907]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:02.907]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:02.907]         }
[16:05:02.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:02.907]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:02.907]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:02.907]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:02.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:02.907]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:02.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:02.907]             base::names(...future.oldOptions))
[16:05:02.907]     }
[16:05:02.907]     if (FALSE) {
[16:05:02.907]     }
[16:05:02.907]     else {
[16:05:02.907]         if (TRUE) {
[16:05:02.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:02.907]                 open = "w")
[16:05:02.907]         }
[16:05:02.907]         else {
[16:05:02.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:02.907]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:02.907]         }
[16:05:02.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:02.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:02.907]             base::sink(type = "output", split = FALSE)
[16:05:02.907]             base::close(...future.stdout)
[16:05:02.907]         }, add = TRUE)
[16:05:02.907]     }
[16:05:02.907]     ...future.frame <- base::sys.nframe()
[16:05:02.907]     ...future.conditions <- base::list()
[16:05:02.907]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:02.907]     if (FALSE) {
[16:05:02.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:02.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:02.907]     }
[16:05:02.907]     ...future.result <- base::tryCatch({
[16:05:02.907]         base::withCallingHandlers({
[16:05:02.907]             ...future.value <- base::withVisible(base::local({
[16:05:02.907]                 ...future.makeSendCondition <- base::local({
[16:05:02.907]                   sendCondition <- NULL
[16:05:02.907]                   function(frame = 1L) {
[16:05:02.907]                     if (is.function(sendCondition)) 
[16:05:02.907]                       return(sendCondition)
[16:05:02.907]                     ns <- getNamespace("parallel")
[16:05:02.907]                     if (exists("sendData", mode = "function", 
[16:05:02.907]                       envir = ns)) {
[16:05:02.907]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:02.907]                         envir = ns)
[16:05:02.907]                       envir <- sys.frame(frame)
[16:05:02.907]                       master <- NULL
[16:05:02.907]                       while (!identical(envir, .GlobalEnv) && 
[16:05:02.907]                         !identical(envir, emptyenv())) {
[16:05:02.907]                         if (exists("master", mode = "list", envir = envir, 
[16:05:02.907]                           inherits = FALSE)) {
[16:05:02.907]                           master <- get("master", mode = "list", 
[16:05:02.907]                             envir = envir, inherits = FALSE)
[16:05:02.907]                           if (inherits(master, c("SOCKnode", 
[16:05:02.907]                             "SOCK0node"))) {
[16:05:02.907]                             sendCondition <<- function(cond) {
[16:05:02.907]                               data <- list(type = "VALUE", value = cond, 
[16:05:02.907]                                 success = TRUE)
[16:05:02.907]                               parallel_sendData(master, data)
[16:05:02.907]                             }
[16:05:02.907]                             return(sendCondition)
[16:05:02.907]                           }
[16:05:02.907]                         }
[16:05:02.907]                         frame <- frame + 1L
[16:05:02.907]                         envir <- sys.frame(frame)
[16:05:02.907]                       }
[16:05:02.907]                     }
[16:05:02.907]                     sendCondition <<- function(cond) NULL
[16:05:02.907]                   }
[16:05:02.907]                 })
[16:05:02.907]                 withCallingHandlers({
[16:05:02.907]                   {
[16:05:02.907]                     x <- list(b = 2)
[16:05:02.907]                     x$a <- 1
[16:05:02.907]                     x
[16:05:02.907]                   }
[16:05:02.907]                 }, immediateCondition = function(cond) {
[16:05:02.907]                   sendCondition <- ...future.makeSendCondition()
[16:05:02.907]                   sendCondition(cond)
[16:05:02.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.907]                   {
[16:05:02.907]                     inherits <- base::inherits
[16:05:02.907]                     invokeRestart <- base::invokeRestart
[16:05:02.907]                     is.null <- base::is.null
[16:05:02.907]                     muffled <- FALSE
[16:05:02.907]                     if (inherits(cond, "message")) {
[16:05:02.907]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:02.907]                       if (muffled) 
[16:05:02.907]                         invokeRestart("muffleMessage")
[16:05:02.907]                     }
[16:05:02.907]                     else if (inherits(cond, "warning")) {
[16:05:02.907]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:02.907]                       if (muffled) 
[16:05:02.907]                         invokeRestart("muffleWarning")
[16:05:02.907]                     }
[16:05:02.907]                     else if (inherits(cond, "condition")) {
[16:05:02.907]                       if (!is.null(pattern)) {
[16:05:02.907]                         computeRestarts <- base::computeRestarts
[16:05:02.907]                         grepl <- base::grepl
[16:05:02.907]                         restarts <- computeRestarts(cond)
[16:05:02.907]                         for (restart in restarts) {
[16:05:02.907]                           name <- restart$name
[16:05:02.907]                           if (is.null(name)) 
[16:05:02.907]                             next
[16:05:02.907]                           if (!grepl(pattern, name)) 
[16:05:02.907]                             next
[16:05:02.907]                           invokeRestart(restart)
[16:05:02.907]                           muffled <- TRUE
[16:05:02.907]                           break
[16:05:02.907]                         }
[16:05:02.907]                       }
[16:05:02.907]                     }
[16:05:02.907]                     invisible(muffled)
[16:05:02.907]                   }
[16:05:02.907]                   muffleCondition(cond)
[16:05:02.907]                 })
[16:05:02.907]             }))
[16:05:02.907]             future::FutureResult(value = ...future.value$value, 
[16:05:02.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.907]                   ...future.rng), globalenv = if (FALSE) 
[16:05:02.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:02.907]                     ...future.globalenv.names))
[16:05:02.907]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:02.907]         }, condition = base::local({
[16:05:02.907]             c <- base::c
[16:05:02.907]             inherits <- base::inherits
[16:05:02.907]             invokeRestart <- base::invokeRestart
[16:05:02.907]             length <- base::length
[16:05:02.907]             list <- base::list
[16:05:02.907]             seq.int <- base::seq.int
[16:05:02.907]             signalCondition <- base::signalCondition
[16:05:02.907]             sys.calls <- base::sys.calls
[16:05:02.907]             `[[` <- base::`[[`
[16:05:02.907]             `+` <- base::`+`
[16:05:02.907]             `<<-` <- base::`<<-`
[16:05:02.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:02.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:02.907]                   3L)]
[16:05:02.907]             }
[16:05:02.907]             function(cond) {
[16:05:02.907]                 is_error <- inherits(cond, "error")
[16:05:02.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:02.907]                   NULL)
[16:05:02.907]                 if (is_error) {
[16:05:02.907]                   sessionInformation <- function() {
[16:05:02.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:02.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:02.907]                       search = base::search(), system = base::Sys.info())
[16:05:02.907]                   }
[16:05:02.907]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:02.907]                     cond$call), session = sessionInformation(), 
[16:05:02.907]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:02.907]                   signalCondition(cond)
[16:05:02.907]                 }
[16:05:02.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:02.907]                 "immediateCondition"))) {
[16:05:02.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:02.907]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:02.907]                   if (TRUE && !signal) {
[16:05:02.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.907]                     {
[16:05:02.907]                       inherits <- base::inherits
[16:05:02.907]                       invokeRestart <- base::invokeRestart
[16:05:02.907]                       is.null <- base::is.null
[16:05:02.907]                       muffled <- FALSE
[16:05:02.907]                       if (inherits(cond, "message")) {
[16:05:02.907]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.907]                         if (muffled) 
[16:05:02.907]                           invokeRestart("muffleMessage")
[16:05:02.907]                       }
[16:05:02.907]                       else if (inherits(cond, "warning")) {
[16:05:02.907]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.907]                         if (muffled) 
[16:05:02.907]                           invokeRestart("muffleWarning")
[16:05:02.907]                       }
[16:05:02.907]                       else if (inherits(cond, "condition")) {
[16:05:02.907]                         if (!is.null(pattern)) {
[16:05:02.907]                           computeRestarts <- base::computeRestarts
[16:05:02.907]                           grepl <- base::grepl
[16:05:02.907]                           restarts <- computeRestarts(cond)
[16:05:02.907]                           for (restart in restarts) {
[16:05:02.907]                             name <- restart$name
[16:05:02.907]                             if (is.null(name)) 
[16:05:02.907]                               next
[16:05:02.907]                             if (!grepl(pattern, name)) 
[16:05:02.907]                               next
[16:05:02.907]                             invokeRestart(restart)
[16:05:02.907]                             muffled <- TRUE
[16:05:02.907]                             break
[16:05:02.907]                           }
[16:05:02.907]                         }
[16:05:02.907]                       }
[16:05:02.907]                       invisible(muffled)
[16:05:02.907]                     }
[16:05:02.907]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.907]                   }
[16:05:02.907]                 }
[16:05:02.907]                 else {
[16:05:02.907]                   if (TRUE) {
[16:05:02.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.907]                     {
[16:05:02.907]                       inherits <- base::inherits
[16:05:02.907]                       invokeRestart <- base::invokeRestart
[16:05:02.907]                       is.null <- base::is.null
[16:05:02.907]                       muffled <- FALSE
[16:05:02.907]                       if (inherits(cond, "message")) {
[16:05:02.907]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.907]                         if (muffled) 
[16:05:02.907]                           invokeRestart("muffleMessage")
[16:05:02.907]                       }
[16:05:02.907]                       else if (inherits(cond, "warning")) {
[16:05:02.907]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.907]                         if (muffled) 
[16:05:02.907]                           invokeRestart("muffleWarning")
[16:05:02.907]                       }
[16:05:02.907]                       else if (inherits(cond, "condition")) {
[16:05:02.907]                         if (!is.null(pattern)) {
[16:05:02.907]                           computeRestarts <- base::computeRestarts
[16:05:02.907]                           grepl <- base::grepl
[16:05:02.907]                           restarts <- computeRestarts(cond)
[16:05:02.907]                           for (restart in restarts) {
[16:05:02.907]                             name <- restart$name
[16:05:02.907]                             if (is.null(name)) 
[16:05:02.907]                               next
[16:05:02.907]                             if (!grepl(pattern, name)) 
[16:05:02.907]                               next
[16:05:02.907]                             invokeRestart(restart)
[16:05:02.907]                             muffled <- TRUE
[16:05:02.907]                             break
[16:05:02.907]                           }
[16:05:02.907]                         }
[16:05:02.907]                       }
[16:05:02.907]                       invisible(muffled)
[16:05:02.907]                     }
[16:05:02.907]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.907]                   }
[16:05:02.907]                 }
[16:05:02.907]             }
[16:05:02.907]         }))
[16:05:02.907]     }, error = function(ex) {
[16:05:02.907]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:02.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.907]                 ...future.rng), started = ...future.startTime, 
[16:05:02.907]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:02.907]             version = "1.8"), class = "FutureResult")
[16:05:02.907]     }, finally = {
[16:05:02.907]         if (!identical(...future.workdir, getwd())) 
[16:05:02.907]             setwd(...future.workdir)
[16:05:02.907]         {
[16:05:02.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:02.907]                 ...future.oldOptions$nwarnings <- NULL
[16:05:02.907]             }
[16:05:02.907]             base::options(...future.oldOptions)
[16:05:02.907]             if (.Platform$OS.type == "windows") {
[16:05:02.907]                 old_names <- names(...future.oldEnvVars)
[16:05:02.907]                 envs <- base::Sys.getenv()
[16:05:02.907]                 names <- names(envs)
[16:05:02.907]                 common <- intersect(names, old_names)
[16:05:02.907]                 added <- setdiff(names, old_names)
[16:05:02.907]                 removed <- setdiff(old_names, names)
[16:05:02.907]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:02.907]                   envs[common]]
[16:05:02.907]                 NAMES <- toupper(changed)
[16:05:02.907]                 args <- list()
[16:05:02.907]                 for (kk in seq_along(NAMES)) {
[16:05:02.907]                   name <- changed[[kk]]
[16:05:02.907]                   NAME <- NAMES[[kk]]
[16:05:02.907]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.907]                     next
[16:05:02.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.907]                 }
[16:05:02.907]                 NAMES <- toupper(added)
[16:05:02.907]                 for (kk in seq_along(NAMES)) {
[16:05:02.907]                   name <- added[[kk]]
[16:05:02.907]                   NAME <- NAMES[[kk]]
[16:05:02.907]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.907]                     next
[16:05:02.907]                   args[[name]] <- ""
[16:05:02.907]                 }
[16:05:02.907]                 NAMES <- toupper(removed)
[16:05:02.907]                 for (kk in seq_along(NAMES)) {
[16:05:02.907]                   name <- removed[[kk]]
[16:05:02.907]                   NAME <- NAMES[[kk]]
[16:05:02.907]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.907]                     next
[16:05:02.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.907]                 }
[16:05:02.907]                 if (length(args) > 0) 
[16:05:02.907]                   base::do.call(base::Sys.setenv, args = args)
[16:05:02.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:02.907]             }
[16:05:02.907]             else {
[16:05:02.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:02.907]             }
[16:05:02.907]             {
[16:05:02.907]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:02.907]                   0L) {
[16:05:02.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:02.907]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:02.907]                   base::options(opts)
[16:05:02.907]                 }
[16:05:02.907]                 {
[16:05:02.907]                   {
[16:05:02.907]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:02.907]                     NULL
[16:05:02.907]                   }
[16:05:02.907]                   options(future.plan = NULL)
[16:05:02.907]                   if (is.na(NA_character_)) 
[16:05:02.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:02.907]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:02.907]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:02.907]                     envir = parent.frame()) 
[16:05:02.907]                   {
[16:05:02.907]                     if (is.function(workers)) 
[16:05:02.907]                       workers <- workers()
[16:05:02.907]                     workers <- structure(as.integer(workers), 
[16:05:02.907]                       class = class(workers))
[16:05:02.907]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:02.907]                       workers >= 1)
[16:05:02.907]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:02.907]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:02.907]                     }
[16:05:02.907]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:02.907]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:02.907]                       envir = envir)
[16:05:02.907]                     if (!future$lazy) 
[16:05:02.907]                       future <- run(future)
[16:05:02.907]                     invisible(future)
[16:05:02.907]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:02.907]                 }
[16:05:02.907]             }
[16:05:02.907]         }
[16:05:02.907]     })
[16:05:02.907]     if (TRUE) {
[16:05:02.907]         base::sink(type = "output", split = FALSE)
[16:05:02.907]         if (TRUE) {
[16:05:02.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:02.907]         }
[16:05:02.907]         else {
[16:05:02.907]             ...future.result["stdout"] <- base::list(NULL)
[16:05:02.907]         }
[16:05:02.907]         base::close(...future.stdout)
[16:05:02.907]         ...future.stdout <- NULL
[16:05:02.907]     }
[16:05:02.907]     ...future.result$conditions <- ...future.conditions
[16:05:02.907]     ...future.result$finished <- base::Sys.time()
[16:05:02.907]     ...future.result
[16:05:02.907] }
[16:05:02.911] MultisessionFuture started
[16:05:02.911] - Launch lazy future ... done
[16:05:02.911] run() for ‘MultisessionFuture’ ... done
[16:05:02.911] result() for ClusterFuture ...
[16:05:02.911] receiveMessageFromWorker() for ClusterFuture ...
[16:05:02.911] - Validating connection of MultisessionFuture
[16:05:02.956] - received message: FutureResult
[16:05:02.956] - Received FutureResult
[16:05:02.956] - Erased future from FutureRegistry
[16:05:02.956] result() for ClusterFuture ...
[16:05:02.956] - result already collected: FutureResult
[16:05:02.956] result() for ClusterFuture ... done
[16:05:02.956] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:02.956] result() for ClusterFuture ... done
[16:05:02.957] result() for ClusterFuture ...
[16:05:02.957] - result already collected: FutureResult
[16:05:02.957] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:02.957] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:02.957] Searching for globals...
[16:05:02.959] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:02.959] Searching for globals ... DONE
[16:05:02.959] Resolving globals: TRUE
[16:05:02.960] Resolving any globals that are futures ...
[16:05:02.960] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:02.960] Resolving any globals that are futures ... DONE
[16:05:02.960] Resolving futures part of globals (recursively) ...
[16:05:02.960] resolve() on list ...
[16:05:02.960]  recursive: 99
[16:05:02.961]  length: 1
[16:05:02.961]  elements: ‘x’
[16:05:02.961]  length: 0 (resolved future 1)
[16:05:02.961] resolve() on list ... DONE
[16:05:02.961] - globals: [1] ‘x’
[16:05:02.961] Resolving futures part of globals (recursively) ... DONE
[16:05:02.961] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:02.962] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:02.962] - globals: [1] ‘x’
[16:05:02.962] 
[16:05:02.962] getGlobalsAndPackages() ... DONE
[16:05:02.962] run() for ‘Future’ ...
[16:05:02.962] - state: ‘created’
[16:05:02.962] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:02.976] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:02.976] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:02.976]   - Field: ‘node’
[16:05:02.976]   - Field: ‘label’
[16:05:02.977]   - Field: ‘local’
[16:05:02.977]   - Field: ‘owner’
[16:05:02.977]   - Field: ‘envir’
[16:05:02.977]   - Field: ‘workers’
[16:05:02.977]   - Field: ‘packages’
[16:05:02.977]   - Field: ‘gc’
[16:05:02.977]   - Field: ‘conditions’
[16:05:02.977]   - Field: ‘persistent’
[16:05:02.977]   - Field: ‘expr’
[16:05:02.977]   - Field: ‘uuid’
[16:05:02.978]   - Field: ‘seed’
[16:05:02.978]   - Field: ‘version’
[16:05:02.978]   - Field: ‘result’
[16:05:02.978]   - Field: ‘asynchronous’
[16:05:02.978]   - Field: ‘calls’
[16:05:02.978]   - Field: ‘globals’
[16:05:02.978]   - Field: ‘stdout’
[16:05:02.978]   - Field: ‘earlySignal’
[16:05:02.978]   - Field: ‘lazy’
[16:05:02.978]   - Field: ‘state’
[16:05:02.978] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:02.979] - Launch lazy future ...
[16:05:02.979] Packages needed by the future expression (n = 0): <none>
[16:05:02.979] Packages needed by future strategies (n = 0): <none>
[16:05:02.979] {
[16:05:02.979]     {
[16:05:02.979]         {
[16:05:02.979]             ...future.startTime <- base::Sys.time()
[16:05:02.979]             {
[16:05:02.979]                 {
[16:05:02.979]                   {
[16:05:02.979]                     {
[16:05:02.979]                       base::local({
[16:05:02.979]                         has_future <- base::requireNamespace("future", 
[16:05:02.979]                           quietly = TRUE)
[16:05:02.979]                         if (has_future) {
[16:05:02.979]                           ns <- base::getNamespace("future")
[16:05:02.979]                           version <- ns[[".package"]][["version"]]
[16:05:02.979]                           if (is.null(version)) 
[16:05:02.979]                             version <- utils::packageVersion("future")
[16:05:02.979]                         }
[16:05:02.979]                         else {
[16:05:02.979]                           version <- NULL
[16:05:02.979]                         }
[16:05:02.979]                         if (!has_future || version < "1.8.0") {
[16:05:02.979]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:02.979]                             "", base::R.version$version.string), 
[16:05:02.979]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:02.979]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:02.979]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:02.979]                               "release", "version")], collapse = " "), 
[16:05:02.979]                             hostname = base::Sys.info()[["nodename"]])
[16:05:02.979]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:02.979]                             info)
[16:05:02.979]                           info <- base::paste(info, collapse = "; ")
[16:05:02.979]                           if (!has_future) {
[16:05:02.979]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:02.979]                               info)
[16:05:02.979]                           }
[16:05:02.979]                           else {
[16:05:02.979]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:02.979]                               info, version)
[16:05:02.979]                           }
[16:05:02.979]                           base::stop(msg)
[16:05:02.979]                         }
[16:05:02.979]                       })
[16:05:02.979]                     }
[16:05:02.979]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:02.979]                     base::options(mc.cores = 1L)
[16:05:02.979]                   }
[16:05:02.979]                   options(future.plan = NULL)
[16:05:02.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:02.979]                 }
[16:05:02.979]                 ...future.workdir <- getwd()
[16:05:02.979]             }
[16:05:02.979]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:02.979]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:02.979]         }
[16:05:02.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:02.979]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:02.979]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:02.979]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:02.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:02.979]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:02.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:02.979]             base::names(...future.oldOptions))
[16:05:02.979]     }
[16:05:02.979]     if (FALSE) {
[16:05:02.979]     }
[16:05:02.979]     else {
[16:05:02.979]         if (TRUE) {
[16:05:02.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:02.979]                 open = "w")
[16:05:02.979]         }
[16:05:02.979]         else {
[16:05:02.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:02.979]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:02.979]         }
[16:05:02.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:02.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:02.979]             base::sink(type = "output", split = FALSE)
[16:05:02.979]             base::close(...future.stdout)
[16:05:02.979]         }, add = TRUE)
[16:05:02.979]     }
[16:05:02.979]     ...future.frame <- base::sys.nframe()
[16:05:02.979]     ...future.conditions <- base::list()
[16:05:02.979]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:02.979]     if (FALSE) {
[16:05:02.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:02.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:02.979]     }
[16:05:02.979]     ...future.result <- base::tryCatch({
[16:05:02.979]         base::withCallingHandlers({
[16:05:02.979]             ...future.value <- base::withVisible(base::local({
[16:05:02.979]                 ...future.makeSendCondition <- base::local({
[16:05:02.979]                   sendCondition <- NULL
[16:05:02.979]                   function(frame = 1L) {
[16:05:02.979]                     if (is.function(sendCondition)) 
[16:05:02.979]                       return(sendCondition)
[16:05:02.979]                     ns <- getNamespace("parallel")
[16:05:02.979]                     if (exists("sendData", mode = "function", 
[16:05:02.979]                       envir = ns)) {
[16:05:02.979]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:02.979]                         envir = ns)
[16:05:02.979]                       envir <- sys.frame(frame)
[16:05:02.979]                       master <- NULL
[16:05:02.979]                       while (!identical(envir, .GlobalEnv) && 
[16:05:02.979]                         !identical(envir, emptyenv())) {
[16:05:02.979]                         if (exists("master", mode = "list", envir = envir, 
[16:05:02.979]                           inherits = FALSE)) {
[16:05:02.979]                           master <- get("master", mode = "list", 
[16:05:02.979]                             envir = envir, inherits = FALSE)
[16:05:02.979]                           if (inherits(master, c("SOCKnode", 
[16:05:02.979]                             "SOCK0node"))) {
[16:05:02.979]                             sendCondition <<- function(cond) {
[16:05:02.979]                               data <- list(type = "VALUE", value = cond, 
[16:05:02.979]                                 success = TRUE)
[16:05:02.979]                               parallel_sendData(master, data)
[16:05:02.979]                             }
[16:05:02.979]                             return(sendCondition)
[16:05:02.979]                           }
[16:05:02.979]                         }
[16:05:02.979]                         frame <- frame + 1L
[16:05:02.979]                         envir <- sys.frame(frame)
[16:05:02.979]                       }
[16:05:02.979]                     }
[16:05:02.979]                     sendCondition <<- function(cond) NULL
[16:05:02.979]                   }
[16:05:02.979]                 })
[16:05:02.979]                 withCallingHandlers({
[16:05:02.979]                   {
[16:05:02.979]                     x[["a"]] <- 1
[16:05:02.979]                     x
[16:05:02.979]                   }
[16:05:02.979]                 }, immediateCondition = function(cond) {
[16:05:02.979]                   sendCondition <- ...future.makeSendCondition()
[16:05:02.979]                   sendCondition(cond)
[16:05:02.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.979]                   {
[16:05:02.979]                     inherits <- base::inherits
[16:05:02.979]                     invokeRestart <- base::invokeRestart
[16:05:02.979]                     is.null <- base::is.null
[16:05:02.979]                     muffled <- FALSE
[16:05:02.979]                     if (inherits(cond, "message")) {
[16:05:02.979]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:02.979]                       if (muffled) 
[16:05:02.979]                         invokeRestart("muffleMessage")
[16:05:02.979]                     }
[16:05:02.979]                     else if (inherits(cond, "warning")) {
[16:05:02.979]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:02.979]                       if (muffled) 
[16:05:02.979]                         invokeRestart("muffleWarning")
[16:05:02.979]                     }
[16:05:02.979]                     else if (inherits(cond, "condition")) {
[16:05:02.979]                       if (!is.null(pattern)) {
[16:05:02.979]                         computeRestarts <- base::computeRestarts
[16:05:02.979]                         grepl <- base::grepl
[16:05:02.979]                         restarts <- computeRestarts(cond)
[16:05:02.979]                         for (restart in restarts) {
[16:05:02.979]                           name <- restart$name
[16:05:02.979]                           if (is.null(name)) 
[16:05:02.979]                             next
[16:05:02.979]                           if (!grepl(pattern, name)) 
[16:05:02.979]                             next
[16:05:02.979]                           invokeRestart(restart)
[16:05:02.979]                           muffled <- TRUE
[16:05:02.979]                           break
[16:05:02.979]                         }
[16:05:02.979]                       }
[16:05:02.979]                     }
[16:05:02.979]                     invisible(muffled)
[16:05:02.979]                   }
[16:05:02.979]                   muffleCondition(cond)
[16:05:02.979]                 })
[16:05:02.979]             }))
[16:05:02.979]             future::FutureResult(value = ...future.value$value, 
[16:05:02.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.979]                   ...future.rng), globalenv = if (FALSE) 
[16:05:02.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:02.979]                     ...future.globalenv.names))
[16:05:02.979]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:02.979]         }, condition = base::local({
[16:05:02.979]             c <- base::c
[16:05:02.979]             inherits <- base::inherits
[16:05:02.979]             invokeRestart <- base::invokeRestart
[16:05:02.979]             length <- base::length
[16:05:02.979]             list <- base::list
[16:05:02.979]             seq.int <- base::seq.int
[16:05:02.979]             signalCondition <- base::signalCondition
[16:05:02.979]             sys.calls <- base::sys.calls
[16:05:02.979]             `[[` <- base::`[[`
[16:05:02.979]             `+` <- base::`+`
[16:05:02.979]             `<<-` <- base::`<<-`
[16:05:02.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:02.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:02.979]                   3L)]
[16:05:02.979]             }
[16:05:02.979]             function(cond) {
[16:05:02.979]                 is_error <- inherits(cond, "error")
[16:05:02.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:02.979]                   NULL)
[16:05:02.979]                 if (is_error) {
[16:05:02.979]                   sessionInformation <- function() {
[16:05:02.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:02.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:02.979]                       search = base::search(), system = base::Sys.info())
[16:05:02.979]                   }
[16:05:02.979]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:02.979]                     cond$call), session = sessionInformation(), 
[16:05:02.979]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:02.979]                   signalCondition(cond)
[16:05:02.979]                 }
[16:05:02.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:02.979]                 "immediateCondition"))) {
[16:05:02.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:02.979]                   ...future.conditions[[length(...future.conditions) + 
[16:05:02.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:02.979]                   if (TRUE && !signal) {
[16:05:02.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.979]                     {
[16:05:02.979]                       inherits <- base::inherits
[16:05:02.979]                       invokeRestart <- base::invokeRestart
[16:05:02.979]                       is.null <- base::is.null
[16:05:02.979]                       muffled <- FALSE
[16:05:02.979]                       if (inherits(cond, "message")) {
[16:05:02.979]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.979]                         if (muffled) 
[16:05:02.979]                           invokeRestart("muffleMessage")
[16:05:02.979]                       }
[16:05:02.979]                       else if (inherits(cond, "warning")) {
[16:05:02.979]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.979]                         if (muffled) 
[16:05:02.979]                           invokeRestart("muffleWarning")
[16:05:02.979]                       }
[16:05:02.979]                       else if (inherits(cond, "condition")) {
[16:05:02.979]                         if (!is.null(pattern)) {
[16:05:02.979]                           computeRestarts <- base::computeRestarts
[16:05:02.979]                           grepl <- base::grepl
[16:05:02.979]                           restarts <- computeRestarts(cond)
[16:05:02.979]                           for (restart in restarts) {
[16:05:02.979]                             name <- restart$name
[16:05:02.979]                             if (is.null(name)) 
[16:05:02.979]                               next
[16:05:02.979]                             if (!grepl(pattern, name)) 
[16:05:02.979]                               next
[16:05:02.979]                             invokeRestart(restart)
[16:05:02.979]                             muffled <- TRUE
[16:05:02.979]                             break
[16:05:02.979]                           }
[16:05:02.979]                         }
[16:05:02.979]                       }
[16:05:02.979]                       invisible(muffled)
[16:05:02.979]                     }
[16:05:02.979]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.979]                   }
[16:05:02.979]                 }
[16:05:02.979]                 else {
[16:05:02.979]                   if (TRUE) {
[16:05:02.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:02.979]                     {
[16:05:02.979]                       inherits <- base::inherits
[16:05:02.979]                       invokeRestart <- base::invokeRestart
[16:05:02.979]                       is.null <- base::is.null
[16:05:02.979]                       muffled <- FALSE
[16:05:02.979]                       if (inherits(cond, "message")) {
[16:05:02.979]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:02.979]                         if (muffled) 
[16:05:02.979]                           invokeRestart("muffleMessage")
[16:05:02.979]                       }
[16:05:02.979]                       else if (inherits(cond, "warning")) {
[16:05:02.979]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:02.979]                         if (muffled) 
[16:05:02.979]                           invokeRestart("muffleWarning")
[16:05:02.979]                       }
[16:05:02.979]                       else if (inherits(cond, "condition")) {
[16:05:02.979]                         if (!is.null(pattern)) {
[16:05:02.979]                           computeRestarts <- base::computeRestarts
[16:05:02.979]                           grepl <- base::grepl
[16:05:02.979]                           restarts <- computeRestarts(cond)
[16:05:02.979]                           for (restart in restarts) {
[16:05:02.979]                             name <- restart$name
[16:05:02.979]                             if (is.null(name)) 
[16:05:02.979]                               next
[16:05:02.979]                             if (!grepl(pattern, name)) 
[16:05:02.979]                               next
[16:05:02.979]                             invokeRestart(restart)
[16:05:02.979]                             muffled <- TRUE
[16:05:02.979]                             break
[16:05:02.979]                           }
[16:05:02.979]                         }
[16:05:02.979]                       }
[16:05:02.979]                       invisible(muffled)
[16:05:02.979]                     }
[16:05:02.979]                     muffleCondition(cond, pattern = "^muffle")
[16:05:02.979]                   }
[16:05:02.979]                 }
[16:05:02.979]             }
[16:05:02.979]         }))
[16:05:02.979]     }, error = function(ex) {
[16:05:02.979]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:02.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:02.979]                 ...future.rng), started = ...future.startTime, 
[16:05:02.979]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:02.979]             version = "1.8"), class = "FutureResult")
[16:05:02.979]     }, finally = {
[16:05:02.979]         if (!identical(...future.workdir, getwd())) 
[16:05:02.979]             setwd(...future.workdir)
[16:05:02.979]         {
[16:05:02.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:02.979]                 ...future.oldOptions$nwarnings <- NULL
[16:05:02.979]             }
[16:05:02.979]             base::options(...future.oldOptions)
[16:05:02.979]             if (.Platform$OS.type == "windows") {
[16:05:02.979]                 old_names <- names(...future.oldEnvVars)
[16:05:02.979]                 envs <- base::Sys.getenv()
[16:05:02.979]                 names <- names(envs)
[16:05:02.979]                 common <- intersect(names, old_names)
[16:05:02.979]                 added <- setdiff(names, old_names)
[16:05:02.979]                 removed <- setdiff(old_names, names)
[16:05:02.979]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:02.979]                   envs[common]]
[16:05:02.979]                 NAMES <- toupper(changed)
[16:05:02.979]                 args <- list()
[16:05:02.979]                 for (kk in seq_along(NAMES)) {
[16:05:02.979]                   name <- changed[[kk]]
[16:05:02.979]                   NAME <- NAMES[[kk]]
[16:05:02.979]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.979]                     next
[16:05:02.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.979]                 }
[16:05:02.979]                 NAMES <- toupper(added)
[16:05:02.979]                 for (kk in seq_along(NAMES)) {
[16:05:02.979]                   name <- added[[kk]]
[16:05:02.979]                   NAME <- NAMES[[kk]]
[16:05:02.979]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.979]                     next
[16:05:02.979]                   args[[name]] <- ""
[16:05:02.979]                 }
[16:05:02.979]                 NAMES <- toupper(removed)
[16:05:02.979]                 for (kk in seq_along(NAMES)) {
[16:05:02.979]                   name <- removed[[kk]]
[16:05:02.979]                   NAME <- NAMES[[kk]]
[16:05:02.979]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:02.979]                     next
[16:05:02.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:02.979]                 }
[16:05:02.979]                 if (length(args) > 0) 
[16:05:02.979]                   base::do.call(base::Sys.setenv, args = args)
[16:05:02.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:02.979]             }
[16:05:02.979]             else {
[16:05:02.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:02.979]             }
[16:05:02.979]             {
[16:05:02.979]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:02.979]                   0L) {
[16:05:02.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:02.979]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:02.979]                   base::options(opts)
[16:05:02.979]                 }
[16:05:02.979]                 {
[16:05:02.979]                   {
[16:05:02.979]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:02.979]                     NULL
[16:05:02.979]                   }
[16:05:02.979]                   options(future.plan = NULL)
[16:05:02.979]                   if (is.na(NA_character_)) 
[16:05:02.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:02.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:02.979]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:02.979]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:02.979]                     envir = parent.frame()) 
[16:05:02.979]                   {
[16:05:02.979]                     if (is.function(workers)) 
[16:05:02.979]                       workers <- workers()
[16:05:02.979]                     workers <- structure(as.integer(workers), 
[16:05:02.979]                       class = class(workers))
[16:05:02.979]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:02.979]                       workers >= 1)
[16:05:02.979]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:02.979]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:02.979]                     }
[16:05:02.979]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:02.979]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:02.979]                       envir = envir)
[16:05:02.979]                     if (!future$lazy) 
[16:05:02.979]                       future <- run(future)
[16:05:02.979]                     invisible(future)
[16:05:02.979]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:02.979]                 }
[16:05:02.979]             }
[16:05:02.979]         }
[16:05:02.979]     })
[16:05:02.979]     if (TRUE) {
[16:05:02.979]         base::sink(type = "output", split = FALSE)
[16:05:02.979]         if (TRUE) {
[16:05:02.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:02.979]         }
[16:05:02.979]         else {
[16:05:02.979]             ...future.result["stdout"] <- base::list(NULL)
[16:05:02.979]         }
[16:05:02.979]         base::close(...future.stdout)
[16:05:02.979]         ...future.stdout <- NULL
[16:05:02.979]     }
[16:05:02.979]     ...future.result$conditions <- ...future.conditions
[16:05:02.979]     ...future.result$finished <- base::Sys.time()
[16:05:02.979]     ...future.result
[16:05:02.979] }
[16:05:02.982] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:05:02.982] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:05:02.983] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:05:02.983] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:05:02.983] MultisessionFuture started
[16:05:02.983] - Launch lazy future ... done
[16:05:02.983] run() for ‘MultisessionFuture’ ... done
[16:05:02.984] result() for ClusterFuture ...
[16:05:02.984] receiveMessageFromWorker() for ClusterFuture ...
[16:05:02.984] - Validating connection of MultisessionFuture
[16:05:03.032] - received message: FutureResult
[16:05:03.032] - Received FutureResult
[16:05:03.032] - Erased future from FutureRegistry
[16:05:03.032] result() for ClusterFuture ...
[16:05:03.033] - result already collected: FutureResult
[16:05:03.033] result() for ClusterFuture ... done
[16:05:03.033] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:03.033] result() for ClusterFuture ... done
[16:05:03.033] result() for ClusterFuture ...
[16:05:03.033] - result already collected: FutureResult
[16:05:03.033] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:03.033] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:03.034] Searching for globals...
[16:05:03.036] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:03.036] Searching for globals ... DONE
[16:05:03.036] Resolving globals: TRUE
[16:05:03.036] Resolving any globals that are futures ...
[16:05:03.036] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:03.036] Resolving any globals that are futures ... DONE
[16:05:03.037] Resolving futures part of globals (recursively) ...
[16:05:03.037] resolve() on list ...
[16:05:03.037]  recursive: 99
[16:05:03.037]  length: 1
[16:05:03.037]  elements: ‘x’
[16:05:03.037]  length: 0 (resolved future 1)
[16:05:03.037] resolve() on list ... DONE
[16:05:03.037] - globals: [1] ‘x’
[16:05:03.037] Resolving futures part of globals (recursively) ... DONE
[16:05:03.038] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:03.038] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:03.038] - globals: [1] ‘x’
[16:05:03.038] 
[16:05:03.038] getGlobalsAndPackages() ... DONE
[16:05:03.039] run() for ‘Future’ ...
[16:05:03.039] - state: ‘created’
[16:05:03.039] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:03.052] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:03.053] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:03.053]   - Field: ‘node’
[16:05:03.053]   - Field: ‘label’
[16:05:03.053]   - Field: ‘local’
[16:05:03.053]   - Field: ‘owner’
[16:05:03.053]   - Field: ‘envir’
[16:05:03.053]   - Field: ‘workers’
[16:05:03.053]   - Field: ‘packages’
[16:05:03.053]   - Field: ‘gc’
[16:05:03.053]   - Field: ‘conditions’
[16:05:03.054]   - Field: ‘persistent’
[16:05:03.054]   - Field: ‘expr’
[16:05:03.054]   - Field: ‘uuid’
[16:05:03.054]   - Field: ‘seed’
[16:05:03.054]   - Field: ‘version’
[16:05:03.054]   - Field: ‘result’
[16:05:03.054]   - Field: ‘asynchronous’
[16:05:03.054]   - Field: ‘calls’
[16:05:03.054]   - Field: ‘globals’
[16:05:03.054]   - Field: ‘stdout’
[16:05:03.054]   - Field: ‘earlySignal’
[16:05:03.055]   - Field: ‘lazy’
[16:05:03.055]   - Field: ‘state’
[16:05:03.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:03.055] - Launch lazy future ...
[16:05:03.055] Packages needed by the future expression (n = 0): <none>
[16:05:03.055] Packages needed by future strategies (n = 0): <none>
[16:05:03.056] {
[16:05:03.056]     {
[16:05:03.056]         {
[16:05:03.056]             ...future.startTime <- base::Sys.time()
[16:05:03.056]             {
[16:05:03.056]                 {
[16:05:03.056]                   {
[16:05:03.056]                     {
[16:05:03.056]                       base::local({
[16:05:03.056]                         has_future <- base::requireNamespace("future", 
[16:05:03.056]                           quietly = TRUE)
[16:05:03.056]                         if (has_future) {
[16:05:03.056]                           ns <- base::getNamespace("future")
[16:05:03.056]                           version <- ns[[".package"]][["version"]]
[16:05:03.056]                           if (is.null(version)) 
[16:05:03.056]                             version <- utils::packageVersion("future")
[16:05:03.056]                         }
[16:05:03.056]                         else {
[16:05:03.056]                           version <- NULL
[16:05:03.056]                         }
[16:05:03.056]                         if (!has_future || version < "1.8.0") {
[16:05:03.056]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:03.056]                             "", base::R.version$version.string), 
[16:05:03.056]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:03.056]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:03.056]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:03.056]                               "release", "version")], collapse = " "), 
[16:05:03.056]                             hostname = base::Sys.info()[["nodename"]])
[16:05:03.056]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:03.056]                             info)
[16:05:03.056]                           info <- base::paste(info, collapse = "; ")
[16:05:03.056]                           if (!has_future) {
[16:05:03.056]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:03.056]                               info)
[16:05:03.056]                           }
[16:05:03.056]                           else {
[16:05:03.056]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:03.056]                               info, version)
[16:05:03.056]                           }
[16:05:03.056]                           base::stop(msg)
[16:05:03.056]                         }
[16:05:03.056]                       })
[16:05:03.056]                     }
[16:05:03.056]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:03.056]                     base::options(mc.cores = 1L)
[16:05:03.056]                   }
[16:05:03.056]                   options(future.plan = NULL)
[16:05:03.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:03.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:03.056]                 }
[16:05:03.056]                 ...future.workdir <- getwd()
[16:05:03.056]             }
[16:05:03.056]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:03.056]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:03.056]         }
[16:05:03.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:03.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:03.056]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:03.056]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:03.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:03.056]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:03.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:03.056]             base::names(...future.oldOptions))
[16:05:03.056]     }
[16:05:03.056]     if (FALSE) {
[16:05:03.056]     }
[16:05:03.056]     else {
[16:05:03.056]         if (TRUE) {
[16:05:03.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:03.056]                 open = "w")
[16:05:03.056]         }
[16:05:03.056]         else {
[16:05:03.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:03.056]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:03.056]         }
[16:05:03.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:03.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:03.056]             base::sink(type = "output", split = FALSE)
[16:05:03.056]             base::close(...future.stdout)
[16:05:03.056]         }, add = TRUE)
[16:05:03.056]     }
[16:05:03.056]     ...future.frame <- base::sys.nframe()
[16:05:03.056]     ...future.conditions <- base::list()
[16:05:03.056]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:03.056]     if (FALSE) {
[16:05:03.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:03.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:03.056]     }
[16:05:03.056]     ...future.result <- base::tryCatch({
[16:05:03.056]         base::withCallingHandlers({
[16:05:03.056]             ...future.value <- base::withVisible(base::local({
[16:05:03.056]                 ...future.makeSendCondition <- base::local({
[16:05:03.056]                   sendCondition <- NULL
[16:05:03.056]                   function(frame = 1L) {
[16:05:03.056]                     if (is.function(sendCondition)) 
[16:05:03.056]                       return(sendCondition)
[16:05:03.056]                     ns <- getNamespace("parallel")
[16:05:03.056]                     if (exists("sendData", mode = "function", 
[16:05:03.056]                       envir = ns)) {
[16:05:03.056]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:03.056]                         envir = ns)
[16:05:03.056]                       envir <- sys.frame(frame)
[16:05:03.056]                       master <- NULL
[16:05:03.056]                       while (!identical(envir, .GlobalEnv) && 
[16:05:03.056]                         !identical(envir, emptyenv())) {
[16:05:03.056]                         if (exists("master", mode = "list", envir = envir, 
[16:05:03.056]                           inherits = FALSE)) {
[16:05:03.056]                           master <- get("master", mode = "list", 
[16:05:03.056]                             envir = envir, inherits = FALSE)
[16:05:03.056]                           if (inherits(master, c("SOCKnode", 
[16:05:03.056]                             "SOCK0node"))) {
[16:05:03.056]                             sendCondition <<- function(cond) {
[16:05:03.056]                               data <- list(type = "VALUE", value = cond, 
[16:05:03.056]                                 success = TRUE)
[16:05:03.056]                               parallel_sendData(master, data)
[16:05:03.056]                             }
[16:05:03.056]                             return(sendCondition)
[16:05:03.056]                           }
[16:05:03.056]                         }
[16:05:03.056]                         frame <- frame + 1L
[16:05:03.056]                         envir <- sys.frame(frame)
[16:05:03.056]                       }
[16:05:03.056]                     }
[16:05:03.056]                     sendCondition <<- function(cond) NULL
[16:05:03.056]                   }
[16:05:03.056]                 })
[16:05:03.056]                 withCallingHandlers({
[16:05:03.056]                   {
[16:05:03.056]                     x[["a"]] <- 1
[16:05:03.056]                     x
[16:05:03.056]                   }
[16:05:03.056]                 }, immediateCondition = function(cond) {
[16:05:03.056]                   sendCondition <- ...future.makeSendCondition()
[16:05:03.056]                   sendCondition(cond)
[16:05:03.056]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.056]                   {
[16:05:03.056]                     inherits <- base::inherits
[16:05:03.056]                     invokeRestart <- base::invokeRestart
[16:05:03.056]                     is.null <- base::is.null
[16:05:03.056]                     muffled <- FALSE
[16:05:03.056]                     if (inherits(cond, "message")) {
[16:05:03.056]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:03.056]                       if (muffled) 
[16:05:03.056]                         invokeRestart("muffleMessage")
[16:05:03.056]                     }
[16:05:03.056]                     else if (inherits(cond, "warning")) {
[16:05:03.056]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:03.056]                       if (muffled) 
[16:05:03.056]                         invokeRestart("muffleWarning")
[16:05:03.056]                     }
[16:05:03.056]                     else if (inherits(cond, "condition")) {
[16:05:03.056]                       if (!is.null(pattern)) {
[16:05:03.056]                         computeRestarts <- base::computeRestarts
[16:05:03.056]                         grepl <- base::grepl
[16:05:03.056]                         restarts <- computeRestarts(cond)
[16:05:03.056]                         for (restart in restarts) {
[16:05:03.056]                           name <- restart$name
[16:05:03.056]                           if (is.null(name)) 
[16:05:03.056]                             next
[16:05:03.056]                           if (!grepl(pattern, name)) 
[16:05:03.056]                             next
[16:05:03.056]                           invokeRestart(restart)
[16:05:03.056]                           muffled <- TRUE
[16:05:03.056]                           break
[16:05:03.056]                         }
[16:05:03.056]                       }
[16:05:03.056]                     }
[16:05:03.056]                     invisible(muffled)
[16:05:03.056]                   }
[16:05:03.056]                   muffleCondition(cond)
[16:05:03.056]                 })
[16:05:03.056]             }))
[16:05:03.056]             future::FutureResult(value = ...future.value$value, 
[16:05:03.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:03.056]                   ...future.rng), globalenv = if (FALSE) 
[16:05:03.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:03.056]                     ...future.globalenv.names))
[16:05:03.056]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:03.056]         }, condition = base::local({
[16:05:03.056]             c <- base::c
[16:05:03.056]             inherits <- base::inherits
[16:05:03.056]             invokeRestart <- base::invokeRestart
[16:05:03.056]             length <- base::length
[16:05:03.056]             list <- base::list
[16:05:03.056]             seq.int <- base::seq.int
[16:05:03.056]             signalCondition <- base::signalCondition
[16:05:03.056]             sys.calls <- base::sys.calls
[16:05:03.056]             `[[` <- base::`[[`
[16:05:03.056]             `+` <- base::`+`
[16:05:03.056]             `<<-` <- base::`<<-`
[16:05:03.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:03.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:03.056]                   3L)]
[16:05:03.056]             }
[16:05:03.056]             function(cond) {
[16:05:03.056]                 is_error <- inherits(cond, "error")
[16:05:03.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:03.056]                   NULL)
[16:05:03.056]                 if (is_error) {
[16:05:03.056]                   sessionInformation <- function() {
[16:05:03.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:03.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:03.056]                       search = base::search(), system = base::Sys.info())
[16:05:03.056]                   }
[16:05:03.056]                   ...future.conditions[[length(...future.conditions) + 
[16:05:03.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:03.056]                     cond$call), session = sessionInformation(), 
[16:05:03.056]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:03.056]                   signalCondition(cond)
[16:05:03.056]                 }
[16:05:03.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:03.056]                 "immediateCondition"))) {
[16:05:03.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:03.056]                   ...future.conditions[[length(...future.conditions) + 
[16:05:03.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:03.056]                   if (TRUE && !signal) {
[16:05:03.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.056]                     {
[16:05:03.056]                       inherits <- base::inherits
[16:05:03.056]                       invokeRestart <- base::invokeRestart
[16:05:03.056]                       is.null <- base::is.null
[16:05:03.056]                       muffled <- FALSE
[16:05:03.056]                       if (inherits(cond, "message")) {
[16:05:03.056]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:03.056]                         if (muffled) 
[16:05:03.056]                           invokeRestart("muffleMessage")
[16:05:03.056]                       }
[16:05:03.056]                       else if (inherits(cond, "warning")) {
[16:05:03.056]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:03.056]                         if (muffled) 
[16:05:03.056]                           invokeRestart("muffleWarning")
[16:05:03.056]                       }
[16:05:03.056]                       else if (inherits(cond, "condition")) {
[16:05:03.056]                         if (!is.null(pattern)) {
[16:05:03.056]                           computeRestarts <- base::computeRestarts
[16:05:03.056]                           grepl <- base::grepl
[16:05:03.056]                           restarts <- computeRestarts(cond)
[16:05:03.056]                           for (restart in restarts) {
[16:05:03.056]                             name <- restart$name
[16:05:03.056]                             if (is.null(name)) 
[16:05:03.056]                               next
[16:05:03.056]                             if (!grepl(pattern, name)) 
[16:05:03.056]                               next
[16:05:03.056]                             invokeRestart(restart)
[16:05:03.056]                             muffled <- TRUE
[16:05:03.056]                             break
[16:05:03.056]                           }
[16:05:03.056]                         }
[16:05:03.056]                       }
[16:05:03.056]                       invisible(muffled)
[16:05:03.056]                     }
[16:05:03.056]                     muffleCondition(cond, pattern = "^muffle")
[16:05:03.056]                   }
[16:05:03.056]                 }
[16:05:03.056]                 else {
[16:05:03.056]                   if (TRUE) {
[16:05:03.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.056]                     {
[16:05:03.056]                       inherits <- base::inherits
[16:05:03.056]                       invokeRestart <- base::invokeRestart
[16:05:03.056]                       is.null <- base::is.null
[16:05:03.056]                       muffled <- FALSE
[16:05:03.056]                       if (inherits(cond, "message")) {
[16:05:03.056]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:03.056]                         if (muffled) 
[16:05:03.056]                           invokeRestart("muffleMessage")
[16:05:03.056]                       }
[16:05:03.056]                       else if (inherits(cond, "warning")) {
[16:05:03.056]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:03.056]                         if (muffled) 
[16:05:03.056]                           invokeRestart("muffleWarning")
[16:05:03.056]                       }
[16:05:03.056]                       else if (inherits(cond, "condition")) {
[16:05:03.056]                         if (!is.null(pattern)) {
[16:05:03.056]                           computeRestarts <- base::computeRestarts
[16:05:03.056]                           grepl <- base::grepl
[16:05:03.056]                           restarts <- computeRestarts(cond)
[16:05:03.056]                           for (restart in restarts) {
[16:05:03.056]                             name <- restart$name
[16:05:03.056]                             if (is.null(name)) 
[16:05:03.056]                               next
[16:05:03.056]                             if (!grepl(pattern, name)) 
[16:05:03.056]                               next
[16:05:03.056]                             invokeRestart(restart)
[16:05:03.056]                             muffled <- TRUE
[16:05:03.056]                             break
[16:05:03.056]                           }
[16:05:03.056]                         }
[16:05:03.056]                       }
[16:05:03.056]                       invisible(muffled)
[16:05:03.056]                     }
[16:05:03.056]                     muffleCondition(cond, pattern = "^muffle")
[16:05:03.056]                   }
[16:05:03.056]                 }
[16:05:03.056]             }
[16:05:03.056]         }))
[16:05:03.056]     }, error = function(ex) {
[16:05:03.056]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:03.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:03.056]                 ...future.rng), started = ...future.startTime, 
[16:05:03.056]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:03.056]             version = "1.8"), class = "FutureResult")
[16:05:03.056]     }, finally = {
[16:05:03.056]         if (!identical(...future.workdir, getwd())) 
[16:05:03.056]             setwd(...future.workdir)
[16:05:03.056]         {
[16:05:03.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:03.056]                 ...future.oldOptions$nwarnings <- NULL
[16:05:03.056]             }
[16:05:03.056]             base::options(...future.oldOptions)
[16:05:03.056]             if (.Platform$OS.type == "windows") {
[16:05:03.056]                 old_names <- names(...future.oldEnvVars)
[16:05:03.056]                 envs <- base::Sys.getenv()
[16:05:03.056]                 names <- names(envs)
[16:05:03.056]                 common <- intersect(names, old_names)
[16:05:03.056]                 added <- setdiff(names, old_names)
[16:05:03.056]                 removed <- setdiff(old_names, names)
[16:05:03.056]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:03.056]                   envs[common]]
[16:05:03.056]                 NAMES <- toupper(changed)
[16:05:03.056]                 args <- list()
[16:05:03.056]                 for (kk in seq_along(NAMES)) {
[16:05:03.056]                   name <- changed[[kk]]
[16:05:03.056]                   NAME <- NAMES[[kk]]
[16:05:03.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.056]                     next
[16:05:03.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:03.056]                 }
[16:05:03.056]                 NAMES <- toupper(added)
[16:05:03.056]                 for (kk in seq_along(NAMES)) {
[16:05:03.056]                   name <- added[[kk]]
[16:05:03.056]                   NAME <- NAMES[[kk]]
[16:05:03.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.056]                     next
[16:05:03.056]                   args[[name]] <- ""
[16:05:03.056]                 }
[16:05:03.056]                 NAMES <- toupper(removed)
[16:05:03.056]                 for (kk in seq_along(NAMES)) {
[16:05:03.056]                   name <- removed[[kk]]
[16:05:03.056]                   NAME <- NAMES[[kk]]
[16:05:03.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.056]                     next
[16:05:03.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:03.056]                 }
[16:05:03.056]                 if (length(args) > 0) 
[16:05:03.056]                   base::do.call(base::Sys.setenv, args = args)
[16:05:03.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:03.056]             }
[16:05:03.056]             else {
[16:05:03.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:03.056]             }
[16:05:03.056]             {
[16:05:03.056]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:03.056]                   0L) {
[16:05:03.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:03.056]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:03.056]                   base::options(opts)
[16:05:03.056]                 }
[16:05:03.056]                 {
[16:05:03.056]                   {
[16:05:03.056]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:03.056]                     NULL
[16:05:03.056]                   }
[16:05:03.056]                   options(future.plan = NULL)
[16:05:03.056]                   if (is.na(NA_character_)) 
[16:05:03.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:03.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:03.056]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:03.056]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:03.056]                     envir = parent.frame()) 
[16:05:03.056]                   {
[16:05:03.056]                     if (is.function(workers)) 
[16:05:03.056]                       workers <- workers()
[16:05:03.056]                     workers <- structure(as.integer(workers), 
[16:05:03.056]                       class = class(workers))
[16:05:03.056]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:03.056]                       workers >= 1)
[16:05:03.056]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:03.056]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:03.056]                     }
[16:05:03.056]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:03.056]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:03.056]                       envir = envir)
[16:05:03.056]                     if (!future$lazy) 
[16:05:03.056]                       future <- run(future)
[16:05:03.056]                     invisible(future)
[16:05:03.056]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:03.056]                 }
[16:05:03.056]             }
[16:05:03.056]         }
[16:05:03.056]     })
[16:05:03.056]     if (TRUE) {
[16:05:03.056]         base::sink(type = "output", split = FALSE)
[16:05:03.056]         if (TRUE) {
[16:05:03.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:03.056]         }
[16:05:03.056]         else {
[16:05:03.056]             ...future.result["stdout"] <- base::list(NULL)
[16:05:03.056]         }
[16:05:03.056]         base::close(...future.stdout)
[16:05:03.056]         ...future.stdout <- NULL
[16:05:03.056]     }
[16:05:03.056]     ...future.result$conditions <- ...future.conditions
[16:05:03.056]     ...future.result$finished <- base::Sys.time()
[16:05:03.056]     ...future.result
[16:05:03.056] }
[16:05:03.059] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:05:03.059] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:05:03.059] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:05:03.059] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:05:03.060] MultisessionFuture started
[16:05:03.060] - Launch lazy future ... done
[16:05:03.060] run() for ‘MultisessionFuture’ ... done
[16:05:03.060] result() for ClusterFuture ...
[16:05:03.061] receiveMessageFromWorker() for ClusterFuture ...
[16:05:03.061] - Validating connection of MultisessionFuture
[16:05:03.108] - received message: FutureResult
[16:05:03.108] - Received FutureResult
[16:05:03.108] - Erased future from FutureRegistry
[16:05:03.108] result() for ClusterFuture ...
[16:05:03.108] - result already collected: FutureResult
[16:05:03.109] result() for ClusterFuture ... done
[16:05:03.109] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:03.109] result() for ClusterFuture ... done
[16:05:03.109] result() for ClusterFuture ...
[16:05:03.109] - result already collected: FutureResult
[16:05:03.109] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:03.109] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:03.110] Searching for globals...
[16:05:03.112] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:03.112] Searching for globals ... DONE
[16:05:03.113] Resolving globals: TRUE
[16:05:03.113] Resolving any globals that are futures ...
[16:05:03.113] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:05:03.113] Resolving any globals that are futures ... DONE
[16:05:03.113] Resolving futures part of globals (recursively) ...
[16:05:03.114] resolve() on list ...
[16:05:03.114]  recursive: 99
[16:05:03.116]  length: 1
[16:05:03.116]  elements: ‘x’
[16:05:03.116]  length: 0 (resolved future 1)
[16:05:03.116] resolve() on list ... DONE
[16:05:03.116] - globals: [1] ‘x’
[16:05:03.116] Resolving futures part of globals (recursively) ... DONE
[16:05:03.117] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:03.117] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:03.117] - globals: [1] ‘x’
[16:05:03.117] 
[16:05:03.117] getGlobalsAndPackages() ... DONE
[16:05:03.118] run() for ‘Future’ ...
[16:05:03.118] - state: ‘created’
[16:05:03.118] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:03.132] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:03.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:03.132]   - Field: ‘node’
[16:05:03.132]   - Field: ‘label’
[16:05:03.132]   - Field: ‘local’
[16:05:03.133]   - Field: ‘owner’
[16:05:03.133]   - Field: ‘envir’
[16:05:03.133]   - Field: ‘workers’
[16:05:03.133]   - Field: ‘packages’
[16:05:03.133]   - Field: ‘gc’
[16:05:03.133]   - Field: ‘conditions’
[16:05:03.133]   - Field: ‘persistent’
[16:05:03.133]   - Field: ‘expr’
[16:05:03.133]   - Field: ‘uuid’
[16:05:03.133]   - Field: ‘seed’
[16:05:03.133]   - Field: ‘version’
[16:05:03.134]   - Field: ‘result’
[16:05:03.134]   - Field: ‘asynchronous’
[16:05:03.134]   - Field: ‘calls’
[16:05:03.134]   - Field: ‘globals’
[16:05:03.134]   - Field: ‘stdout’
[16:05:03.134]   - Field: ‘earlySignal’
[16:05:03.134]   - Field: ‘lazy’
[16:05:03.134]   - Field: ‘state’
[16:05:03.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:03.134] - Launch lazy future ...
[16:05:03.135] Packages needed by the future expression (n = 0): <none>
[16:05:03.135] Packages needed by future strategies (n = 0): <none>
[16:05:03.135] {
[16:05:03.135]     {
[16:05:03.135]         {
[16:05:03.135]             ...future.startTime <- base::Sys.time()
[16:05:03.135]             {
[16:05:03.135]                 {
[16:05:03.135]                   {
[16:05:03.135]                     {
[16:05:03.135]                       base::local({
[16:05:03.135]                         has_future <- base::requireNamespace("future", 
[16:05:03.135]                           quietly = TRUE)
[16:05:03.135]                         if (has_future) {
[16:05:03.135]                           ns <- base::getNamespace("future")
[16:05:03.135]                           version <- ns[[".package"]][["version"]]
[16:05:03.135]                           if (is.null(version)) 
[16:05:03.135]                             version <- utils::packageVersion("future")
[16:05:03.135]                         }
[16:05:03.135]                         else {
[16:05:03.135]                           version <- NULL
[16:05:03.135]                         }
[16:05:03.135]                         if (!has_future || version < "1.8.0") {
[16:05:03.135]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:03.135]                             "", base::R.version$version.string), 
[16:05:03.135]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:03.135]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:03.135]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:03.135]                               "release", "version")], collapse = " "), 
[16:05:03.135]                             hostname = base::Sys.info()[["nodename"]])
[16:05:03.135]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:03.135]                             info)
[16:05:03.135]                           info <- base::paste(info, collapse = "; ")
[16:05:03.135]                           if (!has_future) {
[16:05:03.135]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:03.135]                               info)
[16:05:03.135]                           }
[16:05:03.135]                           else {
[16:05:03.135]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:03.135]                               info, version)
[16:05:03.135]                           }
[16:05:03.135]                           base::stop(msg)
[16:05:03.135]                         }
[16:05:03.135]                       })
[16:05:03.135]                     }
[16:05:03.135]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:03.135]                     base::options(mc.cores = 1L)
[16:05:03.135]                   }
[16:05:03.135]                   options(future.plan = NULL)
[16:05:03.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:03.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:03.135]                 }
[16:05:03.135]                 ...future.workdir <- getwd()
[16:05:03.135]             }
[16:05:03.135]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:03.135]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:03.135]         }
[16:05:03.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:03.135]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:03.135]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:03.135]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:03.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:03.135]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:03.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:03.135]             base::names(...future.oldOptions))
[16:05:03.135]     }
[16:05:03.135]     if (FALSE) {
[16:05:03.135]     }
[16:05:03.135]     else {
[16:05:03.135]         if (TRUE) {
[16:05:03.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:03.135]                 open = "w")
[16:05:03.135]         }
[16:05:03.135]         else {
[16:05:03.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:03.135]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:03.135]         }
[16:05:03.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:03.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:03.135]             base::sink(type = "output", split = FALSE)
[16:05:03.135]             base::close(...future.stdout)
[16:05:03.135]         }, add = TRUE)
[16:05:03.135]     }
[16:05:03.135]     ...future.frame <- base::sys.nframe()
[16:05:03.135]     ...future.conditions <- base::list()
[16:05:03.135]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:03.135]     if (FALSE) {
[16:05:03.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:03.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:03.135]     }
[16:05:03.135]     ...future.result <- base::tryCatch({
[16:05:03.135]         base::withCallingHandlers({
[16:05:03.135]             ...future.value <- base::withVisible(base::local({
[16:05:03.135]                 ...future.makeSendCondition <- base::local({
[16:05:03.135]                   sendCondition <- NULL
[16:05:03.135]                   function(frame = 1L) {
[16:05:03.135]                     if (is.function(sendCondition)) 
[16:05:03.135]                       return(sendCondition)
[16:05:03.135]                     ns <- getNamespace("parallel")
[16:05:03.135]                     if (exists("sendData", mode = "function", 
[16:05:03.135]                       envir = ns)) {
[16:05:03.135]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:03.135]                         envir = ns)
[16:05:03.135]                       envir <- sys.frame(frame)
[16:05:03.135]                       master <- NULL
[16:05:03.135]                       while (!identical(envir, .GlobalEnv) && 
[16:05:03.135]                         !identical(envir, emptyenv())) {
[16:05:03.135]                         if (exists("master", mode = "list", envir = envir, 
[16:05:03.135]                           inherits = FALSE)) {
[16:05:03.135]                           master <- get("master", mode = "list", 
[16:05:03.135]                             envir = envir, inherits = FALSE)
[16:05:03.135]                           if (inherits(master, c("SOCKnode", 
[16:05:03.135]                             "SOCK0node"))) {
[16:05:03.135]                             sendCondition <<- function(cond) {
[16:05:03.135]                               data <- list(type = "VALUE", value = cond, 
[16:05:03.135]                                 success = TRUE)
[16:05:03.135]                               parallel_sendData(master, data)
[16:05:03.135]                             }
[16:05:03.135]                             return(sendCondition)
[16:05:03.135]                           }
[16:05:03.135]                         }
[16:05:03.135]                         frame <- frame + 1L
[16:05:03.135]                         envir <- sys.frame(frame)
[16:05:03.135]                       }
[16:05:03.135]                     }
[16:05:03.135]                     sendCondition <<- function(cond) NULL
[16:05:03.135]                   }
[16:05:03.135]                 })
[16:05:03.135]                 withCallingHandlers({
[16:05:03.135]                   {
[16:05:03.135]                     x[["a"]] <- 1
[16:05:03.135]                     x
[16:05:03.135]                   }
[16:05:03.135]                 }, immediateCondition = function(cond) {
[16:05:03.135]                   sendCondition <- ...future.makeSendCondition()
[16:05:03.135]                   sendCondition(cond)
[16:05:03.135]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.135]                   {
[16:05:03.135]                     inherits <- base::inherits
[16:05:03.135]                     invokeRestart <- base::invokeRestart
[16:05:03.135]                     is.null <- base::is.null
[16:05:03.135]                     muffled <- FALSE
[16:05:03.135]                     if (inherits(cond, "message")) {
[16:05:03.135]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:03.135]                       if (muffled) 
[16:05:03.135]                         invokeRestart("muffleMessage")
[16:05:03.135]                     }
[16:05:03.135]                     else if (inherits(cond, "warning")) {
[16:05:03.135]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:03.135]                       if (muffled) 
[16:05:03.135]                         invokeRestart("muffleWarning")
[16:05:03.135]                     }
[16:05:03.135]                     else if (inherits(cond, "condition")) {
[16:05:03.135]                       if (!is.null(pattern)) {
[16:05:03.135]                         computeRestarts <- base::computeRestarts
[16:05:03.135]                         grepl <- base::grepl
[16:05:03.135]                         restarts <- computeRestarts(cond)
[16:05:03.135]                         for (restart in restarts) {
[16:05:03.135]                           name <- restart$name
[16:05:03.135]                           if (is.null(name)) 
[16:05:03.135]                             next
[16:05:03.135]                           if (!grepl(pattern, name)) 
[16:05:03.135]                             next
[16:05:03.135]                           invokeRestart(restart)
[16:05:03.135]                           muffled <- TRUE
[16:05:03.135]                           break
[16:05:03.135]                         }
[16:05:03.135]                       }
[16:05:03.135]                     }
[16:05:03.135]                     invisible(muffled)
[16:05:03.135]                   }
[16:05:03.135]                   muffleCondition(cond)
[16:05:03.135]                 })
[16:05:03.135]             }))
[16:05:03.135]             future::FutureResult(value = ...future.value$value, 
[16:05:03.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:03.135]                   ...future.rng), globalenv = if (FALSE) 
[16:05:03.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:03.135]                     ...future.globalenv.names))
[16:05:03.135]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:03.135]         }, condition = base::local({
[16:05:03.135]             c <- base::c
[16:05:03.135]             inherits <- base::inherits
[16:05:03.135]             invokeRestart <- base::invokeRestart
[16:05:03.135]             length <- base::length
[16:05:03.135]             list <- base::list
[16:05:03.135]             seq.int <- base::seq.int
[16:05:03.135]             signalCondition <- base::signalCondition
[16:05:03.135]             sys.calls <- base::sys.calls
[16:05:03.135]             `[[` <- base::`[[`
[16:05:03.135]             `+` <- base::`+`
[16:05:03.135]             `<<-` <- base::`<<-`
[16:05:03.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:03.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:03.135]                   3L)]
[16:05:03.135]             }
[16:05:03.135]             function(cond) {
[16:05:03.135]                 is_error <- inherits(cond, "error")
[16:05:03.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:03.135]                   NULL)
[16:05:03.135]                 if (is_error) {
[16:05:03.135]                   sessionInformation <- function() {
[16:05:03.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:03.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:03.135]                       search = base::search(), system = base::Sys.info())
[16:05:03.135]                   }
[16:05:03.135]                   ...future.conditions[[length(...future.conditions) + 
[16:05:03.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:03.135]                     cond$call), session = sessionInformation(), 
[16:05:03.135]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:03.135]                   signalCondition(cond)
[16:05:03.135]                 }
[16:05:03.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:03.135]                 "immediateCondition"))) {
[16:05:03.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:03.135]                   ...future.conditions[[length(...future.conditions) + 
[16:05:03.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:03.135]                   if (TRUE && !signal) {
[16:05:03.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.135]                     {
[16:05:03.135]                       inherits <- base::inherits
[16:05:03.135]                       invokeRestart <- base::invokeRestart
[16:05:03.135]                       is.null <- base::is.null
[16:05:03.135]                       muffled <- FALSE
[16:05:03.135]                       if (inherits(cond, "message")) {
[16:05:03.135]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:03.135]                         if (muffled) 
[16:05:03.135]                           invokeRestart("muffleMessage")
[16:05:03.135]                       }
[16:05:03.135]                       else if (inherits(cond, "warning")) {
[16:05:03.135]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:03.135]                         if (muffled) 
[16:05:03.135]                           invokeRestart("muffleWarning")
[16:05:03.135]                       }
[16:05:03.135]                       else if (inherits(cond, "condition")) {
[16:05:03.135]                         if (!is.null(pattern)) {
[16:05:03.135]                           computeRestarts <- base::computeRestarts
[16:05:03.135]                           grepl <- base::grepl
[16:05:03.135]                           restarts <- computeRestarts(cond)
[16:05:03.135]                           for (restart in restarts) {
[16:05:03.135]                             name <- restart$name
[16:05:03.135]                             if (is.null(name)) 
[16:05:03.135]                               next
[16:05:03.135]                             if (!grepl(pattern, name)) 
[16:05:03.135]                               next
[16:05:03.135]                             invokeRestart(restart)
[16:05:03.135]                             muffled <- TRUE
[16:05:03.135]                             break
[16:05:03.135]                           }
[16:05:03.135]                         }
[16:05:03.135]                       }
[16:05:03.135]                       invisible(muffled)
[16:05:03.135]                     }
[16:05:03.135]                     muffleCondition(cond, pattern = "^muffle")
[16:05:03.135]                   }
[16:05:03.135]                 }
[16:05:03.135]                 else {
[16:05:03.135]                   if (TRUE) {
[16:05:03.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.135]                     {
[16:05:03.135]                       inherits <- base::inherits
[16:05:03.135]                       invokeRestart <- base::invokeRestart
[16:05:03.135]                       is.null <- base::is.null
[16:05:03.135]                       muffled <- FALSE
[16:05:03.135]                       if (inherits(cond, "message")) {
[16:05:03.135]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:03.135]                         if (muffled) 
[16:05:03.135]                           invokeRestart("muffleMessage")
[16:05:03.135]                       }
[16:05:03.135]                       else if (inherits(cond, "warning")) {
[16:05:03.135]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:03.135]                         if (muffled) 
[16:05:03.135]                           invokeRestart("muffleWarning")
[16:05:03.135]                       }
[16:05:03.135]                       else if (inherits(cond, "condition")) {
[16:05:03.135]                         if (!is.null(pattern)) {
[16:05:03.135]                           computeRestarts <- base::computeRestarts
[16:05:03.135]                           grepl <- base::grepl
[16:05:03.135]                           restarts <- computeRestarts(cond)
[16:05:03.135]                           for (restart in restarts) {
[16:05:03.135]                             name <- restart$name
[16:05:03.135]                             if (is.null(name)) 
[16:05:03.135]                               next
[16:05:03.135]                             if (!grepl(pattern, name)) 
[16:05:03.135]                               next
[16:05:03.135]                             invokeRestart(restart)
[16:05:03.135]                             muffled <- TRUE
[16:05:03.135]                             break
[16:05:03.135]                           }
[16:05:03.135]                         }
[16:05:03.135]                       }
[16:05:03.135]                       invisible(muffled)
[16:05:03.135]                     }
[16:05:03.135]                     muffleCondition(cond, pattern = "^muffle")
[16:05:03.135]                   }
[16:05:03.135]                 }
[16:05:03.135]             }
[16:05:03.135]         }))
[16:05:03.135]     }, error = function(ex) {
[16:05:03.135]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:03.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:03.135]                 ...future.rng), started = ...future.startTime, 
[16:05:03.135]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:03.135]             version = "1.8"), class = "FutureResult")
[16:05:03.135]     }, finally = {
[16:05:03.135]         if (!identical(...future.workdir, getwd())) 
[16:05:03.135]             setwd(...future.workdir)
[16:05:03.135]         {
[16:05:03.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:03.135]                 ...future.oldOptions$nwarnings <- NULL
[16:05:03.135]             }
[16:05:03.135]             base::options(...future.oldOptions)
[16:05:03.135]             if (.Platform$OS.type == "windows") {
[16:05:03.135]                 old_names <- names(...future.oldEnvVars)
[16:05:03.135]                 envs <- base::Sys.getenv()
[16:05:03.135]                 names <- names(envs)
[16:05:03.135]                 common <- intersect(names, old_names)
[16:05:03.135]                 added <- setdiff(names, old_names)
[16:05:03.135]                 removed <- setdiff(old_names, names)
[16:05:03.135]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:03.135]                   envs[common]]
[16:05:03.135]                 NAMES <- toupper(changed)
[16:05:03.135]                 args <- list()
[16:05:03.135]                 for (kk in seq_along(NAMES)) {
[16:05:03.135]                   name <- changed[[kk]]
[16:05:03.135]                   NAME <- NAMES[[kk]]
[16:05:03.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.135]                     next
[16:05:03.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:03.135]                 }
[16:05:03.135]                 NAMES <- toupper(added)
[16:05:03.135]                 for (kk in seq_along(NAMES)) {
[16:05:03.135]                   name <- added[[kk]]
[16:05:03.135]                   NAME <- NAMES[[kk]]
[16:05:03.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.135]                     next
[16:05:03.135]                   args[[name]] <- ""
[16:05:03.135]                 }
[16:05:03.135]                 NAMES <- toupper(removed)
[16:05:03.135]                 for (kk in seq_along(NAMES)) {
[16:05:03.135]                   name <- removed[[kk]]
[16:05:03.135]                   NAME <- NAMES[[kk]]
[16:05:03.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.135]                     next
[16:05:03.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:03.135]                 }
[16:05:03.135]                 if (length(args) > 0) 
[16:05:03.135]                   base::do.call(base::Sys.setenv, args = args)
[16:05:03.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:03.135]             }
[16:05:03.135]             else {
[16:05:03.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:03.135]             }
[16:05:03.135]             {
[16:05:03.135]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:03.135]                   0L) {
[16:05:03.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:03.135]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:03.135]                   base::options(opts)
[16:05:03.135]                 }
[16:05:03.135]                 {
[16:05:03.135]                   {
[16:05:03.135]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:03.135]                     NULL
[16:05:03.135]                   }
[16:05:03.135]                   options(future.plan = NULL)
[16:05:03.135]                   if (is.na(NA_character_)) 
[16:05:03.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:03.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:03.135]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:03.135]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:03.135]                     envir = parent.frame()) 
[16:05:03.135]                   {
[16:05:03.135]                     if (is.function(workers)) 
[16:05:03.135]                       workers <- workers()
[16:05:03.135]                     workers <- structure(as.integer(workers), 
[16:05:03.135]                       class = class(workers))
[16:05:03.135]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:03.135]                       workers >= 1)
[16:05:03.135]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:03.135]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:03.135]                     }
[16:05:03.135]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:03.135]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:03.135]                       envir = envir)
[16:05:03.135]                     if (!future$lazy) 
[16:05:03.135]                       future <- run(future)
[16:05:03.135]                     invisible(future)
[16:05:03.135]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:03.135]                 }
[16:05:03.135]             }
[16:05:03.135]         }
[16:05:03.135]     })
[16:05:03.135]     if (TRUE) {
[16:05:03.135]         base::sink(type = "output", split = FALSE)
[16:05:03.135]         if (TRUE) {
[16:05:03.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:03.135]         }
[16:05:03.135]         else {
[16:05:03.135]             ...future.result["stdout"] <- base::list(NULL)
[16:05:03.135]         }
[16:05:03.135]         base::close(...future.stdout)
[16:05:03.135]         ...future.stdout <- NULL
[16:05:03.135]     }
[16:05:03.135]     ...future.result$conditions <- ...future.conditions
[16:05:03.135]     ...future.result$finished <- base::Sys.time()
[16:05:03.135]     ...future.result
[16:05:03.135] }
[16:05:03.138] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:05:03.138] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:05:03.138] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:05:03.139] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:05:03.139] MultisessionFuture started
[16:05:03.139] - Launch lazy future ... done
[16:05:03.139] run() for ‘MultisessionFuture’ ... done
[16:05:03.139] result() for ClusterFuture ...
[16:05:03.140] receiveMessageFromWorker() for ClusterFuture ...
[16:05:03.140] - Validating connection of MultisessionFuture
[16:05:03.188] - received message: FutureResult
[16:05:03.188] - Received FutureResult
[16:05:03.188] - Erased future from FutureRegistry
[16:05:03.188] result() for ClusterFuture ...
[16:05:03.188] - result already collected: FutureResult
[16:05:03.188] result() for ClusterFuture ... done
[16:05:03.189] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:03.189] result() for ClusterFuture ... done
[16:05:03.189] result() for ClusterFuture ...
[16:05:03.189] - result already collected: FutureResult
[16:05:03.189] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:03.189] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:03.190] Searching for globals...
[16:05:03.192] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:03.192] Searching for globals ... DONE
[16:05:03.192] Resolving globals: TRUE
[16:05:03.192] Resolving any globals that are futures ...
[16:05:03.192] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:03.192] Resolving any globals that are futures ... DONE
[16:05:03.193] Resolving futures part of globals (recursively) ...
[16:05:03.193] resolve() on list ...
[16:05:03.193]  recursive: 99
[16:05:03.193]  length: 1
[16:05:03.193]  elements: ‘x’
[16:05:03.193]  length: 0 (resolved future 1)
[16:05:03.193] resolve() on list ... DONE
[16:05:03.194] - globals: [1] ‘x’
[16:05:03.194] Resolving futures part of globals (recursively) ... DONE
[16:05:03.194] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:03.194] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:03.194] - globals: [1] ‘x’
[16:05:03.194] 
[16:05:03.194] getGlobalsAndPackages() ... DONE
[16:05:03.195] run() for ‘Future’ ...
[16:05:03.195] - state: ‘created’
[16:05:03.195] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:03.209] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:03.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:03.209]   - Field: ‘node’
[16:05:03.209]   - Field: ‘label’
[16:05:03.209]   - Field: ‘local’
[16:05:03.209]   - Field: ‘owner’
[16:05:03.209]   - Field: ‘envir’
[16:05:03.209]   - Field: ‘workers’
[16:05:03.209]   - Field: ‘packages’
[16:05:03.210]   - Field: ‘gc’
[16:05:03.210]   - Field: ‘conditions’
[16:05:03.210]   - Field: ‘persistent’
[16:05:03.210]   - Field: ‘expr’
[16:05:03.210]   - Field: ‘uuid’
[16:05:03.210]   - Field: ‘seed’
[16:05:03.210]   - Field: ‘version’
[16:05:03.210]   - Field: ‘result’
[16:05:03.210]   - Field: ‘asynchronous’
[16:05:03.210]   - Field: ‘calls’
[16:05:03.210]   - Field: ‘globals’
[16:05:03.211]   - Field: ‘stdout’
[16:05:03.211]   - Field: ‘earlySignal’
[16:05:03.211]   - Field: ‘lazy’
[16:05:03.211]   - Field: ‘state’
[16:05:03.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:03.211] - Launch lazy future ...
[16:05:03.211] Packages needed by the future expression (n = 0): <none>
[16:05:03.211] Packages needed by future strategies (n = 0): <none>
[16:05:03.212] {
[16:05:03.212]     {
[16:05:03.212]         {
[16:05:03.212]             ...future.startTime <- base::Sys.time()
[16:05:03.212]             {
[16:05:03.212]                 {
[16:05:03.212]                   {
[16:05:03.212]                     {
[16:05:03.212]                       base::local({
[16:05:03.212]                         has_future <- base::requireNamespace("future", 
[16:05:03.212]                           quietly = TRUE)
[16:05:03.212]                         if (has_future) {
[16:05:03.212]                           ns <- base::getNamespace("future")
[16:05:03.212]                           version <- ns[[".package"]][["version"]]
[16:05:03.212]                           if (is.null(version)) 
[16:05:03.212]                             version <- utils::packageVersion("future")
[16:05:03.212]                         }
[16:05:03.212]                         else {
[16:05:03.212]                           version <- NULL
[16:05:03.212]                         }
[16:05:03.212]                         if (!has_future || version < "1.8.0") {
[16:05:03.212]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:03.212]                             "", base::R.version$version.string), 
[16:05:03.212]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:03.212]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:03.212]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:03.212]                               "release", "version")], collapse = " "), 
[16:05:03.212]                             hostname = base::Sys.info()[["nodename"]])
[16:05:03.212]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:03.212]                             info)
[16:05:03.212]                           info <- base::paste(info, collapse = "; ")
[16:05:03.212]                           if (!has_future) {
[16:05:03.212]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:03.212]                               info)
[16:05:03.212]                           }
[16:05:03.212]                           else {
[16:05:03.212]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:03.212]                               info, version)
[16:05:03.212]                           }
[16:05:03.212]                           base::stop(msg)
[16:05:03.212]                         }
[16:05:03.212]                       })
[16:05:03.212]                     }
[16:05:03.212]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:03.212]                     base::options(mc.cores = 1L)
[16:05:03.212]                   }
[16:05:03.212]                   options(future.plan = NULL)
[16:05:03.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:03.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:03.212]                 }
[16:05:03.212]                 ...future.workdir <- getwd()
[16:05:03.212]             }
[16:05:03.212]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:03.212]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:03.212]         }
[16:05:03.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:03.212]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:03.212]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:03.212]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:03.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:03.212]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:03.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:03.212]             base::names(...future.oldOptions))
[16:05:03.212]     }
[16:05:03.212]     if (FALSE) {
[16:05:03.212]     }
[16:05:03.212]     else {
[16:05:03.212]         if (TRUE) {
[16:05:03.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:03.212]                 open = "w")
[16:05:03.212]         }
[16:05:03.212]         else {
[16:05:03.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:03.212]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:03.212]         }
[16:05:03.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:03.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:03.212]             base::sink(type = "output", split = FALSE)
[16:05:03.212]             base::close(...future.stdout)
[16:05:03.212]         }, add = TRUE)
[16:05:03.212]     }
[16:05:03.212]     ...future.frame <- base::sys.nframe()
[16:05:03.212]     ...future.conditions <- base::list()
[16:05:03.212]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:03.212]     if (FALSE) {
[16:05:03.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:03.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:03.212]     }
[16:05:03.212]     ...future.result <- base::tryCatch({
[16:05:03.212]         base::withCallingHandlers({
[16:05:03.212]             ...future.value <- base::withVisible(base::local({
[16:05:03.212]                 ...future.makeSendCondition <- base::local({
[16:05:03.212]                   sendCondition <- NULL
[16:05:03.212]                   function(frame = 1L) {
[16:05:03.212]                     if (is.function(sendCondition)) 
[16:05:03.212]                       return(sendCondition)
[16:05:03.212]                     ns <- getNamespace("parallel")
[16:05:03.212]                     if (exists("sendData", mode = "function", 
[16:05:03.212]                       envir = ns)) {
[16:05:03.212]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:03.212]                         envir = ns)
[16:05:03.212]                       envir <- sys.frame(frame)
[16:05:03.212]                       master <- NULL
[16:05:03.212]                       while (!identical(envir, .GlobalEnv) && 
[16:05:03.212]                         !identical(envir, emptyenv())) {
[16:05:03.212]                         if (exists("master", mode = "list", envir = envir, 
[16:05:03.212]                           inherits = FALSE)) {
[16:05:03.212]                           master <- get("master", mode = "list", 
[16:05:03.212]                             envir = envir, inherits = FALSE)
[16:05:03.212]                           if (inherits(master, c("SOCKnode", 
[16:05:03.212]                             "SOCK0node"))) {
[16:05:03.212]                             sendCondition <<- function(cond) {
[16:05:03.212]                               data <- list(type = "VALUE", value = cond, 
[16:05:03.212]                                 success = TRUE)
[16:05:03.212]                               parallel_sendData(master, data)
[16:05:03.212]                             }
[16:05:03.212]                             return(sendCondition)
[16:05:03.212]                           }
[16:05:03.212]                         }
[16:05:03.212]                         frame <- frame + 1L
[16:05:03.212]                         envir <- sys.frame(frame)
[16:05:03.212]                       }
[16:05:03.212]                     }
[16:05:03.212]                     sendCondition <<- function(cond) NULL
[16:05:03.212]                   }
[16:05:03.212]                 })
[16:05:03.212]                 withCallingHandlers({
[16:05:03.212]                   {
[16:05:03.212]                     x["a"] <- list(1)
[16:05:03.212]                     x
[16:05:03.212]                   }
[16:05:03.212]                 }, immediateCondition = function(cond) {
[16:05:03.212]                   sendCondition <- ...future.makeSendCondition()
[16:05:03.212]                   sendCondition(cond)
[16:05:03.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.212]                   {
[16:05:03.212]                     inherits <- base::inherits
[16:05:03.212]                     invokeRestart <- base::invokeRestart
[16:05:03.212]                     is.null <- base::is.null
[16:05:03.212]                     muffled <- FALSE
[16:05:03.212]                     if (inherits(cond, "message")) {
[16:05:03.212]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:03.212]                       if (muffled) 
[16:05:03.212]                         invokeRestart("muffleMessage")
[16:05:03.212]                     }
[16:05:03.212]                     else if (inherits(cond, "warning")) {
[16:05:03.212]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:03.212]                       if (muffled) 
[16:05:03.212]                         invokeRestart("muffleWarning")
[16:05:03.212]                     }
[16:05:03.212]                     else if (inherits(cond, "condition")) {
[16:05:03.212]                       if (!is.null(pattern)) {
[16:05:03.212]                         computeRestarts <- base::computeRestarts
[16:05:03.212]                         grepl <- base::grepl
[16:05:03.212]                         restarts <- computeRestarts(cond)
[16:05:03.212]                         for (restart in restarts) {
[16:05:03.212]                           name <- restart$name
[16:05:03.212]                           if (is.null(name)) 
[16:05:03.212]                             next
[16:05:03.212]                           if (!grepl(pattern, name)) 
[16:05:03.212]                             next
[16:05:03.212]                           invokeRestart(restart)
[16:05:03.212]                           muffled <- TRUE
[16:05:03.212]                           break
[16:05:03.212]                         }
[16:05:03.212]                       }
[16:05:03.212]                     }
[16:05:03.212]                     invisible(muffled)
[16:05:03.212]                   }
[16:05:03.212]                   muffleCondition(cond)
[16:05:03.212]                 })
[16:05:03.212]             }))
[16:05:03.212]             future::FutureResult(value = ...future.value$value, 
[16:05:03.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:03.212]                   ...future.rng), globalenv = if (FALSE) 
[16:05:03.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:03.212]                     ...future.globalenv.names))
[16:05:03.212]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:03.212]         }, condition = base::local({
[16:05:03.212]             c <- base::c
[16:05:03.212]             inherits <- base::inherits
[16:05:03.212]             invokeRestart <- base::invokeRestart
[16:05:03.212]             length <- base::length
[16:05:03.212]             list <- base::list
[16:05:03.212]             seq.int <- base::seq.int
[16:05:03.212]             signalCondition <- base::signalCondition
[16:05:03.212]             sys.calls <- base::sys.calls
[16:05:03.212]             `[[` <- base::`[[`
[16:05:03.212]             `+` <- base::`+`
[16:05:03.212]             `<<-` <- base::`<<-`
[16:05:03.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:03.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:03.212]                   3L)]
[16:05:03.212]             }
[16:05:03.212]             function(cond) {
[16:05:03.212]                 is_error <- inherits(cond, "error")
[16:05:03.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:03.212]                   NULL)
[16:05:03.212]                 if (is_error) {
[16:05:03.212]                   sessionInformation <- function() {
[16:05:03.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:03.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:03.212]                       search = base::search(), system = base::Sys.info())
[16:05:03.212]                   }
[16:05:03.212]                   ...future.conditions[[length(...future.conditions) + 
[16:05:03.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:03.212]                     cond$call), session = sessionInformation(), 
[16:05:03.212]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:03.212]                   signalCondition(cond)
[16:05:03.212]                 }
[16:05:03.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:03.212]                 "immediateCondition"))) {
[16:05:03.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:03.212]                   ...future.conditions[[length(...future.conditions) + 
[16:05:03.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:03.212]                   if (TRUE && !signal) {
[16:05:03.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.212]                     {
[16:05:03.212]                       inherits <- base::inherits
[16:05:03.212]                       invokeRestart <- base::invokeRestart
[16:05:03.212]                       is.null <- base::is.null
[16:05:03.212]                       muffled <- FALSE
[16:05:03.212]                       if (inherits(cond, "message")) {
[16:05:03.212]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:03.212]                         if (muffled) 
[16:05:03.212]                           invokeRestart("muffleMessage")
[16:05:03.212]                       }
[16:05:03.212]                       else if (inherits(cond, "warning")) {
[16:05:03.212]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:03.212]                         if (muffled) 
[16:05:03.212]                           invokeRestart("muffleWarning")
[16:05:03.212]                       }
[16:05:03.212]                       else if (inherits(cond, "condition")) {
[16:05:03.212]                         if (!is.null(pattern)) {
[16:05:03.212]                           computeRestarts <- base::computeRestarts
[16:05:03.212]                           grepl <- base::grepl
[16:05:03.212]                           restarts <- computeRestarts(cond)
[16:05:03.212]                           for (restart in restarts) {
[16:05:03.212]                             name <- restart$name
[16:05:03.212]                             if (is.null(name)) 
[16:05:03.212]                               next
[16:05:03.212]                             if (!grepl(pattern, name)) 
[16:05:03.212]                               next
[16:05:03.212]                             invokeRestart(restart)
[16:05:03.212]                             muffled <- TRUE
[16:05:03.212]                             break
[16:05:03.212]                           }
[16:05:03.212]                         }
[16:05:03.212]                       }
[16:05:03.212]                       invisible(muffled)
[16:05:03.212]                     }
[16:05:03.212]                     muffleCondition(cond, pattern = "^muffle")
[16:05:03.212]                   }
[16:05:03.212]                 }
[16:05:03.212]                 else {
[16:05:03.212]                   if (TRUE) {
[16:05:03.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.212]                     {
[16:05:03.212]                       inherits <- base::inherits
[16:05:03.212]                       invokeRestart <- base::invokeRestart
[16:05:03.212]                       is.null <- base::is.null
[16:05:03.212]                       muffled <- FALSE
[16:05:03.212]                       if (inherits(cond, "message")) {
[16:05:03.212]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:03.212]                         if (muffled) 
[16:05:03.212]                           invokeRestart("muffleMessage")
[16:05:03.212]                       }
[16:05:03.212]                       else if (inherits(cond, "warning")) {
[16:05:03.212]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:03.212]                         if (muffled) 
[16:05:03.212]                           invokeRestart("muffleWarning")
[16:05:03.212]                       }
[16:05:03.212]                       else if (inherits(cond, "condition")) {
[16:05:03.212]                         if (!is.null(pattern)) {
[16:05:03.212]                           computeRestarts <- base::computeRestarts
[16:05:03.212]                           grepl <- base::grepl
[16:05:03.212]                           restarts <- computeRestarts(cond)
[16:05:03.212]                           for (restart in restarts) {
[16:05:03.212]                             name <- restart$name
[16:05:03.212]                             if (is.null(name)) 
[16:05:03.212]                               next
[16:05:03.212]                             if (!grepl(pattern, name)) 
[16:05:03.212]                               next
[16:05:03.212]                             invokeRestart(restart)
[16:05:03.212]                             muffled <- TRUE
[16:05:03.212]                             break
[16:05:03.212]                           }
[16:05:03.212]                         }
[16:05:03.212]                       }
[16:05:03.212]                       invisible(muffled)
[16:05:03.212]                     }
[16:05:03.212]                     muffleCondition(cond, pattern = "^muffle")
[16:05:03.212]                   }
[16:05:03.212]                 }
[16:05:03.212]             }
[16:05:03.212]         }))
[16:05:03.212]     }, error = function(ex) {
[16:05:03.212]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:03.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:03.212]                 ...future.rng), started = ...future.startTime, 
[16:05:03.212]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:03.212]             version = "1.8"), class = "FutureResult")
[16:05:03.212]     }, finally = {
[16:05:03.212]         if (!identical(...future.workdir, getwd())) 
[16:05:03.212]             setwd(...future.workdir)
[16:05:03.212]         {
[16:05:03.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:03.212]                 ...future.oldOptions$nwarnings <- NULL
[16:05:03.212]             }
[16:05:03.212]             base::options(...future.oldOptions)
[16:05:03.212]             if (.Platform$OS.type == "windows") {
[16:05:03.212]                 old_names <- names(...future.oldEnvVars)
[16:05:03.212]                 envs <- base::Sys.getenv()
[16:05:03.212]                 names <- names(envs)
[16:05:03.212]                 common <- intersect(names, old_names)
[16:05:03.212]                 added <- setdiff(names, old_names)
[16:05:03.212]                 removed <- setdiff(old_names, names)
[16:05:03.212]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:03.212]                   envs[common]]
[16:05:03.212]                 NAMES <- toupper(changed)
[16:05:03.212]                 args <- list()
[16:05:03.212]                 for (kk in seq_along(NAMES)) {
[16:05:03.212]                   name <- changed[[kk]]
[16:05:03.212]                   NAME <- NAMES[[kk]]
[16:05:03.212]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.212]                     next
[16:05:03.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:03.212]                 }
[16:05:03.212]                 NAMES <- toupper(added)
[16:05:03.212]                 for (kk in seq_along(NAMES)) {
[16:05:03.212]                   name <- added[[kk]]
[16:05:03.212]                   NAME <- NAMES[[kk]]
[16:05:03.212]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.212]                     next
[16:05:03.212]                   args[[name]] <- ""
[16:05:03.212]                 }
[16:05:03.212]                 NAMES <- toupper(removed)
[16:05:03.212]                 for (kk in seq_along(NAMES)) {
[16:05:03.212]                   name <- removed[[kk]]
[16:05:03.212]                   NAME <- NAMES[[kk]]
[16:05:03.212]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.212]                     next
[16:05:03.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:03.212]                 }
[16:05:03.212]                 if (length(args) > 0) 
[16:05:03.212]                   base::do.call(base::Sys.setenv, args = args)
[16:05:03.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:03.212]             }
[16:05:03.212]             else {
[16:05:03.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:03.212]             }
[16:05:03.212]             {
[16:05:03.212]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:03.212]                   0L) {
[16:05:03.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:03.212]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:03.212]                   base::options(opts)
[16:05:03.212]                 }
[16:05:03.212]                 {
[16:05:03.212]                   {
[16:05:03.212]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:03.212]                     NULL
[16:05:03.212]                   }
[16:05:03.212]                   options(future.plan = NULL)
[16:05:03.212]                   if (is.na(NA_character_)) 
[16:05:03.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:03.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:03.212]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:03.212]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:03.212]                     envir = parent.frame()) 
[16:05:03.212]                   {
[16:05:03.212]                     if (is.function(workers)) 
[16:05:03.212]                       workers <- workers()
[16:05:03.212]                     workers <- structure(as.integer(workers), 
[16:05:03.212]                       class = class(workers))
[16:05:03.212]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:03.212]                       workers >= 1)
[16:05:03.212]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:03.212]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:03.212]                     }
[16:05:03.212]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:03.212]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:03.212]                       envir = envir)
[16:05:03.212]                     if (!future$lazy) 
[16:05:03.212]                       future <- run(future)
[16:05:03.212]                     invisible(future)
[16:05:03.212]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:03.212]                 }
[16:05:03.212]             }
[16:05:03.212]         }
[16:05:03.212]     })
[16:05:03.212]     if (TRUE) {
[16:05:03.212]         base::sink(type = "output", split = FALSE)
[16:05:03.212]         if (TRUE) {
[16:05:03.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:03.212]         }
[16:05:03.212]         else {
[16:05:03.212]             ...future.result["stdout"] <- base::list(NULL)
[16:05:03.212]         }
[16:05:03.212]         base::close(...future.stdout)
[16:05:03.212]         ...future.stdout <- NULL
[16:05:03.212]     }
[16:05:03.212]     ...future.result$conditions <- ...future.conditions
[16:05:03.212]     ...future.result$finished <- base::Sys.time()
[16:05:03.212]     ...future.result
[16:05:03.212] }
[16:05:03.215] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:05:03.215] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:05:03.215] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:05:03.215] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:05:03.216] MultisessionFuture started
[16:05:03.216] - Launch lazy future ... done
[16:05:03.216] run() for ‘MultisessionFuture’ ... done
[16:05:03.216] result() for ClusterFuture ...
[16:05:03.216] receiveMessageFromWorker() for ClusterFuture ...
[16:05:03.216] - Validating connection of MultisessionFuture
[16:05:03.264] - received message: FutureResult
[16:05:03.264] - Received FutureResult
[16:05:03.264] - Erased future from FutureRegistry
[16:05:03.264] result() for ClusterFuture ...
[16:05:03.264] - result already collected: FutureResult
[16:05:03.264] result() for ClusterFuture ... done
[16:05:03.264] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:03.265] result() for ClusterFuture ... done
[16:05:03.265] result() for ClusterFuture ...
[16:05:03.265] - result already collected: FutureResult
[16:05:03.265] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:03.265] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:03.265] Searching for globals...
[16:05:03.267] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:03.268] Searching for globals ... DONE
[16:05:03.268] Resolving globals: TRUE
[16:05:03.268] Resolving any globals that are futures ...
[16:05:03.268] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:03.268] Resolving any globals that are futures ... DONE
[16:05:03.268] Resolving futures part of globals (recursively) ...
[16:05:03.269] resolve() on list ...
[16:05:03.269]  recursive: 99
[16:05:03.269]  length: 1
[16:05:03.269]  elements: ‘x’
[16:05:03.269]  length: 0 (resolved future 1)
[16:05:03.269] resolve() on list ... DONE
[16:05:03.269] - globals: [1] ‘x’
[16:05:03.269] Resolving futures part of globals (recursively) ... DONE
[16:05:03.269] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:03.270] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:03.270] - globals: [1] ‘x’
[16:05:03.270] 
[16:05:03.270] getGlobalsAndPackages() ... DONE
[16:05:03.270] run() for ‘Future’ ...
[16:05:03.270] - state: ‘created’
[16:05:03.271] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:03.284] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:03.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:03.285]   - Field: ‘node’
[16:05:03.285]   - Field: ‘label’
[16:05:03.285]   - Field: ‘local’
[16:05:03.285]   - Field: ‘owner’
[16:05:03.285]   - Field: ‘envir’
[16:05:03.285]   - Field: ‘workers’
[16:05:03.285]   - Field: ‘packages’
[16:05:03.285]   - Field: ‘gc’
[16:05:03.285]   - Field: ‘conditions’
[16:05:03.285]   - Field: ‘persistent’
[16:05:03.285]   - Field: ‘expr’
[16:05:03.286]   - Field: ‘uuid’
[16:05:03.286]   - Field: ‘seed’
[16:05:03.286]   - Field: ‘version’
[16:05:03.286]   - Field: ‘result’
[16:05:03.286]   - Field: ‘asynchronous’
[16:05:03.286]   - Field: ‘calls’
[16:05:03.286]   - Field: ‘globals’
[16:05:03.286]   - Field: ‘stdout’
[16:05:03.286]   - Field: ‘earlySignal’
[16:05:03.286]   - Field: ‘lazy’
[16:05:03.286]   - Field: ‘state’
[16:05:03.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:03.287] - Launch lazy future ...
[16:05:03.287] Packages needed by the future expression (n = 0): <none>
[16:05:03.287] Packages needed by future strategies (n = 0): <none>
[16:05:03.287] {
[16:05:03.287]     {
[16:05:03.287]         {
[16:05:03.287]             ...future.startTime <- base::Sys.time()
[16:05:03.287]             {
[16:05:03.287]                 {
[16:05:03.287]                   {
[16:05:03.287]                     {
[16:05:03.287]                       base::local({
[16:05:03.287]                         has_future <- base::requireNamespace("future", 
[16:05:03.287]                           quietly = TRUE)
[16:05:03.287]                         if (has_future) {
[16:05:03.287]                           ns <- base::getNamespace("future")
[16:05:03.287]                           version <- ns[[".package"]][["version"]]
[16:05:03.287]                           if (is.null(version)) 
[16:05:03.287]                             version <- utils::packageVersion("future")
[16:05:03.287]                         }
[16:05:03.287]                         else {
[16:05:03.287]                           version <- NULL
[16:05:03.287]                         }
[16:05:03.287]                         if (!has_future || version < "1.8.0") {
[16:05:03.287]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:03.287]                             "", base::R.version$version.string), 
[16:05:03.287]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:03.287]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:03.287]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:03.287]                               "release", "version")], collapse = " "), 
[16:05:03.287]                             hostname = base::Sys.info()[["nodename"]])
[16:05:03.287]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:03.287]                             info)
[16:05:03.287]                           info <- base::paste(info, collapse = "; ")
[16:05:03.287]                           if (!has_future) {
[16:05:03.287]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:03.287]                               info)
[16:05:03.287]                           }
[16:05:03.287]                           else {
[16:05:03.287]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:03.287]                               info, version)
[16:05:03.287]                           }
[16:05:03.287]                           base::stop(msg)
[16:05:03.287]                         }
[16:05:03.287]                       })
[16:05:03.287]                     }
[16:05:03.287]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:03.287]                     base::options(mc.cores = 1L)
[16:05:03.287]                   }
[16:05:03.287]                   options(future.plan = NULL)
[16:05:03.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:03.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:03.287]                 }
[16:05:03.287]                 ...future.workdir <- getwd()
[16:05:03.287]             }
[16:05:03.287]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:03.287]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:03.287]         }
[16:05:03.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:03.287]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:03.287]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:03.287]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:03.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:03.287]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:03.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:03.287]             base::names(...future.oldOptions))
[16:05:03.287]     }
[16:05:03.287]     if (FALSE) {
[16:05:03.287]     }
[16:05:03.287]     else {
[16:05:03.287]         if (TRUE) {
[16:05:03.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:03.287]                 open = "w")
[16:05:03.287]         }
[16:05:03.287]         else {
[16:05:03.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:03.287]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:03.287]         }
[16:05:03.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:03.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:03.287]             base::sink(type = "output", split = FALSE)
[16:05:03.287]             base::close(...future.stdout)
[16:05:03.287]         }, add = TRUE)
[16:05:03.287]     }
[16:05:03.287]     ...future.frame <- base::sys.nframe()
[16:05:03.287]     ...future.conditions <- base::list()
[16:05:03.287]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:03.287]     if (FALSE) {
[16:05:03.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:03.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:03.287]     }
[16:05:03.287]     ...future.result <- base::tryCatch({
[16:05:03.287]         base::withCallingHandlers({
[16:05:03.287]             ...future.value <- base::withVisible(base::local({
[16:05:03.287]                 ...future.makeSendCondition <- base::local({
[16:05:03.287]                   sendCondition <- NULL
[16:05:03.287]                   function(frame = 1L) {
[16:05:03.287]                     if (is.function(sendCondition)) 
[16:05:03.287]                       return(sendCondition)
[16:05:03.287]                     ns <- getNamespace("parallel")
[16:05:03.287]                     if (exists("sendData", mode = "function", 
[16:05:03.287]                       envir = ns)) {
[16:05:03.287]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:03.287]                         envir = ns)
[16:05:03.287]                       envir <- sys.frame(frame)
[16:05:03.287]                       master <- NULL
[16:05:03.287]                       while (!identical(envir, .GlobalEnv) && 
[16:05:03.287]                         !identical(envir, emptyenv())) {
[16:05:03.287]                         if (exists("master", mode = "list", envir = envir, 
[16:05:03.287]                           inherits = FALSE)) {
[16:05:03.287]                           master <- get("master", mode = "list", 
[16:05:03.287]                             envir = envir, inherits = FALSE)
[16:05:03.287]                           if (inherits(master, c("SOCKnode", 
[16:05:03.287]                             "SOCK0node"))) {
[16:05:03.287]                             sendCondition <<- function(cond) {
[16:05:03.287]                               data <- list(type = "VALUE", value = cond, 
[16:05:03.287]                                 success = TRUE)
[16:05:03.287]                               parallel_sendData(master, data)
[16:05:03.287]                             }
[16:05:03.287]                             return(sendCondition)
[16:05:03.287]                           }
[16:05:03.287]                         }
[16:05:03.287]                         frame <- frame + 1L
[16:05:03.287]                         envir <- sys.frame(frame)
[16:05:03.287]                       }
[16:05:03.287]                     }
[16:05:03.287]                     sendCondition <<- function(cond) NULL
[16:05:03.287]                   }
[16:05:03.287]                 })
[16:05:03.287]                 withCallingHandlers({
[16:05:03.287]                   {
[16:05:03.287]                     x["a"] <- list(1)
[16:05:03.287]                     x
[16:05:03.287]                   }
[16:05:03.287]                 }, immediateCondition = function(cond) {
[16:05:03.287]                   sendCondition <- ...future.makeSendCondition()
[16:05:03.287]                   sendCondition(cond)
[16:05:03.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.287]                   {
[16:05:03.287]                     inherits <- base::inherits
[16:05:03.287]                     invokeRestart <- base::invokeRestart
[16:05:03.287]                     is.null <- base::is.null
[16:05:03.287]                     muffled <- FALSE
[16:05:03.287]                     if (inherits(cond, "message")) {
[16:05:03.287]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:03.287]                       if (muffled) 
[16:05:03.287]                         invokeRestart("muffleMessage")
[16:05:03.287]                     }
[16:05:03.287]                     else if (inherits(cond, "warning")) {
[16:05:03.287]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:03.287]                       if (muffled) 
[16:05:03.287]                         invokeRestart("muffleWarning")
[16:05:03.287]                     }
[16:05:03.287]                     else if (inherits(cond, "condition")) {
[16:05:03.287]                       if (!is.null(pattern)) {
[16:05:03.287]                         computeRestarts <- base::computeRestarts
[16:05:03.287]                         grepl <- base::grepl
[16:05:03.287]                         restarts <- computeRestarts(cond)
[16:05:03.287]                         for (restart in restarts) {
[16:05:03.287]                           name <- restart$name
[16:05:03.287]                           if (is.null(name)) 
[16:05:03.287]                             next
[16:05:03.287]                           if (!grepl(pattern, name)) 
[16:05:03.287]                             next
[16:05:03.287]                           invokeRestart(restart)
[16:05:03.287]                           muffled <- TRUE
[16:05:03.287]                           break
[16:05:03.287]                         }
[16:05:03.287]                       }
[16:05:03.287]                     }
[16:05:03.287]                     invisible(muffled)
[16:05:03.287]                   }
[16:05:03.287]                   muffleCondition(cond)
[16:05:03.287]                 })
[16:05:03.287]             }))
[16:05:03.287]             future::FutureResult(value = ...future.value$value, 
[16:05:03.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:03.287]                   ...future.rng), globalenv = if (FALSE) 
[16:05:03.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:03.287]                     ...future.globalenv.names))
[16:05:03.287]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:03.287]         }, condition = base::local({
[16:05:03.287]             c <- base::c
[16:05:03.287]             inherits <- base::inherits
[16:05:03.287]             invokeRestart <- base::invokeRestart
[16:05:03.287]             length <- base::length
[16:05:03.287]             list <- base::list
[16:05:03.287]             seq.int <- base::seq.int
[16:05:03.287]             signalCondition <- base::signalCondition
[16:05:03.287]             sys.calls <- base::sys.calls
[16:05:03.287]             `[[` <- base::`[[`
[16:05:03.287]             `+` <- base::`+`
[16:05:03.287]             `<<-` <- base::`<<-`
[16:05:03.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:03.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:03.287]                   3L)]
[16:05:03.287]             }
[16:05:03.287]             function(cond) {
[16:05:03.287]                 is_error <- inherits(cond, "error")
[16:05:03.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:03.287]                   NULL)
[16:05:03.287]                 if (is_error) {
[16:05:03.287]                   sessionInformation <- function() {
[16:05:03.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:03.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:03.287]                       search = base::search(), system = base::Sys.info())
[16:05:03.287]                   }
[16:05:03.287]                   ...future.conditions[[length(...future.conditions) + 
[16:05:03.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:03.287]                     cond$call), session = sessionInformation(), 
[16:05:03.287]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:03.287]                   signalCondition(cond)
[16:05:03.287]                 }
[16:05:03.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:03.287]                 "immediateCondition"))) {
[16:05:03.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:03.287]                   ...future.conditions[[length(...future.conditions) + 
[16:05:03.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:03.287]                   if (TRUE && !signal) {
[16:05:03.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.287]                     {
[16:05:03.287]                       inherits <- base::inherits
[16:05:03.287]                       invokeRestart <- base::invokeRestart
[16:05:03.287]                       is.null <- base::is.null
[16:05:03.287]                       muffled <- FALSE
[16:05:03.287]                       if (inherits(cond, "message")) {
[16:05:03.287]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:03.287]                         if (muffled) 
[16:05:03.287]                           invokeRestart("muffleMessage")
[16:05:03.287]                       }
[16:05:03.287]                       else if (inherits(cond, "warning")) {
[16:05:03.287]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:03.287]                         if (muffled) 
[16:05:03.287]                           invokeRestart("muffleWarning")
[16:05:03.287]                       }
[16:05:03.287]                       else if (inherits(cond, "condition")) {
[16:05:03.287]                         if (!is.null(pattern)) {
[16:05:03.287]                           computeRestarts <- base::computeRestarts
[16:05:03.287]                           grepl <- base::grepl
[16:05:03.287]                           restarts <- computeRestarts(cond)
[16:05:03.287]                           for (restart in restarts) {
[16:05:03.287]                             name <- restart$name
[16:05:03.287]                             if (is.null(name)) 
[16:05:03.287]                               next
[16:05:03.287]                             if (!grepl(pattern, name)) 
[16:05:03.287]                               next
[16:05:03.287]                             invokeRestart(restart)
[16:05:03.287]                             muffled <- TRUE
[16:05:03.287]                             break
[16:05:03.287]                           }
[16:05:03.287]                         }
[16:05:03.287]                       }
[16:05:03.287]                       invisible(muffled)
[16:05:03.287]                     }
[16:05:03.287]                     muffleCondition(cond, pattern = "^muffle")
[16:05:03.287]                   }
[16:05:03.287]                 }
[16:05:03.287]                 else {
[16:05:03.287]                   if (TRUE) {
[16:05:03.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.287]                     {
[16:05:03.287]                       inherits <- base::inherits
[16:05:03.287]                       invokeRestart <- base::invokeRestart
[16:05:03.287]                       is.null <- base::is.null
[16:05:03.287]                       muffled <- FALSE
[16:05:03.287]                       if (inherits(cond, "message")) {
[16:05:03.287]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:03.287]                         if (muffled) 
[16:05:03.287]                           invokeRestart("muffleMessage")
[16:05:03.287]                       }
[16:05:03.287]                       else if (inherits(cond, "warning")) {
[16:05:03.287]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:03.287]                         if (muffled) 
[16:05:03.287]                           invokeRestart("muffleWarning")
[16:05:03.287]                       }
[16:05:03.287]                       else if (inherits(cond, "condition")) {
[16:05:03.287]                         if (!is.null(pattern)) {
[16:05:03.287]                           computeRestarts <- base::computeRestarts
[16:05:03.287]                           grepl <- base::grepl
[16:05:03.287]                           restarts <- computeRestarts(cond)
[16:05:03.287]                           for (restart in restarts) {
[16:05:03.287]                             name <- restart$name
[16:05:03.287]                             if (is.null(name)) 
[16:05:03.287]                               next
[16:05:03.287]                             if (!grepl(pattern, name)) 
[16:05:03.287]                               next
[16:05:03.287]                             invokeRestart(restart)
[16:05:03.287]                             muffled <- TRUE
[16:05:03.287]                             break
[16:05:03.287]                           }
[16:05:03.287]                         }
[16:05:03.287]                       }
[16:05:03.287]                       invisible(muffled)
[16:05:03.287]                     }
[16:05:03.287]                     muffleCondition(cond, pattern = "^muffle")
[16:05:03.287]                   }
[16:05:03.287]                 }
[16:05:03.287]             }
[16:05:03.287]         }))
[16:05:03.287]     }, error = function(ex) {
[16:05:03.287]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:03.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:03.287]                 ...future.rng), started = ...future.startTime, 
[16:05:03.287]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:03.287]             version = "1.8"), class = "FutureResult")
[16:05:03.287]     }, finally = {
[16:05:03.287]         if (!identical(...future.workdir, getwd())) 
[16:05:03.287]             setwd(...future.workdir)
[16:05:03.287]         {
[16:05:03.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:03.287]                 ...future.oldOptions$nwarnings <- NULL
[16:05:03.287]             }
[16:05:03.287]             base::options(...future.oldOptions)
[16:05:03.287]             if (.Platform$OS.type == "windows") {
[16:05:03.287]                 old_names <- names(...future.oldEnvVars)
[16:05:03.287]                 envs <- base::Sys.getenv()
[16:05:03.287]                 names <- names(envs)
[16:05:03.287]                 common <- intersect(names, old_names)
[16:05:03.287]                 added <- setdiff(names, old_names)
[16:05:03.287]                 removed <- setdiff(old_names, names)
[16:05:03.287]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:03.287]                   envs[common]]
[16:05:03.287]                 NAMES <- toupper(changed)
[16:05:03.287]                 args <- list()
[16:05:03.287]                 for (kk in seq_along(NAMES)) {
[16:05:03.287]                   name <- changed[[kk]]
[16:05:03.287]                   NAME <- NAMES[[kk]]
[16:05:03.287]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.287]                     next
[16:05:03.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:03.287]                 }
[16:05:03.287]                 NAMES <- toupper(added)
[16:05:03.287]                 for (kk in seq_along(NAMES)) {
[16:05:03.287]                   name <- added[[kk]]
[16:05:03.287]                   NAME <- NAMES[[kk]]
[16:05:03.287]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.287]                     next
[16:05:03.287]                   args[[name]] <- ""
[16:05:03.287]                 }
[16:05:03.287]                 NAMES <- toupper(removed)
[16:05:03.287]                 for (kk in seq_along(NAMES)) {
[16:05:03.287]                   name <- removed[[kk]]
[16:05:03.287]                   NAME <- NAMES[[kk]]
[16:05:03.287]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.287]                     next
[16:05:03.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:03.287]                 }
[16:05:03.287]                 if (length(args) > 0) 
[16:05:03.287]                   base::do.call(base::Sys.setenv, args = args)
[16:05:03.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:03.287]             }
[16:05:03.287]             else {
[16:05:03.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:03.287]             }
[16:05:03.287]             {
[16:05:03.287]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:03.287]                   0L) {
[16:05:03.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:03.287]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:03.287]                   base::options(opts)
[16:05:03.287]                 }
[16:05:03.287]                 {
[16:05:03.287]                   {
[16:05:03.287]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:03.287]                     NULL
[16:05:03.287]                   }
[16:05:03.287]                   options(future.plan = NULL)
[16:05:03.287]                   if (is.na(NA_character_)) 
[16:05:03.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:03.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:03.287]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:03.287]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:03.287]                     envir = parent.frame()) 
[16:05:03.287]                   {
[16:05:03.287]                     if (is.function(workers)) 
[16:05:03.287]                       workers <- workers()
[16:05:03.287]                     workers <- structure(as.integer(workers), 
[16:05:03.287]                       class = class(workers))
[16:05:03.287]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:03.287]                       workers >= 1)
[16:05:03.287]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:03.287]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:03.287]                     }
[16:05:03.287]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:03.287]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:03.287]                       envir = envir)
[16:05:03.287]                     if (!future$lazy) 
[16:05:03.287]                       future <- run(future)
[16:05:03.287]                     invisible(future)
[16:05:03.287]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:03.287]                 }
[16:05:03.287]             }
[16:05:03.287]         }
[16:05:03.287]     })
[16:05:03.287]     if (TRUE) {
[16:05:03.287]         base::sink(type = "output", split = FALSE)
[16:05:03.287]         if (TRUE) {
[16:05:03.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:03.287]         }
[16:05:03.287]         else {
[16:05:03.287]             ...future.result["stdout"] <- base::list(NULL)
[16:05:03.287]         }
[16:05:03.287]         base::close(...future.stdout)
[16:05:03.287]         ...future.stdout <- NULL
[16:05:03.287]     }
[16:05:03.287]     ...future.result$conditions <- ...future.conditions
[16:05:03.287]     ...future.result$finished <- base::Sys.time()
[16:05:03.287]     ...future.result
[16:05:03.287] }
[16:05:03.290] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:05:03.290] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:05:03.291] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:05:03.291] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:05:03.291] MultisessionFuture started
[16:05:03.291] - Launch lazy future ... done
[16:05:03.291] run() for ‘MultisessionFuture’ ... done
[16:05:03.292] result() for ClusterFuture ...
[16:05:03.292] receiveMessageFromWorker() for ClusterFuture ...
[16:05:03.292] - Validating connection of MultisessionFuture
[16:05:03.340] - received message: FutureResult
[16:05:03.340] - Received FutureResult
[16:05:03.340] - Erased future from FutureRegistry
[16:05:03.340] result() for ClusterFuture ...
[16:05:03.340] - result already collected: FutureResult
[16:05:03.340] result() for ClusterFuture ... done
[16:05:03.340] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:03.340] result() for ClusterFuture ... done
[16:05:03.341] result() for ClusterFuture ...
[16:05:03.341] - result already collected: FutureResult
[16:05:03.341] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:03.341] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:03.341] Searching for globals...
[16:05:03.344] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:03.344] Searching for globals ... DONE
[16:05:03.344] Resolving globals: TRUE
[16:05:03.344] Resolving any globals that are futures ...
[16:05:03.344] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:05:03.344] Resolving any globals that are futures ... DONE
[16:05:03.344] Resolving futures part of globals (recursively) ...
[16:05:03.345] resolve() on list ...
[16:05:03.345]  recursive: 99
[16:05:03.345]  length: 1
[16:05:03.345]  elements: ‘x’
[16:05:03.345]  length: 0 (resolved future 1)
[16:05:03.345] resolve() on list ... DONE
[16:05:03.345] - globals: [1] ‘x’
[16:05:03.345] Resolving futures part of globals (recursively) ... DONE
[16:05:03.346] The total size of the 1 globals is 0 bytes (0 bytes)
[16:05:03.346] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:05:03.346] - globals: [1] ‘x’
[16:05:03.346] 
[16:05:03.346] getGlobalsAndPackages() ... DONE
[16:05:03.346] run() for ‘Future’ ...
[16:05:03.347] - state: ‘created’
[16:05:03.347] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:03.360] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:03.360] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:03.360]   - Field: ‘node’
[16:05:03.360]   - Field: ‘label’
[16:05:03.361]   - Field: ‘local’
[16:05:03.361]   - Field: ‘owner’
[16:05:03.361]   - Field: ‘envir’
[16:05:03.361]   - Field: ‘workers’
[16:05:03.361]   - Field: ‘packages’
[16:05:03.361]   - Field: ‘gc’
[16:05:03.361]   - Field: ‘conditions’
[16:05:03.361]   - Field: ‘persistent’
[16:05:03.361]   - Field: ‘expr’
[16:05:03.361]   - Field: ‘uuid’
[16:05:03.362]   - Field: ‘seed’
[16:05:03.362]   - Field: ‘version’
[16:05:03.362]   - Field: ‘result’
[16:05:03.362]   - Field: ‘asynchronous’
[16:05:03.362]   - Field: ‘calls’
[16:05:03.362]   - Field: ‘globals’
[16:05:03.362]   - Field: ‘stdout’
[16:05:03.362]   - Field: ‘earlySignal’
[16:05:03.362]   - Field: ‘lazy’
[16:05:03.362]   - Field: ‘state’
[16:05:03.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:03.363] - Launch lazy future ...
[16:05:03.363] Packages needed by the future expression (n = 0): <none>
[16:05:03.363] Packages needed by future strategies (n = 0): <none>
[16:05:03.363] {
[16:05:03.363]     {
[16:05:03.363]         {
[16:05:03.363]             ...future.startTime <- base::Sys.time()
[16:05:03.363]             {
[16:05:03.363]                 {
[16:05:03.363]                   {
[16:05:03.363]                     {
[16:05:03.363]                       base::local({
[16:05:03.363]                         has_future <- base::requireNamespace("future", 
[16:05:03.363]                           quietly = TRUE)
[16:05:03.363]                         if (has_future) {
[16:05:03.363]                           ns <- base::getNamespace("future")
[16:05:03.363]                           version <- ns[[".package"]][["version"]]
[16:05:03.363]                           if (is.null(version)) 
[16:05:03.363]                             version <- utils::packageVersion("future")
[16:05:03.363]                         }
[16:05:03.363]                         else {
[16:05:03.363]                           version <- NULL
[16:05:03.363]                         }
[16:05:03.363]                         if (!has_future || version < "1.8.0") {
[16:05:03.363]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:03.363]                             "", base::R.version$version.string), 
[16:05:03.363]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:03.363]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:03.363]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:03.363]                               "release", "version")], collapse = " "), 
[16:05:03.363]                             hostname = base::Sys.info()[["nodename"]])
[16:05:03.363]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:03.363]                             info)
[16:05:03.363]                           info <- base::paste(info, collapse = "; ")
[16:05:03.363]                           if (!has_future) {
[16:05:03.363]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:03.363]                               info)
[16:05:03.363]                           }
[16:05:03.363]                           else {
[16:05:03.363]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:03.363]                               info, version)
[16:05:03.363]                           }
[16:05:03.363]                           base::stop(msg)
[16:05:03.363]                         }
[16:05:03.363]                       })
[16:05:03.363]                     }
[16:05:03.363]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:03.363]                     base::options(mc.cores = 1L)
[16:05:03.363]                   }
[16:05:03.363]                   options(future.plan = NULL)
[16:05:03.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:03.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:03.363]                 }
[16:05:03.363]                 ...future.workdir <- getwd()
[16:05:03.363]             }
[16:05:03.363]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:03.363]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:03.363]         }
[16:05:03.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:03.363]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:03.363]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:03.363]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:03.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:03.363]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:03.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:03.363]             base::names(...future.oldOptions))
[16:05:03.363]     }
[16:05:03.363]     if (FALSE) {
[16:05:03.363]     }
[16:05:03.363]     else {
[16:05:03.363]         if (TRUE) {
[16:05:03.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:03.363]                 open = "w")
[16:05:03.363]         }
[16:05:03.363]         else {
[16:05:03.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:03.363]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:03.363]         }
[16:05:03.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:03.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:03.363]             base::sink(type = "output", split = FALSE)
[16:05:03.363]             base::close(...future.stdout)
[16:05:03.363]         }, add = TRUE)
[16:05:03.363]     }
[16:05:03.363]     ...future.frame <- base::sys.nframe()
[16:05:03.363]     ...future.conditions <- base::list()
[16:05:03.363]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:03.363]     if (FALSE) {
[16:05:03.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:03.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:03.363]     }
[16:05:03.363]     ...future.result <- base::tryCatch({
[16:05:03.363]         base::withCallingHandlers({
[16:05:03.363]             ...future.value <- base::withVisible(base::local({
[16:05:03.363]                 ...future.makeSendCondition <- base::local({
[16:05:03.363]                   sendCondition <- NULL
[16:05:03.363]                   function(frame = 1L) {
[16:05:03.363]                     if (is.function(sendCondition)) 
[16:05:03.363]                       return(sendCondition)
[16:05:03.363]                     ns <- getNamespace("parallel")
[16:05:03.363]                     if (exists("sendData", mode = "function", 
[16:05:03.363]                       envir = ns)) {
[16:05:03.363]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:03.363]                         envir = ns)
[16:05:03.363]                       envir <- sys.frame(frame)
[16:05:03.363]                       master <- NULL
[16:05:03.363]                       while (!identical(envir, .GlobalEnv) && 
[16:05:03.363]                         !identical(envir, emptyenv())) {
[16:05:03.363]                         if (exists("master", mode = "list", envir = envir, 
[16:05:03.363]                           inherits = FALSE)) {
[16:05:03.363]                           master <- get("master", mode = "list", 
[16:05:03.363]                             envir = envir, inherits = FALSE)
[16:05:03.363]                           if (inherits(master, c("SOCKnode", 
[16:05:03.363]                             "SOCK0node"))) {
[16:05:03.363]                             sendCondition <<- function(cond) {
[16:05:03.363]                               data <- list(type = "VALUE", value = cond, 
[16:05:03.363]                                 success = TRUE)
[16:05:03.363]                               parallel_sendData(master, data)
[16:05:03.363]                             }
[16:05:03.363]                             return(sendCondition)
[16:05:03.363]                           }
[16:05:03.363]                         }
[16:05:03.363]                         frame <- frame + 1L
[16:05:03.363]                         envir <- sys.frame(frame)
[16:05:03.363]                       }
[16:05:03.363]                     }
[16:05:03.363]                     sendCondition <<- function(cond) NULL
[16:05:03.363]                   }
[16:05:03.363]                 })
[16:05:03.363]                 withCallingHandlers({
[16:05:03.363]                   {
[16:05:03.363]                     x["a"] <- list(1)
[16:05:03.363]                     x
[16:05:03.363]                   }
[16:05:03.363]                 }, immediateCondition = function(cond) {
[16:05:03.363]                   sendCondition <- ...future.makeSendCondition()
[16:05:03.363]                   sendCondition(cond)
[16:05:03.363]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.363]                   {
[16:05:03.363]                     inherits <- base::inherits
[16:05:03.363]                     invokeRestart <- base::invokeRestart
[16:05:03.363]                     is.null <- base::is.null
[16:05:03.363]                     muffled <- FALSE
[16:05:03.363]                     if (inherits(cond, "message")) {
[16:05:03.363]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:03.363]                       if (muffled) 
[16:05:03.363]                         invokeRestart("muffleMessage")
[16:05:03.363]                     }
[16:05:03.363]                     else if (inherits(cond, "warning")) {
[16:05:03.363]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:03.363]                       if (muffled) 
[16:05:03.363]                         invokeRestart("muffleWarning")
[16:05:03.363]                     }
[16:05:03.363]                     else if (inherits(cond, "condition")) {
[16:05:03.363]                       if (!is.null(pattern)) {
[16:05:03.363]                         computeRestarts <- base::computeRestarts
[16:05:03.363]                         grepl <- base::grepl
[16:05:03.363]                         restarts <- computeRestarts(cond)
[16:05:03.363]                         for (restart in restarts) {
[16:05:03.363]                           name <- restart$name
[16:05:03.363]                           if (is.null(name)) 
[16:05:03.363]                             next
[16:05:03.363]                           if (!grepl(pattern, name)) 
[16:05:03.363]                             next
[16:05:03.363]                           invokeRestart(restart)
[16:05:03.363]                           muffled <- TRUE
[16:05:03.363]                           break
[16:05:03.363]                         }
[16:05:03.363]                       }
[16:05:03.363]                     }
[16:05:03.363]                     invisible(muffled)
[16:05:03.363]                   }
[16:05:03.363]                   muffleCondition(cond)
[16:05:03.363]                 })
[16:05:03.363]             }))
[16:05:03.363]             future::FutureResult(value = ...future.value$value, 
[16:05:03.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:03.363]                   ...future.rng), globalenv = if (FALSE) 
[16:05:03.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:03.363]                     ...future.globalenv.names))
[16:05:03.363]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:03.363]         }, condition = base::local({
[16:05:03.363]             c <- base::c
[16:05:03.363]             inherits <- base::inherits
[16:05:03.363]             invokeRestart <- base::invokeRestart
[16:05:03.363]             length <- base::length
[16:05:03.363]             list <- base::list
[16:05:03.363]             seq.int <- base::seq.int
[16:05:03.363]             signalCondition <- base::signalCondition
[16:05:03.363]             sys.calls <- base::sys.calls
[16:05:03.363]             `[[` <- base::`[[`
[16:05:03.363]             `+` <- base::`+`
[16:05:03.363]             `<<-` <- base::`<<-`
[16:05:03.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:03.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:03.363]                   3L)]
[16:05:03.363]             }
[16:05:03.363]             function(cond) {
[16:05:03.363]                 is_error <- inherits(cond, "error")
[16:05:03.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:03.363]                   NULL)
[16:05:03.363]                 if (is_error) {
[16:05:03.363]                   sessionInformation <- function() {
[16:05:03.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:03.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:03.363]                       search = base::search(), system = base::Sys.info())
[16:05:03.363]                   }
[16:05:03.363]                   ...future.conditions[[length(...future.conditions) + 
[16:05:03.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:03.363]                     cond$call), session = sessionInformation(), 
[16:05:03.363]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:03.363]                   signalCondition(cond)
[16:05:03.363]                 }
[16:05:03.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:03.363]                 "immediateCondition"))) {
[16:05:03.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:03.363]                   ...future.conditions[[length(...future.conditions) + 
[16:05:03.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:03.363]                   if (TRUE && !signal) {
[16:05:03.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.363]                     {
[16:05:03.363]                       inherits <- base::inherits
[16:05:03.363]                       invokeRestart <- base::invokeRestart
[16:05:03.363]                       is.null <- base::is.null
[16:05:03.363]                       muffled <- FALSE
[16:05:03.363]                       if (inherits(cond, "message")) {
[16:05:03.363]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:03.363]                         if (muffled) 
[16:05:03.363]                           invokeRestart("muffleMessage")
[16:05:03.363]                       }
[16:05:03.363]                       else if (inherits(cond, "warning")) {
[16:05:03.363]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:03.363]                         if (muffled) 
[16:05:03.363]                           invokeRestart("muffleWarning")
[16:05:03.363]                       }
[16:05:03.363]                       else if (inherits(cond, "condition")) {
[16:05:03.363]                         if (!is.null(pattern)) {
[16:05:03.363]                           computeRestarts <- base::computeRestarts
[16:05:03.363]                           grepl <- base::grepl
[16:05:03.363]                           restarts <- computeRestarts(cond)
[16:05:03.363]                           for (restart in restarts) {
[16:05:03.363]                             name <- restart$name
[16:05:03.363]                             if (is.null(name)) 
[16:05:03.363]                               next
[16:05:03.363]                             if (!grepl(pattern, name)) 
[16:05:03.363]                               next
[16:05:03.363]                             invokeRestart(restart)
[16:05:03.363]                             muffled <- TRUE
[16:05:03.363]                             break
[16:05:03.363]                           }
[16:05:03.363]                         }
[16:05:03.363]                       }
[16:05:03.363]                       invisible(muffled)
[16:05:03.363]                     }
[16:05:03.363]                     muffleCondition(cond, pattern = "^muffle")
[16:05:03.363]                   }
[16:05:03.363]                 }
[16:05:03.363]                 else {
[16:05:03.363]                   if (TRUE) {
[16:05:03.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.363]                     {
[16:05:03.363]                       inherits <- base::inherits
[16:05:03.363]                       invokeRestart <- base::invokeRestart
[16:05:03.363]                       is.null <- base::is.null
[16:05:03.363]                       muffled <- FALSE
[16:05:03.363]                       if (inherits(cond, "message")) {
[16:05:03.363]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:03.363]                         if (muffled) 
[16:05:03.363]                           invokeRestart("muffleMessage")
[16:05:03.363]                       }
[16:05:03.363]                       else if (inherits(cond, "warning")) {
[16:05:03.363]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:03.363]                         if (muffled) 
[16:05:03.363]                           invokeRestart("muffleWarning")
[16:05:03.363]                       }
[16:05:03.363]                       else if (inherits(cond, "condition")) {
[16:05:03.363]                         if (!is.null(pattern)) {
[16:05:03.363]                           computeRestarts <- base::computeRestarts
[16:05:03.363]                           grepl <- base::grepl
[16:05:03.363]                           restarts <- computeRestarts(cond)
[16:05:03.363]                           for (restart in restarts) {
[16:05:03.363]                             name <- restart$name
[16:05:03.363]                             if (is.null(name)) 
[16:05:03.363]                               next
[16:05:03.363]                             if (!grepl(pattern, name)) 
[16:05:03.363]                               next
[16:05:03.363]                             invokeRestart(restart)
[16:05:03.363]                             muffled <- TRUE
[16:05:03.363]                             break
[16:05:03.363]                           }
[16:05:03.363]                         }
[16:05:03.363]                       }
[16:05:03.363]                       invisible(muffled)
[16:05:03.363]                     }
[16:05:03.363]                     muffleCondition(cond, pattern = "^muffle")
[16:05:03.363]                   }
[16:05:03.363]                 }
[16:05:03.363]             }
[16:05:03.363]         }))
[16:05:03.363]     }, error = function(ex) {
[16:05:03.363]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:03.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:03.363]                 ...future.rng), started = ...future.startTime, 
[16:05:03.363]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:03.363]             version = "1.8"), class = "FutureResult")
[16:05:03.363]     }, finally = {
[16:05:03.363]         if (!identical(...future.workdir, getwd())) 
[16:05:03.363]             setwd(...future.workdir)
[16:05:03.363]         {
[16:05:03.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:03.363]                 ...future.oldOptions$nwarnings <- NULL
[16:05:03.363]             }
[16:05:03.363]             base::options(...future.oldOptions)
[16:05:03.363]             if (.Platform$OS.type == "windows") {
[16:05:03.363]                 old_names <- names(...future.oldEnvVars)
[16:05:03.363]                 envs <- base::Sys.getenv()
[16:05:03.363]                 names <- names(envs)
[16:05:03.363]                 common <- intersect(names, old_names)
[16:05:03.363]                 added <- setdiff(names, old_names)
[16:05:03.363]                 removed <- setdiff(old_names, names)
[16:05:03.363]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:03.363]                   envs[common]]
[16:05:03.363]                 NAMES <- toupper(changed)
[16:05:03.363]                 args <- list()
[16:05:03.363]                 for (kk in seq_along(NAMES)) {
[16:05:03.363]                   name <- changed[[kk]]
[16:05:03.363]                   NAME <- NAMES[[kk]]
[16:05:03.363]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.363]                     next
[16:05:03.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:03.363]                 }
[16:05:03.363]                 NAMES <- toupper(added)
[16:05:03.363]                 for (kk in seq_along(NAMES)) {
[16:05:03.363]                   name <- added[[kk]]
[16:05:03.363]                   NAME <- NAMES[[kk]]
[16:05:03.363]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.363]                     next
[16:05:03.363]                   args[[name]] <- ""
[16:05:03.363]                 }
[16:05:03.363]                 NAMES <- toupper(removed)
[16:05:03.363]                 for (kk in seq_along(NAMES)) {
[16:05:03.363]                   name <- removed[[kk]]
[16:05:03.363]                   NAME <- NAMES[[kk]]
[16:05:03.363]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.363]                     next
[16:05:03.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:03.363]                 }
[16:05:03.363]                 if (length(args) > 0) 
[16:05:03.363]                   base::do.call(base::Sys.setenv, args = args)
[16:05:03.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:03.363]             }
[16:05:03.363]             else {
[16:05:03.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:03.363]             }
[16:05:03.363]             {
[16:05:03.363]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:03.363]                   0L) {
[16:05:03.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:03.363]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:03.363]                   base::options(opts)
[16:05:03.363]                 }
[16:05:03.363]                 {
[16:05:03.363]                   {
[16:05:03.363]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:03.363]                     NULL
[16:05:03.363]                   }
[16:05:03.363]                   options(future.plan = NULL)
[16:05:03.363]                   if (is.na(NA_character_)) 
[16:05:03.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:03.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:03.363]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:03.363]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:03.363]                     envir = parent.frame()) 
[16:05:03.363]                   {
[16:05:03.363]                     if (is.function(workers)) 
[16:05:03.363]                       workers <- workers()
[16:05:03.363]                     workers <- structure(as.integer(workers), 
[16:05:03.363]                       class = class(workers))
[16:05:03.363]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:03.363]                       workers >= 1)
[16:05:03.363]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:03.363]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:03.363]                     }
[16:05:03.363]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:03.363]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:03.363]                       envir = envir)
[16:05:03.363]                     if (!future$lazy) 
[16:05:03.363]                       future <- run(future)
[16:05:03.363]                     invisible(future)
[16:05:03.363]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:03.363]                 }
[16:05:03.363]             }
[16:05:03.363]         }
[16:05:03.363]     })
[16:05:03.363]     if (TRUE) {
[16:05:03.363]         base::sink(type = "output", split = FALSE)
[16:05:03.363]         if (TRUE) {
[16:05:03.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:03.363]         }
[16:05:03.363]         else {
[16:05:03.363]             ...future.result["stdout"] <- base::list(NULL)
[16:05:03.363]         }
[16:05:03.363]         base::close(...future.stdout)
[16:05:03.363]         ...future.stdout <- NULL
[16:05:03.363]     }
[16:05:03.363]     ...future.result$conditions <- ...future.conditions
[16:05:03.363]     ...future.result$finished <- base::Sys.time()
[16:05:03.363]     ...future.result
[16:05:03.363] }
[16:05:03.366] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:05:03.366] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:05:03.367] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:05:03.367] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:05:03.367] MultisessionFuture started
[16:05:03.367] - Launch lazy future ... done
[16:05:03.367] run() for ‘MultisessionFuture’ ... done
[16:05:03.368] result() for ClusterFuture ...
[16:05:03.368] receiveMessageFromWorker() for ClusterFuture ...
[16:05:03.368] - Validating connection of MultisessionFuture
[16:05:03.420] - received message: FutureResult
[16:05:03.420] - Received FutureResult
[16:05:03.420] - Erased future from FutureRegistry
[16:05:03.420] result() for ClusterFuture ...
[16:05:03.420] - result already collected: FutureResult
[16:05:03.420] result() for ClusterFuture ... done
[16:05:03.421] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:03.421] result() for ClusterFuture ... done
[16:05:03.421] result() for ClusterFuture ...
[16:05:03.421] - result already collected: FutureResult
[16:05:03.421] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:03.421] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:03.422] Searching for globals...
[16:05:03.424] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[16:05:03.424] Searching for globals ... DONE
[16:05:03.424] Resolving globals: TRUE
[16:05:03.424] Resolving any globals that are futures ...
[16:05:03.424] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[16:05:03.424] Resolving any globals that are futures ... DONE
[16:05:03.425] Resolving futures part of globals (recursively) ...
[16:05:03.425] resolve() on list ...
[16:05:03.425]  recursive: 99
[16:05:03.425]  length: 2
[16:05:03.425]  elements: ‘x’, ‘name’
[16:05:03.425]  length: 1 (resolved future 1)
[16:05:03.426]  length: 0 (resolved future 2)
[16:05:03.426] resolve() on list ... DONE
[16:05:03.426] - globals: [2] ‘x’, ‘name’
[16:05:03.426] Resolving futures part of globals (recursively) ... DONE
[16:05:03.426] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:03.426] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[16:05:03.426] - globals: [2] ‘x’, ‘name’
[16:05:03.427] 
[16:05:03.427] getGlobalsAndPackages() ... DONE
[16:05:03.427] run() for ‘Future’ ...
[16:05:03.427] - state: ‘created’
[16:05:03.427] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:03.441] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:03.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:03.441]   - Field: ‘node’
[16:05:03.441]   - Field: ‘label’
[16:05:03.441]   - Field: ‘local’
[16:05:03.441]   - Field: ‘owner’
[16:05:03.441]   - Field: ‘envir’
[16:05:03.441]   - Field: ‘workers’
[16:05:03.441]   - Field: ‘packages’
[16:05:03.442]   - Field: ‘gc’
[16:05:03.442]   - Field: ‘conditions’
[16:05:03.442]   - Field: ‘persistent’
[16:05:03.442]   - Field: ‘expr’
[16:05:03.442]   - Field: ‘uuid’
[16:05:03.442]   - Field: ‘seed’
[16:05:03.442]   - Field: ‘version’
[16:05:03.442]   - Field: ‘result’
[16:05:03.442]   - Field: ‘asynchronous’
[16:05:03.442]   - Field: ‘calls’
[16:05:03.442]   - Field: ‘globals’
[16:05:03.443]   - Field: ‘stdout’
[16:05:03.443]   - Field: ‘earlySignal’
[16:05:03.443]   - Field: ‘lazy’
[16:05:03.443]   - Field: ‘state’
[16:05:03.443] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:03.443] - Launch lazy future ...
[16:05:03.443] Packages needed by the future expression (n = 0): <none>
[16:05:03.443] Packages needed by future strategies (n = 0): <none>
[16:05:03.444] {
[16:05:03.444]     {
[16:05:03.444]         {
[16:05:03.444]             ...future.startTime <- base::Sys.time()
[16:05:03.444]             {
[16:05:03.444]                 {
[16:05:03.444]                   {
[16:05:03.444]                     {
[16:05:03.444]                       base::local({
[16:05:03.444]                         has_future <- base::requireNamespace("future", 
[16:05:03.444]                           quietly = TRUE)
[16:05:03.444]                         if (has_future) {
[16:05:03.444]                           ns <- base::getNamespace("future")
[16:05:03.444]                           version <- ns[[".package"]][["version"]]
[16:05:03.444]                           if (is.null(version)) 
[16:05:03.444]                             version <- utils::packageVersion("future")
[16:05:03.444]                         }
[16:05:03.444]                         else {
[16:05:03.444]                           version <- NULL
[16:05:03.444]                         }
[16:05:03.444]                         if (!has_future || version < "1.8.0") {
[16:05:03.444]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:03.444]                             "", base::R.version$version.string), 
[16:05:03.444]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:03.444]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:03.444]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:03.444]                               "release", "version")], collapse = " "), 
[16:05:03.444]                             hostname = base::Sys.info()[["nodename"]])
[16:05:03.444]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:03.444]                             info)
[16:05:03.444]                           info <- base::paste(info, collapse = "; ")
[16:05:03.444]                           if (!has_future) {
[16:05:03.444]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:03.444]                               info)
[16:05:03.444]                           }
[16:05:03.444]                           else {
[16:05:03.444]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:03.444]                               info, version)
[16:05:03.444]                           }
[16:05:03.444]                           base::stop(msg)
[16:05:03.444]                         }
[16:05:03.444]                       })
[16:05:03.444]                     }
[16:05:03.444]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:03.444]                     base::options(mc.cores = 1L)
[16:05:03.444]                   }
[16:05:03.444]                   options(future.plan = NULL)
[16:05:03.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:03.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:03.444]                 }
[16:05:03.444]                 ...future.workdir <- getwd()
[16:05:03.444]             }
[16:05:03.444]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:03.444]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:03.444]         }
[16:05:03.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:03.444]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:03.444]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:03.444]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:03.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:03.444]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:03.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:03.444]             base::names(...future.oldOptions))
[16:05:03.444]     }
[16:05:03.444]     if (FALSE) {
[16:05:03.444]     }
[16:05:03.444]     else {
[16:05:03.444]         if (TRUE) {
[16:05:03.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:03.444]                 open = "w")
[16:05:03.444]         }
[16:05:03.444]         else {
[16:05:03.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:03.444]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:03.444]         }
[16:05:03.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:03.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:03.444]             base::sink(type = "output", split = FALSE)
[16:05:03.444]             base::close(...future.stdout)
[16:05:03.444]         }, add = TRUE)
[16:05:03.444]     }
[16:05:03.444]     ...future.frame <- base::sys.nframe()
[16:05:03.444]     ...future.conditions <- base::list()
[16:05:03.444]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:03.444]     if (FALSE) {
[16:05:03.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:03.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:03.444]     }
[16:05:03.444]     ...future.result <- base::tryCatch({
[16:05:03.444]         base::withCallingHandlers({
[16:05:03.444]             ...future.value <- base::withVisible(base::local({
[16:05:03.444]                 ...future.makeSendCondition <- base::local({
[16:05:03.444]                   sendCondition <- NULL
[16:05:03.444]                   function(frame = 1L) {
[16:05:03.444]                     if (is.function(sendCondition)) 
[16:05:03.444]                       return(sendCondition)
[16:05:03.444]                     ns <- getNamespace("parallel")
[16:05:03.444]                     if (exists("sendData", mode = "function", 
[16:05:03.444]                       envir = ns)) {
[16:05:03.444]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:03.444]                         envir = ns)
[16:05:03.444]                       envir <- sys.frame(frame)
[16:05:03.444]                       master <- NULL
[16:05:03.444]                       while (!identical(envir, .GlobalEnv) && 
[16:05:03.444]                         !identical(envir, emptyenv())) {
[16:05:03.444]                         if (exists("master", mode = "list", envir = envir, 
[16:05:03.444]                           inherits = FALSE)) {
[16:05:03.444]                           master <- get("master", mode = "list", 
[16:05:03.444]                             envir = envir, inherits = FALSE)
[16:05:03.444]                           if (inherits(master, c("SOCKnode", 
[16:05:03.444]                             "SOCK0node"))) {
[16:05:03.444]                             sendCondition <<- function(cond) {
[16:05:03.444]                               data <- list(type = "VALUE", value = cond, 
[16:05:03.444]                                 success = TRUE)
[16:05:03.444]                               parallel_sendData(master, data)
[16:05:03.444]                             }
[16:05:03.444]                             return(sendCondition)
[16:05:03.444]                           }
[16:05:03.444]                         }
[16:05:03.444]                         frame <- frame + 1L
[16:05:03.444]                         envir <- sys.frame(frame)
[16:05:03.444]                       }
[16:05:03.444]                     }
[16:05:03.444]                     sendCondition <<- function(cond) NULL
[16:05:03.444]                   }
[16:05:03.444]                 })
[16:05:03.444]                 withCallingHandlers({
[16:05:03.444]                   {
[16:05:03.444]                     x[name] <- list(1)
[16:05:03.444]                     x
[16:05:03.444]                   }
[16:05:03.444]                 }, immediateCondition = function(cond) {
[16:05:03.444]                   sendCondition <- ...future.makeSendCondition()
[16:05:03.444]                   sendCondition(cond)
[16:05:03.444]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.444]                   {
[16:05:03.444]                     inherits <- base::inherits
[16:05:03.444]                     invokeRestart <- base::invokeRestart
[16:05:03.444]                     is.null <- base::is.null
[16:05:03.444]                     muffled <- FALSE
[16:05:03.444]                     if (inherits(cond, "message")) {
[16:05:03.444]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:03.444]                       if (muffled) 
[16:05:03.444]                         invokeRestart("muffleMessage")
[16:05:03.444]                     }
[16:05:03.444]                     else if (inherits(cond, "warning")) {
[16:05:03.444]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:03.444]                       if (muffled) 
[16:05:03.444]                         invokeRestart("muffleWarning")
[16:05:03.444]                     }
[16:05:03.444]                     else if (inherits(cond, "condition")) {
[16:05:03.444]                       if (!is.null(pattern)) {
[16:05:03.444]                         computeRestarts <- base::computeRestarts
[16:05:03.444]                         grepl <- base::grepl
[16:05:03.444]                         restarts <- computeRestarts(cond)
[16:05:03.444]                         for (restart in restarts) {
[16:05:03.444]                           name <- restart$name
[16:05:03.444]                           if (is.null(name)) 
[16:05:03.444]                             next
[16:05:03.444]                           if (!grepl(pattern, name)) 
[16:05:03.444]                             next
[16:05:03.444]                           invokeRestart(restart)
[16:05:03.444]                           muffled <- TRUE
[16:05:03.444]                           break
[16:05:03.444]                         }
[16:05:03.444]                       }
[16:05:03.444]                     }
[16:05:03.444]                     invisible(muffled)
[16:05:03.444]                   }
[16:05:03.444]                   muffleCondition(cond)
[16:05:03.444]                 })
[16:05:03.444]             }))
[16:05:03.444]             future::FutureResult(value = ...future.value$value, 
[16:05:03.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:03.444]                   ...future.rng), globalenv = if (FALSE) 
[16:05:03.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:03.444]                     ...future.globalenv.names))
[16:05:03.444]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:03.444]         }, condition = base::local({
[16:05:03.444]             c <- base::c
[16:05:03.444]             inherits <- base::inherits
[16:05:03.444]             invokeRestart <- base::invokeRestart
[16:05:03.444]             length <- base::length
[16:05:03.444]             list <- base::list
[16:05:03.444]             seq.int <- base::seq.int
[16:05:03.444]             signalCondition <- base::signalCondition
[16:05:03.444]             sys.calls <- base::sys.calls
[16:05:03.444]             `[[` <- base::`[[`
[16:05:03.444]             `+` <- base::`+`
[16:05:03.444]             `<<-` <- base::`<<-`
[16:05:03.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:03.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:03.444]                   3L)]
[16:05:03.444]             }
[16:05:03.444]             function(cond) {
[16:05:03.444]                 is_error <- inherits(cond, "error")
[16:05:03.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:03.444]                   NULL)
[16:05:03.444]                 if (is_error) {
[16:05:03.444]                   sessionInformation <- function() {
[16:05:03.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:03.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:03.444]                       search = base::search(), system = base::Sys.info())
[16:05:03.444]                   }
[16:05:03.444]                   ...future.conditions[[length(...future.conditions) + 
[16:05:03.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:03.444]                     cond$call), session = sessionInformation(), 
[16:05:03.444]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:03.444]                   signalCondition(cond)
[16:05:03.444]                 }
[16:05:03.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:03.444]                 "immediateCondition"))) {
[16:05:03.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:03.444]                   ...future.conditions[[length(...future.conditions) + 
[16:05:03.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:03.444]                   if (TRUE && !signal) {
[16:05:03.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.444]                     {
[16:05:03.444]                       inherits <- base::inherits
[16:05:03.444]                       invokeRestart <- base::invokeRestart
[16:05:03.444]                       is.null <- base::is.null
[16:05:03.444]                       muffled <- FALSE
[16:05:03.444]                       if (inherits(cond, "message")) {
[16:05:03.444]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:03.444]                         if (muffled) 
[16:05:03.444]                           invokeRestart("muffleMessage")
[16:05:03.444]                       }
[16:05:03.444]                       else if (inherits(cond, "warning")) {
[16:05:03.444]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:03.444]                         if (muffled) 
[16:05:03.444]                           invokeRestart("muffleWarning")
[16:05:03.444]                       }
[16:05:03.444]                       else if (inherits(cond, "condition")) {
[16:05:03.444]                         if (!is.null(pattern)) {
[16:05:03.444]                           computeRestarts <- base::computeRestarts
[16:05:03.444]                           grepl <- base::grepl
[16:05:03.444]                           restarts <- computeRestarts(cond)
[16:05:03.444]                           for (restart in restarts) {
[16:05:03.444]                             name <- restart$name
[16:05:03.444]                             if (is.null(name)) 
[16:05:03.444]                               next
[16:05:03.444]                             if (!grepl(pattern, name)) 
[16:05:03.444]                               next
[16:05:03.444]                             invokeRestart(restart)
[16:05:03.444]                             muffled <- TRUE
[16:05:03.444]                             break
[16:05:03.444]                           }
[16:05:03.444]                         }
[16:05:03.444]                       }
[16:05:03.444]                       invisible(muffled)
[16:05:03.444]                     }
[16:05:03.444]                     muffleCondition(cond, pattern = "^muffle")
[16:05:03.444]                   }
[16:05:03.444]                 }
[16:05:03.444]                 else {
[16:05:03.444]                   if (TRUE) {
[16:05:03.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:03.444]                     {
[16:05:03.444]                       inherits <- base::inherits
[16:05:03.444]                       invokeRestart <- base::invokeRestart
[16:05:03.444]                       is.null <- base::is.null
[16:05:03.444]                       muffled <- FALSE
[16:05:03.444]                       if (inherits(cond, "message")) {
[16:05:03.444]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:03.444]                         if (muffled) 
[16:05:03.444]                           invokeRestart("muffleMessage")
[16:05:03.444]                       }
[16:05:03.444]                       else if (inherits(cond, "warning")) {
[16:05:03.444]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:03.444]                         if (muffled) 
[16:05:03.444]                           invokeRestart("muffleWarning")
[16:05:03.444]                       }
[16:05:03.444]                       else if (inherits(cond, "condition")) {
[16:05:03.444]                         if (!is.null(pattern)) {
[16:05:03.444]                           computeRestarts <- base::computeRestarts
[16:05:03.444]                           grepl <- base::grepl
[16:05:03.444]                           restarts <- computeRestarts(cond)
[16:05:03.444]                           for (restart in restarts) {
[16:05:03.444]                             name <- restart$name
[16:05:03.444]                             if (is.null(name)) 
[16:05:03.444]                               next
[16:05:03.444]                             if (!grepl(pattern, name)) 
[16:05:03.444]                               next
[16:05:03.444]                             invokeRestart(restart)
[16:05:03.444]                             muffled <- TRUE
[16:05:03.444]                             break
[16:05:03.444]                           }
[16:05:03.444]                         }
[16:05:03.444]                       }
[16:05:03.444]                       invisible(muffled)
[16:05:03.444]                     }
[16:05:03.444]                     muffleCondition(cond, pattern = "^muffle")
[16:05:03.444]                   }
[16:05:03.444]                 }
[16:05:03.444]             }
[16:05:03.444]         }))
[16:05:03.444]     }, error = function(ex) {
[16:05:03.444]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:03.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:03.444]                 ...future.rng), started = ...future.startTime, 
[16:05:03.444]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:03.444]             version = "1.8"), class = "FutureResult")
[16:05:03.444]     }, finally = {
[16:05:03.444]         if (!identical(...future.workdir, getwd())) 
[16:05:03.444]             setwd(...future.workdir)
[16:05:03.444]         {
[16:05:03.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:03.444]                 ...future.oldOptions$nwarnings <- NULL
[16:05:03.444]             }
[16:05:03.444]             base::options(...future.oldOptions)
[16:05:03.444]             if (.Platform$OS.type == "windows") {
[16:05:03.444]                 old_names <- names(...future.oldEnvVars)
[16:05:03.444]                 envs <- base::Sys.getenv()
[16:05:03.444]                 names <- names(envs)
[16:05:03.444]                 common <- intersect(names, old_names)
[16:05:03.444]                 added <- setdiff(names, old_names)
[16:05:03.444]                 removed <- setdiff(old_names, names)
[16:05:03.444]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:03.444]                   envs[common]]
[16:05:03.444]                 NAMES <- toupper(changed)
[16:05:03.444]                 args <- list()
[16:05:03.444]                 for (kk in seq_along(NAMES)) {
[16:05:03.444]                   name <- changed[[kk]]
[16:05:03.444]                   NAME <- NAMES[[kk]]
[16:05:03.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.444]                     next
[16:05:03.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:03.444]                 }
[16:05:03.444]                 NAMES <- toupper(added)
[16:05:03.444]                 for (kk in seq_along(NAMES)) {
[16:05:03.444]                   name <- added[[kk]]
[16:05:03.444]                   NAME <- NAMES[[kk]]
[16:05:03.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.444]                     next
[16:05:03.444]                   args[[name]] <- ""
[16:05:03.444]                 }
[16:05:03.444]                 NAMES <- toupper(removed)
[16:05:03.444]                 for (kk in seq_along(NAMES)) {
[16:05:03.444]                   name <- removed[[kk]]
[16:05:03.444]                   NAME <- NAMES[[kk]]
[16:05:03.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:03.444]                     next
[16:05:03.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:03.444]                 }
[16:05:03.444]                 if (length(args) > 0) 
[16:05:03.444]                   base::do.call(base::Sys.setenv, args = args)
[16:05:03.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:03.444]             }
[16:05:03.444]             else {
[16:05:03.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:03.444]             }
[16:05:03.444]             {
[16:05:03.444]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:03.444]                   0L) {
[16:05:03.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:03.444]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:03.444]                   base::options(opts)
[16:05:03.444]                 }
[16:05:03.444]                 {
[16:05:03.444]                   {
[16:05:03.444]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:03.444]                     NULL
[16:05:03.444]                   }
[16:05:03.444]                   options(future.plan = NULL)
[16:05:03.444]                   if (is.na(NA_character_)) 
[16:05:03.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:03.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:03.444]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:03.444]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:03.444]                     envir = parent.frame()) 
[16:05:03.444]                   {
[16:05:03.444]                     if (is.function(workers)) 
[16:05:03.444]                       workers <- workers()
[16:05:03.444]                     workers <- structure(as.integer(workers), 
[16:05:03.444]                       class = class(workers))
[16:05:03.444]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:03.444]                       workers >= 1)
[16:05:03.444]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:03.444]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:03.444]                     }
[16:05:03.444]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:03.444]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:03.444]                       envir = envir)
[16:05:03.444]                     if (!future$lazy) 
[16:05:03.444]                       future <- run(future)
[16:05:03.444]                     invisible(future)
[16:05:03.444]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:03.444]                 }
[16:05:03.444]             }
[16:05:03.444]         }
[16:05:03.444]     })
[16:05:03.444]     if (TRUE) {
[16:05:03.444]         base::sink(type = "output", split = FALSE)
[16:05:03.444]         if (TRUE) {
[16:05:03.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:03.444]         }
[16:05:03.444]         else {
[16:05:03.444]             ...future.result["stdout"] <- base::list(NULL)
[16:05:03.444]         }
[16:05:03.444]         base::close(...future.stdout)
[16:05:03.444]         ...future.stdout <- NULL
[16:05:03.444]     }
[16:05:03.444]     ...future.result$conditions <- ...future.conditions
[16:05:03.444]     ...future.result$finished <- base::Sys.time()
[16:05:03.444]     ...future.result
[16:05:03.444] }
[16:05:03.447] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:05:03.447] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:05:03.449] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:05:03.449] Exporting ‘name’ (112 bytes) to cluster node #1 ...
[16:05:03.449] Exporting ‘name’ (112 bytes) to cluster node #1 ... DONE
[16:05:03.450] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:05:03.450] MultisessionFuture started
[16:05:03.450] - Launch lazy future ... done
[16:05:03.450] run() for ‘MultisessionFuture’ ... done
[16:05:03.451] result() for ClusterFuture ...
[16:05:03.451] receiveMessageFromWorker() for ClusterFuture ...
[16:05:03.451] - Validating connection of MultisessionFuture
[16:05:03.496] - received message: FutureResult
[16:05:03.496] - Received FutureResult
[16:05:03.496] - Erased future from FutureRegistry
[16:05:03.496] result() for ClusterFuture ...
[16:05:03.496] - result already collected: FutureResult
[16:05:03.496] result() for ClusterFuture ... done
[16:05:03.496] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:03.496] result() for ClusterFuture ... done
[16:05:03.496] result() for ClusterFuture ...
[16:05:03.497] - result already collected: FutureResult
[16:05:03.497] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[16:05:03.497] plan(): Setting new future strategy stack:
[16:05:03.498] List of future strategies:
[16:05:03.498] 1. FutureStrategy:
[16:05:03.498]    - args: function (..., envir = parent.frame())
[16:05:03.498]    - tweaked: FALSE
[16:05:03.498]    - call: future::plan(oplan)
[16:05:03.498] plan(): nbrOfWorkers() = 1
> 
