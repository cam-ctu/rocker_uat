
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:26:06.202] plan(): Setting new future strategy stack:
[10:26:06.203] List of future strategies:
[10:26:06.203] 1. sequential:
[10:26:06.203]    - args: function (..., envir = parent.frame())
[10:26:06.203]    - tweaked: FALSE
[10:26:06.203]    - call: future::plan("sequential")
[10:26:06.216] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[10:26:06.282] plan(): Setting new future strategy stack:
[10:26:06.282] List of future strategies:
[10:26:06.282] 1. sequential:
[10:26:06.282]    - args: function (..., envir = parent.frame())
[10:26:06.282]    - tweaked: FALSE
[10:26:06.282]    - call: plan(strategy)
[10:26:06.292] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.293] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.293] Searching for globals...
[10:26:06.301] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.301] Searching for globals ... DONE
[10:26:06.301] Resolving globals: TRUE
[10:26:06.301] Resolving any globals that are futures ...
[10:26:06.301] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.301] Resolving any globals that are futures ... DONE
[10:26:06.302] Resolving futures part of globals (recursively) ...
[10:26:06.303] resolve() on list ...
[10:26:06.303]  recursive: 99
[10:26:06.303]  length: 1
[10:26:06.303]  elements: ‘x’
[10:26:06.303]  length: 0 (resolved future 1)
[10:26:06.303] resolve() on list ... DONE
[10:26:06.303] - globals: [1] ‘x’
[10:26:06.304] Resolving futures part of globals (recursively) ... DONE
[10:26:06.304] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.304] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.305] - globals: [1] ‘x’
[10:26:06.305] 
[10:26:06.305] getGlobalsAndPackages() ... DONE
[10:26:06.305] run() for ‘Future’ ...
[10:26:06.306] - state: ‘created’
[10:26:06.306] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:06.306] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:06.306] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:06.306]   - Field: ‘label’
[10:26:06.306]   - Field: ‘local’
[10:26:06.307]   - Field: ‘owner’
[10:26:06.307]   - Field: ‘envir’
[10:26:06.307]   - Field: ‘packages’
[10:26:06.307]   - Field: ‘gc’
[10:26:06.307]   - Field: ‘conditions’
[10:26:06.307]   - Field: ‘expr’
[10:26:06.307]   - Field: ‘uuid’
[10:26:06.307]   - Field: ‘seed’
[10:26:06.307]   - Field: ‘version’
[10:26:06.307]   - Field: ‘result’
[10:26:06.307]   - Field: ‘asynchronous’
[10:26:06.308]   - Field: ‘calls’
[10:26:06.308]   - Field: ‘globals’
[10:26:06.308]   - Field: ‘stdout’
[10:26:06.308]   - Field: ‘earlySignal’
[10:26:06.308]   - Field: ‘lazy’
[10:26:06.308]   - Field: ‘state’
[10:26:06.308] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:06.308] - Launch lazy future ...
[10:26:06.310] Packages needed by the future expression (n = 0): <none>
[10:26:06.311] Packages needed by future strategies (n = 0): <none>
[10:26:06.311] {
[10:26:06.311]     {
[10:26:06.311]         {
[10:26:06.311]             ...future.startTime <- base::Sys.time()
[10:26:06.311]             {
[10:26:06.311]                 {
[10:26:06.311]                   {
[10:26:06.311]                     base::local({
[10:26:06.311]                       has_future <- base::requireNamespace("future", 
[10:26:06.311]                         quietly = TRUE)
[10:26:06.311]                       if (has_future) {
[10:26:06.311]                         ns <- base::getNamespace("future")
[10:26:06.311]                         version <- ns[[".package"]][["version"]]
[10:26:06.311]                         if (is.null(version)) 
[10:26:06.311]                           version <- utils::packageVersion("future")
[10:26:06.311]                       }
[10:26:06.311]                       else {
[10:26:06.311]                         version <- NULL
[10:26:06.311]                       }
[10:26:06.311]                       if (!has_future || version < "1.8.0") {
[10:26:06.311]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.311]                           "", base::R.version$version.string), 
[10:26:06.311]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:06.311]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.311]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.311]                             "release", "version")], collapse = " "), 
[10:26:06.311]                           hostname = base::Sys.info()[["nodename"]])
[10:26:06.311]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.311]                           info)
[10:26:06.311]                         info <- base::paste(info, collapse = "; ")
[10:26:06.311]                         if (!has_future) {
[10:26:06.311]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.311]                             info)
[10:26:06.311]                         }
[10:26:06.311]                         else {
[10:26:06.311]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.311]                             info, version)
[10:26:06.311]                         }
[10:26:06.311]                         base::stop(msg)
[10:26:06.311]                       }
[10:26:06.311]                     })
[10:26:06.311]                   }
[10:26:06.311]                   options(future.plan = NULL)
[10:26:06.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.311]                 }
[10:26:06.311]                 ...future.workdir <- getwd()
[10:26:06.311]             }
[10:26:06.311]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.311]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.311]         }
[10:26:06.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.311]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.311]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.311]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.311]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.311]             base::names(...future.oldOptions))
[10:26:06.311]     }
[10:26:06.311]     if (FALSE) {
[10:26:06.311]     }
[10:26:06.311]     else {
[10:26:06.311]         if (TRUE) {
[10:26:06.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.311]                 open = "w")
[10:26:06.311]         }
[10:26:06.311]         else {
[10:26:06.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.311]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.311]         }
[10:26:06.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.311]             base::sink(type = "output", split = FALSE)
[10:26:06.311]             base::close(...future.stdout)
[10:26:06.311]         }, add = TRUE)
[10:26:06.311]     }
[10:26:06.311]     ...future.frame <- base::sys.nframe()
[10:26:06.311]     ...future.conditions <- base::list()
[10:26:06.311]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.311]     if (FALSE) {
[10:26:06.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.311]     }
[10:26:06.311]     ...future.result <- base::tryCatch({
[10:26:06.311]         base::withCallingHandlers({
[10:26:06.311]             ...future.value <- base::withVisible(base::local({
[10:26:06.311]                 x$a <- 1
[10:26:06.311]                 x
[10:26:06.311]             }))
[10:26:06.311]             future::FutureResult(value = ...future.value$value, 
[10:26:06.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.311]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.311]                     ...future.globalenv.names))
[10:26:06.311]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.311]         }, condition = base::local({
[10:26:06.311]             c <- base::c
[10:26:06.311]             inherits <- base::inherits
[10:26:06.311]             invokeRestart <- base::invokeRestart
[10:26:06.311]             length <- base::length
[10:26:06.311]             list <- base::list
[10:26:06.311]             seq.int <- base::seq.int
[10:26:06.311]             signalCondition <- base::signalCondition
[10:26:06.311]             sys.calls <- base::sys.calls
[10:26:06.311]             `[[` <- base::`[[`
[10:26:06.311]             `+` <- base::`+`
[10:26:06.311]             `<<-` <- base::`<<-`
[10:26:06.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.311]                   3L)]
[10:26:06.311]             }
[10:26:06.311]             function(cond) {
[10:26:06.311]                 is_error <- inherits(cond, "error")
[10:26:06.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.311]                   NULL)
[10:26:06.311]                 if (is_error) {
[10:26:06.311]                   sessionInformation <- function() {
[10:26:06.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.311]                       search = base::search(), system = base::Sys.info())
[10:26:06.311]                   }
[10:26:06.311]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.311]                     cond$call), session = sessionInformation(), 
[10:26:06.311]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.311]                   signalCondition(cond)
[10:26:06.311]                 }
[10:26:06.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.311]                 "immediateCondition"))) {
[10:26:06.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.311]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.311]                   if (TRUE && !signal) {
[10:26:06.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.311]                     {
[10:26:06.311]                       inherits <- base::inherits
[10:26:06.311]                       invokeRestart <- base::invokeRestart
[10:26:06.311]                       is.null <- base::is.null
[10:26:06.311]                       muffled <- FALSE
[10:26:06.311]                       if (inherits(cond, "message")) {
[10:26:06.311]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.311]                         if (muffled) 
[10:26:06.311]                           invokeRestart("muffleMessage")
[10:26:06.311]                       }
[10:26:06.311]                       else if (inherits(cond, "warning")) {
[10:26:06.311]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.311]                         if (muffled) 
[10:26:06.311]                           invokeRestart("muffleWarning")
[10:26:06.311]                       }
[10:26:06.311]                       else if (inherits(cond, "condition")) {
[10:26:06.311]                         if (!is.null(pattern)) {
[10:26:06.311]                           computeRestarts <- base::computeRestarts
[10:26:06.311]                           grepl <- base::grepl
[10:26:06.311]                           restarts <- computeRestarts(cond)
[10:26:06.311]                           for (restart in restarts) {
[10:26:06.311]                             name <- restart$name
[10:26:06.311]                             if (is.null(name)) 
[10:26:06.311]                               next
[10:26:06.311]                             if (!grepl(pattern, name)) 
[10:26:06.311]                               next
[10:26:06.311]                             invokeRestart(restart)
[10:26:06.311]                             muffled <- TRUE
[10:26:06.311]                             break
[10:26:06.311]                           }
[10:26:06.311]                         }
[10:26:06.311]                       }
[10:26:06.311]                       invisible(muffled)
[10:26:06.311]                     }
[10:26:06.311]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.311]                   }
[10:26:06.311]                 }
[10:26:06.311]                 else {
[10:26:06.311]                   if (TRUE) {
[10:26:06.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.311]                     {
[10:26:06.311]                       inherits <- base::inherits
[10:26:06.311]                       invokeRestart <- base::invokeRestart
[10:26:06.311]                       is.null <- base::is.null
[10:26:06.311]                       muffled <- FALSE
[10:26:06.311]                       if (inherits(cond, "message")) {
[10:26:06.311]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.311]                         if (muffled) 
[10:26:06.311]                           invokeRestart("muffleMessage")
[10:26:06.311]                       }
[10:26:06.311]                       else if (inherits(cond, "warning")) {
[10:26:06.311]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.311]                         if (muffled) 
[10:26:06.311]                           invokeRestart("muffleWarning")
[10:26:06.311]                       }
[10:26:06.311]                       else if (inherits(cond, "condition")) {
[10:26:06.311]                         if (!is.null(pattern)) {
[10:26:06.311]                           computeRestarts <- base::computeRestarts
[10:26:06.311]                           grepl <- base::grepl
[10:26:06.311]                           restarts <- computeRestarts(cond)
[10:26:06.311]                           for (restart in restarts) {
[10:26:06.311]                             name <- restart$name
[10:26:06.311]                             if (is.null(name)) 
[10:26:06.311]                               next
[10:26:06.311]                             if (!grepl(pattern, name)) 
[10:26:06.311]                               next
[10:26:06.311]                             invokeRestart(restart)
[10:26:06.311]                             muffled <- TRUE
[10:26:06.311]                             break
[10:26:06.311]                           }
[10:26:06.311]                         }
[10:26:06.311]                       }
[10:26:06.311]                       invisible(muffled)
[10:26:06.311]                     }
[10:26:06.311]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.311]                   }
[10:26:06.311]                 }
[10:26:06.311]             }
[10:26:06.311]         }))
[10:26:06.311]     }, error = function(ex) {
[10:26:06.311]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.311]                 ...future.rng), started = ...future.startTime, 
[10:26:06.311]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.311]             version = "1.8"), class = "FutureResult")
[10:26:06.311]     }, finally = {
[10:26:06.311]         if (!identical(...future.workdir, getwd())) 
[10:26:06.311]             setwd(...future.workdir)
[10:26:06.311]         {
[10:26:06.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.311]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.311]             }
[10:26:06.311]             base::options(...future.oldOptions)
[10:26:06.311]             if (.Platform$OS.type == "windows") {
[10:26:06.311]                 old_names <- names(...future.oldEnvVars)
[10:26:06.311]                 envs <- base::Sys.getenv()
[10:26:06.311]                 names <- names(envs)
[10:26:06.311]                 common <- intersect(names, old_names)
[10:26:06.311]                 added <- setdiff(names, old_names)
[10:26:06.311]                 removed <- setdiff(old_names, names)
[10:26:06.311]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.311]                   envs[common]]
[10:26:06.311]                 NAMES <- toupper(changed)
[10:26:06.311]                 args <- list()
[10:26:06.311]                 for (kk in seq_along(NAMES)) {
[10:26:06.311]                   name <- changed[[kk]]
[10:26:06.311]                   NAME <- NAMES[[kk]]
[10:26:06.311]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.311]                     next
[10:26:06.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.311]                 }
[10:26:06.311]                 NAMES <- toupper(added)
[10:26:06.311]                 for (kk in seq_along(NAMES)) {
[10:26:06.311]                   name <- added[[kk]]
[10:26:06.311]                   NAME <- NAMES[[kk]]
[10:26:06.311]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.311]                     next
[10:26:06.311]                   args[[name]] <- ""
[10:26:06.311]                 }
[10:26:06.311]                 NAMES <- toupper(removed)
[10:26:06.311]                 for (kk in seq_along(NAMES)) {
[10:26:06.311]                   name <- removed[[kk]]
[10:26:06.311]                   NAME <- NAMES[[kk]]
[10:26:06.311]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.311]                     next
[10:26:06.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.311]                 }
[10:26:06.311]                 if (length(args) > 0) 
[10:26:06.311]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.311]             }
[10:26:06.311]             else {
[10:26:06.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.311]             }
[10:26:06.311]             {
[10:26:06.311]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.311]                   0L) {
[10:26:06.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.311]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.311]                   base::options(opts)
[10:26:06.311]                 }
[10:26:06.311]                 {
[10:26:06.311]                   {
[10:26:06.311]                     NULL
[10:26:06.311]                     RNGkind("Mersenne-Twister")
[10:26:06.311]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:06.311]                       inherits = FALSE)
[10:26:06.311]                   }
[10:26:06.311]                   options(future.plan = NULL)
[10:26:06.311]                   if (is.na(NA_character_)) 
[10:26:06.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.311]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:06.311]                   {
[10:26:06.311]                     future <- SequentialFuture(..., envir = envir)
[10:26:06.311]                     if (!future$lazy) 
[10:26:06.311]                       future <- run(future)
[10:26:06.311]                     invisible(future)
[10:26:06.311]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.311]                 }
[10:26:06.311]             }
[10:26:06.311]         }
[10:26:06.311]     })
[10:26:06.311]     if (TRUE) {
[10:26:06.311]         base::sink(type = "output", split = FALSE)
[10:26:06.311]         if (TRUE) {
[10:26:06.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.311]         }
[10:26:06.311]         else {
[10:26:06.311]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.311]         }
[10:26:06.311]         base::close(...future.stdout)
[10:26:06.311]         ...future.stdout <- NULL
[10:26:06.311]     }
[10:26:06.311]     ...future.result$conditions <- ...future.conditions
[10:26:06.311]     ...future.result$finished <- base::Sys.time()
[10:26:06.311]     ...future.result
[10:26:06.311] }
[10:26:06.313] assign_globals() ...
[10:26:06.313] List of 1
[10:26:06.313]  $ x: list()
[10:26:06.313]  - attr(*, "where")=List of 1
[10:26:06.313]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.313]  - attr(*, "resolved")= logi TRUE
[10:26:06.313]  - attr(*, "total_size")= num 0
[10:26:06.313]  - attr(*, "already-done")= logi TRUE
[10:26:06.317] - copied ‘x’ to environment
[10:26:06.317] assign_globals() ... done
[10:26:06.317] plan(): Setting new future strategy stack:
[10:26:06.317] List of future strategies:
[10:26:06.317] 1. sequential:
[10:26:06.317]    - args: function (..., envir = parent.frame())
[10:26:06.317]    - tweaked: FALSE
[10:26:06.317]    - call: NULL
[10:26:06.318] plan(): nbrOfWorkers() = 1
[10:26:06.319] plan(): Setting new future strategy stack:
[10:26:06.319] List of future strategies:
[10:26:06.319] 1. sequential:
[10:26:06.319]    - args: function (..., envir = parent.frame())
[10:26:06.319]    - tweaked: FALSE
[10:26:06.319]    - call: plan(strategy)
[10:26:06.319] plan(): nbrOfWorkers() = 1
[10:26:06.319] SequentialFuture started (and completed)
[10:26:06.320] - Launch lazy future ... done
[10:26:06.320] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.320] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.321] Searching for globals...
[10:26:06.322] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.323] Searching for globals ... DONE
[10:26:06.323] Resolving globals: TRUE
[10:26:06.323] Resolving any globals that are futures ...
[10:26:06.323] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.323] Resolving any globals that are futures ... DONE
[10:26:06.323] Resolving futures part of globals (recursively) ...
[10:26:06.323] resolve() on list ...
[10:26:06.324]  recursive: 99
[10:26:06.324]  length: 1
[10:26:06.324]  elements: ‘x’
[10:26:06.324]  length: 0 (resolved future 1)
[10:26:06.324] resolve() on list ... DONE
[10:26:06.324] - globals: [1] ‘x’
[10:26:06.324] Resolving futures part of globals (recursively) ... DONE
[10:26:06.324] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.325] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.325] - globals: [1] ‘x’
[10:26:06.325] 
[10:26:06.325] getGlobalsAndPackages() ... DONE
[10:26:06.325] run() for ‘Future’ ...
[10:26:06.325] - state: ‘created’
[10:26:06.325] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:06.326] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:06.326] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:06.326]   - Field: ‘label’
[10:26:06.326]   - Field: ‘local’
[10:26:06.326]   - Field: ‘owner’
[10:26:06.326]   - Field: ‘envir’
[10:26:06.326]   - Field: ‘packages’
[10:26:06.326]   - Field: ‘gc’
[10:26:06.326]   - Field: ‘conditions’
[10:26:06.326]   - Field: ‘expr’
[10:26:06.327]   - Field: ‘uuid’
[10:26:06.327]   - Field: ‘seed’
[10:26:06.327]   - Field: ‘version’
[10:26:06.327]   - Field: ‘result’
[10:26:06.327]   - Field: ‘asynchronous’
[10:26:06.327]   - Field: ‘calls’
[10:26:06.327]   - Field: ‘globals’
[10:26:06.327]   - Field: ‘stdout’
[10:26:06.327]   - Field: ‘earlySignal’
[10:26:06.327]   - Field: ‘lazy’
[10:26:06.327]   - Field: ‘state’
[10:26:06.327] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:06.328] - Launch lazy future ...
[10:26:06.328] Packages needed by the future expression (n = 0): <none>
[10:26:06.328] Packages needed by future strategies (n = 0): <none>
[10:26:06.328] {
[10:26:06.328]     {
[10:26:06.328]         {
[10:26:06.328]             ...future.startTime <- base::Sys.time()
[10:26:06.328]             {
[10:26:06.328]                 {
[10:26:06.328]                   {
[10:26:06.328]                     base::local({
[10:26:06.328]                       has_future <- base::requireNamespace("future", 
[10:26:06.328]                         quietly = TRUE)
[10:26:06.328]                       if (has_future) {
[10:26:06.328]                         ns <- base::getNamespace("future")
[10:26:06.328]                         version <- ns[[".package"]][["version"]]
[10:26:06.328]                         if (is.null(version)) 
[10:26:06.328]                           version <- utils::packageVersion("future")
[10:26:06.328]                       }
[10:26:06.328]                       else {
[10:26:06.328]                         version <- NULL
[10:26:06.328]                       }
[10:26:06.328]                       if (!has_future || version < "1.8.0") {
[10:26:06.328]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.328]                           "", base::R.version$version.string), 
[10:26:06.328]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:06.328]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.328]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.328]                             "release", "version")], collapse = " "), 
[10:26:06.328]                           hostname = base::Sys.info()[["nodename"]])
[10:26:06.328]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.328]                           info)
[10:26:06.328]                         info <- base::paste(info, collapse = "; ")
[10:26:06.328]                         if (!has_future) {
[10:26:06.328]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.328]                             info)
[10:26:06.328]                         }
[10:26:06.328]                         else {
[10:26:06.328]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.328]                             info, version)
[10:26:06.328]                         }
[10:26:06.328]                         base::stop(msg)
[10:26:06.328]                       }
[10:26:06.328]                     })
[10:26:06.328]                   }
[10:26:06.328]                   options(future.plan = NULL)
[10:26:06.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.328]                 }
[10:26:06.328]                 ...future.workdir <- getwd()
[10:26:06.328]             }
[10:26:06.328]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.328]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.328]         }
[10:26:06.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.328]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.328]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.328]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.328]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.328]             base::names(...future.oldOptions))
[10:26:06.328]     }
[10:26:06.328]     if (FALSE) {
[10:26:06.328]     }
[10:26:06.328]     else {
[10:26:06.328]         if (TRUE) {
[10:26:06.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.328]                 open = "w")
[10:26:06.328]         }
[10:26:06.328]         else {
[10:26:06.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.328]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.328]         }
[10:26:06.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.328]             base::sink(type = "output", split = FALSE)
[10:26:06.328]             base::close(...future.stdout)
[10:26:06.328]         }, add = TRUE)
[10:26:06.328]     }
[10:26:06.328]     ...future.frame <- base::sys.nframe()
[10:26:06.328]     ...future.conditions <- base::list()
[10:26:06.328]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.328]     if (FALSE) {
[10:26:06.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.328]     }
[10:26:06.328]     ...future.result <- base::tryCatch({
[10:26:06.328]         base::withCallingHandlers({
[10:26:06.328]             ...future.value <- base::withVisible(base::local({
[10:26:06.328]                 x$a <- 1
[10:26:06.328]                 x
[10:26:06.328]             }))
[10:26:06.328]             future::FutureResult(value = ...future.value$value, 
[10:26:06.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.328]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.328]                     ...future.globalenv.names))
[10:26:06.328]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.328]         }, condition = base::local({
[10:26:06.328]             c <- base::c
[10:26:06.328]             inherits <- base::inherits
[10:26:06.328]             invokeRestart <- base::invokeRestart
[10:26:06.328]             length <- base::length
[10:26:06.328]             list <- base::list
[10:26:06.328]             seq.int <- base::seq.int
[10:26:06.328]             signalCondition <- base::signalCondition
[10:26:06.328]             sys.calls <- base::sys.calls
[10:26:06.328]             `[[` <- base::`[[`
[10:26:06.328]             `+` <- base::`+`
[10:26:06.328]             `<<-` <- base::`<<-`
[10:26:06.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.328]                   3L)]
[10:26:06.328]             }
[10:26:06.328]             function(cond) {
[10:26:06.328]                 is_error <- inherits(cond, "error")
[10:26:06.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.328]                   NULL)
[10:26:06.328]                 if (is_error) {
[10:26:06.328]                   sessionInformation <- function() {
[10:26:06.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.328]                       search = base::search(), system = base::Sys.info())
[10:26:06.328]                   }
[10:26:06.328]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.328]                     cond$call), session = sessionInformation(), 
[10:26:06.328]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.328]                   signalCondition(cond)
[10:26:06.328]                 }
[10:26:06.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.328]                 "immediateCondition"))) {
[10:26:06.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.328]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.328]                   if (TRUE && !signal) {
[10:26:06.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.328]                     {
[10:26:06.328]                       inherits <- base::inherits
[10:26:06.328]                       invokeRestart <- base::invokeRestart
[10:26:06.328]                       is.null <- base::is.null
[10:26:06.328]                       muffled <- FALSE
[10:26:06.328]                       if (inherits(cond, "message")) {
[10:26:06.328]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.328]                         if (muffled) 
[10:26:06.328]                           invokeRestart("muffleMessage")
[10:26:06.328]                       }
[10:26:06.328]                       else if (inherits(cond, "warning")) {
[10:26:06.328]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.328]                         if (muffled) 
[10:26:06.328]                           invokeRestart("muffleWarning")
[10:26:06.328]                       }
[10:26:06.328]                       else if (inherits(cond, "condition")) {
[10:26:06.328]                         if (!is.null(pattern)) {
[10:26:06.328]                           computeRestarts <- base::computeRestarts
[10:26:06.328]                           grepl <- base::grepl
[10:26:06.328]                           restarts <- computeRestarts(cond)
[10:26:06.328]                           for (restart in restarts) {
[10:26:06.328]                             name <- restart$name
[10:26:06.328]                             if (is.null(name)) 
[10:26:06.328]                               next
[10:26:06.328]                             if (!grepl(pattern, name)) 
[10:26:06.328]                               next
[10:26:06.328]                             invokeRestart(restart)
[10:26:06.328]                             muffled <- TRUE
[10:26:06.328]                             break
[10:26:06.328]                           }
[10:26:06.328]                         }
[10:26:06.328]                       }
[10:26:06.328]                       invisible(muffled)
[10:26:06.328]                     }
[10:26:06.328]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.328]                   }
[10:26:06.328]                 }
[10:26:06.328]                 else {
[10:26:06.328]                   if (TRUE) {
[10:26:06.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.328]                     {
[10:26:06.328]                       inherits <- base::inherits
[10:26:06.328]                       invokeRestart <- base::invokeRestart
[10:26:06.328]                       is.null <- base::is.null
[10:26:06.328]                       muffled <- FALSE
[10:26:06.328]                       if (inherits(cond, "message")) {
[10:26:06.328]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.328]                         if (muffled) 
[10:26:06.328]                           invokeRestart("muffleMessage")
[10:26:06.328]                       }
[10:26:06.328]                       else if (inherits(cond, "warning")) {
[10:26:06.328]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.328]                         if (muffled) 
[10:26:06.328]                           invokeRestart("muffleWarning")
[10:26:06.328]                       }
[10:26:06.328]                       else if (inherits(cond, "condition")) {
[10:26:06.328]                         if (!is.null(pattern)) {
[10:26:06.328]                           computeRestarts <- base::computeRestarts
[10:26:06.328]                           grepl <- base::grepl
[10:26:06.328]                           restarts <- computeRestarts(cond)
[10:26:06.328]                           for (restart in restarts) {
[10:26:06.328]                             name <- restart$name
[10:26:06.328]                             if (is.null(name)) 
[10:26:06.328]                               next
[10:26:06.328]                             if (!grepl(pattern, name)) 
[10:26:06.328]                               next
[10:26:06.328]                             invokeRestart(restart)
[10:26:06.328]                             muffled <- TRUE
[10:26:06.328]                             break
[10:26:06.328]                           }
[10:26:06.328]                         }
[10:26:06.328]                       }
[10:26:06.328]                       invisible(muffled)
[10:26:06.328]                     }
[10:26:06.328]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.328]                   }
[10:26:06.328]                 }
[10:26:06.328]             }
[10:26:06.328]         }))
[10:26:06.328]     }, error = function(ex) {
[10:26:06.328]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.328]                 ...future.rng), started = ...future.startTime, 
[10:26:06.328]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.328]             version = "1.8"), class = "FutureResult")
[10:26:06.328]     }, finally = {
[10:26:06.328]         if (!identical(...future.workdir, getwd())) 
[10:26:06.328]             setwd(...future.workdir)
[10:26:06.328]         {
[10:26:06.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.328]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.328]             }
[10:26:06.328]             base::options(...future.oldOptions)
[10:26:06.328]             if (.Platform$OS.type == "windows") {
[10:26:06.328]                 old_names <- names(...future.oldEnvVars)
[10:26:06.328]                 envs <- base::Sys.getenv()
[10:26:06.328]                 names <- names(envs)
[10:26:06.328]                 common <- intersect(names, old_names)
[10:26:06.328]                 added <- setdiff(names, old_names)
[10:26:06.328]                 removed <- setdiff(old_names, names)
[10:26:06.328]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.328]                   envs[common]]
[10:26:06.328]                 NAMES <- toupper(changed)
[10:26:06.328]                 args <- list()
[10:26:06.328]                 for (kk in seq_along(NAMES)) {
[10:26:06.328]                   name <- changed[[kk]]
[10:26:06.328]                   NAME <- NAMES[[kk]]
[10:26:06.328]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.328]                     next
[10:26:06.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.328]                 }
[10:26:06.328]                 NAMES <- toupper(added)
[10:26:06.328]                 for (kk in seq_along(NAMES)) {
[10:26:06.328]                   name <- added[[kk]]
[10:26:06.328]                   NAME <- NAMES[[kk]]
[10:26:06.328]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.328]                     next
[10:26:06.328]                   args[[name]] <- ""
[10:26:06.328]                 }
[10:26:06.328]                 NAMES <- toupper(removed)
[10:26:06.328]                 for (kk in seq_along(NAMES)) {
[10:26:06.328]                   name <- removed[[kk]]
[10:26:06.328]                   NAME <- NAMES[[kk]]
[10:26:06.328]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.328]                     next
[10:26:06.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.328]                 }
[10:26:06.328]                 if (length(args) > 0) 
[10:26:06.328]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.328]             }
[10:26:06.328]             else {
[10:26:06.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.328]             }
[10:26:06.328]             {
[10:26:06.328]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.328]                   0L) {
[10:26:06.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.328]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.328]                   base::options(opts)
[10:26:06.328]                 }
[10:26:06.328]                 {
[10:26:06.328]                   {
[10:26:06.328]                     NULL
[10:26:06.328]                     RNGkind("Mersenne-Twister")
[10:26:06.328]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:06.328]                       inherits = FALSE)
[10:26:06.328]                   }
[10:26:06.328]                   options(future.plan = NULL)
[10:26:06.328]                   if (is.na(NA_character_)) 
[10:26:06.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.328]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:06.328]                   {
[10:26:06.328]                     future <- SequentialFuture(..., envir = envir)
[10:26:06.328]                     if (!future$lazy) 
[10:26:06.328]                       future <- run(future)
[10:26:06.328]                     invisible(future)
[10:26:06.328]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.328]                 }
[10:26:06.328]             }
[10:26:06.328]         }
[10:26:06.328]     })
[10:26:06.328]     if (TRUE) {
[10:26:06.328]         base::sink(type = "output", split = FALSE)
[10:26:06.328]         if (TRUE) {
[10:26:06.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.328]         }
[10:26:06.328]         else {
[10:26:06.328]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.328]         }
[10:26:06.328]         base::close(...future.stdout)
[10:26:06.328]         ...future.stdout <- NULL
[10:26:06.328]     }
[10:26:06.328]     ...future.result$conditions <- ...future.conditions
[10:26:06.328]     ...future.result$finished <- base::Sys.time()
[10:26:06.328]     ...future.result
[10:26:06.328] }
[10:26:06.330] assign_globals() ...
[10:26:06.330] List of 1
[10:26:06.330]  $ x: list()
[10:26:06.330]  - attr(*, "where")=List of 1
[10:26:06.330]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.330]  - attr(*, "resolved")= logi TRUE
[10:26:06.330]  - attr(*, "total_size")= num 0
[10:26:06.330]  - attr(*, "already-done")= logi TRUE
[10:26:06.332] - copied ‘x’ to environment
[10:26:06.332] assign_globals() ... done
[10:26:06.332] plan(): Setting new future strategy stack:
[10:26:06.333] List of future strategies:
[10:26:06.333] 1. sequential:
[10:26:06.333]    - args: function (..., envir = parent.frame())
[10:26:06.333]    - tweaked: FALSE
[10:26:06.333]    - call: NULL
[10:26:06.333] plan(): nbrOfWorkers() = 1
[10:26:06.334] plan(): Setting new future strategy stack:
[10:26:06.334] List of future strategies:
[10:26:06.334] 1. sequential:
[10:26:06.334]    - args: function (..., envir = parent.frame())
[10:26:06.334]    - tweaked: FALSE
[10:26:06.334]    - call: plan(strategy)
[10:26:06.334] plan(): nbrOfWorkers() = 1
[10:26:06.334] SequentialFuture started (and completed)
[10:26:06.334] - Launch lazy future ... done
[10:26:06.334] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.336] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.336] Searching for globals...
[10:26:06.338] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.338] Searching for globals ... DONE
[10:26:06.338] Resolving globals: TRUE
[10:26:06.338] Resolving any globals that are futures ...
[10:26:06.338] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.338] Resolving any globals that are futures ... DONE
[10:26:06.338] Resolving futures part of globals (recursively) ...
[10:26:06.339] resolve() on list ...
[10:26:06.339]  recursive: 99
[10:26:06.339]  length: 1
[10:26:06.339]  elements: ‘x’
[10:26:06.339]  length: 0 (resolved future 1)
[10:26:06.339] resolve() on list ... DONE
[10:26:06.339] - globals: [1] ‘x’
[10:26:06.339] Resolving futures part of globals (recursively) ... DONE
[10:26:06.339] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.340] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.341] - globals: [1] ‘x’
[10:26:06.341] 
[10:26:06.341] getGlobalsAndPackages() ... DONE
[10:26:06.341] run() for ‘Future’ ...
[10:26:06.342] - state: ‘created’
[10:26:06.342] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:06.342] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:06.342] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:06.342]   - Field: ‘label’
[10:26:06.342]   - Field: ‘local’
[10:26:06.342]   - Field: ‘owner’
[10:26:06.342]   - Field: ‘envir’
[10:26:06.343]   - Field: ‘packages’
[10:26:06.343]   - Field: ‘gc’
[10:26:06.343]   - Field: ‘conditions’
[10:26:06.343]   - Field: ‘expr’
[10:26:06.343]   - Field: ‘uuid’
[10:26:06.343]   - Field: ‘seed’
[10:26:06.343]   - Field: ‘version’
[10:26:06.343]   - Field: ‘result’
[10:26:06.343]   - Field: ‘asynchronous’
[10:26:06.343]   - Field: ‘calls’
[10:26:06.343]   - Field: ‘globals’
[10:26:06.344]   - Field: ‘stdout’
[10:26:06.344]   - Field: ‘earlySignal’
[10:26:06.344]   - Field: ‘lazy’
[10:26:06.344]   - Field: ‘state’
[10:26:06.344] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:06.344] - Launch lazy future ...
[10:26:06.344] Packages needed by the future expression (n = 0): <none>
[10:26:06.344] Packages needed by future strategies (n = 0): <none>
[10:26:06.345] {
[10:26:06.345]     {
[10:26:06.345]         {
[10:26:06.345]             ...future.startTime <- base::Sys.time()
[10:26:06.345]             {
[10:26:06.345]                 {
[10:26:06.345]                   {
[10:26:06.345]                     base::local({
[10:26:06.345]                       has_future <- base::requireNamespace("future", 
[10:26:06.345]                         quietly = TRUE)
[10:26:06.345]                       if (has_future) {
[10:26:06.345]                         ns <- base::getNamespace("future")
[10:26:06.345]                         version <- ns[[".package"]][["version"]]
[10:26:06.345]                         if (is.null(version)) 
[10:26:06.345]                           version <- utils::packageVersion("future")
[10:26:06.345]                       }
[10:26:06.345]                       else {
[10:26:06.345]                         version <- NULL
[10:26:06.345]                       }
[10:26:06.345]                       if (!has_future || version < "1.8.0") {
[10:26:06.345]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.345]                           "", base::R.version$version.string), 
[10:26:06.345]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:06.345]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.345]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.345]                             "release", "version")], collapse = " "), 
[10:26:06.345]                           hostname = base::Sys.info()[["nodename"]])
[10:26:06.345]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.345]                           info)
[10:26:06.345]                         info <- base::paste(info, collapse = "; ")
[10:26:06.345]                         if (!has_future) {
[10:26:06.345]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.345]                             info)
[10:26:06.345]                         }
[10:26:06.345]                         else {
[10:26:06.345]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.345]                             info, version)
[10:26:06.345]                         }
[10:26:06.345]                         base::stop(msg)
[10:26:06.345]                       }
[10:26:06.345]                     })
[10:26:06.345]                   }
[10:26:06.345]                   options(future.plan = NULL)
[10:26:06.345]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.345]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.345]                 }
[10:26:06.345]                 ...future.workdir <- getwd()
[10:26:06.345]             }
[10:26:06.345]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.345]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.345]         }
[10:26:06.345]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.345]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.345]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.345]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.345]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.345]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.345]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.345]             base::names(...future.oldOptions))
[10:26:06.345]     }
[10:26:06.345]     if (FALSE) {
[10:26:06.345]     }
[10:26:06.345]     else {
[10:26:06.345]         if (TRUE) {
[10:26:06.345]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.345]                 open = "w")
[10:26:06.345]         }
[10:26:06.345]         else {
[10:26:06.345]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.345]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.345]         }
[10:26:06.345]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.345]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.345]             base::sink(type = "output", split = FALSE)
[10:26:06.345]             base::close(...future.stdout)
[10:26:06.345]         }, add = TRUE)
[10:26:06.345]     }
[10:26:06.345]     ...future.frame <- base::sys.nframe()
[10:26:06.345]     ...future.conditions <- base::list()
[10:26:06.345]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.345]     if (FALSE) {
[10:26:06.345]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.345]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.345]     }
[10:26:06.345]     ...future.result <- base::tryCatch({
[10:26:06.345]         base::withCallingHandlers({
[10:26:06.345]             ...future.value <- base::withVisible(base::local({
[10:26:06.345]                 x$a <- 1
[10:26:06.345]                 x
[10:26:06.345]             }))
[10:26:06.345]             future::FutureResult(value = ...future.value$value, 
[10:26:06.345]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.345]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.345]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.345]                     ...future.globalenv.names))
[10:26:06.345]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.345]         }, condition = base::local({
[10:26:06.345]             c <- base::c
[10:26:06.345]             inherits <- base::inherits
[10:26:06.345]             invokeRestart <- base::invokeRestart
[10:26:06.345]             length <- base::length
[10:26:06.345]             list <- base::list
[10:26:06.345]             seq.int <- base::seq.int
[10:26:06.345]             signalCondition <- base::signalCondition
[10:26:06.345]             sys.calls <- base::sys.calls
[10:26:06.345]             `[[` <- base::`[[`
[10:26:06.345]             `+` <- base::`+`
[10:26:06.345]             `<<-` <- base::`<<-`
[10:26:06.345]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.345]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.345]                   3L)]
[10:26:06.345]             }
[10:26:06.345]             function(cond) {
[10:26:06.345]                 is_error <- inherits(cond, "error")
[10:26:06.345]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.345]                   NULL)
[10:26:06.345]                 if (is_error) {
[10:26:06.345]                   sessionInformation <- function() {
[10:26:06.345]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.345]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.345]                       search = base::search(), system = base::Sys.info())
[10:26:06.345]                   }
[10:26:06.345]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.345]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.345]                     cond$call), session = sessionInformation(), 
[10:26:06.345]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.345]                   signalCondition(cond)
[10:26:06.345]                 }
[10:26:06.345]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.345]                 "immediateCondition"))) {
[10:26:06.345]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.345]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.345]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.345]                   if (TRUE && !signal) {
[10:26:06.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.345]                     {
[10:26:06.345]                       inherits <- base::inherits
[10:26:06.345]                       invokeRestart <- base::invokeRestart
[10:26:06.345]                       is.null <- base::is.null
[10:26:06.345]                       muffled <- FALSE
[10:26:06.345]                       if (inherits(cond, "message")) {
[10:26:06.345]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.345]                         if (muffled) 
[10:26:06.345]                           invokeRestart("muffleMessage")
[10:26:06.345]                       }
[10:26:06.345]                       else if (inherits(cond, "warning")) {
[10:26:06.345]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.345]                         if (muffled) 
[10:26:06.345]                           invokeRestart("muffleWarning")
[10:26:06.345]                       }
[10:26:06.345]                       else if (inherits(cond, "condition")) {
[10:26:06.345]                         if (!is.null(pattern)) {
[10:26:06.345]                           computeRestarts <- base::computeRestarts
[10:26:06.345]                           grepl <- base::grepl
[10:26:06.345]                           restarts <- computeRestarts(cond)
[10:26:06.345]                           for (restart in restarts) {
[10:26:06.345]                             name <- restart$name
[10:26:06.345]                             if (is.null(name)) 
[10:26:06.345]                               next
[10:26:06.345]                             if (!grepl(pattern, name)) 
[10:26:06.345]                               next
[10:26:06.345]                             invokeRestart(restart)
[10:26:06.345]                             muffled <- TRUE
[10:26:06.345]                             break
[10:26:06.345]                           }
[10:26:06.345]                         }
[10:26:06.345]                       }
[10:26:06.345]                       invisible(muffled)
[10:26:06.345]                     }
[10:26:06.345]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.345]                   }
[10:26:06.345]                 }
[10:26:06.345]                 else {
[10:26:06.345]                   if (TRUE) {
[10:26:06.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.345]                     {
[10:26:06.345]                       inherits <- base::inherits
[10:26:06.345]                       invokeRestart <- base::invokeRestart
[10:26:06.345]                       is.null <- base::is.null
[10:26:06.345]                       muffled <- FALSE
[10:26:06.345]                       if (inherits(cond, "message")) {
[10:26:06.345]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.345]                         if (muffled) 
[10:26:06.345]                           invokeRestart("muffleMessage")
[10:26:06.345]                       }
[10:26:06.345]                       else if (inherits(cond, "warning")) {
[10:26:06.345]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.345]                         if (muffled) 
[10:26:06.345]                           invokeRestart("muffleWarning")
[10:26:06.345]                       }
[10:26:06.345]                       else if (inherits(cond, "condition")) {
[10:26:06.345]                         if (!is.null(pattern)) {
[10:26:06.345]                           computeRestarts <- base::computeRestarts
[10:26:06.345]                           grepl <- base::grepl
[10:26:06.345]                           restarts <- computeRestarts(cond)
[10:26:06.345]                           for (restart in restarts) {
[10:26:06.345]                             name <- restart$name
[10:26:06.345]                             if (is.null(name)) 
[10:26:06.345]                               next
[10:26:06.345]                             if (!grepl(pattern, name)) 
[10:26:06.345]                               next
[10:26:06.345]                             invokeRestart(restart)
[10:26:06.345]                             muffled <- TRUE
[10:26:06.345]                             break
[10:26:06.345]                           }
[10:26:06.345]                         }
[10:26:06.345]                       }
[10:26:06.345]                       invisible(muffled)
[10:26:06.345]                     }
[10:26:06.345]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.345]                   }
[10:26:06.345]                 }
[10:26:06.345]             }
[10:26:06.345]         }))
[10:26:06.345]     }, error = function(ex) {
[10:26:06.345]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.345]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.345]                 ...future.rng), started = ...future.startTime, 
[10:26:06.345]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.345]             version = "1.8"), class = "FutureResult")
[10:26:06.345]     }, finally = {
[10:26:06.345]         if (!identical(...future.workdir, getwd())) 
[10:26:06.345]             setwd(...future.workdir)
[10:26:06.345]         {
[10:26:06.345]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.345]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.345]             }
[10:26:06.345]             base::options(...future.oldOptions)
[10:26:06.345]             if (.Platform$OS.type == "windows") {
[10:26:06.345]                 old_names <- names(...future.oldEnvVars)
[10:26:06.345]                 envs <- base::Sys.getenv()
[10:26:06.345]                 names <- names(envs)
[10:26:06.345]                 common <- intersect(names, old_names)
[10:26:06.345]                 added <- setdiff(names, old_names)
[10:26:06.345]                 removed <- setdiff(old_names, names)
[10:26:06.345]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.345]                   envs[common]]
[10:26:06.345]                 NAMES <- toupper(changed)
[10:26:06.345]                 args <- list()
[10:26:06.345]                 for (kk in seq_along(NAMES)) {
[10:26:06.345]                   name <- changed[[kk]]
[10:26:06.345]                   NAME <- NAMES[[kk]]
[10:26:06.345]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.345]                     next
[10:26:06.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.345]                 }
[10:26:06.345]                 NAMES <- toupper(added)
[10:26:06.345]                 for (kk in seq_along(NAMES)) {
[10:26:06.345]                   name <- added[[kk]]
[10:26:06.345]                   NAME <- NAMES[[kk]]
[10:26:06.345]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.345]                     next
[10:26:06.345]                   args[[name]] <- ""
[10:26:06.345]                 }
[10:26:06.345]                 NAMES <- toupper(removed)
[10:26:06.345]                 for (kk in seq_along(NAMES)) {
[10:26:06.345]                   name <- removed[[kk]]
[10:26:06.345]                   NAME <- NAMES[[kk]]
[10:26:06.345]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.345]                     next
[10:26:06.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.345]                 }
[10:26:06.345]                 if (length(args) > 0) 
[10:26:06.345]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.345]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.345]             }
[10:26:06.345]             else {
[10:26:06.345]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.345]             }
[10:26:06.345]             {
[10:26:06.345]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.345]                   0L) {
[10:26:06.345]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.345]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.345]                   base::options(opts)
[10:26:06.345]                 }
[10:26:06.345]                 {
[10:26:06.345]                   {
[10:26:06.345]                     NULL
[10:26:06.345]                     RNGkind("Mersenne-Twister")
[10:26:06.345]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:06.345]                       inherits = FALSE)
[10:26:06.345]                   }
[10:26:06.345]                   options(future.plan = NULL)
[10:26:06.345]                   if (is.na(NA_character_)) 
[10:26:06.345]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.345]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.345]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:06.345]                   {
[10:26:06.345]                     future <- SequentialFuture(..., envir = envir)
[10:26:06.345]                     if (!future$lazy) 
[10:26:06.345]                       future <- run(future)
[10:26:06.345]                     invisible(future)
[10:26:06.345]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.345]                 }
[10:26:06.345]             }
[10:26:06.345]         }
[10:26:06.345]     })
[10:26:06.345]     if (TRUE) {
[10:26:06.345]         base::sink(type = "output", split = FALSE)
[10:26:06.345]         if (TRUE) {
[10:26:06.345]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.345]         }
[10:26:06.345]         else {
[10:26:06.345]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.345]         }
[10:26:06.345]         base::close(...future.stdout)
[10:26:06.345]         ...future.stdout <- NULL
[10:26:06.345]     }
[10:26:06.345]     ...future.result$conditions <- ...future.conditions
[10:26:06.345]     ...future.result$finished <- base::Sys.time()
[10:26:06.345]     ...future.result
[10:26:06.345] }
[10:26:06.346] assign_globals() ...
[10:26:06.346] List of 1
[10:26:06.346]  $ x: list()
[10:26:06.346]  - attr(*, "where")=List of 1
[10:26:06.346]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.346]  - attr(*, "resolved")= logi TRUE
[10:26:06.346]  - attr(*, "total_size")= num 0
[10:26:06.346]  - attr(*, "already-done")= logi TRUE
[10:26:06.349] - copied ‘x’ to environment
[10:26:06.349] assign_globals() ... done
[10:26:06.349] plan(): Setting new future strategy stack:
[10:26:06.349] List of future strategies:
[10:26:06.349] 1. sequential:
[10:26:06.349]    - args: function (..., envir = parent.frame())
[10:26:06.349]    - tweaked: FALSE
[10:26:06.349]    - call: NULL
[10:26:06.349] plan(): nbrOfWorkers() = 1
[10:26:06.350] plan(): Setting new future strategy stack:
[10:26:06.350] List of future strategies:
[10:26:06.350] 1. sequential:
[10:26:06.350]    - args: function (..., envir = parent.frame())
[10:26:06.350]    - tweaked: FALSE
[10:26:06.350]    - call: plan(strategy)
[10:26:06.350] plan(): nbrOfWorkers() = 1
[10:26:06.350] SequentialFuture started (and completed)
[10:26:06.351] - Launch lazy future ... done
[10:26:06.351] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.351] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.351] Searching for globals...
[10:26:06.353] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.353] Searching for globals ... DONE
[10:26:06.353] Resolving globals: TRUE
[10:26:06.353] Resolving any globals that are futures ...
[10:26:06.353] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.354] Resolving any globals that are futures ... DONE
[10:26:06.354] Resolving futures part of globals (recursively) ...
[10:26:06.354] resolve() on list ...
[10:26:06.354]  recursive: 99
[10:26:06.354]  length: 1
[10:26:06.354]  elements: ‘x’
[10:26:06.354]  length: 0 (resolved future 1)
[10:26:06.355] resolve() on list ... DONE
[10:26:06.355] - globals: [1] ‘x’
[10:26:06.355] Resolving futures part of globals (recursively) ... DONE
[10:26:06.355] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.355] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.355] - globals: [1] ‘x’
[10:26:06.355] 
[10:26:06.356] getGlobalsAndPackages() ... DONE
[10:26:06.356] run() for ‘Future’ ...
[10:26:06.356] - state: ‘created’
[10:26:06.356] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:06.356] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:06.356] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:06.356]   - Field: ‘label’
[10:26:06.357]   - Field: ‘local’
[10:26:06.357]   - Field: ‘owner’
[10:26:06.357]   - Field: ‘envir’
[10:26:06.357]   - Field: ‘packages’
[10:26:06.357]   - Field: ‘gc’
[10:26:06.357]   - Field: ‘conditions’
[10:26:06.357]   - Field: ‘expr’
[10:26:06.357]   - Field: ‘uuid’
[10:26:06.357]   - Field: ‘seed’
[10:26:06.357]   - Field: ‘version’
[10:26:06.357]   - Field: ‘result’
[10:26:06.358]   - Field: ‘asynchronous’
[10:26:06.358]   - Field: ‘calls’
[10:26:06.358]   - Field: ‘globals’
[10:26:06.358]   - Field: ‘stdout’
[10:26:06.358]   - Field: ‘earlySignal’
[10:26:06.358]   - Field: ‘lazy’
[10:26:06.358]   - Field: ‘state’
[10:26:06.358] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:06.358] - Launch lazy future ...
[10:26:06.358] Packages needed by the future expression (n = 0): <none>
[10:26:06.359] Packages needed by future strategies (n = 0): <none>
[10:26:06.359] {
[10:26:06.359]     {
[10:26:06.359]         {
[10:26:06.359]             ...future.startTime <- base::Sys.time()
[10:26:06.359]             {
[10:26:06.359]                 {
[10:26:06.359]                   {
[10:26:06.359]                     base::local({
[10:26:06.359]                       has_future <- base::requireNamespace("future", 
[10:26:06.359]                         quietly = TRUE)
[10:26:06.359]                       if (has_future) {
[10:26:06.359]                         ns <- base::getNamespace("future")
[10:26:06.359]                         version <- ns[[".package"]][["version"]]
[10:26:06.359]                         if (is.null(version)) 
[10:26:06.359]                           version <- utils::packageVersion("future")
[10:26:06.359]                       }
[10:26:06.359]                       else {
[10:26:06.359]                         version <- NULL
[10:26:06.359]                       }
[10:26:06.359]                       if (!has_future || version < "1.8.0") {
[10:26:06.359]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.359]                           "", base::R.version$version.string), 
[10:26:06.359]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:06.359]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.359]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.359]                             "release", "version")], collapse = " "), 
[10:26:06.359]                           hostname = base::Sys.info()[["nodename"]])
[10:26:06.359]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.359]                           info)
[10:26:06.359]                         info <- base::paste(info, collapse = "; ")
[10:26:06.359]                         if (!has_future) {
[10:26:06.359]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.359]                             info)
[10:26:06.359]                         }
[10:26:06.359]                         else {
[10:26:06.359]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.359]                             info, version)
[10:26:06.359]                         }
[10:26:06.359]                         base::stop(msg)
[10:26:06.359]                       }
[10:26:06.359]                     })
[10:26:06.359]                   }
[10:26:06.359]                   options(future.plan = NULL)
[10:26:06.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.359]                 }
[10:26:06.359]                 ...future.workdir <- getwd()
[10:26:06.359]             }
[10:26:06.359]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.359]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.359]         }
[10:26:06.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.359]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.359]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.359]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.359]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.359]             base::names(...future.oldOptions))
[10:26:06.359]     }
[10:26:06.359]     if (FALSE) {
[10:26:06.359]     }
[10:26:06.359]     else {
[10:26:06.359]         if (TRUE) {
[10:26:06.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.359]                 open = "w")
[10:26:06.359]         }
[10:26:06.359]         else {
[10:26:06.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.359]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.359]         }
[10:26:06.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.359]             base::sink(type = "output", split = FALSE)
[10:26:06.359]             base::close(...future.stdout)
[10:26:06.359]         }, add = TRUE)
[10:26:06.359]     }
[10:26:06.359]     ...future.frame <- base::sys.nframe()
[10:26:06.359]     ...future.conditions <- base::list()
[10:26:06.359]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.359]     if (FALSE) {
[10:26:06.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.359]     }
[10:26:06.359]     ...future.result <- base::tryCatch({
[10:26:06.359]         base::withCallingHandlers({
[10:26:06.359]             ...future.value <- base::withVisible(base::local({
[10:26:06.359]                 x$a <- 1
[10:26:06.359]                 x
[10:26:06.359]             }))
[10:26:06.359]             future::FutureResult(value = ...future.value$value, 
[10:26:06.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.359]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.359]                     ...future.globalenv.names))
[10:26:06.359]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.359]         }, condition = base::local({
[10:26:06.359]             c <- base::c
[10:26:06.359]             inherits <- base::inherits
[10:26:06.359]             invokeRestart <- base::invokeRestart
[10:26:06.359]             length <- base::length
[10:26:06.359]             list <- base::list
[10:26:06.359]             seq.int <- base::seq.int
[10:26:06.359]             signalCondition <- base::signalCondition
[10:26:06.359]             sys.calls <- base::sys.calls
[10:26:06.359]             `[[` <- base::`[[`
[10:26:06.359]             `+` <- base::`+`
[10:26:06.359]             `<<-` <- base::`<<-`
[10:26:06.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.359]                   3L)]
[10:26:06.359]             }
[10:26:06.359]             function(cond) {
[10:26:06.359]                 is_error <- inherits(cond, "error")
[10:26:06.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.359]                   NULL)
[10:26:06.359]                 if (is_error) {
[10:26:06.359]                   sessionInformation <- function() {
[10:26:06.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.359]                       search = base::search(), system = base::Sys.info())
[10:26:06.359]                   }
[10:26:06.359]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.359]                     cond$call), session = sessionInformation(), 
[10:26:06.359]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.359]                   signalCondition(cond)
[10:26:06.359]                 }
[10:26:06.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.359]                 "immediateCondition"))) {
[10:26:06.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.359]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.359]                   if (TRUE && !signal) {
[10:26:06.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.359]                     {
[10:26:06.359]                       inherits <- base::inherits
[10:26:06.359]                       invokeRestart <- base::invokeRestart
[10:26:06.359]                       is.null <- base::is.null
[10:26:06.359]                       muffled <- FALSE
[10:26:06.359]                       if (inherits(cond, "message")) {
[10:26:06.359]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.359]                         if (muffled) 
[10:26:06.359]                           invokeRestart("muffleMessage")
[10:26:06.359]                       }
[10:26:06.359]                       else if (inherits(cond, "warning")) {
[10:26:06.359]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.359]                         if (muffled) 
[10:26:06.359]                           invokeRestart("muffleWarning")
[10:26:06.359]                       }
[10:26:06.359]                       else if (inherits(cond, "condition")) {
[10:26:06.359]                         if (!is.null(pattern)) {
[10:26:06.359]                           computeRestarts <- base::computeRestarts
[10:26:06.359]                           grepl <- base::grepl
[10:26:06.359]                           restarts <- computeRestarts(cond)
[10:26:06.359]                           for (restart in restarts) {
[10:26:06.359]                             name <- restart$name
[10:26:06.359]                             if (is.null(name)) 
[10:26:06.359]                               next
[10:26:06.359]                             if (!grepl(pattern, name)) 
[10:26:06.359]                               next
[10:26:06.359]                             invokeRestart(restart)
[10:26:06.359]                             muffled <- TRUE
[10:26:06.359]                             break
[10:26:06.359]                           }
[10:26:06.359]                         }
[10:26:06.359]                       }
[10:26:06.359]                       invisible(muffled)
[10:26:06.359]                     }
[10:26:06.359]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.359]                   }
[10:26:06.359]                 }
[10:26:06.359]                 else {
[10:26:06.359]                   if (TRUE) {
[10:26:06.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.359]                     {
[10:26:06.359]                       inherits <- base::inherits
[10:26:06.359]                       invokeRestart <- base::invokeRestart
[10:26:06.359]                       is.null <- base::is.null
[10:26:06.359]                       muffled <- FALSE
[10:26:06.359]                       if (inherits(cond, "message")) {
[10:26:06.359]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.359]                         if (muffled) 
[10:26:06.359]                           invokeRestart("muffleMessage")
[10:26:06.359]                       }
[10:26:06.359]                       else if (inherits(cond, "warning")) {
[10:26:06.359]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.359]                         if (muffled) 
[10:26:06.359]                           invokeRestart("muffleWarning")
[10:26:06.359]                       }
[10:26:06.359]                       else if (inherits(cond, "condition")) {
[10:26:06.359]                         if (!is.null(pattern)) {
[10:26:06.359]                           computeRestarts <- base::computeRestarts
[10:26:06.359]                           grepl <- base::grepl
[10:26:06.359]                           restarts <- computeRestarts(cond)
[10:26:06.359]                           for (restart in restarts) {
[10:26:06.359]                             name <- restart$name
[10:26:06.359]                             if (is.null(name)) 
[10:26:06.359]                               next
[10:26:06.359]                             if (!grepl(pattern, name)) 
[10:26:06.359]                               next
[10:26:06.359]                             invokeRestart(restart)
[10:26:06.359]                             muffled <- TRUE
[10:26:06.359]                             break
[10:26:06.359]                           }
[10:26:06.359]                         }
[10:26:06.359]                       }
[10:26:06.359]                       invisible(muffled)
[10:26:06.359]                     }
[10:26:06.359]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.359]                   }
[10:26:06.359]                 }
[10:26:06.359]             }
[10:26:06.359]         }))
[10:26:06.359]     }, error = function(ex) {
[10:26:06.359]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.359]                 ...future.rng), started = ...future.startTime, 
[10:26:06.359]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.359]             version = "1.8"), class = "FutureResult")
[10:26:06.359]     }, finally = {
[10:26:06.359]         if (!identical(...future.workdir, getwd())) 
[10:26:06.359]             setwd(...future.workdir)
[10:26:06.359]         {
[10:26:06.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.359]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.359]             }
[10:26:06.359]             base::options(...future.oldOptions)
[10:26:06.359]             if (.Platform$OS.type == "windows") {
[10:26:06.359]                 old_names <- names(...future.oldEnvVars)
[10:26:06.359]                 envs <- base::Sys.getenv()
[10:26:06.359]                 names <- names(envs)
[10:26:06.359]                 common <- intersect(names, old_names)
[10:26:06.359]                 added <- setdiff(names, old_names)
[10:26:06.359]                 removed <- setdiff(old_names, names)
[10:26:06.359]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.359]                   envs[common]]
[10:26:06.359]                 NAMES <- toupper(changed)
[10:26:06.359]                 args <- list()
[10:26:06.359]                 for (kk in seq_along(NAMES)) {
[10:26:06.359]                   name <- changed[[kk]]
[10:26:06.359]                   NAME <- NAMES[[kk]]
[10:26:06.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.359]                     next
[10:26:06.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.359]                 }
[10:26:06.359]                 NAMES <- toupper(added)
[10:26:06.359]                 for (kk in seq_along(NAMES)) {
[10:26:06.359]                   name <- added[[kk]]
[10:26:06.359]                   NAME <- NAMES[[kk]]
[10:26:06.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.359]                     next
[10:26:06.359]                   args[[name]] <- ""
[10:26:06.359]                 }
[10:26:06.359]                 NAMES <- toupper(removed)
[10:26:06.359]                 for (kk in seq_along(NAMES)) {
[10:26:06.359]                   name <- removed[[kk]]
[10:26:06.359]                   NAME <- NAMES[[kk]]
[10:26:06.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.359]                     next
[10:26:06.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.359]                 }
[10:26:06.359]                 if (length(args) > 0) 
[10:26:06.359]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.359]             }
[10:26:06.359]             else {
[10:26:06.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.359]             }
[10:26:06.359]             {
[10:26:06.359]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.359]                   0L) {
[10:26:06.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.359]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.359]                   base::options(opts)
[10:26:06.359]                 }
[10:26:06.359]                 {
[10:26:06.359]                   {
[10:26:06.359]                     NULL
[10:26:06.359]                     RNGkind("Mersenne-Twister")
[10:26:06.359]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:06.359]                       inherits = FALSE)
[10:26:06.359]                   }
[10:26:06.359]                   options(future.plan = NULL)
[10:26:06.359]                   if (is.na(NA_character_)) 
[10:26:06.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.359]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:06.359]                   {
[10:26:06.359]                     future <- SequentialFuture(..., envir = envir)
[10:26:06.359]                     if (!future$lazy) 
[10:26:06.359]                       future <- run(future)
[10:26:06.359]                     invisible(future)
[10:26:06.359]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.359]                 }
[10:26:06.359]             }
[10:26:06.359]         }
[10:26:06.359]     })
[10:26:06.359]     if (TRUE) {
[10:26:06.359]         base::sink(type = "output", split = FALSE)
[10:26:06.359]         if (TRUE) {
[10:26:06.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.359]         }
[10:26:06.359]         else {
[10:26:06.359]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.359]         }
[10:26:06.359]         base::close(...future.stdout)
[10:26:06.359]         ...future.stdout <- NULL
[10:26:06.359]     }
[10:26:06.359]     ...future.result$conditions <- ...future.conditions
[10:26:06.359]     ...future.result$finished <- base::Sys.time()
[10:26:06.359]     ...future.result
[10:26:06.359] }
[10:26:06.360] assign_globals() ...
[10:26:06.361] List of 1
[10:26:06.361]  $ x: list()
[10:26:06.361]  - attr(*, "where")=List of 1
[10:26:06.361]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.361]  - attr(*, "resolved")= logi TRUE
[10:26:06.361]  - attr(*, "total_size")= num 0
[10:26:06.361]  - attr(*, "already-done")= logi TRUE
[10:26:06.363] - copied ‘x’ to environment
[10:26:06.363] assign_globals() ... done
[10:26:06.363] plan(): Setting new future strategy stack:
[10:26:06.363] List of future strategies:
[10:26:06.363] 1. sequential:
[10:26:06.363]    - args: function (..., envir = parent.frame())
[10:26:06.363]    - tweaked: FALSE
[10:26:06.363]    - call: NULL
[10:26:06.364] plan(): nbrOfWorkers() = 1
[10:26:06.364] plan(): Setting new future strategy stack:
[10:26:06.364] List of future strategies:
[10:26:06.364] 1. sequential:
[10:26:06.364]    - args: function (..., envir = parent.frame())
[10:26:06.364]    - tweaked: FALSE
[10:26:06.364]    - call: plan(strategy)
[10:26:06.365] plan(): nbrOfWorkers() = 1
[10:26:06.365] SequentialFuture started (and completed)
[10:26:06.365] - Launch lazy future ... done
[10:26:06.365] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.365] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.366] Searching for globals...
[10:26:06.369] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:26:06.369] Searching for globals ... DONE
[10:26:06.369] Resolving globals: TRUE
[10:26:06.369] Resolving any globals that are futures ...
[10:26:06.369] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:26:06.369] Resolving any globals that are futures ... DONE
[10:26:06.370] 
[10:26:06.370] 
[10:26:06.370] getGlobalsAndPackages() ... DONE
[10:26:06.370] run() for ‘Future’ ...
[10:26:06.370] - state: ‘created’
[10:26:06.370] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:06.371] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:06.371] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:06.371]   - Field: ‘label’
[10:26:06.371]   - Field: ‘local’
[10:26:06.371]   - Field: ‘owner’
[10:26:06.371]   - Field: ‘envir’
[10:26:06.371]   - Field: ‘packages’
[10:26:06.371]   - Field: ‘gc’
[10:26:06.371]   - Field: ‘conditions’
[10:26:06.371]   - Field: ‘expr’
[10:26:06.371]   - Field: ‘uuid’
[10:26:06.372]   - Field: ‘seed’
[10:26:06.372]   - Field: ‘version’
[10:26:06.372]   - Field: ‘result’
[10:26:06.372]   - Field: ‘asynchronous’
[10:26:06.372]   - Field: ‘calls’
[10:26:06.372]   - Field: ‘globals’
[10:26:06.372]   - Field: ‘stdout’
[10:26:06.372]   - Field: ‘earlySignal’
[10:26:06.372]   - Field: ‘lazy’
[10:26:06.372]   - Field: ‘state’
[10:26:06.372] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:06.373] - Launch lazy future ...
[10:26:06.373] Packages needed by the future expression (n = 0): <none>
[10:26:06.373] Packages needed by future strategies (n = 0): <none>
[10:26:06.373] {
[10:26:06.373]     {
[10:26:06.373]         {
[10:26:06.373]             ...future.startTime <- base::Sys.time()
[10:26:06.373]             {
[10:26:06.373]                 {
[10:26:06.373]                   {
[10:26:06.373]                     base::local({
[10:26:06.373]                       has_future <- base::requireNamespace("future", 
[10:26:06.373]                         quietly = TRUE)
[10:26:06.373]                       if (has_future) {
[10:26:06.373]                         ns <- base::getNamespace("future")
[10:26:06.373]                         version <- ns[[".package"]][["version"]]
[10:26:06.373]                         if (is.null(version)) 
[10:26:06.373]                           version <- utils::packageVersion("future")
[10:26:06.373]                       }
[10:26:06.373]                       else {
[10:26:06.373]                         version <- NULL
[10:26:06.373]                       }
[10:26:06.373]                       if (!has_future || version < "1.8.0") {
[10:26:06.373]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.373]                           "", base::R.version$version.string), 
[10:26:06.373]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:06.373]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.373]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.373]                             "release", "version")], collapse = " "), 
[10:26:06.373]                           hostname = base::Sys.info()[["nodename"]])
[10:26:06.373]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.373]                           info)
[10:26:06.373]                         info <- base::paste(info, collapse = "; ")
[10:26:06.373]                         if (!has_future) {
[10:26:06.373]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.373]                             info)
[10:26:06.373]                         }
[10:26:06.373]                         else {
[10:26:06.373]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.373]                             info, version)
[10:26:06.373]                         }
[10:26:06.373]                         base::stop(msg)
[10:26:06.373]                       }
[10:26:06.373]                     })
[10:26:06.373]                   }
[10:26:06.373]                   options(future.plan = NULL)
[10:26:06.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.373]                 }
[10:26:06.373]                 ...future.workdir <- getwd()
[10:26:06.373]             }
[10:26:06.373]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.373]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.373]         }
[10:26:06.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.373]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.373]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.373]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.373]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.373]             base::names(...future.oldOptions))
[10:26:06.373]     }
[10:26:06.373]     if (FALSE) {
[10:26:06.373]     }
[10:26:06.373]     else {
[10:26:06.373]         if (TRUE) {
[10:26:06.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.373]                 open = "w")
[10:26:06.373]         }
[10:26:06.373]         else {
[10:26:06.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.373]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.373]         }
[10:26:06.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.373]             base::sink(type = "output", split = FALSE)
[10:26:06.373]             base::close(...future.stdout)
[10:26:06.373]         }, add = TRUE)
[10:26:06.373]     }
[10:26:06.373]     ...future.frame <- base::sys.nframe()
[10:26:06.373]     ...future.conditions <- base::list()
[10:26:06.373]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.373]     if (FALSE) {
[10:26:06.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.373]     }
[10:26:06.373]     ...future.result <- base::tryCatch({
[10:26:06.373]         base::withCallingHandlers({
[10:26:06.373]             ...future.value <- base::withVisible(base::local({
[10:26:06.373]                 x <- list(b = 2)
[10:26:06.373]                 x$a <- 1
[10:26:06.373]                 x
[10:26:06.373]             }))
[10:26:06.373]             future::FutureResult(value = ...future.value$value, 
[10:26:06.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.373]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.373]                     ...future.globalenv.names))
[10:26:06.373]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.373]         }, condition = base::local({
[10:26:06.373]             c <- base::c
[10:26:06.373]             inherits <- base::inherits
[10:26:06.373]             invokeRestart <- base::invokeRestart
[10:26:06.373]             length <- base::length
[10:26:06.373]             list <- base::list
[10:26:06.373]             seq.int <- base::seq.int
[10:26:06.373]             signalCondition <- base::signalCondition
[10:26:06.373]             sys.calls <- base::sys.calls
[10:26:06.373]             `[[` <- base::`[[`
[10:26:06.373]             `+` <- base::`+`
[10:26:06.373]             `<<-` <- base::`<<-`
[10:26:06.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.373]                   3L)]
[10:26:06.373]             }
[10:26:06.373]             function(cond) {
[10:26:06.373]                 is_error <- inherits(cond, "error")
[10:26:06.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.373]                   NULL)
[10:26:06.373]                 if (is_error) {
[10:26:06.373]                   sessionInformation <- function() {
[10:26:06.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.373]                       search = base::search(), system = base::Sys.info())
[10:26:06.373]                   }
[10:26:06.373]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.373]                     cond$call), session = sessionInformation(), 
[10:26:06.373]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.373]                   signalCondition(cond)
[10:26:06.373]                 }
[10:26:06.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.373]                 "immediateCondition"))) {
[10:26:06.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.373]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.373]                   if (TRUE && !signal) {
[10:26:06.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.373]                     {
[10:26:06.373]                       inherits <- base::inherits
[10:26:06.373]                       invokeRestart <- base::invokeRestart
[10:26:06.373]                       is.null <- base::is.null
[10:26:06.373]                       muffled <- FALSE
[10:26:06.373]                       if (inherits(cond, "message")) {
[10:26:06.373]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.373]                         if (muffled) 
[10:26:06.373]                           invokeRestart("muffleMessage")
[10:26:06.373]                       }
[10:26:06.373]                       else if (inherits(cond, "warning")) {
[10:26:06.373]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.373]                         if (muffled) 
[10:26:06.373]                           invokeRestart("muffleWarning")
[10:26:06.373]                       }
[10:26:06.373]                       else if (inherits(cond, "condition")) {
[10:26:06.373]                         if (!is.null(pattern)) {
[10:26:06.373]                           computeRestarts <- base::computeRestarts
[10:26:06.373]                           grepl <- base::grepl
[10:26:06.373]                           restarts <- computeRestarts(cond)
[10:26:06.373]                           for (restart in restarts) {
[10:26:06.373]                             name <- restart$name
[10:26:06.373]                             if (is.null(name)) 
[10:26:06.373]                               next
[10:26:06.373]                             if (!grepl(pattern, name)) 
[10:26:06.373]                               next
[10:26:06.373]                             invokeRestart(restart)
[10:26:06.373]                             muffled <- TRUE
[10:26:06.373]                             break
[10:26:06.373]                           }
[10:26:06.373]                         }
[10:26:06.373]                       }
[10:26:06.373]                       invisible(muffled)
[10:26:06.373]                     }
[10:26:06.373]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.373]                   }
[10:26:06.373]                 }
[10:26:06.373]                 else {
[10:26:06.373]                   if (TRUE) {
[10:26:06.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.373]                     {
[10:26:06.373]                       inherits <- base::inherits
[10:26:06.373]                       invokeRestart <- base::invokeRestart
[10:26:06.373]                       is.null <- base::is.null
[10:26:06.373]                       muffled <- FALSE
[10:26:06.373]                       if (inherits(cond, "message")) {
[10:26:06.373]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.373]                         if (muffled) 
[10:26:06.373]                           invokeRestart("muffleMessage")
[10:26:06.373]                       }
[10:26:06.373]                       else if (inherits(cond, "warning")) {
[10:26:06.373]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.373]                         if (muffled) 
[10:26:06.373]                           invokeRestart("muffleWarning")
[10:26:06.373]                       }
[10:26:06.373]                       else if (inherits(cond, "condition")) {
[10:26:06.373]                         if (!is.null(pattern)) {
[10:26:06.373]                           computeRestarts <- base::computeRestarts
[10:26:06.373]                           grepl <- base::grepl
[10:26:06.373]                           restarts <- computeRestarts(cond)
[10:26:06.373]                           for (restart in restarts) {
[10:26:06.373]                             name <- restart$name
[10:26:06.373]                             if (is.null(name)) 
[10:26:06.373]                               next
[10:26:06.373]                             if (!grepl(pattern, name)) 
[10:26:06.373]                               next
[10:26:06.373]                             invokeRestart(restart)
[10:26:06.373]                             muffled <- TRUE
[10:26:06.373]                             break
[10:26:06.373]                           }
[10:26:06.373]                         }
[10:26:06.373]                       }
[10:26:06.373]                       invisible(muffled)
[10:26:06.373]                     }
[10:26:06.373]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.373]                   }
[10:26:06.373]                 }
[10:26:06.373]             }
[10:26:06.373]         }))
[10:26:06.373]     }, error = function(ex) {
[10:26:06.373]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.373]                 ...future.rng), started = ...future.startTime, 
[10:26:06.373]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.373]             version = "1.8"), class = "FutureResult")
[10:26:06.373]     }, finally = {
[10:26:06.373]         if (!identical(...future.workdir, getwd())) 
[10:26:06.373]             setwd(...future.workdir)
[10:26:06.373]         {
[10:26:06.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.373]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.373]             }
[10:26:06.373]             base::options(...future.oldOptions)
[10:26:06.373]             if (.Platform$OS.type == "windows") {
[10:26:06.373]                 old_names <- names(...future.oldEnvVars)
[10:26:06.373]                 envs <- base::Sys.getenv()
[10:26:06.373]                 names <- names(envs)
[10:26:06.373]                 common <- intersect(names, old_names)
[10:26:06.373]                 added <- setdiff(names, old_names)
[10:26:06.373]                 removed <- setdiff(old_names, names)
[10:26:06.373]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.373]                   envs[common]]
[10:26:06.373]                 NAMES <- toupper(changed)
[10:26:06.373]                 args <- list()
[10:26:06.373]                 for (kk in seq_along(NAMES)) {
[10:26:06.373]                   name <- changed[[kk]]
[10:26:06.373]                   NAME <- NAMES[[kk]]
[10:26:06.373]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.373]                     next
[10:26:06.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.373]                 }
[10:26:06.373]                 NAMES <- toupper(added)
[10:26:06.373]                 for (kk in seq_along(NAMES)) {
[10:26:06.373]                   name <- added[[kk]]
[10:26:06.373]                   NAME <- NAMES[[kk]]
[10:26:06.373]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.373]                     next
[10:26:06.373]                   args[[name]] <- ""
[10:26:06.373]                 }
[10:26:06.373]                 NAMES <- toupper(removed)
[10:26:06.373]                 for (kk in seq_along(NAMES)) {
[10:26:06.373]                   name <- removed[[kk]]
[10:26:06.373]                   NAME <- NAMES[[kk]]
[10:26:06.373]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.373]                     next
[10:26:06.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.373]                 }
[10:26:06.373]                 if (length(args) > 0) 
[10:26:06.373]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.373]             }
[10:26:06.373]             else {
[10:26:06.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.373]             }
[10:26:06.373]             {
[10:26:06.373]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.373]                   0L) {
[10:26:06.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.373]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.373]                   base::options(opts)
[10:26:06.373]                 }
[10:26:06.373]                 {
[10:26:06.373]                   {
[10:26:06.373]                     NULL
[10:26:06.373]                     RNGkind("Mersenne-Twister")
[10:26:06.373]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:06.373]                       inherits = FALSE)
[10:26:06.373]                   }
[10:26:06.373]                   options(future.plan = NULL)
[10:26:06.373]                   if (is.na(NA_character_)) 
[10:26:06.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.373]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:06.373]                   {
[10:26:06.373]                     future <- SequentialFuture(..., envir = envir)
[10:26:06.373]                     if (!future$lazy) 
[10:26:06.373]                       future <- run(future)
[10:26:06.373]                     invisible(future)
[10:26:06.373]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.373]                 }
[10:26:06.373]             }
[10:26:06.373]         }
[10:26:06.373]     })
[10:26:06.373]     if (TRUE) {
[10:26:06.373]         base::sink(type = "output", split = FALSE)
[10:26:06.373]         if (TRUE) {
[10:26:06.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.373]         }
[10:26:06.373]         else {
[10:26:06.373]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.373]         }
[10:26:06.373]         base::close(...future.stdout)
[10:26:06.373]         ...future.stdout <- NULL
[10:26:06.373]     }
[10:26:06.373]     ...future.result$conditions <- ...future.conditions
[10:26:06.373]     ...future.result$finished <- base::Sys.time()
[10:26:06.373]     ...future.result
[10:26:06.373] }
[10:26:06.375] plan(): Setting new future strategy stack:
[10:26:06.375] List of future strategies:
[10:26:06.375] 1. sequential:
[10:26:06.375]    - args: function (..., envir = parent.frame())
[10:26:06.375]    - tweaked: FALSE
[10:26:06.375]    - call: NULL
[10:26:06.375] plan(): nbrOfWorkers() = 1
[10:26:06.376] plan(): Setting new future strategy stack:
[10:26:06.376] List of future strategies:
[10:26:06.376] 1. sequential:
[10:26:06.376]    - args: function (..., envir = parent.frame())
[10:26:06.376]    - tweaked: FALSE
[10:26:06.376]    - call: plan(strategy)
[10:26:06.376] plan(): nbrOfWorkers() = 1
[10:26:06.377] SequentialFuture started (and completed)
[10:26:06.377] - Launch lazy future ... done
[10:26:06.377] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.377] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.377] Searching for globals...
[10:26:06.379] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:06.379] Searching for globals ... DONE
[10:26:06.379] Resolving globals: TRUE
[10:26:06.379] Resolving any globals that are futures ...
[10:26:06.379] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:06.380] Resolving any globals that are futures ... DONE
[10:26:06.380] Resolving futures part of globals (recursively) ...
[10:26:06.380] resolve() on list ...
[10:26:06.380]  recursive: 99
[10:26:06.380]  length: 1
[10:26:06.380]  elements: ‘x’
[10:26:06.380]  length: 0 (resolved future 1)
[10:26:06.380] resolve() on list ... DONE
[10:26:06.381] - globals: [1] ‘x’
[10:26:06.381] Resolving futures part of globals (recursively) ... DONE
[10:26:06.381] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.381] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.381] - globals: [1] ‘x’
[10:26:06.381] 
[10:26:06.381] getGlobalsAndPackages() ... DONE
[10:26:06.382] run() for ‘Future’ ...
[10:26:06.382] - state: ‘created’
[10:26:06.382] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:06.382] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:06.382] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:06.382]   - Field: ‘label’
[10:26:06.382]   - Field: ‘local’
[10:26:06.382]   - Field: ‘owner’
[10:26:06.383]   - Field: ‘envir’
[10:26:06.383]   - Field: ‘packages’
[10:26:06.383]   - Field: ‘gc’
[10:26:06.383]   - Field: ‘conditions’
[10:26:06.383]   - Field: ‘expr’
[10:26:06.383]   - Field: ‘uuid’
[10:26:06.383]   - Field: ‘seed’
[10:26:06.383]   - Field: ‘version’
[10:26:06.383]   - Field: ‘result’
[10:26:06.383]   - Field: ‘asynchronous’
[10:26:06.383]   - Field: ‘calls’
[10:26:06.383]   - Field: ‘globals’
[10:26:06.384]   - Field: ‘stdout’
[10:26:06.384]   - Field: ‘earlySignal’
[10:26:06.384]   - Field: ‘lazy’
[10:26:06.384]   - Field: ‘state’
[10:26:06.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:06.384] - Launch lazy future ...
[10:26:06.384] Packages needed by the future expression (n = 0): <none>
[10:26:06.384] Packages needed by future strategies (n = 0): <none>
[10:26:06.385] {
[10:26:06.385]     {
[10:26:06.385]         {
[10:26:06.385]             ...future.startTime <- base::Sys.time()
[10:26:06.385]             {
[10:26:06.385]                 {
[10:26:06.385]                   {
[10:26:06.385]                     base::local({
[10:26:06.385]                       has_future <- base::requireNamespace("future", 
[10:26:06.385]                         quietly = TRUE)
[10:26:06.385]                       if (has_future) {
[10:26:06.385]                         ns <- base::getNamespace("future")
[10:26:06.385]                         version <- ns[[".package"]][["version"]]
[10:26:06.385]                         if (is.null(version)) 
[10:26:06.385]                           version <- utils::packageVersion("future")
[10:26:06.385]                       }
[10:26:06.385]                       else {
[10:26:06.385]                         version <- NULL
[10:26:06.385]                       }
[10:26:06.385]                       if (!has_future || version < "1.8.0") {
[10:26:06.385]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.385]                           "", base::R.version$version.string), 
[10:26:06.385]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:06.385]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.385]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.385]                             "release", "version")], collapse = " "), 
[10:26:06.385]                           hostname = base::Sys.info()[["nodename"]])
[10:26:06.385]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.385]                           info)
[10:26:06.385]                         info <- base::paste(info, collapse = "; ")
[10:26:06.385]                         if (!has_future) {
[10:26:06.385]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.385]                             info)
[10:26:06.385]                         }
[10:26:06.385]                         else {
[10:26:06.385]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.385]                             info, version)
[10:26:06.385]                         }
[10:26:06.385]                         base::stop(msg)
[10:26:06.385]                       }
[10:26:06.385]                     })
[10:26:06.385]                   }
[10:26:06.385]                   options(future.plan = NULL)
[10:26:06.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.385]                 }
[10:26:06.385]                 ...future.workdir <- getwd()
[10:26:06.385]             }
[10:26:06.385]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.385]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.385]         }
[10:26:06.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.385]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.385]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.385]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.385]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.385]             base::names(...future.oldOptions))
[10:26:06.385]     }
[10:26:06.385]     if (FALSE) {
[10:26:06.385]     }
[10:26:06.385]     else {
[10:26:06.385]         if (TRUE) {
[10:26:06.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.385]                 open = "w")
[10:26:06.385]         }
[10:26:06.385]         else {
[10:26:06.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.385]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.385]         }
[10:26:06.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.385]             base::sink(type = "output", split = FALSE)
[10:26:06.385]             base::close(...future.stdout)
[10:26:06.385]         }, add = TRUE)
[10:26:06.385]     }
[10:26:06.385]     ...future.frame <- base::sys.nframe()
[10:26:06.385]     ...future.conditions <- base::list()
[10:26:06.385]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.385]     if (FALSE) {
[10:26:06.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.385]     }
[10:26:06.385]     ...future.result <- base::tryCatch({
[10:26:06.385]         base::withCallingHandlers({
[10:26:06.385]             ...future.value <- base::withVisible(base::local({
[10:26:06.385]                 x[["a"]] <- 1
[10:26:06.385]                 x
[10:26:06.385]             }))
[10:26:06.385]             future::FutureResult(value = ...future.value$value, 
[10:26:06.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.385]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.385]                     ...future.globalenv.names))
[10:26:06.385]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.385]         }, condition = base::local({
[10:26:06.385]             c <- base::c
[10:26:06.385]             inherits <- base::inherits
[10:26:06.385]             invokeRestart <- base::invokeRestart
[10:26:06.385]             length <- base::length
[10:26:06.385]             list <- base::list
[10:26:06.385]             seq.int <- base::seq.int
[10:26:06.385]             signalCondition <- base::signalCondition
[10:26:06.385]             sys.calls <- base::sys.calls
[10:26:06.385]             `[[` <- base::`[[`
[10:26:06.385]             `+` <- base::`+`
[10:26:06.385]             `<<-` <- base::`<<-`
[10:26:06.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.385]                   3L)]
[10:26:06.385]             }
[10:26:06.385]             function(cond) {
[10:26:06.385]                 is_error <- inherits(cond, "error")
[10:26:06.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.385]                   NULL)
[10:26:06.385]                 if (is_error) {
[10:26:06.385]                   sessionInformation <- function() {
[10:26:06.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.385]                       search = base::search(), system = base::Sys.info())
[10:26:06.385]                   }
[10:26:06.385]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.385]                     cond$call), session = sessionInformation(), 
[10:26:06.385]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.385]                   signalCondition(cond)
[10:26:06.385]                 }
[10:26:06.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.385]                 "immediateCondition"))) {
[10:26:06.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.385]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.385]                   if (TRUE && !signal) {
[10:26:06.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.385]                     {
[10:26:06.385]                       inherits <- base::inherits
[10:26:06.385]                       invokeRestart <- base::invokeRestart
[10:26:06.385]                       is.null <- base::is.null
[10:26:06.385]                       muffled <- FALSE
[10:26:06.385]                       if (inherits(cond, "message")) {
[10:26:06.385]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.385]                         if (muffled) 
[10:26:06.385]                           invokeRestart("muffleMessage")
[10:26:06.385]                       }
[10:26:06.385]                       else if (inherits(cond, "warning")) {
[10:26:06.385]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.385]                         if (muffled) 
[10:26:06.385]                           invokeRestart("muffleWarning")
[10:26:06.385]                       }
[10:26:06.385]                       else if (inherits(cond, "condition")) {
[10:26:06.385]                         if (!is.null(pattern)) {
[10:26:06.385]                           computeRestarts <- base::computeRestarts
[10:26:06.385]                           grepl <- base::grepl
[10:26:06.385]                           restarts <- computeRestarts(cond)
[10:26:06.385]                           for (restart in restarts) {
[10:26:06.385]                             name <- restart$name
[10:26:06.385]                             if (is.null(name)) 
[10:26:06.385]                               next
[10:26:06.385]                             if (!grepl(pattern, name)) 
[10:26:06.385]                               next
[10:26:06.385]                             invokeRestart(restart)
[10:26:06.385]                             muffled <- TRUE
[10:26:06.385]                             break
[10:26:06.385]                           }
[10:26:06.385]                         }
[10:26:06.385]                       }
[10:26:06.385]                       invisible(muffled)
[10:26:06.385]                     }
[10:26:06.385]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.385]                   }
[10:26:06.385]                 }
[10:26:06.385]                 else {
[10:26:06.385]                   if (TRUE) {
[10:26:06.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.385]                     {
[10:26:06.385]                       inherits <- base::inherits
[10:26:06.385]                       invokeRestart <- base::invokeRestart
[10:26:06.385]                       is.null <- base::is.null
[10:26:06.385]                       muffled <- FALSE
[10:26:06.385]                       if (inherits(cond, "message")) {
[10:26:06.385]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.385]                         if (muffled) 
[10:26:06.385]                           invokeRestart("muffleMessage")
[10:26:06.385]                       }
[10:26:06.385]                       else if (inherits(cond, "warning")) {
[10:26:06.385]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.385]                         if (muffled) 
[10:26:06.385]                           invokeRestart("muffleWarning")
[10:26:06.385]                       }
[10:26:06.385]                       else if (inherits(cond, "condition")) {
[10:26:06.385]                         if (!is.null(pattern)) {
[10:26:06.385]                           computeRestarts <- base::computeRestarts
[10:26:06.385]                           grepl <- base::grepl
[10:26:06.385]                           restarts <- computeRestarts(cond)
[10:26:06.385]                           for (restart in restarts) {
[10:26:06.385]                             name <- restart$name
[10:26:06.385]                             if (is.null(name)) 
[10:26:06.385]                               next
[10:26:06.385]                             if (!grepl(pattern, name)) 
[10:26:06.385]                               next
[10:26:06.385]                             invokeRestart(restart)
[10:26:06.385]                             muffled <- TRUE
[10:26:06.385]                             break
[10:26:06.385]                           }
[10:26:06.385]                         }
[10:26:06.385]                       }
[10:26:06.385]                       invisible(muffled)
[10:26:06.385]                     }
[10:26:06.385]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.385]                   }
[10:26:06.385]                 }
[10:26:06.385]             }
[10:26:06.385]         }))
[10:26:06.385]     }, error = function(ex) {
[10:26:06.385]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.385]                 ...future.rng), started = ...future.startTime, 
[10:26:06.385]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.385]             version = "1.8"), class = "FutureResult")
[10:26:06.385]     }, finally = {
[10:26:06.385]         if (!identical(...future.workdir, getwd())) 
[10:26:06.385]             setwd(...future.workdir)
[10:26:06.385]         {
[10:26:06.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.385]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.385]             }
[10:26:06.385]             base::options(...future.oldOptions)
[10:26:06.385]             if (.Platform$OS.type == "windows") {
[10:26:06.385]                 old_names <- names(...future.oldEnvVars)
[10:26:06.385]                 envs <- base::Sys.getenv()
[10:26:06.385]                 names <- names(envs)
[10:26:06.385]                 common <- intersect(names, old_names)
[10:26:06.385]                 added <- setdiff(names, old_names)
[10:26:06.385]                 removed <- setdiff(old_names, names)
[10:26:06.385]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.385]                   envs[common]]
[10:26:06.385]                 NAMES <- toupper(changed)
[10:26:06.385]                 args <- list()
[10:26:06.385]                 for (kk in seq_along(NAMES)) {
[10:26:06.385]                   name <- changed[[kk]]
[10:26:06.385]                   NAME <- NAMES[[kk]]
[10:26:06.385]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.385]                     next
[10:26:06.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.385]                 }
[10:26:06.385]                 NAMES <- toupper(added)
[10:26:06.385]                 for (kk in seq_along(NAMES)) {
[10:26:06.385]                   name <- added[[kk]]
[10:26:06.385]                   NAME <- NAMES[[kk]]
[10:26:06.385]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.385]                     next
[10:26:06.385]                   args[[name]] <- ""
[10:26:06.385]                 }
[10:26:06.385]                 NAMES <- toupper(removed)
[10:26:06.385]                 for (kk in seq_along(NAMES)) {
[10:26:06.385]                   name <- removed[[kk]]
[10:26:06.385]                   NAME <- NAMES[[kk]]
[10:26:06.385]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.385]                     next
[10:26:06.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.385]                 }
[10:26:06.385]                 if (length(args) > 0) 
[10:26:06.385]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.385]             }
[10:26:06.385]             else {
[10:26:06.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.385]             }
[10:26:06.385]             {
[10:26:06.385]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.385]                   0L) {
[10:26:06.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.385]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.385]                   base::options(opts)
[10:26:06.385]                 }
[10:26:06.385]                 {
[10:26:06.385]                   {
[10:26:06.385]                     NULL
[10:26:06.385]                     RNGkind("Mersenne-Twister")
[10:26:06.385]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:06.385]                       inherits = FALSE)
[10:26:06.385]                   }
[10:26:06.385]                   options(future.plan = NULL)
[10:26:06.385]                   if (is.na(NA_character_)) 
[10:26:06.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.385]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:06.385]                   {
[10:26:06.385]                     future <- SequentialFuture(..., envir = envir)
[10:26:06.385]                     if (!future$lazy) 
[10:26:06.385]                       future <- run(future)
[10:26:06.385]                     invisible(future)
[10:26:06.385]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.385]                 }
[10:26:06.385]             }
[10:26:06.385]         }
[10:26:06.385]     })
[10:26:06.385]     if (TRUE) {
[10:26:06.385]         base::sink(type = "output", split = FALSE)
[10:26:06.385]         if (TRUE) {
[10:26:06.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.385]         }
[10:26:06.385]         else {
[10:26:06.385]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.385]         }
[10:26:06.385]         base::close(...future.stdout)
[10:26:06.385]         ...future.stdout <- NULL
[10:26:06.385]     }
[10:26:06.385]     ...future.result$conditions <- ...future.conditions
[10:26:06.385]     ...future.result$finished <- base::Sys.time()
[10:26:06.385]     ...future.result
[10:26:06.385] }
[10:26:06.386] assign_globals() ...
[10:26:06.386] List of 1
[10:26:06.386]  $ x: list()
[10:26:06.386]  - attr(*, "where")=List of 1
[10:26:06.386]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.386]  - attr(*, "resolved")= logi TRUE
[10:26:06.386]  - attr(*, "total_size")= num 0
[10:26:06.386]  - attr(*, "already-done")= logi TRUE
[10:26:06.389] - copied ‘x’ to environment
[10:26:06.389] assign_globals() ... done
[10:26:06.389] plan(): Setting new future strategy stack:
[10:26:06.389] List of future strategies:
[10:26:06.389] 1. sequential:
[10:26:06.389]    - args: function (..., envir = parent.frame())
[10:26:06.389]    - tweaked: FALSE
[10:26:06.389]    - call: NULL
[10:26:06.389] plan(): nbrOfWorkers() = 1
[10:26:06.390] plan(): Setting new future strategy stack:
[10:26:06.390] List of future strategies:
[10:26:06.390] 1. sequential:
[10:26:06.390]    - args: function (..., envir = parent.frame())
[10:26:06.390]    - tweaked: FALSE
[10:26:06.390]    - call: plan(strategy)
[10:26:06.390] plan(): nbrOfWorkers() = 1
[10:26:06.390] SequentialFuture started (and completed)
[10:26:06.391] - Launch lazy future ... done
[10:26:06.391] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.391] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.391] Searching for globals...
[10:26:06.394] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:06.394] Searching for globals ... DONE
[10:26:06.394] Resolving globals: TRUE
[10:26:06.394] Resolving any globals that are futures ...
[10:26:06.394] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:06.394] Resolving any globals that are futures ... DONE
[10:26:06.395] Resolving futures part of globals (recursively) ...
[10:26:06.395] resolve() on list ...
[10:26:06.395]  recursive: 99
[10:26:06.395]  length: 1
[10:26:06.395]  elements: ‘x’
[10:26:06.395]  length: 0 (resolved future 1)
[10:26:06.395] resolve() on list ... DONE
[10:26:06.395] - globals: [1] ‘x’
[10:26:06.396] Resolving futures part of globals (recursively) ... DONE
[10:26:06.396] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.396] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.396] - globals: [1] ‘x’
[10:26:06.396] 
[10:26:06.396] getGlobalsAndPackages() ... DONE
[10:26:06.396] run() for ‘Future’ ...
[10:26:06.397] - state: ‘created’
[10:26:06.397] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:06.397] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:06.397] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:06.397]   - Field: ‘label’
[10:26:06.397]   - Field: ‘local’
[10:26:06.397]   - Field: ‘owner’
[10:26:06.397]   - Field: ‘envir’
[10:26:06.398]   - Field: ‘packages’
[10:26:06.398]   - Field: ‘gc’
[10:26:06.398]   - Field: ‘conditions’
[10:26:06.398]   - Field: ‘expr’
[10:26:06.398]   - Field: ‘uuid’
[10:26:06.398]   - Field: ‘seed’
[10:26:06.398]   - Field: ‘version’
[10:26:06.398]   - Field: ‘result’
[10:26:06.398]   - Field: ‘asynchronous’
[10:26:06.398]   - Field: ‘calls’
[10:26:06.398]   - Field: ‘globals’
[10:26:06.398]   - Field: ‘stdout’
[10:26:06.399]   - Field: ‘earlySignal’
[10:26:06.399]   - Field: ‘lazy’
[10:26:06.399]   - Field: ‘state’
[10:26:06.399] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:06.399] - Launch lazy future ...
[10:26:06.399] Packages needed by the future expression (n = 0): <none>
[10:26:06.399] Packages needed by future strategies (n = 0): <none>
[10:26:06.399] {
[10:26:06.399]     {
[10:26:06.399]         {
[10:26:06.399]             ...future.startTime <- base::Sys.time()
[10:26:06.399]             {
[10:26:06.399]                 {
[10:26:06.399]                   {
[10:26:06.399]                     base::local({
[10:26:06.399]                       has_future <- base::requireNamespace("future", 
[10:26:06.399]                         quietly = TRUE)
[10:26:06.399]                       if (has_future) {
[10:26:06.399]                         ns <- base::getNamespace("future")
[10:26:06.399]                         version <- ns[[".package"]][["version"]]
[10:26:06.399]                         if (is.null(version)) 
[10:26:06.399]                           version <- utils::packageVersion("future")
[10:26:06.399]                       }
[10:26:06.399]                       else {
[10:26:06.399]                         version <- NULL
[10:26:06.399]                       }
[10:26:06.399]                       if (!has_future || version < "1.8.0") {
[10:26:06.399]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.399]                           "", base::R.version$version.string), 
[10:26:06.399]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:06.399]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.399]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.399]                             "release", "version")], collapse = " "), 
[10:26:06.399]                           hostname = base::Sys.info()[["nodename"]])
[10:26:06.399]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.399]                           info)
[10:26:06.399]                         info <- base::paste(info, collapse = "; ")
[10:26:06.399]                         if (!has_future) {
[10:26:06.399]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.399]                             info)
[10:26:06.399]                         }
[10:26:06.399]                         else {
[10:26:06.399]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.399]                             info, version)
[10:26:06.399]                         }
[10:26:06.399]                         base::stop(msg)
[10:26:06.399]                       }
[10:26:06.399]                     })
[10:26:06.399]                   }
[10:26:06.399]                   options(future.plan = NULL)
[10:26:06.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.399]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.399]                 }
[10:26:06.399]                 ...future.workdir <- getwd()
[10:26:06.399]             }
[10:26:06.399]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.399]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.399]         }
[10:26:06.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.399]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.399]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.399]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.399]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.399]             base::names(...future.oldOptions))
[10:26:06.399]     }
[10:26:06.399]     if (FALSE) {
[10:26:06.399]     }
[10:26:06.399]     else {
[10:26:06.399]         if (TRUE) {
[10:26:06.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.399]                 open = "w")
[10:26:06.399]         }
[10:26:06.399]         else {
[10:26:06.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.399]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.399]         }
[10:26:06.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.399]             base::sink(type = "output", split = FALSE)
[10:26:06.399]             base::close(...future.stdout)
[10:26:06.399]         }, add = TRUE)
[10:26:06.399]     }
[10:26:06.399]     ...future.frame <- base::sys.nframe()
[10:26:06.399]     ...future.conditions <- base::list()
[10:26:06.399]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.399]     if (FALSE) {
[10:26:06.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.399]     }
[10:26:06.399]     ...future.result <- base::tryCatch({
[10:26:06.399]         base::withCallingHandlers({
[10:26:06.399]             ...future.value <- base::withVisible(base::local({
[10:26:06.399]                 x[["a"]] <- 1
[10:26:06.399]                 x
[10:26:06.399]             }))
[10:26:06.399]             future::FutureResult(value = ...future.value$value, 
[10:26:06.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.399]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.399]                     ...future.globalenv.names))
[10:26:06.399]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.399]         }, condition = base::local({
[10:26:06.399]             c <- base::c
[10:26:06.399]             inherits <- base::inherits
[10:26:06.399]             invokeRestart <- base::invokeRestart
[10:26:06.399]             length <- base::length
[10:26:06.399]             list <- base::list
[10:26:06.399]             seq.int <- base::seq.int
[10:26:06.399]             signalCondition <- base::signalCondition
[10:26:06.399]             sys.calls <- base::sys.calls
[10:26:06.399]             `[[` <- base::`[[`
[10:26:06.399]             `+` <- base::`+`
[10:26:06.399]             `<<-` <- base::`<<-`
[10:26:06.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.399]                   3L)]
[10:26:06.399]             }
[10:26:06.399]             function(cond) {
[10:26:06.399]                 is_error <- inherits(cond, "error")
[10:26:06.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.399]                   NULL)
[10:26:06.399]                 if (is_error) {
[10:26:06.399]                   sessionInformation <- function() {
[10:26:06.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.399]                       search = base::search(), system = base::Sys.info())
[10:26:06.399]                   }
[10:26:06.399]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.399]                     cond$call), session = sessionInformation(), 
[10:26:06.399]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.399]                   signalCondition(cond)
[10:26:06.399]                 }
[10:26:06.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.399]                 "immediateCondition"))) {
[10:26:06.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.399]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.399]                   if (TRUE && !signal) {
[10:26:06.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.399]                     {
[10:26:06.399]                       inherits <- base::inherits
[10:26:06.399]                       invokeRestart <- base::invokeRestart
[10:26:06.399]                       is.null <- base::is.null
[10:26:06.399]                       muffled <- FALSE
[10:26:06.399]                       if (inherits(cond, "message")) {
[10:26:06.399]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.399]                         if (muffled) 
[10:26:06.399]                           invokeRestart("muffleMessage")
[10:26:06.399]                       }
[10:26:06.399]                       else if (inherits(cond, "warning")) {
[10:26:06.399]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.399]                         if (muffled) 
[10:26:06.399]                           invokeRestart("muffleWarning")
[10:26:06.399]                       }
[10:26:06.399]                       else if (inherits(cond, "condition")) {
[10:26:06.399]                         if (!is.null(pattern)) {
[10:26:06.399]                           computeRestarts <- base::computeRestarts
[10:26:06.399]                           grepl <- base::grepl
[10:26:06.399]                           restarts <- computeRestarts(cond)
[10:26:06.399]                           for (restart in restarts) {
[10:26:06.399]                             name <- restart$name
[10:26:06.399]                             if (is.null(name)) 
[10:26:06.399]                               next
[10:26:06.399]                             if (!grepl(pattern, name)) 
[10:26:06.399]                               next
[10:26:06.399]                             invokeRestart(restart)
[10:26:06.399]                             muffled <- TRUE
[10:26:06.399]                             break
[10:26:06.399]                           }
[10:26:06.399]                         }
[10:26:06.399]                       }
[10:26:06.399]                       invisible(muffled)
[10:26:06.399]                     }
[10:26:06.399]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.399]                   }
[10:26:06.399]                 }
[10:26:06.399]                 else {
[10:26:06.399]                   if (TRUE) {
[10:26:06.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.399]                     {
[10:26:06.399]                       inherits <- base::inherits
[10:26:06.399]                       invokeRestart <- base::invokeRestart
[10:26:06.399]                       is.null <- base::is.null
[10:26:06.399]                       muffled <- FALSE
[10:26:06.399]                       if (inherits(cond, "message")) {
[10:26:06.399]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.399]                         if (muffled) 
[10:26:06.399]                           invokeRestart("muffleMessage")
[10:26:06.399]                       }
[10:26:06.399]                       else if (inherits(cond, "warning")) {
[10:26:06.399]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.399]                         if (muffled) 
[10:26:06.399]                           invokeRestart("muffleWarning")
[10:26:06.399]                       }
[10:26:06.399]                       else if (inherits(cond, "condition")) {
[10:26:06.399]                         if (!is.null(pattern)) {
[10:26:06.399]                           computeRestarts <- base::computeRestarts
[10:26:06.399]                           grepl <- base::grepl
[10:26:06.399]                           restarts <- computeRestarts(cond)
[10:26:06.399]                           for (restart in restarts) {
[10:26:06.399]                             name <- restart$name
[10:26:06.399]                             if (is.null(name)) 
[10:26:06.399]                               next
[10:26:06.399]                             if (!grepl(pattern, name)) 
[10:26:06.399]                               next
[10:26:06.399]                             invokeRestart(restart)
[10:26:06.399]                             muffled <- TRUE
[10:26:06.399]                             break
[10:26:06.399]                           }
[10:26:06.399]                         }
[10:26:06.399]                       }
[10:26:06.399]                       invisible(muffled)
[10:26:06.399]                     }
[10:26:06.399]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.399]                   }
[10:26:06.399]                 }
[10:26:06.399]             }
[10:26:06.399]         }))
[10:26:06.399]     }, error = function(ex) {
[10:26:06.399]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.399]                 ...future.rng), started = ...future.startTime, 
[10:26:06.399]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.399]             version = "1.8"), class = "FutureResult")
[10:26:06.399]     }, finally = {
[10:26:06.399]         if (!identical(...future.workdir, getwd())) 
[10:26:06.399]             setwd(...future.workdir)
[10:26:06.399]         {
[10:26:06.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.399]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.399]             }
[10:26:06.399]             base::options(...future.oldOptions)
[10:26:06.399]             if (.Platform$OS.type == "windows") {
[10:26:06.399]                 old_names <- names(...future.oldEnvVars)
[10:26:06.399]                 envs <- base::Sys.getenv()
[10:26:06.399]                 names <- names(envs)
[10:26:06.399]                 common <- intersect(names, old_names)
[10:26:06.399]                 added <- setdiff(names, old_names)
[10:26:06.399]                 removed <- setdiff(old_names, names)
[10:26:06.399]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.399]                   envs[common]]
[10:26:06.399]                 NAMES <- toupper(changed)
[10:26:06.399]                 args <- list()
[10:26:06.399]                 for (kk in seq_along(NAMES)) {
[10:26:06.399]                   name <- changed[[kk]]
[10:26:06.399]                   NAME <- NAMES[[kk]]
[10:26:06.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.399]                     next
[10:26:06.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.399]                 }
[10:26:06.399]                 NAMES <- toupper(added)
[10:26:06.399]                 for (kk in seq_along(NAMES)) {
[10:26:06.399]                   name <- added[[kk]]
[10:26:06.399]                   NAME <- NAMES[[kk]]
[10:26:06.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.399]                     next
[10:26:06.399]                   args[[name]] <- ""
[10:26:06.399]                 }
[10:26:06.399]                 NAMES <- toupper(removed)
[10:26:06.399]                 for (kk in seq_along(NAMES)) {
[10:26:06.399]                   name <- removed[[kk]]
[10:26:06.399]                   NAME <- NAMES[[kk]]
[10:26:06.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.399]                     next
[10:26:06.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.399]                 }
[10:26:06.399]                 if (length(args) > 0) 
[10:26:06.399]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.399]             }
[10:26:06.399]             else {
[10:26:06.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.399]             }
[10:26:06.399]             {
[10:26:06.399]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.399]                   0L) {
[10:26:06.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.399]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.399]                   base::options(opts)
[10:26:06.399]                 }
[10:26:06.399]                 {
[10:26:06.399]                   {
[10:26:06.399]                     NULL
[10:26:06.399]                     RNGkind("Mersenne-Twister")
[10:26:06.399]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:06.399]                       inherits = FALSE)
[10:26:06.399]                   }
[10:26:06.399]                   options(future.plan = NULL)
[10:26:06.399]                   if (is.na(NA_character_)) 
[10:26:06.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.399]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:06.399]                   {
[10:26:06.399]                     future <- SequentialFuture(..., envir = envir)
[10:26:06.399]                     if (!future$lazy) 
[10:26:06.399]                       future <- run(future)
[10:26:06.399]                     invisible(future)
[10:26:06.399]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.399]                 }
[10:26:06.399]             }
[10:26:06.399]         }
[10:26:06.399]     })
[10:26:06.399]     if (TRUE) {
[10:26:06.399]         base::sink(type = "output", split = FALSE)
[10:26:06.399]         if (TRUE) {
[10:26:06.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.399]         }
[10:26:06.399]         else {
[10:26:06.399]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.399]         }
[10:26:06.399]         base::close(...future.stdout)
[10:26:06.399]         ...future.stdout <- NULL
[10:26:06.399]     }
[10:26:06.399]     ...future.result$conditions <- ...future.conditions
[10:26:06.399]     ...future.result$finished <- base::Sys.time()
[10:26:06.399]     ...future.result
[10:26:06.399] }
[10:26:06.401] assign_globals() ...
[10:26:06.401] List of 1
[10:26:06.401]  $ x: list()
[10:26:06.401]  - attr(*, "where")=List of 1
[10:26:06.401]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.401]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.401]  - attr(*, "resolved")= logi TRUE
[10:26:06.401]  - attr(*, "total_size")= num 0
[10:26:06.401]  - attr(*, "already-done")= logi TRUE
[10:26:06.403] - copied ‘x’ to environment
[10:26:06.403] assign_globals() ... done
[10:26:06.404] plan(): Setting new future strategy stack:
[10:26:06.404] List of future strategies:
[10:26:06.404] 1. sequential:
[10:26:06.404]    - args: function (..., envir = parent.frame())
[10:26:06.404]    - tweaked: FALSE
[10:26:06.404]    - call: NULL
[10:26:06.404] plan(): nbrOfWorkers() = 1
[10:26:06.405] plan(): Setting new future strategy stack:
[10:26:06.405] List of future strategies:
[10:26:06.405] 1. sequential:
[10:26:06.405]    - args: function (..., envir = parent.frame())
[10:26:06.405]    - tweaked: FALSE
[10:26:06.405]    - call: plan(strategy)
[10:26:06.405] plan(): nbrOfWorkers() = 1
[10:26:06.405] SequentialFuture started (and completed)
[10:26:06.406] - Launch lazy future ... done
[10:26:06.406] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.406] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.406] Searching for globals...
[10:26:06.408] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:06.408] Searching for globals ... DONE
[10:26:06.408] Resolving globals: TRUE
[10:26:06.408] Resolving any globals that are futures ...
[10:26:06.408] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:06.408] Resolving any globals that are futures ... DONE
[10:26:06.409] Resolving futures part of globals (recursively) ...
[10:26:06.409] resolve() on list ...
[10:26:06.409]  recursive: 99
[10:26:06.409]  length: 1
[10:26:06.409]  elements: ‘x’
[10:26:06.409]  length: 0 (resolved future 1)
[10:26:06.409] resolve() on list ... DONE
[10:26:06.409] - globals: [1] ‘x’
[10:26:06.410] Resolving futures part of globals (recursively) ... DONE
[10:26:06.410] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.410] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.410] - globals: [1] ‘x’
[10:26:06.410] 
[10:26:06.410] getGlobalsAndPackages() ... DONE
[10:26:06.411] run() for ‘Future’ ...
[10:26:06.411] - state: ‘created’
[10:26:06.411] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:06.411] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:06.411] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:06.411]   - Field: ‘label’
[10:26:06.411]   - Field: ‘local’
[10:26:06.411]   - Field: ‘owner’
[10:26:06.412]   - Field: ‘envir’
[10:26:06.412]   - Field: ‘packages’
[10:26:06.412]   - Field: ‘gc’
[10:26:06.412]   - Field: ‘conditions’
[10:26:06.412]   - Field: ‘expr’
[10:26:06.412]   - Field: ‘uuid’
[10:26:06.412]   - Field: ‘seed’
[10:26:06.412]   - Field: ‘version’
[10:26:06.412]   - Field: ‘result’
[10:26:06.412]   - Field: ‘asynchronous’
[10:26:06.412]   - Field: ‘calls’
[10:26:06.412]   - Field: ‘globals’
[10:26:06.413]   - Field: ‘stdout’
[10:26:06.413]   - Field: ‘earlySignal’
[10:26:06.413]   - Field: ‘lazy’
[10:26:06.413]   - Field: ‘state’
[10:26:06.413] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:06.413] - Launch lazy future ...
[10:26:06.413] Packages needed by the future expression (n = 0): <none>
[10:26:06.413] Packages needed by future strategies (n = 0): <none>
[10:26:06.414] {
[10:26:06.414]     {
[10:26:06.414]         {
[10:26:06.414]             ...future.startTime <- base::Sys.time()
[10:26:06.414]             {
[10:26:06.414]                 {
[10:26:06.414]                   {
[10:26:06.414]                     base::local({
[10:26:06.414]                       has_future <- base::requireNamespace("future", 
[10:26:06.414]                         quietly = TRUE)
[10:26:06.414]                       if (has_future) {
[10:26:06.414]                         ns <- base::getNamespace("future")
[10:26:06.414]                         version <- ns[[".package"]][["version"]]
[10:26:06.414]                         if (is.null(version)) 
[10:26:06.414]                           version <- utils::packageVersion("future")
[10:26:06.414]                       }
[10:26:06.414]                       else {
[10:26:06.414]                         version <- NULL
[10:26:06.414]                       }
[10:26:06.414]                       if (!has_future || version < "1.8.0") {
[10:26:06.414]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.414]                           "", base::R.version$version.string), 
[10:26:06.414]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:06.414]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.414]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.414]                             "release", "version")], collapse = " "), 
[10:26:06.414]                           hostname = base::Sys.info()[["nodename"]])
[10:26:06.414]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.414]                           info)
[10:26:06.414]                         info <- base::paste(info, collapse = "; ")
[10:26:06.414]                         if (!has_future) {
[10:26:06.414]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.414]                             info)
[10:26:06.414]                         }
[10:26:06.414]                         else {
[10:26:06.414]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.414]                             info, version)
[10:26:06.414]                         }
[10:26:06.414]                         base::stop(msg)
[10:26:06.414]                       }
[10:26:06.414]                     })
[10:26:06.414]                   }
[10:26:06.414]                   options(future.plan = NULL)
[10:26:06.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.414]                 }
[10:26:06.414]                 ...future.workdir <- getwd()
[10:26:06.414]             }
[10:26:06.414]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.414]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.414]         }
[10:26:06.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.414]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.414]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.414]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.414]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.414]             base::names(...future.oldOptions))
[10:26:06.414]     }
[10:26:06.414]     if (FALSE) {
[10:26:06.414]     }
[10:26:06.414]     else {
[10:26:06.414]         if (TRUE) {
[10:26:06.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.414]                 open = "w")
[10:26:06.414]         }
[10:26:06.414]         else {
[10:26:06.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.414]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.414]         }
[10:26:06.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.414]             base::sink(type = "output", split = FALSE)
[10:26:06.414]             base::close(...future.stdout)
[10:26:06.414]         }, add = TRUE)
[10:26:06.414]     }
[10:26:06.414]     ...future.frame <- base::sys.nframe()
[10:26:06.414]     ...future.conditions <- base::list()
[10:26:06.414]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.414]     if (FALSE) {
[10:26:06.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.414]     }
[10:26:06.414]     ...future.result <- base::tryCatch({
[10:26:06.414]         base::withCallingHandlers({
[10:26:06.414]             ...future.value <- base::withVisible(base::local({
[10:26:06.414]                 x[["a"]] <- 1
[10:26:06.414]                 x
[10:26:06.414]             }))
[10:26:06.414]             future::FutureResult(value = ...future.value$value, 
[10:26:06.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.414]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.414]                     ...future.globalenv.names))
[10:26:06.414]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.414]         }, condition = base::local({
[10:26:06.414]             c <- base::c
[10:26:06.414]             inherits <- base::inherits
[10:26:06.414]             invokeRestart <- base::invokeRestart
[10:26:06.414]             length <- base::length
[10:26:06.414]             list <- base::list
[10:26:06.414]             seq.int <- base::seq.int
[10:26:06.414]             signalCondition <- base::signalCondition
[10:26:06.414]             sys.calls <- base::sys.calls
[10:26:06.414]             `[[` <- base::`[[`
[10:26:06.414]             `+` <- base::`+`
[10:26:06.414]             `<<-` <- base::`<<-`
[10:26:06.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.414]                   3L)]
[10:26:06.414]             }
[10:26:06.414]             function(cond) {
[10:26:06.414]                 is_error <- inherits(cond, "error")
[10:26:06.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.414]                   NULL)
[10:26:06.414]                 if (is_error) {
[10:26:06.414]                   sessionInformation <- function() {
[10:26:06.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.414]                       search = base::search(), system = base::Sys.info())
[10:26:06.414]                   }
[10:26:06.414]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.414]                     cond$call), session = sessionInformation(), 
[10:26:06.414]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.414]                   signalCondition(cond)
[10:26:06.414]                 }
[10:26:06.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.414]                 "immediateCondition"))) {
[10:26:06.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.414]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.414]                   if (TRUE && !signal) {
[10:26:06.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.414]                     {
[10:26:06.414]                       inherits <- base::inherits
[10:26:06.414]                       invokeRestart <- base::invokeRestart
[10:26:06.414]                       is.null <- base::is.null
[10:26:06.414]                       muffled <- FALSE
[10:26:06.414]                       if (inherits(cond, "message")) {
[10:26:06.414]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.414]                         if (muffled) 
[10:26:06.414]                           invokeRestart("muffleMessage")
[10:26:06.414]                       }
[10:26:06.414]                       else if (inherits(cond, "warning")) {
[10:26:06.414]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.414]                         if (muffled) 
[10:26:06.414]                           invokeRestart("muffleWarning")
[10:26:06.414]                       }
[10:26:06.414]                       else if (inherits(cond, "condition")) {
[10:26:06.414]                         if (!is.null(pattern)) {
[10:26:06.414]                           computeRestarts <- base::computeRestarts
[10:26:06.414]                           grepl <- base::grepl
[10:26:06.414]                           restarts <- computeRestarts(cond)
[10:26:06.414]                           for (restart in restarts) {
[10:26:06.414]                             name <- restart$name
[10:26:06.414]                             if (is.null(name)) 
[10:26:06.414]                               next
[10:26:06.414]                             if (!grepl(pattern, name)) 
[10:26:06.414]                               next
[10:26:06.414]                             invokeRestart(restart)
[10:26:06.414]                             muffled <- TRUE
[10:26:06.414]                             break
[10:26:06.414]                           }
[10:26:06.414]                         }
[10:26:06.414]                       }
[10:26:06.414]                       invisible(muffled)
[10:26:06.414]                     }
[10:26:06.414]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.414]                   }
[10:26:06.414]                 }
[10:26:06.414]                 else {
[10:26:06.414]                   if (TRUE) {
[10:26:06.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.414]                     {
[10:26:06.414]                       inherits <- base::inherits
[10:26:06.414]                       invokeRestart <- base::invokeRestart
[10:26:06.414]                       is.null <- base::is.null
[10:26:06.414]                       muffled <- FALSE
[10:26:06.414]                       if (inherits(cond, "message")) {
[10:26:06.414]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.414]                         if (muffled) 
[10:26:06.414]                           invokeRestart("muffleMessage")
[10:26:06.414]                       }
[10:26:06.414]                       else if (inherits(cond, "warning")) {
[10:26:06.414]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.414]                         if (muffled) 
[10:26:06.414]                           invokeRestart("muffleWarning")
[10:26:06.414]                       }
[10:26:06.414]                       else if (inherits(cond, "condition")) {
[10:26:06.414]                         if (!is.null(pattern)) {
[10:26:06.414]                           computeRestarts <- base::computeRestarts
[10:26:06.414]                           grepl <- base::grepl
[10:26:06.414]                           restarts <- computeRestarts(cond)
[10:26:06.414]                           for (restart in restarts) {
[10:26:06.414]                             name <- restart$name
[10:26:06.414]                             if (is.null(name)) 
[10:26:06.414]                               next
[10:26:06.414]                             if (!grepl(pattern, name)) 
[10:26:06.414]                               next
[10:26:06.414]                             invokeRestart(restart)
[10:26:06.414]                             muffled <- TRUE
[10:26:06.414]                             break
[10:26:06.414]                           }
[10:26:06.414]                         }
[10:26:06.414]                       }
[10:26:06.414]                       invisible(muffled)
[10:26:06.414]                     }
[10:26:06.414]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.414]                   }
[10:26:06.414]                 }
[10:26:06.414]             }
[10:26:06.414]         }))
[10:26:06.414]     }, error = function(ex) {
[10:26:06.414]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.414]                 ...future.rng), started = ...future.startTime, 
[10:26:06.414]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.414]             version = "1.8"), class = "FutureResult")
[10:26:06.414]     }, finally = {
[10:26:06.414]         if (!identical(...future.workdir, getwd())) 
[10:26:06.414]             setwd(...future.workdir)
[10:26:06.414]         {
[10:26:06.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.414]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.414]             }
[10:26:06.414]             base::options(...future.oldOptions)
[10:26:06.414]             if (.Platform$OS.type == "windows") {
[10:26:06.414]                 old_names <- names(...future.oldEnvVars)
[10:26:06.414]                 envs <- base::Sys.getenv()
[10:26:06.414]                 names <- names(envs)
[10:26:06.414]                 common <- intersect(names, old_names)
[10:26:06.414]                 added <- setdiff(names, old_names)
[10:26:06.414]                 removed <- setdiff(old_names, names)
[10:26:06.414]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.414]                   envs[common]]
[10:26:06.414]                 NAMES <- toupper(changed)
[10:26:06.414]                 args <- list()
[10:26:06.414]                 for (kk in seq_along(NAMES)) {
[10:26:06.414]                   name <- changed[[kk]]
[10:26:06.414]                   NAME <- NAMES[[kk]]
[10:26:06.414]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.414]                     next
[10:26:06.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.414]                 }
[10:26:06.414]                 NAMES <- toupper(added)
[10:26:06.414]                 for (kk in seq_along(NAMES)) {
[10:26:06.414]                   name <- added[[kk]]
[10:26:06.414]                   NAME <- NAMES[[kk]]
[10:26:06.414]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.414]                     next
[10:26:06.414]                   args[[name]] <- ""
[10:26:06.414]                 }
[10:26:06.414]                 NAMES <- toupper(removed)
[10:26:06.414]                 for (kk in seq_along(NAMES)) {
[10:26:06.414]                   name <- removed[[kk]]
[10:26:06.414]                   NAME <- NAMES[[kk]]
[10:26:06.414]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.414]                     next
[10:26:06.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.414]                 }
[10:26:06.414]                 if (length(args) > 0) 
[10:26:06.414]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.414]             }
[10:26:06.414]             else {
[10:26:06.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.414]             }
[10:26:06.414]             {
[10:26:06.414]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.414]                   0L) {
[10:26:06.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.414]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.414]                   base::options(opts)
[10:26:06.414]                 }
[10:26:06.414]                 {
[10:26:06.414]                   {
[10:26:06.414]                     NULL
[10:26:06.414]                     RNGkind("Mersenne-Twister")
[10:26:06.414]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:06.414]                       inherits = FALSE)
[10:26:06.414]                   }
[10:26:06.414]                   options(future.plan = NULL)
[10:26:06.414]                   if (is.na(NA_character_)) 
[10:26:06.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.414]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:06.414]                   {
[10:26:06.414]                     future <- SequentialFuture(..., envir = envir)
[10:26:06.414]                     if (!future$lazy) 
[10:26:06.414]                       future <- run(future)
[10:26:06.414]                     invisible(future)
[10:26:06.414]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.414]                 }
[10:26:06.414]             }
[10:26:06.414]         }
[10:26:06.414]     })
[10:26:06.414]     if (TRUE) {
[10:26:06.414]         base::sink(type = "output", split = FALSE)
[10:26:06.414]         if (TRUE) {
[10:26:06.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.414]         }
[10:26:06.414]         else {
[10:26:06.414]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.414]         }
[10:26:06.414]         base::close(...future.stdout)
[10:26:06.414]         ...future.stdout <- NULL
[10:26:06.414]     }
[10:26:06.414]     ...future.result$conditions <- ...future.conditions
[10:26:06.414]     ...future.result$finished <- base::Sys.time()
[10:26:06.414]     ...future.result
[10:26:06.414] }
[10:26:06.415] assign_globals() ...
[10:26:06.415] List of 1
[10:26:06.415]  $ x: list()
[10:26:06.415]  - attr(*, "where")=List of 1
[10:26:06.415]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.415]  - attr(*, "resolved")= logi TRUE
[10:26:06.415]  - attr(*, "total_size")= num 0
[10:26:06.415]  - attr(*, "already-done")= logi TRUE
[10:26:06.417] - copied ‘x’ to environment
[10:26:06.419] assign_globals() ... done
[10:26:06.419] plan(): Setting new future strategy stack:
[10:26:06.419] List of future strategies:
[10:26:06.419] 1. sequential:
[10:26:06.419]    - args: function (..., envir = parent.frame())
[10:26:06.419]    - tweaked: FALSE
[10:26:06.419]    - call: NULL
[10:26:06.419] plan(): nbrOfWorkers() = 1
[10:26:06.420] plan(): Setting new future strategy stack:
[10:26:06.420] List of future strategies:
[10:26:06.420] 1. sequential:
[10:26:06.420]    - args: function (..., envir = parent.frame())
[10:26:06.420]    - tweaked: FALSE
[10:26:06.420]    - call: plan(strategy)
[10:26:06.420] plan(): nbrOfWorkers() = 1
[10:26:06.420] SequentialFuture started (and completed)
[10:26:06.421] - Launch lazy future ... done
[10:26:06.421] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.421] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.421] Searching for globals...
[10:26:06.423] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:06.423] Searching for globals ... DONE
[10:26:06.423] Resolving globals: TRUE
[10:26:06.423] Resolving any globals that are futures ...
[10:26:06.424] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:06.424] Resolving any globals that are futures ... DONE
[10:26:06.424] Resolving futures part of globals (recursively) ...
[10:26:06.424] resolve() on list ...
[10:26:06.424]  recursive: 99
[10:26:06.424]  length: 1
[10:26:06.424]  elements: ‘x’
[10:26:06.425]  length: 0 (resolved future 1)
[10:26:06.425] resolve() on list ... DONE
[10:26:06.425] - globals: [1] ‘x’
[10:26:06.425] Resolving futures part of globals (recursively) ... DONE
[10:26:06.425] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.425] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.425] - globals: [1] ‘x’
[10:26:06.425] 
[10:26:06.426] getGlobalsAndPackages() ... DONE
[10:26:06.426] run() for ‘Future’ ...
[10:26:06.426] - state: ‘created’
[10:26:06.426] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:06.426] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:06.426] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:06.426]   - Field: ‘label’
[10:26:06.426]   - Field: ‘local’
[10:26:06.427]   - Field: ‘owner’
[10:26:06.427]   - Field: ‘envir’
[10:26:06.427]   - Field: ‘packages’
[10:26:06.427]   - Field: ‘gc’
[10:26:06.427]   - Field: ‘conditions’
[10:26:06.427]   - Field: ‘expr’
[10:26:06.427]   - Field: ‘uuid’
[10:26:06.427]   - Field: ‘seed’
[10:26:06.427]   - Field: ‘version’
[10:26:06.427]   - Field: ‘result’
[10:26:06.427]   - Field: ‘asynchronous’
[10:26:06.428]   - Field: ‘calls’
[10:26:06.428]   - Field: ‘globals’
[10:26:06.428]   - Field: ‘stdout’
[10:26:06.428]   - Field: ‘earlySignal’
[10:26:06.428]   - Field: ‘lazy’
[10:26:06.428]   - Field: ‘state’
[10:26:06.428] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:06.428] - Launch lazy future ...
[10:26:06.428] Packages needed by the future expression (n = 0): <none>
[10:26:06.428] Packages needed by future strategies (n = 0): <none>
[10:26:06.429] {
[10:26:06.429]     {
[10:26:06.429]         {
[10:26:06.429]             ...future.startTime <- base::Sys.time()
[10:26:06.429]             {
[10:26:06.429]                 {
[10:26:06.429]                   {
[10:26:06.429]                     base::local({
[10:26:06.429]                       has_future <- base::requireNamespace("future", 
[10:26:06.429]                         quietly = TRUE)
[10:26:06.429]                       if (has_future) {
[10:26:06.429]                         ns <- base::getNamespace("future")
[10:26:06.429]                         version <- ns[[".package"]][["version"]]
[10:26:06.429]                         if (is.null(version)) 
[10:26:06.429]                           version <- utils::packageVersion("future")
[10:26:06.429]                       }
[10:26:06.429]                       else {
[10:26:06.429]                         version <- NULL
[10:26:06.429]                       }
[10:26:06.429]                       if (!has_future || version < "1.8.0") {
[10:26:06.429]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.429]                           "", base::R.version$version.string), 
[10:26:06.429]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:06.429]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.429]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.429]                             "release", "version")], collapse = " "), 
[10:26:06.429]                           hostname = base::Sys.info()[["nodename"]])
[10:26:06.429]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.429]                           info)
[10:26:06.429]                         info <- base::paste(info, collapse = "; ")
[10:26:06.429]                         if (!has_future) {
[10:26:06.429]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.429]                             info)
[10:26:06.429]                         }
[10:26:06.429]                         else {
[10:26:06.429]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.429]                             info, version)
[10:26:06.429]                         }
[10:26:06.429]                         base::stop(msg)
[10:26:06.429]                       }
[10:26:06.429]                     })
[10:26:06.429]                   }
[10:26:06.429]                   options(future.plan = NULL)
[10:26:06.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.429]                 }
[10:26:06.429]                 ...future.workdir <- getwd()
[10:26:06.429]             }
[10:26:06.429]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.429]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.429]         }
[10:26:06.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.429]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.429]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.429]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.429]             base::names(...future.oldOptions))
[10:26:06.429]     }
[10:26:06.429]     if (FALSE) {
[10:26:06.429]     }
[10:26:06.429]     else {
[10:26:06.429]         if (TRUE) {
[10:26:06.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.429]                 open = "w")
[10:26:06.429]         }
[10:26:06.429]         else {
[10:26:06.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.429]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.429]         }
[10:26:06.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.429]             base::sink(type = "output", split = FALSE)
[10:26:06.429]             base::close(...future.stdout)
[10:26:06.429]         }, add = TRUE)
[10:26:06.429]     }
[10:26:06.429]     ...future.frame <- base::sys.nframe()
[10:26:06.429]     ...future.conditions <- base::list()
[10:26:06.429]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.429]     if (FALSE) {
[10:26:06.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.429]     }
[10:26:06.429]     ...future.result <- base::tryCatch({
[10:26:06.429]         base::withCallingHandlers({
[10:26:06.429]             ...future.value <- base::withVisible(base::local({
[10:26:06.429]                 x["a"] <- list(1)
[10:26:06.429]                 x
[10:26:06.429]             }))
[10:26:06.429]             future::FutureResult(value = ...future.value$value, 
[10:26:06.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.429]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.429]                     ...future.globalenv.names))
[10:26:06.429]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.429]         }, condition = base::local({
[10:26:06.429]             c <- base::c
[10:26:06.429]             inherits <- base::inherits
[10:26:06.429]             invokeRestart <- base::invokeRestart
[10:26:06.429]             length <- base::length
[10:26:06.429]             list <- base::list
[10:26:06.429]             seq.int <- base::seq.int
[10:26:06.429]             signalCondition <- base::signalCondition
[10:26:06.429]             sys.calls <- base::sys.calls
[10:26:06.429]             `[[` <- base::`[[`
[10:26:06.429]             `+` <- base::`+`
[10:26:06.429]             `<<-` <- base::`<<-`
[10:26:06.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.429]                   3L)]
[10:26:06.429]             }
[10:26:06.429]             function(cond) {
[10:26:06.429]                 is_error <- inherits(cond, "error")
[10:26:06.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.429]                   NULL)
[10:26:06.429]                 if (is_error) {
[10:26:06.429]                   sessionInformation <- function() {
[10:26:06.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.429]                       search = base::search(), system = base::Sys.info())
[10:26:06.429]                   }
[10:26:06.429]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.429]                     cond$call), session = sessionInformation(), 
[10:26:06.429]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.429]                   signalCondition(cond)
[10:26:06.429]                 }
[10:26:06.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.429]                 "immediateCondition"))) {
[10:26:06.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.429]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.429]                   if (TRUE && !signal) {
[10:26:06.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.429]                     {
[10:26:06.429]                       inherits <- base::inherits
[10:26:06.429]                       invokeRestart <- base::invokeRestart
[10:26:06.429]                       is.null <- base::is.null
[10:26:06.429]                       muffled <- FALSE
[10:26:06.429]                       if (inherits(cond, "message")) {
[10:26:06.429]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.429]                         if (muffled) 
[10:26:06.429]                           invokeRestart("muffleMessage")
[10:26:06.429]                       }
[10:26:06.429]                       else if (inherits(cond, "warning")) {
[10:26:06.429]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.429]                         if (muffled) 
[10:26:06.429]                           invokeRestart("muffleWarning")
[10:26:06.429]                       }
[10:26:06.429]                       else if (inherits(cond, "condition")) {
[10:26:06.429]                         if (!is.null(pattern)) {
[10:26:06.429]                           computeRestarts <- base::computeRestarts
[10:26:06.429]                           grepl <- base::grepl
[10:26:06.429]                           restarts <- computeRestarts(cond)
[10:26:06.429]                           for (restart in restarts) {
[10:26:06.429]                             name <- restart$name
[10:26:06.429]                             if (is.null(name)) 
[10:26:06.429]                               next
[10:26:06.429]                             if (!grepl(pattern, name)) 
[10:26:06.429]                               next
[10:26:06.429]                             invokeRestart(restart)
[10:26:06.429]                             muffled <- TRUE
[10:26:06.429]                             break
[10:26:06.429]                           }
[10:26:06.429]                         }
[10:26:06.429]                       }
[10:26:06.429]                       invisible(muffled)
[10:26:06.429]                     }
[10:26:06.429]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.429]                   }
[10:26:06.429]                 }
[10:26:06.429]                 else {
[10:26:06.429]                   if (TRUE) {
[10:26:06.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.429]                     {
[10:26:06.429]                       inherits <- base::inherits
[10:26:06.429]                       invokeRestart <- base::invokeRestart
[10:26:06.429]                       is.null <- base::is.null
[10:26:06.429]                       muffled <- FALSE
[10:26:06.429]                       if (inherits(cond, "message")) {
[10:26:06.429]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.429]                         if (muffled) 
[10:26:06.429]                           invokeRestart("muffleMessage")
[10:26:06.429]                       }
[10:26:06.429]                       else if (inherits(cond, "warning")) {
[10:26:06.429]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.429]                         if (muffled) 
[10:26:06.429]                           invokeRestart("muffleWarning")
[10:26:06.429]                       }
[10:26:06.429]                       else if (inherits(cond, "condition")) {
[10:26:06.429]                         if (!is.null(pattern)) {
[10:26:06.429]                           computeRestarts <- base::computeRestarts
[10:26:06.429]                           grepl <- base::grepl
[10:26:06.429]                           restarts <- computeRestarts(cond)
[10:26:06.429]                           for (restart in restarts) {
[10:26:06.429]                             name <- restart$name
[10:26:06.429]                             if (is.null(name)) 
[10:26:06.429]                               next
[10:26:06.429]                             if (!grepl(pattern, name)) 
[10:26:06.429]                               next
[10:26:06.429]                             invokeRestart(restart)
[10:26:06.429]                             muffled <- TRUE
[10:26:06.429]                             break
[10:26:06.429]                           }
[10:26:06.429]                         }
[10:26:06.429]                       }
[10:26:06.429]                       invisible(muffled)
[10:26:06.429]                     }
[10:26:06.429]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.429]                   }
[10:26:06.429]                 }
[10:26:06.429]             }
[10:26:06.429]         }))
[10:26:06.429]     }, error = function(ex) {
[10:26:06.429]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.429]                 ...future.rng), started = ...future.startTime, 
[10:26:06.429]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.429]             version = "1.8"), class = "FutureResult")
[10:26:06.429]     }, finally = {
[10:26:06.429]         if (!identical(...future.workdir, getwd())) 
[10:26:06.429]             setwd(...future.workdir)
[10:26:06.429]         {
[10:26:06.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.429]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.429]             }
[10:26:06.429]             base::options(...future.oldOptions)
[10:26:06.429]             if (.Platform$OS.type == "windows") {
[10:26:06.429]                 old_names <- names(...future.oldEnvVars)
[10:26:06.429]                 envs <- base::Sys.getenv()
[10:26:06.429]                 names <- names(envs)
[10:26:06.429]                 common <- intersect(names, old_names)
[10:26:06.429]                 added <- setdiff(names, old_names)
[10:26:06.429]                 removed <- setdiff(old_names, names)
[10:26:06.429]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.429]                   envs[common]]
[10:26:06.429]                 NAMES <- toupper(changed)
[10:26:06.429]                 args <- list()
[10:26:06.429]                 for (kk in seq_along(NAMES)) {
[10:26:06.429]                   name <- changed[[kk]]
[10:26:06.429]                   NAME <- NAMES[[kk]]
[10:26:06.429]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.429]                     next
[10:26:06.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.429]                 }
[10:26:06.429]                 NAMES <- toupper(added)
[10:26:06.429]                 for (kk in seq_along(NAMES)) {
[10:26:06.429]                   name <- added[[kk]]
[10:26:06.429]                   NAME <- NAMES[[kk]]
[10:26:06.429]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.429]                     next
[10:26:06.429]                   args[[name]] <- ""
[10:26:06.429]                 }
[10:26:06.429]                 NAMES <- toupper(removed)
[10:26:06.429]                 for (kk in seq_along(NAMES)) {
[10:26:06.429]                   name <- removed[[kk]]
[10:26:06.429]                   NAME <- NAMES[[kk]]
[10:26:06.429]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.429]                     next
[10:26:06.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.429]                 }
[10:26:06.429]                 if (length(args) > 0) 
[10:26:06.429]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.429]             }
[10:26:06.429]             else {
[10:26:06.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.429]             }
[10:26:06.429]             {
[10:26:06.429]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.429]                   0L) {
[10:26:06.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.429]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.429]                   base::options(opts)
[10:26:06.429]                 }
[10:26:06.429]                 {
[10:26:06.429]                   {
[10:26:06.429]                     NULL
[10:26:06.429]                     RNGkind("Mersenne-Twister")
[10:26:06.429]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:06.429]                       inherits = FALSE)
[10:26:06.429]                   }
[10:26:06.429]                   options(future.plan = NULL)
[10:26:06.429]                   if (is.na(NA_character_)) 
[10:26:06.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.429]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:06.429]                   {
[10:26:06.429]                     future <- SequentialFuture(..., envir = envir)
[10:26:06.429]                     if (!future$lazy) 
[10:26:06.429]                       future <- run(future)
[10:26:06.429]                     invisible(future)
[10:26:06.429]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.429]                 }
[10:26:06.429]             }
[10:26:06.429]         }
[10:26:06.429]     })
[10:26:06.429]     if (TRUE) {
[10:26:06.429]         base::sink(type = "output", split = FALSE)
[10:26:06.429]         if (TRUE) {
[10:26:06.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.429]         }
[10:26:06.429]         else {
[10:26:06.429]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.429]         }
[10:26:06.429]         base::close(...future.stdout)
[10:26:06.429]         ...future.stdout <- NULL
[10:26:06.429]     }
[10:26:06.429]     ...future.result$conditions <- ...future.conditions
[10:26:06.429]     ...future.result$finished <- base::Sys.time()
[10:26:06.429]     ...future.result
[10:26:06.429] }
[10:26:06.430] assign_globals() ...
[10:26:06.431] List of 1
[10:26:06.431]  $ x: list()
[10:26:06.431]  - attr(*, "where")=List of 1
[10:26:06.431]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.431]  - attr(*, "resolved")= logi TRUE
[10:26:06.431]  - attr(*, "total_size")= num 0
[10:26:06.431]  - attr(*, "already-done")= logi TRUE
[10:26:06.433] - copied ‘x’ to environment
[10:26:06.433] assign_globals() ... done
[10:26:06.433] plan(): Setting new future strategy stack:
[10:26:06.433] List of future strategies:
[10:26:06.433] 1. sequential:
[10:26:06.433]    - args: function (..., envir = parent.frame())
[10:26:06.433]    - tweaked: FALSE
[10:26:06.433]    - call: NULL
[10:26:06.433] plan(): nbrOfWorkers() = 1
[10:26:06.434] plan(): Setting new future strategy stack:
[10:26:06.434] List of future strategies:
[10:26:06.434] 1. sequential:
[10:26:06.434]    - args: function (..., envir = parent.frame())
[10:26:06.434]    - tweaked: FALSE
[10:26:06.434]    - call: plan(strategy)
[10:26:06.435] plan(): nbrOfWorkers() = 1
[10:26:06.435] SequentialFuture started (and completed)
[10:26:06.435] - Launch lazy future ... done
[10:26:06.435] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.435] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.435] Searching for globals...
[10:26:06.437] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:06.437] Searching for globals ... DONE
[10:26:06.437] Resolving globals: TRUE
[10:26:06.438] Resolving any globals that are futures ...
[10:26:06.438] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:06.438] Resolving any globals that are futures ... DONE
[10:26:06.438] Resolving futures part of globals (recursively) ...
[10:26:06.438] resolve() on list ...
[10:26:06.438]  recursive: 99
[10:26:06.439]  length: 1
[10:26:06.439]  elements: ‘x’
[10:26:06.439]  length: 0 (resolved future 1)
[10:26:06.439] resolve() on list ... DONE
[10:26:06.439] - globals: [1] ‘x’
[10:26:06.439] Resolving futures part of globals (recursively) ... DONE
[10:26:06.439] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.439] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.440] - globals: [1] ‘x’
[10:26:06.440] 
[10:26:06.440] getGlobalsAndPackages() ... DONE
[10:26:06.440] run() for ‘Future’ ...
[10:26:06.440] - state: ‘created’
[10:26:06.440] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:06.440] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:06.441] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:06.441]   - Field: ‘label’
[10:26:06.441]   - Field: ‘local’
[10:26:06.441]   - Field: ‘owner’
[10:26:06.441]   - Field: ‘envir’
[10:26:06.441]   - Field: ‘packages’
[10:26:06.441]   - Field: ‘gc’
[10:26:06.441]   - Field: ‘conditions’
[10:26:06.441]   - Field: ‘expr’
[10:26:06.441]   - Field: ‘uuid’
[10:26:06.441]   - Field: ‘seed’
[10:26:06.442]   - Field: ‘version’
[10:26:06.442]   - Field: ‘result’
[10:26:06.442]   - Field: ‘asynchronous’
[10:26:06.442]   - Field: ‘calls’
[10:26:06.443]   - Field: ‘globals’
[10:26:06.443]   - Field: ‘stdout’
[10:26:06.443]   - Field: ‘earlySignal’
[10:26:06.443]   - Field: ‘lazy’
[10:26:06.443]   - Field: ‘state’
[10:26:06.443] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:06.443] - Launch lazy future ...
[10:26:06.444] Packages needed by the future expression (n = 0): <none>
[10:26:06.444] Packages needed by future strategies (n = 0): <none>
[10:26:06.444] {
[10:26:06.444]     {
[10:26:06.444]         {
[10:26:06.444]             ...future.startTime <- base::Sys.time()
[10:26:06.444]             {
[10:26:06.444]                 {
[10:26:06.444]                   {
[10:26:06.444]                     base::local({
[10:26:06.444]                       has_future <- base::requireNamespace("future", 
[10:26:06.444]                         quietly = TRUE)
[10:26:06.444]                       if (has_future) {
[10:26:06.444]                         ns <- base::getNamespace("future")
[10:26:06.444]                         version <- ns[[".package"]][["version"]]
[10:26:06.444]                         if (is.null(version)) 
[10:26:06.444]                           version <- utils::packageVersion("future")
[10:26:06.444]                       }
[10:26:06.444]                       else {
[10:26:06.444]                         version <- NULL
[10:26:06.444]                       }
[10:26:06.444]                       if (!has_future || version < "1.8.0") {
[10:26:06.444]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.444]                           "", base::R.version$version.string), 
[10:26:06.444]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:06.444]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.444]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.444]                             "release", "version")], collapse = " "), 
[10:26:06.444]                           hostname = base::Sys.info()[["nodename"]])
[10:26:06.444]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.444]                           info)
[10:26:06.444]                         info <- base::paste(info, collapse = "; ")
[10:26:06.444]                         if (!has_future) {
[10:26:06.444]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.444]                             info)
[10:26:06.444]                         }
[10:26:06.444]                         else {
[10:26:06.444]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.444]                             info, version)
[10:26:06.444]                         }
[10:26:06.444]                         base::stop(msg)
[10:26:06.444]                       }
[10:26:06.444]                     })
[10:26:06.444]                   }
[10:26:06.444]                   options(future.plan = NULL)
[10:26:06.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.444]                 }
[10:26:06.444]                 ...future.workdir <- getwd()
[10:26:06.444]             }
[10:26:06.444]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.444]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.444]         }
[10:26:06.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.444]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.444]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.444]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.444]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.444]             base::names(...future.oldOptions))
[10:26:06.444]     }
[10:26:06.444]     if (FALSE) {
[10:26:06.444]     }
[10:26:06.444]     else {
[10:26:06.444]         if (TRUE) {
[10:26:06.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.444]                 open = "w")
[10:26:06.444]         }
[10:26:06.444]         else {
[10:26:06.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.444]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.444]         }
[10:26:06.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.444]             base::sink(type = "output", split = FALSE)
[10:26:06.444]             base::close(...future.stdout)
[10:26:06.444]         }, add = TRUE)
[10:26:06.444]     }
[10:26:06.444]     ...future.frame <- base::sys.nframe()
[10:26:06.444]     ...future.conditions <- base::list()
[10:26:06.444]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.444]     if (FALSE) {
[10:26:06.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.444]     }
[10:26:06.444]     ...future.result <- base::tryCatch({
[10:26:06.444]         base::withCallingHandlers({
[10:26:06.444]             ...future.value <- base::withVisible(base::local({
[10:26:06.444]                 x["a"] <- list(1)
[10:26:06.444]                 x
[10:26:06.444]             }))
[10:26:06.444]             future::FutureResult(value = ...future.value$value, 
[10:26:06.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.444]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.444]                     ...future.globalenv.names))
[10:26:06.444]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.444]         }, condition = base::local({
[10:26:06.444]             c <- base::c
[10:26:06.444]             inherits <- base::inherits
[10:26:06.444]             invokeRestart <- base::invokeRestart
[10:26:06.444]             length <- base::length
[10:26:06.444]             list <- base::list
[10:26:06.444]             seq.int <- base::seq.int
[10:26:06.444]             signalCondition <- base::signalCondition
[10:26:06.444]             sys.calls <- base::sys.calls
[10:26:06.444]             `[[` <- base::`[[`
[10:26:06.444]             `+` <- base::`+`
[10:26:06.444]             `<<-` <- base::`<<-`
[10:26:06.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.444]                   3L)]
[10:26:06.444]             }
[10:26:06.444]             function(cond) {
[10:26:06.444]                 is_error <- inherits(cond, "error")
[10:26:06.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.444]                   NULL)
[10:26:06.444]                 if (is_error) {
[10:26:06.444]                   sessionInformation <- function() {
[10:26:06.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.444]                       search = base::search(), system = base::Sys.info())
[10:26:06.444]                   }
[10:26:06.444]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.444]                     cond$call), session = sessionInformation(), 
[10:26:06.444]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.444]                   signalCondition(cond)
[10:26:06.444]                 }
[10:26:06.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.444]                 "immediateCondition"))) {
[10:26:06.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.444]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.444]                   if (TRUE && !signal) {
[10:26:06.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.444]                     {
[10:26:06.444]                       inherits <- base::inherits
[10:26:06.444]                       invokeRestart <- base::invokeRestart
[10:26:06.444]                       is.null <- base::is.null
[10:26:06.444]                       muffled <- FALSE
[10:26:06.444]                       if (inherits(cond, "message")) {
[10:26:06.444]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.444]                         if (muffled) 
[10:26:06.444]                           invokeRestart("muffleMessage")
[10:26:06.444]                       }
[10:26:06.444]                       else if (inherits(cond, "warning")) {
[10:26:06.444]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.444]                         if (muffled) 
[10:26:06.444]                           invokeRestart("muffleWarning")
[10:26:06.444]                       }
[10:26:06.444]                       else if (inherits(cond, "condition")) {
[10:26:06.444]                         if (!is.null(pattern)) {
[10:26:06.444]                           computeRestarts <- base::computeRestarts
[10:26:06.444]                           grepl <- base::grepl
[10:26:06.444]                           restarts <- computeRestarts(cond)
[10:26:06.444]                           for (restart in restarts) {
[10:26:06.444]                             name <- restart$name
[10:26:06.444]                             if (is.null(name)) 
[10:26:06.444]                               next
[10:26:06.444]                             if (!grepl(pattern, name)) 
[10:26:06.444]                               next
[10:26:06.444]                             invokeRestart(restart)
[10:26:06.444]                             muffled <- TRUE
[10:26:06.444]                             break
[10:26:06.444]                           }
[10:26:06.444]                         }
[10:26:06.444]                       }
[10:26:06.444]                       invisible(muffled)
[10:26:06.444]                     }
[10:26:06.444]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.444]                   }
[10:26:06.444]                 }
[10:26:06.444]                 else {
[10:26:06.444]                   if (TRUE) {
[10:26:06.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.444]                     {
[10:26:06.444]                       inherits <- base::inherits
[10:26:06.444]                       invokeRestart <- base::invokeRestart
[10:26:06.444]                       is.null <- base::is.null
[10:26:06.444]                       muffled <- FALSE
[10:26:06.444]                       if (inherits(cond, "message")) {
[10:26:06.444]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.444]                         if (muffled) 
[10:26:06.444]                           invokeRestart("muffleMessage")
[10:26:06.444]                       }
[10:26:06.444]                       else if (inherits(cond, "warning")) {
[10:26:06.444]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.444]                         if (muffled) 
[10:26:06.444]                           invokeRestart("muffleWarning")
[10:26:06.444]                       }
[10:26:06.444]                       else if (inherits(cond, "condition")) {
[10:26:06.444]                         if (!is.null(pattern)) {
[10:26:06.444]                           computeRestarts <- base::computeRestarts
[10:26:06.444]                           grepl <- base::grepl
[10:26:06.444]                           restarts <- computeRestarts(cond)
[10:26:06.444]                           for (restart in restarts) {
[10:26:06.444]                             name <- restart$name
[10:26:06.444]                             if (is.null(name)) 
[10:26:06.444]                               next
[10:26:06.444]                             if (!grepl(pattern, name)) 
[10:26:06.444]                               next
[10:26:06.444]                             invokeRestart(restart)
[10:26:06.444]                             muffled <- TRUE
[10:26:06.444]                             break
[10:26:06.444]                           }
[10:26:06.444]                         }
[10:26:06.444]                       }
[10:26:06.444]                       invisible(muffled)
[10:26:06.444]                     }
[10:26:06.444]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.444]                   }
[10:26:06.444]                 }
[10:26:06.444]             }
[10:26:06.444]         }))
[10:26:06.444]     }, error = function(ex) {
[10:26:06.444]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.444]                 ...future.rng), started = ...future.startTime, 
[10:26:06.444]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.444]             version = "1.8"), class = "FutureResult")
[10:26:06.444]     }, finally = {
[10:26:06.444]         if (!identical(...future.workdir, getwd())) 
[10:26:06.444]             setwd(...future.workdir)
[10:26:06.444]         {
[10:26:06.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.444]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.444]             }
[10:26:06.444]             base::options(...future.oldOptions)
[10:26:06.444]             if (.Platform$OS.type == "windows") {
[10:26:06.444]                 old_names <- names(...future.oldEnvVars)
[10:26:06.444]                 envs <- base::Sys.getenv()
[10:26:06.444]                 names <- names(envs)
[10:26:06.444]                 common <- intersect(names, old_names)
[10:26:06.444]                 added <- setdiff(names, old_names)
[10:26:06.444]                 removed <- setdiff(old_names, names)
[10:26:06.444]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.444]                   envs[common]]
[10:26:06.444]                 NAMES <- toupper(changed)
[10:26:06.444]                 args <- list()
[10:26:06.444]                 for (kk in seq_along(NAMES)) {
[10:26:06.444]                   name <- changed[[kk]]
[10:26:06.444]                   NAME <- NAMES[[kk]]
[10:26:06.444]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.444]                     next
[10:26:06.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.444]                 }
[10:26:06.444]                 NAMES <- toupper(added)
[10:26:06.444]                 for (kk in seq_along(NAMES)) {
[10:26:06.444]                   name <- added[[kk]]
[10:26:06.444]                   NAME <- NAMES[[kk]]
[10:26:06.444]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.444]                     next
[10:26:06.444]                   args[[name]] <- ""
[10:26:06.444]                 }
[10:26:06.444]                 NAMES <- toupper(removed)
[10:26:06.444]                 for (kk in seq_along(NAMES)) {
[10:26:06.444]                   name <- removed[[kk]]
[10:26:06.444]                   NAME <- NAMES[[kk]]
[10:26:06.444]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.444]                     next
[10:26:06.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.444]                 }
[10:26:06.444]                 if (length(args) > 0) 
[10:26:06.444]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.444]             }
[10:26:06.444]             else {
[10:26:06.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.444]             }
[10:26:06.444]             {
[10:26:06.444]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.444]                   0L) {
[10:26:06.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.444]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.444]                   base::options(opts)
[10:26:06.444]                 }
[10:26:06.444]                 {
[10:26:06.444]                   {
[10:26:06.444]                     NULL
[10:26:06.444]                     RNGkind("Mersenne-Twister")
[10:26:06.444]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:06.444]                       inherits = FALSE)
[10:26:06.444]                   }
[10:26:06.444]                   options(future.plan = NULL)
[10:26:06.444]                   if (is.na(NA_character_)) 
[10:26:06.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.444]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:06.444]                   {
[10:26:06.444]                     future <- SequentialFuture(..., envir = envir)
[10:26:06.444]                     if (!future$lazy) 
[10:26:06.444]                       future <- run(future)
[10:26:06.444]                     invisible(future)
[10:26:06.444]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.444]                 }
[10:26:06.444]             }
[10:26:06.444]         }
[10:26:06.444]     })
[10:26:06.444]     if (TRUE) {
[10:26:06.444]         base::sink(type = "output", split = FALSE)
[10:26:06.444]         if (TRUE) {
[10:26:06.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.444]         }
[10:26:06.444]         else {
[10:26:06.444]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.444]         }
[10:26:06.444]         base::close(...future.stdout)
[10:26:06.444]         ...future.stdout <- NULL
[10:26:06.444]     }
[10:26:06.444]     ...future.result$conditions <- ...future.conditions
[10:26:06.444]     ...future.result$finished <- base::Sys.time()
[10:26:06.444]     ...future.result
[10:26:06.444] }
[10:26:06.446] assign_globals() ...
[10:26:06.446] List of 1
[10:26:06.446]  $ x: list()
[10:26:06.446]  - attr(*, "where")=List of 1
[10:26:06.446]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.446]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.446]  - attr(*, "resolved")= logi TRUE
[10:26:06.446]  - attr(*, "total_size")= num 0
[10:26:06.446]  - attr(*, "already-done")= logi TRUE
[10:26:06.448] - copied ‘x’ to environment
[10:26:06.448] assign_globals() ... done
[10:26:06.448] plan(): Setting new future strategy stack:
[10:26:06.448] List of future strategies:
[10:26:06.448] 1. sequential:
[10:26:06.448]    - args: function (..., envir = parent.frame())
[10:26:06.448]    - tweaked: FALSE
[10:26:06.448]    - call: NULL
[10:26:06.449] plan(): nbrOfWorkers() = 1
[10:26:06.449] plan(): Setting new future strategy stack:
[10:26:06.449] List of future strategies:
[10:26:06.449] 1. sequential:
[10:26:06.449]    - args: function (..., envir = parent.frame())
[10:26:06.449]    - tweaked: FALSE
[10:26:06.449]    - call: plan(strategy)
[10:26:06.450] plan(): nbrOfWorkers() = 1
[10:26:06.450] SequentialFuture started (and completed)
[10:26:06.450] - Launch lazy future ... done
[10:26:06.450] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.450] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.451] Searching for globals...
[10:26:06.452] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:06.453] Searching for globals ... DONE
[10:26:06.453] Resolving globals: TRUE
[10:26:06.453] Resolving any globals that are futures ...
[10:26:06.453] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:06.453] Resolving any globals that are futures ... DONE
[10:26:06.453] Resolving futures part of globals (recursively) ...
[10:26:06.453] resolve() on list ...
[10:26:06.454]  recursive: 99
[10:26:06.454]  length: 1
[10:26:06.454]  elements: ‘x’
[10:26:06.454]  length: 0 (resolved future 1)
[10:26:06.454] resolve() on list ... DONE
[10:26:06.454] - globals: [1] ‘x’
[10:26:06.454] Resolving futures part of globals (recursively) ... DONE
[10:26:06.454] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.455] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.455] - globals: [1] ‘x’
[10:26:06.455] 
[10:26:06.455] getGlobalsAndPackages() ... DONE
[10:26:06.455] run() for ‘Future’ ...
[10:26:06.455] - state: ‘created’
[10:26:06.455] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:06.456] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:06.456] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:06.456]   - Field: ‘label’
[10:26:06.456]   - Field: ‘local’
[10:26:06.456]   - Field: ‘owner’
[10:26:06.456]   - Field: ‘envir’
[10:26:06.456]   - Field: ‘packages’
[10:26:06.456]   - Field: ‘gc’
[10:26:06.456]   - Field: ‘conditions’
[10:26:06.456]   - Field: ‘expr’
[10:26:06.456]   - Field: ‘uuid’
[10:26:06.457]   - Field: ‘seed’
[10:26:06.457]   - Field: ‘version’
[10:26:06.457]   - Field: ‘result’
[10:26:06.457]   - Field: ‘asynchronous’
[10:26:06.457]   - Field: ‘calls’
[10:26:06.457]   - Field: ‘globals’
[10:26:06.457]   - Field: ‘stdout’
[10:26:06.457]   - Field: ‘earlySignal’
[10:26:06.457]   - Field: ‘lazy’
[10:26:06.457]   - Field: ‘state’
[10:26:06.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:06.458] - Launch lazy future ...
[10:26:06.458] Packages needed by the future expression (n = 0): <none>
[10:26:06.458] Packages needed by future strategies (n = 0): <none>
[10:26:06.458] {
[10:26:06.458]     {
[10:26:06.458]         {
[10:26:06.458]             ...future.startTime <- base::Sys.time()
[10:26:06.458]             {
[10:26:06.458]                 {
[10:26:06.458]                   {
[10:26:06.458]                     base::local({
[10:26:06.458]                       has_future <- base::requireNamespace("future", 
[10:26:06.458]                         quietly = TRUE)
[10:26:06.458]                       if (has_future) {
[10:26:06.458]                         ns <- base::getNamespace("future")
[10:26:06.458]                         version <- ns[[".package"]][["version"]]
[10:26:06.458]                         if (is.null(version)) 
[10:26:06.458]                           version <- utils::packageVersion("future")
[10:26:06.458]                       }
[10:26:06.458]                       else {
[10:26:06.458]                         version <- NULL
[10:26:06.458]                       }
[10:26:06.458]                       if (!has_future || version < "1.8.0") {
[10:26:06.458]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.458]                           "", base::R.version$version.string), 
[10:26:06.458]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:06.458]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.458]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.458]                             "release", "version")], collapse = " "), 
[10:26:06.458]                           hostname = base::Sys.info()[["nodename"]])
[10:26:06.458]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.458]                           info)
[10:26:06.458]                         info <- base::paste(info, collapse = "; ")
[10:26:06.458]                         if (!has_future) {
[10:26:06.458]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.458]                             info)
[10:26:06.458]                         }
[10:26:06.458]                         else {
[10:26:06.458]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.458]                             info, version)
[10:26:06.458]                         }
[10:26:06.458]                         base::stop(msg)
[10:26:06.458]                       }
[10:26:06.458]                     })
[10:26:06.458]                   }
[10:26:06.458]                   options(future.plan = NULL)
[10:26:06.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.458]                 }
[10:26:06.458]                 ...future.workdir <- getwd()
[10:26:06.458]             }
[10:26:06.458]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.458]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.458]         }
[10:26:06.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.458]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.458]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.458]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.458]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.458]             base::names(...future.oldOptions))
[10:26:06.458]     }
[10:26:06.458]     if (FALSE) {
[10:26:06.458]     }
[10:26:06.458]     else {
[10:26:06.458]         if (TRUE) {
[10:26:06.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.458]                 open = "w")
[10:26:06.458]         }
[10:26:06.458]         else {
[10:26:06.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.458]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.458]         }
[10:26:06.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.458]             base::sink(type = "output", split = FALSE)
[10:26:06.458]             base::close(...future.stdout)
[10:26:06.458]         }, add = TRUE)
[10:26:06.458]     }
[10:26:06.458]     ...future.frame <- base::sys.nframe()
[10:26:06.458]     ...future.conditions <- base::list()
[10:26:06.458]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.458]     if (FALSE) {
[10:26:06.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.458]     }
[10:26:06.458]     ...future.result <- base::tryCatch({
[10:26:06.458]         base::withCallingHandlers({
[10:26:06.458]             ...future.value <- base::withVisible(base::local({
[10:26:06.458]                 x["a"] <- list(1)
[10:26:06.458]                 x
[10:26:06.458]             }))
[10:26:06.458]             future::FutureResult(value = ...future.value$value, 
[10:26:06.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.458]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.458]                     ...future.globalenv.names))
[10:26:06.458]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.458]         }, condition = base::local({
[10:26:06.458]             c <- base::c
[10:26:06.458]             inherits <- base::inherits
[10:26:06.458]             invokeRestart <- base::invokeRestart
[10:26:06.458]             length <- base::length
[10:26:06.458]             list <- base::list
[10:26:06.458]             seq.int <- base::seq.int
[10:26:06.458]             signalCondition <- base::signalCondition
[10:26:06.458]             sys.calls <- base::sys.calls
[10:26:06.458]             `[[` <- base::`[[`
[10:26:06.458]             `+` <- base::`+`
[10:26:06.458]             `<<-` <- base::`<<-`
[10:26:06.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.458]                   3L)]
[10:26:06.458]             }
[10:26:06.458]             function(cond) {
[10:26:06.458]                 is_error <- inherits(cond, "error")
[10:26:06.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.458]                   NULL)
[10:26:06.458]                 if (is_error) {
[10:26:06.458]                   sessionInformation <- function() {
[10:26:06.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.458]                       search = base::search(), system = base::Sys.info())
[10:26:06.458]                   }
[10:26:06.458]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.458]                     cond$call), session = sessionInformation(), 
[10:26:06.458]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.458]                   signalCondition(cond)
[10:26:06.458]                 }
[10:26:06.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.458]                 "immediateCondition"))) {
[10:26:06.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.458]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.458]                   if (TRUE && !signal) {
[10:26:06.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.458]                     {
[10:26:06.458]                       inherits <- base::inherits
[10:26:06.458]                       invokeRestart <- base::invokeRestart
[10:26:06.458]                       is.null <- base::is.null
[10:26:06.458]                       muffled <- FALSE
[10:26:06.458]                       if (inherits(cond, "message")) {
[10:26:06.458]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.458]                         if (muffled) 
[10:26:06.458]                           invokeRestart("muffleMessage")
[10:26:06.458]                       }
[10:26:06.458]                       else if (inherits(cond, "warning")) {
[10:26:06.458]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.458]                         if (muffled) 
[10:26:06.458]                           invokeRestart("muffleWarning")
[10:26:06.458]                       }
[10:26:06.458]                       else if (inherits(cond, "condition")) {
[10:26:06.458]                         if (!is.null(pattern)) {
[10:26:06.458]                           computeRestarts <- base::computeRestarts
[10:26:06.458]                           grepl <- base::grepl
[10:26:06.458]                           restarts <- computeRestarts(cond)
[10:26:06.458]                           for (restart in restarts) {
[10:26:06.458]                             name <- restart$name
[10:26:06.458]                             if (is.null(name)) 
[10:26:06.458]                               next
[10:26:06.458]                             if (!grepl(pattern, name)) 
[10:26:06.458]                               next
[10:26:06.458]                             invokeRestart(restart)
[10:26:06.458]                             muffled <- TRUE
[10:26:06.458]                             break
[10:26:06.458]                           }
[10:26:06.458]                         }
[10:26:06.458]                       }
[10:26:06.458]                       invisible(muffled)
[10:26:06.458]                     }
[10:26:06.458]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.458]                   }
[10:26:06.458]                 }
[10:26:06.458]                 else {
[10:26:06.458]                   if (TRUE) {
[10:26:06.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.458]                     {
[10:26:06.458]                       inherits <- base::inherits
[10:26:06.458]                       invokeRestart <- base::invokeRestart
[10:26:06.458]                       is.null <- base::is.null
[10:26:06.458]                       muffled <- FALSE
[10:26:06.458]                       if (inherits(cond, "message")) {
[10:26:06.458]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.458]                         if (muffled) 
[10:26:06.458]                           invokeRestart("muffleMessage")
[10:26:06.458]                       }
[10:26:06.458]                       else if (inherits(cond, "warning")) {
[10:26:06.458]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.458]                         if (muffled) 
[10:26:06.458]                           invokeRestart("muffleWarning")
[10:26:06.458]                       }
[10:26:06.458]                       else if (inherits(cond, "condition")) {
[10:26:06.458]                         if (!is.null(pattern)) {
[10:26:06.458]                           computeRestarts <- base::computeRestarts
[10:26:06.458]                           grepl <- base::grepl
[10:26:06.458]                           restarts <- computeRestarts(cond)
[10:26:06.458]                           for (restart in restarts) {
[10:26:06.458]                             name <- restart$name
[10:26:06.458]                             if (is.null(name)) 
[10:26:06.458]                               next
[10:26:06.458]                             if (!grepl(pattern, name)) 
[10:26:06.458]                               next
[10:26:06.458]                             invokeRestart(restart)
[10:26:06.458]                             muffled <- TRUE
[10:26:06.458]                             break
[10:26:06.458]                           }
[10:26:06.458]                         }
[10:26:06.458]                       }
[10:26:06.458]                       invisible(muffled)
[10:26:06.458]                     }
[10:26:06.458]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.458]                   }
[10:26:06.458]                 }
[10:26:06.458]             }
[10:26:06.458]         }))
[10:26:06.458]     }, error = function(ex) {
[10:26:06.458]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.458]                 ...future.rng), started = ...future.startTime, 
[10:26:06.458]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.458]             version = "1.8"), class = "FutureResult")
[10:26:06.458]     }, finally = {
[10:26:06.458]         if (!identical(...future.workdir, getwd())) 
[10:26:06.458]             setwd(...future.workdir)
[10:26:06.458]         {
[10:26:06.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.458]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.458]             }
[10:26:06.458]             base::options(...future.oldOptions)
[10:26:06.458]             if (.Platform$OS.type == "windows") {
[10:26:06.458]                 old_names <- names(...future.oldEnvVars)
[10:26:06.458]                 envs <- base::Sys.getenv()
[10:26:06.458]                 names <- names(envs)
[10:26:06.458]                 common <- intersect(names, old_names)
[10:26:06.458]                 added <- setdiff(names, old_names)
[10:26:06.458]                 removed <- setdiff(old_names, names)
[10:26:06.458]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.458]                   envs[common]]
[10:26:06.458]                 NAMES <- toupper(changed)
[10:26:06.458]                 args <- list()
[10:26:06.458]                 for (kk in seq_along(NAMES)) {
[10:26:06.458]                   name <- changed[[kk]]
[10:26:06.458]                   NAME <- NAMES[[kk]]
[10:26:06.458]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.458]                     next
[10:26:06.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.458]                 }
[10:26:06.458]                 NAMES <- toupper(added)
[10:26:06.458]                 for (kk in seq_along(NAMES)) {
[10:26:06.458]                   name <- added[[kk]]
[10:26:06.458]                   NAME <- NAMES[[kk]]
[10:26:06.458]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.458]                     next
[10:26:06.458]                   args[[name]] <- ""
[10:26:06.458]                 }
[10:26:06.458]                 NAMES <- toupper(removed)
[10:26:06.458]                 for (kk in seq_along(NAMES)) {
[10:26:06.458]                   name <- removed[[kk]]
[10:26:06.458]                   NAME <- NAMES[[kk]]
[10:26:06.458]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.458]                     next
[10:26:06.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.458]                 }
[10:26:06.458]                 if (length(args) > 0) 
[10:26:06.458]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.458]             }
[10:26:06.458]             else {
[10:26:06.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.458]             }
[10:26:06.458]             {
[10:26:06.458]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.458]                   0L) {
[10:26:06.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.458]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.458]                   base::options(opts)
[10:26:06.458]                 }
[10:26:06.458]                 {
[10:26:06.458]                   {
[10:26:06.458]                     NULL
[10:26:06.458]                     RNGkind("Mersenne-Twister")
[10:26:06.458]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:06.458]                       inherits = FALSE)
[10:26:06.458]                   }
[10:26:06.458]                   options(future.plan = NULL)
[10:26:06.458]                   if (is.na(NA_character_)) 
[10:26:06.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.458]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:06.458]                   {
[10:26:06.458]                     future <- SequentialFuture(..., envir = envir)
[10:26:06.458]                     if (!future$lazy) 
[10:26:06.458]                       future <- run(future)
[10:26:06.458]                     invisible(future)
[10:26:06.458]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.458]                 }
[10:26:06.458]             }
[10:26:06.458]         }
[10:26:06.458]     })
[10:26:06.458]     if (TRUE) {
[10:26:06.458]         base::sink(type = "output", split = FALSE)
[10:26:06.458]         if (TRUE) {
[10:26:06.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.458]         }
[10:26:06.458]         else {
[10:26:06.458]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.458]         }
[10:26:06.458]         base::close(...future.stdout)
[10:26:06.458]         ...future.stdout <- NULL
[10:26:06.458]     }
[10:26:06.458]     ...future.result$conditions <- ...future.conditions
[10:26:06.458]     ...future.result$finished <- base::Sys.time()
[10:26:06.458]     ...future.result
[10:26:06.458] }
[10:26:06.460] assign_globals() ...
[10:26:06.460] List of 1
[10:26:06.460]  $ x: list()
[10:26:06.460]  - attr(*, "where")=List of 1
[10:26:06.460]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.460]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.460]  - attr(*, "resolved")= logi TRUE
[10:26:06.460]  - attr(*, "total_size")= num 0
[10:26:06.460]  - attr(*, "already-done")= logi TRUE
[10:26:06.462] - copied ‘x’ to environment
[10:26:06.462] assign_globals() ... done
[10:26:06.462] plan(): Setting new future strategy stack:
[10:26:06.462] List of future strategies:
[10:26:06.462] 1. sequential:
[10:26:06.462]    - args: function (..., envir = parent.frame())
[10:26:06.462]    - tweaked: FALSE
[10:26:06.462]    - call: NULL
[10:26:06.463] plan(): nbrOfWorkers() = 1
[10:26:06.463] plan(): Setting new future strategy stack:
[10:26:06.463] List of future strategies:
[10:26:06.463] 1. sequential:
[10:26:06.463]    - args: function (..., envir = parent.frame())
[10:26:06.463]    - tweaked: FALSE
[10:26:06.463]    - call: plan(strategy)
[10:26:06.464] plan(): nbrOfWorkers() = 1
[10:26:06.464] SequentialFuture started (and completed)
[10:26:06.464] - Launch lazy future ... done
[10:26:06.464] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.465] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.465] Searching for globals...
[10:26:06.468] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:26:06.468] Searching for globals ... DONE
[10:26:06.468] Resolving globals: TRUE
[10:26:06.468] Resolving any globals that are futures ...
[10:26:06.468] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:26:06.468] Resolving any globals that are futures ... DONE
[10:26:06.469] Resolving futures part of globals (recursively) ...
[10:26:06.469] resolve() on list ...
[10:26:06.469]  recursive: 99
[10:26:06.469]  length: 2
[10:26:06.469]  elements: ‘x’, ‘name’
[10:26:06.469]  length: 1 (resolved future 1)
[10:26:06.469]  length: 0 (resolved future 2)
[10:26:06.469] resolve() on list ... DONE
[10:26:06.469] - globals: [2] ‘x’, ‘name’
[10:26:06.470] Resolving futures part of globals (recursively) ... DONE
[10:26:06.470] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:06.470] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[10:26:06.470] - globals: [2] ‘x’, ‘name’
[10:26:06.470] 
[10:26:06.470] getGlobalsAndPackages() ... DONE
[10:26:06.471] run() for ‘Future’ ...
[10:26:06.471] - state: ‘created’
[10:26:06.471] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:06.471] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:06.471] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:06.471]   - Field: ‘label’
[10:26:06.471]   - Field: ‘local’
[10:26:06.471]   - Field: ‘owner’
[10:26:06.472]   - Field: ‘envir’
[10:26:06.472]   - Field: ‘packages’
[10:26:06.472]   - Field: ‘gc’
[10:26:06.472]   - Field: ‘conditions’
[10:26:06.472]   - Field: ‘expr’
[10:26:06.472]   - Field: ‘uuid’
[10:26:06.472]   - Field: ‘seed’
[10:26:06.472]   - Field: ‘version’
[10:26:06.472]   - Field: ‘result’
[10:26:06.472]   - Field: ‘asynchronous’
[10:26:06.472]   - Field: ‘calls’
[10:26:06.472]   - Field: ‘globals’
[10:26:06.473]   - Field: ‘stdout’
[10:26:06.473]   - Field: ‘earlySignal’
[10:26:06.473]   - Field: ‘lazy’
[10:26:06.473]   - Field: ‘state’
[10:26:06.473] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:06.473] - Launch lazy future ...
[10:26:06.473] Packages needed by the future expression (n = 0): <none>
[10:26:06.473] Packages needed by future strategies (n = 0): <none>
[10:26:06.474] {
[10:26:06.474]     {
[10:26:06.474]         {
[10:26:06.474]             ...future.startTime <- base::Sys.time()
[10:26:06.474]             {
[10:26:06.474]                 {
[10:26:06.474]                   {
[10:26:06.474]                     base::local({
[10:26:06.474]                       has_future <- base::requireNamespace("future", 
[10:26:06.474]                         quietly = TRUE)
[10:26:06.474]                       if (has_future) {
[10:26:06.474]                         ns <- base::getNamespace("future")
[10:26:06.474]                         version <- ns[[".package"]][["version"]]
[10:26:06.474]                         if (is.null(version)) 
[10:26:06.474]                           version <- utils::packageVersion("future")
[10:26:06.474]                       }
[10:26:06.474]                       else {
[10:26:06.474]                         version <- NULL
[10:26:06.474]                       }
[10:26:06.474]                       if (!has_future || version < "1.8.0") {
[10:26:06.474]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.474]                           "", base::R.version$version.string), 
[10:26:06.474]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:06.474]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.474]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.474]                             "release", "version")], collapse = " "), 
[10:26:06.474]                           hostname = base::Sys.info()[["nodename"]])
[10:26:06.474]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.474]                           info)
[10:26:06.474]                         info <- base::paste(info, collapse = "; ")
[10:26:06.474]                         if (!has_future) {
[10:26:06.474]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.474]                             info)
[10:26:06.474]                         }
[10:26:06.474]                         else {
[10:26:06.474]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.474]                             info, version)
[10:26:06.474]                         }
[10:26:06.474]                         base::stop(msg)
[10:26:06.474]                       }
[10:26:06.474]                     })
[10:26:06.474]                   }
[10:26:06.474]                   options(future.plan = NULL)
[10:26:06.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.474]                 }
[10:26:06.474]                 ...future.workdir <- getwd()
[10:26:06.474]             }
[10:26:06.474]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.474]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.474]         }
[10:26:06.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.474]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.474]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.474]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.474]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.474]             base::names(...future.oldOptions))
[10:26:06.474]     }
[10:26:06.474]     if (FALSE) {
[10:26:06.474]     }
[10:26:06.474]     else {
[10:26:06.474]         if (TRUE) {
[10:26:06.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.474]                 open = "w")
[10:26:06.474]         }
[10:26:06.474]         else {
[10:26:06.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.474]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.474]         }
[10:26:06.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.474]             base::sink(type = "output", split = FALSE)
[10:26:06.474]             base::close(...future.stdout)
[10:26:06.474]         }, add = TRUE)
[10:26:06.474]     }
[10:26:06.474]     ...future.frame <- base::sys.nframe()
[10:26:06.474]     ...future.conditions <- base::list()
[10:26:06.474]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.474]     if (FALSE) {
[10:26:06.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.474]     }
[10:26:06.474]     ...future.result <- base::tryCatch({
[10:26:06.474]         base::withCallingHandlers({
[10:26:06.474]             ...future.value <- base::withVisible(base::local({
[10:26:06.474]                 x[name] <- list(1)
[10:26:06.474]                 x
[10:26:06.474]             }))
[10:26:06.474]             future::FutureResult(value = ...future.value$value, 
[10:26:06.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.474]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.474]                     ...future.globalenv.names))
[10:26:06.474]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.474]         }, condition = base::local({
[10:26:06.474]             c <- base::c
[10:26:06.474]             inherits <- base::inherits
[10:26:06.474]             invokeRestart <- base::invokeRestart
[10:26:06.474]             length <- base::length
[10:26:06.474]             list <- base::list
[10:26:06.474]             seq.int <- base::seq.int
[10:26:06.474]             signalCondition <- base::signalCondition
[10:26:06.474]             sys.calls <- base::sys.calls
[10:26:06.474]             `[[` <- base::`[[`
[10:26:06.474]             `+` <- base::`+`
[10:26:06.474]             `<<-` <- base::`<<-`
[10:26:06.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.474]                   3L)]
[10:26:06.474]             }
[10:26:06.474]             function(cond) {
[10:26:06.474]                 is_error <- inherits(cond, "error")
[10:26:06.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.474]                   NULL)
[10:26:06.474]                 if (is_error) {
[10:26:06.474]                   sessionInformation <- function() {
[10:26:06.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.474]                       search = base::search(), system = base::Sys.info())
[10:26:06.474]                   }
[10:26:06.474]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.474]                     cond$call), session = sessionInformation(), 
[10:26:06.474]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.474]                   signalCondition(cond)
[10:26:06.474]                 }
[10:26:06.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.474]                 "immediateCondition"))) {
[10:26:06.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.474]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.474]                   if (TRUE && !signal) {
[10:26:06.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.474]                     {
[10:26:06.474]                       inherits <- base::inherits
[10:26:06.474]                       invokeRestart <- base::invokeRestart
[10:26:06.474]                       is.null <- base::is.null
[10:26:06.474]                       muffled <- FALSE
[10:26:06.474]                       if (inherits(cond, "message")) {
[10:26:06.474]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.474]                         if (muffled) 
[10:26:06.474]                           invokeRestart("muffleMessage")
[10:26:06.474]                       }
[10:26:06.474]                       else if (inherits(cond, "warning")) {
[10:26:06.474]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.474]                         if (muffled) 
[10:26:06.474]                           invokeRestart("muffleWarning")
[10:26:06.474]                       }
[10:26:06.474]                       else if (inherits(cond, "condition")) {
[10:26:06.474]                         if (!is.null(pattern)) {
[10:26:06.474]                           computeRestarts <- base::computeRestarts
[10:26:06.474]                           grepl <- base::grepl
[10:26:06.474]                           restarts <- computeRestarts(cond)
[10:26:06.474]                           for (restart in restarts) {
[10:26:06.474]                             name <- restart$name
[10:26:06.474]                             if (is.null(name)) 
[10:26:06.474]                               next
[10:26:06.474]                             if (!grepl(pattern, name)) 
[10:26:06.474]                               next
[10:26:06.474]                             invokeRestart(restart)
[10:26:06.474]                             muffled <- TRUE
[10:26:06.474]                             break
[10:26:06.474]                           }
[10:26:06.474]                         }
[10:26:06.474]                       }
[10:26:06.474]                       invisible(muffled)
[10:26:06.474]                     }
[10:26:06.474]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.474]                   }
[10:26:06.474]                 }
[10:26:06.474]                 else {
[10:26:06.474]                   if (TRUE) {
[10:26:06.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.474]                     {
[10:26:06.474]                       inherits <- base::inherits
[10:26:06.474]                       invokeRestart <- base::invokeRestart
[10:26:06.474]                       is.null <- base::is.null
[10:26:06.474]                       muffled <- FALSE
[10:26:06.474]                       if (inherits(cond, "message")) {
[10:26:06.474]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.474]                         if (muffled) 
[10:26:06.474]                           invokeRestart("muffleMessage")
[10:26:06.474]                       }
[10:26:06.474]                       else if (inherits(cond, "warning")) {
[10:26:06.474]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.474]                         if (muffled) 
[10:26:06.474]                           invokeRestart("muffleWarning")
[10:26:06.474]                       }
[10:26:06.474]                       else if (inherits(cond, "condition")) {
[10:26:06.474]                         if (!is.null(pattern)) {
[10:26:06.474]                           computeRestarts <- base::computeRestarts
[10:26:06.474]                           grepl <- base::grepl
[10:26:06.474]                           restarts <- computeRestarts(cond)
[10:26:06.474]                           for (restart in restarts) {
[10:26:06.474]                             name <- restart$name
[10:26:06.474]                             if (is.null(name)) 
[10:26:06.474]                               next
[10:26:06.474]                             if (!grepl(pattern, name)) 
[10:26:06.474]                               next
[10:26:06.474]                             invokeRestart(restart)
[10:26:06.474]                             muffled <- TRUE
[10:26:06.474]                             break
[10:26:06.474]                           }
[10:26:06.474]                         }
[10:26:06.474]                       }
[10:26:06.474]                       invisible(muffled)
[10:26:06.474]                     }
[10:26:06.474]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.474]                   }
[10:26:06.474]                 }
[10:26:06.474]             }
[10:26:06.474]         }))
[10:26:06.474]     }, error = function(ex) {
[10:26:06.474]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.474]                 ...future.rng), started = ...future.startTime, 
[10:26:06.474]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.474]             version = "1.8"), class = "FutureResult")
[10:26:06.474]     }, finally = {
[10:26:06.474]         if (!identical(...future.workdir, getwd())) 
[10:26:06.474]             setwd(...future.workdir)
[10:26:06.474]         {
[10:26:06.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.474]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.474]             }
[10:26:06.474]             base::options(...future.oldOptions)
[10:26:06.474]             if (.Platform$OS.type == "windows") {
[10:26:06.474]                 old_names <- names(...future.oldEnvVars)
[10:26:06.474]                 envs <- base::Sys.getenv()
[10:26:06.474]                 names <- names(envs)
[10:26:06.474]                 common <- intersect(names, old_names)
[10:26:06.474]                 added <- setdiff(names, old_names)
[10:26:06.474]                 removed <- setdiff(old_names, names)
[10:26:06.474]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.474]                   envs[common]]
[10:26:06.474]                 NAMES <- toupper(changed)
[10:26:06.474]                 args <- list()
[10:26:06.474]                 for (kk in seq_along(NAMES)) {
[10:26:06.474]                   name <- changed[[kk]]
[10:26:06.474]                   NAME <- NAMES[[kk]]
[10:26:06.474]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.474]                     next
[10:26:06.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.474]                 }
[10:26:06.474]                 NAMES <- toupper(added)
[10:26:06.474]                 for (kk in seq_along(NAMES)) {
[10:26:06.474]                   name <- added[[kk]]
[10:26:06.474]                   NAME <- NAMES[[kk]]
[10:26:06.474]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.474]                     next
[10:26:06.474]                   args[[name]] <- ""
[10:26:06.474]                 }
[10:26:06.474]                 NAMES <- toupper(removed)
[10:26:06.474]                 for (kk in seq_along(NAMES)) {
[10:26:06.474]                   name <- removed[[kk]]
[10:26:06.474]                   NAME <- NAMES[[kk]]
[10:26:06.474]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.474]                     next
[10:26:06.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.474]                 }
[10:26:06.474]                 if (length(args) > 0) 
[10:26:06.474]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.474]             }
[10:26:06.474]             else {
[10:26:06.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.474]             }
[10:26:06.474]             {
[10:26:06.474]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.474]                   0L) {
[10:26:06.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.474]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.474]                   base::options(opts)
[10:26:06.474]                 }
[10:26:06.474]                 {
[10:26:06.474]                   {
[10:26:06.474]                     NULL
[10:26:06.474]                     RNGkind("Mersenne-Twister")
[10:26:06.474]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:06.474]                       inherits = FALSE)
[10:26:06.474]                   }
[10:26:06.474]                   options(future.plan = NULL)
[10:26:06.474]                   if (is.na(NA_character_)) 
[10:26:06.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.474]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:06.474]                   {
[10:26:06.474]                     future <- SequentialFuture(..., envir = envir)
[10:26:06.474]                     if (!future$lazy) 
[10:26:06.474]                       future <- run(future)
[10:26:06.474]                     invisible(future)
[10:26:06.474]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.474]                 }
[10:26:06.474]             }
[10:26:06.474]         }
[10:26:06.474]     })
[10:26:06.474]     if (TRUE) {
[10:26:06.474]         base::sink(type = "output", split = FALSE)
[10:26:06.474]         if (TRUE) {
[10:26:06.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.474]         }
[10:26:06.474]         else {
[10:26:06.474]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.474]         }
[10:26:06.474]         base::close(...future.stdout)
[10:26:06.474]         ...future.stdout <- NULL
[10:26:06.474]     }
[10:26:06.474]     ...future.result$conditions <- ...future.conditions
[10:26:06.474]     ...future.result$finished <- base::Sys.time()
[10:26:06.474]     ...future.result
[10:26:06.474] }
[10:26:06.475] assign_globals() ...
[10:26:06.475] List of 2
[10:26:06.475]  $ x   : list()
[10:26:06.475]  $ name: chr "a"
[10:26:06.475]  - attr(*, "where")=List of 2
[10:26:06.475]   ..$ x   :<environment: R_EmptyEnv> 
[10:26:06.475]   ..$ name:<environment: R_EmptyEnv> 
[10:26:06.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.475]  - attr(*, "resolved")= logi TRUE
[10:26:06.475]  - attr(*, "total_size")= num 112
[10:26:06.475]  - attr(*, "already-done")= logi TRUE
[10:26:06.478] - copied ‘x’ to environment
[10:26:06.478] - copied ‘name’ to environment
[10:26:06.478] assign_globals() ... done
[10:26:06.478] plan(): Setting new future strategy stack:
[10:26:06.478] List of future strategies:
[10:26:06.478] 1. sequential:
[10:26:06.478]    - args: function (..., envir = parent.frame())
[10:26:06.478]    - tweaked: FALSE
[10:26:06.478]    - call: NULL
[10:26:06.479] plan(): nbrOfWorkers() = 1
[10:26:06.479] plan(): Setting new future strategy stack:
[10:26:06.479] List of future strategies:
[10:26:06.479] 1. sequential:
[10:26:06.479]    - args: function (..., envir = parent.frame())
[10:26:06.479]    - tweaked: FALSE
[10:26:06.479]    - call: plan(strategy)
[10:26:06.480] plan(): nbrOfWorkers() = 1
[10:26:06.480] SequentialFuture started (and completed)
[10:26:06.480] - Launch lazy future ... done
[10:26:06.480] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[10:26:06.489] plan(): Setting new future strategy stack:
[10:26:06.489] List of future strategies:
[10:26:06.489] 1. multicore:
[10:26:06.489]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.489]    - tweaked: FALSE
[10:26:06.489]    - call: plan(strategy)
[10:26:06.493] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.493] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.493] Searching for globals...
[10:26:06.496] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.496] Searching for globals ... DONE
[10:26:06.496] Resolving globals: TRUE
[10:26:06.496] Resolving any globals that are futures ...
[10:26:06.496] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.496] Resolving any globals that are futures ... DONE
[10:26:06.497] Resolving futures part of globals (recursively) ...
[10:26:06.497] resolve() on list ...
[10:26:06.497]  recursive: 99
[10:26:06.497]  length: 1
[10:26:06.497]  elements: ‘x’
[10:26:06.497]  length: 0 (resolved future 1)
[10:26:06.497] resolve() on list ... DONE
[10:26:06.498] - globals: [1] ‘x’
[10:26:06.498] Resolving futures part of globals (recursively) ... DONE
[10:26:06.498] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.498] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.498] - globals: [1] ‘x’
[10:26:06.498] 
[10:26:06.498] getGlobalsAndPackages() ... DONE
[10:26:06.499] run() for ‘Future’ ...
[10:26:06.499] - state: ‘created’
[10:26:06.499] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:06.502] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:06.502] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:06.503]   - Field: ‘label’
[10:26:06.503]   - Field: ‘local’
[10:26:06.503]   - Field: ‘owner’
[10:26:06.503]   - Field: ‘envir’
[10:26:06.503]   - Field: ‘workers’
[10:26:06.503]   - Field: ‘packages’
[10:26:06.503]   - Field: ‘gc’
[10:26:06.503]   - Field: ‘job’
[10:26:06.503]   - Field: ‘conditions’
[10:26:06.503]   - Field: ‘expr’
[10:26:06.503]   - Field: ‘uuid’
[10:26:06.504]   - Field: ‘seed’
[10:26:06.504]   - Field: ‘version’
[10:26:06.504]   - Field: ‘result’
[10:26:06.504]   - Field: ‘asynchronous’
[10:26:06.504]   - Field: ‘calls’
[10:26:06.504]   - Field: ‘globals’
[10:26:06.504]   - Field: ‘stdout’
[10:26:06.504]   - Field: ‘earlySignal’
[10:26:06.504]   - Field: ‘lazy’
[10:26:06.504]   - Field: ‘state’
[10:26:06.504] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:06.505] - Launch lazy future ...
[10:26:06.505] Packages needed by the future expression (n = 0): <none>
[10:26:06.506] Packages needed by future strategies (n = 0): <none>
[10:26:06.506] {
[10:26:06.506]     {
[10:26:06.506]         {
[10:26:06.506]             ...future.startTime <- base::Sys.time()
[10:26:06.506]             {
[10:26:06.506]                 {
[10:26:06.506]                   {
[10:26:06.506]                     {
[10:26:06.506]                       base::local({
[10:26:06.506]                         has_future <- base::requireNamespace("future", 
[10:26:06.506]                           quietly = TRUE)
[10:26:06.506]                         if (has_future) {
[10:26:06.506]                           ns <- base::getNamespace("future")
[10:26:06.506]                           version <- ns[[".package"]][["version"]]
[10:26:06.506]                           if (is.null(version)) 
[10:26:06.506]                             version <- utils::packageVersion("future")
[10:26:06.506]                         }
[10:26:06.506]                         else {
[10:26:06.506]                           version <- NULL
[10:26:06.506]                         }
[10:26:06.506]                         if (!has_future || version < "1.8.0") {
[10:26:06.506]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.506]                             "", base::R.version$version.string), 
[10:26:06.506]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:06.506]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.506]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.506]                               "release", "version")], collapse = " "), 
[10:26:06.506]                             hostname = base::Sys.info()[["nodename"]])
[10:26:06.506]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.506]                             info)
[10:26:06.506]                           info <- base::paste(info, collapse = "; ")
[10:26:06.506]                           if (!has_future) {
[10:26:06.506]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.506]                               info)
[10:26:06.506]                           }
[10:26:06.506]                           else {
[10:26:06.506]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.506]                               info, version)
[10:26:06.506]                           }
[10:26:06.506]                           base::stop(msg)
[10:26:06.506]                         }
[10:26:06.506]                       })
[10:26:06.506]                     }
[10:26:06.506]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:06.506]                     base::options(mc.cores = 1L)
[10:26:06.506]                   }
[10:26:06.506]                   options(future.plan = NULL)
[10:26:06.506]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.506]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.506]                 }
[10:26:06.506]                 ...future.workdir <- getwd()
[10:26:06.506]             }
[10:26:06.506]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.506]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.506]         }
[10:26:06.506]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.506]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.506]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.506]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.506]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.506]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.506]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.506]             base::names(...future.oldOptions))
[10:26:06.506]     }
[10:26:06.506]     if (FALSE) {
[10:26:06.506]     }
[10:26:06.506]     else {
[10:26:06.506]         if (TRUE) {
[10:26:06.506]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.506]                 open = "w")
[10:26:06.506]         }
[10:26:06.506]         else {
[10:26:06.506]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.506]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.506]         }
[10:26:06.506]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.506]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.506]             base::sink(type = "output", split = FALSE)
[10:26:06.506]             base::close(...future.stdout)
[10:26:06.506]         }, add = TRUE)
[10:26:06.506]     }
[10:26:06.506]     ...future.frame <- base::sys.nframe()
[10:26:06.506]     ...future.conditions <- base::list()
[10:26:06.506]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.506]     if (FALSE) {
[10:26:06.506]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.506]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.506]     }
[10:26:06.506]     ...future.result <- base::tryCatch({
[10:26:06.506]         base::withCallingHandlers({
[10:26:06.506]             ...future.value <- base::withVisible(base::local({
[10:26:06.506]                 withCallingHandlers({
[10:26:06.506]                   {
[10:26:06.506]                     x$a <- 1
[10:26:06.506]                     x
[10:26:06.506]                   }
[10:26:06.506]                 }, immediateCondition = function(cond) {
[10:26:06.506]                   save_rds <- function (object, pathname, ...) 
[10:26:06.506]                   {
[10:26:06.506]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:06.506]                     if (file_test("-f", pathname_tmp)) {
[10:26:06.506]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.506]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:06.506]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.506]                         fi_tmp[["mtime"]])
[10:26:06.506]                     }
[10:26:06.506]                     tryCatch({
[10:26:06.506]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:06.506]                     }, error = function(ex) {
[10:26:06.506]                       msg <- conditionMessage(ex)
[10:26:06.506]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.506]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:06.506]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.506]                         fi_tmp[["mtime"]], msg)
[10:26:06.506]                       ex$message <- msg
[10:26:06.506]                       stop(ex)
[10:26:06.506]                     })
[10:26:06.506]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:06.506]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:06.506]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:06.506]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.506]                       fi <- file.info(pathname)
[10:26:06.506]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:06.506]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.506]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:06.506]                         fi[["size"]], fi[["mtime"]])
[10:26:06.506]                       stop(msg)
[10:26:06.506]                     }
[10:26:06.506]                     invisible(pathname)
[10:26:06.506]                   }
[10:26:06.506]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:06.506]                     rootPath = tempdir()) 
[10:26:06.506]                   {
[10:26:06.506]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:06.506]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:06.506]                       tmpdir = path, fileext = ".rds")
[10:26:06.506]                     save_rds(obj, file)
[10:26:06.506]                   }
[10:26:06.506]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4YXwpK/.future/immediateConditions")
[10:26:06.506]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.506]                   {
[10:26:06.506]                     inherits <- base::inherits
[10:26:06.506]                     invokeRestart <- base::invokeRestart
[10:26:06.506]                     is.null <- base::is.null
[10:26:06.506]                     muffled <- FALSE
[10:26:06.506]                     if (inherits(cond, "message")) {
[10:26:06.506]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:06.506]                       if (muffled) 
[10:26:06.506]                         invokeRestart("muffleMessage")
[10:26:06.506]                     }
[10:26:06.506]                     else if (inherits(cond, "warning")) {
[10:26:06.506]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:06.506]                       if (muffled) 
[10:26:06.506]                         invokeRestart("muffleWarning")
[10:26:06.506]                     }
[10:26:06.506]                     else if (inherits(cond, "condition")) {
[10:26:06.506]                       if (!is.null(pattern)) {
[10:26:06.506]                         computeRestarts <- base::computeRestarts
[10:26:06.506]                         grepl <- base::grepl
[10:26:06.506]                         restarts <- computeRestarts(cond)
[10:26:06.506]                         for (restart in restarts) {
[10:26:06.506]                           name <- restart$name
[10:26:06.506]                           if (is.null(name)) 
[10:26:06.506]                             next
[10:26:06.506]                           if (!grepl(pattern, name)) 
[10:26:06.506]                             next
[10:26:06.506]                           invokeRestart(restart)
[10:26:06.506]                           muffled <- TRUE
[10:26:06.506]                           break
[10:26:06.506]                         }
[10:26:06.506]                       }
[10:26:06.506]                     }
[10:26:06.506]                     invisible(muffled)
[10:26:06.506]                   }
[10:26:06.506]                   muffleCondition(cond)
[10:26:06.506]                 })
[10:26:06.506]             }))
[10:26:06.506]             future::FutureResult(value = ...future.value$value, 
[10:26:06.506]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.506]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.506]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.506]                     ...future.globalenv.names))
[10:26:06.506]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.506]         }, condition = base::local({
[10:26:06.506]             c <- base::c
[10:26:06.506]             inherits <- base::inherits
[10:26:06.506]             invokeRestart <- base::invokeRestart
[10:26:06.506]             length <- base::length
[10:26:06.506]             list <- base::list
[10:26:06.506]             seq.int <- base::seq.int
[10:26:06.506]             signalCondition <- base::signalCondition
[10:26:06.506]             sys.calls <- base::sys.calls
[10:26:06.506]             `[[` <- base::`[[`
[10:26:06.506]             `+` <- base::`+`
[10:26:06.506]             `<<-` <- base::`<<-`
[10:26:06.506]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.506]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.506]                   3L)]
[10:26:06.506]             }
[10:26:06.506]             function(cond) {
[10:26:06.506]                 is_error <- inherits(cond, "error")
[10:26:06.506]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.506]                   NULL)
[10:26:06.506]                 if (is_error) {
[10:26:06.506]                   sessionInformation <- function() {
[10:26:06.506]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.506]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.506]                       search = base::search(), system = base::Sys.info())
[10:26:06.506]                   }
[10:26:06.506]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.506]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.506]                     cond$call), session = sessionInformation(), 
[10:26:06.506]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.506]                   signalCondition(cond)
[10:26:06.506]                 }
[10:26:06.506]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.506]                 "immediateCondition"))) {
[10:26:06.506]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.506]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.506]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.506]                   if (TRUE && !signal) {
[10:26:06.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.506]                     {
[10:26:06.506]                       inherits <- base::inherits
[10:26:06.506]                       invokeRestart <- base::invokeRestart
[10:26:06.506]                       is.null <- base::is.null
[10:26:06.506]                       muffled <- FALSE
[10:26:06.506]                       if (inherits(cond, "message")) {
[10:26:06.506]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.506]                         if (muffled) 
[10:26:06.506]                           invokeRestart("muffleMessage")
[10:26:06.506]                       }
[10:26:06.506]                       else if (inherits(cond, "warning")) {
[10:26:06.506]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.506]                         if (muffled) 
[10:26:06.506]                           invokeRestart("muffleWarning")
[10:26:06.506]                       }
[10:26:06.506]                       else if (inherits(cond, "condition")) {
[10:26:06.506]                         if (!is.null(pattern)) {
[10:26:06.506]                           computeRestarts <- base::computeRestarts
[10:26:06.506]                           grepl <- base::grepl
[10:26:06.506]                           restarts <- computeRestarts(cond)
[10:26:06.506]                           for (restart in restarts) {
[10:26:06.506]                             name <- restart$name
[10:26:06.506]                             if (is.null(name)) 
[10:26:06.506]                               next
[10:26:06.506]                             if (!grepl(pattern, name)) 
[10:26:06.506]                               next
[10:26:06.506]                             invokeRestart(restart)
[10:26:06.506]                             muffled <- TRUE
[10:26:06.506]                             break
[10:26:06.506]                           }
[10:26:06.506]                         }
[10:26:06.506]                       }
[10:26:06.506]                       invisible(muffled)
[10:26:06.506]                     }
[10:26:06.506]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.506]                   }
[10:26:06.506]                 }
[10:26:06.506]                 else {
[10:26:06.506]                   if (TRUE) {
[10:26:06.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.506]                     {
[10:26:06.506]                       inherits <- base::inherits
[10:26:06.506]                       invokeRestart <- base::invokeRestart
[10:26:06.506]                       is.null <- base::is.null
[10:26:06.506]                       muffled <- FALSE
[10:26:06.506]                       if (inherits(cond, "message")) {
[10:26:06.506]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.506]                         if (muffled) 
[10:26:06.506]                           invokeRestart("muffleMessage")
[10:26:06.506]                       }
[10:26:06.506]                       else if (inherits(cond, "warning")) {
[10:26:06.506]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.506]                         if (muffled) 
[10:26:06.506]                           invokeRestart("muffleWarning")
[10:26:06.506]                       }
[10:26:06.506]                       else if (inherits(cond, "condition")) {
[10:26:06.506]                         if (!is.null(pattern)) {
[10:26:06.506]                           computeRestarts <- base::computeRestarts
[10:26:06.506]                           grepl <- base::grepl
[10:26:06.506]                           restarts <- computeRestarts(cond)
[10:26:06.506]                           for (restart in restarts) {
[10:26:06.506]                             name <- restart$name
[10:26:06.506]                             if (is.null(name)) 
[10:26:06.506]                               next
[10:26:06.506]                             if (!grepl(pattern, name)) 
[10:26:06.506]                               next
[10:26:06.506]                             invokeRestart(restart)
[10:26:06.506]                             muffled <- TRUE
[10:26:06.506]                             break
[10:26:06.506]                           }
[10:26:06.506]                         }
[10:26:06.506]                       }
[10:26:06.506]                       invisible(muffled)
[10:26:06.506]                     }
[10:26:06.506]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.506]                   }
[10:26:06.506]                 }
[10:26:06.506]             }
[10:26:06.506]         }))
[10:26:06.506]     }, error = function(ex) {
[10:26:06.506]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.506]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.506]                 ...future.rng), started = ...future.startTime, 
[10:26:06.506]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.506]             version = "1.8"), class = "FutureResult")
[10:26:06.506]     }, finally = {
[10:26:06.506]         if (!identical(...future.workdir, getwd())) 
[10:26:06.506]             setwd(...future.workdir)
[10:26:06.506]         {
[10:26:06.506]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.506]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.506]             }
[10:26:06.506]             base::options(...future.oldOptions)
[10:26:06.506]             if (.Platform$OS.type == "windows") {
[10:26:06.506]                 old_names <- names(...future.oldEnvVars)
[10:26:06.506]                 envs <- base::Sys.getenv()
[10:26:06.506]                 names <- names(envs)
[10:26:06.506]                 common <- intersect(names, old_names)
[10:26:06.506]                 added <- setdiff(names, old_names)
[10:26:06.506]                 removed <- setdiff(old_names, names)
[10:26:06.506]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.506]                   envs[common]]
[10:26:06.506]                 NAMES <- toupper(changed)
[10:26:06.506]                 args <- list()
[10:26:06.506]                 for (kk in seq_along(NAMES)) {
[10:26:06.506]                   name <- changed[[kk]]
[10:26:06.506]                   NAME <- NAMES[[kk]]
[10:26:06.506]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.506]                     next
[10:26:06.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.506]                 }
[10:26:06.506]                 NAMES <- toupper(added)
[10:26:06.506]                 for (kk in seq_along(NAMES)) {
[10:26:06.506]                   name <- added[[kk]]
[10:26:06.506]                   NAME <- NAMES[[kk]]
[10:26:06.506]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.506]                     next
[10:26:06.506]                   args[[name]] <- ""
[10:26:06.506]                 }
[10:26:06.506]                 NAMES <- toupper(removed)
[10:26:06.506]                 for (kk in seq_along(NAMES)) {
[10:26:06.506]                   name <- removed[[kk]]
[10:26:06.506]                   NAME <- NAMES[[kk]]
[10:26:06.506]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.506]                     next
[10:26:06.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.506]                 }
[10:26:06.506]                 if (length(args) > 0) 
[10:26:06.506]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.506]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.506]             }
[10:26:06.506]             else {
[10:26:06.506]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.506]             }
[10:26:06.506]             {
[10:26:06.506]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.506]                   0L) {
[10:26:06.506]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.506]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.506]                   base::options(opts)
[10:26:06.506]                 }
[10:26:06.506]                 {
[10:26:06.506]                   {
[10:26:06.506]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:06.506]                     NULL
[10:26:06.506]                   }
[10:26:06.506]                   options(future.plan = NULL)
[10:26:06.506]                   if (is.na(NA_character_)) 
[10:26:06.506]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.506]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.506]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:06.506]                     envir = parent.frame()) 
[10:26:06.506]                   {
[10:26:06.506]                     default_workers <- missing(workers)
[10:26:06.506]                     if (is.function(workers)) 
[10:26:06.506]                       workers <- workers()
[10:26:06.506]                     workers <- structure(as.integer(workers), 
[10:26:06.506]                       class = class(workers))
[10:26:06.506]                     stop_if_not(is.finite(workers), workers >= 
[10:26:06.506]                       1L)
[10:26:06.506]                     if ((workers == 1L && !inherits(workers, 
[10:26:06.506]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:06.506]                       if (default_workers) 
[10:26:06.506]                         supportsMulticore(warn = TRUE)
[10:26:06.506]                       return(sequential(..., envir = envir))
[10:26:06.506]                     }
[10:26:06.506]                     oopts <- options(mc.cores = workers)
[10:26:06.506]                     on.exit(options(oopts))
[10:26:06.506]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:06.506]                       envir = envir)
[10:26:06.506]                     if (!future$lazy) 
[10:26:06.506]                       future <- run(future)
[10:26:06.506]                     invisible(future)
[10:26:06.506]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.506]                 }
[10:26:06.506]             }
[10:26:06.506]         }
[10:26:06.506]     })
[10:26:06.506]     if (TRUE) {
[10:26:06.506]         base::sink(type = "output", split = FALSE)
[10:26:06.506]         if (TRUE) {
[10:26:06.506]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.506]         }
[10:26:06.506]         else {
[10:26:06.506]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.506]         }
[10:26:06.506]         base::close(...future.stdout)
[10:26:06.506]         ...future.stdout <- NULL
[10:26:06.506]     }
[10:26:06.506]     ...future.result$conditions <- ...future.conditions
[10:26:06.506]     ...future.result$finished <- base::Sys.time()
[10:26:06.506]     ...future.result
[10:26:06.506] }
[10:26:06.508] assign_globals() ...
[10:26:06.508] List of 1
[10:26:06.508]  $ x: list()
[10:26:06.508]  - attr(*, "where")=List of 1
[10:26:06.508]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.508]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.508]  - attr(*, "resolved")= logi TRUE
[10:26:06.508]  - attr(*, "total_size")= num 0
[10:26:06.508]  - attr(*, "already-done")= logi TRUE
[10:26:06.511] - copied ‘x’ to environment
[10:26:06.511] assign_globals() ... done
[10:26:06.511] requestCore(): workers = 2
[10:26:06.514] MulticoreFuture started
[10:26:06.514] - Launch lazy future ... done
[10:26:06.515] run() for ‘MulticoreFuture’ ... done
[10:26:06.515] plan(): Setting new future strategy stack:
[10:26:06.515] List of future strategies:
[10:26:06.515] 1. sequential:
[10:26:06.515]    - args: function (..., envir = parent.frame())
[10:26:06.515]    - tweaked: FALSE
[10:26:06.515]    - call: NULL
[10:26:06.516] plan(): nbrOfWorkers() = 1
[10:26:06.516] result() for MulticoreFuture ...
[10:26:06.518] plan(): Setting new future strategy stack:
[10:26:06.518] List of future strategies:
[10:26:06.518] 1. multicore:
[10:26:06.518]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.518]    - tweaked: FALSE
[10:26:06.518]    - call: plan(strategy)
[10:26:06.522] plan(): nbrOfWorkers() = 2
[10:26:06.527] result() for MulticoreFuture ...
[10:26:06.527] result() for MulticoreFuture ... done
[10:26:06.527] result() for MulticoreFuture ... done
[10:26:06.527] result() for MulticoreFuture ...
[10:26:06.528] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.528] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.528] Searching for globals...
[10:26:06.531] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.531] Searching for globals ... DONE
[10:26:06.531] Resolving globals: TRUE
[10:26:06.531] Resolving any globals that are futures ...
[10:26:06.531] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.531] Resolving any globals that are futures ... DONE
[10:26:06.532] Resolving futures part of globals (recursively) ...
[10:26:06.532] resolve() on list ...
[10:26:06.532]  recursive: 99
[10:26:06.532]  length: 1
[10:26:06.532]  elements: ‘x’
[10:26:06.533]  length: 0 (resolved future 1)
[10:26:06.533] resolve() on list ... DONE
[10:26:06.533] - globals: [1] ‘x’
[10:26:06.533] Resolving futures part of globals (recursively) ... DONE
[10:26:06.533] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.533] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.534] - globals: [1] ‘x’
[10:26:06.534] 
[10:26:06.534] getGlobalsAndPackages() ... DONE
[10:26:06.534] run() for ‘Future’ ...
[10:26:06.534] - state: ‘created’
[10:26:06.535] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:06.538] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:06.539] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:06.539]   - Field: ‘label’
[10:26:06.539]   - Field: ‘local’
[10:26:06.539]   - Field: ‘owner’
[10:26:06.539]   - Field: ‘envir’
[10:26:06.539]   - Field: ‘workers’
[10:26:06.539]   - Field: ‘packages’
[10:26:06.539]   - Field: ‘gc’
[10:26:06.542]   - Field: ‘job’
[10:26:06.542]   - Field: ‘conditions’
[10:26:06.542]   - Field: ‘expr’
[10:26:06.542]   - Field: ‘uuid’
[10:26:06.542]   - Field: ‘seed’
[10:26:06.543]   - Field: ‘version’
[10:26:06.543]   - Field: ‘result’
[10:26:06.543]   - Field: ‘asynchronous’
[10:26:06.543]   - Field: ‘calls’
[10:26:06.543]   - Field: ‘globals’
[10:26:06.543]   - Field: ‘stdout’
[10:26:06.543]   - Field: ‘earlySignal’
[10:26:06.543]   - Field: ‘lazy’
[10:26:06.544]   - Field: ‘state’
[10:26:06.544] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:06.544] - Launch lazy future ...
[10:26:06.544] Packages needed by the future expression (n = 0): <none>
[10:26:06.544] Packages needed by future strategies (n = 0): <none>
[10:26:06.545] {
[10:26:06.545]     {
[10:26:06.545]         {
[10:26:06.545]             ...future.startTime <- base::Sys.time()
[10:26:06.545]             {
[10:26:06.545]                 {
[10:26:06.545]                   {
[10:26:06.545]                     {
[10:26:06.545]                       base::local({
[10:26:06.545]                         has_future <- base::requireNamespace("future", 
[10:26:06.545]                           quietly = TRUE)
[10:26:06.545]                         if (has_future) {
[10:26:06.545]                           ns <- base::getNamespace("future")
[10:26:06.545]                           version <- ns[[".package"]][["version"]]
[10:26:06.545]                           if (is.null(version)) 
[10:26:06.545]                             version <- utils::packageVersion("future")
[10:26:06.545]                         }
[10:26:06.545]                         else {
[10:26:06.545]                           version <- NULL
[10:26:06.545]                         }
[10:26:06.545]                         if (!has_future || version < "1.8.0") {
[10:26:06.545]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.545]                             "", base::R.version$version.string), 
[10:26:06.545]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:06.545]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.545]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.545]                               "release", "version")], collapse = " "), 
[10:26:06.545]                             hostname = base::Sys.info()[["nodename"]])
[10:26:06.545]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.545]                             info)
[10:26:06.545]                           info <- base::paste(info, collapse = "; ")
[10:26:06.545]                           if (!has_future) {
[10:26:06.545]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.545]                               info)
[10:26:06.545]                           }
[10:26:06.545]                           else {
[10:26:06.545]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.545]                               info, version)
[10:26:06.545]                           }
[10:26:06.545]                           base::stop(msg)
[10:26:06.545]                         }
[10:26:06.545]                       })
[10:26:06.545]                     }
[10:26:06.545]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:06.545]                     base::options(mc.cores = 1L)
[10:26:06.545]                   }
[10:26:06.545]                   options(future.plan = NULL)
[10:26:06.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.545]                 }
[10:26:06.545]                 ...future.workdir <- getwd()
[10:26:06.545]             }
[10:26:06.545]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.545]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.545]         }
[10:26:06.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.545]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.545]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.545]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.545]             base::names(...future.oldOptions))
[10:26:06.545]     }
[10:26:06.545]     if (FALSE) {
[10:26:06.545]     }
[10:26:06.545]     else {
[10:26:06.545]         if (TRUE) {
[10:26:06.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.545]                 open = "w")
[10:26:06.545]         }
[10:26:06.545]         else {
[10:26:06.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.545]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.545]         }
[10:26:06.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.545]             base::sink(type = "output", split = FALSE)
[10:26:06.545]             base::close(...future.stdout)
[10:26:06.545]         }, add = TRUE)
[10:26:06.545]     }
[10:26:06.545]     ...future.frame <- base::sys.nframe()
[10:26:06.545]     ...future.conditions <- base::list()
[10:26:06.545]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.545]     if (FALSE) {
[10:26:06.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.545]     }
[10:26:06.545]     ...future.result <- base::tryCatch({
[10:26:06.545]         base::withCallingHandlers({
[10:26:06.545]             ...future.value <- base::withVisible(base::local({
[10:26:06.545]                 withCallingHandlers({
[10:26:06.545]                   {
[10:26:06.545]                     x$a <- 1
[10:26:06.545]                     x
[10:26:06.545]                   }
[10:26:06.545]                 }, immediateCondition = function(cond) {
[10:26:06.545]                   save_rds <- function (object, pathname, ...) 
[10:26:06.545]                   {
[10:26:06.545]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:06.545]                     if (file_test("-f", pathname_tmp)) {
[10:26:06.545]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.545]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:06.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.545]                         fi_tmp[["mtime"]])
[10:26:06.545]                     }
[10:26:06.545]                     tryCatch({
[10:26:06.545]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:06.545]                     }, error = function(ex) {
[10:26:06.545]                       msg <- conditionMessage(ex)
[10:26:06.545]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.545]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:06.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.545]                         fi_tmp[["mtime"]], msg)
[10:26:06.545]                       ex$message <- msg
[10:26:06.545]                       stop(ex)
[10:26:06.545]                     })
[10:26:06.545]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:06.545]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:06.545]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:06.545]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.545]                       fi <- file.info(pathname)
[10:26:06.545]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:06.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.545]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:06.545]                         fi[["size"]], fi[["mtime"]])
[10:26:06.545]                       stop(msg)
[10:26:06.545]                     }
[10:26:06.545]                     invisible(pathname)
[10:26:06.545]                   }
[10:26:06.545]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:06.545]                     rootPath = tempdir()) 
[10:26:06.545]                   {
[10:26:06.545]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:06.545]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:06.545]                       tmpdir = path, fileext = ".rds")
[10:26:06.545]                     save_rds(obj, file)
[10:26:06.545]                   }
[10:26:06.545]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4YXwpK/.future/immediateConditions")
[10:26:06.545]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.545]                   {
[10:26:06.545]                     inherits <- base::inherits
[10:26:06.545]                     invokeRestart <- base::invokeRestart
[10:26:06.545]                     is.null <- base::is.null
[10:26:06.545]                     muffled <- FALSE
[10:26:06.545]                     if (inherits(cond, "message")) {
[10:26:06.545]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:06.545]                       if (muffled) 
[10:26:06.545]                         invokeRestart("muffleMessage")
[10:26:06.545]                     }
[10:26:06.545]                     else if (inherits(cond, "warning")) {
[10:26:06.545]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:06.545]                       if (muffled) 
[10:26:06.545]                         invokeRestart("muffleWarning")
[10:26:06.545]                     }
[10:26:06.545]                     else if (inherits(cond, "condition")) {
[10:26:06.545]                       if (!is.null(pattern)) {
[10:26:06.545]                         computeRestarts <- base::computeRestarts
[10:26:06.545]                         grepl <- base::grepl
[10:26:06.545]                         restarts <- computeRestarts(cond)
[10:26:06.545]                         for (restart in restarts) {
[10:26:06.545]                           name <- restart$name
[10:26:06.545]                           if (is.null(name)) 
[10:26:06.545]                             next
[10:26:06.545]                           if (!grepl(pattern, name)) 
[10:26:06.545]                             next
[10:26:06.545]                           invokeRestart(restart)
[10:26:06.545]                           muffled <- TRUE
[10:26:06.545]                           break
[10:26:06.545]                         }
[10:26:06.545]                       }
[10:26:06.545]                     }
[10:26:06.545]                     invisible(muffled)
[10:26:06.545]                   }
[10:26:06.545]                   muffleCondition(cond)
[10:26:06.545]                 })
[10:26:06.545]             }))
[10:26:06.545]             future::FutureResult(value = ...future.value$value, 
[10:26:06.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.545]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.545]                     ...future.globalenv.names))
[10:26:06.545]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.545]         }, condition = base::local({
[10:26:06.545]             c <- base::c
[10:26:06.545]             inherits <- base::inherits
[10:26:06.545]             invokeRestart <- base::invokeRestart
[10:26:06.545]             length <- base::length
[10:26:06.545]             list <- base::list
[10:26:06.545]             seq.int <- base::seq.int
[10:26:06.545]             signalCondition <- base::signalCondition
[10:26:06.545]             sys.calls <- base::sys.calls
[10:26:06.545]             `[[` <- base::`[[`
[10:26:06.545]             `+` <- base::`+`
[10:26:06.545]             `<<-` <- base::`<<-`
[10:26:06.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.545]                   3L)]
[10:26:06.545]             }
[10:26:06.545]             function(cond) {
[10:26:06.545]                 is_error <- inherits(cond, "error")
[10:26:06.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.545]                   NULL)
[10:26:06.545]                 if (is_error) {
[10:26:06.545]                   sessionInformation <- function() {
[10:26:06.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.545]                       search = base::search(), system = base::Sys.info())
[10:26:06.545]                   }
[10:26:06.545]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.545]                     cond$call), session = sessionInformation(), 
[10:26:06.545]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.545]                   signalCondition(cond)
[10:26:06.545]                 }
[10:26:06.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.545]                 "immediateCondition"))) {
[10:26:06.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.545]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.545]                   if (TRUE && !signal) {
[10:26:06.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.545]                     {
[10:26:06.545]                       inherits <- base::inherits
[10:26:06.545]                       invokeRestart <- base::invokeRestart
[10:26:06.545]                       is.null <- base::is.null
[10:26:06.545]                       muffled <- FALSE
[10:26:06.545]                       if (inherits(cond, "message")) {
[10:26:06.545]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.545]                         if (muffled) 
[10:26:06.545]                           invokeRestart("muffleMessage")
[10:26:06.545]                       }
[10:26:06.545]                       else if (inherits(cond, "warning")) {
[10:26:06.545]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.545]                         if (muffled) 
[10:26:06.545]                           invokeRestart("muffleWarning")
[10:26:06.545]                       }
[10:26:06.545]                       else if (inherits(cond, "condition")) {
[10:26:06.545]                         if (!is.null(pattern)) {
[10:26:06.545]                           computeRestarts <- base::computeRestarts
[10:26:06.545]                           grepl <- base::grepl
[10:26:06.545]                           restarts <- computeRestarts(cond)
[10:26:06.545]                           for (restart in restarts) {
[10:26:06.545]                             name <- restart$name
[10:26:06.545]                             if (is.null(name)) 
[10:26:06.545]                               next
[10:26:06.545]                             if (!grepl(pattern, name)) 
[10:26:06.545]                               next
[10:26:06.545]                             invokeRestart(restart)
[10:26:06.545]                             muffled <- TRUE
[10:26:06.545]                             break
[10:26:06.545]                           }
[10:26:06.545]                         }
[10:26:06.545]                       }
[10:26:06.545]                       invisible(muffled)
[10:26:06.545]                     }
[10:26:06.545]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.545]                   }
[10:26:06.545]                 }
[10:26:06.545]                 else {
[10:26:06.545]                   if (TRUE) {
[10:26:06.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.545]                     {
[10:26:06.545]                       inherits <- base::inherits
[10:26:06.545]                       invokeRestart <- base::invokeRestart
[10:26:06.545]                       is.null <- base::is.null
[10:26:06.545]                       muffled <- FALSE
[10:26:06.545]                       if (inherits(cond, "message")) {
[10:26:06.545]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.545]                         if (muffled) 
[10:26:06.545]                           invokeRestart("muffleMessage")
[10:26:06.545]                       }
[10:26:06.545]                       else if (inherits(cond, "warning")) {
[10:26:06.545]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.545]                         if (muffled) 
[10:26:06.545]                           invokeRestart("muffleWarning")
[10:26:06.545]                       }
[10:26:06.545]                       else if (inherits(cond, "condition")) {
[10:26:06.545]                         if (!is.null(pattern)) {
[10:26:06.545]                           computeRestarts <- base::computeRestarts
[10:26:06.545]                           grepl <- base::grepl
[10:26:06.545]                           restarts <- computeRestarts(cond)
[10:26:06.545]                           for (restart in restarts) {
[10:26:06.545]                             name <- restart$name
[10:26:06.545]                             if (is.null(name)) 
[10:26:06.545]                               next
[10:26:06.545]                             if (!grepl(pattern, name)) 
[10:26:06.545]                               next
[10:26:06.545]                             invokeRestart(restart)
[10:26:06.545]                             muffled <- TRUE
[10:26:06.545]                             break
[10:26:06.545]                           }
[10:26:06.545]                         }
[10:26:06.545]                       }
[10:26:06.545]                       invisible(muffled)
[10:26:06.545]                     }
[10:26:06.545]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.545]                   }
[10:26:06.545]                 }
[10:26:06.545]             }
[10:26:06.545]         }))
[10:26:06.545]     }, error = function(ex) {
[10:26:06.545]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.545]                 ...future.rng), started = ...future.startTime, 
[10:26:06.545]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.545]             version = "1.8"), class = "FutureResult")
[10:26:06.545]     }, finally = {
[10:26:06.545]         if (!identical(...future.workdir, getwd())) 
[10:26:06.545]             setwd(...future.workdir)
[10:26:06.545]         {
[10:26:06.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.545]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.545]             }
[10:26:06.545]             base::options(...future.oldOptions)
[10:26:06.545]             if (.Platform$OS.type == "windows") {
[10:26:06.545]                 old_names <- names(...future.oldEnvVars)
[10:26:06.545]                 envs <- base::Sys.getenv()
[10:26:06.545]                 names <- names(envs)
[10:26:06.545]                 common <- intersect(names, old_names)
[10:26:06.545]                 added <- setdiff(names, old_names)
[10:26:06.545]                 removed <- setdiff(old_names, names)
[10:26:06.545]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.545]                   envs[common]]
[10:26:06.545]                 NAMES <- toupper(changed)
[10:26:06.545]                 args <- list()
[10:26:06.545]                 for (kk in seq_along(NAMES)) {
[10:26:06.545]                   name <- changed[[kk]]
[10:26:06.545]                   NAME <- NAMES[[kk]]
[10:26:06.545]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.545]                     next
[10:26:06.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.545]                 }
[10:26:06.545]                 NAMES <- toupper(added)
[10:26:06.545]                 for (kk in seq_along(NAMES)) {
[10:26:06.545]                   name <- added[[kk]]
[10:26:06.545]                   NAME <- NAMES[[kk]]
[10:26:06.545]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.545]                     next
[10:26:06.545]                   args[[name]] <- ""
[10:26:06.545]                 }
[10:26:06.545]                 NAMES <- toupper(removed)
[10:26:06.545]                 for (kk in seq_along(NAMES)) {
[10:26:06.545]                   name <- removed[[kk]]
[10:26:06.545]                   NAME <- NAMES[[kk]]
[10:26:06.545]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.545]                     next
[10:26:06.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.545]                 }
[10:26:06.545]                 if (length(args) > 0) 
[10:26:06.545]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.545]             }
[10:26:06.545]             else {
[10:26:06.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.545]             }
[10:26:06.545]             {
[10:26:06.545]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.545]                   0L) {
[10:26:06.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.545]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.545]                   base::options(opts)
[10:26:06.545]                 }
[10:26:06.545]                 {
[10:26:06.545]                   {
[10:26:06.545]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:06.545]                     NULL
[10:26:06.545]                   }
[10:26:06.545]                   options(future.plan = NULL)
[10:26:06.545]                   if (is.na(NA_character_)) 
[10:26:06.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.545]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:06.545]                     envir = parent.frame()) 
[10:26:06.545]                   {
[10:26:06.545]                     default_workers <- missing(workers)
[10:26:06.545]                     if (is.function(workers)) 
[10:26:06.545]                       workers <- workers()
[10:26:06.545]                     workers <- structure(as.integer(workers), 
[10:26:06.545]                       class = class(workers))
[10:26:06.545]                     stop_if_not(is.finite(workers), workers >= 
[10:26:06.545]                       1L)
[10:26:06.545]                     if ((workers == 1L && !inherits(workers, 
[10:26:06.545]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:06.545]                       if (default_workers) 
[10:26:06.545]                         supportsMulticore(warn = TRUE)
[10:26:06.545]                       return(sequential(..., envir = envir))
[10:26:06.545]                     }
[10:26:06.545]                     oopts <- options(mc.cores = workers)
[10:26:06.545]                     on.exit(options(oopts))
[10:26:06.545]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:06.545]                       envir = envir)
[10:26:06.545]                     if (!future$lazy) 
[10:26:06.545]                       future <- run(future)
[10:26:06.545]                     invisible(future)
[10:26:06.545]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.545]                 }
[10:26:06.545]             }
[10:26:06.545]         }
[10:26:06.545]     })
[10:26:06.545]     if (TRUE) {
[10:26:06.545]         base::sink(type = "output", split = FALSE)
[10:26:06.545]         if (TRUE) {
[10:26:06.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.545]         }
[10:26:06.545]         else {
[10:26:06.545]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.545]         }
[10:26:06.545]         base::close(...future.stdout)
[10:26:06.545]         ...future.stdout <- NULL
[10:26:06.545]     }
[10:26:06.545]     ...future.result$conditions <- ...future.conditions
[10:26:06.545]     ...future.result$finished <- base::Sys.time()
[10:26:06.545]     ...future.result
[10:26:06.545] }
[10:26:06.547] assign_globals() ...
[10:26:06.548] List of 1
[10:26:06.548]  $ x: list()
[10:26:06.548]  - attr(*, "where")=List of 1
[10:26:06.548]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.548]  - attr(*, "resolved")= logi TRUE
[10:26:06.548]  - attr(*, "total_size")= num 0
[10:26:06.548]  - attr(*, "already-done")= logi TRUE
[10:26:06.551] - copied ‘x’ to environment
[10:26:06.551] assign_globals() ... done
[10:26:06.551] requestCore(): workers = 2
[10:26:06.553] MulticoreFuture started
[10:26:06.553] - Launch lazy future ... done
[10:26:06.554] run() for ‘MulticoreFuture’ ... done
[10:26:06.554] result() for MulticoreFuture ...
[10:26:06.554] plan(): Setting new future strategy stack:
[10:26:06.554] List of future strategies:
[10:26:06.554] 1. sequential:
[10:26:06.554]    - args: function (..., envir = parent.frame())
[10:26:06.554]    - tweaked: FALSE
[10:26:06.554]    - call: NULL
[10:26:06.555] plan(): nbrOfWorkers() = 1
[10:26:06.557] plan(): Setting new future strategy stack:
[10:26:06.557] List of future strategies:
[10:26:06.557] 1. multicore:
[10:26:06.557]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.557]    - tweaked: FALSE
[10:26:06.557]    - call: plan(strategy)
[10:26:06.562] plan(): nbrOfWorkers() = 2
[10:26:06.563] result() for MulticoreFuture ...
[10:26:06.564] result() for MulticoreFuture ... done
[10:26:06.564] result() for MulticoreFuture ... done
[10:26:06.564] result() for MulticoreFuture ...
[10:26:06.564] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.565] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.565] Searching for globals...
[10:26:06.568] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.568] Searching for globals ... DONE
[10:26:06.568] Resolving globals: TRUE
[10:26:06.568] Resolving any globals that are futures ...
[10:26:06.568] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.568] Resolving any globals that are futures ... DONE
[10:26:06.569] Resolving futures part of globals (recursively) ...
[10:26:06.569] resolve() on list ...
[10:26:06.569]  recursive: 99
[10:26:06.569]  length: 1
[10:26:06.570]  elements: ‘x’
[10:26:06.570]  length: 0 (resolved future 1)
[10:26:06.570] resolve() on list ... DONE
[10:26:06.570] - globals: [1] ‘x’
[10:26:06.570] Resolving futures part of globals (recursively) ... DONE
[10:26:06.570] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.571] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.571] - globals: [1] ‘x’
[10:26:06.571] 
[10:26:06.571] getGlobalsAndPackages() ... DONE
[10:26:06.571] run() for ‘Future’ ...
[10:26:06.571] - state: ‘created’
[10:26:06.572] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:06.576] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:06.576] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:06.576]   - Field: ‘label’
[10:26:06.576]   - Field: ‘local’
[10:26:06.576]   - Field: ‘owner’
[10:26:06.576]   - Field: ‘envir’
[10:26:06.576]   - Field: ‘workers’
[10:26:06.576]   - Field: ‘packages’
[10:26:06.577]   - Field: ‘gc’
[10:26:06.577]   - Field: ‘job’
[10:26:06.577]   - Field: ‘conditions’
[10:26:06.577]   - Field: ‘expr’
[10:26:06.577]   - Field: ‘uuid’
[10:26:06.577]   - Field: ‘seed’
[10:26:06.577]   - Field: ‘version’
[10:26:06.577]   - Field: ‘result’
[10:26:06.578]   - Field: ‘asynchronous’
[10:26:06.578]   - Field: ‘calls’
[10:26:06.578]   - Field: ‘globals’
[10:26:06.578]   - Field: ‘stdout’
[10:26:06.578]   - Field: ‘earlySignal’
[10:26:06.578]   - Field: ‘lazy’
[10:26:06.578]   - Field: ‘state’
[10:26:06.578] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:06.578] - Launch lazy future ...
[10:26:06.579] Packages needed by the future expression (n = 0): <none>
[10:26:06.579] Packages needed by future strategies (n = 0): <none>
[10:26:06.579] {
[10:26:06.579]     {
[10:26:06.579]         {
[10:26:06.579]             ...future.startTime <- base::Sys.time()
[10:26:06.579]             {
[10:26:06.579]                 {
[10:26:06.579]                   {
[10:26:06.579]                     {
[10:26:06.579]                       base::local({
[10:26:06.579]                         has_future <- base::requireNamespace("future", 
[10:26:06.579]                           quietly = TRUE)
[10:26:06.579]                         if (has_future) {
[10:26:06.579]                           ns <- base::getNamespace("future")
[10:26:06.579]                           version <- ns[[".package"]][["version"]]
[10:26:06.579]                           if (is.null(version)) 
[10:26:06.579]                             version <- utils::packageVersion("future")
[10:26:06.579]                         }
[10:26:06.579]                         else {
[10:26:06.579]                           version <- NULL
[10:26:06.579]                         }
[10:26:06.579]                         if (!has_future || version < "1.8.0") {
[10:26:06.579]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.579]                             "", base::R.version$version.string), 
[10:26:06.579]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:06.579]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.579]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.579]                               "release", "version")], collapse = " "), 
[10:26:06.579]                             hostname = base::Sys.info()[["nodename"]])
[10:26:06.579]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.579]                             info)
[10:26:06.579]                           info <- base::paste(info, collapse = "; ")
[10:26:06.579]                           if (!has_future) {
[10:26:06.579]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.579]                               info)
[10:26:06.579]                           }
[10:26:06.579]                           else {
[10:26:06.579]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.579]                               info, version)
[10:26:06.579]                           }
[10:26:06.579]                           base::stop(msg)
[10:26:06.579]                         }
[10:26:06.579]                       })
[10:26:06.579]                     }
[10:26:06.579]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:06.579]                     base::options(mc.cores = 1L)
[10:26:06.579]                   }
[10:26:06.579]                   options(future.plan = NULL)
[10:26:06.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.579]                 }
[10:26:06.579]                 ...future.workdir <- getwd()
[10:26:06.579]             }
[10:26:06.579]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.579]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.579]         }
[10:26:06.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.579]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.579]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.579]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.579]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.579]             base::names(...future.oldOptions))
[10:26:06.579]     }
[10:26:06.579]     if (FALSE) {
[10:26:06.579]     }
[10:26:06.579]     else {
[10:26:06.579]         if (TRUE) {
[10:26:06.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.579]                 open = "w")
[10:26:06.579]         }
[10:26:06.579]         else {
[10:26:06.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.579]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.579]         }
[10:26:06.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.579]             base::sink(type = "output", split = FALSE)
[10:26:06.579]             base::close(...future.stdout)
[10:26:06.579]         }, add = TRUE)
[10:26:06.579]     }
[10:26:06.579]     ...future.frame <- base::sys.nframe()
[10:26:06.579]     ...future.conditions <- base::list()
[10:26:06.579]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.579]     if (FALSE) {
[10:26:06.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.579]     }
[10:26:06.579]     ...future.result <- base::tryCatch({
[10:26:06.579]         base::withCallingHandlers({
[10:26:06.579]             ...future.value <- base::withVisible(base::local({
[10:26:06.579]                 withCallingHandlers({
[10:26:06.579]                   {
[10:26:06.579]                     x$a <- 1
[10:26:06.579]                     x
[10:26:06.579]                   }
[10:26:06.579]                 }, immediateCondition = function(cond) {
[10:26:06.579]                   save_rds <- function (object, pathname, ...) 
[10:26:06.579]                   {
[10:26:06.579]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:06.579]                     if (file_test("-f", pathname_tmp)) {
[10:26:06.579]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.579]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:06.579]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.579]                         fi_tmp[["mtime"]])
[10:26:06.579]                     }
[10:26:06.579]                     tryCatch({
[10:26:06.579]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:06.579]                     }, error = function(ex) {
[10:26:06.579]                       msg <- conditionMessage(ex)
[10:26:06.579]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.579]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:06.579]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.579]                         fi_tmp[["mtime"]], msg)
[10:26:06.579]                       ex$message <- msg
[10:26:06.579]                       stop(ex)
[10:26:06.579]                     })
[10:26:06.579]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:06.579]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:06.579]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:06.579]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.579]                       fi <- file.info(pathname)
[10:26:06.579]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:06.579]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.579]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:06.579]                         fi[["size"]], fi[["mtime"]])
[10:26:06.579]                       stop(msg)
[10:26:06.579]                     }
[10:26:06.579]                     invisible(pathname)
[10:26:06.579]                   }
[10:26:06.579]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:06.579]                     rootPath = tempdir()) 
[10:26:06.579]                   {
[10:26:06.579]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:06.579]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:06.579]                       tmpdir = path, fileext = ".rds")
[10:26:06.579]                     save_rds(obj, file)
[10:26:06.579]                   }
[10:26:06.579]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4YXwpK/.future/immediateConditions")
[10:26:06.579]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.579]                   {
[10:26:06.579]                     inherits <- base::inherits
[10:26:06.579]                     invokeRestart <- base::invokeRestart
[10:26:06.579]                     is.null <- base::is.null
[10:26:06.579]                     muffled <- FALSE
[10:26:06.579]                     if (inherits(cond, "message")) {
[10:26:06.579]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:06.579]                       if (muffled) 
[10:26:06.579]                         invokeRestart("muffleMessage")
[10:26:06.579]                     }
[10:26:06.579]                     else if (inherits(cond, "warning")) {
[10:26:06.579]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:06.579]                       if (muffled) 
[10:26:06.579]                         invokeRestart("muffleWarning")
[10:26:06.579]                     }
[10:26:06.579]                     else if (inherits(cond, "condition")) {
[10:26:06.579]                       if (!is.null(pattern)) {
[10:26:06.579]                         computeRestarts <- base::computeRestarts
[10:26:06.579]                         grepl <- base::grepl
[10:26:06.579]                         restarts <- computeRestarts(cond)
[10:26:06.579]                         for (restart in restarts) {
[10:26:06.579]                           name <- restart$name
[10:26:06.579]                           if (is.null(name)) 
[10:26:06.579]                             next
[10:26:06.579]                           if (!grepl(pattern, name)) 
[10:26:06.579]                             next
[10:26:06.579]                           invokeRestart(restart)
[10:26:06.579]                           muffled <- TRUE
[10:26:06.579]                           break
[10:26:06.579]                         }
[10:26:06.579]                       }
[10:26:06.579]                     }
[10:26:06.579]                     invisible(muffled)
[10:26:06.579]                   }
[10:26:06.579]                   muffleCondition(cond)
[10:26:06.579]                 })
[10:26:06.579]             }))
[10:26:06.579]             future::FutureResult(value = ...future.value$value, 
[10:26:06.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.579]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.579]                     ...future.globalenv.names))
[10:26:06.579]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.579]         }, condition = base::local({
[10:26:06.579]             c <- base::c
[10:26:06.579]             inherits <- base::inherits
[10:26:06.579]             invokeRestart <- base::invokeRestart
[10:26:06.579]             length <- base::length
[10:26:06.579]             list <- base::list
[10:26:06.579]             seq.int <- base::seq.int
[10:26:06.579]             signalCondition <- base::signalCondition
[10:26:06.579]             sys.calls <- base::sys.calls
[10:26:06.579]             `[[` <- base::`[[`
[10:26:06.579]             `+` <- base::`+`
[10:26:06.579]             `<<-` <- base::`<<-`
[10:26:06.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.579]                   3L)]
[10:26:06.579]             }
[10:26:06.579]             function(cond) {
[10:26:06.579]                 is_error <- inherits(cond, "error")
[10:26:06.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.579]                   NULL)
[10:26:06.579]                 if (is_error) {
[10:26:06.579]                   sessionInformation <- function() {
[10:26:06.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.579]                       search = base::search(), system = base::Sys.info())
[10:26:06.579]                   }
[10:26:06.579]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.579]                     cond$call), session = sessionInformation(), 
[10:26:06.579]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.579]                   signalCondition(cond)
[10:26:06.579]                 }
[10:26:06.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.579]                 "immediateCondition"))) {
[10:26:06.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.579]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.579]                   if (TRUE && !signal) {
[10:26:06.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.579]                     {
[10:26:06.579]                       inherits <- base::inherits
[10:26:06.579]                       invokeRestart <- base::invokeRestart
[10:26:06.579]                       is.null <- base::is.null
[10:26:06.579]                       muffled <- FALSE
[10:26:06.579]                       if (inherits(cond, "message")) {
[10:26:06.579]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.579]                         if (muffled) 
[10:26:06.579]                           invokeRestart("muffleMessage")
[10:26:06.579]                       }
[10:26:06.579]                       else if (inherits(cond, "warning")) {
[10:26:06.579]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.579]                         if (muffled) 
[10:26:06.579]                           invokeRestart("muffleWarning")
[10:26:06.579]                       }
[10:26:06.579]                       else if (inherits(cond, "condition")) {
[10:26:06.579]                         if (!is.null(pattern)) {
[10:26:06.579]                           computeRestarts <- base::computeRestarts
[10:26:06.579]                           grepl <- base::grepl
[10:26:06.579]                           restarts <- computeRestarts(cond)
[10:26:06.579]                           for (restart in restarts) {
[10:26:06.579]                             name <- restart$name
[10:26:06.579]                             if (is.null(name)) 
[10:26:06.579]                               next
[10:26:06.579]                             if (!grepl(pattern, name)) 
[10:26:06.579]                               next
[10:26:06.579]                             invokeRestart(restart)
[10:26:06.579]                             muffled <- TRUE
[10:26:06.579]                             break
[10:26:06.579]                           }
[10:26:06.579]                         }
[10:26:06.579]                       }
[10:26:06.579]                       invisible(muffled)
[10:26:06.579]                     }
[10:26:06.579]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.579]                   }
[10:26:06.579]                 }
[10:26:06.579]                 else {
[10:26:06.579]                   if (TRUE) {
[10:26:06.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.579]                     {
[10:26:06.579]                       inherits <- base::inherits
[10:26:06.579]                       invokeRestart <- base::invokeRestart
[10:26:06.579]                       is.null <- base::is.null
[10:26:06.579]                       muffled <- FALSE
[10:26:06.579]                       if (inherits(cond, "message")) {
[10:26:06.579]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.579]                         if (muffled) 
[10:26:06.579]                           invokeRestart("muffleMessage")
[10:26:06.579]                       }
[10:26:06.579]                       else if (inherits(cond, "warning")) {
[10:26:06.579]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.579]                         if (muffled) 
[10:26:06.579]                           invokeRestart("muffleWarning")
[10:26:06.579]                       }
[10:26:06.579]                       else if (inherits(cond, "condition")) {
[10:26:06.579]                         if (!is.null(pattern)) {
[10:26:06.579]                           computeRestarts <- base::computeRestarts
[10:26:06.579]                           grepl <- base::grepl
[10:26:06.579]                           restarts <- computeRestarts(cond)
[10:26:06.579]                           for (restart in restarts) {
[10:26:06.579]                             name <- restart$name
[10:26:06.579]                             if (is.null(name)) 
[10:26:06.579]                               next
[10:26:06.579]                             if (!grepl(pattern, name)) 
[10:26:06.579]                               next
[10:26:06.579]                             invokeRestart(restart)
[10:26:06.579]                             muffled <- TRUE
[10:26:06.579]                             break
[10:26:06.579]                           }
[10:26:06.579]                         }
[10:26:06.579]                       }
[10:26:06.579]                       invisible(muffled)
[10:26:06.579]                     }
[10:26:06.579]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.579]                   }
[10:26:06.579]                 }
[10:26:06.579]             }
[10:26:06.579]         }))
[10:26:06.579]     }, error = function(ex) {
[10:26:06.579]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.579]                 ...future.rng), started = ...future.startTime, 
[10:26:06.579]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.579]             version = "1.8"), class = "FutureResult")
[10:26:06.579]     }, finally = {
[10:26:06.579]         if (!identical(...future.workdir, getwd())) 
[10:26:06.579]             setwd(...future.workdir)
[10:26:06.579]         {
[10:26:06.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.579]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.579]             }
[10:26:06.579]             base::options(...future.oldOptions)
[10:26:06.579]             if (.Platform$OS.type == "windows") {
[10:26:06.579]                 old_names <- names(...future.oldEnvVars)
[10:26:06.579]                 envs <- base::Sys.getenv()
[10:26:06.579]                 names <- names(envs)
[10:26:06.579]                 common <- intersect(names, old_names)
[10:26:06.579]                 added <- setdiff(names, old_names)
[10:26:06.579]                 removed <- setdiff(old_names, names)
[10:26:06.579]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.579]                   envs[common]]
[10:26:06.579]                 NAMES <- toupper(changed)
[10:26:06.579]                 args <- list()
[10:26:06.579]                 for (kk in seq_along(NAMES)) {
[10:26:06.579]                   name <- changed[[kk]]
[10:26:06.579]                   NAME <- NAMES[[kk]]
[10:26:06.579]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.579]                     next
[10:26:06.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.579]                 }
[10:26:06.579]                 NAMES <- toupper(added)
[10:26:06.579]                 for (kk in seq_along(NAMES)) {
[10:26:06.579]                   name <- added[[kk]]
[10:26:06.579]                   NAME <- NAMES[[kk]]
[10:26:06.579]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.579]                     next
[10:26:06.579]                   args[[name]] <- ""
[10:26:06.579]                 }
[10:26:06.579]                 NAMES <- toupper(removed)
[10:26:06.579]                 for (kk in seq_along(NAMES)) {
[10:26:06.579]                   name <- removed[[kk]]
[10:26:06.579]                   NAME <- NAMES[[kk]]
[10:26:06.579]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.579]                     next
[10:26:06.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.579]                 }
[10:26:06.579]                 if (length(args) > 0) 
[10:26:06.579]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.579]             }
[10:26:06.579]             else {
[10:26:06.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.579]             }
[10:26:06.579]             {
[10:26:06.579]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.579]                   0L) {
[10:26:06.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.579]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.579]                   base::options(opts)
[10:26:06.579]                 }
[10:26:06.579]                 {
[10:26:06.579]                   {
[10:26:06.579]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:06.579]                     NULL
[10:26:06.579]                   }
[10:26:06.579]                   options(future.plan = NULL)
[10:26:06.579]                   if (is.na(NA_character_)) 
[10:26:06.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.579]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:06.579]                     envir = parent.frame()) 
[10:26:06.579]                   {
[10:26:06.579]                     default_workers <- missing(workers)
[10:26:06.579]                     if (is.function(workers)) 
[10:26:06.579]                       workers <- workers()
[10:26:06.579]                     workers <- structure(as.integer(workers), 
[10:26:06.579]                       class = class(workers))
[10:26:06.579]                     stop_if_not(is.finite(workers), workers >= 
[10:26:06.579]                       1L)
[10:26:06.579]                     if ((workers == 1L && !inherits(workers, 
[10:26:06.579]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:06.579]                       if (default_workers) 
[10:26:06.579]                         supportsMulticore(warn = TRUE)
[10:26:06.579]                       return(sequential(..., envir = envir))
[10:26:06.579]                     }
[10:26:06.579]                     oopts <- options(mc.cores = workers)
[10:26:06.579]                     on.exit(options(oopts))
[10:26:06.579]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:06.579]                       envir = envir)
[10:26:06.579]                     if (!future$lazy) 
[10:26:06.579]                       future <- run(future)
[10:26:06.579]                     invisible(future)
[10:26:06.579]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.579]                 }
[10:26:06.579]             }
[10:26:06.579]         }
[10:26:06.579]     })
[10:26:06.579]     if (TRUE) {
[10:26:06.579]         base::sink(type = "output", split = FALSE)
[10:26:06.579]         if (TRUE) {
[10:26:06.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.579]         }
[10:26:06.579]         else {
[10:26:06.579]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.579]         }
[10:26:06.579]         base::close(...future.stdout)
[10:26:06.579]         ...future.stdout <- NULL
[10:26:06.579]     }
[10:26:06.579]     ...future.result$conditions <- ...future.conditions
[10:26:06.579]     ...future.result$finished <- base::Sys.time()
[10:26:06.579]     ...future.result
[10:26:06.579] }
[10:26:06.582] assign_globals() ...
[10:26:06.582] List of 1
[10:26:06.582]  $ x: list()
[10:26:06.582]  - attr(*, "where")=List of 1
[10:26:06.582]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.582]  - attr(*, "resolved")= logi TRUE
[10:26:06.582]  - attr(*, "total_size")= num 0
[10:26:06.582]  - attr(*, "already-done")= logi TRUE
[10:26:06.585] - copied ‘x’ to environment
[10:26:06.585] assign_globals() ... done
[10:26:06.586] requestCore(): workers = 2
[10:26:06.587] MulticoreFuture started
[10:26:06.588] - Launch lazy future ... done
[10:26:06.588] run() for ‘MulticoreFuture’ ... done
[10:26:06.588] result() for MulticoreFuture ...
[10:26:06.588] plan(): Setting new future strategy stack:
[10:26:06.589] List of future strategies:
[10:26:06.589] 1. sequential:
[10:26:06.589]    - args: function (..., envir = parent.frame())
[10:26:06.589]    - tweaked: FALSE
[10:26:06.589]    - call: NULL
[10:26:06.590] plan(): nbrOfWorkers() = 1
[10:26:06.591] plan(): Setting new future strategy stack:
[10:26:06.592] List of future strategies:
[10:26:06.592] 1. multicore:
[10:26:06.592]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.592]    - tweaked: FALSE
[10:26:06.592]    - call: plan(strategy)
[10:26:06.601] plan(): nbrOfWorkers() = 2
[10:26:06.602] result() for MulticoreFuture ...
[10:26:06.602] result() for MulticoreFuture ... done
[10:26:06.602] result() for MulticoreFuture ... done
[10:26:06.602] result() for MulticoreFuture ...
[10:26:06.602] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.603] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.603] Searching for globals...
[10:26:06.608] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.609] Searching for globals ... DONE
[10:26:06.609] Resolving globals: TRUE
[10:26:06.609] Resolving any globals that are futures ...
[10:26:06.609] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:06.609] Resolving any globals that are futures ... DONE
[10:26:06.610] Resolving futures part of globals (recursively) ...
[10:26:06.610] resolve() on list ...
[10:26:06.610]  recursive: 99
[10:26:06.610]  length: 1
[10:26:06.610]  elements: ‘x’
[10:26:06.610]  length: 0 (resolved future 1)
[10:26:06.611] resolve() on list ... DONE
[10:26:06.611] - globals: [1] ‘x’
[10:26:06.611] Resolving futures part of globals (recursively) ... DONE
[10:26:06.611] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.611] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.612] - globals: [1] ‘x’
[10:26:06.612] 
[10:26:06.612] getGlobalsAndPackages() ... DONE
[10:26:06.612] run() for ‘Future’ ...
[10:26:06.612] - state: ‘created’
[10:26:06.612] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:06.616] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:06.617] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:06.617]   - Field: ‘label’
[10:26:06.617]   - Field: ‘local’
[10:26:06.617]   - Field: ‘owner’
[10:26:06.617]   - Field: ‘envir’
[10:26:06.617]   - Field: ‘workers’
[10:26:06.617]   - Field: ‘packages’
[10:26:06.617]   - Field: ‘gc’
[10:26:06.618]   - Field: ‘job’
[10:26:06.618]   - Field: ‘conditions’
[10:26:06.618]   - Field: ‘expr’
[10:26:06.618]   - Field: ‘uuid’
[10:26:06.618]   - Field: ‘seed’
[10:26:06.618]   - Field: ‘version’
[10:26:06.618]   - Field: ‘result’
[10:26:06.618]   - Field: ‘asynchronous’
[10:26:06.619]   - Field: ‘calls’
[10:26:06.619]   - Field: ‘globals’
[10:26:06.619]   - Field: ‘stdout’
[10:26:06.619]   - Field: ‘earlySignal’
[10:26:06.619]   - Field: ‘lazy’
[10:26:06.619]   - Field: ‘state’
[10:26:06.619] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:06.619] - Launch lazy future ...
[10:26:06.620] Packages needed by the future expression (n = 0): <none>
[10:26:06.620] Packages needed by future strategies (n = 0): <none>
[10:26:06.620] {
[10:26:06.620]     {
[10:26:06.620]         {
[10:26:06.620]             ...future.startTime <- base::Sys.time()
[10:26:06.620]             {
[10:26:06.620]                 {
[10:26:06.620]                   {
[10:26:06.620]                     {
[10:26:06.620]                       base::local({
[10:26:06.620]                         has_future <- base::requireNamespace("future", 
[10:26:06.620]                           quietly = TRUE)
[10:26:06.620]                         if (has_future) {
[10:26:06.620]                           ns <- base::getNamespace("future")
[10:26:06.620]                           version <- ns[[".package"]][["version"]]
[10:26:06.620]                           if (is.null(version)) 
[10:26:06.620]                             version <- utils::packageVersion("future")
[10:26:06.620]                         }
[10:26:06.620]                         else {
[10:26:06.620]                           version <- NULL
[10:26:06.620]                         }
[10:26:06.620]                         if (!has_future || version < "1.8.0") {
[10:26:06.620]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.620]                             "", base::R.version$version.string), 
[10:26:06.620]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:06.620]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.620]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.620]                               "release", "version")], collapse = " "), 
[10:26:06.620]                             hostname = base::Sys.info()[["nodename"]])
[10:26:06.620]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.620]                             info)
[10:26:06.620]                           info <- base::paste(info, collapse = "; ")
[10:26:06.620]                           if (!has_future) {
[10:26:06.620]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.620]                               info)
[10:26:06.620]                           }
[10:26:06.620]                           else {
[10:26:06.620]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.620]                               info, version)
[10:26:06.620]                           }
[10:26:06.620]                           base::stop(msg)
[10:26:06.620]                         }
[10:26:06.620]                       })
[10:26:06.620]                     }
[10:26:06.620]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:06.620]                     base::options(mc.cores = 1L)
[10:26:06.620]                   }
[10:26:06.620]                   options(future.plan = NULL)
[10:26:06.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.620]                 }
[10:26:06.620]                 ...future.workdir <- getwd()
[10:26:06.620]             }
[10:26:06.620]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.620]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.620]         }
[10:26:06.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.620]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.620]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.620]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.620]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.620]             base::names(...future.oldOptions))
[10:26:06.620]     }
[10:26:06.620]     if (FALSE) {
[10:26:06.620]     }
[10:26:06.620]     else {
[10:26:06.620]         if (TRUE) {
[10:26:06.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.620]                 open = "w")
[10:26:06.620]         }
[10:26:06.620]         else {
[10:26:06.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.620]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.620]         }
[10:26:06.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.620]             base::sink(type = "output", split = FALSE)
[10:26:06.620]             base::close(...future.stdout)
[10:26:06.620]         }, add = TRUE)
[10:26:06.620]     }
[10:26:06.620]     ...future.frame <- base::sys.nframe()
[10:26:06.620]     ...future.conditions <- base::list()
[10:26:06.620]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.620]     if (FALSE) {
[10:26:06.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.620]     }
[10:26:06.620]     ...future.result <- base::tryCatch({
[10:26:06.620]         base::withCallingHandlers({
[10:26:06.620]             ...future.value <- base::withVisible(base::local({
[10:26:06.620]                 withCallingHandlers({
[10:26:06.620]                   {
[10:26:06.620]                     x$a <- 1
[10:26:06.620]                     x
[10:26:06.620]                   }
[10:26:06.620]                 }, immediateCondition = function(cond) {
[10:26:06.620]                   save_rds <- function (object, pathname, ...) 
[10:26:06.620]                   {
[10:26:06.620]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:06.620]                     if (file_test("-f", pathname_tmp)) {
[10:26:06.620]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.620]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:06.620]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.620]                         fi_tmp[["mtime"]])
[10:26:06.620]                     }
[10:26:06.620]                     tryCatch({
[10:26:06.620]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:06.620]                     }, error = function(ex) {
[10:26:06.620]                       msg <- conditionMessage(ex)
[10:26:06.620]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.620]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:06.620]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.620]                         fi_tmp[["mtime"]], msg)
[10:26:06.620]                       ex$message <- msg
[10:26:06.620]                       stop(ex)
[10:26:06.620]                     })
[10:26:06.620]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:06.620]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:06.620]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:06.620]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.620]                       fi <- file.info(pathname)
[10:26:06.620]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:06.620]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.620]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:06.620]                         fi[["size"]], fi[["mtime"]])
[10:26:06.620]                       stop(msg)
[10:26:06.620]                     }
[10:26:06.620]                     invisible(pathname)
[10:26:06.620]                   }
[10:26:06.620]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:06.620]                     rootPath = tempdir()) 
[10:26:06.620]                   {
[10:26:06.620]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:06.620]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:06.620]                       tmpdir = path, fileext = ".rds")
[10:26:06.620]                     save_rds(obj, file)
[10:26:06.620]                   }
[10:26:06.620]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4YXwpK/.future/immediateConditions")
[10:26:06.620]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.620]                   {
[10:26:06.620]                     inherits <- base::inherits
[10:26:06.620]                     invokeRestart <- base::invokeRestart
[10:26:06.620]                     is.null <- base::is.null
[10:26:06.620]                     muffled <- FALSE
[10:26:06.620]                     if (inherits(cond, "message")) {
[10:26:06.620]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:06.620]                       if (muffled) 
[10:26:06.620]                         invokeRestart("muffleMessage")
[10:26:06.620]                     }
[10:26:06.620]                     else if (inherits(cond, "warning")) {
[10:26:06.620]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:06.620]                       if (muffled) 
[10:26:06.620]                         invokeRestart("muffleWarning")
[10:26:06.620]                     }
[10:26:06.620]                     else if (inherits(cond, "condition")) {
[10:26:06.620]                       if (!is.null(pattern)) {
[10:26:06.620]                         computeRestarts <- base::computeRestarts
[10:26:06.620]                         grepl <- base::grepl
[10:26:06.620]                         restarts <- computeRestarts(cond)
[10:26:06.620]                         for (restart in restarts) {
[10:26:06.620]                           name <- restart$name
[10:26:06.620]                           if (is.null(name)) 
[10:26:06.620]                             next
[10:26:06.620]                           if (!grepl(pattern, name)) 
[10:26:06.620]                             next
[10:26:06.620]                           invokeRestart(restart)
[10:26:06.620]                           muffled <- TRUE
[10:26:06.620]                           break
[10:26:06.620]                         }
[10:26:06.620]                       }
[10:26:06.620]                     }
[10:26:06.620]                     invisible(muffled)
[10:26:06.620]                   }
[10:26:06.620]                   muffleCondition(cond)
[10:26:06.620]                 })
[10:26:06.620]             }))
[10:26:06.620]             future::FutureResult(value = ...future.value$value, 
[10:26:06.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.620]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.620]                     ...future.globalenv.names))
[10:26:06.620]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.620]         }, condition = base::local({
[10:26:06.620]             c <- base::c
[10:26:06.620]             inherits <- base::inherits
[10:26:06.620]             invokeRestart <- base::invokeRestart
[10:26:06.620]             length <- base::length
[10:26:06.620]             list <- base::list
[10:26:06.620]             seq.int <- base::seq.int
[10:26:06.620]             signalCondition <- base::signalCondition
[10:26:06.620]             sys.calls <- base::sys.calls
[10:26:06.620]             `[[` <- base::`[[`
[10:26:06.620]             `+` <- base::`+`
[10:26:06.620]             `<<-` <- base::`<<-`
[10:26:06.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.620]                   3L)]
[10:26:06.620]             }
[10:26:06.620]             function(cond) {
[10:26:06.620]                 is_error <- inherits(cond, "error")
[10:26:06.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.620]                   NULL)
[10:26:06.620]                 if (is_error) {
[10:26:06.620]                   sessionInformation <- function() {
[10:26:06.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.620]                       search = base::search(), system = base::Sys.info())
[10:26:06.620]                   }
[10:26:06.620]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.620]                     cond$call), session = sessionInformation(), 
[10:26:06.620]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.620]                   signalCondition(cond)
[10:26:06.620]                 }
[10:26:06.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.620]                 "immediateCondition"))) {
[10:26:06.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.620]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.620]                   if (TRUE && !signal) {
[10:26:06.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.620]                     {
[10:26:06.620]                       inherits <- base::inherits
[10:26:06.620]                       invokeRestart <- base::invokeRestart
[10:26:06.620]                       is.null <- base::is.null
[10:26:06.620]                       muffled <- FALSE
[10:26:06.620]                       if (inherits(cond, "message")) {
[10:26:06.620]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.620]                         if (muffled) 
[10:26:06.620]                           invokeRestart("muffleMessage")
[10:26:06.620]                       }
[10:26:06.620]                       else if (inherits(cond, "warning")) {
[10:26:06.620]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.620]                         if (muffled) 
[10:26:06.620]                           invokeRestart("muffleWarning")
[10:26:06.620]                       }
[10:26:06.620]                       else if (inherits(cond, "condition")) {
[10:26:06.620]                         if (!is.null(pattern)) {
[10:26:06.620]                           computeRestarts <- base::computeRestarts
[10:26:06.620]                           grepl <- base::grepl
[10:26:06.620]                           restarts <- computeRestarts(cond)
[10:26:06.620]                           for (restart in restarts) {
[10:26:06.620]                             name <- restart$name
[10:26:06.620]                             if (is.null(name)) 
[10:26:06.620]                               next
[10:26:06.620]                             if (!grepl(pattern, name)) 
[10:26:06.620]                               next
[10:26:06.620]                             invokeRestart(restart)
[10:26:06.620]                             muffled <- TRUE
[10:26:06.620]                             break
[10:26:06.620]                           }
[10:26:06.620]                         }
[10:26:06.620]                       }
[10:26:06.620]                       invisible(muffled)
[10:26:06.620]                     }
[10:26:06.620]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.620]                   }
[10:26:06.620]                 }
[10:26:06.620]                 else {
[10:26:06.620]                   if (TRUE) {
[10:26:06.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.620]                     {
[10:26:06.620]                       inherits <- base::inherits
[10:26:06.620]                       invokeRestart <- base::invokeRestart
[10:26:06.620]                       is.null <- base::is.null
[10:26:06.620]                       muffled <- FALSE
[10:26:06.620]                       if (inherits(cond, "message")) {
[10:26:06.620]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.620]                         if (muffled) 
[10:26:06.620]                           invokeRestart("muffleMessage")
[10:26:06.620]                       }
[10:26:06.620]                       else if (inherits(cond, "warning")) {
[10:26:06.620]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.620]                         if (muffled) 
[10:26:06.620]                           invokeRestart("muffleWarning")
[10:26:06.620]                       }
[10:26:06.620]                       else if (inherits(cond, "condition")) {
[10:26:06.620]                         if (!is.null(pattern)) {
[10:26:06.620]                           computeRestarts <- base::computeRestarts
[10:26:06.620]                           grepl <- base::grepl
[10:26:06.620]                           restarts <- computeRestarts(cond)
[10:26:06.620]                           for (restart in restarts) {
[10:26:06.620]                             name <- restart$name
[10:26:06.620]                             if (is.null(name)) 
[10:26:06.620]                               next
[10:26:06.620]                             if (!grepl(pattern, name)) 
[10:26:06.620]                               next
[10:26:06.620]                             invokeRestart(restart)
[10:26:06.620]                             muffled <- TRUE
[10:26:06.620]                             break
[10:26:06.620]                           }
[10:26:06.620]                         }
[10:26:06.620]                       }
[10:26:06.620]                       invisible(muffled)
[10:26:06.620]                     }
[10:26:06.620]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.620]                   }
[10:26:06.620]                 }
[10:26:06.620]             }
[10:26:06.620]         }))
[10:26:06.620]     }, error = function(ex) {
[10:26:06.620]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.620]                 ...future.rng), started = ...future.startTime, 
[10:26:06.620]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.620]             version = "1.8"), class = "FutureResult")
[10:26:06.620]     }, finally = {
[10:26:06.620]         if (!identical(...future.workdir, getwd())) 
[10:26:06.620]             setwd(...future.workdir)
[10:26:06.620]         {
[10:26:06.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.620]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.620]             }
[10:26:06.620]             base::options(...future.oldOptions)
[10:26:06.620]             if (.Platform$OS.type == "windows") {
[10:26:06.620]                 old_names <- names(...future.oldEnvVars)
[10:26:06.620]                 envs <- base::Sys.getenv()
[10:26:06.620]                 names <- names(envs)
[10:26:06.620]                 common <- intersect(names, old_names)
[10:26:06.620]                 added <- setdiff(names, old_names)
[10:26:06.620]                 removed <- setdiff(old_names, names)
[10:26:06.620]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.620]                   envs[common]]
[10:26:06.620]                 NAMES <- toupper(changed)
[10:26:06.620]                 args <- list()
[10:26:06.620]                 for (kk in seq_along(NAMES)) {
[10:26:06.620]                   name <- changed[[kk]]
[10:26:06.620]                   NAME <- NAMES[[kk]]
[10:26:06.620]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.620]                     next
[10:26:06.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.620]                 }
[10:26:06.620]                 NAMES <- toupper(added)
[10:26:06.620]                 for (kk in seq_along(NAMES)) {
[10:26:06.620]                   name <- added[[kk]]
[10:26:06.620]                   NAME <- NAMES[[kk]]
[10:26:06.620]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.620]                     next
[10:26:06.620]                   args[[name]] <- ""
[10:26:06.620]                 }
[10:26:06.620]                 NAMES <- toupper(removed)
[10:26:06.620]                 for (kk in seq_along(NAMES)) {
[10:26:06.620]                   name <- removed[[kk]]
[10:26:06.620]                   NAME <- NAMES[[kk]]
[10:26:06.620]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.620]                     next
[10:26:06.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.620]                 }
[10:26:06.620]                 if (length(args) > 0) 
[10:26:06.620]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.620]             }
[10:26:06.620]             else {
[10:26:06.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.620]             }
[10:26:06.620]             {
[10:26:06.620]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.620]                   0L) {
[10:26:06.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.620]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.620]                   base::options(opts)
[10:26:06.620]                 }
[10:26:06.620]                 {
[10:26:06.620]                   {
[10:26:06.620]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:06.620]                     NULL
[10:26:06.620]                   }
[10:26:06.620]                   options(future.plan = NULL)
[10:26:06.620]                   if (is.na(NA_character_)) 
[10:26:06.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.620]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:06.620]                     envir = parent.frame()) 
[10:26:06.620]                   {
[10:26:06.620]                     default_workers <- missing(workers)
[10:26:06.620]                     if (is.function(workers)) 
[10:26:06.620]                       workers <- workers()
[10:26:06.620]                     workers <- structure(as.integer(workers), 
[10:26:06.620]                       class = class(workers))
[10:26:06.620]                     stop_if_not(is.finite(workers), workers >= 
[10:26:06.620]                       1L)
[10:26:06.620]                     if ((workers == 1L && !inherits(workers, 
[10:26:06.620]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:06.620]                       if (default_workers) 
[10:26:06.620]                         supportsMulticore(warn = TRUE)
[10:26:06.620]                       return(sequential(..., envir = envir))
[10:26:06.620]                     }
[10:26:06.620]                     oopts <- options(mc.cores = workers)
[10:26:06.620]                     on.exit(options(oopts))
[10:26:06.620]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:06.620]                       envir = envir)
[10:26:06.620]                     if (!future$lazy) 
[10:26:06.620]                       future <- run(future)
[10:26:06.620]                     invisible(future)
[10:26:06.620]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.620]                 }
[10:26:06.620]             }
[10:26:06.620]         }
[10:26:06.620]     })
[10:26:06.620]     if (TRUE) {
[10:26:06.620]         base::sink(type = "output", split = FALSE)
[10:26:06.620]         if (TRUE) {
[10:26:06.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.620]         }
[10:26:06.620]         else {
[10:26:06.620]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.620]         }
[10:26:06.620]         base::close(...future.stdout)
[10:26:06.620]         ...future.stdout <- NULL
[10:26:06.620]     }
[10:26:06.620]     ...future.result$conditions <- ...future.conditions
[10:26:06.620]     ...future.result$finished <- base::Sys.time()
[10:26:06.620]     ...future.result
[10:26:06.620] }
[10:26:06.623] assign_globals() ...
[10:26:06.623] List of 1
[10:26:06.623]  $ x: list()
[10:26:06.623]  - attr(*, "where")=List of 1
[10:26:06.623]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.623]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.623]  - attr(*, "resolved")= logi TRUE
[10:26:06.623]  - attr(*, "total_size")= num 0
[10:26:06.623]  - attr(*, "already-done")= logi TRUE
[10:26:06.626] - copied ‘x’ to environment
[10:26:06.626] assign_globals() ... done
[10:26:06.626] requestCore(): workers = 2
[10:26:06.628] MulticoreFuture started
[10:26:06.628] - Launch lazy future ... done
[10:26:06.629] run() for ‘MulticoreFuture’ ... done
[10:26:06.629] result() for MulticoreFuture ...
[10:26:06.629] plan(): Setting new future strategy stack:
[10:26:06.630] List of future strategies:
[10:26:06.630] 1. sequential:
[10:26:06.630]    - args: function (..., envir = parent.frame())
[10:26:06.630]    - tweaked: FALSE
[10:26:06.630]    - call: NULL
[10:26:06.630] plan(): nbrOfWorkers() = 1
[10:26:06.632] plan(): Setting new future strategy stack:
[10:26:06.632] List of future strategies:
[10:26:06.632] 1. multicore:
[10:26:06.632]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.632]    - tweaked: FALSE
[10:26:06.632]    - call: plan(strategy)
[10:26:06.637] plan(): nbrOfWorkers() = 2
[10:26:06.638] result() for MulticoreFuture ...
[10:26:06.638] result() for MulticoreFuture ... done
[10:26:06.639] result() for MulticoreFuture ... done
[10:26:06.639] result() for MulticoreFuture ...
[10:26:06.639] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.640] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.640] Searching for globals...
[10:26:06.643] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:26:06.643] Searching for globals ... DONE
[10:26:06.644] Resolving globals: TRUE
[10:26:06.644] Resolving any globals that are futures ...
[10:26:06.644] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:26:06.644] Resolving any globals that are futures ... DONE
[10:26:06.644] 
[10:26:06.644] 
[10:26:06.645] getGlobalsAndPackages() ... DONE
[10:26:06.645] run() for ‘Future’ ...
[10:26:06.645] - state: ‘created’
[10:26:06.645] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:06.649] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:06.650] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:06.650]   - Field: ‘label’
[10:26:06.650]   - Field: ‘local’
[10:26:06.650]   - Field: ‘owner’
[10:26:06.650]   - Field: ‘envir’
[10:26:06.650]   - Field: ‘workers’
[10:26:06.650]   - Field: ‘packages’
[10:26:06.650]   - Field: ‘gc’
[10:26:06.651]   - Field: ‘job’
[10:26:06.651]   - Field: ‘conditions’
[10:26:06.651]   - Field: ‘expr’
[10:26:06.651]   - Field: ‘uuid’
[10:26:06.651]   - Field: ‘seed’
[10:26:06.651]   - Field: ‘version’
[10:26:06.651]   - Field: ‘result’
[10:26:06.651]   - Field: ‘asynchronous’
[10:26:06.651]   - Field: ‘calls’
[10:26:06.652]   - Field: ‘globals’
[10:26:06.652]   - Field: ‘stdout’
[10:26:06.652]   - Field: ‘earlySignal’
[10:26:06.652]   - Field: ‘lazy’
[10:26:06.652]   - Field: ‘state’
[10:26:06.652] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:06.655] - Launch lazy future ...
[10:26:06.655] Packages needed by the future expression (n = 0): <none>
[10:26:06.655] Packages needed by future strategies (n = 0): <none>
[10:26:06.656] {
[10:26:06.656]     {
[10:26:06.656]         {
[10:26:06.656]             ...future.startTime <- base::Sys.time()
[10:26:06.656]             {
[10:26:06.656]                 {
[10:26:06.656]                   {
[10:26:06.656]                     {
[10:26:06.656]                       base::local({
[10:26:06.656]                         has_future <- base::requireNamespace("future", 
[10:26:06.656]                           quietly = TRUE)
[10:26:06.656]                         if (has_future) {
[10:26:06.656]                           ns <- base::getNamespace("future")
[10:26:06.656]                           version <- ns[[".package"]][["version"]]
[10:26:06.656]                           if (is.null(version)) 
[10:26:06.656]                             version <- utils::packageVersion("future")
[10:26:06.656]                         }
[10:26:06.656]                         else {
[10:26:06.656]                           version <- NULL
[10:26:06.656]                         }
[10:26:06.656]                         if (!has_future || version < "1.8.0") {
[10:26:06.656]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.656]                             "", base::R.version$version.string), 
[10:26:06.656]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:06.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.656]                               "release", "version")], collapse = " "), 
[10:26:06.656]                             hostname = base::Sys.info()[["nodename"]])
[10:26:06.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.656]                             info)
[10:26:06.656]                           info <- base::paste(info, collapse = "; ")
[10:26:06.656]                           if (!has_future) {
[10:26:06.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.656]                               info)
[10:26:06.656]                           }
[10:26:06.656]                           else {
[10:26:06.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.656]                               info, version)
[10:26:06.656]                           }
[10:26:06.656]                           base::stop(msg)
[10:26:06.656]                         }
[10:26:06.656]                       })
[10:26:06.656]                     }
[10:26:06.656]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:06.656]                     base::options(mc.cores = 1L)
[10:26:06.656]                   }
[10:26:06.656]                   options(future.plan = NULL)
[10:26:06.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.656]                 }
[10:26:06.656]                 ...future.workdir <- getwd()
[10:26:06.656]             }
[10:26:06.656]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.656]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.656]         }
[10:26:06.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.656]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.656]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.656]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.656]             base::names(...future.oldOptions))
[10:26:06.656]     }
[10:26:06.656]     if (FALSE) {
[10:26:06.656]     }
[10:26:06.656]     else {
[10:26:06.656]         if (TRUE) {
[10:26:06.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.656]                 open = "w")
[10:26:06.656]         }
[10:26:06.656]         else {
[10:26:06.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.656]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.656]         }
[10:26:06.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.656]             base::sink(type = "output", split = FALSE)
[10:26:06.656]             base::close(...future.stdout)
[10:26:06.656]         }, add = TRUE)
[10:26:06.656]     }
[10:26:06.656]     ...future.frame <- base::sys.nframe()
[10:26:06.656]     ...future.conditions <- base::list()
[10:26:06.656]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.656]     if (FALSE) {
[10:26:06.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.656]     }
[10:26:06.656]     ...future.result <- base::tryCatch({
[10:26:06.656]         base::withCallingHandlers({
[10:26:06.656]             ...future.value <- base::withVisible(base::local({
[10:26:06.656]                 withCallingHandlers({
[10:26:06.656]                   {
[10:26:06.656]                     x <- list(b = 2)
[10:26:06.656]                     x$a <- 1
[10:26:06.656]                     x
[10:26:06.656]                   }
[10:26:06.656]                 }, immediateCondition = function(cond) {
[10:26:06.656]                   save_rds <- function (object, pathname, ...) 
[10:26:06.656]                   {
[10:26:06.656]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:06.656]                     if (file_test("-f", pathname_tmp)) {
[10:26:06.656]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.656]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:06.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.656]                         fi_tmp[["mtime"]])
[10:26:06.656]                     }
[10:26:06.656]                     tryCatch({
[10:26:06.656]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:06.656]                     }, error = function(ex) {
[10:26:06.656]                       msg <- conditionMessage(ex)
[10:26:06.656]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.656]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:06.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.656]                         fi_tmp[["mtime"]], msg)
[10:26:06.656]                       ex$message <- msg
[10:26:06.656]                       stop(ex)
[10:26:06.656]                     })
[10:26:06.656]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:06.656]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:06.656]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:06.656]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.656]                       fi <- file.info(pathname)
[10:26:06.656]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:06.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.656]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:06.656]                         fi[["size"]], fi[["mtime"]])
[10:26:06.656]                       stop(msg)
[10:26:06.656]                     }
[10:26:06.656]                     invisible(pathname)
[10:26:06.656]                   }
[10:26:06.656]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:06.656]                     rootPath = tempdir()) 
[10:26:06.656]                   {
[10:26:06.656]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:06.656]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:06.656]                       tmpdir = path, fileext = ".rds")
[10:26:06.656]                     save_rds(obj, file)
[10:26:06.656]                   }
[10:26:06.656]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4YXwpK/.future/immediateConditions")
[10:26:06.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.656]                   {
[10:26:06.656]                     inherits <- base::inherits
[10:26:06.656]                     invokeRestart <- base::invokeRestart
[10:26:06.656]                     is.null <- base::is.null
[10:26:06.656]                     muffled <- FALSE
[10:26:06.656]                     if (inherits(cond, "message")) {
[10:26:06.656]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:06.656]                       if (muffled) 
[10:26:06.656]                         invokeRestart("muffleMessage")
[10:26:06.656]                     }
[10:26:06.656]                     else if (inherits(cond, "warning")) {
[10:26:06.656]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:06.656]                       if (muffled) 
[10:26:06.656]                         invokeRestart("muffleWarning")
[10:26:06.656]                     }
[10:26:06.656]                     else if (inherits(cond, "condition")) {
[10:26:06.656]                       if (!is.null(pattern)) {
[10:26:06.656]                         computeRestarts <- base::computeRestarts
[10:26:06.656]                         grepl <- base::grepl
[10:26:06.656]                         restarts <- computeRestarts(cond)
[10:26:06.656]                         for (restart in restarts) {
[10:26:06.656]                           name <- restart$name
[10:26:06.656]                           if (is.null(name)) 
[10:26:06.656]                             next
[10:26:06.656]                           if (!grepl(pattern, name)) 
[10:26:06.656]                             next
[10:26:06.656]                           invokeRestart(restart)
[10:26:06.656]                           muffled <- TRUE
[10:26:06.656]                           break
[10:26:06.656]                         }
[10:26:06.656]                       }
[10:26:06.656]                     }
[10:26:06.656]                     invisible(muffled)
[10:26:06.656]                   }
[10:26:06.656]                   muffleCondition(cond)
[10:26:06.656]                 })
[10:26:06.656]             }))
[10:26:06.656]             future::FutureResult(value = ...future.value$value, 
[10:26:06.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.656]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.656]                     ...future.globalenv.names))
[10:26:06.656]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.656]         }, condition = base::local({
[10:26:06.656]             c <- base::c
[10:26:06.656]             inherits <- base::inherits
[10:26:06.656]             invokeRestart <- base::invokeRestart
[10:26:06.656]             length <- base::length
[10:26:06.656]             list <- base::list
[10:26:06.656]             seq.int <- base::seq.int
[10:26:06.656]             signalCondition <- base::signalCondition
[10:26:06.656]             sys.calls <- base::sys.calls
[10:26:06.656]             `[[` <- base::`[[`
[10:26:06.656]             `+` <- base::`+`
[10:26:06.656]             `<<-` <- base::`<<-`
[10:26:06.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.656]                   3L)]
[10:26:06.656]             }
[10:26:06.656]             function(cond) {
[10:26:06.656]                 is_error <- inherits(cond, "error")
[10:26:06.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.656]                   NULL)
[10:26:06.656]                 if (is_error) {
[10:26:06.656]                   sessionInformation <- function() {
[10:26:06.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.656]                       search = base::search(), system = base::Sys.info())
[10:26:06.656]                   }
[10:26:06.656]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.656]                     cond$call), session = sessionInformation(), 
[10:26:06.656]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.656]                   signalCondition(cond)
[10:26:06.656]                 }
[10:26:06.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.656]                 "immediateCondition"))) {
[10:26:06.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.656]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.656]                   if (TRUE && !signal) {
[10:26:06.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.656]                     {
[10:26:06.656]                       inherits <- base::inherits
[10:26:06.656]                       invokeRestart <- base::invokeRestart
[10:26:06.656]                       is.null <- base::is.null
[10:26:06.656]                       muffled <- FALSE
[10:26:06.656]                       if (inherits(cond, "message")) {
[10:26:06.656]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.656]                         if (muffled) 
[10:26:06.656]                           invokeRestart("muffleMessage")
[10:26:06.656]                       }
[10:26:06.656]                       else if (inherits(cond, "warning")) {
[10:26:06.656]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.656]                         if (muffled) 
[10:26:06.656]                           invokeRestart("muffleWarning")
[10:26:06.656]                       }
[10:26:06.656]                       else if (inherits(cond, "condition")) {
[10:26:06.656]                         if (!is.null(pattern)) {
[10:26:06.656]                           computeRestarts <- base::computeRestarts
[10:26:06.656]                           grepl <- base::grepl
[10:26:06.656]                           restarts <- computeRestarts(cond)
[10:26:06.656]                           for (restart in restarts) {
[10:26:06.656]                             name <- restart$name
[10:26:06.656]                             if (is.null(name)) 
[10:26:06.656]                               next
[10:26:06.656]                             if (!grepl(pattern, name)) 
[10:26:06.656]                               next
[10:26:06.656]                             invokeRestart(restart)
[10:26:06.656]                             muffled <- TRUE
[10:26:06.656]                             break
[10:26:06.656]                           }
[10:26:06.656]                         }
[10:26:06.656]                       }
[10:26:06.656]                       invisible(muffled)
[10:26:06.656]                     }
[10:26:06.656]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.656]                   }
[10:26:06.656]                 }
[10:26:06.656]                 else {
[10:26:06.656]                   if (TRUE) {
[10:26:06.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.656]                     {
[10:26:06.656]                       inherits <- base::inherits
[10:26:06.656]                       invokeRestart <- base::invokeRestart
[10:26:06.656]                       is.null <- base::is.null
[10:26:06.656]                       muffled <- FALSE
[10:26:06.656]                       if (inherits(cond, "message")) {
[10:26:06.656]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.656]                         if (muffled) 
[10:26:06.656]                           invokeRestart("muffleMessage")
[10:26:06.656]                       }
[10:26:06.656]                       else if (inherits(cond, "warning")) {
[10:26:06.656]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.656]                         if (muffled) 
[10:26:06.656]                           invokeRestart("muffleWarning")
[10:26:06.656]                       }
[10:26:06.656]                       else if (inherits(cond, "condition")) {
[10:26:06.656]                         if (!is.null(pattern)) {
[10:26:06.656]                           computeRestarts <- base::computeRestarts
[10:26:06.656]                           grepl <- base::grepl
[10:26:06.656]                           restarts <- computeRestarts(cond)
[10:26:06.656]                           for (restart in restarts) {
[10:26:06.656]                             name <- restart$name
[10:26:06.656]                             if (is.null(name)) 
[10:26:06.656]                               next
[10:26:06.656]                             if (!grepl(pattern, name)) 
[10:26:06.656]                               next
[10:26:06.656]                             invokeRestart(restart)
[10:26:06.656]                             muffled <- TRUE
[10:26:06.656]                             break
[10:26:06.656]                           }
[10:26:06.656]                         }
[10:26:06.656]                       }
[10:26:06.656]                       invisible(muffled)
[10:26:06.656]                     }
[10:26:06.656]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.656]                   }
[10:26:06.656]                 }
[10:26:06.656]             }
[10:26:06.656]         }))
[10:26:06.656]     }, error = function(ex) {
[10:26:06.656]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.656]                 ...future.rng), started = ...future.startTime, 
[10:26:06.656]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.656]             version = "1.8"), class = "FutureResult")
[10:26:06.656]     }, finally = {
[10:26:06.656]         if (!identical(...future.workdir, getwd())) 
[10:26:06.656]             setwd(...future.workdir)
[10:26:06.656]         {
[10:26:06.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.656]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.656]             }
[10:26:06.656]             base::options(...future.oldOptions)
[10:26:06.656]             if (.Platform$OS.type == "windows") {
[10:26:06.656]                 old_names <- names(...future.oldEnvVars)
[10:26:06.656]                 envs <- base::Sys.getenv()
[10:26:06.656]                 names <- names(envs)
[10:26:06.656]                 common <- intersect(names, old_names)
[10:26:06.656]                 added <- setdiff(names, old_names)
[10:26:06.656]                 removed <- setdiff(old_names, names)
[10:26:06.656]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.656]                   envs[common]]
[10:26:06.656]                 NAMES <- toupper(changed)
[10:26:06.656]                 args <- list()
[10:26:06.656]                 for (kk in seq_along(NAMES)) {
[10:26:06.656]                   name <- changed[[kk]]
[10:26:06.656]                   NAME <- NAMES[[kk]]
[10:26:06.656]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.656]                     next
[10:26:06.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.656]                 }
[10:26:06.656]                 NAMES <- toupper(added)
[10:26:06.656]                 for (kk in seq_along(NAMES)) {
[10:26:06.656]                   name <- added[[kk]]
[10:26:06.656]                   NAME <- NAMES[[kk]]
[10:26:06.656]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.656]                     next
[10:26:06.656]                   args[[name]] <- ""
[10:26:06.656]                 }
[10:26:06.656]                 NAMES <- toupper(removed)
[10:26:06.656]                 for (kk in seq_along(NAMES)) {
[10:26:06.656]                   name <- removed[[kk]]
[10:26:06.656]                   NAME <- NAMES[[kk]]
[10:26:06.656]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.656]                     next
[10:26:06.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.656]                 }
[10:26:06.656]                 if (length(args) > 0) 
[10:26:06.656]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.656]             }
[10:26:06.656]             else {
[10:26:06.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.656]             }
[10:26:06.656]             {
[10:26:06.656]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.656]                   0L) {
[10:26:06.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.656]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.656]                   base::options(opts)
[10:26:06.656]                 }
[10:26:06.656]                 {
[10:26:06.656]                   {
[10:26:06.656]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:06.656]                     NULL
[10:26:06.656]                   }
[10:26:06.656]                   options(future.plan = NULL)
[10:26:06.656]                   if (is.na(NA_character_)) 
[10:26:06.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.656]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:06.656]                     envir = parent.frame()) 
[10:26:06.656]                   {
[10:26:06.656]                     default_workers <- missing(workers)
[10:26:06.656]                     if (is.function(workers)) 
[10:26:06.656]                       workers <- workers()
[10:26:06.656]                     workers <- structure(as.integer(workers), 
[10:26:06.656]                       class = class(workers))
[10:26:06.656]                     stop_if_not(is.finite(workers), workers >= 
[10:26:06.656]                       1L)
[10:26:06.656]                     if ((workers == 1L && !inherits(workers, 
[10:26:06.656]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:06.656]                       if (default_workers) 
[10:26:06.656]                         supportsMulticore(warn = TRUE)
[10:26:06.656]                       return(sequential(..., envir = envir))
[10:26:06.656]                     }
[10:26:06.656]                     oopts <- options(mc.cores = workers)
[10:26:06.656]                     on.exit(options(oopts))
[10:26:06.656]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:06.656]                       envir = envir)
[10:26:06.656]                     if (!future$lazy) 
[10:26:06.656]                       future <- run(future)
[10:26:06.656]                     invisible(future)
[10:26:06.656]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.656]                 }
[10:26:06.656]             }
[10:26:06.656]         }
[10:26:06.656]     })
[10:26:06.656]     if (TRUE) {
[10:26:06.656]         base::sink(type = "output", split = FALSE)
[10:26:06.656]         if (TRUE) {
[10:26:06.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.656]         }
[10:26:06.656]         else {
[10:26:06.656]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.656]         }
[10:26:06.656]         base::close(...future.stdout)
[10:26:06.656]         ...future.stdout <- NULL
[10:26:06.656]     }
[10:26:06.656]     ...future.result$conditions <- ...future.conditions
[10:26:06.656]     ...future.result$finished <- base::Sys.time()
[10:26:06.656]     ...future.result
[10:26:06.656] }
[10:26:06.658] requestCore(): workers = 2
[10:26:06.660] MulticoreFuture started
[10:26:06.661] - Launch lazy future ... done
[10:26:06.661] run() for ‘MulticoreFuture’ ... done
[10:26:06.661] plan(): Setting new future strategy stack:
[10:26:06.662] result() for MulticoreFuture ...
[10:26:06.662] List of future strategies:
[10:26:06.662] 1. sequential:
[10:26:06.662]    - args: function (..., envir = parent.frame())
[10:26:06.662]    - tweaked: FALSE
[10:26:06.662]    - call: NULL
[10:26:06.663] plan(): nbrOfWorkers() = 1
[10:26:06.665] plan(): Setting new future strategy stack:
[10:26:06.665] List of future strategies:
[10:26:06.665] 1. multicore:
[10:26:06.665]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.665]    - tweaked: FALSE
[10:26:06.665]    - call: plan(strategy)
[10:26:06.670] plan(): nbrOfWorkers() = 2
[10:26:06.671] result() for MulticoreFuture ...
[10:26:06.671] result() for MulticoreFuture ... done
[10:26:06.671] result() for MulticoreFuture ... done
[10:26:06.671] result() for MulticoreFuture ...
[10:26:06.671] result() for MulticoreFuture ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.672] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.672] Searching for globals...
[10:26:06.675] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:06.675] Searching for globals ... DONE
[10:26:06.675] Resolving globals: TRUE
[10:26:06.675] Resolving any globals that are futures ...
[10:26:06.675] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:06.675] Resolving any globals that are futures ... DONE
[10:26:06.676] Resolving futures part of globals (recursively) ...
[10:26:06.676] resolve() on list ...
[10:26:06.676]  recursive: 99
[10:26:06.676]  length: 1
[10:26:06.677]  elements: ‘x’
[10:26:06.677]  length: 0 (resolved future 1)
[10:26:06.677] resolve() on list ... DONE
[10:26:06.677] - globals: [1] ‘x’
[10:26:06.677] Resolving futures part of globals (recursively) ... DONE
[10:26:06.677] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.678] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.678] - globals: [1] ‘x’
[10:26:06.678] 
[10:26:06.678] getGlobalsAndPackages() ... DONE
[10:26:06.678] run() for ‘Future’ ...
[10:26:06.679] - state: ‘created’
[10:26:06.679] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:06.683] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:06.683] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:06.683]   - Field: ‘label’
[10:26:06.683]   - Field: ‘local’
[10:26:06.683]   - Field: ‘owner’
[10:26:06.683]   - Field: ‘envir’
[10:26:06.683]   - Field: ‘workers’
[10:26:06.684]   - Field: ‘packages’
[10:26:06.684]   - Field: ‘gc’
[10:26:06.684]   - Field: ‘job’
[10:26:06.684]   - Field: ‘conditions’
[10:26:06.684]   - Field: ‘expr’
[10:26:06.684]   - Field: ‘uuid’
[10:26:06.684]   - Field: ‘seed’
[10:26:06.684]   - Field: ‘version’
[10:26:06.684]   - Field: ‘result’
[10:26:06.685]   - Field: ‘asynchronous’
[10:26:06.685]   - Field: ‘calls’
[10:26:06.685]   - Field: ‘globals’
[10:26:06.685]   - Field: ‘stdout’
[10:26:06.685]   - Field: ‘earlySignal’
[10:26:06.685]   - Field: ‘lazy’
[10:26:06.685]   - Field: ‘state’
[10:26:06.685] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:06.686] - Launch lazy future ...
[10:26:06.686] Packages needed by the future expression (n = 0): <none>
[10:26:06.686] Packages needed by future strategies (n = 0): <none>
[10:26:06.687] {
[10:26:06.687]     {
[10:26:06.687]         {
[10:26:06.687]             ...future.startTime <- base::Sys.time()
[10:26:06.687]             {
[10:26:06.687]                 {
[10:26:06.687]                   {
[10:26:06.687]                     {
[10:26:06.687]                       base::local({
[10:26:06.687]                         has_future <- base::requireNamespace("future", 
[10:26:06.687]                           quietly = TRUE)
[10:26:06.687]                         if (has_future) {
[10:26:06.687]                           ns <- base::getNamespace("future")
[10:26:06.687]                           version <- ns[[".package"]][["version"]]
[10:26:06.687]                           if (is.null(version)) 
[10:26:06.687]                             version <- utils::packageVersion("future")
[10:26:06.687]                         }
[10:26:06.687]                         else {
[10:26:06.687]                           version <- NULL
[10:26:06.687]                         }
[10:26:06.687]                         if (!has_future || version < "1.8.0") {
[10:26:06.687]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.687]                             "", base::R.version$version.string), 
[10:26:06.687]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:06.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.687]                               "release", "version")], collapse = " "), 
[10:26:06.687]                             hostname = base::Sys.info()[["nodename"]])
[10:26:06.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.687]                             info)
[10:26:06.687]                           info <- base::paste(info, collapse = "; ")
[10:26:06.687]                           if (!has_future) {
[10:26:06.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.687]                               info)
[10:26:06.687]                           }
[10:26:06.687]                           else {
[10:26:06.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.687]                               info, version)
[10:26:06.687]                           }
[10:26:06.687]                           base::stop(msg)
[10:26:06.687]                         }
[10:26:06.687]                       })
[10:26:06.687]                     }
[10:26:06.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:06.687]                     base::options(mc.cores = 1L)
[10:26:06.687]                   }
[10:26:06.687]                   options(future.plan = NULL)
[10:26:06.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.687]                 }
[10:26:06.687]                 ...future.workdir <- getwd()
[10:26:06.687]             }
[10:26:06.687]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.687]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.687]         }
[10:26:06.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.687]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.687]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.687]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.687]             base::names(...future.oldOptions))
[10:26:06.687]     }
[10:26:06.687]     if (FALSE) {
[10:26:06.687]     }
[10:26:06.687]     else {
[10:26:06.687]         if (TRUE) {
[10:26:06.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.687]                 open = "w")
[10:26:06.687]         }
[10:26:06.687]         else {
[10:26:06.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.687]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.687]         }
[10:26:06.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.687]             base::sink(type = "output", split = FALSE)
[10:26:06.687]             base::close(...future.stdout)
[10:26:06.687]         }, add = TRUE)
[10:26:06.687]     }
[10:26:06.687]     ...future.frame <- base::sys.nframe()
[10:26:06.687]     ...future.conditions <- base::list()
[10:26:06.687]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.687]     if (FALSE) {
[10:26:06.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.687]     }
[10:26:06.687]     ...future.result <- base::tryCatch({
[10:26:06.687]         base::withCallingHandlers({
[10:26:06.687]             ...future.value <- base::withVisible(base::local({
[10:26:06.687]                 withCallingHandlers({
[10:26:06.687]                   {
[10:26:06.687]                     x[["a"]] <- 1
[10:26:06.687]                     x
[10:26:06.687]                   }
[10:26:06.687]                 }, immediateCondition = function(cond) {
[10:26:06.687]                   save_rds <- function (object, pathname, ...) 
[10:26:06.687]                   {
[10:26:06.687]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:06.687]                     if (file_test("-f", pathname_tmp)) {
[10:26:06.687]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.687]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:06.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.687]                         fi_tmp[["mtime"]])
[10:26:06.687]                     }
[10:26:06.687]                     tryCatch({
[10:26:06.687]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:06.687]                     }, error = function(ex) {
[10:26:06.687]                       msg <- conditionMessage(ex)
[10:26:06.687]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.687]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:06.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.687]                         fi_tmp[["mtime"]], msg)
[10:26:06.687]                       ex$message <- msg
[10:26:06.687]                       stop(ex)
[10:26:06.687]                     })
[10:26:06.687]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:06.687]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:06.687]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:06.687]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.687]                       fi <- file.info(pathname)
[10:26:06.687]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:06.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.687]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:06.687]                         fi[["size"]], fi[["mtime"]])
[10:26:06.687]                       stop(msg)
[10:26:06.687]                     }
[10:26:06.687]                     invisible(pathname)
[10:26:06.687]                   }
[10:26:06.687]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:06.687]                     rootPath = tempdir()) 
[10:26:06.687]                   {
[10:26:06.687]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:06.687]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:06.687]                       tmpdir = path, fileext = ".rds")
[10:26:06.687]                     save_rds(obj, file)
[10:26:06.687]                   }
[10:26:06.687]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4YXwpK/.future/immediateConditions")
[10:26:06.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.687]                   {
[10:26:06.687]                     inherits <- base::inherits
[10:26:06.687]                     invokeRestart <- base::invokeRestart
[10:26:06.687]                     is.null <- base::is.null
[10:26:06.687]                     muffled <- FALSE
[10:26:06.687]                     if (inherits(cond, "message")) {
[10:26:06.687]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:06.687]                       if (muffled) 
[10:26:06.687]                         invokeRestart("muffleMessage")
[10:26:06.687]                     }
[10:26:06.687]                     else if (inherits(cond, "warning")) {
[10:26:06.687]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:06.687]                       if (muffled) 
[10:26:06.687]                         invokeRestart("muffleWarning")
[10:26:06.687]                     }
[10:26:06.687]                     else if (inherits(cond, "condition")) {
[10:26:06.687]                       if (!is.null(pattern)) {
[10:26:06.687]                         computeRestarts <- base::computeRestarts
[10:26:06.687]                         grepl <- base::grepl
[10:26:06.687]                         restarts <- computeRestarts(cond)
[10:26:06.687]                         for (restart in restarts) {
[10:26:06.687]                           name <- restart$name
[10:26:06.687]                           if (is.null(name)) 
[10:26:06.687]                             next
[10:26:06.687]                           if (!grepl(pattern, name)) 
[10:26:06.687]                             next
[10:26:06.687]                           invokeRestart(restart)
[10:26:06.687]                           muffled <- TRUE
[10:26:06.687]                           break
[10:26:06.687]                         }
[10:26:06.687]                       }
[10:26:06.687]                     }
[10:26:06.687]                     invisible(muffled)
[10:26:06.687]                   }
[10:26:06.687]                   muffleCondition(cond)
[10:26:06.687]                 })
[10:26:06.687]             }))
[10:26:06.687]             future::FutureResult(value = ...future.value$value, 
[10:26:06.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.687]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.687]                     ...future.globalenv.names))
[10:26:06.687]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.687]         }, condition = base::local({
[10:26:06.687]             c <- base::c
[10:26:06.687]             inherits <- base::inherits
[10:26:06.687]             invokeRestart <- base::invokeRestart
[10:26:06.687]             length <- base::length
[10:26:06.687]             list <- base::list
[10:26:06.687]             seq.int <- base::seq.int
[10:26:06.687]             signalCondition <- base::signalCondition
[10:26:06.687]             sys.calls <- base::sys.calls
[10:26:06.687]             `[[` <- base::`[[`
[10:26:06.687]             `+` <- base::`+`
[10:26:06.687]             `<<-` <- base::`<<-`
[10:26:06.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.687]                   3L)]
[10:26:06.687]             }
[10:26:06.687]             function(cond) {
[10:26:06.687]                 is_error <- inherits(cond, "error")
[10:26:06.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.687]                   NULL)
[10:26:06.687]                 if (is_error) {
[10:26:06.687]                   sessionInformation <- function() {
[10:26:06.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.687]                       search = base::search(), system = base::Sys.info())
[10:26:06.687]                   }
[10:26:06.687]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.687]                     cond$call), session = sessionInformation(), 
[10:26:06.687]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.687]                   signalCondition(cond)
[10:26:06.687]                 }
[10:26:06.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.687]                 "immediateCondition"))) {
[10:26:06.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.687]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.687]                   if (TRUE && !signal) {
[10:26:06.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.687]                     {
[10:26:06.687]                       inherits <- base::inherits
[10:26:06.687]                       invokeRestart <- base::invokeRestart
[10:26:06.687]                       is.null <- base::is.null
[10:26:06.687]                       muffled <- FALSE
[10:26:06.687]                       if (inherits(cond, "message")) {
[10:26:06.687]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.687]                         if (muffled) 
[10:26:06.687]                           invokeRestart("muffleMessage")
[10:26:06.687]                       }
[10:26:06.687]                       else if (inherits(cond, "warning")) {
[10:26:06.687]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.687]                         if (muffled) 
[10:26:06.687]                           invokeRestart("muffleWarning")
[10:26:06.687]                       }
[10:26:06.687]                       else if (inherits(cond, "condition")) {
[10:26:06.687]                         if (!is.null(pattern)) {
[10:26:06.687]                           computeRestarts <- base::computeRestarts
[10:26:06.687]                           grepl <- base::grepl
[10:26:06.687]                           restarts <- computeRestarts(cond)
[10:26:06.687]                           for (restart in restarts) {
[10:26:06.687]                             name <- restart$name
[10:26:06.687]                             if (is.null(name)) 
[10:26:06.687]                               next
[10:26:06.687]                             if (!grepl(pattern, name)) 
[10:26:06.687]                               next
[10:26:06.687]                             invokeRestart(restart)
[10:26:06.687]                             muffled <- TRUE
[10:26:06.687]                             break
[10:26:06.687]                           }
[10:26:06.687]                         }
[10:26:06.687]                       }
[10:26:06.687]                       invisible(muffled)
[10:26:06.687]                     }
[10:26:06.687]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.687]                   }
[10:26:06.687]                 }
[10:26:06.687]                 else {
[10:26:06.687]                   if (TRUE) {
[10:26:06.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.687]                     {
[10:26:06.687]                       inherits <- base::inherits
[10:26:06.687]                       invokeRestart <- base::invokeRestart
[10:26:06.687]                       is.null <- base::is.null
[10:26:06.687]                       muffled <- FALSE
[10:26:06.687]                       if (inherits(cond, "message")) {
[10:26:06.687]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.687]                         if (muffled) 
[10:26:06.687]                           invokeRestart("muffleMessage")
[10:26:06.687]                       }
[10:26:06.687]                       else if (inherits(cond, "warning")) {
[10:26:06.687]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.687]                         if (muffled) 
[10:26:06.687]                           invokeRestart("muffleWarning")
[10:26:06.687]                       }
[10:26:06.687]                       else if (inherits(cond, "condition")) {
[10:26:06.687]                         if (!is.null(pattern)) {
[10:26:06.687]                           computeRestarts <- base::computeRestarts
[10:26:06.687]                           grepl <- base::grepl
[10:26:06.687]                           restarts <- computeRestarts(cond)
[10:26:06.687]                           for (restart in restarts) {
[10:26:06.687]                             name <- restart$name
[10:26:06.687]                             if (is.null(name)) 
[10:26:06.687]                               next
[10:26:06.687]                             if (!grepl(pattern, name)) 
[10:26:06.687]                               next
[10:26:06.687]                             invokeRestart(restart)
[10:26:06.687]                             muffled <- TRUE
[10:26:06.687]                             break
[10:26:06.687]                           }
[10:26:06.687]                         }
[10:26:06.687]                       }
[10:26:06.687]                       invisible(muffled)
[10:26:06.687]                     }
[10:26:06.687]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.687]                   }
[10:26:06.687]                 }
[10:26:06.687]             }
[10:26:06.687]         }))
[10:26:06.687]     }, error = function(ex) {
[10:26:06.687]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.687]                 ...future.rng), started = ...future.startTime, 
[10:26:06.687]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.687]             version = "1.8"), class = "FutureResult")
[10:26:06.687]     }, finally = {
[10:26:06.687]         if (!identical(...future.workdir, getwd())) 
[10:26:06.687]             setwd(...future.workdir)
[10:26:06.687]         {
[10:26:06.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.687]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.687]             }
[10:26:06.687]             base::options(...future.oldOptions)
[10:26:06.687]             if (.Platform$OS.type == "windows") {
[10:26:06.687]                 old_names <- names(...future.oldEnvVars)
[10:26:06.687]                 envs <- base::Sys.getenv()
[10:26:06.687]                 names <- names(envs)
[10:26:06.687]                 common <- intersect(names, old_names)
[10:26:06.687]                 added <- setdiff(names, old_names)
[10:26:06.687]                 removed <- setdiff(old_names, names)
[10:26:06.687]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.687]                   envs[common]]
[10:26:06.687]                 NAMES <- toupper(changed)
[10:26:06.687]                 args <- list()
[10:26:06.687]                 for (kk in seq_along(NAMES)) {
[10:26:06.687]                   name <- changed[[kk]]
[10:26:06.687]                   NAME <- NAMES[[kk]]
[10:26:06.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.687]                     next
[10:26:06.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.687]                 }
[10:26:06.687]                 NAMES <- toupper(added)
[10:26:06.687]                 for (kk in seq_along(NAMES)) {
[10:26:06.687]                   name <- added[[kk]]
[10:26:06.687]                   NAME <- NAMES[[kk]]
[10:26:06.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.687]                     next
[10:26:06.687]                   args[[name]] <- ""
[10:26:06.687]                 }
[10:26:06.687]                 NAMES <- toupper(removed)
[10:26:06.687]                 for (kk in seq_along(NAMES)) {
[10:26:06.687]                   name <- removed[[kk]]
[10:26:06.687]                   NAME <- NAMES[[kk]]
[10:26:06.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.687]                     next
[10:26:06.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.687]                 }
[10:26:06.687]                 if (length(args) > 0) 
[10:26:06.687]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.687]             }
[10:26:06.687]             else {
[10:26:06.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.687]             }
[10:26:06.687]             {
[10:26:06.687]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.687]                   0L) {
[10:26:06.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.687]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.687]                   base::options(opts)
[10:26:06.687]                 }
[10:26:06.687]                 {
[10:26:06.687]                   {
[10:26:06.687]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:06.687]                     NULL
[10:26:06.687]                   }
[10:26:06.687]                   options(future.plan = NULL)
[10:26:06.687]                   if (is.na(NA_character_)) 
[10:26:06.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.687]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:06.687]                     envir = parent.frame()) 
[10:26:06.687]                   {
[10:26:06.687]                     default_workers <- missing(workers)
[10:26:06.687]                     if (is.function(workers)) 
[10:26:06.687]                       workers <- workers()
[10:26:06.687]                     workers <- structure(as.integer(workers), 
[10:26:06.687]                       class = class(workers))
[10:26:06.687]                     stop_if_not(is.finite(workers), workers >= 
[10:26:06.687]                       1L)
[10:26:06.687]                     if ((workers == 1L && !inherits(workers, 
[10:26:06.687]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:06.687]                       if (default_workers) 
[10:26:06.687]                         supportsMulticore(warn = TRUE)
[10:26:06.687]                       return(sequential(..., envir = envir))
[10:26:06.687]                     }
[10:26:06.687]                     oopts <- options(mc.cores = workers)
[10:26:06.687]                     on.exit(options(oopts))
[10:26:06.687]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:06.687]                       envir = envir)
[10:26:06.687]                     if (!future$lazy) 
[10:26:06.687]                       future <- run(future)
[10:26:06.687]                     invisible(future)
[10:26:06.687]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.687]                 }
[10:26:06.687]             }
[10:26:06.687]         }
[10:26:06.687]     })
[10:26:06.687]     if (TRUE) {
[10:26:06.687]         base::sink(type = "output", split = FALSE)
[10:26:06.687]         if (TRUE) {
[10:26:06.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.687]         }
[10:26:06.687]         else {
[10:26:06.687]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.687]         }
[10:26:06.687]         base::close(...future.stdout)
[10:26:06.687]         ...future.stdout <- NULL
[10:26:06.687]     }
[10:26:06.687]     ...future.result$conditions <- ...future.conditions
[10:26:06.687]     ...future.result$finished <- base::Sys.time()
[10:26:06.687]     ...future.result
[10:26:06.687] }
[10:26:06.689] assign_globals() ...
[10:26:06.689] List of 1
[10:26:06.689]  $ x: list()
[10:26:06.689]  - attr(*, "where")=List of 1
[10:26:06.689]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.689]  - attr(*, "resolved")= logi TRUE
[10:26:06.689]  - attr(*, "total_size")= num 0
[10:26:06.689]  - attr(*, "already-done")= logi TRUE
[10:26:06.692] - copied ‘x’ to environment
[10:26:06.692] assign_globals() ... done
[10:26:06.693] requestCore(): workers = 2
[10:26:06.694] MulticoreFuture started
[10:26:06.695] - Launch lazy future ... done
[10:26:06.695] run() for ‘MulticoreFuture’ ... done
[10:26:06.695] result() for MulticoreFuture ...
[10:26:06.695] plan(): Setting new future strategy stack:
[10:26:06.696] List of future strategies:
[10:26:06.696] 1. sequential:
[10:26:06.696]    - args: function (..., envir = parent.frame())
[10:26:06.696]    - tweaked: FALSE
[10:26:06.696]    - call: NULL
[10:26:06.696] plan(): nbrOfWorkers() = 1
[10:26:06.698] plan(): Setting new future strategy stack:
[10:26:06.699] List of future strategies:
[10:26:06.699] 1. multicore:
[10:26:06.699]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.699]    - tweaked: FALSE
[10:26:06.699]    - call: plan(strategy)
[10:26:06.704] plan(): nbrOfWorkers() = 2
[10:26:06.704] result() for MulticoreFuture ...
[10:26:06.704] result() for MulticoreFuture ... done
[10:26:06.705] result() for MulticoreFuture ... done
[10:26:06.705] result() for MulticoreFuture ...
[10:26:06.705] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.705] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.706] Searching for globals...
[10:26:06.708] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:06.708] Searching for globals ... DONE
[10:26:06.708] Resolving globals: TRUE
[10:26:06.709] Resolving any globals that are futures ...
[10:26:06.709] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:06.709] Resolving any globals that are futures ... DONE
[10:26:06.709] Resolving futures part of globals (recursively) ...
[10:26:06.710] resolve() on list ...
[10:26:06.710]  recursive: 99
[10:26:06.710]  length: 1
[10:26:06.710]  elements: ‘x’
[10:26:06.710]  length: 0 (resolved future 1)
[10:26:06.710] resolve() on list ... DONE
[10:26:06.710] - globals: [1] ‘x’
[10:26:06.710] Resolving futures part of globals (recursively) ... DONE
[10:26:06.711] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.711] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.711] - globals: [1] ‘x’
[10:26:06.711] 
[10:26:06.711] getGlobalsAndPackages() ... DONE
[10:26:06.714] run() for ‘Future’ ...
[10:26:06.715] - state: ‘created’
[10:26:06.715] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:06.719] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:06.719] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:06.719]   - Field: ‘label’
[10:26:06.719]   - Field: ‘local’
[10:26:06.719]   - Field: ‘owner’
[10:26:06.720]   - Field: ‘envir’
[10:26:06.720]   - Field: ‘workers’
[10:26:06.720]   - Field: ‘packages’
[10:26:06.720]   - Field: ‘gc’
[10:26:06.720]   - Field: ‘job’
[10:26:06.720]   - Field: ‘conditions’
[10:26:06.720]   - Field: ‘expr’
[10:26:06.720]   - Field: ‘uuid’
[10:26:06.721]   - Field: ‘seed’
[10:26:06.721]   - Field: ‘version’
[10:26:06.721]   - Field: ‘result’
[10:26:06.721]   - Field: ‘asynchronous’
[10:26:06.721]   - Field: ‘calls’
[10:26:06.721]   - Field: ‘globals’
[10:26:06.721]   - Field: ‘stdout’
[10:26:06.721]   - Field: ‘earlySignal’
[10:26:06.722]   - Field: ‘lazy’
[10:26:06.722]   - Field: ‘state’
[10:26:06.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:06.722] - Launch lazy future ...
[10:26:06.722] Packages needed by the future expression (n = 0): <none>
[10:26:06.722] Packages needed by future strategies (n = 0): <none>
[10:26:06.723] {
[10:26:06.723]     {
[10:26:06.723]         {
[10:26:06.723]             ...future.startTime <- base::Sys.time()
[10:26:06.723]             {
[10:26:06.723]                 {
[10:26:06.723]                   {
[10:26:06.723]                     {
[10:26:06.723]                       base::local({
[10:26:06.723]                         has_future <- base::requireNamespace("future", 
[10:26:06.723]                           quietly = TRUE)
[10:26:06.723]                         if (has_future) {
[10:26:06.723]                           ns <- base::getNamespace("future")
[10:26:06.723]                           version <- ns[[".package"]][["version"]]
[10:26:06.723]                           if (is.null(version)) 
[10:26:06.723]                             version <- utils::packageVersion("future")
[10:26:06.723]                         }
[10:26:06.723]                         else {
[10:26:06.723]                           version <- NULL
[10:26:06.723]                         }
[10:26:06.723]                         if (!has_future || version < "1.8.0") {
[10:26:06.723]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.723]                             "", base::R.version$version.string), 
[10:26:06.723]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:06.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.723]                               "release", "version")], collapse = " "), 
[10:26:06.723]                             hostname = base::Sys.info()[["nodename"]])
[10:26:06.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.723]                             info)
[10:26:06.723]                           info <- base::paste(info, collapse = "; ")
[10:26:06.723]                           if (!has_future) {
[10:26:06.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.723]                               info)
[10:26:06.723]                           }
[10:26:06.723]                           else {
[10:26:06.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.723]                               info, version)
[10:26:06.723]                           }
[10:26:06.723]                           base::stop(msg)
[10:26:06.723]                         }
[10:26:06.723]                       })
[10:26:06.723]                     }
[10:26:06.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:06.723]                     base::options(mc.cores = 1L)
[10:26:06.723]                   }
[10:26:06.723]                   options(future.plan = NULL)
[10:26:06.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.723]                 }
[10:26:06.723]                 ...future.workdir <- getwd()
[10:26:06.723]             }
[10:26:06.723]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.723]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.723]         }
[10:26:06.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.723]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.723]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.723]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.723]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.723]             base::names(...future.oldOptions))
[10:26:06.723]     }
[10:26:06.723]     if (FALSE) {
[10:26:06.723]     }
[10:26:06.723]     else {
[10:26:06.723]         if (TRUE) {
[10:26:06.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.723]                 open = "w")
[10:26:06.723]         }
[10:26:06.723]         else {
[10:26:06.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.723]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.723]         }
[10:26:06.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.723]             base::sink(type = "output", split = FALSE)
[10:26:06.723]             base::close(...future.stdout)
[10:26:06.723]         }, add = TRUE)
[10:26:06.723]     }
[10:26:06.723]     ...future.frame <- base::sys.nframe()
[10:26:06.723]     ...future.conditions <- base::list()
[10:26:06.723]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.723]     if (FALSE) {
[10:26:06.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.723]     }
[10:26:06.723]     ...future.result <- base::tryCatch({
[10:26:06.723]         base::withCallingHandlers({
[10:26:06.723]             ...future.value <- base::withVisible(base::local({
[10:26:06.723]                 withCallingHandlers({
[10:26:06.723]                   {
[10:26:06.723]                     x[["a"]] <- 1
[10:26:06.723]                     x
[10:26:06.723]                   }
[10:26:06.723]                 }, immediateCondition = function(cond) {
[10:26:06.723]                   save_rds <- function (object, pathname, ...) 
[10:26:06.723]                   {
[10:26:06.723]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:06.723]                     if (file_test("-f", pathname_tmp)) {
[10:26:06.723]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.723]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:06.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.723]                         fi_tmp[["mtime"]])
[10:26:06.723]                     }
[10:26:06.723]                     tryCatch({
[10:26:06.723]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:06.723]                     }, error = function(ex) {
[10:26:06.723]                       msg <- conditionMessage(ex)
[10:26:06.723]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.723]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:06.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.723]                         fi_tmp[["mtime"]], msg)
[10:26:06.723]                       ex$message <- msg
[10:26:06.723]                       stop(ex)
[10:26:06.723]                     })
[10:26:06.723]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:06.723]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:06.723]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:06.723]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.723]                       fi <- file.info(pathname)
[10:26:06.723]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:06.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.723]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:06.723]                         fi[["size"]], fi[["mtime"]])
[10:26:06.723]                       stop(msg)
[10:26:06.723]                     }
[10:26:06.723]                     invisible(pathname)
[10:26:06.723]                   }
[10:26:06.723]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:06.723]                     rootPath = tempdir()) 
[10:26:06.723]                   {
[10:26:06.723]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:06.723]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:06.723]                       tmpdir = path, fileext = ".rds")
[10:26:06.723]                     save_rds(obj, file)
[10:26:06.723]                   }
[10:26:06.723]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4YXwpK/.future/immediateConditions")
[10:26:06.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.723]                   {
[10:26:06.723]                     inherits <- base::inherits
[10:26:06.723]                     invokeRestart <- base::invokeRestart
[10:26:06.723]                     is.null <- base::is.null
[10:26:06.723]                     muffled <- FALSE
[10:26:06.723]                     if (inherits(cond, "message")) {
[10:26:06.723]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:06.723]                       if (muffled) 
[10:26:06.723]                         invokeRestart("muffleMessage")
[10:26:06.723]                     }
[10:26:06.723]                     else if (inherits(cond, "warning")) {
[10:26:06.723]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:06.723]                       if (muffled) 
[10:26:06.723]                         invokeRestart("muffleWarning")
[10:26:06.723]                     }
[10:26:06.723]                     else if (inherits(cond, "condition")) {
[10:26:06.723]                       if (!is.null(pattern)) {
[10:26:06.723]                         computeRestarts <- base::computeRestarts
[10:26:06.723]                         grepl <- base::grepl
[10:26:06.723]                         restarts <- computeRestarts(cond)
[10:26:06.723]                         for (restart in restarts) {
[10:26:06.723]                           name <- restart$name
[10:26:06.723]                           if (is.null(name)) 
[10:26:06.723]                             next
[10:26:06.723]                           if (!grepl(pattern, name)) 
[10:26:06.723]                             next
[10:26:06.723]                           invokeRestart(restart)
[10:26:06.723]                           muffled <- TRUE
[10:26:06.723]                           break
[10:26:06.723]                         }
[10:26:06.723]                       }
[10:26:06.723]                     }
[10:26:06.723]                     invisible(muffled)
[10:26:06.723]                   }
[10:26:06.723]                   muffleCondition(cond)
[10:26:06.723]                 })
[10:26:06.723]             }))
[10:26:06.723]             future::FutureResult(value = ...future.value$value, 
[10:26:06.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.723]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.723]                     ...future.globalenv.names))
[10:26:06.723]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.723]         }, condition = base::local({
[10:26:06.723]             c <- base::c
[10:26:06.723]             inherits <- base::inherits
[10:26:06.723]             invokeRestart <- base::invokeRestart
[10:26:06.723]             length <- base::length
[10:26:06.723]             list <- base::list
[10:26:06.723]             seq.int <- base::seq.int
[10:26:06.723]             signalCondition <- base::signalCondition
[10:26:06.723]             sys.calls <- base::sys.calls
[10:26:06.723]             `[[` <- base::`[[`
[10:26:06.723]             `+` <- base::`+`
[10:26:06.723]             `<<-` <- base::`<<-`
[10:26:06.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.723]                   3L)]
[10:26:06.723]             }
[10:26:06.723]             function(cond) {
[10:26:06.723]                 is_error <- inherits(cond, "error")
[10:26:06.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.723]                   NULL)
[10:26:06.723]                 if (is_error) {
[10:26:06.723]                   sessionInformation <- function() {
[10:26:06.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.723]                       search = base::search(), system = base::Sys.info())
[10:26:06.723]                   }
[10:26:06.723]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.723]                     cond$call), session = sessionInformation(), 
[10:26:06.723]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.723]                   signalCondition(cond)
[10:26:06.723]                 }
[10:26:06.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.723]                 "immediateCondition"))) {
[10:26:06.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.723]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.723]                   if (TRUE && !signal) {
[10:26:06.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.723]                     {
[10:26:06.723]                       inherits <- base::inherits
[10:26:06.723]                       invokeRestart <- base::invokeRestart
[10:26:06.723]                       is.null <- base::is.null
[10:26:06.723]                       muffled <- FALSE
[10:26:06.723]                       if (inherits(cond, "message")) {
[10:26:06.723]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.723]                         if (muffled) 
[10:26:06.723]                           invokeRestart("muffleMessage")
[10:26:06.723]                       }
[10:26:06.723]                       else if (inherits(cond, "warning")) {
[10:26:06.723]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.723]                         if (muffled) 
[10:26:06.723]                           invokeRestart("muffleWarning")
[10:26:06.723]                       }
[10:26:06.723]                       else if (inherits(cond, "condition")) {
[10:26:06.723]                         if (!is.null(pattern)) {
[10:26:06.723]                           computeRestarts <- base::computeRestarts
[10:26:06.723]                           grepl <- base::grepl
[10:26:06.723]                           restarts <- computeRestarts(cond)
[10:26:06.723]                           for (restart in restarts) {
[10:26:06.723]                             name <- restart$name
[10:26:06.723]                             if (is.null(name)) 
[10:26:06.723]                               next
[10:26:06.723]                             if (!grepl(pattern, name)) 
[10:26:06.723]                               next
[10:26:06.723]                             invokeRestart(restart)
[10:26:06.723]                             muffled <- TRUE
[10:26:06.723]                             break
[10:26:06.723]                           }
[10:26:06.723]                         }
[10:26:06.723]                       }
[10:26:06.723]                       invisible(muffled)
[10:26:06.723]                     }
[10:26:06.723]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.723]                   }
[10:26:06.723]                 }
[10:26:06.723]                 else {
[10:26:06.723]                   if (TRUE) {
[10:26:06.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.723]                     {
[10:26:06.723]                       inherits <- base::inherits
[10:26:06.723]                       invokeRestart <- base::invokeRestart
[10:26:06.723]                       is.null <- base::is.null
[10:26:06.723]                       muffled <- FALSE
[10:26:06.723]                       if (inherits(cond, "message")) {
[10:26:06.723]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.723]                         if (muffled) 
[10:26:06.723]                           invokeRestart("muffleMessage")
[10:26:06.723]                       }
[10:26:06.723]                       else if (inherits(cond, "warning")) {
[10:26:06.723]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.723]                         if (muffled) 
[10:26:06.723]                           invokeRestart("muffleWarning")
[10:26:06.723]                       }
[10:26:06.723]                       else if (inherits(cond, "condition")) {
[10:26:06.723]                         if (!is.null(pattern)) {
[10:26:06.723]                           computeRestarts <- base::computeRestarts
[10:26:06.723]                           grepl <- base::grepl
[10:26:06.723]                           restarts <- computeRestarts(cond)
[10:26:06.723]                           for (restart in restarts) {
[10:26:06.723]                             name <- restart$name
[10:26:06.723]                             if (is.null(name)) 
[10:26:06.723]                               next
[10:26:06.723]                             if (!grepl(pattern, name)) 
[10:26:06.723]                               next
[10:26:06.723]                             invokeRestart(restart)
[10:26:06.723]                             muffled <- TRUE
[10:26:06.723]                             break
[10:26:06.723]                           }
[10:26:06.723]                         }
[10:26:06.723]                       }
[10:26:06.723]                       invisible(muffled)
[10:26:06.723]                     }
[10:26:06.723]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.723]                   }
[10:26:06.723]                 }
[10:26:06.723]             }
[10:26:06.723]         }))
[10:26:06.723]     }, error = function(ex) {
[10:26:06.723]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.723]                 ...future.rng), started = ...future.startTime, 
[10:26:06.723]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.723]             version = "1.8"), class = "FutureResult")
[10:26:06.723]     }, finally = {
[10:26:06.723]         if (!identical(...future.workdir, getwd())) 
[10:26:06.723]             setwd(...future.workdir)
[10:26:06.723]         {
[10:26:06.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.723]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.723]             }
[10:26:06.723]             base::options(...future.oldOptions)
[10:26:06.723]             if (.Platform$OS.type == "windows") {
[10:26:06.723]                 old_names <- names(...future.oldEnvVars)
[10:26:06.723]                 envs <- base::Sys.getenv()
[10:26:06.723]                 names <- names(envs)
[10:26:06.723]                 common <- intersect(names, old_names)
[10:26:06.723]                 added <- setdiff(names, old_names)
[10:26:06.723]                 removed <- setdiff(old_names, names)
[10:26:06.723]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.723]                   envs[common]]
[10:26:06.723]                 NAMES <- toupper(changed)
[10:26:06.723]                 args <- list()
[10:26:06.723]                 for (kk in seq_along(NAMES)) {
[10:26:06.723]                   name <- changed[[kk]]
[10:26:06.723]                   NAME <- NAMES[[kk]]
[10:26:06.723]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.723]                     next
[10:26:06.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.723]                 }
[10:26:06.723]                 NAMES <- toupper(added)
[10:26:06.723]                 for (kk in seq_along(NAMES)) {
[10:26:06.723]                   name <- added[[kk]]
[10:26:06.723]                   NAME <- NAMES[[kk]]
[10:26:06.723]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.723]                     next
[10:26:06.723]                   args[[name]] <- ""
[10:26:06.723]                 }
[10:26:06.723]                 NAMES <- toupper(removed)
[10:26:06.723]                 for (kk in seq_along(NAMES)) {
[10:26:06.723]                   name <- removed[[kk]]
[10:26:06.723]                   NAME <- NAMES[[kk]]
[10:26:06.723]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.723]                     next
[10:26:06.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.723]                 }
[10:26:06.723]                 if (length(args) > 0) 
[10:26:06.723]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.723]             }
[10:26:06.723]             else {
[10:26:06.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.723]             }
[10:26:06.723]             {
[10:26:06.723]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.723]                   0L) {
[10:26:06.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.723]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.723]                   base::options(opts)
[10:26:06.723]                 }
[10:26:06.723]                 {
[10:26:06.723]                   {
[10:26:06.723]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:06.723]                     NULL
[10:26:06.723]                   }
[10:26:06.723]                   options(future.plan = NULL)
[10:26:06.723]                   if (is.na(NA_character_)) 
[10:26:06.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.723]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:06.723]                     envir = parent.frame()) 
[10:26:06.723]                   {
[10:26:06.723]                     default_workers <- missing(workers)
[10:26:06.723]                     if (is.function(workers)) 
[10:26:06.723]                       workers <- workers()
[10:26:06.723]                     workers <- structure(as.integer(workers), 
[10:26:06.723]                       class = class(workers))
[10:26:06.723]                     stop_if_not(is.finite(workers), workers >= 
[10:26:06.723]                       1L)
[10:26:06.723]                     if ((workers == 1L && !inherits(workers, 
[10:26:06.723]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:06.723]                       if (default_workers) 
[10:26:06.723]                         supportsMulticore(warn = TRUE)
[10:26:06.723]                       return(sequential(..., envir = envir))
[10:26:06.723]                     }
[10:26:06.723]                     oopts <- options(mc.cores = workers)
[10:26:06.723]                     on.exit(options(oopts))
[10:26:06.723]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:06.723]                       envir = envir)
[10:26:06.723]                     if (!future$lazy) 
[10:26:06.723]                       future <- run(future)
[10:26:06.723]                     invisible(future)
[10:26:06.723]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.723]                 }
[10:26:06.723]             }
[10:26:06.723]         }
[10:26:06.723]     })
[10:26:06.723]     if (TRUE) {
[10:26:06.723]         base::sink(type = "output", split = FALSE)
[10:26:06.723]         if (TRUE) {
[10:26:06.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.723]         }
[10:26:06.723]         else {
[10:26:06.723]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.723]         }
[10:26:06.723]         base::close(...future.stdout)
[10:26:06.723]         ...future.stdout <- NULL
[10:26:06.723]     }
[10:26:06.723]     ...future.result$conditions <- ...future.conditions
[10:26:06.723]     ...future.result$finished <- base::Sys.time()
[10:26:06.723]     ...future.result
[10:26:06.723] }
[10:26:06.725] assign_globals() ...
[10:26:06.725] List of 1
[10:26:06.725]  $ x: list()
[10:26:06.725]  - attr(*, "where")=List of 1
[10:26:06.725]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.725]  - attr(*, "resolved")= logi TRUE
[10:26:06.725]  - attr(*, "total_size")= num 0
[10:26:06.725]  - attr(*, "already-done")= logi TRUE
[10:26:06.728] - copied ‘x’ to environment
[10:26:06.728] assign_globals() ... done
[10:26:06.729] requestCore(): workers = 2
[10:26:06.730] MulticoreFuture started
[10:26:06.731] - Launch lazy future ... done
[10:26:06.731] run() for ‘MulticoreFuture’ ... done
[10:26:06.731] result() for MulticoreFuture ...
[10:26:06.731] plan(): Setting new future strategy stack:
[10:26:06.732] List of future strategies:
[10:26:06.732] 1. sequential:
[10:26:06.732]    - args: function (..., envir = parent.frame())
[10:26:06.732]    - tweaked: FALSE
[10:26:06.732]    - call: NULL
[10:26:06.732] plan(): nbrOfWorkers() = 1
[10:26:06.734] plan(): Setting new future strategy stack:
[10:26:06.735] List of future strategies:
[10:26:06.735] 1. multicore:
[10:26:06.735]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.735]    - tweaked: FALSE
[10:26:06.735]    - call: plan(strategy)
[10:26:06.739] plan(): nbrOfWorkers() = 2
[10:26:06.740] result() for MulticoreFuture ...
[10:26:06.740] result() for MulticoreFuture ... done
[10:26:06.741] result() for MulticoreFuture ... done
[10:26:06.741] result() for MulticoreFuture ...
[10:26:06.741] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.742] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.742] Searching for globals...
[10:26:06.745] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:06.745] Searching for globals ... DONE
[10:26:06.745] Resolving globals: TRUE
[10:26:06.745] Resolving any globals that are futures ...
[10:26:06.745] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:06.745] Resolving any globals that are futures ... DONE
[10:26:06.746] Resolving futures part of globals (recursively) ...
[10:26:06.746] resolve() on list ...
[10:26:06.746]  recursive: 99
[10:26:06.746]  length: 1
[10:26:06.746]  elements: ‘x’
[10:26:06.747]  length: 0 (resolved future 1)
[10:26:06.747] resolve() on list ... DONE
[10:26:06.747] - globals: [1] ‘x’
[10:26:06.747] Resolving futures part of globals (recursively) ... DONE
[10:26:06.747] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.747] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.748] - globals: [1] ‘x’
[10:26:06.748] 
[10:26:06.748] getGlobalsAndPackages() ... DONE
[10:26:06.748] run() for ‘Future’ ...
[10:26:06.748] - state: ‘created’
[10:26:06.749] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:06.753] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:06.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:06.753]   - Field: ‘label’
[10:26:06.753]   - Field: ‘local’
[10:26:06.753]   - Field: ‘owner’
[10:26:06.753]   - Field: ‘envir’
[10:26:06.753]   - Field: ‘workers’
[10:26:06.753]   - Field: ‘packages’
[10:26:06.754]   - Field: ‘gc’
[10:26:06.754]   - Field: ‘job’
[10:26:06.754]   - Field: ‘conditions’
[10:26:06.754]   - Field: ‘expr’
[10:26:06.754]   - Field: ‘uuid’
[10:26:06.754]   - Field: ‘seed’
[10:26:06.754]   - Field: ‘version’
[10:26:06.754]   - Field: ‘result’
[10:26:06.754]   - Field: ‘asynchronous’
[10:26:06.755]   - Field: ‘calls’
[10:26:06.755]   - Field: ‘globals’
[10:26:06.755]   - Field: ‘stdout’
[10:26:06.755]   - Field: ‘earlySignal’
[10:26:06.755]   - Field: ‘lazy’
[10:26:06.755]   - Field: ‘state’
[10:26:06.755] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:06.755] - Launch lazy future ...
[10:26:06.756] Packages needed by the future expression (n = 0): <none>
[10:26:06.756] Packages needed by future strategies (n = 0): <none>
[10:26:06.756] {
[10:26:06.756]     {
[10:26:06.756]         {
[10:26:06.756]             ...future.startTime <- base::Sys.time()
[10:26:06.756]             {
[10:26:06.756]                 {
[10:26:06.756]                   {
[10:26:06.756]                     {
[10:26:06.756]                       base::local({
[10:26:06.756]                         has_future <- base::requireNamespace("future", 
[10:26:06.756]                           quietly = TRUE)
[10:26:06.756]                         if (has_future) {
[10:26:06.756]                           ns <- base::getNamespace("future")
[10:26:06.756]                           version <- ns[[".package"]][["version"]]
[10:26:06.756]                           if (is.null(version)) 
[10:26:06.756]                             version <- utils::packageVersion("future")
[10:26:06.756]                         }
[10:26:06.756]                         else {
[10:26:06.756]                           version <- NULL
[10:26:06.756]                         }
[10:26:06.756]                         if (!has_future || version < "1.8.0") {
[10:26:06.756]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.756]                             "", base::R.version$version.string), 
[10:26:06.756]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:06.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.756]                               "release", "version")], collapse = " "), 
[10:26:06.756]                             hostname = base::Sys.info()[["nodename"]])
[10:26:06.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.756]                             info)
[10:26:06.756]                           info <- base::paste(info, collapse = "; ")
[10:26:06.756]                           if (!has_future) {
[10:26:06.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.756]                               info)
[10:26:06.756]                           }
[10:26:06.756]                           else {
[10:26:06.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.756]                               info, version)
[10:26:06.756]                           }
[10:26:06.756]                           base::stop(msg)
[10:26:06.756]                         }
[10:26:06.756]                       })
[10:26:06.756]                     }
[10:26:06.756]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:06.756]                     base::options(mc.cores = 1L)
[10:26:06.756]                   }
[10:26:06.756]                   options(future.plan = NULL)
[10:26:06.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.756]                 }
[10:26:06.756]                 ...future.workdir <- getwd()
[10:26:06.756]             }
[10:26:06.756]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.756]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.756]         }
[10:26:06.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.756]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.756]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.756]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.756]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.756]             base::names(...future.oldOptions))
[10:26:06.756]     }
[10:26:06.756]     if (FALSE) {
[10:26:06.756]     }
[10:26:06.756]     else {
[10:26:06.756]         if (TRUE) {
[10:26:06.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.756]                 open = "w")
[10:26:06.756]         }
[10:26:06.756]         else {
[10:26:06.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.756]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.756]         }
[10:26:06.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.756]             base::sink(type = "output", split = FALSE)
[10:26:06.756]             base::close(...future.stdout)
[10:26:06.756]         }, add = TRUE)
[10:26:06.756]     }
[10:26:06.756]     ...future.frame <- base::sys.nframe()
[10:26:06.756]     ...future.conditions <- base::list()
[10:26:06.756]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.756]     if (FALSE) {
[10:26:06.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.756]     }
[10:26:06.756]     ...future.result <- base::tryCatch({
[10:26:06.756]         base::withCallingHandlers({
[10:26:06.756]             ...future.value <- base::withVisible(base::local({
[10:26:06.756]                 withCallingHandlers({
[10:26:06.756]                   {
[10:26:06.756]                     x[["a"]] <- 1
[10:26:06.756]                     x
[10:26:06.756]                   }
[10:26:06.756]                 }, immediateCondition = function(cond) {
[10:26:06.756]                   save_rds <- function (object, pathname, ...) 
[10:26:06.756]                   {
[10:26:06.756]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:06.756]                     if (file_test("-f", pathname_tmp)) {
[10:26:06.756]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.756]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:06.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.756]                         fi_tmp[["mtime"]])
[10:26:06.756]                     }
[10:26:06.756]                     tryCatch({
[10:26:06.756]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:06.756]                     }, error = function(ex) {
[10:26:06.756]                       msg <- conditionMessage(ex)
[10:26:06.756]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.756]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:06.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.756]                         fi_tmp[["mtime"]], msg)
[10:26:06.756]                       ex$message <- msg
[10:26:06.756]                       stop(ex)
[10:26:06.756]                     })
[10:26:06.756]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:06.756]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:06.756]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:06.756]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.756]                       fi <- file.info(pathname)
[10:26:06.756]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:06.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.756]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:06.756]                         fi[["size"]], fi[["mtime"]])
[10:26:06.756]                       stop(msg)
[10:26:06.756]                     }
[10:26:06.756]                     invisible(pathname)
[10:26:06.756]                   }
[10:26:06.756]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:06.756]                     rootPath = tempdir()) 
[10:26:06.756]                   {
[10:26:06.756]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:06.756]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:06.756]                       tmpdir = path, fileext = ".rds")
[10:26:06.756]                     save_rds(obj, file)
[10:26:06.756]                   }
[10:26:06.756]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4YXwpK/.future/immediateConditions")
[10:26:06.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.756]                   {
[10:26:06.756]                     inherits <- base::inherits
[10:26:06.756]                     invokeRestart <- base::invokeRestart
[10:26:06.756]                     is.null <- base::is.null
[10:26:06.756]                     muffled <- FALSE
[10:26:06.756]                     if (inherits(cond, "message")) {
[10:26:06.756]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:06.756]                       if (muffled) 
[10:26:06.756]                         invokeRestart("muffleMessage")
[10:26:06.756]                     }
[10:26:06.756]                     else if (inherits(cond, "warning")) {
[10:26:06.756]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:06.756]                       if (muffled) 
[10:26:06.756]                         invokeRestart("muffleWarning")
[10:26:06.756]                     }
[10:26:06.756]                     else if (inherits(cond, "condition")) {
[10:26:06.756]                       if (!is.null(pattern)) {
[10:26:06.756]                         computeRestarts <- base::computeRestarts
[10:26:06.756]                         grepl <- base::grepl
[10:26:06.756]                         restarts <- computeRestarts(cond)
[10:26:06.756]                         for (restart in restarts) {
[10:26:06.756]                           name <- restart$name
[10:26:06.756]                           if (is.null(name)) 
[10:26:06.756]                             next
[10:26:06.756]                           if (!grepl(pattern, name)) 
[10:26:06.756]                             next
[10:26:06.756]                           invokeRestart(restart)
[10:26:06.756]                           muffled <- TRUE
[10:26:06.756]                           break
[10:26:06.756]                         }
[10:26:06.756]                       }
[10:26:06.756]                     }
[10:26:06.756]                     invisible(muffled)
[10:26:06.756]                   }
[10:26:06.756]                   muffleCondition(cond)
[10:26:06.756]                 })
[10:26:06.756]             }))
[10:26:06.756]             future::FutureResult(value = ...future.value$value, 
[10:26:06.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.756]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.756]                     ...future.globalenv.names))
[10:26:06.756]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.756]         }, condition = base::local({
[10:26:06.756]             c <- base::c
[10:26:06.756]             inherits <- base::inherits
[10:26:06.756]             invokeRestart <- base::invokeRestart
[10:26:06.756]             length <- base::length
[10:26:06.756]             list <- base::list
[10:26:06.756]             seq.int <- base::seq.int
[10:26:06.756]             signalCondition <- base::signalCondition
[10:26:06.756]             sys.calls <- base::sys.calls
[10:26:06.756]             `[[` <- base::`[[`
[10:26:06.756]             `+` <- base::`+`
[10:26:06.756]             `<<-` <- base::`<<-`
[10:26:06.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.756]                   3L)]
[10:26:06.756]             }
[10:26:06.756]             function(cond) {
[10:26:06.756]                 is_error <- inherits(cond, "error")
[10:26:06.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.756]                   NULL)
[10:26:06.756]                 if (is_error) {
[10:26:06.756]                   sessionInformation <- function() {
[10:26:06.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.756]                       search = base::search(), system = base::Sys.info())
[10:26:06.756]                   }
[10:26:06.756]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.756]                     cond$call), session = sessionInformation(), 
[10:26:06.756]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.756]                   signalCondition(cond)
[10:26:06.756]                 }
[10:26:06.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.756]                 "immediateCondition"))) {
[10:26:06.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.756]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.756]                   if (TRUE && !signal) {
[10:26:06.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.756]                     {
[10:26:06.756]                       inherits <- base::inherits
[10:26:06.756]                       invokeRestart <- base::invokeRestart
[10:26:06.756]                       is.null <- base::is.null
[10:26:06.756]                       muffled <- FALSE
[10:26:06.756]                       if (inherits(cond, "message")) {
[10:26:06.756]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.756]                         if (muffled) 
[10:26:06.756]                           invokeRestart("muffleMessage")
[10:26:06.756]                       }
[10:26:06.756]                       else if (inherits(cond, "warning")) {
[10:26:06.756]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.756]                         if (muffled) 
[10:26:06.756]                           invokeRestart("muffleWarning")
[10:26:06.756]                       }
[10:26:06.756]                       else if (inherits(cond, "condition")) {
[10:26:06.756]                         if (!is.null(pattern)) {
[10:26:06.756]                           computeRestarts <- base::computeRestarts
[10:26:06.756]                           grepl <- base::grepl
[10:26:06.756]                           restarts <- computeRestarts(cond)
[10:26:06.756]                           for (restart in restarts) {
[10:26:06.756]                             name <- restart$name
[10:26:06.756]                             if (is.null(name)) 
[10:26:06.756]                               next
[10:26:06.756]                             if (!grepl(pattern, name)) 
[10:26:06.756]                               next
[10:26:06.756]                             invokeRestart(restart)
[10:26:06.756]                             muffled <- TRUE
[10:26:06.756]                             break
[10:26:06.756]                           }
[10:26:06.756]                         }
[10:26:06.756]                       }
[10:26:06.756]                       invisible(muffled)
[10:26:06.756]                     }
[10:26:06.756]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.756]                   }
[10:26:06.756]                 }
[10:26:06.756]                 else {
[10:26:06.756]                   if (TRUE) {
[10:26:06.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.756]                     {
[10:26:06.756]                       inherits <- base::inherits
[10:26:06.756]                       invokeRestart <- base::invokeRestart
[10:26:06.756]                       is.null <- base::is.null
[10:26:06.756]                       muffled <- FALSE
[10:26:06.756]                       if (inherits(cond, "message")) {
[10:26:06.756]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.756]                         if (muffled) 
[10:26:06.756]                           invokeRestart("muffleMessage")
[10:26:06.756]                       }
[10:26:06.756]                       else if (inherits(cond, "warning")) {
[10:26:06.756]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.756]                         if (muffled) 
[10:26:06.756]                           invokeRestart("muffleWarning")
[10:26:06.756]                       }
[10:26:06.756]                       else if (inherits(cond, "condition")) {
[10:26:06.756]                         if (!is.null(pattern)) {
[10:26:06.756]                           computeRestarts <- base::computeRestarts
[10:26:06.756]                           grepl <- base::grepl
[10:26:06.756]                           restarts <- computeRestarts(cond)
[10:26:06.756]                           for (restart in restarts) {
[10:26:06.756]                             name <- restart$name
[10:26:06.756]                             if (is.null(name)) 
[10:26:06.756]                               next
[10:26:06.756]                             if (!grepl(pattern, name)) 
[10:26:06.756]                               next
[10:26:06.756]                             invokeRestart(restart)
[10:26:06.756]                             muffled <- TRUE
[10:26:06.756]                             break
[10:26:06.756]                           }
[10:26:06.756]                         }
[10:26:06.756]                       }
[10:26:06.756]                       invisible(muffled)
[10:26:06.756]                     }
[10:26:06.756]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.756]                   }
[10:26:06.756]                 }
[10:26:06.756]             }
[10:26:06.756]         }))
[10:26:06.756]     }, error = function(ex) {
[10:26:06.756]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.756]                 ...future.rng), started = ...future.startTime, 
[10:26:06.756]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.756]             version = "1.8"), class = "FutureResult")
[10:26:06.756]     }, finally = {
[10:26:06.756]         if (!identical(...future.workdir, getwd())) 
[10:26:06.756]             setwd(...future.workdir)
[10:26:06.756]         {
[10:26:06.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.756]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.756]             }
[10:26:06.756]             base::options(...future.oldOptions)
[10:26:06.756]             if (.Platform$OS.type == "windows") {
[10:26:06.756]                 old_names <- names(...future.oldEnvVars)
[10:26:06.756]                 envs <- base::Sys.getenv()
[10:26:06.756]                 names <- names(envs)
[10:26:06.756]                 common <- intersect(names, old_names)
[10:26:06.756]                 added <- setdiff(names, old_names)
[10:26:06.756]                 removed <- setdiff(old_names, names)
[10:26:06.756]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.756]                   envs[common]]
[10:26:06.756]                 NAMES <- toupper(changed)
[10:26:06.756]                 args <- list()
[10:26:06.756]                 for (kk in seq_along(NAMES)) {
[10:26:06.756]                   name <- changed[[kk]]
[10:26:06.756]                   NAME <- NAMES[[kk]]
[10:26:06.756]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.756]                     next
[10:26:06.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.756]                 }
[10:26:06.756]                 NAMES <- toupper(added)
[10:26:06.756]                 for (kk in seq_along(NAMES)) {
[10:26:06.756]                   name <- added[[kk]]
[10:26:06.756]                   NAME <- NAMES[[kk]]
[10:26:06.756]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.756]                     next
[10:26:06.756]                   args[[name]] <- ""
[10:26:06.756]                 }
[10:26:06.756]                 NAMES <- toupper(removed)
[10:26:06.756]                 for (kk in seq_along(NAMES)) {
[10:26:06.756]                   name <- removed[[kk]]
[10:26:06.756]                   NAME <- NAMES[[kk]]
[10:26:06.756]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.756]                     next
[10:26:06.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.756]                 }
[10:26:06.756]                 if (length(args) > 0) 
[10:26:06.756]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.756]             }
[10:26:06.756]             else {
[10:26:06.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.756]             }
[10:26:06.756]             {
[10:26:06.756]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.756]                   0L) {
[10:26:06.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.756]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.756]                   base::options(opts)
[10:26:06.756]                 }
[10:26:06.756]                 {
[10:26:06.756]                   {
[10:26:06.756]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:06.756]                     NULL
[10:26:06.756]                   }
[10:26:06.756]                   options(future.plan = NULL)
[10:26:06.756]                   if (is.na(NA_character_)) 
[10:26:06.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.756]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:06.756]                     envir = parent.frame()) 
[10:26:06.756]                   {
[10:26:06.756]                     default_workers <- missing(workers)
[10:26:06.756]                     if (is.function(workers)) 
[10:26:06.756]                       workers <- workers()
[10:26:06.756]                     workers <- structure(as.integer(workers), 
[10:26:06.756]                       class = class(workers))
[10:26:06.756]                     stop_if_not(is.finite(workers), workers >= 
[10:26:06.756]                       1L)
[10:26:06.756]                     if ((workers == 1L && !inherits(workers, 
[10:26:06.756]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:06.756]                       if (default_workers) 
[10:26:06.756]                         supportsMulticore(warn = TRUE)
[10:26:06.756]                       return(sequential(..., envir = envir))
[10:26:06.756]                     }
[10:26:06.756]                     oopts <- options(mc.cores = workers)
[10:26:06.756]                     on.exit(options(oopts))
[10:26:06.756]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:06.756]                       envir = envir)
[10:26:06.756]                     if (!future$lazy) 
[10:26:06.756]                       future <- run(future)
[10:26:06.756]                     invisible(future)
[10:26:06.756]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.756]                 }
[10:26:06.756]             }
[10:26:06.756]         }
[10:26:06.756]     })
[10:26:06.756]     if (TRUE) {
[10:26:06.756]         base::sink(type = "output", split = FALSE)
[10:26:06.756]         if (TRUE) {
[10:26:06.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.756]         }
[10:26:06.756]         else {
[10:26:06.756]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.756]         }
[10:26:06.756]         base::close(...future.stdout)
[10:26:06.756]         ...future.stdout <- NULL
[10:26:06.756]     }
[10:26:06.756]     ...future.result$conditions <- ...future.conditions
[10:26:06.756]     ...future.result$finished <- base::Sys.time()
[10:26:06.756]     ...future.result
[10:26:06.756] }
[10:26:06.759] assign_globals() ...
[10:26:06.759] List of 1
[10:26:06.759]  $ x: list()
[10:26:06.759]  - attr(*, "where")=List of 1
[10:26:06.759]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.759]  - attr(*, "resolved")= logi TRUE
[10:26:06.759]  - attr(*, "total_size")= num 0
[10:26:06.759]  - attr(*, "already-done")= logi TRUE
[10:26:06.764] - copied ‘x’ to environment
[10:26:06.764] assign_globals() ... done
[10:26:06.765] requestCore(): workers = 2
[10:26:06.766] MulticoreFuture started
[10:26:06.767] - Launch lazy future ... done
[10:26:06.767] run() for ‘MulticoreFuture’ ... done
[10:26:06.768] plan(): Setting new future strategy stack:
[10:26:06.768] result() for MulticoreFuture ...
[10:26:06.768] List of future strategies:
[10:26:06.768] 1. sequential:
[10:26:06.768]    - args: function (..., envir = parent.frame())
[10:26:06.768]    - tweaked: FALSE
[10:26:06.768]    - call: NULL
[10:26:06.769] plan(): nbrOfWorkers() = 1
[10:26:06.771] plan(): Setting new future strategy stack:
[10:26:06.771] List of future strategies:
[10:26:06.771] 1. multicore:
[10:26:06.771]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.771]    - tweaked: FALSE
[10:26:06.771]    - call: plan(strategy)
[10:26:06.777] plan(): nbrOfWorkers() = 2
[10:26:06.777] result() for MulticoreFuture ...
[10:26:06.778] result() for MulticoreFuture ... done
[10:26:06.778] result() for MulticoreFuture ... done
[10:26:06.778] result() for MulticoreFuture ...
[10:26:06.778] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.779] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.779] Searching for globals...
[10:26:06.782] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:06.782] Searching for globals ... DONE
[10:26:06.782] Resolving globals: TRUE
[10:26:06.782] Resolving any globals that are futures ...
[10:26:06.783] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:06.783] Resolving any globals that are futures ... DONE
[10:26:06.783] Resolving futures part of globals (recursively) ...
[10:26:06.784] resolve() on list ...
[10:26:06.784]  recursive: 99
[10:26:06.784]  length: 1
[10:26:06.784]  elements: ‘x’
[10:26:06.784]  length: 0 (resolved future 1)
[10:26:06.784] resolve() on list ... DONE
[10:26:06.784] - globals: [1] ‘x’
[10:26:06.784] Resolving futures part of globals (recursively) ... DONE
[10:26:06.785] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.785] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.785] - globals: [1] ‘x’
[10:26:06.785] 
[10:26:06.785] getGlobalsAndPackages() ... DONE
[10:26:06.786] run() for ‘Future’ ...
[10:26:06.786] - state: ‘created’
[10:26:06.786] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:06.790] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:06.790] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:06.790]   - Field: ‘label’
[10:26:06.790]   - Field: ‘local’
[10:26:06.790]   - Field: ‘owner’
[10:26:06.791]   - Field: ‘envir’
[10:26:06.791]   - Field: ‘workers’
[10:26:06.791]   - Field: ‘packages’
[10:26:06.791]   - Field: ‘gc’
[10:26:06.791]   - Field: ‘job’
[10:26:06.791]   - Field: ‘conditions’
[10:26:06.791]   - Field: ‘expr’
[10:26:06.791]   - Field: ‘uuid’
[10:26:06.791]   - Field: ‘seed’
[10:26:06.792]   - Field: ‘version’
[10:26:06.792]   - Field: ‘result’
[10:26:06.792]   - Field: ‘asynchronous’
[10:26:06.792]   - Field: ‘calls’
[10:26:06.792]   - Field: ‘globals’
[10:26:06.792]   - Field: ‘stdout’
[10:26:06.792]   - Field: ‘earlySignal’
[10:26:06.792]   - Field: ‘lazy’
[10:26:06.792]   - Field: ‘state’
[10:26:06.793] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:06.793] - Launch lazy future ...
[10:26:06.793] Packages needed by the future expression (n = 0): <none>
[10:26:06.793] Packages needed by future strategies (n = 0): <none>
[10:26:06.794] {
[10:26:06.794]     {
[10:26:06.794]         {
[10:26:06.794]             ...future.startTime <- base::Sys.time()
[10:26:06.794]             {
[10:26:06.794]                 {
[10:26:06.794]                   {
[10:26:06.794]                     {
[10:26:06.794]                       base::local({
[10:26:06.794]                         has_future <- base::requireNamespace("future", 
[10:26:06.794]                           quietly = TRUE)
[10:26:06.794]                         if (has_future) {
[10:26:06.794]                           ns <- base::getNamespace("future")
[10:26:06.794]                           version <- ns[[".package"]][["version"]]
[10:26:06.794]                           if (is.null(version)) 
[10:26:06.794]                             version <- utils::packageVersion("future")
[10:26:06.794]                         }
[10:26:06.794]                         else {
[10:26:06.794]                           version <- NULL
[10:26:06.794]                         }
[10:26:06.794]                         if (!has_future || version < "1.8.0") {
[10:26:06.794]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.794]                             "", base::R.version$version.string), 
[10:26:06.794]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:06.794]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.794]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.794]                               "release", "version")], collapse = " "), 
[10:26:06.794]                             hostname = base::Sys.info()[["nodename"]])
[10:26:06.794]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.794]                             info)
[10:26:06.794]                           info <- base::paste(info, collapse = "; ")
[10:26:06.794]                           if (!has_future) {
[10:26:06.794]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.794]                               info)
[10:26:06.794]                           }
[10:26:06.794]                           else {
[10:26:06.794]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.794]                               info, version)
[10:26:06.794]                           }
[10:26:06.794]                           base::stop(msg)
[10:26:06.794]                         }
[10:26:06.794]                       })
[10:26:06.794]                     }
[10:26:06.794]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:06.794]                     base::options(mc.cores = 1L)
[10:26:06.794]                   }
[10:26:06.794]                   options(future.plan = NULL)
[10:26:06.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.794]                 }
[10:26:06.794]                 ...future.workdir <- getwd()
[10:26:06.794]             }
[10:26:06.794]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.794]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.794]         }
[10:26:06.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.794]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.794]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.794]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.794]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.794]             base::names(...future.oldOptions))
[10:26:06.794]     }
[10:26:06.794]     if (FALSE) {
[10:26:06.794]     }
[10:26:06.794]     else {
[10:26:06.794]         if (TRUE) {
[10:26:06.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.794]                 open = "w")
[10:26:06.794]         }
[10:26:06.794]         else {
[10:26:06.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.794]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.794]         }
[10:26:06.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.794]             base::sink(type = "output", split = FALSE)
[10:26:06.794]             base::close(...future.stdout)
[10:26:06.794]         }, add = TRUE)
[10:26:06.794]     }
[10:26:06.794]     ...future.frame <- base::sys.nframe()
[10:26:06.794]     ...future.conditions <- base::list()
[10:26:06.794]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.794]     if (FALSE) {
[10:26:06.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.794]     }
[10:26:06.794]     ...future.result <- base::tryCatch({
[10:26:06.794]         base::withCallingHandlers({
[10:26:06.794]             ...future.value <- base::withVisible(base::local({
[10:26:06.794]                 withCallingHandlers({
[10:26:06.794]                   {
[10:26:06.794]                     x["a"] <- list(1)
[10:26:06.794]                     x
[10:26:06.794]                   }
[10:26:06.794]                 }, immediateCondition = function(cond) {
[10:26:06.794]                   save_rds <- function (object, pathname, ...) 
[10:26:06.794]                   {
[10:26:06.794]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:06.794]                     if (file_test("-f", pathname_tmp)) {
[10:26:06.794]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.794]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:06.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.794]                         fi_tmp[["mtime"]])
[10:26:06.794]                     }
[10:26:06.794]                     tryCatch({
[10:26:06.794]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:06.794]                     }, error = function(ex) {
[10:26:06.794]                       msg <- conditionMessage(ex)
[10:26:06.794]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.794]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:06.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.794]                         fi_tmp[["mtime"]], msg)
[10:26:06.794]                       ex$message <- msg
[10:26:06.794]                       stop(ex)
[10:26:06.794]                     })
[10:26:06.794]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:06.794]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:06.794]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:06.794]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.794]                       fi <- file.info(pathname)
[10:26:06.794]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:06.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.794]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:06.794]                         fi[["size"]], fi[["mtime"]])
[10:26:06.794]                       stop(msg)
[10:26:06.794]                     }
[10:26:06.794]                     invisible(pathname)
[10:26:06.794]                   }
[10:26:06.794]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:06.794]                     rootPath = tempdir()) 
[10:26:06.794]                   {
[10:26:06.794]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:06.794]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:06.794]                       tmpdir = path, fileext = ".rds")
[10:26:06.794]                     save_rds(obj, file)
[10:26:06.794]                   }
[10:26:06.794]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4YXwpK/.future/immediateConditions")
[10:26:06.794]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.794]                   {
[10:26:06.794]                     inherits <- base::inherits
[10:26:06.794]                     invokeRestart <- base::invokeRestart
[10:26:06.794]                     is.null <- base::is.null
[10:26:06.794]                     muffled <- FALSE
[10:26:06.794]                     if (inherits(cond, "message")) {
[10:26:06.794]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:06.794]                       if (muffled) 
[10:26:06.794]                         invokeRestart("muffleMessage")
[10:26:06.794]                     }
[10:26:06.794]                     else if (inherits(cond, "warning")) {
[10:26:06.794]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:06.794]                       if (muffled) 
[10:26:06.794]                         invokeRestart("muffleWarning")
[10:26:06.794]                     }
[10:26:06.794]                     else if (inherits(cond, "condition")) {
[10:26:06.794]                       if (!is.null(pattern)) {
[10:26:06.794]                         computeRestarts <- base::computeRestarts
[10:26:06.794]                         grepl <- base::grepl
[10:26:06.794]                         restarts <- computeRestarts(cond)
[10:26:06.794]                         for (restart in restarts) {
[10:26:06.794]                           name <- restart$name
[10:26:06.794]                           if (is.null(name)) 
[10:26:06.794]                             next
[10:26:06.794]                           if (!grepl(pattern, name)) 
[10:26:06.794]                             next
[10:26:06.794]                           invokeRestart(restart)
[10:26:06.794]                           muffled <- TRUE
[10:26:06.794]                           break
[10:26:06.794]                         }
[10:26:06.794]                       }
[10:26:06.794]                     }
[10:26:06.794]                     invisible(muffled)
[10:26:06.794]                   }
[10:26:06.794]                   muffleCondition(cond)
[10:26:06.794]                 })
[10:26:06.794]             }))
[10:26:06.794]             future::FutureResult(value = ...future.value$value, 
[10:26:06.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.794]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.794]                     ...future.globalenv.names))
[10:26:06.794]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.794]         }, condition = base::local({
[10:26:06.794]             c <- base::c
[10:26:06.794]             inherits <- base::inherits
[10:26:06.794]             invokeRestart <- base::invokeRestart
[10:26:06.794]             length <- base::length
[10:26:06.794]             list <- base::list
[10:26:06.794]             seq.int <- base::seq.int
[10:26:06.794]             signalCondition <- base::signalCondition
[10:26:06.794]             sys.calls <- base::sys.calls
[10:26:06.794]             `[[` <- base::`[[`
[10:26:06.794]             `+` <- base::`+`
[10:26:06.794]             `<<-` <- base::`<<-`
[10:26:06.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.794]                   3L)]
[10:26:06.794]             }
[10:26:06.794]             function(cond) {
[10:26:06.794]                 is_error <- inherits(cond, "error")
[10:26:06.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.794]                   NULL)
[10:26:06.794]                 if (is_error) {
[10:26:06.794]                   sessionInformation <- function() {
[10:26:06.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.794]                       search = base::search(), system = base::Sys.info())
[10:26:06.794]                   }
[10:26:06.794]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.794]                     cond$call), session = sessionInformation(), 
[10:26:06.794]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.794]                   signalCondition(cond)
[10:26:06.794]                 }
[10:26:06.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.794]                 "immediateCondition"))) {
[10:26:06.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.794]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.794]                   if (TRUE && !signal) {
[10:26:06.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.794]                     {
[10:26:06.794]                       inherits <- base::inherits
[10:26:06.794]                       invokeRestart <- base::invokeRestart
[10:26:06.794]                       is.null <- base::is.null
[10:26:06.794]                       muffled <- FALSE
[10:26:06.794]                       if (inherits(cond, "message")) {
[10:26:06.794]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.794]                         if (muffled) 
[10:26:06.794]                           invokeRestart("muffleMessage")
[10:26:06.794]                       }
[10:26:06.794]                       else if (inherits(cond, "warning")) {
[10:26:06.794]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.794]                         if (muffled) 
[10:26:06.794]                           invokeRestart("muffleWarning")
[10:26:06.794]                       }
[10:26:06.794]                       else if (inherits(cond, "condition")) {
[10:26:06.794]                         if (!is.null(pattern)) {
[10:26:06.794]                           computeRestarts <- base::computeRestarts
[10:26:06.794]                           grepl <- base::grepl
[10:26:06.794]                           restarts <- computeRestarts(cond)
[10:26:06.794]                           for (restart in restarts) {
[10:26:06.794]                             name <- restart$name
[10:26:06.794]                             if (is.null(name)) 
[10:26:06.794]                               next
[10:26:06.794]                             if (!grepl(pattern, name)) 
[10:26:06.794]                               next
[10:26:06.794]                             invokeRestart(restart)
[10:26:06.794]                             muffled <- TRUE
[10:26:06.794]                             break
[10:26:06.794]                           }
[10:26:06.794]                         }
[10:26:06.794]                       }
[10:26:06.794]                       invisible(muffled)
[10:26:06.794]                     }
[10:26:06.794]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.794]                   }
[10:26:06.794]                 }
[10:26:06.794]                 else {
[10:26:06.794]                   if (TRUE) {
[10:26:06.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.794]                     {
[10:26:06.794]                       inherits <- base::inherits
[10:26:06.794]                       invokeRestart <- base::invokeRestart
[10:26:06.794]                       is.null <- base::is.null
[10:26:06.794]                       muffled <- FALSE
[10:26:06.794]                       if (inherits(cond, "message")) {
[10:26:06.794]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.794]                         if (muffled) 
[10:26:06.794]                           invokeRestart("muffleMessage")
[10:26:06.794]                       }
[10:26:06.794]                       else if (inherits(cond, "warning")) {
[10:26:06.794]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.794]                         if (muffled) 
[10:26:06.794]                           invokeRestart("muffleWarning")
[10:26:06.794]                       }
[10:26:06.794]                       else if (inherits(cond, "condition")) {
[10:26:06.794]                         if (!is.null(pattern)) {
[10:26:06.794]                           computeRestarts <- base::computeRestarts
[10:26:06.794]                           grepl <- base::grepl
[10:26:06.794]                           restarts <- computeRestarts(cond)
[10:26:06.794]                           for (restart in restarts) {
[10:26:06.794]                             name <- restart$name
[10:26:06.794]                             if (is.null(name)) 
[10:26:06.794]                               next
[10:26:06.794]                             if (!grepl(pattern, name)) 
[10:26:06.794]                               next
[10:26:06.794]                             invokeRestart(restart)
[10:26:06.794]                             muffled <- TRUE
[10:26:06.794]                             break
[10:26:06.794]                           }
[10:26:06.794]                         }
[10:26:06.794]                       }
[10:26:06.794]                       invisible(muffled)
[10:26:06.794]                     }
[10:26:06.794]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.794]                   }
[10:26:06.794]                 }
[10:26:06.794]             }
[10:26:06.794]         }))
[10:26:06.794]     }, error = function(ex) {
[10:26:06.794]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.794]                 ...future.rng), started = ...future.startTime, 
[10:26:06.794]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.794]             version = "1.8"), class = "FutureResult")
[10:26:06.794]     }, finally = {
[10:26:06.794]         if (!identical(...future.workdir, getwd())) 
[10:26:06.794]             setwd(...future.workdir)
[10:26:06.794]         {
[10:26:06.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.794]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.794]             }
[10:26:06.794]             base::options(...future.oldOptions)
[10:26:06.794]             if (.Platform$OS.type == "windows") {
[10:26:06.794]                 old_names <- names(...future.oldEnvVars)
[10:26:06.794]                 envs <- base::Sys.getenv()
[10:26:06.794]                 names <- names(envs)
[10:26:06.794]                 common <- intersect(names, old_names)
[10:26:06.794]                 added <- setdiff(names, old_names)
[10:26:06.794]                 removed <- setdiff(old_names, names)
[10:26:06.794]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.794]                   envs[common]]
[10:26:06.794]                 NAMES <- toupper(changed)
[10:26:06.794]                 args <- list()
[10:26:06.794]                 for (kk in seq_along(NAMES)) {
[10:26:06.794]                   name <- changed[[kk]]
[10:26:06.794]                   NAME <- NAMES[[kk]]
[10:26:06.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.794]                     next
[10:26:06.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.794]                 }
[10:26:06.794]                 NAMES <- toupper(added)
[10:26:06.794]                 for (kk in seq_along(NAMES)) {
[10:26:06.794]                   name <- added[[kk]]
[10:26:06.794]                   NAME <- NAMES[[kk]]
[10:26:06.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.794]                     next
[10:26:06.794]                   args[[name]] <- ""
[10:26:06.794]                 }
[10:26:06.794]                 NAMES <- toupper(removed)
[10:26:06.794]                 for (kk in seq_along(NAMES)) {
[10:26:06.794]                   name <- removed[[kk]]
[10:26:06.794]                   NAME <- NAMES[[kk]]
[10:26:06.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.794]                     next
[10:26:06.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.794]                 }
[10:26:06.794]                 if (length(args) > 0) 
[10:26:06.794]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.794]             }
[10:26:06.794]             else {
[10:26:06.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.794]             }
[10:26:06.794]             {
[10:26:06.794]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.794]                   0L) {
[10:26:06.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.794]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.794]                   base::options(opts)
[10:26:06.794]                 }
[10:26:06.794]                 {
[10:26:06.794]                   {
[10:26:06.794]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:06.794]                     NULL
[10:26:06.794]                   }
[10:26:06.794]                   options(future.plan = NULL)
[10:26:06.794]                   if (is.na(NA_character_)) 
[10:26:06.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.794]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:06.794]                     envir = parent.frame()) 
[10:26:06.794]                   {
[10:26:06.794]                     default_workers <- missing(workers)
[10:26:06.794]                     if (is.function(workers)) 
[10:26:06.794]                       workers <- workers()
[10:26:06.794]                     workers <- structure(as.integer(workers), 
[10:26:06.794]                       class = class(workers))
[10:26:06.794]                     stop_if_not(is.finite(workers), workers >= 
[10:26:06.794]                       1L)
[10:26:06.794]                     if ((workers == 1L && !inherits(workers, 
[10:26:06.794]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:06.794]                       if (default_workers) 
[10:26:06.794]                         supportsMulticore(warn = TRUE)
[10:26:06.794]                       return(sequential(..., envir = envir))
[10:26:06.794]                     }
[10:26:06.794]                     oopts <- options(mc.cores = workers)
[10:26:06.794]                     on.exit(options(oopts))
[10:26:06.794]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:06.794]                       envir = envir)
[10:26:06.794]                     if (!future$lazy) 
[10:26:06.794]                       future <- run(future)
[10:26:06.794]                     invisible(future)
[10:26:06.794]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.794]                 }
[10:26:06.794]             }
[10:26:06.794]         }
[10:26:06.794]     })
[10:26:06.794]     if (TRUE) {
[10:26:06.794]         base::sink(type = "output", split = FALSE)
[10:26:06.794]         if (TRUE) {
[10:26:06.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.794]         }
[10:26:06.794]         else {
[10:26:06.794]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.794]         }
[10:26:06.794]         base::close(...future.stdout)
[10:26:06.794]         ...future.stdout <- NULL
[10:26:06.794]     }
[10:26:06.794]     ...future.result$conditions <- ...future.conditions
[10:26:06.794]     ...future.result$finished <- base::Sys.time()
[10:26:06.794]     ...future.result
[10:26:06.794] }
[10:26:06.796] assign_globals() ...
[10:26:06.797] List of 1
[10:26:06.797]  $ x: list()
[10:26:06.797]  - attr(*, "where")=List of 1
[10:26:06.797]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.797]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.797]  - attr(*, "resolved")= logi TRUE
[10:26:06.797]  - attr(*, "total_size")= num 0
[10:26:06.797]  - attr(*, "already-done")= logi TRUE
[10:26:06.799] - copied ‘x’ to environment
[10:26:06.800] assign_globals() ... done
[10:26:06.800] requestCore(): workers = 2
[10:26:06.801] MulticoreFuture started
[10:26:06.802] - Launch lazy future ... done
[10:26:06.802] run() for ‘MulticoreFuture’ ... done
[10:26:06.802] result() for MulticoreFuture ...
[10:26:06.803] plan(): Setting new future strategy stack:
[10:26:06.803] List of future strategies:
[10:26:06.803] 1. sequential:
[10:26:06.803]    - args: function (..., envir = parent.frame())
[10:26:06.803]    - tweaked: FALSE
[10:26:06.803]    - call: NULL
[10:26:06.804] plan(): nbrOfWorkers() = 1
[10:26:06.806] plan(): Setting new future strategy stack:
[10:26:06.806] List of future strategies:
[10:26:06.806] 1. multicore:
[10:26:06.806]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.806]    - tweaked: FALSE
[10:26:06.806]    - call: plan(strategy)
[10:26:06.811] plan(): nbrOfWorkers() = 2
[10:26:06.811] result() for MulticoreFuture ...
[10:26:06.812] result() for MulticoreFuture ... done
[10:26:06.812] result() for MulticoreFuture ... done
[10:26:06.812] result() for MulticoreFuture ...
[10:26:06.812] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.812] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.813] Searching for globals...
[10:26:06.815] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:06.816] Searching for globals ... DONE
[10:26:06.816] Resolving globals: TRUE
[10:26:06.816] Resolving any globals that are futures ...
[10:26:06.816] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:06.816] Resolving any globals that are futures ... DONE
[10:26:06.817] Resolving futures part of globals (recursively) ...
[10:26:06.817] resolve() on list ...
[10:26:06.817]  recursive: 99
[10:26:06.817]  length: 1
[10:26:06.817]  elements: ‘x’
[10:26:06.817]  length: 0 (resolved future 1)
[10:26:06.818] resolve() on list ... DONE
[10:26:06.818] - globals: [1] ‘x’
[10:26:06.818] Resolving futures part of globals (recursively) ... DONE
[10:26:06.818] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.818] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.821] - globals: [1] ‘x’
[10:26:06.821] 
[10:26:06.821] getGlobalsAndPackages() ... DONE
[10:26:06.822] run() for ‘Future’ ...
[10:26:06.822] - state: ‘created’
[10:26:06.822] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:06.826] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:06.826] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:06.826]   - Field: ‘label’
[10:26:06.826]   - Field: ‘local’
[10:26:06.827]   - Field: ‘owner’
[10:26:06.827]   - Field: ‘envir’
[10:26:06.827]   - Field: ‘workers’
[10:26:06.827]   - Field: ‘packages’
[10:26:06.827]   - Field: ‘gc’
[10:26:06.827]   - Field: ‘job’
[10:26:06.827]   - Field: ‘conditions’
[10:26:06.827]   - Field: ‘expr’
[10:26:06.828]   - Field: ‘uuid’
[10:26:06.828]   - Field: ‘seed’
[10:26:06.828]   - Field: ‘version’
[10:26:06.828]   - Field: ‘result’
[10:26:06.828]   - Field: ‘asynchronous’
[10:26:06.828]   - Field: ‘calls’
[10:26:06.828]   - Field: ‘globals’
[10:26:06.828]   - Field: ‘stdout’
[10:26:06.828]   - Field: ‘earlySignal’
[10:26:06.829]   - Field: ‘lazy’
[10:26:06.829]   - Field: ‘state’
[10:26:06.829] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:06.829] - Launch lazy future ...
[10:26:06.829] Packages needed by the future expression (n = 0): <none>
[10:26:06.829] Packages needed by future strategies (n = 0): <none>
[10:26:06.830] {
[10:26:06.830]     {
[10:26:06.830]         {
[10:26:06.830]             ...future.startTime <- base::Sys.time()
[10:26:06.830]             {
[10:26:06.830]                 {
[10:26:06.830]                   {
[10:26:06.830]                     {
[10:26:06.830]                       base::local({
[10:26:06.830]                         has_future <- base::requireNamespace("future", 
[10:26:06.830]                           quietly = TRUE)
[10:26:06.830]                         if (has_future) {
[10:26:06.830]                           ns <- base::getNamespace("future")
[10:26:06.830]                           version <- ns[[".package"]][["version"]]
[10:26:06.830]                           if (is.null(version)) 
[10:26:06.830]                             version <- utils::packageVersion("future")
[10:26:06.830]                         }
[10:26:06.830]                         else {
[10:26:06.830]                           version <- NULL
[10:26:06.830]                         }
[10:26:06.830]                         if (!has_future || version < "1.8.0") {
[10:26:06.830]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.830]                             "", base::R.version$version.string), 
[10:26:06.830]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:06.830]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.830]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.830]                               "release", "version")], collapse = " "), 
[10:26:06.830]                             hostname = base::Sys.info()[["nodename"]])
[10:26:06.830]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.830]                             info)
[10:26:06.830]                           info <- base::paste(info, collapse = "; ")
[10:26:06.830]                           if (!has_future) {
[10:26:06.830]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.830]                               info)
[10:26:06.830]                           }
[10:26:06.830]                           else {
[10:26:06.830]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.830]                               info, version)
[10:26:06.830]                           }
[10:26:06.830]                           base::stop(msg)
[10:26:06.830]                         }
[10:26:06.830]                       })
[10:26:06.830]                     }
[10:26:06.830]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:06.830]                     base::options(mc.cores = 1L)
[10:26:06.830]                   }
[10:26:06.830]                   options(future.plan = NULL)
[10:26:06.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.830]                 }
[10:26:06.830]                 ...future.workdir <- getwd()
[10:26:06.830]             }
[10:26:06.830]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.830]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.830]         }
[10:26:06.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.830]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.830]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.830]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.830]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.830]             base::names(...future.oldOptions))
[10:26:06.830]     }
[10:26:06.830]     if (FALSE) {
[10:26:06.830]     }
[10:26:06.830]     else {
[10:26:06.830]         if (TRUE) {
[10:26:06.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.830]                 open = "w")
[10:26:06.830]         }
[10:26:06.830]         else {
[10:26:06.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.830]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.830]         }
[10:26:06.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.830]             base::sink(type = "output", split = FALSE)
[10:26:06.830]             base::close(...future.stdout)
[10:26:06.830]         }, add = TRUE)
[10:26:06.830]     }
[10:26:06.830]     ...future.frame <- base::sys.nframe()
[10:26:06.830]     ...future.conditions <- base::list()
[10:26:06.830]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.830]     if (FALSE) {
[10:26:06.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.830]     }
[10:26:06.830]     ...future.result <- base::tryCatch({
[10:26:06.830]         base::withCallingHandlers({
[10:26:06.830]             ...future.value <- base::withVisible(base::local({
[10:26:06.830]                 withCallingHandlers({
[10:26:06.830]                   {
[10:26:06.830]                     x["a"] <- list(1)
[10:26:06.830]                     x
[10:26:06.830]                   }
[10:26:06.830]                 }, immediateCondition = function(cond) {
[10:26:06.830]                   save_rds <- function (object, pathname, ...) 
[10:26:06.830]                   {
[10:26:06.830]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:06.830]                     if (file_test("-f", pathname_tmp)) {
[10:26:06.830]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.830]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:06.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.830]                         fi_tmp[["mtime"]])
[10:26:06.830]                     }
[10:26:06.830]                     tryCatch({
[10:26:06.830]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:06.830]                     }, error = function(ex) {
[10:26:06.830]                       msg <- conditionMessage(ex)
[10:26:06.830]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.830]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:06.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.830]                         fi_tmp[["mtime"]], msg)
[10:26:06.830]                       ex$message <- msg
[10:26:06.830]                       stop(ex)
[10:26:06.830]                     })
[10:26:06.830]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:06.830]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:06.830]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:06.830]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.830]                       fi <- file.info(pathname)
[10:26:06.830]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:06.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.830]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:06.830]                         fi[["size"]], fi[["mtime"]])
[10:26:06.830]                       stop(msg)
[10:26:06.830]                     }
[10:26:06.830]                     invisible(pathname)
[10:26:06.830]                   }
[10:26:06.830]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:06.830]                     rootPath = tempdir()) 
[10:26:06.830]                   {
[10:26:06.830]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:06.830]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:06.830]                       tmpdir = path, fileext = ".rds")
[10:26:06.830]                     save_rds(obj, file)
[10:26:06.830]                   }
[10:26:06.830]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4YXwpK/.future/immediateConditions")
[10:26:06.830]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.830]                   {
[10:26:06.830]                     inherits <- base::inherits
[10:26:06.830]                     invokeRestart <- base::invokeRestart
[10:26:06.830]                     is.null <- base::is.null
[10:26:06.830]                     muffled <- FALSE
[10:26:06.830]                     if (inherits(cond, "message")) {
[10:26:06.830]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:06.830]                       if (muffled) 
[10:26:06.830]                         invokeRestart("muffleMessage")
[10:26:06.830]                     }
[10:26:06.830]                     else if (inherits(cond, "warning")) {
[10:26:06.830]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:06.830]                       if (muffled) 
[10:26:06.830]                         invokeRestart("muffleWarning")
[10:26:06.830]                     }
[10:26:06.830]                     else if (inherits(cond, "condition")) {
[10:26:06.830]                       if (!is.null(pattern)) {
[10:26:06.830]                         computeRestarts <- base::computeRestarts
[10:26:06.830]                         grepl <- base::grepl
[10:26:06.830]                         restarts <- computeRestarts(cond)
[10:26:06.830]                         for (restart in restarts) {
[10:26:06.830]                           name <- restart$name
[10:26:06.830]                           if (is.null(name)) 
[10:26:06.830]                             next
[10:26:06.830]                           if (!grepl(pattern, name)) 
[10:26:06.830]                             next
[10:26:06.830]                           invokeRestart(restart)
[10:26:06.830]                           muffled <- TRUE
[10:26:06.830]                           break
[10:26:06.830]                         }
[10:26:06.830]                       }
[10:26:06.830]                     }
[10:26:06.830]                     invisible(muffled)
[10:26:06.830]                   }
[10:26:06.830]                   muffleCondition(cond)
[10:26:06.830]                 })
[10:26:06.830]             }))
[10:26:06.830]             future::FutureResult(value = ...future.value$value, 
[10:26:06.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.830]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.830]                     ...future.globalenv.names))
[10:26:06.830]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.830]         }, condition = base::local({
[10:26:06.830]             c <- base::c
[10:26:06.830]             inherits <- base::inherits
[10:26:06.830]             invokeRestart <- base::invokeRestart
[10:26:06.830]             length <- base::length
[10:26:06.830]             list <- base::list
[10:26:06.830]             seq.int <- base::seq.int
[10:26:06.830]             signalCondition <- base::signalCondition
[10:26:06.830]             sys.calls <- base::sys.calls
[10:26:06.830]             `[[` <- base::`[[`
[10:26:06.830]             `+` <- base::`+`
[10:26:06.830]             `<<-` <- base::`<<-`
[10:26:06.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.830]                   3L)]
[10:26:06.830]             }
[10:26:06.830]             function(cond) {
[10:26:06.830]                 is_error <- inherits(cond, "error")
[10:26:06.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.830]                   NULL)
[10:26:06.830]                 if (is_error) {
[10:26:06.830]                   sessionInformation <- function() {
[10:26:06.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.830]                       search = base::search(), system = base::Sys.info())
[10:26:06.830]                   }
[10:26:06.830]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.830]                     cond$call), session = sessionInformation(), 
[10:26:06.830]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.830]                   signalCondition(cond)
[10:26:06.830]                 }
[10:26:06.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.830]                 "immediateCondition"))) {
[10:26:06.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.830]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.830]                   if (TRUE && !signal) {
[10:26:06.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.830]                     {
[10:26:06.830]                       inherits <- base::inherits
[10:26:06.830]                       invokeRestart <- base::invokeRestart
[10:26:06.830]                       is.null <- base::is.null
[10:26:06.830]                       muffled <- FALSE
[10:26:06.830]                       if (inherits(cond, "message")) {
[10:26:06.830]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.830]                         if (muffled) 
[10:26:06.830]                           invokeRestart("muffleMessage")
[10:26:06.830]                       }
[10:26:06.830]                       else if (inherits(cond, "warning")) {
[10:26:06.830]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.830]                         if (muffled) 
[10:26:06.830]                           invokeRestart("muffleWarning")
[10:26:06.830]                       }
[10:26:06.830]                       else if (inherits(cond, "condition")) {
[10:26:06.830]                         if (!is.null(pattern)) {
[10:26:06.830]                           computeRestarts <- base::computeRestarts
[10:26:06.830]                           grepl <- base::grepl
[10:26:06.830]                           restarts <- computeRestarts(cond)
[10:26:06.830]                           for (restart in restarts) {
[10:26:06.830]                             name <- restart$name
[10:26:06.830]                             if (is.null(name)) 
[10:26:06.830]                               next
[10:26:06.830]                             if (!grepl(pattern, name)) 
[10:26:06.830]                               next
[10:26:06.830]                             invokeRestart(restart)
[10:26:06.830]                             muffled <- TRUE
[10:26:06.830]                             break
[10:26:06.830]                           }
[10:26:06.830]                         }
[10:26:06.830]                       }
[10:26:06.830]                       invisible(muffled)
[10:26:06.830]                     }
[10:26:06.830]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.830]                   }
[10:26:06.830]                 }
[10:26:06.830]                 else {
[10:26:06.830]                   if (TRUE) {
[10:26:06.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.830]                     {
[10:26:06.830]                       inherits <- base::inherits
[10:26:06.830]                       invokeRestart <- base::invokeRestart
[10:26:06.830]                       is.null <- base::is.null
[10:26:06.830]                       muffled <- FALSE
[10:26:06.830]                       if (inherits(cond, "message")) {
[10:26:06.830]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.830]                         if (muffled) 
[10:26:06.830]                           invokeRestart("muffleMessage")
[10:26:06.830]                       }
[10:26:06.830]                       else if (inherits(cond, "warning")) {
[10:26:06.830]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.830]                         if (muffled) 
[10:26:06.830]                           invokeRestart("muffleWarning")
[10:26:06.830]                       }
[10:26:06.830]                       else if (inherits(cond, "condition")) {
[10:26:06.830]                         if (!is.null(pattern)) {
[10:26:06.830]                           computeRestarts <- base::computeRestarts
[10:26:06.830]                           grepl <- base::grepl
[10:26:06.830]                           restarts <- computeRestarts(cond)
[10:26:06.830]                           for (restart in restarts) {
[10:26:06.830]                             name <- restart$name
[10:26:06.830]                             if (is.null(name)) 
[10:26:06.830]                               next
[10:26:06.830]                             if (!grepl(pattern, name)) 
[10:26:06.830]                               next
[10:26:06.830]                             invokeRestart(restart)
[10:26:06.830]                             muffled <- TRUE
[10:26:06.830]                             break
[10:26:06.830]                           }
[10:26:06.830]                         }
[10:26:06.830]                       }
[10:26:06.830]                       invisible(muffled)
[10:26:06.830]                     }
[10:26:06.830]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.830]                   }
[10:26:06.830]                 }
[10:26:06.830]             }
[10:26:06.830]         }))
[10:26:06.830]     }, error = function(ex) {
[10:26:06.830]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.830]                 ...future.rng), started = ...future.startTime, 
[10:26:06.830]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.830]             version = "1.8"), class = "FutureResult")
[10:26:06.830]     }, finally = {
[10:26:06.830]         if (!identical(...future.workdir, getwd())) 
[10:26:06.830]             setwd(...future.workdir)
[10:26:06.830]         {
[10:26:06.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.830]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.830]             }
[10:26:06.830]             base::options(...future.oldOptions)
[10:26:06.830]             if (.Platform$OS.type == "windows") {
[10:26:06.830]                 old_names <- names(...future.oldEnvVars)
[10:26:06.830]                 envs <- base::Sys.getenv()
[10:26:06.830]                 names <- names(envs)
[10:26:06.830]                 common <- intersect(names, old_names)
[10:26:06.830]                 added <- setdiff(names, old_names)
[10:26:06.830]                 removed <- setdiff(old_names, names)
[10:26:06.830]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.830]                   envs[common]]
[10:26:06.830]                 NAMES <- toupper(changed)
[10:26:06.830]                 args <- list()
[10:26:06.830]                 for (kk in seq_along(NAMES)) {
[10:26:06.830]                   name <- changed[[kk]]
[10:26:06.830]                   NAME <- NAMES[[kk]]
[10:26:06.830]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.830]                     next
[10:26:06.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.830]                 }
[10:26:06.830]                 NAMES <- toupper(added)
[10:26:06.830]                 for (kk in seq_along(NAMES)) {
[10:26:06.830]                   name <- added[[kk]]
[10:26:06.830]                   NAME <- NAMES[[kk]]
[10:26:06.830]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.830]                     next
[10:26:06.830]                   args[[name]] <- ""
[10:26:06.830]                 }
[10:26:06.830]                 NAMES <- toupper(removed)
[10:26:06.830]                 for (kk in seq_along(NAMES)) {
[10:26:06.830]                   name <- removed[[kk]]
[10:26:06.830]                   NAME <- NAMES[[kk]]
[10:26:06.830]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.830]                     next
[10:26:06.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.830]                 }
[10:26:06.830]                 if (length(args) > 0) 
[10:26:06.830]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.830]             }
[10:26:06.830]             else {
[10:26:06.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.830]             }
[10:26:06.830]             {
[10:26:06.830]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.830]                   0L) {
[10:26:06.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.830]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.830]                   base::options(opts)
[10:26:06.830]                 }
[10:26:06.830]                 {
[10:26:06.830]                   {
[10:26:06.830]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:06.830]                     NULL
[10:26:06.830]                   }
[10:26:06.830]                   options(future.plan = NULL)
[10:26:06.830]                   if (is.na(NA_character_)) 
[10:26:06.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.830]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:06.830]                     envir = parent.frame()) 
[10:26:06.830]                   {
[10:26:06.830]                     default_workers <- missing(workers)
[10:26:06.830]                     if (is.function(workers)) 
[10:26:06.830]                       workers <- workers()
[10:26:06.830]                     workers <- structure(as.integer(workers), 
[10:26:06.830]                       class = class(workers))
[10:26:06.830]                     stop_if_not(is.finite(workers), workers >= 
[10:26:06.830]                       1L)
[10:26:06.830]                     if ((workers == 1L && !inherits(workers, 
[10:26:06.830]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:06.830]                       if (default_workers) 
[10:26:06.830]                         supportsMulticore(warn = TRUE)
[10:26:06.830]                       return(sequential(..., envir = envir))
[10:26:06.830]                     }
[10:26:06.830]                     oopts <- options(mc.cores = workers)
[10:26:06.830]                     on.exit(options(oopts))
[10:26:06.830]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:06.830]                       envir = envir)
[10:26:06.830]                     if (!future$lazy) 
[10:26:06.830]                       future <- run(future)
[10:26:06.830]                     invisible(future)
[10:26:06.830]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.830]                 }
[10:26:06.830]             }
[10:26:06.830]         }
[10:26:06.830]     })
[10:26:06.830]     if (TRUE) {
[10:26:06.830]         base::sink(type = "output", split = FALSE)
[10:26:06.830]         if (TRUE) {
[10:26:06.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.830]         }
[10:26:06.830]         else {
[10:26:06.830]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.830]         }
[10:26:06.830]         base::close(...future.stdout)
[10:26:06.830]         ...future.stdout <- NULL
[10:26:06.830]     }
[10:26:06.830]     ...future.result$conditions <- ...future.conditions
[10:26:06.830]     ...future.result$finished <- base::Sys.time()
[10:26:06.830]     ...future.result
[10:26:06.830] }
[10:26:06.832] assign_globals() ...
[10:26:06.833] List of 1
[10:26:06.833]  $ x: list()
[10:26:06.833]  - attr(*, "where")=List of 1
[10:26:06.833]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.833]  - attr(*, "resolved")= logi TRUE
[10:26:06.833]  - attr(*, "total_size")= num 0
[10:26:06.833]  - attr(*, "already-done")= logi TRUE
[10:26:06.836] - copied ‘x’ to environment
[10:26:06.836] assign_globals() ... done
[10:26:06.836] requestCore(): workers = 2
[10:26:06.838] MulticoreFuture started
[10:26:06.838] - Launch lazy future ... done
[10:26:06.838] run() for ‘MulticoreFuture’ ... done
[10:26:06.838] result() for MulticoreFuture ...
[10:26:06.839] plan(): Setting new future strategy stack:
[10:26:06.839] List of future strategies:
[10:26:06.839] 1. sequential:
[10:26:06.839]    - args: function (..., envir = parent.frame())
[10:26:06.839]    - tweaked: FALSE
[10:26:06.839]    - call: NULL
[10:26:06.840] plan(): nbrOfWorkers() = 1
[10:26:06.842] plan(): Setting new future strategy stack:
[10:26:06.842] List of future strategies:
[10:26:06.842] 1. multicore:
[10:26:06.842]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.842]    - tweaked: FALSE
[10:26:06.842]    - call: plan(strategy)
[10:26:06.847] plan(): nbrOfWorkers() = 2
[10:26:06.848] result() for MulticoreFuture ...
[10:26:06.848] result() for MulticoreFuture ... done
[10:26:06.848] result() for MulticoreFuture ... done
[10:26:06.848] result() for MulticoreFuture ...
[10:26:06.849] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.849] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.850] Searching for globals...
[10:26:06.852] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:06.853] Searching for globals ... DONE
[10:26:06.853] Resolving globals: TRUE
[10:26:06.853] Resolving any globals that are futures ...
[10:26:06.853] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:06.853] Resolving any globals that are futures ... DONE
[10:26:06.854] Resolving futures part of globals (recursively) ...
[10:26:06.854] resolve() on list ...
[10:26:06.854]  recursive: 99
[10:26:06.854]  length: 1
[10:26:06.854]  elements: ‘x’
[10:26:06.854]  length: 0 (resolved future 1)
[10:26:06.855] resolve() on list ... DONE
[10:26:06.855] - globals: [1] ‘x’
[10:26:06.855] Resolving futures part of globals (recursively) ... DONE
[10:26:06.855] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:06.855] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:06.856] - globals: [1] ‘x’
[10:26:06.856] 
[10:26:06.856] getGlobalsAndPackages() ... DONE
[10:26:06.856] run() for ‘Future’ ...
[10:26:06.856] - state: ‘created’
[10:26:06.856] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:06.860] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:06.861] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:06.861]   - Field: ‘label’
[10:26:06.861]   - Field: ‘local’
[10:26:06.861]   - Field: ‘owner’
[10:26:06.861]   - Field: ‘envir’
[10:26:06.861]   - Field: ‘workers’
[10:26:06.861]   - Field: ‘packages’
[10:26:06.862]   - Field: ‘gc’
[10:26:06.862]   - Field: ‘job’
[10:26:06.862]   - Field: ‘conditions’
[10:26:06.862]   - Field: ‘expr’
[10:26:06.862]   - Field: ‘uuid’
[10:26:06.862]   - Field: ‘seed’
[10:26:06.862]   - Field: ‘version’
[10:26:06.862]   - Field: ‘result’
[10:26:06.862]   - Field: ‘asynchronous’
[10:26:06.863]   - Field: ‘calls’
[10:26:06.863]   - Field: ‘globals’
[10:26:06.863]   - Field: ‘stdout’
[10:26:06.863]   - Field: ‘earlySignal’
[10:26:06.863]   - Field: ‘lazy’
[10:26:06.863]   - Field: ‘state’
[10:26:06.863] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:06.863] - Launch lazy future ...
[10:26:06.864] Packages needed by the future expression (n = 0): <none>
[10:26:06.864] Packages needed by future strategies (n = 0): <none>
[10:26:06.864] {
[10:26:06.864]     {
[10:26:06.864]         {
[10:26:06.864]             ...future.startTime <- base::Sys.time()
[10:26:06.864]             {
[10:26:06.864]                 {
[10:26:06.864]                   {
[10:26:06.864]                     {
[10:26:06.864]                       base::local({
[10:26:06.864]                         has_future <- base::requireNamespace("future", 
[10:26:06.864]                           quietly = TRUE)
[10:26:06.864]                         if (has_future) {
[10:26:06.864]                           ns <- base::getNamespace("future")
[10:26:06.864]                           version <- ns[[".package"]][["version"]]
[10:26:06.864]                           if (is.null(version)) 
[10:26:06.864]                             version <- utils::packageVersion("future")
[10:26:06.864]                         }
[10:26:06.864]                         else {
[10:26:06.864]                           version <- NULL
[10:26:06.864]                         }
[10:26:06.864]                         if (!has_future || version < "1.8.0") {
[10:26:06.864]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.864]                             "", base::R.version$version.string), 
[10:26:06.864]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:06.864]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.864]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.864]                               "release", "version")], collapse = " "), 
[10:26:06.864]                             hostname = base::Sys.info()[["nodename"]])
[10:26:06.864]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.864]                             info)
[10:26:06.864]                           info <- base::paste(info, collapse = "; ")
[10:26:06.864]                           if (!has_future) {
[10:26:06.864]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.864]                               info)
[10:26:06.864]                           }
[10:26:06.864]                           else {
[10:26:06.864]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.864]                               info, version)
[10:26:06.864]                           }
[10:26:06.864]                           base::stop(msg)
[10:26:06.864]                         }
[10:26:06.864]                       })
[10:26:06.864]                     }
[10:26:06.864]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:06.864]                     base::options(mc.cores = 1L)
[10:26:06.864]                   }
[10:26:06.864]                   options(future.plan = NULL)
[10:26:06.864]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.864]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.864]                 }
[10:26:06.864]                 ...future.workdir <- getwd()
[10:26:06.864]             }
[10:26:06.864]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.864]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.864]         }
[10:26:06.864]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.864]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.864]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.864]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.864]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.864]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.864]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.864]             base::names(...future.oldOptions))
[10:26:06.864]     }
[10:26:06.864]     if (FALSE) {
[10:26:06.864]     }
[10:26:06.864]     else {
[10:26:06.864]         if (TRUE) {
[10:26:06.864]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.864]                 open = "w")
[10:26:06.864]         }
[10:26:06.864]         else {
[10:26:06.864]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.864]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.864]         }
[10:26:06.864]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.864]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.864]             base::sink(type = "output", split = FALSE)
[10:26:06.864]             base::close(...future.stdout)
[10:26:06.864]         }, add = TRUE)
[10:26:06.864]     }
[10:26:06.864]     ...future.frame <- base::sys.nframe()
[10:26:06.864]     ...future.conditions <- base::list()
[10:26:06.864]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.864]     if (FALSE) {
[10:26:06.864]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.864]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.864]     }
[10:26:06.864]     ...future.result <- base::tryCatch({
[10:26:06.864]         base::withCallingHandlers({
[10:26:06.864]             ...future.value <- base::withVisible(base::local({
[10:26:06.864]                 withCallingHandlers({
[10:26:06.864]                   {
[10:26:06.864]                     x["a"] <- list(1)
[10:26:06.864]                     x
[10:26:06.864]                   }
[10:26:06.864]                 }, immediateCondition = function(cond) {
[10:26:06.864]                   save_rds <- function (object, pathname, ...) 
[10:26:06.864]                   {
[10:26:06.864]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:06.864]                     if (file_test("-f", pathname_tmp)) {
[10:26:06.864]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.864]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:06.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.864]                         fi_tmp[["mtime"]])
[10:26:06.864]                     }
[10:26:06.864]                     tryCatch({
[10:26:06.864]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:06.864]                     }, error = function(ex) {
[10:26:06.864]                       msg <- conditionMessage(ex)
[10:26:06.864]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.864]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:06.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.864]                         fi_tmp[["mtime"]], msg)
[10:26:06.864]                       ex$message <- msg
[10:26:06.864]                       stop(ex)
[10:26:06.864]                     })
[10:26:06.864]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:06.864]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:06.864]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:06.864]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.864]                       fi <- file.info(pathname)
[10:26:06.864]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:06.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.864]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:06.864]                         fi[["size"]], fi[["mtime"]])
[10:26:06.864]                       stop(msg)
[10:26:06.864]                     }
[10:26:06.864]                     invisible(pathname)
[10:26:06.864]                   }
[10:26:06.864]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:06.864]                     rootPath = tempdir()) 
[10:26:06.864]                   {
[10:26:06.864]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:06.864]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:06.864]                       tmpdir = path, fileext = ".rds")
[10:26:06.864]                     save_rds(obj, file)
[10:26:06.864]                   }
[10:26:06.864]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4YXwpK/.future/immediateConditions")
[10:26:06.864]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.864]                   {
[10:26:06.864]                     inherits <- base::inherits
[10:26:06.864]                     invokeRestart <- base::invokeRestart
[10:26:06.864]                     is.null <- base::is.null
[10:26:06.864]                     muffled <- FALSE
[10:26:06.864]                     if (inherits(cond, "message")) {
[10:26:06.864]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:06.864]                       if (muffled) 
[10:26:06.864]                         invokeRestart("muffleMessage")
[10:26:06.864]                     }
[10:26:06.864]                     else if (inherits(cond, "warning")) {
[10:26:06.864]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:06.864]                       if (muffled) 
[10:26:06.864]                         invokeRestart("muffleWarning")
[10:26:06.864]                     }
[10:26:06.864]                     else if (inherits(cond, "condition")) {
[10:26:06.864]                       if (!is.null(pattern)) {
[10:26:06.864]                         computeRestarts <- base::computeRestarts
[10:26:06.864]                         grepl <- base::grepl
[10:26:06.864]                         restarts <- computeRestarts(cond)
[10:26:06.864]                         for (restart in restarts) {
[10:26:06.864]                           name <- restart$name
[10:26:06.864]                           if (is.null(name)) 
[10:26:06.864]                             next
[10:26:06.864]                           if (!grepl(pattern, name)) 
[10:26:06.864]                             next
[10:26:06.864]                           invokeRestart(restart)
[10:26:06.864]                           muffled <- TRUE
[10:26:06.864]                           break
[10:26:06.864]                         }
[10:26:06.864]                       }
[10:26:06.864]                     }
[10:26:06.864]                     invisible(muffled)
[10:26:06.864]                   }
[10:26:06.864]                   muffleCondition(cond)
[10:26:06.864]                 })
[10:26:06.864]             }))
[10:26:06.864]             future::FutureResult(value = ...future.value$value, 
[10:26:06.864]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.864]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.864]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.864]                     ...future.globalenv.names))
[10:26:06.864]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.864]         }, condition = base::local({
[10:26:06.864]             c <- base::c
[10:26:06.864]             inherits <- base::inherits
[10:26:06.864]             invokeRestart <- base::invokeRestart
[10:26:06.864]             length <- base::length
[10:26:06.864]             list <- base::list
[10:26:06.864]             seq.int <- base::seq.int
[10:26:06.864]             signalCondition <- base::signalCondition
[10:26:06.864]             sys.calls <- base::sys.calls
[10:26:06.864]             `[[` <- base::`[[`
[10:26:06.864]             `+` <- base::`+`
[10:26:06.864]             `<<-` <- base::`<<-`
[10:26:06.864]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.864]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.864]                   3L)]
[10:26:06.864]             }
[10:26:06.864]             function(cond) {
[10:26:06.864]                 is_error <- inherits(cond, "error")
[10:26:06.864]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.864]                   NULL)
[10:26:06.864]                 if (is_error) {
[10:26:06.864]                   sessionInformation <- function() {
[10:26:06.864]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.864]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.864]                       search = base::search(), system = base::Sys.info())
[10:26:06.864]                   }
[10:26:06.864]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.864]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.864]                     cond$call), session = sessionInformation(), 
[10:26:06.864]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.864]                   signalCondition(cond)
[10:26:06.864]                 }
[10:26:06.864]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.864]                 "immediateCondition"))) {
[10:26:06.864]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.864]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.864]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.864]                   if (TRUE && !signal) {
[10:26:06.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.864]                     {
[10:26:06.864]                       inherits <- base::inherits
[10:26:06.864]                       invokeRestart <- base::invokeRestart
[10:26:06.864]                       is.null <- base::is.null
[10:26:06.864]                       muffled <- FALSE
[10:26:06.864]                       if (inherits(cond, "message")) {
[10:26:06.864]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.864]                         if (muffled) 
[10:26:06.864]                           invokeRestart("muffleMessage")
[10:26:06.864]                       }
[10:26:06.864]                       else if (inherits(cond, "warning")) {
[10:26:06.864]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.864]                         if (muffled) 
[10:26:06.864]                           invokeRestart("muffleWarning")
[10:26:06.864]                       }
[10:26:06.864]                       else if (inherits(cond, "condition")) {
[10:26:06.864]                         if (!is.null(pattern)) {
[10:26:06.864]                           computeRestarts <- base::computeRestarts
[10:26:06.864]                           grepl <- base::grepl
[10:26:06.864]                           restarts <- computeRestarts(cond)
[10:26:06.864]                           for (restart in restarts) {
[10:26:06.864]                             name <- restart$name
[10:26:06.864]                             if (is.null(name)) 
[10:26:06.864]                               next
[10:26:06.864]                             if (!grepl(pattern, name)) 
[10:26:06.864]                               next
[10:26:06.864]                             invokeRestart(restart)
[10:26:06.864]                             muffled <- TRUE
[10:26:06.864]                             break
[10:26:06.864]                           }
[10:26:06.864]                         }
[10:26:06.864]                       }
[10:26:06.864]                       invisible(muffled)
[10:26:06.864]                     }
[10:26:06.864]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.864]                   }
[10:26:06.864]                 }
[10:26:06.864]                 else {
[10:26:06.864]                   if (TRUE) {
[10:26:06.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.864]                     {
[10:26:06.864]                       inherits <- base::inherits
[10:26:06.864]                       invokeRestart <- base::invokeRestart
[10:26:06.864]                       is.null <- base::is.null
[10:26:06.864]                       muffled <- FALSE
[10:26:06.864]                       if (inherits(cond, "message")) {
[10:26:06.864]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.864]                         if (muffled) 
[10:26:06.864]                           invokeRestart("muffleMessage")
[10:26:06.864]                       }
[10:26:06.864]                       else if (inherits(cond, "warning")) {
[10:26:06.864]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.864]                         if (muffled) 
[10:26:06.864]                           invokeRestart("muffleWarning")
[10:26:06.864]                       }
[10:26:06.864]                       else if (inherits(cond, "condition")) {
[10:26:06.864]                         if (!is.null(pattern)) {
[10:26:06.864]                           computeRestarts <- base::computeRestarts
[10:26:06.864]                           grepl <- base::grepl
[10:26:06.864]                           restarts <- computeRestarts(cond)
[10:26:06.864]                           for (restart in restarts) {
[10:26:06.864]                             name <- restart$name
[10:26:06.864]                             if (is.null(name)) 
[10:26:06.864]                               next
[10:26:06.864]                             if (!grepl(pattern, name)) 
[10:26:06.864]                               next
[10:26:06.864]                             invokeRestart(restart)
[10:26:06.864]                             muffled <- TRUE
[10:26:06.864]                             break
[10:26:06.864]                           }
[10:26:06.864]                         }
[10:26:06.864]                       }
[10:26:06.864]                       invisible(muffled)
[10:26:06.864]                     }
[10:26:06.864]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.864]                   }
[10:26:06.864]                 }
[10:26:06.864]             }
[10:26:06.864]         }))
[10:26:06.864]     }, error = function(ex) {
[10:26:06.864]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.864]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.864]                 ...future.rng), started = ...future.startTime, 
[10:26:06.864]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.864]             version = "1.8"), class = "FutureResult")
[10:26:06.864]     }, finally = {
[10:26:06.864]         if (!identical(...future.workdir, getwd())) 
[10:26:06.864]             setwd(...future.workdir)
[10:26:06.864]         {
[10:26:06.864]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.864]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.864]             }
[10:26:06.864]             base::options(...future.oldOptions)
[10:26:06.864]             if (.Platform$OS.type == "windows") {
[10:26:06.864]                 old_names <- names(...future.oldEnvVars)
[10:26:06.864]                 envs <- base::Sys.getenv()
[10:26:06.864]                 names <- names(envs)
[10:26:06.864]                 common <- intersect(names, old_names)
[10:26:06.864]                 added <- setdiff(names, old_names)
[10:26:06.864]                 removed <- setdiff(old_names, names)
[10:26:06.864]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.864]                   envs[common]]
[10:26:06.864]                 NAMES <- toupper(changed)
[10:26:06.864]                 args <- list()
[10:26:06.864]                 for (kk in seq_along(NAMES)) {
[10:26:06.864]                   name <- changed[[kk]]
[10:26:06.864]                   NAME <- NAMES[[kk]]
[10:26:06.864]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.864]                     next
[10:26:06.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.864]                 }
[10:26:06.864]                 NAMES <- toupper(added)
[10:26:06.864]                 for (kk in seq_along(NAMES)) {
[10:26:06.864]                   name <- added[[kk]]
[10:26:06.864]                   NAME <- NAMES[[kk]]
[10:26:06.864]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.864]                     next
[10:26:06.864]                   args[[name]] <- ""
[10:26:06.864]                 }
[10:26:06.864]                 NAMES <- toupper(removed)
[10:26:06.864]                 for (kk in seq_along(NAMES)) {
[10:26:06.864]                   name <- removed[[kk]]
[10:26:06.864]                   NAME <- NAMES[[kk]]
[10:26:06.864]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.864]                     next
[10:26:06.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.864]                 }
[10:26:06.864]                 if (length(args) > 0) 
[10:26:06.864]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.864]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.864]             }
[10:26:06.864]             else {
[10:26:06.864]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.864]             }
[10:26:06.864]             {
[10:26:06.864]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.864]                   0L) {
[10:26:06.864]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.864]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.864]                   base::options(opts)
[10:26:06.864]                 }
[10:26:06.864]                 {
[10:26:06.864]                   {
[10:26:06.864]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:06.864]                     NULL
[10:26:06.864]                   }
[10:26:06.864]                   options(future.plan = NULL)
[10:26:06.864]                   if (is.na(NA_character_)) 
[10:26:06.864]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.864]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.864]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:06.864]                     envir = parent.frame()) 
[10:26:06.864]                   {
[10:26:06.864]                     default_workers <- missing(workers)
[10:26:06.864]                     if (is.function(workers)) 
[10:26:06.864]                       workers <- workers()
[10:26:06.864]                     workers <- structure(as.integer(workers), 
[10:26:06.864]                       class = class(workers))
[10:26:06.864]                     stop_if_not(is.finite(workers), workers >= 
[10:26:06.864]                       1L)
[10:26:06.864]                     if ((workers == 1L && !inherits(workers, 
[10:26:06.864]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:06.864]                       if (default_workers) 
[10:26:06.864]                         supportsMulticore(warn = TRUE)
[10:26:06.864]                       return(sequential(..., envir = envir))
[10:26:06.864]                     }
[10:26:06.864]                     oopts <- options(mc.cores = workers)
[10:26:06.864]                     on.exit(options(oopts))
[10:26:06.864]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:06.864]                       envir = envir)
[10:26:06.864]                     if (!future$lazy) 
[10:26:06.864]                       future <- run(future)
[10:26:06.864]                     invisible(future)
[10:26:06.864]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.864]                 }
[10:26:06.864]             }
[10:26:06.864]         }
[10:26:06.864]     })
[10:26:06.864]     if (TRUE) {
[10:26:06.864]         base::sink(type = "output", split = FALSE)
[10:26:06.864]         if (TRUE) {
[10:26:06.864]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.864]         }
[10:26:06.864]         else {
[10:26:06.864]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.864]         }
[10:26:06.864]         base::close(...future.stdout)
[10:26:06.864]         ...future.stdout <- NULL
[10:26:06.864]     }
[10:26:06.864]     ...future.result$conditions <- ...future.conditions
[10:26:06.864]     ...future.result$finished <- base::Sys.time()
[10:26:06.864]     ...future.result
[10:26:06.864] }
[10:26:06.867] assign_globals() ...
[10:26:06.867] List of 1
[10:26:06.867]  $ x: list()
[10:26:06.867]  - attr(*, "where")=List of 1
[10:26:06.867]   ..$ x:<environment: R_EmptyEnv> 
[10:26:06.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.867]  - attr(*, "resolved")= logi TRUE
[10:26:06.867]  - attr(*, "total_size")= num 0
[10:26:06.867]  - attr(*, "already-done")= logi TRUE
[10:26:06.873] - copied ‘x’ to environment
[10:26:06.873] assign_globals() ... done
[10:26:06.873] requestCore(): workers = 2
[10:26:06.875] MulticoreFuture started
[10:26:06.875] - Launch lazy future ... done
[10:26:06.875] run() for ‘MulticoreFuture’ ... done
[10:26:06.876] result() for MulticoreFuture ...
[10:26:06.876] plan(): Setting new future strategy stack:
[10:26:06.876] List of future strategies:
[10:26:06.876] 1. sequential:
[10:26:06.876]    - args: function (..., envir = parent.frame())
[10:26:06.876]    - tweaked: FALSE
[10:26:06.876]    - call: NULL
[10:26:06.877] plan(): nbrOfWorkers() = 1
[10:26:06.879] plan(): Setting new future strategy stack:
[10:26:06.879] List of future strategies:
[10:26:06.879] 1. multicore:
[10:26:06.879]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.879]    - tweaked: FALSE
[10:26:06.879]    - call: plan(strategy)
[10:26:06.884] plan(): nbrOfWorkers() = 2
[10:26:06.885] result() for MulticoreFuture ...
[10:26:06.885] result() for MulticoreFuture ... done
[10:26:06.885] result() for MulticoreFuture ... done
[10:26:06.885] result() for MulticoreFuture ...
[10:26:06.885] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.886] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.887] Searching for globals...
[10:26:06.889] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:26:06.890] Searching for globals ... DONE
[10:26:06.890] Resolving globals: TRUE
[10:26:06.890] Resolving any globals that are futures ...
[10:26:06.890] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:26:06.890] Resolving any globals that are futures ... DONE
[10:26:06.891] Resolving futures part of globals (recursively) ...
[10:26:06.891] resolve() on list ...
[10:26:06.891]  recursive: 99
[10:26:06.891]  length: 2
[10:26:06.891]  elements: ‘x’, ‘name’
[10:26:06.891]  length: 1 (resolved future 1)
[10:26:06.892]  length: 0 (resolved future 2)
[10:26:06.892] resolve() on list ... DONE
[10:26:06.892] - globals: [2] ‘x’, ‘name’
[10:26:06.892] Resolving futures part of globals (recursively) ... DONE
[10:26:06.892] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:06.893] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[10:26:06.893] - globals: [2] ‘x’, ‘name’
[10:26:06.893] 
[10:26:06.893] getGlobalsAndPackages() ... DONE
[10:26:06.893] run() for ‘Future’ ...
[10:26:06.894] - state: ‘created’
[10:26:06.894] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:06.898] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:06.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:06.898]   - Field: ‘label’
[10:26:06.898]   - Field: ‘local’
[10:26:06.898]   - Field: ‘owner’
[10:26:06.898]   - Field: ‘envir’
[10:26:06.898]   - Field: ‘workers’
[10:26:06.898]   - Field: ‘packages’
[10:26:06.899]   - Field: ‘gc’
[10:26:06.899]   - Field: ‘job’
[10:26:06.899]   - Field: ‘conditions’
[10:26:06.899]   - Field: ‘expr’
[10:26:06.899]   - Field: ‘uuid’
[10:26:06.899]   - Field: ‘seed’
[10:26:06.899]   - Field: ‘version’
[10:26:06.899]   - Field: ‘result’
[10:26:06.899]   - Field: ‘asynchronous’
[10:26:06.900]   - Field: ‘calls’
[10:26:06.900]   - Field: ‘globals’
[10:26:06.900]   - Field: ‘stdout’
[10:26:06.900]   - Field: ‘earlySignal’
[10:26:06.900]   - Field: ‘lazy’
[10:26:06.900]   - Field: ‘state’
[10:26:06.900] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:06.900] - Launch lazy future ...
[10:26:06.901] Packages needed by the future expression (n = 0): <none>
[10:26:06.901] Packages needed by future strategies (n = 0): <none>
[10:26:06.901] {
[10:26:06.901]     {
[10:26:06.901]         {
[10:26:06.901]             ...future.startTime <- base::Sys.time()
[10:26:06.901]             {
[10:26:06.901]                 {
[10:26:06.901]                   {
[10:26:06.901]                     {
[10:26:06.901]                       base::local({
[10:26:06.901]                         has_future <- base::requireNamespace("future", 
[10:26:06.901]                           quietly = TRUE)
[10:26:06.901]                         if (has_future) {
[10:26:06.901]                           ns <- base::getNamespace("future")
[10:26:06.901]                           version <- ns[[".package"]][["version"]]
[10:26:06.901]                           if (is.null(version)) 
[10:26:06.901]                             version <- utils::packageVersion("future")
[10:26:06.901]                         }
[10:26:06.901]                         else {
[10:26:06.901]                           version <- NULL
[10:26:06.901]                         }
[10:26:06.901]                         if (!has_future || version < "1.8.0") {
[10:26:06.901]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:06.901]                             "", base::R.version$version.string), 
[10:26:06.901]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:06.901]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:06.901]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:06.901]                               "release", "version")], collapse = " "), 
[10:26:06.901]                             hostname = base::Sys.info()[["nodename"]])
[10:26:06.901]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:06.901]                             info)
[10:26:06.901]                           info <- base::paste(info, collapse = "; ")
[10:26:06.901]                           if (!has_future) {
[10:26:06.901]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:06.901]                               info)
[10:26:06.901]                           }
[10:26:06.901]                           else {
[10:26:06.901]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:06.901]                               info, version)
[10:26:06.901]                           }
[10:26:06.901]                           base::stop(msg)
[10:26:06.901]                         }
[10:26:06.901]                       })
[10:26:06.901]                     }
[10:26:06.901]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:06.901]                     base::options(mc.cores = 1L)
[10:26:06.901]                   }
[10:26:06.901]                   options(future.plan = NULL)
[10:26:06.901]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.901]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:06.901]                 }
[10:26:06.901]                 ...future.workdir <- getwd()
[10:26:06.901]             }
[10:26:06.901]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:06.901]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:06.901]         }
[10:26:06.901]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:06.901]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:06.901]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:06.901]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:06.901]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:06.901]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:06.901]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:06.901]             base::names(...future.oldOptions))
[10:26:06.901]     }
[10:26:06.901]     if (FALSE) {
[10:26:06.901]     }
[10:26:06.901]     else {
[10:26:06.901]         if (TRUE) {
[10:26:06.901]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:06.901]                 open = "w")
[10:26:06.901]         }
[10:26:06.901]         else {
[10:26:06.901]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:06.901]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:06.901]         }
[10:26:06.901]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:06.901]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:06.901]             base::sink(type = "output", split = FALSE)
[10:26:06.901]             base::close(...future.stdout)
[10:26:06.901]         }, add = TRUE)
[10:26:06.901]     }
[10:26:06.901]     ...future.frame <- base::sys.nframe()
[10:26:06.901]     ...future.conditions <- base::list()
[10:26:06.901]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:06.901]     if (FALSE) {
[10:26:06.901]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:06.901]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:06.901]     }
[10:26:06.901]     ...future.result <- base::tryCatch({
[10:26:06.901]         base::withCallingHandlers({
[10:26:06.901]             ...future.value <- base::withVisible(base::local({
[10:26:06.901]                 withCallingHandlers({
[10:26:06.901]                   {
[10:26:06.901]                     x[name] <- list(1)
[10:26:06.901]                     x
[10:26:06.901]                   }
[10:26:06.901]                 }, immediateCondition = function(cond) {
[10:26:06.901]                   save_rds <- function (object, pathname, ...) 
[10:26:06.901]                   {
[10:26:06.901]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:06.901]                     if (file_test("-f", pathname_tmp)) {
[10:26:06.901]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.901]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:06.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.901]                         fi_tmp[["mtime"]])
[10:26:06.901]                     }
[10:26:06.901]                     tryCatch({
[10:26:06.901]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:06.901]                     }, error = function(ex) {
[10:26:06.901]                       msg <- conditionMessage(ex)
[10:26:06.901]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.901]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:06.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.901]                         fi_tmp[["mtime"]], msg)
[10:26:06.901]                       ex$message <- msg
[10:26:06.901]                       stop(ex)
[10:26:06.901]                     })
[10:26:06.901]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:06.901]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:06.901]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:06.901]                       fi_tmp <- file.info(pathname_tmp)
[10:26:06.901]                       fi <- file.info(pathname)
[10:26:06.901]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:06.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:06.901]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:06.901]                         fi[["size"]], fi[["mtime"]])
[10:26:06.901]                       stop(msg)
[10:26:06.901]                     }
[10:26:06.901]                     invisible(pathname)
[10:26:06.901]                   }
[10:26:06.901]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:06.901]                     rootPath = tempdir()) 
[10:26:06.901]                   {
[10:26:06.901]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:06.901]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:06.901]                       tmpdir = path, fileext = ".rds")
[10:26:06.901]                     save_rds(obj, file)
[10:26:06.901]                   }
[10:26:06.901]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4YXwpK/.future/immediateConditions")
[10:26:06.901]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.901]                   {
[10:26:06.901]                     inherits <- base::inherits
[10:26:06.901]                     invokeRestart <- base::invokeRestart
[10:26:06.901]                     is.null <- base::is.null
[10:26:06.901]                     muffled <- FALSE
[10:26:06.901]                     if (inherits(cond, "message")) {
[10:26:06.901]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:06.901]                       if (muffled) 
[10:26:06.901]                         invokeRestart("muffleMessage")
[10:26:06.901]                     }
[10:26:06.901]                     else if (inherits(cond, "warning")) {
[10:26:06.901]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:06.901]                       if (muffled) 
[10:26:06.901]                         invokeRestart("muffleWarning")
[10:26:06.901]                     }
[10:26:06.901]                     else if (inherits(cond, "condition")) {
[10:26:06.901]                       if (!is.null(pattern)) {
[10:26:06.901]                         computeRestarts <- base::computeRestarts
[10:26:06.901]                         grepl <- base::grepl
[10:26:06.901]                         restarts <- computeRestarts(cond)
[10:26:06.901]                         for (restart in restarts) {
[10:26:06.901]                           name <- restart$name
[10:26:06.901]                           if (is.null(name)) 
[10:26:06.901]                             next
[10:26:06.901]                           if (!grepl(pattern, name)) 
[10:26:06.901]                             next
[10:26:06.901]                           invokeRestart(restart)
[10:26:06.901]                           muffled <- TRUE
[10:26:06.901]                           break
[10:26:06.901]                         }
[10:26:06.901]                       }
[10:26:06.901]                     }
[10:26:06.901]                     invisible(muffled)
[10:26:06.901]                   }
[10:26:06.901]                   muffleCondition(cond)
[10:26:06.901]                 })
[10:26:06.901]             }))
[10:26:06.901]             future::FutureResult(value = ...future.value$value, 
[10:26:06.901]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.901]                   ...future.rng), globalenv = if (FALSE) 
[10:26:06.901]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:06.901]                     ...future.globalenv.names))
[10:26:06.901]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:06.901]         }, condition = base::local({
[10:26:06.901]             c <- base::c
[10:26:06.901]             inherits <- base::inherits
[10:26:06.901]             invokeRestart <- base::invokeRestart
[10:26:06.901]             length <- base::length
[10:26:06.901]             list <- base::list
[10:26:06.901]             seq.int <- base::seq.int
[10:26:06.901]             signalCondition <- base::signalCondition
[10:26:06.901]             sys.calls <- base::sys.calls
[10:26:06.901]             `[[` <- base::`[[`
[10:26:06.901]             `+` <- base::`+`
[10:26:06.901]             `<<-` <- base::`<<-`
[10:26:06.901]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:06.901]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:06.901]                   3L)]
[10:26:06.901]             }
[10:26:06.901]             function(cond) {
[10:26:06.901]                 is_error <- inherits(cond, "error")
[10:26:06.901]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:06.901]                   NULL)
[10:26:06.901]                 if (is_error) {
[10:26:06.901]                   sessionInformation <- function() {
[10:26:06.901]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:06.901]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:06.901]                       search = base::search(), system = base::Sys.info())
[10:26:06.901]                   }
[10:26:06.901]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.901]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:06.901]                     cond$call), session = sessionInformation(), 
[10:26:06.901]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:06.901]                   signalCondition(cond)
[10:26:06.901]                 }
[10:26:06.901]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:06.901]                 "immediateCondition"))) {
[10:26:06.901]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:06.901]                   ...future.conditions[[length(...future.conditions) + 
[10:26:06.901]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:06.901]                   if (TRUE && !signal) {
[10:26:06.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.901]                     {
[10:26:06.901]                       inherits <- base::inherits
[10:26:06.901]                       invokeRestart <- base::invokeRestart
[10:26:06.901]                       is.null <- base::is.null
[10:26:06.901]                       muffled <- FALSE
[10:26:06.901]                       if (inherits(cond, "message")) {
[10:26:06.901]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.901]                         if (muffled) 
[10:26:06.901]                           invokeRestart("muffleMessage")
[10:26:06.901]                       }
[10:26:06.901]                       else if (inherits(cond, "warning")) {
[10:26:06.901]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.901]                         if (muffled) 
[10:26:06.901]                           invokeRestart("muffleWarning")
[10:26:06.901]                       }
[10:26:06.901]                       else if (inherits(cond, "condition")) {
[10:26:06.901]                         if (!is.null(pattern)) {
[10:26:06.901]                           computeRestarts <- base::computeRestarts
[10:26:06.901]                           grepl <- base::grepl
[10:26:06.901]                           restarts <- computeRestarts(cond)
[10:26:06.901]                           for (restart in restarts) {
[10:26:06.901]                             name <- restart$name
[10:26:06.901]                             if (is.null(name)) 
[10:26:06.901]                               next
[10:26:06.901]                             if (!grepl(pattern, name)) 
[10:26:06.901]                               next
[10:26:06.901]                             invokeRestart(restart)
[10:26:06.901]                             muffled <- TRUE
[10:26:06.901]                             break
[10:26:06.901]                           }
[10:26:06.901]                         }
[10:26:06.901]                       }
[10:26:06.901]                       invisible(muffled)
[10:26:06.901]                     }
[10:26:06.901]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.901]                   }
[10:26:06.901]                 }
[10:26:06.901]                 else {
[10:26:06.901]                   if (TRUE) {
[10:26:06.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:06.901]                     {
[10:26:06.901]                       inherits <- base::inherits
[10:26:06.901]                       invokeRestart <- base::invokeRestart
[10:26:06.901]                       is.null <- base::is.null
[10:26:06.901]                       muffled <- FALSE
[10:26:06.901]                       if (inherits(cond, "message")) {
[10:26:06.901]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:06.901]                         if (muffled) 
[10:26:06.901]                           invokeRestart("muffleMessage")
[10:26:06.901]                       }
[10:26:06.901]                       else if (inherits(cond, "warning")) {
[10:26:06.901]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:06.901]                         if (muffled) 
[10:26:06.901]                           invokeRestart("muffleWarning")
[10:26:06.901]                       }
[10:26:06.901]                       else if (inherits(cond, "condition")) {
[10:26:06.901]                         if (!is.null(pattern)) {
[10:26:06.901]                           computeRestarts <- base::computeRestarts
[10:26:06.901]                           grepl <- base::grepl
[10:26:06.901]                           restarts <- computeRestarts(cond)
[10:26:06.901]                           for (restart in restarts) {
[10:26:06.901]                             name <- restart$name
[10:26:06.901]                             if (is.null(name)) 
[10:26:06.901]                               next
[10:26:06.901]                             if (!grepl(pattern, name)) 
[10:26:06.901]                               next
[10:26:06.901]                             invokeRestart(restart)
[10:26:06.901]                             muffled <- TRUE
[10:26:06.901]                             break
[10:26:06.901]                           }
[10:26:06.901]                         }
[10:26:06.901]                       }
[10:26:06.901]                       invisible(muffled)
[10:26:06.901]                     }
[10:26:06.901]                     muffleCondition(cond, pattern = "^muffle")
[10:26:06.901]                   }
[10:26:06.901]                 }
[10:26:06.901]             }
[10:26:06.901]         }))
[10:26:06.901]     }, error = function(ex) {
[10:26:06.901]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:06.901]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:06.901]                 ...future.rng), started = ...future.startTime, 
[10:26:06.901]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:06.901]             version = "1.8"), class = "FutureResult")
[10:26:06.901]     }, finally = {
[10:26:06.901]         if (!identical(...future.workdir, getwd())) 
[10:26:06.901]             setwd(...future.workdir)
[10:26:06.901]         {
[10:26:06.901]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:06.901]                 ...future.oldOptions$nwarnings <- NULL
[10:26:06.901]             }
[10:26:06.901]             base::options(...future.oldOptions)
[10:26:06.901]             if (.Platform$OS.type == "windows") {
[10:26:06.901]                 old_names <- names(...future.oldEnvVars)
[10:26:06.901]                 envs <- base::Sys.getenv()
[10:26:06.901]                 names <- names(envs)
[10:26:06.901]                 common <- intersect(names, old_names)
[10:26:06.901]                 added <- setdiff(names, old_names)
[10:26:06.901]                 removed <- setdiff(old_names, names)
[10:26:06.901]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:06.901]                   envs[common]]
[10:26:06.901]                 NAMES <- toupper(changed)
[10:26:06.901]                 args <- list()
[10:26:06.901]                 for (kk in seq_along(NAMES)) {
[10:26:06.901]                   name <- changed[[kk]]
[10:26:06.901]                   NAME <- NAMES[[kk]]
[10:26:06.901]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.901]                     next
[10:26:06.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.901]                 }
[10:26:06.901]                 NAMES <- toupper(added)
[10:26:06.901]                 for (kk in seq_along(NAMES)) {
[10:26:06.901]                   name <- added[[kk]]
[10:26:06.901]                   NAME <- NAMES[[kk]]
[10:26:06.901]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.901]                     next
[10:26:06.901]                   args[[name]] <- ""
[10:26:06.901]                 }
[10:26:06.901]                 NAMES <- toupper(removed)
[10:26:06.901]                 for (kk in seq_along(NAMES)) {
[10:26:06.901]                   name <- removed[[kk]]
[10:26:06.901]                   NAME <- NAMES[[kk]]
[10:26:06.901]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:06.901]                     next
[10:26:06.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:06.901]                 }
[10:26:06.901]                 if (length(args) > 0) 
[10:26:06.901]                   base::do.call(base::Sys.setenv, args = args)
[10:26:06.901]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:06.901]             }
[10:26:06.901]             else {
[10:26:06.901]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:06.901]             }
[10:26:06.901]             {
[10:26:06.901]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:06.901]                   0L) {
[10:26:06.901]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:06.901]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:06.901]                   base::options(opts)
[10:26:06.901]                 }
[10:26:06.901]                 {
[10:26:06.901]                   {
[10:26:06.901]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:06.901]                     NULL
[10:26:06.901]                   }
[10:26:06.901]                   options(future.plan = NULL)
[10:26:06.901]                   if (is.na(NA_character_)) 
[10:26:06.901]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:06.901]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:06.901]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:06.901]                     envir = parent.frame()) 
[10:26:06.901]                   {
[10:26:06.901]                     default_workers <- missing(workers)
[10:26:06.901]                     if (is.function(workers)) 
[10:26:06.901]                       workers <- workers()
[10:26:06.901]                     workers <- structure(as.integer(workers), 
[10:26:06.901]                       class = class(workers))
[10:26:06.901]                     stop_if_not(is.finite(workers), workers >= 
[10:26:06.901]                       1L)
[10:26:06.901]                     if ((workers == 1L && !inherits(workers, 
[10:26:06.901]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:06.901]                       if (default_workers) 
[10:26:06.901]                         supportsMulticore(warn = TRUE)
[10:26:06.901]                       return(sequential(..., envir = envir))
[10:26:06.901]                     }
[10:26:06.901]                     oopts <- options(mc.cores = workers)
[10:26:06.901]                     on.exit(options(oopts))
[10:26:06.901]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:06.901]                       envir = envir)
[10:26:06.901]                     if (!future$lazy) 
[10:26:06.901]                       future <- run(future)
[10:26:06.901]                     invisible(future)
[10:26:06.901]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:06.901]                 }
[10:26:06.901]             }
[10:26:06.901]         }
[10:26:06.901]     })
[10:26:06.901]     if (TRUE) {
[10:26:06.901]         base::sink(type = "output", split = FALSE)
[10:26:06.901]         if (TRUE) {
[10:26:06.901]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:06.901]         }
[10:26:06.901]         else {
[10:26:06.901]             ...future.result["stdout"] <- base::list(NULL)
[10:26:06.901]         }
[10:26:06.901]         base::close(...future.stdout)
[10:26:06.901]         ...future.stdout <- NULL
[10:26:06.901]     }
[10:26:06.901]     ...future.result$conditions <- ...future.conditions
[10:26:06.901]     ...future.result$finished <- base::Sys.time()
[10:26:06.901]     ...future.result
[10:26:06.901] }
[10:26:06.904] assign_globals() ...
[10:26:06.904] List of 2
[10:26:06.904]  $ x   : list()
[10:26:06.904]  $ name: chr "a"
[10:26:06.904]  - attr(*, "where")=List of 2
[10:26:06.904]   ..$ x   :<environment: R_EmptyEnv> 
[10:26:06.904]   ..$ name:<environment: R_EmptyEnv> 
[10:26:06.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:06.904]  - attr(*, "resolved")= logi TRUE
[10:26:06.904]  - attr(*, "total_size")= num 112
[10:26:06.904]  - attr(*, "already-done")= logi TRUE
[10:26:06.908] - copied ‘x’ to environment
[10:26:06.908] - copied ‘name’ to environment
[10:26:06.908] assign_globals() ... done
[10:26:06.908] requestCore(): workers = 2
[10:26:06.910] MulticoreFuture started
[10:26:06.910] - Launch lazy future ... done
[10:26:06.910] run() for ‘MulticoreFuture’ ... done
[10:26:06.911] result() for MulticoreFuture ...
[10:26:06.911] plan(): Setting new future strategy stack:
[10:26:06.911] List of future strategies:
[10:26:06.911] 1. sequential:
[10:26:06.911]    - args: function (..., envir = parent.frame())
[10:26:06.911]    - tweaked: FALSE
[10:26:06.911]    - call: NULL
[10:26:06.912] plan(): nbrOfWorkers() = 1
[10:26:06.914] plan(): Setting new future strategy stack:
[10:26:06.914] List of future strategies:
[10:26:06.914] 1. multicore:
[10:26:06.914]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:06.914]    - tweaked: FALSE
[10:26:06.914]    - call: plan(strategy)
[10:26:06.919] plan(): nbrOfWorkers() = 2
[10:26:06.920] result() for MulticoreFuture ...
[10:26:06.920] result() for MulticoreFuture ... done
[10:26:06.920] result() for MulticoreFuture ... done
[10:26:06.920] result() for MulticoreFuture ...
[10:26:06.921] result() for MulticoreFuture ... done
$a
[1] 1

- plan('multisession') ...
[10:26:06.921] plan(): Setting new future strategy stack:
[10:26:06.921] List of future strategies:
[10:26:06.921] 1. multisession:
[10:26:06.921]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:06.921]    - tweaked: FALSE
[10:26:06.921]    - call: plan(strategy)
[10:26:06.922] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:26:06.922] multisession:
[10:26:06.922] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:06.922] - tweaked: FALSE
[10:26:06.922] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:06.932] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:06.933] Not searching for globals
[10:26:06.933] - globals: [0] <none>
[10:26:06.933] getGlobalsAndPackages() ... DONE
[10:26:06.934] [local output] makeClusterPSOCK() ...
[10:26:06.978] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:26:06.980] [local output] Base port: 11506
[10:26:06.980] [local output] Getting setup options for 2 cluster nodes ...
[10:26:06.980] [local output]  - Node 1 of 2 ...
[10:26:06.980] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:06.981] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4YXwpK/worker.rank=1.parallelly.parent=85848.14f582dd3cd59.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp4YXwpK/worker.rank=1.parallelly.parent=85848.14f582dd3cd59.pid")'’
[10:26:07.170] - Possible to infer worker's PID: TRUE
[10:26:07.170] [local output] Rscript port: 11506

[10:26:07.171] [local output]  - Node 2 of 2 ...
[10:26:07.171] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:07.172] [local output] Rscript port: 11506

[10:26:07.172] [local output] Getting setup options for 2 cluster nodes ... done
[10:26:07.172] [local output]  - Parallel setup requested for some PSOCK nodes
[10:26:07.173] [local output] Setting up PSOCK nodes in parallel
[10:26:07.173] List of 36
[10:26:07.173]  $ worker          : chr "localhost"
[10:26:07.173]   ..- attr(*, "localhost")= logi TRUE
[10:26:07.173]  $ master          : chr "localhost"
[10:26:07.173]  $ port            : int 11506
[10:26:07.173]  $ connectTimeout  : num 120
[10:26:07.173]  $ timeout         : num 2592000
[10:26:07.173]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:26:07.173]  $ homogeneous     : logi TRUE
[10:26:07.173]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:26:07.173]  $ rscript_envs    : NULL
[10:26:07.173]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:07.173]  $ rscript_startup : NULL
[10:26:07.173]  $ rscript_sh      : chr "sh"
[10:26:07.173]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:07.173]  $ methods         : logi TRUE
[10:26:07.173]  $ socketOptions   : chr "no-delay"
[10:26:07.173]  $ useXDR          : logi FALSE
[10:26:07.173]  $ outfile         : chr "/dev/null"
[10:26:07.173]  $ renice          : int NA
[10:26:07.173]  $ rshcmd          : NULL
[10:26:07.173]  $ user            : chr(0) 
[10:26:07.173]  $ revtunnel       : logi FALSE
[10:26:07.173]  $ rshlogfile      : NULL
[10:26:07.173]  $ rshopts         : chr(0) 
[10:26:07.173]  $ rank            : int 1
[10:26:07.173]  $ manual          : logi FALSE
[10:26:07.173]  $ dryrun          : logi FALSE
[10:26:07.173]  $ quiet           : logi FALSE
[10:26:07.173]  $ setup_strategy  : chr "parallel"
[10:26:07.173]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:07.173]  $ pidfile         : chr "/tmp/Rtmp4YXwpK/worker.rank=1.parallelly.parent=85848.14f582dd3cd59.pid"
[10:26:07.173]  $ rshcmd_label    : NULL
[10:26:07.173]  $ rsh_call        : NULL
[10:26:07.173]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:07.173]  $ localMachine    : logi TRUE
[10:26:07.173]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:26:07.173]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:26:07.173]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:26:07.173]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:26:07.173]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:26:07.173]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:26:07.173]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:26:07.173]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:26:07.173]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:26:07.173]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:26:07.173]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:26:07.173]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:26:07.173]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:26:07.173]  $ arguments       :List of 28
[10:26:07.173]   ..$ worker          : chr "localhost"
[10:26:07.173]   ..$ master          : NULL
[10:26:07.173]   ..$ port            : int 11506
[10:26:07.173]   ..$ connectTimeout  : num 120
[10:26:07.173]   ..$ timeout         : num 2592000
[10:26:07.173]   ..$ rscript         : NULL
[10:26:07.173]   ..$ homogeneous     : NULL
[10:26:07.173]   ..$ rscript_args    : NULL
[10:26:07.173]   ..$ rscript_envs    : NULL
[10:26:07.173]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:07.173]   ..$ rscript_startup : NULL
[10:26:07.173]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:26:07.173]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:07.173]   ..$ methods         : logi TRUE
[10:26:07.173]   ..$ socketOptions   : chr "no-delay"
[10:26:07.173]   ..$ useXDR          : logi FALSE
[10:26:07.173]   ..$ outfile         : chr "/dev/null"
[10:26:07.173]   ..$ renice          : int NA
[10:26:07.173]   ..$ rshcmd          : NULL
[10:26:07.173]   ..$ user            : NULL
[10:26:07.173]   ..$ revtunnel       : logi NA
[10:26:07.173]   ..$ rshlogfile      : NULL
[10:26:07.173]   ..$ rshopts         : NULL
[10:26:07.173]   ..$ rank            : int 1
[10:26:07.173]   ..$ manual          : logi FALSE
[10:26:07.173]   ..$ dryrun          : logi FALSE
[10:26:07.173]   ..$ quiet           : logi FALSE
[10:26:07.173]   ..$ setup_strategy  : chr "parallel"
[10:26:07.173]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:26:07.190] [local output] System call to launch all workers:
[10:26:07.190] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4YXwpK/worker.rank=1.parallelly.parent=85848.14f582dd3cd59.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11506 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:26:07.190] [local output] Starting PSOCK main server
[10:26:07.195] [local output] Workers launched
[10:26:07.196] [local output] Waiting for workers to connect back
[10:26:07.196]  - [local output] 0 workers out of 2 ready
[10:26:07.459]  - [local output] 0 workers out of 2 ready
[10:26:07.459]  - [local output] 1 workers out of 2 ready
[10:26:07.464]  - [local output] 1 workers out of 2 ready
[10:26:07.464]  - [local output] 2 workers out of 2 ready
[10:26:07.464] [local output] Launching of workers completed
[10:26:07.464] [local output] Collecting session information from workers
[10:26:07.465] [local output]  - Worker #1 of 2
[10:26:07.466] [local output]  - Worker #2 of 2
[10:26:07.466] [local output] makeClusterPSOCK() ... done
[10:26:07.478] Packages needed by the future expression (n = 0): <none>
[10:26:07.478] Packages needed by future strategies (n = 0): <none>
[10:26:07.478] {
[10:26:07.478]     {
[10:26:07.478]         {
[10:26:07.478]             ...future.startTime <- base::Sys.time()
[10:26:07.478]             {
[10:26:07.478]                 {
[10:26:07.478]                   {
[10:26:07.478]                     {
[10:26:07.478]                       base::local({
[10:26:07.478]                         has_future <- base::requireNamespace("future", 
[10:26:07.478]                           quietly = TRUE)
[10:26:07.478]                         if (has_future) {
[10:26:07.478]                           ns <- base::getNamespace("future")
[10:26:07.478]                           version <- ns[[".package"]][["version"]]
[10:26:07.478]                           if (is.null(version)) 
[10:26:07.478]                             version <- utils::packageVersion("future")
[10:26:07.478]                         }
[10:26:07.478]                         else {
[10:26:07.478]                           version <- NULL
[10:26:07.478]                         }
[10:26:07.478]                         if (!has_future || version < "1.8.0") {
[10:26:07.478]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:07.478]                             "", base::R.version$version.string), 
[10:26:07.478]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:07.478]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:07.478]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:07.478]                               "release", "version")], collapse = " "), 
[10:26:07.478]                             hostname = base::Sys.info()[["nodename"]])
[10:26:07.478]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:07.478]                             info)
[10:26:07.478]                           info <- base::paste(info, collapse = "; ")
[10:26:07.478]                           if (!has_future) {
[10:26:07.478]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:07.478]                               info)
[10:26:07.478]                           }
[10:26:07.478]                           else {
[10:26:07.478]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:07.478]                               info, version)
[10:26:07.478]                           }
[10:26:07.478]                           base::stop(msg)
[10:26:07.478]                         }
[10:26:07.478]                       })
[10:26:07.478]                     }
[10:26:07.478]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:07.478]                     base::options(mc.cores = 1L)
[10:26:07.478]                   }
[10:26:07.478]                   options(future.plan = NULL)
[10:26:07.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:07.478]                 }
[10:26:07.478]                 ...future.workdir <- getwd()
[10:26:07.478]             }
[10:26:07.478]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:07.478]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:07.478]         }
[10:26:07.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:07.478]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:07.478]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:07.478]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:07.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:07.478]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:07.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:07.478]             base::names(...future.oldOptions))
[10:26:07.478]     }
[10:26:07.478]     if (FALSE) {
[10:26:07.478]     }
[10:26:07.478]     else {
[10:26:07.478]         if (TRUE) {
[10:26:07.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:07.478]                 open = "w")
[10:26:07.478]         }
[10:26:07.478]         else {
[10:26:07.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:07.478]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:07.478]         }
[10:26:07.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:07.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:07.478]             base::sink(type = "output", split = FALSE)
[10:26:07.478]             base::close(...future.stdout)
[10:26:07.478]         }, add = TRUE)
[10:26:07.478]     }
[10:26:07.478]     ...future.frame <- base::sys.nframe()
[10:26:07.478]     ...future.conditions <- base::list()
[10:26:07.478]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:07.478]     if (FALSE) {
[10:26:07.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:07.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:07.478]     }
[10:26:07.478]     ...future.result <- base::tryCatch({
[10:26:07.478]         base::withCallingHandlers({
[10:26:07.478]             ...future.value <- base::withVisible(base::local({
[10:26:07.478]                 ...future.makeSendCondition <- base::local({
[10:26:07.478]                   sendCondition <- NULL
[10:26:07.478]                   function(frame = 1L) {
[10:26:07.478]                     if (is.function(sendCondition)) 
[10:26:07.478]                       return(sendCondition)
[10:26:07.478]                     ns <- getNamespace("parallel")
[10:26:07.478]                     if (exists("sendData", mode = "function", 
[10:26:07.478]                       envir = ns)) {
[10:26:07.478]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:07.478]                         envir = ns)
[10:26:07.478]                       envir <- sys.frame(frame)
[10:26:07.478]                       master <- NULL
[10:26:07.478]                       while (!identical(envir, .GlobalEnv) && 
[10:26:07.478]                         !identical(envir, emptyenv())) {
[10:26:07.478]                         if (exists("master", mode = "list", envir = envir, 
[10:26:07.478]                           inherits = FALSE)) {
[10:26:07.478]                           master <- get("master", mode = "list", 
[10:26:07.478]                             envir = envir, inherits = FALSE)
[10:26:07.478]                           if (inherits(master, c("SOCKnode", 
[10:26:07.478]                             "SOCK0node"))) {
[10:26:07.478]                             sendCondition <<- function(cond) {
[10:26:07.478]                               data <- list(type = "VALUE", value = cond, 
[10:26:07.478]                                 success = TRUE)
[10:26:07.478]                               parallel_sendData(master, data)
[10:26:07.478]                             }
[10:26:07.478]                             return(sendCondition)
[10:26:07.478]                           }
[10:26:07.478]                         }
[10:26:07.478]                         frame <- frame + 1L
[10:26:07.478]                         envir <- sys.frame(frame)
[10:26:07.478]                       }
[10:26:07.478]                     }
[10:26:07.478]                     sendCondition <<- function(cond) NULL
[10:26:07.478]                   }
[10:26:07.478]                 })
[10:26:07.478]                 withCallingHandlers({
[10:26:07.478]                   NA
[10:26:07.478]                 }, immediateCondition = function(cond) {
[10:26:07.478]                   sendCondition <- ...future.makeSendCondition()
[10:26:07.478]                   sendCondition(cond)
[10:26:07.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.478]                   {
[10:26:07.478]                     inherits <- base::inherits
[10:26:07.478]                     invokeRestart <- base::invokeRestart
[10:26:07.478]                     is.null <- base::is.null
[10:26:07.478]                     muffled <- FALSE
[10:26:07.478]                     if (inherits(cond, "message")) {
[10:26:07.478]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:07.478]                       if (muffled) 
[10:26:07.478]                         invokeRestart("muffleMessage")
[10:26:07.478]                     }
[10:26:07.478]                     else if (inherits(cond, "warning")) {
[10:26:07.478]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:07.478]                       if (muffled) 
[10:26:07.478]                         invokeRestart("muffleWarning")
[10:26:07.478]                     }
[10:26:07.478]                     else if (inherits(cond, "condition")) {
[10:26:07.478]                       if (!is.null(pattern)) {
[10:26:07.478]                         computeRestarts <- base::computeRestarts
[10:26:07.478]                         grepl <- base::grepl
[10:26:07.478]                         restarts <- computeRestarts(cond)
[10:26:07.478]                         for (restart in restarts) {
[10:26:07.478]                           name <- restart$name
[10:26:07.478]                           if (is.null(name)) 
[10:26:07.478]                             next
[10:26:07.478]                           if (!grepl(pattern, name)) 
[10:26:07.478]                             next
[10:26:07.478]                           invokeRestart(restart)
[10:26:07.478]                           muffled <- TRUE
[10:26:07.478]                           break
[10:26:07.478]                         }
[10:26:07.478]                       }
[10:26:07.478]                     }
[10:26:07.478]                     invisible(muffled)
[10:26:07.478]                   }
[10:26:07.478]                   muffleCondition(cond)
[10:26:07.478]                 })
[10:26:07.478]             }))
[10:26:07.478]             future::FutureResult(value = ...future.value$value, 
[10:26:07.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.478]                   ...future.rng), globalenv = if (FALSE) 
[10:26:07.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:07.478]                     ...future.globalenv.names))
[10:26:07.478]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:07.478]         }, condition = base::local({
[10:26:07.478]             c <- base::c
[10:26:07.478]             inherits <- base::inherits
[10:26:07.478]             invokeRestart <- base::invokeRestart
[10:26:07.478]             length <- base::length
[10:26:07.478]             list <- base::list
[10:26:07.478]             seq.int <- base::seq.int
[10:26:07.478]             signalCondition <- base::signalCondition
[10:26:07.478]             sys.calls <- base::sys.calls
[10:26:07.478]             `[[` <- base::`[[`
[10:26:07.478]             `+` <- base::`+`
[10:26:07.478]             `<<-` <- base::`<<-`
[10:26:07.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:07.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:07.478]                   3L)]
[10:26:07.478]             }
[10:26:07.478]             function(cond) {
[10:26:07.478]                 is_error <- inherits(cond, "error")
[10:26:07.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:07.478]                   NULL)
[10:26:07.478]                 if (is_error) {
[10:26:07.478]                   sessionInformation <- function() {
[10:26:07.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:07.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:07.478]                       search = base::search(), system = base::Sys.info())
[10:26:07.478]                   }
[10:26:07.478]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:07.478]                     cond$call), session = sessionInformation(), 
[10:26:07.478]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:07.478]                   signalCondition(cond)
[10:26:07.478]                 }
[10:26:07.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:07.478]                 "immediateCondition"))) {
[10:26:07.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:07.478]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:07.478]                   if (TRUE && !signal) {
[10:26:07.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.478]                     {
[10:26:07.478]                       inherits <- base::inherits
[10:26:07.478]                       invokeRestart <- base::invokeRestart
[10:26:07.478]                       is.null <- base::is.null
[10:26:07.478]                       muffled <- FALSE
[10:26:07.478]                       if (inherits(cond, "message")) {
[10:26:07.478]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.478]                         if (muffled) 
[10:26:07.478]                           invokeRestart("muffleMessage")
[10:26:07.478]                       }
[10:26:07.478]                       else if (inherits(cond, "warning")) {
[10:26:07.478]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.478]                         if (muffled) 
[10:26:07.478]                           invokeRestart("muffleWarning")
[10:26:07.478]                       }
[10:26:07.478]                       else if (inherits(cond, "condition")) {
[10:26:07.478]                         if (!is.null(pattern)) {
[10:26:07.478]                           computeRestarts <- base::computeRestarts
[10:26:07.478]                           grepl <- base::grepl
[10:26:07.478]                           restarts <- computeRestarts(cond)
[10:26:07.478]                           for (restart in restarts) {
[10:26:07.478]                             name <- restart$name
[10:26:07.478]                             if (is.null(name)) 
[10:26:07.478]                               next
[10:26:07.478]                             if (!grepl(pattern, name)) 
[10:26:07.478]                               next
[10:26:07.478]                             invokeRestart(restart)
[10:26:07.478]                             muffled <- TRUE
[10:26:07.478]                             break
[10:26:07.478]                           }
[10:26:07.478]                         }
[10:26:07.478]                       }
[10:26:07.478]                       invisible(muffled)
[10:26:07.478]                     }
[10:26:07.478]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.478]                   }
[10:26:07.478]                 }
[10:26:07.478]                 else {
[10:26:07.478]                   if (TRUE) {
[10:26:07.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.478]                     {
[10:26:07.478]                       inherits <- base::inherits
[10:26:07.478]                       invokeRestart <- base::invokeRestart
[10:26:07.478]                       is.null <- base::is.null
[10:26:07.478]                       muffled <- FALSE
[10:26:07.478]                       if (inherits(cond, "message")) {
[10:26:07.478]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.478]                         if (muffled) 
[10:26:07.478]                           invokeRestart("muffleMessage")
[10:26:07.478]                       }
[10:26:07.478]                       else if (inherits(cond, "warning")) {
[10:26:07.478]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.478]                         if (muffled) 
[10:26:07.478]                           invokeRestart("muffleWarning")
[10:26:07.478]                       }
[10:26:07.478]                       else if (inherits(cond, "condition")) {
[10:26:07.478]                         if (!is.null(pattern)) {
[10:26:07.478]                           computeRestarts <- base::computeRestarts
[10:26:07.478]                           grepl <- base::grepl
[10:26:07.478]                           restarts <- computeRestarts(cond)
[10:26:07.478]                           for (restart in restarts) {
[10:26:07.478]                             name <- restart$name
[10:26:07.478]                             if (is.null(name)) 
[10:26:07.478]                               next
[10:26:07.478]                             if (!grepl(pattern, name)) 
[10:26:07.478]                               next
[10:26:07.478]                             invokeRestart(restart)
[10:26:07.478]                             muffled <- TRUE
[10:26:07.478]                             break
[10:26:07.478]                           }
[10:26:07.478]                         }
[10:26:07.478]                       }
[10:26:07.478]                       invisible(muffled)
[10:26:07.478]                     }
[10:26:07.478]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.478]                   }
[10:26:07.478]                 }
[10:26:07.478]             }
[10:26:07.478]         }))
[10:26:07.478]     }, error = function(ex) {
[10:26:07.478]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:07.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.478]                 ...future.rng), started = ...future.startTime, 
[10:26:07.478]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:07.478]             version = "1.8"), class = "FutureResult")
[10:26:07.478]     }, finally = {
[10:26:07.478]         if (!identical(...future.workdir, getwd())) 
[10:26:07.478]             setwd(...future.workdir)
[10:26:07.478]         {
[10:26:07.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:07.478]                 ...future.oldOptions$nwarnings <- NULL
[10:26:07.478]             }
[10:26:07.478]             base::options(...future.oldOptions)
[10:26:07.478]             if (.Platform$OS.type == "windows") {
[10:26:07.478]                 old_names <- names(...future.oldEnvVars)
[10:26:07.478]                 envs <- base::Sys.getenv()
[10:26:07.478]                 names <- names(envs)
[10:26:07.478]                 common <- intersect(names, old_names)
[10:26:07.478]                 added <- setdiff(names, old_names)
[10:26:07.478]                 removed <- setdiff(old_names, names)
[10:26:07.478]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:07.478]                   envs[common]]
[10:26:07.478]                 NAMES <- toupper(changed)
[10:26:07.478]                 args <- list()
[10:26:07.478]                 for (kk in seq_along(NAMES)) {
[10:26:07.478]                   name <- changed[[kk]]
[10:26:07.478]                   NAME <- NAMES[[kk]]
[10:26:07.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.478]                     next
[10:26:07.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.478]                 }
[10:26:07.478]                 NAMES <- toupper(added)
[10:26:07.478]                 for (kk in seq_along(NAMES)) {
[10:26:07.478]                   name <- added[[kk]]
[10:26:07.478]                   NAME <- NAMES[[kk]]
[10:26:07.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.478]                     next
[10:26:07.478]                   args[[name]] <- ""
[10:26:07.478]                 }
[10:26:07.478]                 NAMES <- toupper(removed)
[10:26:07.478]                 for (kk in seq_along(NAMES)) {
[10:26:07.478]                   name <- removed[[kk]]
[10:26:07.478]                   NAME <- NAMES[[kk]]
[10:26:07.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.478]                     next
[10:26:07.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.478]                 }
[10:26:07.478]                 if (length(args) > 0) 
[10:26:07.478]                   base::do.call(base::Sys.setenv, args = args)
[10:26:07.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:07.478]             }
[10:26:07.478]             else {
[10:26:07.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:07.478]             }
[10:26:07.478]             {
[10:26:07.478]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:07.478]                   0L) {
[10:26:07.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:07.478]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:07.478]                   base::options(opts)
[10:26:07.478]                 }
[10:26:07.478]                 {
[10:26:07.478]                   {
[10:26:07.478]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:07.478]                     NULL
[10:26:07.478]                   }
[10:26:07.478]                   options(future.plan = NULL)
[10:26:07.478]                   if (is.na(NA_character_)) 
[10:26:07.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:07.478]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:07.478]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:07.478]                     envir = parent.frame()) 
[10:26:07.478]                   {
[10:26:07.478]                     if (is.function(workers)) 
[10:26:07.478]                       workers <- workers()
[10:26:07.478]                     workers <- structure(as.integer(workers), 
[10:26:07.478]                       class = class(workers))
[10:26:07.478]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:07.478]                       workers >= 1)
[10:26:07.478]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:07.478]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:07.478]                     }
[10:26:07.478]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:07.478]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:07.478]                       envir = envir)
[10:26:07.478]                     if (!future$lazy) 
[10:26:07.478]                       future <- run(future)
[10:26:07.478]                     invisible(future)
[10:26:07.478]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:07.478]                 }
[10:26:07.478]             }
[10:26:07.478]         }
[10:26:07.478]     })
[10:26:07.478]     if (TRUE) {
[10:26:07.478]         base::sink(type = "output", split = FALSE)
[10:26:07.478]         if (TRUE) {
[10:26:07.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:07.478]         }
[10:26:07.478]         else {
[10:26:07.478]             ...future.result["stdout"] <- base::list(NULL)
[10:26:07.478]         }
[10:26:07.478]         base::close(...future.stdout)
[10:26:07.478]         ...future.stdout <- NULL
[10:26:07.478]     }
[10:26:07.478]     ...future.result$conditions <- ...future.conditions
[10:26:07.478]     ...future.result$finished <- base::Sys.time()
[10:26:07.478]     ...future.result
[10:26:07.478] }
[10:26:07.532] MultisessionFuture started
[10:26:07.532] result() for ClusterFuture ...
[10:26:07.533] receiveMessageFromWorker() for ClusterFuture ...
[10:26:07.533] - Validating connection of MultisessionFuture
[10:26:07.576] - received message: FutureResult
[10:26:07.576] - Received FutureResult
[10:26:07.576] - Erased future from FutureRegistry
[10:26:07.576] result() for ClusterFuture ...
[10:26:07.576] - result already collected: FutureResult
[10:26:07.576] result() for ClusterFuture ... done
[10:26:07.577] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:07.577] result() for ClusterFuture ... done
[10:26:07.577] result() for ClusterFuture ...
[10:26:07.577] - result already collected: FutureResult
[10:26:07.577] result() for ClusterFuture ... done
[10:26:07.577] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:26:07.581] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:07.581] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:07.581] Searching for globals...
[10:26:07.584] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:07.584] Searching for globals ... DONE
[10:26:07.584] Resolving globals: TRUE
[10:26:07.584] Resolving any globals that are futures ...
[10:26:07.585] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:07.585] Resolving any globals that are futures ... DONE
[10:26:07.585] Resolving futures part of globals (recursively) ...
[10:26:07.585] resolve() on list ...
[10:26:07.586]  recursive: 99
[10:26:07.586]  length: 1
[10:26:07.586]  elements: ‘x’
[10:26:07.586]  length: 0 (resolved future 1)
[10:26:07.586] resolve() on list ... DONE
[10:26:07.586] - globals: [1] ‘x’
[10:26:07.586] Resolving futures part of globals (recursively) ... DONE
[10:26:07.587] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:07.587] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:07.587] - globals: [1] ‘x’
[10:26:07.587] 
[10:26:07.587] getGlobalsAndPackages() ... DONE
[10:26:07.588] run() for ‘Future’ ...
[10:26:07.588] - state: ‘created’
[10:26:07.588] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:07.602] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:07.602] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:07.603]   - Field: ‘node’
[10:26:07.603]   - Field: ‘label’
[10:26:07.603]   - Field: ‘local’
[10:26:07.603]   - Field: ‘owner’
[10:26:07.603]   - Field: ‘envir’
[10:26:07.603]   - Field: ‘workers’
[10:26:07.603]   - Field: ‘packages’
[10:26:07.603]   - Field: ‘gc’
[10:26:07.603]   - Field: ‘conditions’
[10:26:07.604]   - Field: ‘persistent’
[10:26:07.604]   - Field: ‘expr’
[10:26:07.604]   - Field: ‘uuid’
[10:26:07.604]   - Field: ‘seed’
[10:26:07.604]   - Field: ‘version’
[10:26:07.604]   - Field: ‘result’
[10:26:07.604]   - Field: ‘asynchronous’
[10:26:07.604]   - Field: ‘calls’
[10:26:07.604]   - Field: ‘globals’
[10:26:07.605]   - Field: ‘stdout’
[10:26:07.605]   - Field: ‘earlySignal’
[10:26:07.605]   - Field: ‘lazy’
[10:26:07.605]   - Field: ‘state’
[10:26:07.605] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:07.605] - Launch lazy future ...
[10:26:07.606] Packages needed by the future expression (n = 0): <none>
[10:26:07.606] Packages needed by future strategies (n = 0): <none>
[10:26:07.606] {
[10:26:07.606]     {
[10:26:07.606]         {
[10:26:07.606]             ...future.startTime <- base::Sys.time()
[10:26:07.606]             {
[10:26:07.606]                 {
[10:26:07.606]                   {
[10:26:07.606]                     {
[10:26:07.606]                       base::local({
[10:26:07.606]                         has_future <- base::requireNamespace("future", 
[10:26:07.606]                           quietly = TRUE)
[10:26:07.606]                         if (has_future) {
[10:26:07.606]                           ns <- base::getNamespace("future")
[10:26:07.606]                           version <- ns[[".package"]][["version"]]
[10:26:07.606]                           if (is.null(version)) 
[10:26:07.606]                             version <- utils::packageVersion("future")
[10:26:07.606]                         }
[10:26:07.606]                         else {
[10:26:07.606]                           version <- NULL
[10:26:07.606]                         }
[10:26:07.606]                         if (!has_future || version < "1.8.0") {
[10:26:07.606]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:07.606]                             "", base::R.version$version.string), 
[10:26:07.606]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:07.606]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:07.606]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:07.606]                               "release", "version")], collapse = " "), 
[10:26:07.606]                             hostname = base::Sys.info()[["nodename"]])
[10:26:07.606]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:07.606]                             info)
[10:26:07.606]                           info <- base::paste(info, collapse = "; ")
[10:26:07.606]                           if (!has_future) {
[10:26:07.606]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:07.606]                               info)
[10:26:07.606]                           }
[10:26:07.606]                           else {
[10:26:07.606]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:07.606]                               info, version)
[10:26:07.606]                           }
[10:26:07.606]                           base::stop(msg)
[10:26:07.606]                         }
[10:26:07.606]                       })
[10:26:07.606]                     }
[10:26:07.606]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:07.606]                     base::options(mc.cores = 1L)
[10:26:07.606]                   }
[10:26:07.606]                   options(future.plan = NULL)
[10:26:07.606]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.606]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:07.606]                 }
[10:26:07.606]                 ...future.workdir <- getwd()
[10:26:07.606]             }
[10:26:07.606]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:07.606]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:07.606]         }
[10:26:07.606]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:07.606]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:07.606]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:07.606]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:07.606]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:07.606]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:07.606]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:07.606]             base::names(...future.oldOptions))
[10:26:07.606]     }
[10:26:07.606]     if (FALSE) {
[10:26:07.606]     }
[10:26:07.606]     else {
[10:26:07.606]         if (TRUE) {
[10:26:07.606]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:07.606]                 open = "w")
[10:26:07.606]         }
[10:26:07.606]         else {
[10:26:07.606]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:07.606]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:07.606]         }
[10:26:07.606]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:07.606]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:07.606]             base::sink(type = "output", split = FALSE)
[10:26:07.606]             base::close(...future.stdout)
[10:26:07.606]         }, add = TRUE)
[10:26:07.606]     }
[10:26:07.606]     ...future.frame <- base::sys.nframe()
[10:26:07.606]     ...future.conditions <- base::list()
[10:26:07.606]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:07.606]     if (FALSE) {
[10:26:07.606]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:07.606]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:07.606]     }
[10:26:07.606]     ...future.result <- base::tryCatch({
[10:26:07.606]         base::withCallingHandlers({
[10:26:07.606]             ...future.value <- base::withVisible(base::local({
[10:26:07.606]                 ...future.makeSendCondition <- base::local({
[10:26:07.606]                   sendCondition <- NULL
[10:26:07.606]                   function(frame = 1L) {
[10:26:07.606]                     if (is.function(sendCondition)) 
[10:26:07.606]                       return(sendCondition)
[10:26:07.606]                     ns <- getNamespace("parallel")
[10:26:07.606]                     if (exists("sendData", mode = "function", 
[10:26:07.606]                       envir = ns)) {
[10:26:07.606]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:07.606]                         envir = ns)
[10:26:07.606]                       envir <- sys.frame(frame)
[10:26:07.606]                       master <- NULL
[10:26:07.606]                       while (!identical(envir, .GlobalEnv) && 
[10:26:07.606]                         !identical(envir, emptyenv())) {
[10:26:07.606]                         if (exists("master", mode = "list", envir = envir, 
[10:26:07.606]                           inherits = FALSE)) {
[10:26:07.606]                           master <- get("master", mode = "list", 
[10:26:07.606]                             envir = envir, inherits = FALSE)
[10:26:07.606]                           if (inherits(master, c("SOCKnode", 
[10:26:07.606]                             "SOCK0node"))) {
[10:26:07.606]                             sendCondition <<- function(cond) {
[10:26:07.606]                               data <- list(type = "VALUE", value = cond, 
[10:26:07.606]                                 success = TRUE)
[10:26:07.606]                               parallel_sendData(master, data)
[10:26:07.606]                             }
[10:26:07.606]                             return(sendCondition)
[10:26:07.606]                           }
[10:26:07.606]                         }
[10:26:07.606]                         frame <- frame + 1L
[10:26:07.606]                         envir <- sys.frame(frame)
[10:26:07.606]                       }
[10:26:07.606]                     }
[10:26:07.606]                     sendCondition <<- function(cond) NULL
[10:26:07.606]                   }
[10:26:07.606]                 })
[10:26:07.606]                 withCallingHandlers({
[10:26:07.606]                   {
[10:26:07.606]                     x$a <- 1
[10:26:07.606]                     x
[10:26:07.606]                   }
[10:26:07.606]                 }, immediateCondition = function(cond) {
[10:26:07.606]                   sendCondition <- ...future.makeSendCondition()
[10:26:07.606]                   sendCondition(cond)
[10:26:07.606]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.606]                   {
[10:26:07.606]                     inherits <- base::inherits
[10:26:07.606]                     invokeRestart <- base::invokeRestart
[10:26:07.606]                     is.null <- base::is.null
[10:26:07.606]                     muffled <- FALSE
[10:26:07.606]                     if (inherits(cond, "message")) {
[10:26:07.606]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:07.606]                       if (muffled) 
[10:26:07.606]                         invokeRestart("muffleMessage")
[10:26:07.606]                     }
[10:26:07.606]                     else if (inherits(cond, "warning")) {
[10:26:07.606]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:07.606]                       if (muffled) 
[10:26:07.606]                         invokeRestart("muffleWarning")
[10:26:07.606]                     }
[10:26:07.606]                     else if (inherits(cond, "condition")) {
[10:26:07.606]                       if (!is.null(pattern)) {
[10:26:07.606]                         computeRestarts <- base::computeRestarts
[10:26:07.606]                         grepl <- base::grepl
[10:26:07.606]                         restarts <- computeRestarts(cond)
[10:26:07.606]                         for (restart in restarts) {
[10:26:07.606]                           name <- restart$name
[10:26:07.606]                           if (is.null(name)) 
[10:26:07.606]                             next
[10:26:07.606]                           if (!grepl(pattern, name)) 
[10:26:07.606]                             next
[10:26:07.606]                           invokeRestart(restart)
[10:26:07.606]                           muffled <- TRUE
[10:26:07.606]                           break
[10:26:07.606]                         }
[10:26:07.606]                       }
[10:26:07.606]                     }
[10:26:07.606]                     invisible(muffled)
[10:26:07.606]                   }
[10:26:07.606]                   muffleCondition(cond)
[10:26:07.606]                 })
[10:26:07.606]             }))
[10:26:07.606]             future::FutureResult(value = ...future.value$value, 
[10:26:07.606]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.606]                   ...future.rng), globalenv = if (FALSE) 
[10:26:07.606]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:07.606]                     ...future.globalenv.names))
[10:26:07.606]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:07.606]         }, condition = base::local({
[10:26:07.606]             c <- base::c
[10:26:07.606]             inherits <- base::inherits
[10:26:07.606]             invokeRestart <- base::invokeRestart
[10:26:07.606]             length <- base::length
[10:26:07.606]             list <- base::list
[10:26:07.606]             seq.int <- base::seq.int
[10:26:07.606]             signalCondition <- base::signalCondition
[10:26:07.606]             sys.calls <- base::sys.calls
[10:26:07.606]             `[[` <- base::`[[`
[10:26:07.606]             `+` <- base::`+`
[10:26:07.606]             `<<-` <- base::`<<-`
[10:26:07.606]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:07.606]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:07.606]                   3L)]
[10:26:07.606]             }
[10:26:07.606]             function(cond) {
[10:26:07.606]                 is_error <- inherits(cond, "error")
[10:26:07.606]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:07.606]                   NULL)
[10:26:07.606]                 if (is_error) {
[10:26:07.606]                   sessionInformation <- function() {
[10:26:07.606]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:07.606]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:07.606]                       search = base::search(), system = base::Sys.info())
[10:26:07.606]                   }
[10:26:07.606]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.606]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:07.606]                     cond$call), session = sessionInformation(), 
[10:26:07.606]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:07.606]                   signalCondition(cond)
[10:26:07.606]                 }
[10:26:07.606]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:07.606]                 "immediateCondition"))) {
[10:26:07.606]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:07.606]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.606]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:07.606]                   if (TRUE && !signal) {
[10:26:07.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.606]                     {
[10:26:07.606]                       inherits <- base::inherits
[10:26:07.606]                       invokeRestart <- base::invokeRestart
[10:26:07.606]                       is.null <- base::is.null
[10:26:07.606]                       muffled <- FALSE
[10:26:07.606]                       if (inherits(cond, "message")) {
[10:26:07.606]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.606]                         if (muffled) 
[10:26:07.606]                           invokeRestart("muffleMessage")
[10:26:07.606]                       }
[10:26:07.606]                       else if (inherits(cond, "warning")) {
[10:26:07.606]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.606]                         if (muffled) 
[10:26:07.606]                           invokeRestart("muffleWarning")
[10:26:07.606]                       }
[10:26:07.606]                       else if (inherits(cond, "condition")) {
[10:26:07.606]                         if (!is.null(pattern)) {
[10:26:07.606]                           computeRestarts <- base::computeRestarts
[10:26:07.606]                           grepl <- base::grepl
[10:26:07.606]                           restarts <- computeRestarts(cond)
[10:26:07.606]                           for (restart in restarts) {
[10:26:07.606]                             name <- restart$name
[10:26:07.606]                             if (is.null(name)) 
[10:26:07.606]                               next
[10:26:07.606]                             if (!grepl(pattern, name)) 
[10:26:07.606]                               next
[10:26:07.606]                             invokeRestart(restart)
[10:26:07.606]                             muffled <- TRUE
[10:26:07.606]                             break
[10:26:07.606]                           }
[10:26:07.606]                         }
[10:26:07.606]                       }
[10:26:07.606]                       invisible(muffled)
[10:26:07.606]                     }
[10:26:07.606]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.606]                   }
[10:26:07.606]                 }
[10:26:07.606]                 else {
[10:26:07.606]                   if (TRUE) {
[10:26:07.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.606]                     {
[10:26:07.606]                       inherits <- base::inherits
[10:26:07.606]                       invokeRestart <- base::invokeRestart
[10:26:07.606]                       is.null <- base::is.null
[10:26:07.606]                       muffled <- FALSE
[10:26:07.606]                       if (inherits(cond, "message")) {
[10:26:07.606]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.606]                         if (muffled) 
[10:26:07.606]                           invokeRestart("muffleMessage")
[10:26:07.606]                       }
[10:26:07.606]                       else if (inherits(cond, "warning")) {
[10:26:07.606]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.606]                         if (muffled) 
[10:26:07.606]                           invokeRestart("muffleWarning")
[10:26:07.606]                       }
[10:26:07.606]                       else if (inherits(cond, "condition")) {
[10:26:07.606]                         if (!is.null(pattern)) {
[10:26:07.606]                           computeRestarts <- base::computeRestarts
[10:26:07.606]                           grepl <- base::grepl
[10:26:07.606]                           restarts <- computeRestarts(cond)
[10:26:07.606]                           for (restart in restarts) {
[10:26:07.606]                             name <- restart$name
[10:26:07.606]                             if (is.null(name)) 
[10:26:07.606]                               next
[10:26:07.606]                             if (!grepl(pattern, name)) 
[10:26:07.606]                               next
[10:26:07.606]                             invokeRestart(restart)
[10:26:07.606]                             muffled <- TRUE
[10:26:07.606]                             break
[10:26:07.606]                           }
[10:26:07.606]                         }
[10:26:07.606]                       }
[10:26:07.606]                       invisible(muffled)
[10:26:07.606]                     }
[10:26:07.606]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.606]                   }
[10:26:07.606]                 }
[10:26:07.606]             }
[10:26:07.606]         }))
[10:26:07.606]     }, error = function(ex) {
[10:26:07.606]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:07.606]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.606]                 ...future.rng), started = ...future.startTime, 
[10:26:07.606]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:07.606]             version = "1.8"), class = "FutureResult")
[10:26:07.606]     }, finally = {
[10:26:07.606]         if (!identical(...future.workdir, getwd())) 
[10:26:07.606]             setwd(...future.workdir)
[10:26:07.606]         {
[10:26:07.606]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:07.606]                 ...future.oldOptions$nwarnings <- NULL
[10:26:07.606]             }
[10:26:07.606]             base::options(...future.oldOptions)
[10:26:07.606]             if (.Platform$OS.type == "windows") {
[10:26:07.606]                 old_names <- names(...future.oldEnvVars)
[10:26:07.606]                 envs <- base::Sys.getenv()
[10:26:07.606]                 names <- names(envs)
[10:26:07.606]                 common <- intersect(names, old_names)
[10:26:07.606]                 added <- setdiff(names, old_names)
[10:26:07.606]                 removed <- setdiff(old_names, names)
[10:26:07.606]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:07.606]                   envs[common]]
[10:26:07.606]                 NAMES <- toupper(changed)
[10:26:07.606]                 args <- list()
[10:26:07.606]                 for (kk in seq_along(NAMES)) {
[10:26:07.606]                   name <- changed[[kk]]
[10:26:07.606]                   NAME <- NAMES[[kk]]
[10:26:07.606]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.606]                     next
[10:26:07.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.606]                 }
[10:26:07.606]                 NAMES <- toupper(added)
[10:26:07.606]                 for (kk in seq_along(NAMES)) {
[10:26:07.606]                   name <- added[[kk]]
[10:26:07.606]                   NAME <- NAMES[[kk]]
[10:26:07.606]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.606]                     next
[10:26:07.606]                   args[[name]] <- ""
[10:26:07.606]                 }
[10:26:07.606]                 NAMES <- toupper(removed)
[10:26:07.606]                 for (kk in seq_along(NAMES)) {
[10:26:07.606]                   name <- removed[[kk]]
[10:26:07.606]                   NAME <- NAMES[[kk]]
[10:26:07.606]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.606]                     next
[10:26:07.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.606]                 }
[10:26:07.606]                 if (length(args) > 0) 
[10:26:07.606]                   base::do.call(base::Sys.setenv, args = args)
[10:26:07.606]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:07.606]             }
[10:26:07.606]             else {
[10:26:07.606]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:07.606]             }
[10:26:07.606]             {
[10:26:07.606]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:07.606]                   0L) {
[10:26:07.606]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:07.606]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:07.606]                   base::options(opts)
[10:26:07.606]                 }
[10:26:07.606]                 {
[10:26:07.606]                   {
[10:26:07.606]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:07.606]                     NULL
[10:26:07.606]                   }
[10:26:07.606]                   options(future.plan = NULL)
[10:26:07.606]                   if (is.na(NA_character_)) 
[10:26:07.606]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.606]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:07.606]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:07.606]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:07.606]                     envir = parent.frame()) 
[10:26:07.606]                   {
[10:26:07.606]                     if (is.function(workers)) 
[10:26:07.606]                       workers <- workers()
[10:26:07.606]                     workers <- structure(as.integer(workers), 
[10:26:07.606]                       class = class(workers))
[10:26:07.606]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:07.606]                       workers >= 1)
[10:26:07.606]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:07.606]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:07.606]                     }
[10:26:07.606]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:07.606]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:07.606]                       envir = envir)
[10:26:07.606]                     if (!future$lazy) 
[10:26:07.606]                       future <- run(future)
[10:26:07.606]                     invisible(future)
[10:26:07.606]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:07.606]                 }
[10:26:07.606]             }
[10:26:07.606]         }
[10:26:07.606]     })
[10:26:07.606]     if (TRUE) {
[10:26:07.606]         base::sink(type = "output", split = FALSE)
[10:26:07.606]         if (TRUE) {
[10:26:07.606]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:07.606]         }
[10:26:07.606]         else {
[10:26:07.606]             ...future.result["stdout"] <- base::list(NULL)
[10:26:07.606]         }
[10:26:07.606]         base::close(...future.stdout)
[10:26:07.606]         ...future.stdout <- NULL
[10:26:07.606]     }
[10:26:07.606]     ...future.result$conditions <- ...future.conditions
[10:26:07.606]     ...future.result$finished <- base::Sys.time()
[10:26:07.606]     ...future.result
[10:26:07.606] }
[10:26:07.609] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:26:07.609] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:26:07.610] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:26:07.610] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:26:07.611] MultisessionFuture started
[10:26:07.611] - Launch lazy future ... done
[10:26:07.611] run() for ‘MultisessionFuture’ ... done
[10:26:07.611] result() for ClusterFuture ...
[10:26:07.611] receiveMessageFromWorker() for ClusterFuture ...
[10:26:07.611] - Validating connection of MultisessionFuture
[10:26:07.658] - received message: FutureResult
[10:26:07.658] - Received FutureResult
[10:26:07.658] - Erased future from FutureRegistry
[10:26:07.658] result() for ClusterFuture ...
[10:26:07.659] - result already collected: FutureResult
[10:26:07.659] result() for ClusterFuture ... done
[10:26:07.659] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:07.659] result() for ClusterFuture ... done
[10:26:07.659] result() for ClusterFuture ...
[10:26:07.659] - result already collected: FutureResult
[10:26:07.659] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:07.660] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:07.660] Searching for globals...
[10:26:07.662] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:07.662] Searching for globals ... DONE
[10:26:07.663] Resolving globals: TRUE
[10:26:07.663] Resolving any globals that are futures ...
[10:26:07.663] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:07.663] Resolving any globals that are futures ... DONE
[10:26:07.663] Resolving futures part of globals (recursively) ...
[10:26:07.664] resolve() on list ...
[10:26:07.664]  recursive: 99
[10:26:07.664]  length: 1
[10:26:07.664]  elements: ‘x’
[10:26:07.664]  length: 0 (resolved future 1)
[10:26:07.664] resolve() on list ... DONE
[10:26:07.664] - globals: [1] ‘x’
[10:26:07.665] Resolving futures part of globals (recursively) ... DONE
[10:26:07.665] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:07.665] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:07.665] - globals: [1] ‘x’
[10:26:07.665] 
[10:26:07.666] getGlobalsAndPackages() ... DONE
[10:26:07.666] run() for ‘Future’ ...
[10:26:07.666] - state: ‘created’
[10:26:07.666] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:07.680] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:07.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:07.681]   - Field: ‘node’
[10:26:07.681]   - Field: ‘label’
[10:26:07.681]   - Field: ‘local’
[10:26:07.681]   - Field: ‘owner’
[10:26:07.681]   - Field: ‘envir’
[10:26:07.681]   - Field: ‘workers’
[10:26:07.681]   - Field: ‘packages’
[10:26:07.681]   - Field: ‘gc’
[10:26:07.682]   - Field: ‘conditions’
[10:26:07.682]   - Field: ‘persistent’
[10:26:07.682]   - Field: ‘expr’
[10:26:07.682]   - Field: ‘uuid’
[10:26:07.682]   - Field: ‘seed’
[10:26:07.682]   - Field: ‘version’
[10:26:07.682]   - Field: ‘result’
[10:26:07.682]   - Field: ‘asynchronous’
[10:26:07.682]   - Field: ‘calls’
[10:26:07.683]   - Field: ‘globals’
[10:26:07.683]   - Field: ‘stdout’
[10:26:07.683]   - Field: ‘earlySignal’
[10:26:07.683]   - Field: ‘lazy’
[10:26:07.683]   - Field: ‘state’
[10:26:07.683] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:07.683] - Launch lazy future ...
[10:26:07.684] Packages needed by the future expression (n = 0): <none>
[10:26:07.684] Packages needed by future strategies (n = 0): <none>
[10:26:07.684] {
[10:26:07.684]     {
[10:26:07.684]         {
[10:26:07.684]             ...future.startTime <- base::Sys.time()
[10:26:07.684]             {
[10:26:07.684]                 {
[10:26:07.684]                   {
[10:26:07.684]                     {
[10:26:07.684]                       base::local({
[10:26:07.684]                         has_future <- base::requireNamespace("future", 
[10:26:07.684]                           quietly = TRUE)
[10:26:07.684]                         if (has_future) {
[10:26:07.684]                           ns <- base::getNamespace("future")
[10:26:07.684]                           version <- ns[[".package"]][["version"]]
[10:26:07.684]                           if (is.null(version)) 
[10:26:07.684]                             version <- utils::packageVersion("future")
[10:26:07.684]                         }
[10:26:07.684]                         else {
[10:26:07.684]                           version <- NULL
[10:26:07.684]                         }
[10:26:07.684]                         if (!has_future || version < "1.8.0") {
[10:26:07.684]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:07.684]                             "", base::R.version$version.string), 
[10:26:07.684]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:07.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:07.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:07.684]                               "release", "version")], collapse = " "), 
[10:26:07.684]                             hostname = base::Sys.info()[["nodename"]])
[10:26:07.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:07.684]                             info)
[10:26:07.684]                           info <- base::paste(info, collapse = "; ")
[10:26:07.684]                           if (!has_future) {
[10:26:07.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:07.684]                               info)
[10:26:07.684]                           }
[10:26:07.684]                           else {
[10:26:07.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:07.684]                               info, version)
[10:26:07.684]                           }
[10:26:07.684]                           base::stop(msg)
[10:26:07.684]                         }
[10:26:07.684]                       })
[10:26:07.684]                     }
[10:26:07.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:07.684]                     base::options(mc.cores = 1L)
[10:26:07.684]                   }
[10:26:07.684]                   options(future.plan = NULL)
[10:26:07.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:07.684]                 }
[10:26:07.684]                 ...future.workdir <- getwd()
[10:26:07.684]             }
[10:26:07.684]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:07.684]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:07.684]         }
[10:26:07.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:07.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:07.684]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:07.684]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:07.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:07.684]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:07.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:07.684]             base::names(...future.oldOptions))
[10:26:07.684]     }
[10:26:07.684]     if (FALSE) {
[10:26:07.684]     }
[10:26:07.684]     else {
[10:26:07.684]         if (TRUE) {
[10:26:07.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:07.684]                 open = "w")
[10:26:07.684]         }
[10:26:07.684]         else {
[10:26:07.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:07.684]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:07.684]         }
[10:26:07.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:07.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:07.684]             base::sink(type = "output", split = FALSE)
[10:26:07.684]             base::close(...future.stdout)
[10:26:07.684]         }, add = TRUE)
[10:26:07.684]     }
[10:26:07.684]     ...future.frame <- base::sys.nframe()
[10:26:07.684]     ...future.conditions <- base::list()
[10:26:07.684]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:07.684]     if (FALSE) {
[10:26:07.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:07.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:07.684]     }
[10:26:07.684]     ...future.result <- base::tryCatch({
[10:26:07.684]         base::withCallingHandlers({
[10:26:07.684]             ...future.value <- base::withVisible(base::local({
[10:26:07.684]                 ...future.makeSendCondition <- base::local({
[10:26:07.684]                   sendCondition <- NULL
[10:26:07.684]                   function(frame = 1L) {
[10:26:07.684]                     if (is.function(sendCondition)) 
[10:26:07.684]                       return(sendCondition)
[10:26:07.684]                     ns <- getNamespace("parallel")
[10:26:07.684]                     if (exists("sendData", mode = "function", 
[10:26:07.684]                       envir = ns)) {
[10:26:07.684]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:07.684]                         envir = ns)
[10:26:07.684]                       envir <- sys.frame(frame)
[10:26:07.684]                       master <- NULL
[10:26:07.684]                       while (!identical(envir, .GlobalEnv) && 
[10:26:07.684]                         !identical(envir, emptyenv())) {
[10:26:07.684]                         if (exists("master", mode = "list", envir = envir, 
[10:26:07.684]                           inherits = FALSE)) {
[10:26:07.684]                           master <- get("master", mode = "list", 
[10:26:07.684]                             envir = envir, inherits = FALSE)
[10:26:07.684]                           if (inherits(master, c("SOCKnode", 
[10:26:07.684]                             "SOCK0node"))) {
[10:26:07.684]                             sendCondition <<- function(cond) {
[10:26:07.684]                               data <- list(type = "VALUE", value = cond, 
[10:26:07.684]                                 success = TRUE)
[10:26:07.684]                               parallel_sendData(master, data)
[10:26:07.684]                             }
[10:26:07.684]                             return(sendCondition)
[10:26:07.684]                           }
[10:26:07.684]                         }
[10:26:07.684]                         frame <- frame + 1L
[10:26:07.684]                         envir <- sys.frame(frame)
[10:26:07.684]                       }
[10:26:07.684]                     }
[10:26:07.684]                     sendCondition <<- function(cond) NULL
[10:26:07.684]                   }
[10:26:07.684]                 })
[10:26:07.684]                 withCallingHandlers({
[10:26:07.684]                   {
[10:26:07.684]                     x$a <- 1
[10:26:07.684]                     x
[10:26:07.684]                   }
[10:26:07.684]                 }, immediateCondition = function(cond) {
[10:26:07.684]                   sendCondition <- ...future.makeSendCondition()
[10:26:07.684]                   sendCondition(cond)
[10:26:07.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.684]                   {
[10:26:07.684]                     inherits <- base::inherits
[10:26:07.684]                     invokeRestart <- base::invokeRestart
[10:26:07.684]                     is.null <- base::is.null
[10:26:07.684]                     muffled <- FALSE
[10:26:07.684]                     if (inherits(cond, "message")) {
[10:26:07.684]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:07.684]                       if (muffled) 
[10:26:07.684]                         invokeRestart("muffleMessage")
[10:26:07.684]                     }
[10:26:07.684]                     else if (inherits(cond, "warning")) {
[10:26:07.684]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:07.684]                       if (muffled) 
[10:26:07.684]                         invokeRestart("muffleWarning")
[10:26:07.684]                     }
[10:26:07.684]                     else if (inherits(cond, "condition")) {
[10:26:07.684]                       if (!is.null(pattern)) {
[10:26:07.684]                         computeRestarts <- base::computeRestarts
[10:26:07.684]                         grepl <- base::grepl
[10:26:07.684]                         restarts <- computeRestarts(cond)
[10:26:07.684]                         for (restart in restarts) {
[10:26:07.684]                           name <- restart$name
[10:26:07.684]                           if (is.null(name)) 
[10:26:07.684]                             next
[10:26:07.684]                           if (!grepl(pattern, name)) 
[10:26:07.684]                             next
[10:26:07.684]                           invokeRestart(restart)
[10:26:07.684]                           muffled <- TRUE
[10:26:07.684]                           break
[10:26:07.684]                         }
[10:26:07.684]                       }
[10:26:07.684]                     }
[10:26:07.684]                     invisible(muffled)
[10:26:07.684]                   }
[10:26:07.684]                   muffleCondition(cond)
[10:26:07.684]                 })
[10:26:07.684]             }))
[10:26:07.684]             future::FutureResult(value = ...future.value$value, 
[10:26:07.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.684]                   ...future.rng), globalenv = if (FALSE) 
[10:26:07.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:07.684]                     ...future.globalenv.names))
[10:26:07.684]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:07.684]         }, condition = base::local({
[10:26:07.684]             c <- base::c
[10:26:07.684]             inherits <- base::inherits
[10:26:07.684]             invokeRestart <- base::invokeRestart
[10:26:07.684]             length <- base::length
[10:26:07.684]             list <- base::list
[10:26:07.684]             seq.int <- base::seq.int
[10:26:07.684]             signalCondition <- base::signalCondition
[10:26:07.684]             sys.calls <- base::sys.calls
[10:26:07.684]             `[[` <- base::`[[`
[10:26:07.684]             `+` <- base::`+`
[10:26:07.684]             `<<-` <- base::`<<-`
[10:26:07.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:07.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:07.684]                   3L)]
[10:26:07.684]             }
[10:26:07.684]             function(cond) {
[10:26:07.684]                 is_error <- inherits(cond, "error")
[10:26:07.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:07.684]                   NULL)
[10:26:07.684]                 if (is_error) {
[10:26:07.684]                   sessionInformation <- function() {
[10:26:07.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:07.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:07.684]                       search = base::search(), system = base::Sys.info())
[10:26:07.684]                   }
[10:26:07.684]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:07.684]                     cond$call), session = sessionInformation(), 
[10:26:07.684]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:07.684]                   signalCondition(cond)
[10:26:07.684]                 }
[10:26:07.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:07.684]                 "immediateCondition"))) {
[10:26:07.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:07.684]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:07.684]                   if (TRUE && !signal) {
[10:26:07.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.684]                     {
[10:26:07.684]                       inherits <- base::inherits
[10:26:07.684]                       invokeRestart <- base::invokeRestart
[10:26:07.684]                       is.null <- base::is.null
[10:26:07.684]                       muffled <- FALSE
[10:26:07.684]                       if (inherits(cond, "message")) {
[10:26:07.684]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.684]                         if (muffled) 
[10:26:07.684]                           invokeRestart("muffleMessage")
[10:26:07.684]                       }
[10:26:07.684]                       else if (inherits(cond, "warning")) {
[10:26:07.684]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.684]                         if (muffled) 
[10:26:07.684]                           invokeRestart("muffleWarning")
[10:26:07.684]                       }
[10:26:07.684]                       else if (inherits(cond, "condition")) {
[10:26:07.684]                         if (!is.null(pattern)) {
[10:26:07.684]                           computeRestarts <- base::computeRestarts
[10:26:07.684]                           grepl <- base::grepl
[10:26:07.684]                           restarts <- computeRestarts(cond)
[10:26:07.684]                           for (restart in restarts) {
[10:26:07.684]                             name <- restart$name
[10:26:07.684]                             if (is.null(name)) 
[10:26:07.684]                               next
[10:26:07.684]                             if (!grepl(pattern, name)) 
[10:26:07.684]                               next
[10:26:07.684]                             invokeRestart(restart)
[10:26:07.684]                             muffled <- TRUE
[10:26:07.684]                             break
[10:26:07.684]                           }
[10:26:07.684]                         }
[10:26:07.684]                       }
[10:26:07.684]                       invisible(muffled)
[10:26:07.684]                     }
[10:26:07.684]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.684]                   }
[10:26:07.684]                 }
[10:26:07.684]                 else {
[10:26:07.684]                   if (TRUE) {
[10:26:07.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.684]                     {
[10:26:07.684]                       inherits <- base::inherits
[10:26:07.684]                       invokeRestart <- base::invokeRestart
[10:26:07.684]                       is.null <- base::is.null
[10:26:07.684]                       muffled <- FALSE
[10:26:07.684]                       if (inherits(cond, "message")) {
[10:26:07.684]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.684]                         if (muffled) 
[10:26:07.684]                           invokeRestart("muffleMessage")
[10:26:07.684]                       }
[10:26:07.684]                       else if (inherits(cond, "warning")) {
[10:26:07.684]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.684]                         if (muffled) 
[10:26:07.684]                           invokeRestart("muffleWarning")
[10:26:07.684]                       }
[10:26:07.684]                       else if (inherits(cond, "condition")) {
[10:26:07.684]                         if (!is.null(pattern)) {
[10:26:07.684]                           computeRestarts <- base::computeRestarts
[10:26:07.684]                           grepl <- base::grepl
[10:26:07.684]                           restarts <- computeRestarts(cond)
[10:26:07.684]                           for (restart in restarts) {
[10:26:07.684]                             name <- restart$name
[10:26:07.684]                             if (is.null(name)) 
[10:26:07.684]                               next
[10:26:07.684]                             if (!grepl(pattern, name)) 
[10:26:07.684]                               next
[10:26:07.684]                             invokeRestart(restart)
[10:26:07.684]                             muffled <- TRUE
[10:26:07.684]                             break
[10:26:07.684]                           }
[10:26:07.684]                         }
[10:26:07.684]                       }
[10:26:07.684]                       invisible(muffled)
[10:26:07.684]                     }
[10:26:07.684]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.684]                   }
[10:26:07.684]                 }
[10:26:07.684]             }
[10:26:07.684]         }))
[10:26:07.684]     }, error = function(ex) {
[10:26:07.684]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:07.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.684]                 ...future.rng), started = ...future.startTime, 
[10:26:07.684]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:07.684]             version = "1.8"), class = "FutureResult")
[10:26:07.684]     }, finally = {
[10:26:07.684]         if (!identical(...future.workdir, getwd())) 
[10:26:07.684]             setwd(...future.workdir)
[10:26:07.684]         {
[10:26:07.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:07.684]                 ...future.oldOptions$nwarnings <- NULL
[10:26:07.684]             }
[10:26:07.684]             base::options(...future.oldOptions)
[10:26:07.684]             if (.Platform$OS.type == "windows") {
[10:26:07.684]                 old_names <- names(...future.oldEnvVars)
[10:26:07.684]                 envs <- base::Sys.getenv()
[10:26:07.684]                 names <- names(envs)
[10:26:07.684]                 common <- intersect(names, old_names)
[10:26:07.684]                 added <- setdiff(names, old_names)
[10:26:07.684]                 removed <- setdiff(old_names, names)
[10:26:07.684]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:07.684]                   envs[common]]
[10:26:07.684]                 NAMES <- toupper(changed)
[10:26:07.684]                 args <- list()
[10:26:07.684]                 for (kk in seq_along(NAMES)) {
[10:26:07.684]                   name <- changed[[kk]]
[10:26:07.684]                   NAME <- NAMES[[kk]]
[10:26:07.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.684]                     next
[10:26:07.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.684]                 }
[10:26:07.684]                 NAMES <- toupper(added)
[10:26:07.684]                 for (kk in seq_along(NAMES)) {
[10:26:07.684]                   name <- added[[kk]]
[10:26:07.684]                   NAME <- NAMES[[kk]]
[10:26:07.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.684]                     next
[10:26:07.684]                   args[[name]] <- ""
[10:26:07.684]                 }
[10:26:07.684]                 NAMES <- toupper(removed)
[10:26:07.684]                 for (kk in seq_along(NAMES)) {
[10:26:07.684]                   name <- removed[[kk]]
[10:26:07.684]                   NAME <- NAMES[[kk]]
[10:26:07.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.684]                     next
[10:26:07.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.684]                 }
[10:26:07.684]                 if (length(args) > 0) 
[10:26:07.684]                   base::do.call(base::Sys.setenv, args = args)
[10:26:07.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:07.684]             }
[10:26:07.684]             else {
[10:26:07.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:07.684]             }
[10:26:07.684]             {
[10:26:07.684]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:07.684]                   0L) {
[10:26:07.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:07.684]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:07.684]                   base::options(opts)
[10:26:07.684]                 }
[10:26:07.684]                 {
[10:26:07.684]                   {
[10:26:07.684]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:07.684]                     NULL
[10:26:07.684]                   }
[10:26:07.684]                   options(future.plan = NULL)
[10:26:07.684]                   if (is.na(NA_character_)) 
[10:26:07.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:07.684]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:07.684]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:07.684]                     envir = parent.frame()) 
[10:26:07.684]                   {
[10:26:07.684]                     if (is.function(workers)) 
[10:26:07.684]                       workers <- workers()
[10:26:07.684]                     workers <- structure(as.integer(workers), 
[10:26:07.684]                       class = class(workers))
[10:26:07.684]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:07.684]                       workers >= 1)
[10:26:07.684]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:07.684]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:07.684]                     }
[10:26:07.684]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:07.684]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:07.684]                       envir = envir)
[10:26:07.684]                     if (!future$lazy) 
[10:26:07.684]                       future <- run(future)
[10:26:07.684]                     invisible(future)
[10:26:07.684]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:07.684]                 }
[10:26:07.684]             }
[10:26:07.684]         }
[10:26:07.684]     })
[10:26:07.684]     if (TRUE) {
[10:26:07.684]         base::sink(type = "output", split = FALSE)
[10:26:07.684]         if (TRUE) {
[10:26:07.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:07.684]         }
[10:26:07.684]         else {
[10:26:07.684]             ...future.result["stdout"] <- base::list(NULL)
[10:26:07.684]         }
[10:26:07.684]         base::close(...future.stdout)
[10:26:07.684]         ...future.stdout <- NULL
[10:26:07.684]     }
[10:26:07.684]     ...future.result$conditions <- ...future.conditions
[10:26:07.684]     ...future.result$finished <- base::Sys.time()
[10:26:07.684]     ...future.result
[10:26:07.684] }
[10:26:07.687] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:26:07.687] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:26:07.688] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:26:07.688] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:26:07.688] MultisessionFuture started
[10:26:07.689] - Launch lazy future ... done
[10:26:07.689] run() for ‘MultisessionFuture’ ... done
[10:26:07.689] result() for ClusterFuture ...
[10:26:07.689] receiveMessageFromWorker() for ClusterFuture ...
[10:26:07.689] - Validating connection of MultisessionFuture
[10:26:07.734] - received message: FutureResult
[10:26:07.734] - Received FutureResult
[10:26:07.734] - Erased future from FutureRegistry
[10:26:07.734] result() for ClusterFuture ...
[10:26:07.734] - result already collected: FutureResult
[10:26:07.735] result() for ClusterFuture ... done
[10:26:07.735] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:07.735] result() for ClusterFuture ... done
[10:26:07.735] result() for ClusterFuture ...
[10:26:07.735] - result already collected: FutureResult
[10:26:07.735] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:07.736] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:07.736] Searching for globals...
[10:26:07.738] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:07.738] Searching for globals ... DONE
[10:26:07.739] Resolving globals: TRUE
[10:26:07.739] Resolving any globals that are futures ...
[10:26:07.739] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:07.739] Resolving any globals that are futures ... DONE
[10:26:07.739] Resolving futures part of globals (recursively) ...
[10:26:07.740] resolve() on list ...
[10:26:07.740]  recursive: 99
[10:26:07.740]  length: 1
[10:26:07.740]  elements: ‘x’
[10:26:07.740]  length: 0 (resolved future 1)
[10:26:07.740] resolve() on list ... DONE
[10:26:07.740] - globals: [1] ‘x’
[10:26:07.741] Resolving futures part of globals (recursively) ... DONE
[10:26:07.741] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:07.741] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:07.741] - globals: [1] ‘x’
[10:26:07.741] 
[10:26:07.742] getGlobalsAndPackages() ... DONE
[10:26:07.742] run() for ‘Future’ ...
[10:26:07.742] - state: ‘created’
[10:26:07.742] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:07.760] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:07.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:07.760]   - Field: ‘node’
[10:26:07.760]   - Field: ‘label’
[10:26:07.760]   - Field: ‘local’
[10:26:07.760]   - Field: ‘owner’
[10:26:07.760]   - Field: ‘envir’
[10:26:07.761]   - Field: ‘workers’
[10:26:07.761]   - Field: ‘packages’
[10:26:07.761]   - Field: ‘gc’
[10:26:07.761]   - Field: ‘conditions’
[10:26:07.761]   - Field: ‘persistent’
[10:26:07.761]   - Field: ‘expr’
[10:26:07.761]   - Field: ‘uuid’
[10:26:07.761]   - Field: ‘seed’
[10:26:07.761]   - Field: ‘version’
[10:26:07.761]   - Field: ‘result’
[10:26:07.762]   - Field: ‘asynchronous’
[10:26:07.762]   - Field: ‘calls’
[10:26:07.762]   - Field: ‘globals’
[10:26:07.762]   - Field: ‘stdout’
[10:26:07.762]   - Field: ‘earlySignal’
[10:26:07.762]   - Field: ‘lazy’
[10:26:07.762]   - Field: ‘state’
[10:26:07.762] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:07.762] - Launch lazy future ...
[10:26:07.763] Packages needed by the future expression (n = 0): <none>
[10:26:07.763] Packages needed by future strategies (n = 0): <none>
[10:26:07.763] {
[10:26:07.763]     {
[10:26:07.763]         {
[10:26:07.763]             ...future.startTime <- base::Sys.time()
[10:26:07.763]             {
[10:26:07.763]                 {
[10:26:07.763]                   {
[10:26:07.763]                     {
[10:26:07.763]                       base::local({
[10:26:07.763]                         has_future <- base::requireNamespace("future", 
[10:26:07.763]                           quietly = TRUE)
[10:26:07.763]                         if (has_future) {
[10:26:07.763]                           ns <- base::getNamespace("future")
[10:26:07.763]                           version <- ns[[".package"]][["version"]]
[10:26:07.763]                           if (is.null(version)) 
[10:26:07.763]                             version <- utils::packageVersion("future")
[10:26:07.763]                         }
[10:26:07.763]                         else {
[10:26:07.763]                           version <- NULL
[10:26:07.763]                         }
[10:26:07.763]                         if (!has_future || version < "1.8.0") {
[10:26:07.763]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:07.763]                             "", base::R.version$version.string), 
[10:26:07.763]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:07.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:07.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:07.763]                               "release", "version")], collapse = " "), 
[10:26:07.763]                             hostname = base::Sys.info()[["nodename"]])
[10:26:07.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:07.763]                             info)
[10:26:07.763]                           info <- base::paste(info, collapse = "; ")
[10:26:07.763]                           if (!has_future) {
[10:26:07.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:07.763]                               info)
[10:26:07.763]                           }
[10:26:07.763]                           else {
[10:26:07.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:07.763]                               info, version)
[10:26:07.763]                           }
[10:26:07.763]                           base::stop(msg)
[10:26:07.763]                         }
[10:26:07.763]                       })
[10:26:07.763]                     }
[10:26:07.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:07.763]                     base::options(mc.cores = 1L)
[10:26:07.763]                   }
[10:26:07.763]                   options(future.plan = NULL)
[10:26:07.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:07.763]                 }
[10:26:07.763]                 ...future.workdir <- getwd()
[10:26:07.763]             }
[10:26:07.763]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:07.763]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:07.763]         }
[10:26:07.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:07.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:07.763]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:07.763]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:07.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:07.763]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:07.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:07.763]             base::names(...future.oldOptions))
[10:26:07.763]     }
[10:26:07.763]     if (FALSE) {
[10:26:07.763]     }
[10:26:07.763]     else {
[10:26:07.763]         if (TRUE) {
[10:26:07.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:07.763]                 open = "w")
[10:26:07.763]         }
[10:26:07.763]         else {
[10:26:07.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:07.763]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:07.763]         }
[10:26:07.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:07.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:07.763]             base::sink(type = "output", split = FALSE)
[10:26:07.763]             base::close(...future.stdout)
[10:26:07.763]         }, add = TRUE)
[10:26:07.763]     }
[10:26:07.763]     ...future.frame <- base::sys.nframe()
[10:26:07.763]     ...future.conditions <- base::list()
[10:26:07.763]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:07.763]     if (FALSE) {
[10:26:07.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:07.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:07.763]     }
[10:26:07.763]     ...future.result <- base::tryCatch({
[10:26:07.763]         base::withCallingHandlers({
[10:26:07.763]             ...future.value <- base::withVisible(base::local({
[10:26:07.763]                 ...future.makeSendCondition <- base::local({
[10:26:07.763]                   sendCondition <- NULL
[10:26:07.763]                   function(frame = 1L) {
[10:26:07.763]                     if (is.function(sendCondition)) 
[10:26:07.763]                       return(sendCondition)
[10:26:07.763]                     ns <- getNamespace("parallel")
[10:26:07.763]                     if (exists("sendData", mode = "function", 
[10:26:07.763]                       envir = ns)) {
[10:26:07.763]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:07.763]                         envir = ns)
[10:26:07.763]                       envir <- sys.frame(frame)
[10:26:07.763]                       master <- NULL
[10:26:07.763]                       while (!identical(envir, .GlobalEnv) && 
[10:26:07.763]                         !identical(envir, emptyenv())) {
[10:26:07.763]                         if (exists("master", mode = "list", envir = envir, 
[10:26:07.763]                           inherits = FALSE)) {
[10:26:07.763]                           master <- get("master", mode = "list", 
[10:26:07.763]                             envir = envir, inherits = FALSE)
[10:26:07.763]                           if (inherits(master, c("SOCKnode", 
[10:26:07.763]                             "SOCK0node"))) {
[10:26:07.763]                             sendCondition <<- function(cond) {
[10:26:07.763]                               data <- list(type = "VALUE", value = cond, 
[10:26:07.763]                                 success = TRUE)
[10:26:07.763]                               parallel_sendData(master, data)
[10:26:07.763]                             }
[10:26:07.763]                             return(sendCondition)
[10:26:07.763]                           }
[10:26:07.763]                         }
[10:26:07.763]                         frame <- frame + 1L
[10:26:07.763]                         envir <- sys.frame(frame)
[10:26:07.763]                       }
[10:26:07.763]                     }
[10:26:07.763]                     sendCondition <<- function(cond) NULL
[10:26:07.763]                   }
[10:26:07.763]                 })
[10:26:07.763]                 withCallingHandlers({
[10:26:07.763]                   {
[10:26:07.763]                     x$a <- 1
[10:26:07.763]                     x
[10:26:07.763]                   }
[10:26:07.763]                 }, immediateCondition = function(cond) {
[10:26:07.763]                   sendCondition <- ...future.makeSendCondition()
[10:26:07.763]                   sendCondition(cond)
[10:26:07.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.763]                   {
[10:26:07.763]                     inherits <- base::inherits
[10:26:07.763]                     invokeRestart <- base::invokeRestart
[10:26:07.763]                     is.null <- base::is.null
[10:26:07.763]                     muffled <- FALSE
[10:26:07.763]                     if (inherits(cond, "message")) {
[10:26:07.763]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:07.763]                       if (muffled) 
[10:26:07.763]                         invokeRestart("muffleMessage")
[10:26:07.763]                     }
[10:26:07.763]                     else if (inherits(cond, "warning")) {
[10:26:07.763]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:07.763]                       if (muffled) 
[10:26:07.763]                         invokeRestart("muffleWarning")
[10:26:07.763]                     }
[10:26:07.763]                     else if (inherits(cond, "condition")) {
[10:26:07.763]                       if (!is.null(pattern)) {
[10:26:07.763]                         computeRestarts <- base::computeRestarts
[10:26:07.763]                         grepl <- base::grepl
[10:26:07.763]                         restarts <- computeRestarts(cond)
[10:26:07.763]                         for (restart in restarts) {
[10:26:07.763]                           name <- restart$name
[10:26:07.763]                           if (is.null(name)) 
[10:26:07.763]                             next
[10:26:07.763]                           if (!grepl(pattern, name)) 
[10:26:07.763]                             next
[10:26:07.763]                           invokeRestart(restart)
[10:26:07.763]                           muffled <- TRUE
[10:26:07.763]                           break
[10:26:07.763]                         }
[10:26:07.763]                       }
[10:26:07.763]                     }
[10:26:07.763]                     invisible(muffled)
[10:26:07.763]                   }
[10:26:07.763]                   muffleCondition(cond)
[10:26:07.763]                 })
[10:26:07.763]             }))
[10:26:07.763]             future::FutureResult(value = ...future.value$value, 
[10:26:07.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.763]                   ...future.rng), globalenv = if (FALSE) 
[10:26:07.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:07.763]                     ...future.globalenv.names))
[10:26:07.763]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:07.763]         }, condition = base::local({
[10:26:07.763]             c <- base::c
[10:26:07.763]             inherits <- base::inherits
[10:26:07.763]             invokeRestart <- base::invokeRestart
[10:26:07.763]             length <- base::length
[10:26:07.763]             list <- base::list
[10:26:07.763]             seq.int <- base::seq.int
[10:26:07.763]             signalCondition <- base::signalCondition
[10:26:07.763]             sys.calls <- base::sys.calls
[10:26:07.763]             `[[` <- base::`[[`
[10:26:07.763]             `+` <- base::`+`
[10:26:07.763]             `<<-` <- base::`<<-`
[10:26:07.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:07.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:07.763]                   3L)]
[10:26:07.763]             }
[10:26:07.763]             function(cond) {
[10:26:07.763]                 is_error <- inherits(cond, "error")
[10:26:07.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:07.763]                   NULL)
[10:26:07.763]                 if (is_error) {
[10:26:07.763]                   sessionInformation <- function() {
[10:26:07.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:07.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:07.763]                       search = base::search(), system = base::Sys.info())
[10:26:07.763]                   }
[10:26:07.763]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:07.763]                     cond$call), session = sessionInformation(), 
[10:26:07.763]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:07.763]                   signalCondition(cond)
[10:26:07.763]                 }
[10:26:07.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:07.763]                 "immediateCondition"))) {
[10:26:07.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:07.763]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:07.763]                   if (TRUE && !signal) {
[10:26:07.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.763]                     {
[10:26:07.763]                       inherits <- base::inherits
[10:26:07.763]                       invokeRestart <- base::invokeRestart
[10:26:07.763]                       is.null <- base::is.null
[10:26:07.763]                       muffled <- FALSE
[10:26:07.763]                       if (inherits(cond, "message")) {
[10:26:07.763]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.763]                         if (muffled) 
[10:26:07.763]                           invokeRestart("muffleMessage")
[10:26:07.763]                       }
[10:26:07.763]                       else if (inherits(cond, "warning")) {
[10:26:07.763]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.763]                         if (muffled) 
[10:26:07.763]                           invokeRestart("muffleWarning")
[10:26:07.763]                       }
[10:26:07.763]                       else if (inherits(cond, "condition")) {
[10:26:07.763]                         if (!is.null(pattern)) {
[10:26:07.763]                           computeRestarts <- base::computeRestarts
[10:26:07.763]                           grepl <- base::grepl
[10:26:07.763]                           restarts <- computeRestarts(cond)
[10:26:07.763]                           for (restart in restarts) {
[10:26:07.763]                             name <- restart$name
[10:26:07.763]                             if (is.null(name)) 
[10:26:07.763]                               next
[10:26:07.763]                             if (!grepl(pattern, name)) 
[10:26:07.763]                               next
[10:26:07.763]                             invokeRestart(restart)
[10:26:07.763]                             muffled <- TRUE
[10:26:07.763]                             break
[10:26:07.763]                           }
[10:26:07.763]                         }
[10:26:07.763]                       }
[10:26:07.763]                       invisible(muffled)
[10:26:07.763]                     }
[10:26:07.763]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.763]                   }
[10:26:07.763]                 }
[10:26:07.763]                 else {
[10:26:07.763]                   if (TRUE) {
[10:26:07.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.763]                     {
[10:26:07.763]                       inherits <- base::inherits
[10:26:07.763]                       invokeRestart <- base::invokeRestart
[10:26:07.763]                       is.null <- base::is.null
[10:26:07.763]                       muffled <- FALSE
[10:26:07.763]                       if (inherits(cond, "message")) {
[10:26:07.763]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.763]                         if (muffled) 
[10:26:07.763]                           invokeRestart("muffleMessage")
[10:26:07.763]                       }
[10:26:07.763]                       else if (inherits(cond, "warning")) {
[10:26:07.763]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.763]                         if (muffled) 
[10:26:07.763]                           invokeRestart("muffleWarning")
[10:26:07.763]                       }
[10:26:07.763]                       else if (inherits(cond, "condition")) {
[10:26:07.763]                         if (!is.null(pattern)) {
[10:26:07.763]                           computeRestarts <- base::computeRestarts
[10:26:07.763]                           grepl <- base::grepl
[10:26:07.763]                           restarts <- computeRestarts(cond)
[10:26:07.763]                           for (restart in restarts) {
[10:26:07.763]                             name <- restart$name
[10:26:07.763]                             if (is.null(name)) 
[10:26:07.763]                               next
[10:26:07.763]                             if (!grepl(pattern, name)) 
[10:26:07.763]                               next
[10:26:07.763]                             invokeRestart(restart)
[10:26:07.763]                             muffled <- TRUE
[10:26:07.763]                             break
[10:26:07.763]                           }
[10:26:07.763]                         }
[10:26:07.763]                       }
[10:26:07.763]                       invisible(muffled)
[10:26:07.763]                     }
[10:26:07.763]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.763]                   }
[10:26:07.763]                 }
[10:26:07.763]             }
[10:26:07.763]         }))
[10:26:07.763]     }, error = function(ex) {
[10:26:07.763]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:07.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.763]                 ...future.rng), started = ...future.startTime, 
[10:26:07.763]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:07.763]             version = "1.8"), class = "FutureResult")
[10:26:07.763]     }, finally = {
[10:26:07.763]         if (!identical(...future.workdir, getwd())) 
[10:26:07.763]             setwd(...future.workdir)
[10:26:07.763]         {
[10:26:07.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:07.763]                 ...future.oldOptions$nwarnings <- NULL
[10:26:07.763]             }
[10:26:07.763]             base::options(...future.oldOptions)
[10:26:07.763]             if (.Platform$OS.type == "windows") {
[10:26:07.763]                 old_names <- names(...future.oldEnvVars)
[10:26:07.763]                 envs <- base::Sys.getenv()
[10:26:07.763]                 names <- names(envs)
[10:26:07.763]                 common <- intersect(names, old_names)
[10:26:07.763]                 added <- setdiff(names, old_names)
[10:26:07.763]                 removed <- setdiff(old_names, names)
[10:26:07.763]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:07.763]                   envs[common]]
[10:26:07.763]                 NAMES <- toupper(changed)
[10:26:07.763]                 args <- list()
[10:26:07.763]                 for (kk in seq_along(NAMES)) {
[10:26:07.763]                   name <- changed[[kk]]
[10:26:07.763]                   NAME <- NAMES[[kk]]
[10:26:07.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.763]                     next
[10:26:07.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.763]                 }
[10:26:07.763]                 NAMES <- toupper(added)
[10:26:07.763]                 for (kk in seq_along(NAMES)) {
[10:26:07.763]                   name <- added[[kk]]
[10:26:07.763]                   NAME <- NAMES[[kk]]
[10:26:07.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.763]                     next
[10:26:07.763]                   args[[name]] <- ""
[10:26:07.763]                 }
[10:26:07.763]                 NAMES <- toupper(removed)
[10:26:07.763]                 for (kk in seq_along(NAMES)) {
[10:26:07.763]                   name <- removed[[kk]]
[10:26:07.763]                   NAME <- NAMES[[kk]]
[10:26:07.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.763]                     next
[10:26:07.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.763]                 }
[10:26:07.763]                 if (length(args) > 0) 
[10:26:07.763]                   base::do.call(base::Sys.setenv, args = args)
[10:26:07.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:07.763]             }
[10:26:07.763]             else {
[10:26:07.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:07.763]             }
[10:26:07.763]             {
[10:26:07.763]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:07.763]                   0L) {
[10:26:07.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:07.763]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:07.763]                   base::options(opts)
[10:26:07.763]                 }
[10:26:07.763]                 {
[10:26:07.763]                   {
[10:26:07.763]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:07.763]                     NULL
[10:26:07.763]                   }
[10:26:07.763]                   options(future.plan = NULL)
[10:26:07.763]                   if (is.na(NA_character_)) 
[10:26:07.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:07.763]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:07.763]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:07.763]                     envir = parent.frame()) 
[10:26:07.763]                   {
[10:26:07.763]                     if (is.function(workers)) 
[10:26:07.763]                       workers <- workers()
[10:26:07.763]                     workers <- structure(as.integer(workers), 
[10:26:07.763]                       class = class(workers))
[10:26:07.763]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:07.763]                       workers >= 1)
[10:26:07.763]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:07.763]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:07.763]                     }
[10:26:07.763]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:07.763]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:07.763]                       envir = envir)
[10:26:07.763]                     if (!future$lazy) 
[10:26:07.763]                       future <- run(future)
[10:26:07.763]                     invisible(future)
[10:26:07.763]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:07.763]                 }
[10:26:07.763]             }
[10:26:07.763]         }
[10:26:07.763]     })
[10:26:07.763]     if (TRUE) {
[10:26:07.763]         base::sink(type = "output", split = FALSE)
[10:26:07.763]         if (TRUE) {
[10:26:07.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:07.763]         }
[10:26:07.763]         else {
[10:26:07.763]             ...future.result["stdout"] <- base::list(NULL)
[10:26:07.763]         }
[10:26:07.763]         base::close(...future.stdout)
[10:26:07.763]         ...future.stdout <- NULL
[10:26:07.763]     }
[10:26:07.763]     ...future.result$conditions <- ...future.conditions
[10:26:07.763]     ...future.result$finished <- base::Sys.time()
[10:26:07.763]     ...future.result
[10:26:07.763] }
[10:26:07.766] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:26:07.766] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:26:07.766] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:26:07.766] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:26:07.767] MultisessionFuture started
[10:26:07.767] - Launch lazy future ... done
[10:26:07.767] run() for ‘MultisessionFuture’ ... done
[10:26:07.767] result() for ClusterFuture ...
[10:26:07.767] receiveMessageFromWorker() for ClusterFuture ...
[10:26:07.767] - Validating connection of MultisessionFuture
[10:26:07.814] - received message: FutureResult
[10:26:07.814] - Received FutureResult
[10:26:07.815] - Erased future from FutureRegistry
[10:26:07.815] result() for ClusterFuture ...
[10:26:07.815] - result already collected: FutureResult
[10:26:07.815] result() for ClusterFuture ... done
[10:26:07.815] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:07.815] result() for ClusterFuture ... done
[10:26:07.815] result() for ClusterFuture ...
[10:26:07.815] - result already collected: FutureResult
[10:26:07.815] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:07.816] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:07.816] Searching for globals...
[10:26:07.818] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:07.818] Searching for globals ... DONE
[10:26:07.818] Resolving globals: TRUE
[10:26:07.818] Resolving any globals that are futures ...
[10:26:07.818] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:26:07.818] Resolving any globals that are futures ... DONE
[10:26:07.819] Resolving futures part of globals (recursively) ...
[10:26:07.819] resolve() on list ...
[10:26:07.819]  recursive: 99
[10:26:07.819]  length: 1
[10:26:07.819]  elements: ‘x’
[10:26:07.819]  length: 0 (resolved future 1)
[10:26:07.819] resolve() on list ... DONE
[10:26:07.820] - globals: [1] ‘x’
[10:26:07.820] Resolving futures part of globals (recursively) ... DONE
[10:26:07.820] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:07.820] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:07.820] - globals: [1] ‘x’
[10:26:07.820] 
[10:26:07.820] getGlobalsAndPackages() ... DONE
[10:26:07.821] run() for ‘Future’ ...
[10:26:07.821] - state: ‘created’
[10:26:07.821] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:07.835] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:07.835] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:07.835]   - Field: ‘node’
[10:26:07.835]   - Field: ‘label’
[10:26:07.835]   - Field: ‘local’
[10:26:07.835]   - Field: ‘owner’
[10:26:07.835]   - Field: ‘envir’
[10:26:07.835]   - Field: ‘workers’
[10:26:07.835]   - Field: ‘packages’
[10:26:07.836]   - Field: ‘gc’
[10:26:07.836]   - Field: ‘conditions’
[10:26:07.836]   - Field: ‘persistent’
[10:26:07.836]   - Field: ‘expr’
[10:26:07.836]   - Field: ‘uuid’
[10:26:07.836]   - Field: ‘seed’
[10:26:07.836]   - Field: ‘version’
[10:26:07.836]   - Field: ‘result’
[10:26:07.836]   - Field: ‘asynchronous’
[10:26:07.836]   - Field: ‘calls’
[10:26:07.836]   - Field: ‘globals’
[10:26:07.837]   - Field: ‘stdout’
[10:26:07.837]   - Field: ‘earlySignal’
[10:26:07.837]   - Field: ‘lazy’
[10:26:07.837]   - Field: ‘state’
[10:26:07.837] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:07.837] - Launch lazy future ...
[10:26:07.837] Packages needed by the future expression (n = 0): <none>
[10:26:07.837] Packages needed by future strategies (n = 0): <none>
[10:26:07.838] {
[10:26:07.838]     {
[10:26:07.838]         {
[10:26:07.838]             ...future.startTime <- base::Sys.time()
[10:26:07.838]             {
[10:26:07.838]                 {
[10:26:07.838]                   {
[10:26:07.838]                     {
[10:26:07.838]                       base::local({
[10:26:07.838]                         has_future <- base::requireNamespace("future", 
[10:26:07.838]                           quietly = TRUE)
[10:26:07.838]                         if (has_future) {
[10:26:07.838]                           ns <- base::getNamespace("future")
[10:26:07.838]                           version <- ns[[".package"]][["version"]]
[10:26:07.838]                           if (is.null(version)) 
[10:26:07.838]                             version <- utils::packageVersion("future")
[10:26:07.838]                         }
[10:26:07.838]                         else {
[10:26:07.838]                           version <- NULL
[10:26:07.838]                         }
[10:26:07.838]                         if (!has_future || version < "1.8.0") {
[10:26:07.838]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:07.838]                             "", base::R.version$version.string), 
[10:26:07.838]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:07.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:07.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:07.838]                               "release", "version")], collapse = " "), 
[10:26:07.838]                             hostname = base::Sys.info()[["nodename"]])
[10:26:07.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:07.838]                             info)
[10:26:07.838]                           info <- base::paste(info, collapse = "; ")
[10:26:07.838]                           if (!has_future) {
[10:26:07.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:07.838]                               info)
[10:26:07.838]                           }
[10:26:07.838]                           else {
[10:26:07.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:07.838]                               info, version)
[10:26:07.838]                           }
[10:26:07.838]                           base::stop(msg)
[10:26:07.838]                         }
[10:26:07.838]                       })
[10:26:07.838]                     }
[10:26:07.838]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:07.838]                     base::options(mc.cores = 1L)
[10:26:07.838]                   }
[10:26:07.838]                   options(future.plan = NULL)
[10:26:07.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:07.838]                 }
[10:26:07.838]                 ...future.workdir <- getwd()
[10:26:07.838]             }
[10:26:07.838]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:07.838]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:07.838]         }
[10:26:07.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:07.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:07.838]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:07.838]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:07.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:07.838]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:07.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:07.838]             base::names(...future.oldOptions))
[10:26:07.838]     }
[10:26:07.838]     if (FALSE) {
[10:26:07.838]     }
[10:26:07.838]     else {
[10:26:07.838]         if (TRUE) {
[10:26:07.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:07.838]                 open = "w")
[10:26:07.838]         }
[10:26:07.838]         else {
[10:26:07.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:07.838]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:07.838]         }
[10:26:07.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:07.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:07.838]             base::sink(type = "output", split = FALSE)
[10:26:07.838]             base::close(...future.stdout)
[10:26:07.838]         }, add = TRUE)
[10:26:07.838]     }
[10:26:07.838]     ...future.frame <- base::sys.nframe()
[10:26:07.838]     ...future.conditions <- base::list()
[10:26:07.838]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:07.838]     if (FALSE) {
[10:26:07.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:07.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:07.838]     }
[10:26:07.838]     ...future.result <- base::tryCatch({
[10:26:07.838]         base::withCallingHandlers({
[10:26:07.838]             ...future.value <- base::withVisible(base::local({
[10:26:07.838]                 ...future.makeSendCondition <- base::local({
[10:26:07.838]                   sendCondition <- NULL
[10:26:07.838]                   function(frame = 1L) {
[10:26:07.838]                     if (is.function(sendCondition)) 
[10:26:07.838]                       return(sendCondition)
[10:26:07.838]                     ns <- getNamespace("parallel")
[10:26:07.838]                     if (exists("sendData", mode = "function", 
[10:26:07.838]                       envir = ns)) {
[10:26:07.838]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:07.838]                         envir = ns)
[10:26:07.838]                       envir <- sys.frame(frame)
[10:26:07.838]                       master <- NULL
[10:26:07.838]                       while (!identical(envir, .GlobalEnv) && 
[10:26:07.838]                         !identical(envir, emptyenv())) {
[10:26:07.838]                         if (exists("master", mode = "list", envir = envir, 
[10:26:07.838]                           inherits = FALSE)) {
[10:26:07.838]                           master <- get("master", mode = "list", 
[10:26:07.838]                             envir = envir, inherits = FALSE)
[10:26:07.838]                           if (inherits(master, c("SOCKnode", 
[10:26:07.838]                             "SOCK0node"))) {
[10:26:07.838]                             sendCondition <<- function(cond) {
[10:26:07.838]                               data <- list(type = "VALUE", value = cond, 
[10:26:07.838]                                 success = TRUE)
[10:26:07.838]                               parallel_sendData(master, data)
[10:26:07.838]                             }
[10:26:07.838]                             return(sendCondition)
[10:26:07.838]                           }
[10:26:07.838]                         }
[10:26:07.838]                         frame <- frame + 1L
[10:26:07.838]                         envir <- sys.frame(frame)
[10:26:07.838]                       }
[10:26:07.838]                     }
[10:26:07.838]                     sendCondition <<- function(cond) NULL
[10:26:07.838]                   }
[10:26:07.838]                 })
[10:26:07.838]                 withCallingHandlers({
[10:26:07.838]                   {
[10:26:07.838]                     x$a <- 1
[10:26:07.838]                     x
[10:26:07.838]                   }
[10:26:07.838]                 }, immediateCondition = function(cond) {
[10:26:07.838]                   sendCondition <- ...future.makeSendCondition()
[10:26:07.838]                   sendCondition(cond)
[10:26:07.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.838]                   {
[10:26:07.838]                     inherits <- base::inherits
[10:26:07.838]                     invokeRestart <- base::invokeRestart
[10:26:07.838]                     is.null <- base::is.null
[10:26:07.838]                     muffled <- FALSE
[10:26:07.838]                     if (inherits(cond, "message")) {
[10:26:07.838]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:07.838]                       if (muffled) 
[10:26:07.838]                         invokeRestart("muffleMessage")
[10:26:07.838]                     }
[10:26:07.838]                     else if (inherits(cond, "warning")) {
[10:26:07.838]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:07.838]                       if (muffled) 
[10:26:07.838]                         invokeRestart("muffleWarning")
[10:26:07.838]                     }
[10:26:07.838]                     else if (inherits(cond, "condition")) {
[10:26:07.838]                       if (!is.null(pattern)) {
[10:26:07.838]                         computeRestarts <- base::computeRestarts
[10:26:07.838]                         grepl <- base::grepl
[10:26:07.838]                         restarts <- computeRestarts(cond)
[10:26:07.838]                         for (restart in restarts) {
[10:26:07.838]                           name <- restart$name
[10:26:07.838]                           if (is.null(name)) 
[10:26:07.838]                             next
[10:26:07.838]                           if (!grepl(pattern, name)) 
[10:26:07.838]                             next
[10:26:07.838]                           invokeRestart(restart)
[10:26:07.838]                           muffled <- TRUE
[10:26:07.838]                           break
[10:26:07.838]                         }
[10:26:07.838]                       }
[10:26:07.838]                     }
[10:26:07.838]                     invisible(muffled)
[10:26:07.838]                   }
[10:26:07.838]                   muffleCondition(cond)
[10:26:07.838]                 })
[10:26:07.838]             }))
[10:26:07.838]             future::FutureResult(value = ...future.value$value, 
[10:26:07.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.838]                   ...future.rng), globalenv = if (FALSE) 
[10:26:07.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:07.838]                     ...future.globalenv.names))
[10:26:07.838]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:07.838]         }, condition = base::local({
[10:26:07.838]             c <- base::c
[10:26:07.838]             inherits <- base::inherits
[10:26:07.838]             invokeRestart <- base::invokeRestart
[10:26:07.838]             length <- base::length
[10:26:07.838]             list <- base::list
[10:26:07.838]             seq.int <- base::seq.int
[10:26:07.838]             signalCondition <- base::signalCondition
[10:26:07.838]             sys.calls <- base::sys.calls
[10:26:07.838]             `[[` <- base::`[[`
[10:26:07.838]             `+` <- base::`+`
[10:26:07.838]             `<<-` <- base::`<<-`
[10:26:07.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:07.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:07.838]                   3L)]
[10:26:07.838]             }
[10:26:07.838]             function(cond) {
[10:26:07.838]                 is_error <- inherits(cond, "error")
[10:26:07.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:07.838]                   NULL)
[10:26:07.838]                 if (is_error) {
[10:26:07.838]                   sessionInformation <- function() {
[10:26:07.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:07.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:07.838]                       search = base::search(), system = base::Sys.info())
[10:26:07.838]                   }
[10:26:07.838]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:07.838]                     cond$call), session = sessionInformation(), 
[10:26:07.838]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:07.838]                   signalCondition(cond)
[10:26:07.838]                 }
[10:26:07.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:07.838]                 "immediateCondition"))) {
[10:26:07.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:07.838]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:07.838]                   if (TRUE && !signal) {
[10:26:07.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.838]                     {
[10:26:07.838]                       inherits <- base::inherits
[10:26:07.838]                       invokeRestart <- base::invokeRestart
[10:26:07.838]                       is.null <- base::is.null
[10:26:07.838]                       muffled <- FALSE
[10:26:07.838]                       if (inherits(cond, "message")) {
[10:26:07.838]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.838]                         if (muffled) 
[10:26:07.838]                           invokeRestart("muffleMessage")
[10:26:07.838]                       }
[10:26:07.838]                       else if (inherits(cond, "warning")) {
[10:26:07.838]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.838]                         if (muffled) 
[10:26:07.838]                           invokeRestart("muffleWarning")
[10:26:07.838]                       }
[10:26:07.838]                       else if (inherits(cond, "condition")) {
[10:26:07.838]                         if (!is.null(pattern)) {
[10:26:07.838]                           computeRestarts <- base::computeRestarts
[10:26:07.838]                           grepl <- base::grepl
[10:26:07.838]                           restarts <- computeRestarts(cond)
[10:26:07.838]                           for (restart in restarts) {
[10:26:07.838]                             name <- restart$name
[10:26:07.838]                             if (is.null(name)) 
[10:26:07.838]                               next
[10:26:07.838]                             if (!grepl(pattern, name)) 
[10:26:07.838]                               next
[10:26:07.838]                             invokeRestart(restart)
[10:26:07.838]                             muffled <- TRUE
[10:26:07.838]                             break
[10:26:07.838]                           }
[10:26:07.838]                         }
[10:26:07.838]                       }
[10:26:07.838]                       invisible(muffled)
[10:26:07.838]                     }
[10:26:07.838]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.838]                   }
[10:26:07.838]                 }
[10:26:07.838]                 else {
[10:26:07.838]                   if (TRUE) {
[10:26:07.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.838]                     {
[10:26:07.838]                       inherits <- base::inherits
[10:26:07.838]                       invokeRestart <- base::invokeRestart
[10:26:07.838]                       is.null <- base::is.null
[10:26:07.838]                       muffled <- FALSE
[10:26:07.838]                       if (inherits(cond, "message")) {
[10:26:07.838]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.838]                         if (muffled) 
[10:26:07.838]                           invokeRestart("muffleMessage")
[10:26:07.838]                       }
[10:26:07.838]                       else if (inherits(cond, "warning")) {
[10:26:07.838]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.838]                         if (muffled) 
[10:26:07.838]                           invokeRestart("muffleWarning")
[10:26:07.838]                       }
[10:26:07.838]                       else if (inherits(cond, "condition")) {
[10:26:07.838]                         if (!is.null(pattern)) {
[10:26:07.838]                           computeRestarts <- base::computeRestarts
[10:26:07.838]                           grepl <- base::grepl
[10:26:07.838]                           restarts <- computeRestarts(cond)
[10:26:07.838]                           for (restart in restarts) {
[10:26:07.838]                             name <- restart$name
[10:26:07.838]                             if (is.null(name)) 
[10:26:07.838]                               next
[10:26:07.838]                             if (!grepl(pattern, name)) 
[10:26:07.838]                               next
[10:26:07.838]                             invokeRestart(restart)
[10:26:07.838]                             muffled <- TRUE
[10:26:07.838]                             break
[10:26:07.838]                           }
[10:26:07.838]                         }
[10:26:07.838]                       }
[10:26:07.838]                       invisible(muffled)
[10:26:07.838]                     }
[10:26:07.838]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.838]                   }
[10:26:07.838]                 }
[10:26:07.838]             }
[10:26:07.838]         }))
[10:26:07.838]     }, error = function(ex) {
[10:26:07.838]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:07.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.838]                 ...future.rng), started = ...future.startTime, 
[10:26:07.838]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:07.838]             version = "1.8"), class = "FutureResult")
[10:26:07.838]     }, finally = {
[10:26:07.838]         if (!identical(...future.workdir, getwd())) 
[10:26:07.838]             setwd(...future.workdir)
[10:26:07.838]         {
[10:26:07.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:07.838]                 ...future.oldOptions$nwarnings <- NULL
[10:26:07.838]             }
[10:26:07.838]             base::options(...future.oldOptions)
[10:26:07.838]             if (.Platform$OS.type == "windows") {
[10:26:07.838]                 old_names <- names(...future.oldEnvVars)
[10:26:07.838]                 envs <- base::Sys.getenv()
[10:26:07.838]                 names <- names(envs)
[10:26:07.838]                 common <- intersect(names, old_names)
[10:26:07.838]                 added <- setdiff(names, old_names)
[10:26:07.838]                 removed <- setdiff(old_names, names)
[10:26:07.838]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:07.838]                   envs[common]]
[10:26:07.838]                 NAMES <- toupper(changed)
[10:26:07.838]                 args <- list()
[10:26:07.838]                 for (kk in seq_along(NAMES)) {
[10:26:07.838]                   name <- changed[[kk]]
[10:26:07.838]                   NAME <- NAMES[[kk]]
[10:26:07.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.838]                     next
[10:26:07.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.838]                 }
[10:26:07.838]                 NAMES <- toupper(added)
[10:26:07.838]                 for (kk in seq_along(NAMES)) {
[10:26:07.838]                   name <- added[[kk]]
[10:26:07.838]                   NAME <- NAMES[[kk]]
[10:26:07.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.838]                     next
[10:26:07.838]                   args[[name]] <- ""
[10:26:07.838]                 }
[10:26:07.838]                 NAMES <- toupper(removed)
[10:26:07.838]                 for (kk in seq_along(NAMES)) {
[10:26:07.838]                   name <- removed[[kk]]
[10:26:07.838]                   NAME <- NAMES[[kk]]
[10:26:07.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.838]                     next
[10:26:07.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.838]                 }
[10:26:07.838]                 if (length(args) > 0) 
[10:26:07.838]                   base::do.call(base::Sys.setenv, args = args)
[10:26:07.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:07.838]             }
[10:26:07.838]             else {
[10:26:07.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:07.838]             }
[10:26:07.838]             {
[10:26:07.838]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:07.838]                   0L) {
[10:26:07.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:07.838]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:07.838]                   base::options(opts)
[10:26:07.838]                 }
[10:26:07.838]                 {
[10:26:07.838]                   {
[10:26:07.838]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:07.838]                     NULL
[10:26:07.838]                   }
[10:26:07.838]                   options(future.plan = NULL)
[10:26:07.838]                   if (is.na(NA_character_)) 
[10:26:07.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:07.838]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:07.838]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:07.838]                     envir = parent.frame()) 
[10:26:07.838]                   {
[10:26:07.838]                     if (is.function(workers)) 
[10:26:07.838]                       workers <- workers()
[10:26:07.838]                     workers <- structure(as.integer(workers), 
[10:26:07.838]                       class = class(workers))
[10:26:07.838]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:07.838]                       workers >= 1)
[10:26:07.838]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:07.838]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:07.838]                     }
[10:26:07.838]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:07.838]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:07.838]                       envir = envir)
[10:26:07.838]                     if (!future$lazy) 
[10:26:07.838]                       future <- run(future)
[10:26:07.838]                     invisible(future)
[10:26:07.838]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:07.838]                 }
[10:26:07.838]             }
[10:26:07.838]         }
[10:26:07.838]     })
[10:26:07.838]     if (TRUE) {
[10:26:07.838]         base::sink(type = "output", split = FALSE)
[10:26:07.838]         if (TRUE) {
[10:26:07.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:07.838]         }
[10:26:07.838]         else {
[10:26:07.838]             ...future.result["stdout"] <- base::list(NULL)
[10:26:07.838]         }
[10:26:07.838]         base::close(...future.stdout)
[10:26:07.838]         ...future.stdout <- NULL
[10:26:07.838]     }
[10:26:07.838]     ...future.result$conditions <- ...future.conditions
[10:26:07.838]     ...future.result$finished <- base::Sys.time()
[10:26:07.838]     ...future.result
[10:26:07.838] }
[10:26:07.840] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:26:07.841] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:26:07.841] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:26:07.841] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:26:07.841] MultisessionFuture started
[10:26:07.842] - Launch lazy future ... done
[10:26:07.842] run() for ‘MultisessionFuture’ ... done
[10:26:07.842] result() for ClusterFuture ...
[10:26:07.842] receiveMessageFromWorker() for ClusterFuture ...
[10:26:07.842] - Validating connection of MultisessionFuture
[10:26:07.890] - received message: FutureResult
[10:26:07.890] - Received FutureResult
[10:26:07.890] - Erased future from FutureRegistry
[10:26:07.890] result() for ClusterFuture ...
[10:26:07.890] - result already collected: FutureResult
[10:26:07.890] result() for ClusterFuture ... done
[10:26:07.891] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:07.891] result() for ClusterFuture ... done
[10:26:07.891] result() for ClusterFuture ...
[10:26:07.891] - result already collected: FutureResult
[10:26:07.891] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:07.891] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:07.892] Searching for globals...
[10:26:07.894] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:26:07.894] Searching for globals ... DONE
[10:26:07.894] Resolving globals: TRUE
[10:26:07.894] Resolving any globals that are futures ...
[10:26:07.894] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:26:07.894] Resolving any globals that are futures ... DONE
[10:26:07.895] 
[10:26:07.895] 
[10:26:07.895] getGlobalsAndPackages() ... DONE
[10:26:07.895] run() for ‘Future’ ...
[10:26:07.895] - state: ‘created’
[10:26:07.895] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:07.909] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:07.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:07.909]   - Field: ‘node’
[10:26:07.909]   - Field: ‘label’
[10:26:07.909]   - Field: ‘local’
[10:26:07.910]   - Field: ‘owner’
[10:26:07.910]   - Field: ‘envir’
[10:26:07.910]   - Field: ‘workers’
[10:26:07.910]   - Field: ‘packages’
[10:26:07.910]   - Field: ‘gc’
[10:26:07.910]   - Field: ‘conditions’
[10:26:07.910]   - Field: ‘persistent’
[10:26:07.910]   - Field: ‘expr’
[10:26:07.910]   - Field: ‘uuid’
[10:26:07.910]   - Field: ‘seed’
[10:26:07.911]   - Field: ‘version’
[10:26:07.911]   - Field: ‘result’
[10:26:07.911]   - Field: ‘asynchronous’
[10:26:07.911]   - Field: ‘calls’
[10:26:07.911]   - Field: ‘globals’
[10:26:07.911]   - Field: ‘stdout’
[10:26:07.911]   - Field: ‘earlySignal’
[10:26:07.911]   - Field: ‘lazy’
[10:26:07.911]   - Field: ‘state’
[10:26:07.911] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:07.911] - Launch lazy future ...
[10:26:07.912] Packages needed by the future expression (n = 0): <none>
[10:26:07.912] Packages needed by future strategies (n = 0): <none>
[10:26:07.912] {
[10:26:07.912]     {
[10:26:07.912]         {
[10:26:07.912]             ...future.startTime <- base::Sys.time()
[10:26:07.912]             {
[10:26:07.912]                 {
[10:26:07.912]                   {
[10:26:07.912]                     {
[10:26:07.912]                       base::local({
[10:26:07.912]                         has_future <- base::requireNamespace("future", 
[10:26:07.912]                           quietly = TRUE)
[10:26:07.912]                         if (has_future) {
[10:26:07.912]                           ns <- base::getNamespace("future")
[10:26:07.912]                           version <- ns[[".package"]][["version"]]
[10:26:07.912]                           if (is.null(version)) 
[10:26:07.912]                             version <- utils::packageVersion("future")
[10:26:07.912]                         }
[10:26:07.912]                         else {
[10:26:07.912]                           version <- NULL
[10:26:07.912]                         }
[10:26:07.912]                         if (!has_future || version < "1.8.0") {
[10:26:07.912]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:07.912]                             "", base::R.version$version.string), 
[10:26:07.912]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:07.912]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:07.912]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:07.912]                               "release", "version")], collapse = " "), 
[10:26:07.912]                             hostname = base::Sys.info()[["nodename"]])
[10:26:07.912]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:07.912]                             info)
[10:26:07.912]                           info <- base::paste(info, collapse = "; ")
[10:26:07.912]                           if (!has_future) {
[10:26:07.912]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:07.912]                               info)
[10:26:07.912]                           }
[10:26:07.912]                           else {
[10:26:07.912]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:07.912]                               info, version)
[10:26:07.912]                           }
[10:26:07.912]                           base::stop(msg)
[10:26:07.912]                         }
[10:26:07.912]                       })
[10:26:07.912]                     }
[10:26:07.912]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:07.912]                     base::options(mc.cores = 1L)
[10:26:07.912]                   }
[10:26:07.912]                   options(future.plan = NULL)
[10:26:07.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:07.912]                 }
[10:26:07.912]                 ...future.workdir <- getwd()
[10:26:07.912]             }
[10:26:07.912]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:07.912]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:07.912]         }
[10:26:07.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:07.912]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:07.912]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:07.912]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:07.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:07.912]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:07.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:07.912]             base::names(...future.oldOptions))
[10:26:07.912]     }
[10:26:07.912]     if (FALSE) {
[10:26:07.912]     }
[10:26:07.912]     else {
[10:26:07.912]         if (TRUE) {
[10:26:07.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:07.912]                 open = "w")
[10:26:07.912]         }
[10:26:07.912]         else {
[10:26:07.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:07.912]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:07.912]         }
[10:26:07.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:07.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:07.912]             base::sink(type = "output", split = FALSE)
[10:26:07.912]             base::close(...future.stdout)
[10:26:07.912]         }, add = TRUE)
[10:26:07.912]     }
[10:26:07.912]     ...future.frame <- base::sys.nframe()
[10:26:07.912]     ...future.conditions <- base::list()
[10:26:07.912]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:07.912]     if (FALSE) {
[10:26:07.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:07.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:07.912]     }
[10:26:07.912]     ...future.result <- base::tryCatch({
[10:26:07.912]         base::withCallingHandlers({
[10:26:07.912]             ...future.value <- base::withVisible(base::local({
[10:26:07.912]                 ...future.makeSendCondition <- base::local({
[10:26:07.912]                   sendCondition <- NULL
[10:26:07.912]                   function(frame = 1L) {
[10:26:07.912]                     if (is.function(sendCondition)) 
[10:26:07.912]                       return(sendCondition)
[10:26:07.912]                     ns <- getNamespace("parallel")
[10:26:07.912]                     if (exists("sendData", mode = "function", 
[10:26:07.912]                       envir = ns)) {
[10:26:07.912]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:07.912]                         envir = ns)
[10:26:07.912]                       envir <- sys.frame(frame)
[10:26:07.912]                       master <- NULL
[10:26:07.912]                       while (!identical(envir, .GlobalEnv) && 
[10:26:07.912]                         !identical(envir, emptyenv())) {
[10:26:07.912]                         if (exists("master", mode = "list", envir = envir, 
[10:26:07.912]                           inherits = FALSE)) {
[10:26:07.912]                           master <- get("master", mode = "list", 
[10:26:07.912]                             envir = envir, inherits = FALSE)
[10:26:07.912]                           if (inherits(master, c("SOCKnode", 
[10:26:07.912]                             "SOCK0node"))) {
[10:26:07.912]                             sendCondition <<- function(cond) {
[10:26:07.912]                               data <- list(type = "VALUE", value = cond, 
[10:26:07.912]                                 success = TRUE)
[10:26:07.912]                               parallel_sendData(master, data)
[10:26:07.912]                             }
[10:26:07.912]                             return(sendCondition)
[10:26:07.912]                           }
[10:26:07.912]                         }
[10:26:07.912]                         frame <- frame + 1L
[10:26:07.912]                         envir <- sys.frame(frame)
[10:26:07.912]                       }
[10:26:07.912]                     }
[10:26:07.912]                     sendCondition <<- function(cond) NULL
[10:26:07.912]                   }
[10:26:07.912]                 })
[10:26:07.912]                 withCallingHandlers({
[10:26:07.912]                   {
[10:26:07.912]                     x <- list(b = 2)
[10:26:07.912]                     x$a <- 1
[10:26:07.912]                     x
[10:26:07.912]                   }
[10:26:07.912]                 }, immediateCondition = function(cond) {
[10:26:07.912]                   sendCondition <- ...future.makeSendCondition()
[10:26:07.912]                   sendCondition(cond)
[10:26:07.912]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.912]                   {
[10:26:07.912]                     inherits <- base::inherits
[10:26:07.912]                     invokeRestart <- base::invokeRestart
[10:26:07.912]                     is.null <- base::is.null
[10:26:07.912]                     muffled <- FALSE
[10:26:07.912]                     if (inherits(cond, "message")) {
[10:26:07.912]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:07.912]                       if (muffled) 
[10:26:07.912]                         invokeRestart("muffleMessage")
[10:26:07.912]                     }
[10:26:07.912]                     else if (inherits(cond, "warning")) {
[10:26:07.912]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:07.912]                       if (muffled) 
[10:26:07.912]                         invokeRestart("muffleWarning")
[10:26:07.912]                     }
[10:26:07.912]                     else if (inherits(cond, "condition")) {
[10:26:07.912]                       if (!is.null(pattern)) {
[10:26:07.912]                         computeRestarts <- base::computeRestarts
[10:26:07.912]                         grepl <- base::grepl
[10:26:07.912]                         restarts <- computeRestarts(cond)
[10:26:07.912]                         for (restart in restarts) {
[10:26:07.912]                           name <- restart$name
[10:26:07.912]                           if (is.null(name)) 
[10:26:07.912]                             next
[10:26:07.912]                           if (!grepl(pattern, name)) 
[10:26:07.912]                             next
[10:26:07.912]                           invokeRestart(restart)
[10:26:07.912]                           muffled <- TRUE
[10:26:07.912]                           break
[10:26:07.912]                         }
[10:26:07.912]                       }
[10:26:07.912]                     }
[10:26:07.912]                     invisible(muffled)
[10:26:07.912]                   }
[10:26:07.912]                   muffleCondition(cond)
[10:26:07.912]                 })
[10:26:07.912]             }))
[10:26:07.912]             future::FutureResult(value = ...future.value$value, 
[10:26:07.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.912]                   ...future.rng), globalenv = if (FALSE) 
[10:26:07.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:07.912]                     ...future.globalenv.names))
[10:26:07.912]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:07.912]         }, condition = base::local({
[10:26:07.912]             c <- base::c
[10:26:07.912]             inherits <- base::inherits
[10:26:07.912]             invokeRestart <- base::invokeRestart
[10:26:07.912]             length <- base::length
[10:26:07.912]             list <- base::list
[10:26:07.912]             seq.int <- base::seq.int
[10:26:07.912]             signalCondition <- base::signalCondition
[10:26:07.912]             sys.calls <- base::sys.calls
[10:26:07.912]             `[[` <- base::`[[`
[10:26:07.912]             `+` <- base::`+`
[10:26:07.912]             `<<-` <- base::`<<-`
[10:26:07.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:07.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:07.912]                   3L)]
[10:26:07.912]             }
[10:26:07.912]             function(cond) {
[10:26:07.912]                 is_error <- inherits(cond, "error")
[10:26:07.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:07.912]                   NULL)
[10:26:07.912]                 if (is_error) {
[10:26:07.912]                   sessionInformation <- function() {
[10:26:07.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:07.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:07.912]                       search = base::search(), system = base::Sys.info())
[10:26:07.912]                   }
[10:26:07.912]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:07.912]                     cond$call), session = sessionInformation(), 
[10:26:07.912]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:07.912]                   signalCondition(cond)
[10:26:07.912]                 }
[10:26:07.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:07.912]                 "immediateCondition"))) {
[10:26:07.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:07.912]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:07.912]                   if (TRUE && !signal) {
[10:26:07.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.912]                     {
[10:26:07.912]                       inherits <- base::inherits
[10:26:07.912]                       invokeRestart <- base::invokeRestart
[10:26:07.912]                       is.null <- base::is.null
[10:26:07.912]                       muffled <- FALSE
[10:26:07.912]                       if (inherits(cond, "message")) {
[10:26:07.912]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.912]                         if (muffled) 
[10:26:07.912]                           invokeRestart("muffleMessage")
[10:26:07.912]                       }
[10:26:07.912]                       else if (inherits(cond, "warning")) {
[10:26:07.912]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.912]                         if (muffled) 
[10:26:07.912]                           invokeRestart("muffleWarning")
[10:26:07.912]                       }
[10:26:07.912]                       else if (inherits(cond, "condition")) {
[10:26:07.912]                         if (!is.null(pattern)) {
[10:26:07.912]                           computeRestarts <- base::computeRestarts
[10:26:07.912]                           grepl <- base::grepl
[10:26:07.912]                           restarts <- computeRestarts(cond)
[10:26:07.912]                           for (restart in restarts) {
[10:26:07.912]                             name <- restart$name
[10:26:07.912]                             if (is.null(name)) 
[10:26:07.912]                               next
[10:26:07.912]                             if (!grepl(pattern, name)) 
[10:26:07.912]                               next
[10:26:07.912]                             invokeRestart(restart)
[10:26:07.912]                             muffled <- TRUE
[10:26:07.912]                             break
[10:26:07.912]                           }
[10:26:07.912]                         }
[10:26:07.912]                       }
[10:26:07.912]                       invisible(muffled)
[10:26:07.912]                     }
[10:26:07.912]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.912]                   }
[10:26:07.912]                 }
[10:26:07.912]                 else {
[10:26:07.912]                   if (TRUE) {
[10:26:07.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.912]                     {
[10:26:07.912]                       inherits <- base::inherits
[10:26:07.912]                       invokeRestart <- base::invokeRestart
[10:26:07.912]                       is.null <- base::is.null
[10:26:07.912]                       muffled <- FALSE
[10:26:07.912]                       if (inherits(cond, "message")) {
[10:26:07.912]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.912]                         if (muffled) 
[10:26:07.912]                           invokeRestart("muffleMessage")
[10:26:07.912]                       }
[10:26:07.912]                       else if (inherits(cond, "warning")) {
[10:26:07.912]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.912]                         if (muffled) 
[10:26:07.912]                           invokeRestart("muffleWarning")
[10:26:07.912]                       }
[10:26:07.912]                       else if (inherits(cond, "condition")) {
[10:26:07.912]                         if (!is.null(pattern)) {
[10:26:07.912]                           computeRestarts <- base::computeRestarts
[10:26:07.912]                           grepl <- base::grepl
[10:26:07.912]                           restarts <- computeRestarts(cond)
[10:26:07.912]                           for (restart in restarts) {
[10:26:07.912]                             name <- restart$name
[10:26:07.912]                             if (is.null(name)) 
[10:26:07.912]                               next
[10:26:07.912]                             if (!grepl(pattern, name)) 
[10:26:07.912]                               next
[10:26:07.912]                             invokeRestart(restart)
[10:26:07.912]                             muffled <- TRUE
[10:26:07.912]                             break
[10:26:07.912]                           }
[10:26:07.912]                         }
[10:26:07.912]                       }
[10:26:07.912]                       invisible(muffled)
[10:26:07.912]                     }
[10:26:07.912]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.912]                   }
[10:26:07.912]                 }
[10:26:07.912]             }
[10:26:07.912]         }))
[10:26:07.912]     }, error = function(ex) {
[10:26:07.912]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:07.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.912]                 ...future.rng), started = ...future.startTime, 
[10:26:07.912]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:07.912]             version = "1.8"), class = "FutureResult")
[10:26:07.912]     }, finally = {
[10:26:07.912]         if (!identical(...future.workdir, getwd())) 
[10:26:07.912]             setwd(...future.workdir)
[10:26:07.912]         {
[10:26:07.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:07.912]                 ...future.oldOptions$nwarnings <- NULL
[10:26:07.912]             }
[10:26:07.912]             base::options(...future.oldOptions)
[10:26:07.912]             if (.Platform$OS.type == "windows") {
[10:26:07.912]                 old_names <- names(...future.oldEnvVars)
[10:26:07.912]                 envs <- base::Sys.getenv()
[10:26:07.912]                 names <- names(envs)
[10:26:07.912]                 common <- intersect(names, old_names)
[10:26:07.912]                 added <- setdiff(names, old_names)
[10:26:07.912]                 removed <- setdiff(old_names, names)
[10:26:07.912]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:07.912]                   envs[common]]
[10:26:07.912]                 NAMES <- toupper(changed)
[10:26:07.912]                 args <- list()
[10:26:07.912]                 for (kk in seq_along(NAMES)) {
[10:26:07.912]                   name <- changed[[kk]]
[10:26:07.912]                   NAME <- NAMES[[kk]]
[10:26:07.912]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.912]                     next
[10:26:07.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.912]                 }
[10:26:07.912]                 NAMES <- toupper(added)
[10:26:07.912]                 for (kk in seq_along(NAMES)) {
[10:26:07.912]                   name <- added[[kk]]
[10:26:07.912]                   NAME <- NAMES[[kk]]
[10:26:07.912]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.912]                     next
[10:26:07.912]                   args[[name]] <- ""
[10:26:07.912]                 }
[10:26:07.912]                 NAMES <- toupper(removed)
[10:26:07.912]                 for (kk in seq_along(NAMES)) {
[10:26:07.912]                   name <- removed[[kk]]
[10:26:07.912]                   NAME <- NAMES[[kk]]
[10:26:07.912]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.912]                     next
[10:26:07.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.912]                 }
[10:26:07.912]                 if (length(args) > 0) 
[10:26:07.912]                   base::do.call(base::Sys.setenv, args = args)
[10:26:07.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:07.912]             }
[10:26:07.912]             else {
[10:26:07.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:07.912]             }
[10:26:07.912]             {
[10:26:07.912]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:07.912]                   0L) {
[10:26:07.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:07.912]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:07.912]                   base::options(opts)
[10:26:07.912]                 }
[10:26:07.912]                 {
[10:26:07.912]                   {
[10:26:07.912]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:07.912]                     NULL
[10:26:07.912]                   }
[10:26:07.912]                   options(future.plan = NULL)
[10:26:07.912]                   if (is.na(NA_character_)) 
[10:26:07.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:07.912]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:07.912]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:07.912]                     envir = parent.frame()) 
[10:26:07.912]                   {
[10:26:07.912]                     if (is.function(workers)) 
[10:26:07.912]                       workers <- workers()
[10:26:07.912]                     workers <- structure(as.integer(workers), 
[10:26:07.912]                       class = class(workers))
[10:26:07.912]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:07.912]                       workers >= 1)
[10:26:07.912]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:07.912]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:07.912]                     }
[10:26:07.912]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:07.912]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:07.912]                       envir = envir)
[10:26:07.912]                     if (!future$lazy) 
[10:26:07.912]                       future <- run(future)
[10:26:07.912]                     invisible(future)
[10:26:07.912]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:07.912]                 }
[10:26:07.912]             }
[10:26:07.912]         }
[10:26:07.912]     })
[10:26:07.912]     if (TRUE) {
[10:26:07.912]         base::sink(type = "output", split = FALSE)
[10:26:07.912]         if (TRUE) {
[10:26:07.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:07.912]         }
[10:26:07.912]         else {
[10:26:07.912]             ...future.result["stdout"] <- base::list(NULL)
[10:26:07.912]         }
[10:26:07.912]         base::close(...future.stdout)
[10:26:07.912]         ...future.stdout <- NULL
[10:26:07.912]     }
[10:26:07.912]     ...future.result$conditions <- ...future.conditions
[10:26:07.912]     ...future.result$finished <- base::Sys.time()
[10:26:07.912]     ...future.result
[10:26:07.912] }
[10:26:07.915] MultisessionFuture started
[10:26:07.915] - Launch lazy future ... done
[10:26:07.915] run() for ‘MultisessionFuture’ ... done
[10:26:07.916] result() for ClusterFuture ...
[10:26:07.916] receiveMessageFromWorker() for ClusterFuture ...
[10:26:07.916] - Validating connection of MultisessionFuture
[10:26:07.962] - received message: FutureResult
[10:26:07.962] - Received FutureResult
[10:26:07.962] - Erased future from FutureRegistry
[10:26:07.962] result() for ClusterFuture ...
[10:26:07.962] - result already collected: FutureResult
[10:26:07.963] result() for ClusterFuture ... done
[10:26:07.963] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:07.963] result() for ClusterFuture ... done
[10:26:07.963] result() for ClusterFuture ...
[10:26:07.963] - result already collected: FutureResult
[10:26:07.963] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:07.964] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:07.964] Searching for globals...
[10:26:07.966] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:07.966] Searching for globals ... DONE
[10:26:07.966] Resolving globals: TRUE
[10:26:07.966] Resolving any globals that are futures ...
[10:26:07.966] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:07.966] Resolving any globals that are futures ... DONE
[10:26:07.967] Resolving futures part of globals (recursively) ...
[10:26:07.967] resolve() on list ...
[10:26:07.967]  recursive: 99
[10:26:07.967]  length: 1
[10:26:07.967]  elements: ‘x’
[10:26:07.967]  length: 0 (resolved future 1)
[10:26:07.967] resolve() on list ... DONE
[10:26:07.967] - globals: [1] ‘x’
[10:26:07.968] Resolving futures part of globals (recursively) ... DONE
[10:26:07.968] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:07.968] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:07.968] - globals: [1] ‘x’
[10:26:07.968] 
[10:26:07.968] getGlobalsAndPackages() ... DONE
[10:26:07.969] run() for ‘Future’ ...
[10:26:07.969] - state: ‘created’
[10:26:07.969] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:07.982] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:07.982] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:07.982]   - Field: ‘node’
[10:26:07.983]   - Field: ‘label’
[10:26:07.983]   - Field: ‘local’
[10:26:07.983]   - Field: ‘owner’
[10:26:07.983]   - Field: ‘envir’
[10:26:07.983]   - Field: ‘workers’
[10:26:07.983]   - Field: ‘packages’
[10:26:07.983]   - Field: ‘gc’
[10:26:07.983]   - Field: ‘conditions’
[10:26:07.983]   - Field: ‘persistent’
[10:26:07.983]   - Field: ‘expr’
[10:26:07.984]   - Field: ‘uuid’
[10:26:07.984]   - Field: ‘seed’
[10:26:07.984]   - Field: ‘version’
[10:26:07.984]   - Field: ‘result’
[10:26:07.984]   - Field: ‘asynchronous’
[10:26:07.984]   - Field: ‘calls’
[10:26:07.984]   - Field: ‘globals’
[10:26:07.984]   - Field: ‘stdout’
[10:26:07.984]   - Field: ‘earlySignal’
[10:26:07.984]   - Field: ‘lazy’
[10:26:07.984]   - Field: ‘state’
[10:26:07.985] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:07.985] - Launch lazy future ...
[10:26:07.985] Packages needed by the future expression (n = 0): <none>
[10:26:07.985] Packages needed by future strategies (n = 0): <none>
[10:26:07.985] {
[10:26:07.985]     {
[10:26:07.985]         {
[10:26:07.985]             ...future.startTime <- base::Sys.time()
[10:26:07.985]             {
[10:26:07.985]                 {
[10:26:07.985]                   {
[10:26:07.985]                     {
[10:26:07.985]                       base::local({
[10:26:07.985]                         has_future <- base::requireNamespace("future", 
[10:26:07.985]                           quietly = TRUE)
[10:26:07.985]                         if (has_future) {
[10:26:07.985]                           ns <- base::getNamespace("future")
[10:26:07.985]                           version <- ns[[".package"]][["version"]]
[10:26:07.985]                           if (is.null(version)) 
[10:26:07.985]                             version <- utils::packageVersion("future")
[10:26:07.985]                         }
[10:26:07.985]                         else {
[10:26:07.985]                           version <- NULL
[10:26:07.985]                         }
[10:26:07.985]                         if (!has_future || version < "1.8.0") {
[10:26:07.985]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:07.985]                             "", base::R.version$version.string), 
[10:26:07.985]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:07.985]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:07.985]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:07.985]                               "release", "version")], collapse = " "), 
[10:26:07.985]                             hostname = base::Sys.info()[["nodename"]])
[10:26:07.985]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:07.985]                             info)
[10:26:07.985]                           info <- base::paste(info, collapse = "; ")
[10:26:07.985]                           if (!has_future) {
[10:26:07.985]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:07.985]                               info)
[10:26:07.985]                           }
[10:26:07.985]                           else {
[10:26:07.985]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:07.985]                               info, version)
[10:26:07.985]                           }
[10:26:07.985]                           base::stop(msg)
[10:26:07.985]                         }
[10:26:07.985]                       })
[10:26:07.985]                     }
[10:26:07.985]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:07.985]                     base::options(mc.cores = 1L)
[10:26:07.985]                   }
[10:26:07.985]                   options(future.plan = NULL)
[10:26:07.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:07.985]                 }
[10:26:07.985]                 ...future.workdir <- getwd()
[10:26:07.985]             }
[10:26:07.985]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:07.985]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:07.985]         }
[10:26:07.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:07.985]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:07.985]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:07.985]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:07.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:07.985]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:07.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:07.985]             base::names(...future.oldOptions))
[10:26:07.985]     }
[10:26:07.985]     if (FALSE) {
[10:26:07.985]     }
[10:26:07.985]     else {
[10:26:07.985]         if (TRUE) {
[10:26:07.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:07.985]                 open = "w")
[10:26:07.985]         }
[10:26:07.985]         else {
[10:26:07.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:07.985]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:07.985]         }
[10:26:07.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:07.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:07.985]             base::sink(type = "output", split = FALSE)
[10:26:07.985]             base::close(...future.stdout)
[10:26:07.985]         }, add = TRUE)
[10:26:07.985]     }
[10:26:07.985]     ...future.frame <- base::sys.nframe()
[10:26:07.985]     ...future.conditions <- base::list()
[10:26:07.985]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:07.985]     if (FALSE) {
[10:26:07.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:07.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:07.985]     }
[10:26:07.985]     ...future.result <- base::tryCatch({
[10:26:07.985]         base::withCallingHandlers({
[10:26:07.985]             ...future.value <- base::withVisible(base::local({
[10:26:07.985]                 ...future.makeSendCondition <- base::local({
[10:26:07.985]                   sendCondition <- NULL
[10:26:07.985]                   function(frame = 1L) {
[10:26:07.985]                     if (is.function(sendCondition)) 
[10:26:07.985]                       return(sendCondition)
[10:26:07.985]                     ns <- getNamespace("parallel")
[10:26:07.985]                     if (exists("sendData", mode = "function", 
[10:26:07.985]                       envir = ns)) {
[10:26:07.985]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:07.985]                         envir = ns)
[10:26:07.985]                       envir <- sys.frame(frame)
[10:26:07.985]                       master <- NULL
[10:26:07.985]                       while (!identical(envir, .GlobalEnv) && 
[10:26:07.985]                         !identical(envir, emptyenv())) {
[10:26:07.985]                         if (exists("master", mode = "list", envir = envir, 
[10:26:07.985]                           inherits = FALSE)) {
[10:26:07.985]                           master <- get("master", mode = "list", 
[10:26:07.985]                             envir = envir, inherits = FALSE)
[10:26:07.985]                           if (inherits(master, c("SOCKnode", 
[10:26:07.985]                             "SOCK0node"))) {
[10:26:07.985]                             sendCondition <<- function(cond) {
[10:26:07.985]                               data <- list(type = "VALUE", value = cond, 
[10:26:07.985]                                 success = TRUE)
[10:26:07.985]                               parallel_sendData(master, data)
[10:26:07.985]                             }
[10:26:07.985]                             return(sendCondition)
[10:26:07.985]                           }
[10:26:07.985]                         }
[10:26:07.985]                         frame <- frame + 1L
[10:26:07.985]                         envir <- sys.frame(frame)
[10:26:07.985]                       }
[10:26:07.985]                     }
[10:26:07.985]                     sendCondition <<- function(cond) NULL
[10:26:07.985]                   }
[10:26:07.985]                 })
[10:26:07.985]                 withCallingHandlers({
[10:26:07.985]                   {
[10:26:07.985]                     x[["a"]] <- 1
[10:26:07.985]                     x
[10:26:07.985]                   }
[10:26:07.985]                 }, immediateCondition = function(cond) {
[10:26:07.985]                   sendCondition <- ...future.makeSendCondition()
[10:26:07.985]                   sendCondition(cond)
[10:26:07.985]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.985]                   {
[10:26:07.985]                     inherits <- base::inherits
[10:26:07.985]                     invokeRestart <- base::invokeRestart
[10:26:07.985]                     is.null <- base::is.null
[10:26:07.985]                     muffled <- FALSE
[10:26:07.985]                     if (inherits(cond, "message")) {
[10:26:07.985]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:07.985]                       if (muffled) 
[10:26:07.985]                         invokeRestart("muffleMessage")
[10:26:07.985]                     }
[10:26:07.985]                     else if (inherits(cond, "warning")) {
[10:26:07.985]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:07.985]                       if (muffled) 
[10:26:07.985]                         invokeRestart("muffleWarning")
[10:26:07.985]                     }
[10:26:07.985]                     else if (inherits(cond, "condition")) {
[10:26:07.985]                       if (!is.null(pattern)) {
[10:26:07.985]                         computeRestarts <- base::computeRestarts
[10:26:07.985]                         grepl <- base::grepl
[10:26:07.985]                         restarts <- computeRestarts(cond)
[10:26:07.985]                         for (restart in restarts) {
[10:26:07.985]                           name <- restart$name
[10:26:07.985]                           if (is.null(name)) 
[10:26:07.985]                             next
[10:26:07.985]                           if (!grepl(pattern, name)) 
[10:26:07.985]                             next
[10:26:07.985]                           invokeRestart(restart)
[10:26:07.985]                           muffled <- TRUE
[10:26:07.985]                           break
[10:26:07.985]                         }
[10:26:07.985]                       }
[10:26:07.985]                     }
[10:26:07.985]                     invisible(muffled)
[10:26:07.985]                   }
[10:26:07.985]                   muffleCondition(cond)
[10:26:07.985]                 })
[10:26:07.985]             }))
[10:26:07.985]             future::FutureResult(value = ...future.value$value, 
[10:26:07.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.985]                   ...future.rng), globalenv = if (FALSE) 
[10:26:07.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:07.985]                     ...future.globalenv.names))
[10:26:07.985]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:07.985]         }, condition = base::local({
[10:26:07.985]             c <- base::c
[10:26:07.985]             inherits <- base::inherits
[10:26:07.985]             invokeRestart <- base::invokeRestart
[10:26:07.985]             length <- base::length
[10:26:07.985]             list <- base::list
[10:26:07.985]             seq.int <- base::seq.int
[10:26:07.985]             signalCondition <- base::signalCondition
[10:26:07.985]             sys.calls <- base::sys.calls
[10:26:07.985]             `[[` <- base::`[[`
[10:26:07.985]             `+` <- base::`+`
[10:26:07.985]             `<<-` <- base::`<<-`
[10:26:07.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:07.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:07.985]                   3L)]
[10:26:07.985]             }
[10:26:07.985]             function(cond) {
[10:26:07.985]                 is_error <- inherits(cond, "error")
[10:26:07.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:07.985]                   NULL)
[10:26:07.985]                 if (is_error) {
[10:26:07.985]                   sessionInformation <- function() {
[10:26:07.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:07.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:07.985]                       search = base::search(), system = base::Sys.info())
[10:26:07.985]                   }
[10:26:07.985]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:07.985]                     cond$call), session = sessionInformation(), 
[10:26:07.985]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:07.985]                   signalCondition(cond)
[10:26:07.985]                 }
[10:26:07.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:07.985]                 "immediateCondition"))) {
[10:26:07.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:07.985]                   ...future.conditions[[length(...future.conditions) + 
[10:26:07.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:07.985]                   if (TRUE && !signal) {
[10:26:07.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.985]                     {
[10:26:07.985]                       inherits <- base::inherits
[10:26:07.985]                       invokeRestart <- base::invokeRestart
[10:26:07.985]                       is.null <- base::is.null
[10:26:07.985]                       muffled <- FALSE
[10:26:07.985]                       if (inherits(cond, "message")) {
[10:26:07.985]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.985]                         if (muffled) 
[10:26:07.985]                           invokeRestart("muffleMessage")
[10:26:07.985]                       }
[10:26:07.985]                       else if (inherits(cond, "warning")) {
[10:26:07.985]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.985]                         if (muffled) 
[10:26:07.985]                           invokeRestart("muffleWarning")
[10:26:07.985]                       }
[10:26:07.985]                       else if (inherits(cond, "condition")) {
[10:26:07.985]                         if (!is.null(pattern)) {
[10:26:07.985]                           computeRestarts <- base::computeRestarts
[10:26:07.985]                           grepl <- base::grepl
[10:26:07.985]                           restarts <- computeRestarts(cond)
[10:26:07.985]                           for (restart in restarts) {
[10:26:07.985]                             name <- restart$name
[10:26:07.985]                             if (is.null(name)) 
[10:26:07.985]                               next
[10:26:07.985]                             if (!grepl(pattern, name)) 
[10:26:07.985]                               next
[10:26:07.985]                             invokeRestart(restart)
[10:26:07.985]                             muffled <- TRUE
[10:26:07.985]                             break
[10:26:07.985]                           }
[10:26:07.985]                         }
[10:26:07.985]                       }
[10:26:07.985]                       invisible(muffled)
[10:26:07.985]                     }
[10:26:07.985]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.985]                   }
[10:26:07.985]                 }
[10:26:07.985]                 else {
[10:26:07.985]                   if (TRUE) {
[10:26:07.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:07.985]                     {
[10:26:07.985]                       inherits <- base::inherits
[10:26:07.985]                       invokeRestart <- base::invokeRestart
[10:26:07.985]                       is.null <- base::is.null
[10:26:07.985]                       muffled <- FALSE
[10:26:07.985]                       if (inherits(cond, "message")) {
[10:26:07.985]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:07.985]                         if (muffled) 
[10:26:07.985]                           invokeRestart("muffleMessage")
[10:26:07.985]                       }
[10:26:07.985]                       else if (inherits(cond, "warning")) {
[10:26:07.985]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:07.985]                         if (muffled) 
[10:26:07.985]                           invokeRestart("muffleWarning")
[10:26:07.985]                       }
[10:26:07.985]                       else if (inherits(cond, "condition")) {
[10:26:07.985]                         if (!is.null(pattern)) {
[10:26:07.985]                           computeRestarts <- base::computeRestarts
[10:26:07.985]                           grepl <- base::grepl
[10:26:07.985]                           restarts <- computeRestarts(cond)
[10:26:07.985]                           for (restart in restarts) {
[10:26:07.985]                             name <- restart$name
[10:26:07.985]                             if (is.null(name)) 
[10:26:07.985]                               next
[10:26:07.985]                             if (!grepl(pattern, name)) 
[10:26:07.985]                               next
[10:26:07.985]                             invokeRestart(restart)
[10:26:07.985]                             muffled <- TRUE
[10:26:07.985]                             break
[10:26:07.985]                           }
[10:26:07.985]                         }
[10:26:07.985]                       }
[10:26:07.985]                       invisible(muffled)
[10:26:07.985]                     }
[10:26:07.985]                     muffleCondition(cond, pattern = "^muffle")
[10:26:07.985]                   }
[10:26:07.985]                 }
[10:26:07.985]             }
[10:26:07.985]         }))
[10:26:07.985]     }, error = function(ex) {
[10:26:07.985]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:07.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:07.985]                 ...future.rng), started = ...future.startTime, 
[10:26:07.985]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:07.985]             version = "1.8"), class = "FutureResult")
[10:26:07.985]     }, finally = {
[10:26:07.985]         if (!identical(...future.workdir, getwd())) 
[10:26:07.985]             setwd(...future.workdir)
[10:26:07.985]         {
[10:26:07.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:07.985]                 ...future.oldOptions$nwarnings <- NULL
[10:26:07.985]             }
[10:26:07.985]             base::options(...future.oldOptions)
[10:26:07.985]             if (.Platform$OS.type == "windows") {
[10:26:07.985]                 old_names <- names(...future.oldEnvVars)
[10:26:07.985]                 envs <- base::Sys.getenv()
[10:26:07.985]                 names <- names(envs)
[10:26:07.985]                 common <- intersect(names, old_names)
[10:26:07.985]                 added <- setdiff(names, old_names)
[10:26:07.985]                 removed <- setdiff(old_names, names)
[10:26:07.985]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:07.985]                   envs[common]]
[10:26:07.985]                 NAMES <- toupper(changed)
[10:26:07.985]                 args <- list()
[10:26:07.985]                 for (kk in seq_along(NAMES)) {
[10:26:07.985]                   name <- changed[[kk]]
[10:26:07.985]                   NAME <- NAMES[[kk]]
[10:26:07.985]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.985]                     next
[10:26:07.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.985]                 }
[10:26:07.985]                 NAMES <- toupper(added)
[10:26:07.985]                 for (kk in seq_along(NAMES)) {
[10:26:07.985]                   name <- added[[kk]]
[10:26:07.985]                   NAME <- NAMES[[kk]]
[10:26:07.985]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.985]                     next
[10:26:07.985]                   args[[name]] <- ""
[10:26:07.985]                 }
[10:26:07.985]                 NAMES <- toupper(removed)
[10:26:07.985]                 for (kk in seq_along(NAMES)) {
[10:26:07.985]                   name <- removed[[kk]]
[10:26:07.985]                   NAME <- NAMES[[kk]]
[10:26:07.985]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:07.985]                     next
[10:26:07.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:07.985]                 }
[10:26:07.985]                 if (length(args) > 0) 
[10:26:07.985]                   base::do.call(base::Sys.setenv, args = args)
[10:26:07.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:07.985]             }
[10:26:07.985]             else {
[10:26:07.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:07.985]             }
[10:26:07.985]             {
[10:26:07.985]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:07.985]                   0L) {
[10:26:07.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:07.985]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:07.985]                   base::options(opts)
[10:26:07.985]                 }
[10:26:07.985]                 {
[10:26:07.985]                   {
[10:26:07.985]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:07.985]                     NULL
[10:26:07.985]                   }
[10:26:07.985]                   options(future.plan = NULL)
[10:26:07.985]                   if (is.na(NA_character_)) 
[10:26:07.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:07.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:07.985]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:07.985]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:07.985]                     envir = parent.frame()) 
[10:26:07.985]                   {
[10:26:07.985]                     if (is.function(workers)) 
[10:26:07.985]                       workers <- workers()
[10:26:07.985]                     workers <- structure(as.integer(workers), 
[10:26:07.985]                       class = class(workers))
[10:26:07.985]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:07.985]                       workers >= 1)
[10:26:07.985]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:07.985]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:07.985]                     }
[10:26:07.985]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:07.985]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:07.985]                       envir = envir)
[10:26:07.985]                     if (!future$lazy) 
[10:26:07.985]                       future <- run(future)
[10:26:07.985]                     invisible(future)
[10:26:07.985]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:07.985]                 }
[10:26:07.985]             }
[10:26:07.985]         }
[10:26:07.985]     })
[10:26:07.985]     if (TRUE) {
[10:26:07.985]         base::sink(type = "output", split = FALSE)
[10:26:07.985]         if (TRUE) {
[10:26:07.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:07.985]         }
[10:26:07.985]         else {
[10:26:07.985]             ...future.result["stdout"] <- base::list(NULL)
[10:26:07.985]         }
[10:26:07.985]         base::close(...future.stdout)
[10:26:07.985]         ...future.stdout <- NULL
[10:26:07.985]     }
[10:26:07.985]     ...future.result$conditions <- ...future.conditions
[10:26:07.985]     ...future.result$finished <- base::Sys.time()
[10:26:07.985]     ...future.result
[10:26:07.985] }
[10:26:07.988] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:26:07.988] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:26:07.988] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:26:07.989] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:26:07.989] MultisessionFuture started
[10:26:07.989] - Launch lazy future ... done
[10:26:07.989] run() for ‘MultisessionFuture’ ... done
[10:26:07.989] result() for ClusterFuture ...
[10:26:07.990] receiveMessageFromWorker() for ClusterFuture ...
[10:26:07.990] - Validating connection of MultisessionFuture
[10:26:08.034] - received message: FutureResult
[10:26:08.034] - Received FutureResult
[10:26:08.034] - Erased future from FutureRegistry
[10:26:08.034] result() for ClusterFuture ...
[10:26:08.034] - result already collected: FutureResult
[10:26:08.034] result() for ClusterFuture ... done
[10:26:08.034] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:08.035] result() for ClusterFuture ... done
[10:26:08.035] result() for ClusterFuture ...
[10:26:08.035] - result already collected: FutureResult
[10:26:08.035] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:08.035] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:08.035] Searching for globals...
[10:26:08.037] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:08.037] Searching for globals ... DONE
[10:26:08.037] Resolving globals: TRUE
[10:26:08.038] Resolving any globals that are futures ...
[10:26:08.038] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:08.038] Resolving any globals that are futures ... DONE
[10:26:08.038] Resolving futures part of globals (recursively) ...
[10:26:08.038] resolve() on list ...
[10:26:08.038]  recursive: 99
[10:26:08.038]  length: 1
[10:26:08.039]  elements: ‘x’
[10:26:08.039]  length: 0 (resolved future 1)
[10:26:08.039] resolve() on list ... DONE
[10:26:08.039] - globals: [1] ‘x’
[10:26:08.039] Resolving futures part of globals (recursively) ... DONE
[10:26:08.039] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:08.039] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:08.040] - globals: [1] ‘x’
[10:26:08.040] 
[10:26:08.040] getGlobalsAndPackages() ... DONE
[10:26:08.040] run() for ‘Future’ ...
[10:26:08.040] - state: ‘created’
[10:26:08.040] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:08.054] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:08.054] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:08.054]   - Field: ‘node’
[10:26:08.054]   - Field: ‘label’
[10:26:08.054]   - Field: ‘local’
[10:26:08.054]   - Field: ‘owner’
[10:26:08.054]   - Field: ‘envir’
[10:26:08.054]   - Field: ‘workers’
[10:26:08.055]   - Field: ‘packages’
[10:26:08.055]   - Field: ‘gc’
[10:26:08.055]   - Field: ‘conditions’
[10:26:08.055]   - Field: ‘persistent’
[10:26:08.055]   - Field: ‘expr’
[10:26:08.055]   - Field: ‘uuid’
[10:26:08.055]   - Field: ‘seed’
[10:26:08.055]   - Field: ‘version’
[10:26:08.055]   - Field: ‘result’
[10:26:08.055]   - Field: ‘asynchronous’
[10:26:08.056]   - Field: ‘calls’
[10:26:08.056]   - Field: ‘globals’
[10:26:08.056]   - Field: ‘stdout’
[10:26:08.056]   - Field: ‘earlySignal’
[10:26:08.056]   - Field: ‘lazy’
[10:26:08.056]   - Field: ‘state’
[10:26:08.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:08.056] - Launch lazy future ...
[10:26:08.056] Packages needed by the future expression (n = 0): <none>
[10:26:08.057] Packages needed by future strategies (n = 0): <none>
[10:26:08.057] {
[10:26:08.057]     {
[10:26:08.057]         {
[10:26:08.057]             ...future.startTime <- base::Sys.time()
[10:26:08.057]             {
[10:26:08.057]                 {
[10:26:08.057]                   {
[10:26:08.057]                     {
[10:26:08.057]                       base::local({
[10:26:08.057]                         has_future <- base::requireNamespace("future", 
[10:26:08.057]                           quietly = TRUE)
[10:26:08.057]                         if (has_future) {
[10:26:08.057]                           ns <- base::getNamespace("future")
[10:26:08.057]                           version <- ns[[".package"]][["version"]]
[10:26:08.057]                           if (is.null(version)) 
[10:26:08.057]                             version <- utils::packageVersion("future")
[10:26:08.057]                         }
[10:26:08.057]                         else {
[10:26:08.057]                           version <- NULL
[10:26:08.057]                         }
[10:26:08.057]                         if (!has_future || version < "1.8.0") {
[10:26:08.057]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:08.057]                             "", base::R.version$version.string), 
[10:26:08.057]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:08.057]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:08.057]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:08.057]                               "release", "version")], collapse = " "), 
[10:26:08.057]                             hostname = base::Sys.info()[["nodename"]])
[10:26:08.057]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:08.057]                             info)
[10:26:08.057]                           info <- base::paste(info, collapse = "; ")
[10:26:08.057]                           if (!has_future) {
[10:26:08.057]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:08.057]                               info)
[10:26:08.057]                           }
[10:26:08.057]                           else {
[10:26:08.057]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:08.057]                               info, version)
[10:26:08.057]                           }
[10:26:08.057]                           base::stop(msg)
[10:26:08.057]                         }
[10:26:08.057]                       })
[10:26:08.057]                     }
[10:26:08.057]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:08.057]                     base::options(mc.cores = 1L)
[10:26:08.057]                   }
[10:26:08.057]                   options(future.plan = NULL)
[10:26:08.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:08.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:08.057]                 }
[10:26:08.057]                 ...future.workdir <- getwd()
[10:26:08.057]             }
[10:26:08.057]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:08.057]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:08.057]         }
[10:26:08.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:08.057]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:08.057]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:08.057]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:08.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:08.057]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:08.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:08.057]             base::names(...future.oldOptions))
[10:26:08.057]     }
[10:26:08.057]     if (FALSE) {
[10:26:08.057]     }
[10:26:08.057]     else {
[10:26:08.057]         if (TRUE) {
[10:26:08.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:08.057]                 open = "w")
[10:26:08.057]         }
[10:26:08.057]         else {
[10:26:08.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:08.057]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:08.057]         }
[10:26:08.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:08.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:08.057]             base::sink(type = "output", split = FALSE)
[10:26:08.057]             base::close(...future.stdout)
[10:26:08.057]         }, add = TRUE)
[10:26:08.057]     }
[10:26:08.057]     ...future.frame <- base::sys.nframe()
[10:26:08.057]     ...future.conditions <- base::list()
[10:26:08.057]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:08.057]     if (FALSE) {
[10:26:08.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:08.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:08.057]     }
[10:26:08.057]     ...future.result <- base::tryCatch({
[10:26:08.057]         base::withCallingHandlers({
[10:26:08.057]             ...future.value <- base::withVisible(base::local({
[10:26:08.057]                 ...future.makeSendCondition <- base::local({
[10:26:08.057]                   sendCondition <- NULL
[10:26:08.057]                   function(frame = 1L) {
[10:26:08.057]                     if (is.function(sendCondition)) 
[10:26:08.057]                       return(sendCondition)
[10:26:08.057]                     ns <- getNamespace("parallel")
[10:26:08.057]                     if (exists("sendData", mode = "function", 
[10:26:08.057]                       envir = ns)) {
[10:26:08.057]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:08.057]                         envir = ns)
[10:26:08.057]                       envir <- sys.frame(frame)
[10:26:08.057]                       master <- NULL
[10:26:08.057]                       while (!identical(envir, .GlobalEnv) && 
[10:26:08.057]                         !identical(envir, emptyenv())) {
[10:26:08.057]                         if (exists("master", mode = "list", envir = envir, 
[10:26:08.057]                           inherits = FALSE)) {
[10:26:08.057]                           master <- get("master", mode = "list", 
[10:26:08.057]                             envir = envir, inherits = FALSE)
[10:26:08.057]                           if (inherits(master, c("SOCKnode", 
[10:26:08.057]                             "SOCK0node"))) {
[10:26:08.057]                             sendCondition <<- function(cond) {
[10:26:08.057]                               data <- list(type = "VALUE", value = cond, 
[10:26:08.057]                                 success = TRUE)
[10:26:08.057]                               parallel_sendData(master, data)
[10:26:08.057]                             }
[10:26:08.057]                             return(sendCondition)
[10:26:08.057]                           }
[10:26:08.057]                         }
[10:26:08.057]                         frame <- frame + 1L
[10:26:08.057]                         envir <- sys.frame(frame)
[10:26:08.057]                       }
[10:26:08.057]                     }
[10:26:08.057]                     sendCondition <<- function(cond) NULL
[10:26:08.057]                   }
[10:26:08.057]                 })
[10:26:08.057]                 withCallingHandlers({
[10:26:08.057]                   {
[10:26:08.057]                     x[["a"]] <- 1
[10:26:08.057]                     x
[10:26:08.057]                   }
[10:26:08.057]                 }, immediateCondition = function(cond) {
[10:26:08.057]                   sendCondition <- ...future.makeSendCondition()
[10:26:08.057]                   sendCondition(cond)
[10:26:08.057]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.057]                   {
[10:26:08.057]                     inherits <- base::inherits
[10:26:08.057]                     invokeRestart <- base::invokeRestart
[10:26:08.057]                     is.null <- base::is.null
[10:26:08.057]                     muffled <- FALSE
[10:26:08.057]                     if (inherits(cond, "message")) {
[10:26:08.057]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:08.057]                       if (muffled) 
[10:26:08.057]                         invokeRestart("muffleMessage")
[10:26:08.057]                     }
[10:26:08.057]                     else if (inherits(cond, "warning")) {
[10:26:08.057]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:08.057]                       if (muffled) 
[10:26:08.057]                         invokeRestart("muffleWarning")
[10:26:08.057]                     }
[10:26:08.057]                     else if (inherits(cond, "condition")) {
[10:26:08.057]                       if (!is.null(pattern)) {
[10:26:08.057]                         computeRestarts <- base::computeRestarts
[10:26:08.057]                         grepl <- base::grepl
[10:26:08.057]                         restarts <- computeRestarts(cond)
[10:26:08.057]                         for (restart in restarts) {
[10:26:08.057]                           name <- restart$name
[10:26:08.057]                           if (is.null(name)) 
[10:26:08.057]                             next
[10:26:08.057]                           if (!grepl(pattern, name)) 
[10:26:08.057]                             next
[10:26:08.057]                           invokeRestart(restart)
[10:26:08.057]                           muffled <- TRUE
[10:26:08.057]                           break
[10:26:08.057]                         }
[10:26:08.057]                       }
[10:26:08.057]                     }
[10:26:08.057]                     invisible(muffled)
[10:26:08.057]                   }
[10:26:08.057]                   muffleCondition(cond)
[10:26:08.057]                 })
[10:26:08.057]             }))
[10:26:08.057]             future::FutureResult(value = ...future.value$value, 
[10:26:08.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:08.057]                   ...future.rng), globalenv = if (FALSE) 
[10:26:08.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:08.057]                     ...future.globalenv.names))
[10:26:08.057]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:08.057]         }, condition = base::local({
[10:26:08.057]             c <- base::c
[10:26:08.057]             inherits <- base::inherits
[10:26:08.057]             invokeRestart <- base::invokeRestart
[10:26:08.057]             length <- base::length
[10:26:08.057]             list <- base::list
[10:26:08.057]             seq.int <- base::seq.int
[10:26:08.057]             signalCondition <- base::signalCondition
[10:26:08.057]             sys.calls <- base::sys.calls
[10:26:08.057]             `[[` <- base::`[[`
[10:26:08.057]             `+` <- base::`+`
[10:26:08.057]             `<<-` <- base::`<<-`
[10:26:08.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:08.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:08.057]                   3L)]
[10:26:08.057]             }
[10:26:08.057]             function(cond) {
[10:26:08.057]                 is_error <- inherits(cond, "error")
[10:26:08.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:08.057]                   NULL)
[10:26:08.057]                 if (is_error) {
[10:26:08.057]                   sessionInformation <- function() {
[10:26:08.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:08.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:08.057]                       search = base::search(), system = base::Sys.info())
[10:26:08.057]                   }
[10:26:08.057]                   ...future.conditions[[length(...future.conditions) + 
[10:26:08.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:08.057]                     cond$call), session = sessionInformation(), 
[10:26:08.057]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:08.057]                   signalCondition(cond)
[10:26:08.057]                 }
[10:26:08.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:08.057]                 "immediateCondition"))) {
[10:26:08.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:08.057]                   ...future.conditions[[length(...future.conditions) + 
[10:26:08.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:08.057]                   if (TRUE && !signal) {
[10:26:08.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.057]                     {
[10:26:08.057]                       inherits <- base::inherits
[10:26:08.057]                       invokeRestart <- base::invokeRestart
[10:26:08.057]                       is.null <- base::is.null
[10:26:08.057]                       muffled <- FALSE
[10:26:08.057]                       if (inherits(cond, "message")) {
[10:26:08.057]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:08.057]                         if (muffled) 
[10:26:08.057]                           invokeRestart("muffleMessage")
[10:26:08.057]                       }
[10:26:08.057]                       else if (inherits(cond, "warning")) {
[10:26:08.057]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:08.057]                         if (muffled) 
[10:26:08.057]                           invokeRestart("muffleWarning")
[10:26:08.057]                       }
[10:26:08.057]                       else if (inherits(cond, "condition")) {
[10:26:08.057]                         if (!is.null(pattern)) {
[10:26:08.057]                           computeRestarts <- base::computeRestarts
[10:26:08.057]                           grepl <- base::grepl
[10:26:08.057]                           restarts <- computeRestarts(cond)
[10:26:08.057]                           for (restart in restarts) {
[10:26:08.057]                             name <- restart$name
[10:26:08.057]                             if (is.null(name)) 
[10:26:08.057]                               next
[10:26:08.057]                             if (!grepl(pattern, name)) 
[10:26:08.057]                               next
[10:26:08.057]                             invokeRestart(restart)
[10:26:08.057]                             muffled <- TRUE
[10:26:08.057]                             break
[10:26:08.057]                           }
[10:26:08.057]                         }
[10:26:08.057]                       }
[10:26:08.057]                       invisible(muffled)
[10:26:08.057]                     }
[10:26:08.057]                     muffleCondition(cond, pattern = "^muffle")
[10:26:08.057]                   }
[10:26:08.057]                 }
[10:26:08.057]                 else {
[10:26:08.057]                   if (TRUE) {
[10:26:08.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.057]                     {
[10:26:08.057]                       inherits <- base::inherits
[10:26:08.057]                       invokeRestart <- base::invokeRestart
[10:26:08.057]                       is.null <- base::is.null
[10:26:08.057]                       muffled <- FALSE
[10:26:08.057]                       if (inherits(cond, "message")) {
[10:26:08.057]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:08.057]                         if (muffled) 
[10:26:08.057]                           invokeRestart("muffleMessage")
[10:26:08.057]                       }
[10:26:08.057]                       else if (inherits(cond, "warning")) {
[10:26:08.057]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:08.057]                         if (muffled) 
[10:26:08.057]                           invokeRestart("muffleWarning")
[10:26:08.057]                       }
[10:26:08.057]                       else if (inherits(cond, "condition")) {
[10:26:08.057]                         if (!is.null(pattern)) {
[10:26:08.057]                           computeRestarts <- base::computeRestarts
[10:26:08.057]                           grepl <- base::grepl
[10:26:08.057]                           restarts <- computeRestarts(cond)
[10:26:08.057]                           for (restart in restarts) {
[10:26:08.057]                             name <- restart$name
[10:26:08.057]                             if (is.null(name)) 
[10:26:08.057]                               next
[10:26:08.057]                             if (!grepl(pattern, name)) 
[10:26:08.057]                               next
[10:26:08.057]                             invokeRestart(restart)
[10:26:08.057]                             muffled <- TRUE
[10:26:08.057]                             break
[10:26:08.057]                           }
[10:26:08.057]                         }
[10:26:08.057]                       }
[10:26:08.057]                       invisible(muffled)
[10:26:08.057]                     }
[10:26:08.057]                     muffleCondition(cond, pattern = "^muffle")
[10:26:08.057]                   }
[10:26:08.057]                 }
[10:26:08.057]             }
[10:26:08.057]         }))
[10:26:08.057]     }, error = function(ex) {
[10:26:08.057]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:08.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:08.057]                 ...future.rng), started = ...future.startTime, 
[10:26:08.057]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:08.057]             version = "1.8"), class = "FutureResult")
[10:26:08.057]     }, finally = {
[10:26:08.057]         if (!identical(...future.workdir, getwd())) 
[10:26:08.057]             setwd(...future.workdir)
[10:26:08.057]         {
[10:26:08.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:08.057]                 ...future.oldOptions$nwarnings <- NULL
[10:26:08.057]             }
[10:26:08.057]             base::options(...future.oldOptions)
[10:26:08.057]             if (.Platform$OS.type == "windows") {
[10:26:08.057]                 old_names <- names(...future.oldEnvVars)
[10:26:08.057]                 envs <- base::Sys.getenv()
[10:26:08.057]                 names <- names(envs)
[10:26:08.057]                 common <- intersect(names, old_names)
[10:26:08.057]                 added <- setdiff(names, old_names)
[10:26:08.057]                 removed <- setdiff(old_names, names)
[10:26:08.057]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:08.057]                   envs[common]]
[10:26:08.057]                 NAMES <- toupper(changed)
[10:26:08.057]                 args <- list()
[10:26:08.057]                 for (kk in seq_along(NAMES)) {
[10:26:08.057]                   name <- changed[[kk]]
[10:26:08.057]                   NAME <- NAMES[[kk]]
[10:26:08.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.057]                     next
[10:26:08.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:08.057]                 }
[10:26:08.057]                 NAMES <- toupper(added)
[10:26:08.057]                 for (kk in seq_along(NAMES)) {
[10:26:08.057]                   name <- added[[kk]]
[10:26:08.057]                   NAME <- NAMES[[kk]]
[10:26:08.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.057]                     next
[10:26:08.057]                   args[[name]] <- ""
[10:26:08.057]                 }
[10:26:08.057]                 NAMES <- toupper(removed)
[10:26:08.057]                 for (kk in seq_along(NAMES)) {
[10:26:08.057]                   name <- removed[[kk]]
[10:26:08.057]                   NAME <- NAMES[[kk]]
[10:26:08.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.057]                     next
[10:26:08.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:08.057]                 }
[10:26:08.057]                 if (length(args) > 0) 
[10:26:08.057]                   base::do.call(base::Sys.setenv, args = args)
[10:26:08.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:08.057]             }
[10:26:08.057]             else {
[10:26:08.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:08.057]             }
[10:26:08.057]             {
[10:26:08.057]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:08.057]                   0L) {
[10:26:08.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:08.057]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:08.057]                   base::options(opts)
[10:26:08.057]                 }
[10:26:08.057]                 {
[10:26:08.057]                   {
[10:26:08.057]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:08.057]                     NULL
[10:26:08.057]                   }
[10:26:08.057]                   options(future.plan = NULL)
[10:26:08.057]                   if (is.na(NA_character_)) 
[10:26:08.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:08.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:08.057]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:08.057]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:08.057]                     envir = parent.frame()) 
[10:26:08.057]                   {
[10:26:08.057]                     if (is.function(workers)) 
[10:26:08.057]                       workers <- workers()
[10:26:08.057]                     workers <- structure(as.integer(workers), 
[10:26:08.057]                       class = class(workers))
[10:26:08.057]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:08.057]                       workers >= 1)
[10:26:08.057]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:08.057]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:08.057]                     }
[10:26:08.057]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:08.057]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:08.057]                       envir = envir)
[10:26:08.057]                     if (!future$lazy) 
[10:26:08.057]                       future <- run(future)
[10:26:08.057]                     invisible(future)
[10:26:08.057]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:08.057]                 }
[10:26:08.057]             }
[10:26:08.057]         }
[10:26:08.057]     })
[10:26:08.057]     if (TRUE) {
[10:26:08.057]         base::sink(type = "output", split = FALSE)
[10:26:08.057]         if (TRUE) {
[10:26:08.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:08.057]         }
[10:26:08.057]         else {
[10:26:08.057]             ...future.result["stdout"] <- base::list(NULL)
[10:26:08.057]         }
[10:26:08.057]         base::close(...future.stdout)
[10:26:08.057]         ...future.stdout <- NULL
[10:26:08.057]     }
[10:26:08.057]     ...future.result$conditions <- ...future.conditions
[10:26:08.057]     ...future.result$finished <- base::Sys.time()
[10:26:08.057]     ...future.result
[10:26:08.057] }
[10:26:08.060] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:26:08.060] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:26:08.060] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:26:08.060] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:26:08.061] MultisessionFuture started
[10:26:08.061] - Launch lazy future ... done
[10:26:08.061] run() for ‘MultisessionFuture’ ... done
[10:26:08.061] result() for ClusterFuture ...
[10:26:08.061] receiveMessageFromWorker() for ClusterFuture ...
[10:26:08.061] - Validating connection of MultisessionFuture
[10:26:08.106] - received message: FutureResult
[10:26:08.106] - Received FutureResult
[10:26:08.106] - Erased future from FutureRegistry
[10:26:08.107] result() for ClusterFuture ...
[10:26:08.107] - result already collected: FutureResult
[10:26:08.107] result() for ClusterFuture ... done
[10:26:08.107] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:08.107] result() for ClusterFuture ... done
[10:26:08.107] result() for ClusterFuture ...
[10:26:08.107] - result already collected: FutureResult
[10:26:08.107] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:08.108] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:08.108] Searching for globals...
[10:26:08.111] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:08.111] Searching for globals ... DONE
[10:26:08.111] Resolving globals: TRUE
[10:26:08.111] Resolving any globals that are futures ...
[10:26:08.111] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:26:08.111] Resolving any globals that are futures ... DONE
[10:26:08.112] Resolving futures part of globals (recursively) ...
[10:26:08.112] resolve() on list ...
[10:26:08.112]  recursive: 99
[10:26:08.115]  length: 1
[10:26:08.115]  elements: ‘x’
[10:26:08.115]  length: 0 (resolved future 1)
[10:26:08.115] resolve() on list ... DONE
[10:26:08.115] - globals: [1] ‘x’
[10:26:08.115] Resolving futures part of globals (recursively) ... DONE
[10:26:08.115] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:08.116] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:08.116] - globals: [1] ‘x’
[10:26:08.116] 
[10:26:08.116] getGlobalsAndPackages() ... DONE
[10:26:08.116] run() for ‘Future’ ...
[10:26:08.117] - state: ‘created’
[10:26:08.117] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:08.132] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:08.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:08.132]   - Field: ‘node’
[10:26:08.132]   - Field: ‘label’
[10:26:08.132]   - Field: ‘local’
[10:26:08.132]   - Field: ‘owner’
[10:26:08.132]   - Field: ‘envir’
[10:26:08.133]   - Field: ‘workers’
[10:26:08.133]   - Field: ‘packages’
[10:26:08.133]   - Field: ‘gc’
[10:26:08.133]   - Field: ‘conditions’
[10:26:08.133]   - Field: ‘persistent’
[10:26:08.133]   - Field: ‘expr’
[10:26:08.133]   - Field: ‘uuid’
[10:26:08.133]   - Field: ‘seed’
[10:26:08.133]   - Field: ‘version’
[10:26:08.133]   - Field: ‘result’
[10:26:08.133]   - Field: ‘asynchronous’
[10:26:08.134]   - Field: ‘calls’
[10:26:08.134]   - Field: ‘globals’
[10:26:08.134]   - Field: ‘stdout’
[10:26:08.134]   - Field: ‘earlySignal’
[10:26:08.134]   - Field: ‘lazy’
[10:26:08.134]   - Field: ‘state’
[10:26:08.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:08.134] - Launch lazy future ...
[10:26:08.134] Packages needed by the future expression (n = 0): <none>
[10:26:08.135] Packages needed by future strategies (n = 0): <none>
[10:26:08.135] {
[10:26:08.135]     {
[10:26:08.135]         {
[10:26:08.135]             ...future.startTime <- base::Sys.time()
[10:26:08.135]             {
[10:26:08.135]                 {
[10:26:08.135]                   {
[10:26:08.135]                     {
[10:26:08.135]                       base::local({
[10:26:08.135]                         has_future <- base::requireNamespace("future", 
[10:26:08.135]                           quietly = TRUE)
[10:26:08.135]                         if (has_future) {
[10:26:08.135]                           ns <- base::getNamespace("future")
[10:26:08.135]                           version <- ns[[".package"]][["version"]]
[10:26:08.135]                           if (is.null(version)) 
[10:26:08.135]                             version <- utils::packageVersion("future")
[10:26:08.135]                         }
[10:26:08.135]                         else {
[10:26:08.135]                           version <- NULL
[10:26:08.135]                         }
[10:26:08.135]                         if (!has_future || version < "1.8.0") {
[10:26:08.135]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:08.135]                             "", base::R.version$version.string), 
[10:26:08.135]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:08.135]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:08.135]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:08.135]                               "release", "version")], collapse = " "), 
[10:26:08.135]                             hostname = base::Sys.info()[["nodename"]])
[10:26:08.135]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:08.135]                             info)
[10:26:08.135]                           info <- base::paste(info, collapse = "; ")
[10:26:08.135]                           if (!has_future) {
[10:26:08.135]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:08.135]                               info)
[10:26:08.135]                           }
[10:26:08.135]                           else {
[10:26:08.135]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:08.135]                               info, version)
[10:26:08.135]                           }
[10:26:08.135]                           base::stop(msg)
[10:26:08.135]                         }
[10:26:08.135]                       })
[10:26:08.135]                     }
[10:26:08.135]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:08.135]                     base::options(mc.cores = 1L)
[10:26:08.135]                   }
[10:26:08.135]                   options(future.plan = NULL)
[10:26:08.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:08.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:08.135]                 }
[10:26:08.135]                 ...future.workdir <- getwd()
[10:26:08.135]             }
[10:26:08.135]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:08.135]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:08.135]         }
[10:26:08.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:08.135]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:08.135]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:08.135]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:08.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:08.135]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:08.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:08.135]             base::names(...future.oldOptions))
[10:26:08.135]     }
[10:26:08.135]     if (FALSE) {
[10:26:08.135]     }
[10:26:08.135]     else {
[10:26:08.135]         if (TRUE) {
[10:26:08.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:08.135]                 open = "w")
[10:26:08.135]         }
[10:26:08.135]         else {
[10:26:08.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:08.135]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:08.135]         }
[10:26:08.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:08.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:08.135]             base::sink(type = "output", split = FALSE)
[10:26:08.135]             base::close(...future.stdout)
[10:26:08.135]         }, add = TRUE)
[10:26:08.135]     }
[10:26:08.135]     ...future.frame <- base::sys.nframe()
[10:26:08.135]     ...future.conditions <- base::list()
[10:26:08.135]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:08.135]     if (FALSE) {
[10:26:08.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:08.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:08.135]     }
[10:26:08.135]     ...future.result <- base::tryCatch({
[10:26:08.135]         base::withCallingHandlers({
[10:26:08.135]             ...future.value <- base::withVisible(base::local({
[10:26:08.135]                 ...future.makeSendCondition <- base::local({
[10:26:08.135]                   sendCondition <- NULL
[10:26:08.135]                   function(frame = 1L) {
[10:26:08.135]                     if (is.function(sendCondition)) 
[10:26:08.135]                       return(sendCondition)
[10:26:08.135]                     ns <- getNamespace("parallel")
[10:26:08.135]                     if (exists("sendData", mode = "function", 
[10:26:08.135]                       envir = ns)) {
[10:26:08.135]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:08.135]                         envir = ns)
[10:26:08.135]                       envir <- sys.frame(frame)
[10:26:08.135]                       master <- NULL
[10:26:08.135]                       while (!identical(envir, .GlobalEnv) && 
[10:26:08.135]                         !identical(envir, emptyenv())) {
[10:26:08.135]                         if (exists("master", mode = "list", envir = envir, 
[10:26:08.135]                           inherits = FALSE)) {
[10:26:08.135]                           master <- get("master", mode = "list", 
[10:26:08.135]                             envir = envir, inherits = FALSE)
[10:26:08.135]                           if (inherits(master, c("SOCKnode", 
[10:26:08.135]                             "SOCK0node"))) {
[10:26:08.135]                             sendCondition <<- function(cond) {
[10:26:08.135]                               data <- list(type = "VALUE", value = cond, 
[10:26:08.135]                                 success = TRUE)
[10:26:08.135]                               parallel_sendData(master, data)
[10:26:08.135]                             }
[10:26:08.135]                             return(sendCondition)
[10:26:08.135]                           }
[10:26:08.135]                         }
[10:26:08.135]                         frame <- frame + 1L
[10:26:08.135]                         envir <- sys.frame(frame)
[10:26:08.135]                       }
[10:26:08.135]                     }
[10:26:08.135]                     sendCondition <<- function(cond) NULL
[10:26:08.135]                   }
[10:26:08.135]                 })
[10:26:08.135]                 withCallingHandlers({
[10:26:08.135]                   {
[10:26:08.135]                     x[["a"]] <- 1
[10:26:08.135]                     x
[10:26:08.135]                   }
[10:26:08.135]                 }, immediateCondition = function(cond) {
[10:26:08.135]                   sendCondition <- ...future.makeSendCondition()
[10:26:08.135]                   sendCondition(cond)
[10:26:08.135]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.135]                   {
[10:26:08.135]                     inherits <- base::inherits
[10:26:08.135]                     invokeRestart <- base::invokeRestart
[10:26:08.135]                     is.null <- base::is.null
[10:26:08.135]                     muffled <- FALSE
[10:26:08.135]                     if (inherits(cond, "message")) {
[10:26:08.135]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:08.135]                       if (muffled) 
[10:26:08.135]                         invokeRestart("muffleMessage")
[10:26:08.135]                     }
[10:26:08.135]                     else if (inherits(cond, "warning")) {
[10:26:08.135]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:08.135]                       if (muffled) 
[10:26:08.135]                         invokeRestart("muffleWarning")
[10:26:08.135]                     }
[10:26:08.135]                     else if (inherits(cond, "condition")) {
[10:26:08.135]                       if (!is.null(pattern)) {
[10:26:08.135]                         computeRestarts <- base::computeRestarts
[10:26:08.135]                         grepl <- base::grepl
[10:26:08.135]                         restarts <- computeRestarts(cond)
[10:26:08.135]                         for (restart in restarts) {
[10:26:08.135]                           name <- restart$name
[10:26:08.135]                           if (is.null(name)) 
[10:26:08.135]                             next
[10:26:08.135]                           if (!grepl(pattern, name)) 
[10:26:08.135]                             next
[10:26:08.135]                           invokeRestart(restart)
[10:26:08.135]                           muffled <- TRUE
[10:26:08.135]                           break
[10:26:08.135]                         }
[10:26:08.135]                       }
[10:26:08.135]                     }
[10:26:08.135]                     invisible(muffled)
[10:26:08.135]                   }
[10:26:08.135]                   muffleCondition(cond)
[10:26:08.135]                 })
[10:26:08.135]             }))
[10:26:08.135]             future::FutureResult(value = ...future.value$value, 
[10:26:08.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:08.135]                   ...future.rng), globalenv = if (FALSE) 
[10:26:08.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:08.135]                     ...future.globalenv.names))
[10:26:08.135]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:08.135]         }, condition = base::local({
[10:26:08.135]             c <- base::c
[10:26:08.135]             inherits <- base::inherits
[10:26:08.135]             invokeRestart <- base::invokeRestart
[10:26:08.135]             length <- base::length
[10:26:08.135]             list <- base::list
[10:26:08.135]             seq.int <- base::seq.int
[10:26:08.135]             signalCondition <- base::signalCondition
[10:26:08.135]             sys.calls <- base::sys.calls
[10:26:08.135]             `[[` <- base::`[[`
[10:26:08.135]             `+` <- base::`+`
[10:26:08.135]             `<<-` <- base::`<<-`
[10:26:08.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:08.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:08.135]                   3L)]
[10:26:08.135]             }
[10:26:08.135]             function(cond) {
[10:26:08.135]                 is_error <- inherits(cond, "error")
[10:26:08.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:08.135]                   NULL)
[10:26:08.135]                 if (is_error) {
[10:26:08.135]                   sessionInformation <- function() {
[10:26:08.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:08.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:08.135]                       search = base::search(), system = base::Sys.info())
[10:26:08.135]                   }
[10:26:08.135]                   ...future.conditions[[length(...future.conditions) + 
[10:26:08.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:08.135]                     cond$call), session = sessionInformation(), 
[10:26:08.135]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:08.135]                   signalCondition(cond)
[10:26:08.135]                 }
[10:26:08.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:08.135]                 "immediateCondition"))) {
[10:26:08.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:08.135]                   ...future.conditions[[length(...future.conditions) + 
[10:26:08.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:08.135]                   if (TRUE && !signal) {
[10:26:08.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.135]                     {
[10:26:08.135]                       inherits <- base::inherits
[10:26:08.135]                       invokeRestart <- base::invokeRestart
[10:26:08.135]                       is.null <- base::is.null
[10:26:08.135]                       muffled <- FALSE
[10:26:08.135]                       if (inherits(cond, "message")) {
[10:26:08.135]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:08.135]                         if (muffled) 
[10:26:08.135]                           invokeRestart("muffleMessage")
[10:26:08.135]                       }
[10:26:08.135]                       else if (inherits(cond, "warning")) {
[10:26:08.135]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:08.135]                         if (muffled) 
[10:26:08.135]                           invokeRestart("muffleWarning")
[10:26:08.135]                       }
[10:26:08.135]                       else if (inherits(cond, "condition")) {
[10:26:08.135]                         if (!is.null(pattern)) {
[10:26:08.135]                           computeRestarts <- base::computeRestarts
[10:26:08.135]                           grepl <- base::grepl
[10:26:08.135]                           restarts <- computeRestarts(cond)
[10:26:08.135]                           for (restart in restarts) {
[10:26:08.135]                             name <- restart$name
[10:26:08.135]                             if (is.null(name)) 
[10:26:08.135]                               next
[10:26:08.135]                             if (!grepl(pattern, name)) 
[10:26:08.135]                               next
[10:26:08.135]                             invokeRestart(restart)
[10:26:08.135]                             muffled <- TRUE
[10:26:08.135]                             break
[10:26:08.135]                           }
[10:26:08.135]                         }
[10:26:08.135]                       }
[10:26:08.135]                       invisible(muffled)
[10:26:08.135]                     }
[10:26:08.135]                     muffleCondition(cond, pattern = "^muffle")
[10:26:08.135]                   }
[10:26:08.135]                 }
[10:26:08.135]                 else {
[10:26:08.135]                   if (TRUE) {
[10:26:08.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.135]                     {
[10:26:08.135]                       inherits <- base::inherits
[10:26:08.135]                       invokeRestart <- base::invokeRestart
[10:26:08.135]                       is.null <- base::is.null
[10:26:08.135]                       muffled <- FALSE
[10:26:08.135]                       if (inherits(cond, "message")) {
[10:26:08.135]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:08.135]                         if (muffled) 
[10:26:08.135]                           invokeRestart("muffleMessage")
[10:26:08.135]                       }
[10:26:08.135]                       else if (inherits(cond, "warning")) {
[10:26:08.135]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:08.135]                         if (muffled) 
[10:26:08.135]                           invokeRestart("muffleWarning")
[10:26:08.135]                       }
[10:26:08.135]                       else if (inherits(cond, "condition")) {
[10:26:08.135]                         if (!is.null(pattern)) {
[10:26:08.135]                           computeRestarts <- base::computeRestarts
[10:26:08.135]                           grepl <- base::grepl
[10:26:08.135]                           restarts <- computeRestarts(cond)
[10:26:08.135]                           for (restart in restarts) {
[10:26:08.135]                             name <- restart$name
[10:26:08.135]                             if (is.null(name)) 
[10:26:08.135]                               next
[10:26:08.135]                             if (!grepl(pattern, name)) 
[10:26:08.135]                               next
[10:26:08.135]                             invokeRestart(restart)
[10:26:08.135]                             muffled <- TRUE
[10:26:08.135]                             break
[10:26:08.135]                           }
[10:26:08.135]                         }
[10:26:08.135]                       }
[10:26:08.135]                       invisible(muffled)
[10:26:08.135]                     }
[10:26:08.135]                     muffleCondition(cond, pattern = "^muffle")
[10:26:08.135]                   }
[10:26:08.135]                 }
[10:26:08.135]             }
[10:26:08.135]         }))
[10:26:08.135]     }, error = function(ex) {
[10:26:08.135]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:08.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:08.135]                 ...future.rng), started = ...future.startTime, 
[10:26:08.135]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:08.135]             version = "1.8"), class = "FutureResult")
[10:26:08.135]     }, finally = {
[10:26:08.135]         if (!identical(...future.workdir, getwd())) 
[10:26:08.135]             setwd(...future.workdir)
[10:26:08.135]         {
[10:26:08.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:08.135]                 ...future.oldOptions$nwarnings <- NULL
[10:26:08.135]             }
[10:26:08.135]             base::options(...future.oldOptions)
[10:26:08.135]             if (.Platform$OS.type == "windows") {
[10:26:08.135]                 old_names <- names(...future.oldEnvVars)
[10:26:08.135]                 envs <- base::Sys.getenv()
[10:26:08.135]                 names <- names(envs)
[10:26:08.135]                 common <- intersect(names, old_names)
[10:26:08.135]                 added <- setdiff(names, old_names)
[10:26:08.135]                 removed <- setdiff(old_names, names)
[10:26:08.135]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:08.135]                   envs[common]]
[10:26:08.135]                 NAMES <- toupper(changed)
[10:26:08.135]                 args <- list()
[10:26:08.135]                 for (kk in seq_along(NAMES)) {
[10:26:08.135]                   name <- changed[[kk]]
[10:26:08.135]                   NAME <- NAMES[[kk]]
[10:26:08.135]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.135]                     next
[10:26:08.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:08.135]                 }
[10:26:08.135]                 NAMES <- toupper(added)
[10:26:08.135]                 for (kk in seq_along(NAMES)) {
[10:26:08.135]                   name <- added[[kk]]
[10:26:08.135]                   NAME <- NAMES[[kk]]
[10:26:08.135]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.135]                     next
[10:26:08.135]                   args[[name]] <- ""
[10:26:08.135]                 }
[10:26:08.135]                 NAMES <- toupper(removed)
[10:26:08.135]                 for (kk in seq_along(NAMES)) {
[10:26:08.135]                   name <- removed[[kk]]
[10:26:08.135]                   NAME <- NAMES[[kk]]
[10:26:08.135]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.135]                     next
[10:26:08.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:08.135]                 }
[10:26:08.135]                 if (length(args) > 0) 
[10:26:08.135]                   base::do.call(base::Sys.setenv, args = args)
[10:26:08.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:08.135]             }
[10:26:08.135]             else {
[10:26:08.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:08.135]             }
[10:26:08.135]             {
[10:26:08.135]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:08.135]                   0L) {
[10:26:08.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:08.135]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:08.135]                   base::options(opts)
[10:26:08.135]                 }
[10:26:08.135]                 {
[10:26:08.135]                   {
[10:26:08.135]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:08.135]                     NULL
[10:26:08.135]                   }
[10:26:08.135]                   options(future.plan = NULL)
[10:26:08.135]                   if (is.na(NA_character_)) 
[10:26:08.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:08.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:08.135]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:08.135]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:08.135]                     envir = parent.frame()) 
[10:26:08.135]                   {
[10:26:08.135]                     if (is.function(workers)) 
[10:26:08.135]                       workers <- workers()
[10:26:08.135]                     workers <- structure(as.integer(workers), 
[10:26:08.135]                       class = class(workers))
[10:26:08.135]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:08.135]                       workers >= 1)
[10:26:08.135]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:08.135]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:08.135]                     }
[10:26:08.135]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:08.135]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:08.135]                       envir = envir)
[10:26:08.135]                     if (!future$lazy) 
[10:26:08.135]                       future <- run(future)
[10:26:08.135]                     invisible(future)
[10:26:08.135]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:08.135]                 }
[10:26:08.135]             }
[10:26:08.135]         }
[10:26:08.135]     })
[10:26:08.135]     if (TRUE) {
[10:26:08.135]         base::sink(type = "output", split = FALSE)
[10:26:08.135]         if (TRUE) {
[10:26:08.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:08.135]         }
[10:26:08.135]         else {
[10:26:08.135]             ...future.result["stdout"] <- base::list(NULL)
[10:26:08.135]         }
[10:26:08.135]         base::close(...future.stdout)
[10:26:08.135]         ...future.stdout <- NULL
[10:26:08.135]     }
[10:26:08.135]     ...future.result$conditions <- ...future.conditions
[10:26:08.135]     ...future.result$finished <- base::Sys.time()
[10:26:08.135]     ...future.result
[10:26:08.135] }
[10:26:08.138] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:26:08.138] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:26:08.138] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:26:08.138] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:26:08.139] MultisessionFuture started
[10:26:08.139] - Launch lazy future ... done
[10:26:08.139] run() for ‘MultisessionFuture’ ... done
[10:26:08.139] result() for ClusterFuture ...
[10:26:08.139] receiveMessageFromWorker() for ClusterFuture ...
[10:26:08.139] - Validating connection of MultisessionFuture
[10:26:08.186] - received message: FutureResult
[10:26:08.186] - Received FutureResult
[10:26:08.186] - Erased future from FutureRegistry
[10:26:08.187] result() for ClusterFuture ...
[10:26:08.187] - result already collected: FutureResult
[10:26:08.187] result() for ClusterFuture ... done
[10:26:08.187] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:08.187] result() for ClusterFuture ... done
[10:26:08.187] result() for ClusterFuture ...
[10:26:08.187] - result already collected: FutureResult
[10:26:08.187] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:08.188] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:08.188] Searching for globals...
[10:26:08.190] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:08.190] Searching for globals ... DONE
[10:26:08.190] Resolving globals: TRUE
[10:26:08.190] Resolving any globals that are futures ...
[10:26:08.190] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:08.191] Resolving any globals that are futures ... DONE
[10:26:08.191] Resolving futures part of globals (recursively) ...
[10:26:08.191] resolve() on list ...
[10:26:08.191]  recursive: 99
[10:26:08.191]  length: 1
[10:26:08.191]  elements: ‘x’
[10:26:08.192]  length: 0 (resolved future 1)
[10:26:08.192] resolve() on list ... DONE
[10:26:08.192] - globals: [1] ‘x’
[10:26:08.192] Resolving futures part of globals (recursively) ... DONE
[10:26:08.192] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:08.192] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:08.192] - globals: [1] ‘x’
[10:26:08.193] 
[10:26:08.193] getGlobalsAndPackages() ... DONE
[10:26:08.193] run() for ‘Future’ ...
[10:26:08.193] - state: ‘created’
[10:26:08.193] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:08.207] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:08.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:08.207]   - Field: ‘node’
[10:26:08.207]   - Field: ‘label’
[10:26:08.207]   - Field: ‘local’
[10:26:08.207]   - Field: ‘owner’
[10:26:08.207]   - Field: ‘envir’
[10:26:08.208]   - Field: ‘workers’
[10:26:08.208]   - Field: ‘packages’
[10:26:08.208]   - Field: ‘gc’
[10:26:08.208]   - Field: ‘conditions’
[10:26:08.208]   - Field: ‘persistent’
[10:26:08.208]   - Field: ‘expr’
[10:26:08.208]   - Field: ‘uuid’
[10:26:08.208]   - Field: ‘seed’
[10:26:08.208]   - Field: ‘version’
[10:26:08.208]   - Field: ‘result’
[10:26:08.208]   - Field: ‘asynchronous’
[10:26:08.209]   - Field: ‘calls’
[10:26:08.209]   - Field: ‘globals’
[10:26:08.209]   - Field: ‘stdout’
[10:26:08.209]   - Field: ‘earlySignal’
[10:26:08.209]   - Field: ‘lazy’
[10:26:08.209]   - Field: ‘state’
[10:26:08.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:08.209] - Launch lazy future ...
[10:26:08.210] Packages needed by the future expression (n = 0): <none>
[10:26:08.210] Packages needed by future strategies (n = 0): <none>
[10:26:08.211] {
[10:26:08.211]     {
[10:26:08.211]         {
[10:26:08.211]             ...future.startTime <- base::Sys.time()
[10:26:08.211]             {
[10:26:08.211]                 {
[10:26:08.211]                   {
[10:26:08.211]                     {
[10:26:08.211]                       base::local({
[10:26:08.211]                         has_future <- base::requireNamespace("future", 
[10:26:08.211]                           quietly = TRUE)
[10:26:08.211]                         if (has_future) {
[10:26:08.211]                           ns <- base::getNamespace("future")
[10:26:08.211]                           version <- ns[[".package"]][["version"]]
[10:26:08.211]                           if (is.null(version)) 
[10:26:08.211]                             version <- utils::packageVersion("future")
[10:26:08.211]                         }
[10:26:08.211]                         else {
[10:26:08.211]                           version <- NULL
[10:26:08.211]                         }
[10:26:08.211]                         if (!has_future || version < "1.8.0") {
[10:26:08.211]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:08.211]                             "", base::R.version$version.string), 
[10:26:08.211]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:08.211]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:08.211]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:08.211]                               "release", "version")], collapse = " "), 
[10:26:08.211]                             hostname = base::Sys.info()[["nodename"]])
[10:26:08.211]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:08.211]                             info)
[10:26:08.211]                           info <- base::paste(info, collapse = "; ")
[10:26:08.211]                           if (!has_future) {
[10:26:08.211]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:08.211]                               info)
[10:26:08.211]                           }
[10:26:08.211]                           else {
[10:26:08.211]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:08.211]                               info, version)
[10:26:08.211]                           }
[10:26:08.211]                           base::stop(msg)
[10:26:08.211]                         }
[10:26:08.211]                       })
[10:26:08.211]                     }
[10:26:08.211]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:08.211]                     base::options(mc.cores = 1L)
[10:26:08.211]                   }
[10:26:08.211]                   options(future.plan = NULL)
[10:26:08.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:08.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:08.211]                 }
[10:26:08.211]                 ...future.workdir <- getwd()
[10:26:08.211]             }
[10:26:08.211]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:08.211]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:08.211]         }
[10:26:08.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:08.211]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:08.211]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:08.211]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:08.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:08.211]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:08.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:08.211]             base::names(...future.oldOptions))
[10:26:08.211]     }
[10:26:08.211]     if (FALSE) {
[10:26:08.211]     }
[10:26:08.211]     else {
[10:26:08.211]         if (TRUE) {
[10:26:08.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:08.211]                 open = "w")
[10:26:08.211]         }
[10:26:08.211]         else {
[10:26:08.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:08.211]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:08.211]         }
[10:26:08.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:08.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:08.211]             base::sink(type = "output", split = FALSE)
[10:26:08.211]             base::close(...future.stdout)
[10:26:08.211]         }, add = TRUE)
[10:26:08.211]     }
[10:26:08.211]     ...future.frame <- base::sys.nframe()
[10:26:08.211]     ...future.conditions <- base::list()
[10:26:08.211]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:08.211]     if (FALSE) {
[10:26:08.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:08.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:08.211]     }
[10:26:08.211]     ...future.result <- base::tryCatch({
[10:26:08.211]         base::withCallingHandlers({
[10:26:08.211]             ...future.value <- base::withVisible(base::local({
[10:26:08.211]                 ...future.makeSendCondition <- base::local({
[10:26:08.211]                   sendCondition <- NULL
[10:26:08.211]                   function(frame = 1L) {
[10:26:08.211]                     if (is.function(sendCondition)) 
[10:26:08.211]                       return(sendCondition)
[10:26:08.211]                     ns <- getNamespace("parallel")
[10:26:08.211]                     if (exists("sendData", mode = "function", 
[10:26:08.211]                       envir = ns)) {
[10:26:08.211]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:08.211]                         envir = ns)
[10:26:08.211]                       envir <- sys.frame(frame)
[10:26:08.211]                       master <- NULL
[10:26:08.211]                       while (!identical(envir, .GlobalEnv) && 
[10:26:08.211]                         !identical(envir, emptyenv())) {
[10:26:08.211]                         if (exists("master", mode = "list", envir = envir, 
[10:26:08.211]                           inherits = FALSE)) {
[10:26:08.211]                           master <- get("master", mode = "list", 
[10:26:08.211]                             envir = envir, inherits = FALSE)
[10:26:08.211]                           if (inherits(master, c("SOCKnode", 
[10:26:08.211]                             "SOCK0node"))) {
[10:26:08.211]                             sendCondition <<- function(cond) {
[10:26:08.211]                               data <- list(type = "VALUE", value = cond, 
[10:26:08.211]                                 success = TRUE)
[10:26:08.211]                               parallel_sendData(master, data)
[10:26:08.211]                             }
[10:26:08.211]                             return(sendCondition)
[10:26:08.211]                           }
[10:26:08.211]                         }
[10:26:08.211]                         frame <- frame + 1L
[10:26:08.211]                         envir <- sys.frame(frame)
[10:26:08.211]                       }
[10:26:08.211]                     }
[10:26:08.211]                     sendCondition <<- function(cond) NULL
[10:26:08.211]                   }
[10:26:08.211]                 })
[10:26:08.211]                 withCallingHandlers({
[10:26:08.211]                   {
[10:26:08.211]                     x["a"] <- list(1)
[10:26:08.211]                     x
[10:26:08.211]                   }
[10:26:08.211]                 }, immediateCondition = function(cond) {
[10:26:08.211]                   sendCondition <- ...future.makeSendCondition()
[10:26:08.211]                   sendCondition(cond)
[10:26:08.211]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.211]                   {
[10:26:08.211]                     inherits <- base::inherits
[10:26:08.211]                     invokeRestart <- base::invokeRestart
[10:26:08.211]                     is.null <- base::is.null
[10:26:08.211]                     muffled <- FALSE
[10:26:08.211]                     if (inherits(cond, "message")) {
[10:26:08.211]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:08.211]                       if (muffled) 
[10:26:08.211]                         invokeRestart("muffleMessage")
[10:26:08.211]                     }
[10:26:08.211]                     else if (inherits(cond, "warning")) {
[10:26:08.211]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:08.211]                       if (muffled) 
[10:26:08.211]                         invokeRestart("muffleWarning")
[10:26:08.211]                     }
[10:26:08.211]                     else if (inherits(cond, "condition")) {
[10:26:08.211]                       if (!is.null(pattern)) {
[10:26:08.211]                         computeRestarts <- base::computeRestarts
[10:26:08.211]                         grepl <- base::grepl
[10:26:08.211]                         restarts <- computeRestarts(cond)
[10:26:08.211]                         for (restart in restarts) {
[10:26:08.211]                           name <- restart$name
[10:26:08.211]                           if (is.null(name)) 
[10:26:08.211]                             next
[10:26:08.211]                           if (!grepl(pattern, name)) 
[10:26:08.211]                             next
[10:26:08.211]                           invokeRestart(restart)
[10:26:08.211]                           muffled <- TRUE
[10:26:08.211]                           break
[10:26:08.211]                         }
[10:26:08.211]                       }
[10:26:08.211]                     }
[10:26:08.211]                     invisible(muffled)
[10:26:08.211]                   }
[10:26:08.211]                   muffleCondition(cond)
[10:26:08.211]                 })
[10:26:08.211]             }))
[10:26:08.211]             future::FutureResult(value = ...future.value$value, 
[10:26:08.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:08.211]                   ...future.rng), globalenv = if (FALSE) 
[10:26:08.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:08.211]                     ...future.globalenv.names))
[10:26:08.211]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:08.211]         }, condition = base::local({
[10:26:08.211]             c <- base::c
[10:26:08.211]             inherits <- base::inherits
[10:26:08.211]             invokeRestart <- base::invokeRestart
[10:26:08.211]             length <- base::length
[10:26:08.211]             list <- base::list
[10:26:08.211]             seq.int <- base::seq.int
[10:26:08.211]             signalCondition <- base::signalCondition
[10:26:08.211]             sys.calls <- base::sys.calls
[10:26:08.211]             `[[` <- base::`[[`
[10:26:08.211]             `+` <- base::`+`
[10:26:08.211]             `<<-` <- base::`<<-`
[10:26:08.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:08.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:08.211]                   3L)]
[10:26:08.211]             }
[10:26:08.211]             function(cond) {
[10:26:08.211]                 is_error <- inherits(cond, "error")
[10:26:08.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:08.211]                   NULL)
[10:26:08.211]                 if (is_error) {
[10:26:08.211]                   sessionInformation <- function() {
[10:26:08.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:08.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:08.211]                       search = base::search(), system = base::Sys.info())
[10:26:08.211]                   }
[10:26:08.211]                   ...future.conditions[[length(...future.conditions) + 
[10:26:08.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:08.211]                     cond$call), session = sessionInformation(), 
[10:26:08.211]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:08.211]                   signalCondition(cond)
[10:26:08.211]                 }
[10:26:08.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:08.211]                 "immediateCondition"))) {
[10:26:08.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:08.211]                   ...future.conditions[[length(...future.conditions) + 
[10:26:08.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:08.211]                   if (TRUE && !signal) {
[10:26:08.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.211]                     {
[10:26:08.211]                       inherits <- base::inherits
[10:26:08.211]                       invokeRestart <- base::invokeRestart
[10:26:08.211]                       is.null <- base::is.null
[10:26:08.211]                       muffled <- FALSE
[10:26:08.211]                       if (inherits(cond, "message")) {
[10:26:08.211]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:08.211]                         if (muffled) 
[10:26:08.211]                           invokeRestart("muffleMessage")
[10:26:08.211]                       }
[10:26:08.211]                       else if (inherits(cond, "warning")) {
[10:26:08.211]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:08.211]                         if (muffled) 
[10:26:08.211]                           invokeRestart("muffleWarning")
[10:26:08.211]                       }
[10:26:08.211]                       else if (inherits(cond, "condition")) {
[10:26:08.211]                         if (!is.null(pattern)) {
[10:26:08.211]                           computeRestarts <- base::computeRestarts
[10:26:08.211]                           grepl <- base::grepl
[10:26:08.211]                           restarts <- computeRestarts(cond)
[10:26:08.211]                           for (restart in restarts) {
[10:26:08.211]                             name <- restart$name
[10:26:08.211]                             if (is.null(name)) 
[10:26:08.211]                               next
[10:26:08.211]                             if (!grepl(pattern, name)) 
[10:26:08.211]                               next
[10:26:08.211]                             invokeRestart(restart)
[10:26:08.211]                             muffled <- TRUE
[10:26:08.211]                             break
[10:26:08.211]                           }
[10:26:08.211]                         }
[10:26:08.211]                       }
[10:26:08.211]                       invisible(muffled)
[10:26:08.211]                     }
[10:26:08.211]                     muffleCondition(cond, pattern = "^muffle")
[10:26:08.211]                   }
[10:26:08.211]                 }
[10:26:08.211]                 else {
[10:26:08.211]                   if (TRUE) {
[10:26:08.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.211]                     {
[10:26:08.211]                       inherits <- base::inherits
[10:26:08.211]                       invokeRestart <- base::invokeRestart
[10:26:08.211]                       is.null <- base::is.null
[10:26:08.211]                       muffled <- FALSE
[10:26:08.211]                       if (inherits(cond, "message")) {
[10:26:08.211]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:08.211]                         if (muffled) 
[10:26:08.211]                           invokeRestart("muffleMessage")
[10:26:08.211]                       }
[10:26:08.211]                       else if (inherits(cond, "warning")) {
[10:26:08.211]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:08.211]                         if (muffled) 
[10:26:08.211]                           invokeRestart("muffleWarning")
[10:26:08.211]                       }
[10:26:08.211]                       else if (inherits(cond, "condition")) {
[10:26:08.211]                         if (!is.null(pattern)) {
[10:26:08.211]                           computeRestarts <- base::computeRestarts
[10:26:08.211]                           grepl <- base::grepl
[10:26:08.211]                           restarts <- computeRestarts(cond)
[10:26:08.211]                           for (restart in restarts) {
[10:26:08.211]                             name <- restart$name
[10:26:08.211]                             if (is.null(name)) 
[10:26:08.211]                               next
[10:26:08.211]                             if (!grepl(pattern, name)) 
[10:26:08.211]                               next
[10:26:08.211]                             invokeRestart(restart)
[10:26:08.211]                             muffled <- TRUE
[10:26:08.211]                             break
[10:26:08.211]                           }
[10:26:08.211]                         }
[10:26:08.211]                       }
[10:26:08.211]                       invisible(muffled)
[10:26:08.211]                     }
[10:26:08.211]                     muffleCondition(cond, pattern = "^muffle")
[10:26:08.211]                   }
[10:26:08.211]                 }
[10:26:08.211]             }
[10:26:08.211]         }))
[10:26:08.211]     }, error = function(ex) {
[10:26:08.211]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:08.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:08.211]                 ...future.rng), started = ...future.startTime, 
[10:26:08.211]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:08.211]             version = "1.8"), class = "FutureResult")
[10:26:08.211]     }, finally = {
[10:26:08.211]         if (!identical(...future.workdir, getwd())) 
[10:26:08.211]             setwd(...future.workdir)
[10:26:08.211]         {
[10:26:08.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:08.211]                 ...future.oldOptions$nwarnings <- NULL
[10:26:08.211]             }
[10:26:08.211]             base::options(...future.oldOptions)
[10:26:08.211]             if (.Platform$OS.type == "windows") {
[10:26:08.211]                 old_names <- names(...future.oldEnvVars)
[10:26:08.211]                 envs <- base::Sys.getenv()
[10:26:08.211]                 names <- names(envs)
[10:26:08.211]                 common <- intersect(names, old_names)
[10:26:08.211]                 added <- setdiff(names, old_names)
[10:26:08.211]                 removed <- setdiff(old_names, names)
[10:26:08.211]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:08.211]                   envs[common]]
[10:26:08.211]                 NAMES <- toupper(changed)
[10:26:08.211]                 args <- list()
[10:26:08.211]                 for (kk in seq_along(NAMES)) {
[10:26:08.211]                   name <- changed[[kk]]
[10:26:08.211]                   NAME <- NAMES[[kk]]
[10:26:08.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.211]                     next
[10:26:08.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:08.211]                 }
[10:26:08.211]                 NAMES <- toupper(added)
[10:26:08.211]                 for (kk in seq_along(NAMES)) {
[10:26:08.211]                   name <- added[[kk]]
[10:26:08.211]                   NAME <- NAMES[[kk]]
[10:26:08.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.211]                     next
[10:26:08.211]                   args[[name]] <- ""
[10:26:08.211]                 }
[10:26:08.211]                 NAMES <- toupper(removed)
[10:26:08.211]                 for (kk in seq_along(NAMES)) {
[10:26:08.211]                   name <- removed[[kk]]
[10:26:08.211]                   NAME <- NAMES[[kk]]
[10:26:08.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.211]                     next
[10:26:08.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:08.211]                 }
[10:26:08.211]                 if (length(args) > 0) 
[10:26:08.211]                   base::do.call(base::Sys.setenv, args = args)
[10:26:08.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:08.211]             }
[10:26:08.211]             else {
[10:26:08.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:08.211]             }
[10:26:08.211]             {
[10:26:08.211]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:08.211]                   0L) {
[10:26:08.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:08.211]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:08.211]                   base::options(opts)
[10:26:08.211]                 }
[10:26:08.211]                 {
[10:26:08.211]                   {
[10:26:08.211]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:08.211]                     NULL
[10:26:08.211]                   }
[10:26:08.211]                   options(future.plan = NULL)
[10:26:08.211]                   if (is.na(NA_character_)) 
[10:26:08.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:08.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:08.211]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:08.211]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:08.211]                     envir = parent.frame()) 
[10:26:08.211]                   {
[10:26:08.211]                     if (is.function(workers)) 
[10:26:08.211]                       workers <- workers()
[10:26:08.211]                     workers <- structure(as.integer(workers), 
[10:26:08.211]                       class = class(workers))
[10:26:08.211]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:08.211]                       workers >= 1)
[10:26:08.211]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:08.211]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:08.211]                     }
[10:26:08.211]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:08.211]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:08.211]                       envir = envir)
[10:26:08.211]                     if (!future$lazy) 
[10:26:08.211]                       future <- run(future)
[10:26:08.211]                     invisible(future)
[10:26:08.211]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:08.211]                 }
[10:26:08.211]             }
[10:26:08.211]         }
[10:26:08.211]     })
[10:26:08.211]     if (TRUE) {
[10:26:08.211]         base::sink(type = "output", split = FALSE)
[10:26:08.211]         if (TRUE) {
[10:26:08.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:08.211]         }
[10:26:08.211]         else {
[10:26:08.211]             ...future.result["stdout"] <- base::list(NULL)
[10:26:08.211]         }
[10:26:08.211]         base::close(...future.stdout)
[10:26:08.211]         ...future.stdout <- NULL
[10:26:08.211]     }
[10:26:08.211]     ...future.result$conditions <- ...future.conditions
[10:26:08.211]     ...future.result$finished <- base::Sys.time()
[10:26:08.211]     ...future.result
[10:26:08.211] }
[10:26:08.213] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:26:08.213] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:26:08.214] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:26:08.214] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:26:08.214] MultisessionFuture started
[10:26:08.214] - Launch lazy future ... done
[10:26:08.215] run() for ‘MultisessionFuture’ ... done
[10:26:08.215] result() for ClusterFuture ...
[10:26:08.215] receiveMessageFromWorker() for ClusterFuture ...
[10:26:08.215] - Validating connection of MultisessionFuture
[10:26:08.262] - received message: FutureResult
[10:26:08.262] - Received FutureResult
[10:26:08.262] - Erased future from FutureRegistry
[10:26:08.262] result() for ClusterFuture ...
[10:26:08.262] - result already collected: FutureResult
[10:26:08.263] result() for ClusterFuture ... done
[10:26:08.263] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:08.263] result() for ClusterFuture ... done
[10:26:08.263] result() for ClusterFuture ...
[10:26:08.263] - result already collected: FutureResult
[10:26:08.263] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:08.263] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:08.263] Searching for globals...
[10:26:08.265] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:08.266] Searching for globals ... DONE
[10:26:08.266] Resolving globals: TRUE
[10:26:08.266] Resolving any globals that are futures ...
[10:26:08.266] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:08.266] Resolving any globals that are futures ... DONE
[10:26:08.266] Resolving futures part of globals (recursively) ...
[10:26:08.267] resolve() on list ...
[10:26:08.267]  recursive: 99
[10:26:08.267]  length: 1
[10:26:08.267]  elements: ‘x’
[10:26:08.267]  length: 0 (resolved future 1)
[10:26:08.267] resolve() on list ... DONE
[10:26:08.267] - globals: [1] ‘x’
[10:26:08.267] Resolving futures part of globals (recursively) ... DONE
[10:26:08.267] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:08.268] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:08.268] - globals: [1] ‘x’
[10:26:08.268] 
[10:26:08.268] getGlobalsAndPackages() ... DONE
[10:26:08.268] run() for ‘Future’ ...
[10:26:08.268] - state: ‘created’
[10:26:08.269] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:08.282] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:08.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:08.282]   - Field: ‘node’
[10:26:08.282]   - Field: ‘label’
[10:26:08.283]   - Field: ‘local’
[10:26:08.283]   - Field: ‘owner’
[10:26:08.283]   - Field: ‘envir’
[10:26:08.283]   - Field: ‘workers’
[10:26:08.283]   - Field: ‘packages’
[10:26:08.283]   - Field: ‘gc’
[10:26:08.283]   - Field: ‘conditions’
[10:26:08.283]   - Field: ‘persistent’
[10:26:08.283]   - Field: ‘expr’
[10:26:08.283]   - Field: ‘uuid’
[10:26:08.283]   - Field: ‘seed’
[10:26:08.284]   - Field: ‘version’
[10:26:08.284]   - Field: ‘result’
[10:26:08.284]   - Field: ‘asynchronous’
[10:26:08.284]   - Field: ‘calls’
[10:26:08.284]   - Field: ‘globals’
[10:26:08.284]   - Field: ‘stdout’
[10:26:08.284]   - Field: ‘earlySignal’
[10:26:08.284]   - Field: ‘lazy’
[10:26:08.284]   - Field: ‘state’
[10:26:08.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:08.284] - Launch lazy future ...
[10:26:08.285] Packages needed by the future expression (n = 0): <none>
[10:26:08.285] Packages needed by future strategies (n = 0): <none>
[10:26:08.285] {
[10:26:08.285]     {
[10:26:08.285]         {
[10:26:08.285]             ...future.startTime <- base::Sys.time()
[10:26:08.285]             {
[10:26:08.285]                 {
[10:26:08.285]                   {
[10:26:08.285]                     {
[10:26:08.285]                       base::local({
[10:26:08.285]                         has_future <- base::requireNamespace("future", 
[10:26:08.285]                           quietly = TRUE)
[10:26:08.285]                         if (has_future) {
[10:26:08.285]                           ns <- base::getNamespace("future")
[10:26:08.285]                           version <- ns[[".package"]][["version"]]
[10:26:08.285]                           if (is.null(version)) 
[10:26:08.285]                             version <- utils::packageVersion("future")
[10:26:08.285]                         }
[10:26:08.285]                         else {
[10:26:08.285]                           version <- NULL
[10:26:08.285]                         }
[10:26:08.285]                         if (!has_future || version < "1.8.0") {
[10:26:08.285]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:08.285]                             "", base::R.version$version.string), 
[10:26:08.285]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:08.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:08.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:08.285]                               "release", "version")], collapse = " "), 
[10:26:08.285]                             hostname = base::Sys.info()[["nodename"]])
[10:26:08.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:08.285]                             info)
[10:26:08.285]                           info <- base::paste(info, collapse = "; ")
[10:26:08.285]                           if (!has_future) {
[10:26:08.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:08.285]                               info)
[10:26:08.285]                           }
[10:26:08.285]                           else {
[10:26:08.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:08.285]                               info, version)
[10:26:08.285]                           }
[10:26:08.285]                           base::stop(msg)
[10:26:08.285]                         }
[10:26:08.285]                       })
[10:26:08.285]                     }
[10:26:08.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:08.285]                     base::options(mc.cores = 1L)
[10:26:08.285]                   }
[10:26:08.285]                   options(future.plan = NULL)
[10:26:08.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:08.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:08.285]                 }
[10:26:08.285]                 ...future.workdir <- getwd()
[10:26:08.285]             }
[10:26:08.285]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:08.285]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:08.285]         }
[10:26:08.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:08.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:08.285]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:08.285]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:08.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:08.285]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:08.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:08.285]             base::names(...future.oldOptions))
[10:26:08.285]     }
[10:26:08.285]     if (FALSE) {
[10:26:08.285]     }
[10:26:08.285]     else {
[10:26:08.285]         if (TRUE) {
[10:26:08.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:08.285]                 open = "w")
[10:26:08.285]         }
[10:26:08.285]         else {
[10:26:08.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:08.285]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:08.285]         }
[10:26:08.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:08.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:08.285]             base::sink(type = "output", split = FALSE)
[10:26:08.285]             base::close(...future.stdout)
[10:26:08.285]         }, add = TRUE)
[10:26:08.285]     }
[10:26:08.285]     ...future.frame <- base::sys.nframe()
[10:26:08.285]     ...future.conditions <- base::list()
[10:26:08.285]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:08.285]     if (FALSE) {
[10:26:08.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:08.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:08.285]     }
[10:26:08.285]     ...future.result <- base::tryCatch({
[10:26:08.285]         base::withCallingHandlers({
[10:26:08.285]             ...future.value <- base::withVisible(base::local({
[10:26:08.285]                 ...future.makeSendCondition <- base::local({
[10:26:08.285]                   sendCondition <- NULL
[10:26:08.285]                   function(frame = 1L) {
[10:26:08.285]                     if (is.function(sendCondition)) 
[10:26:08.285]                       return(sendCondition)
[10:26:08.285]                     ns <- getNamespace("parallel")
[10:26:08.285]                     if (exists("sendData", mode = "function", 
[10:26:08.285]                       envir = ns)) {
[10:26:08.285]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:08.285]                         envir = ns)
[10:26:08.285]                       envir <- sys.frame(frame)
[10:26:08.285]                       master <- NULL
[10:26:08.285]                       while (!identical(envir, .GlobalEnv) && 
[10:26:08.285]                         !identical(envir, emptyenv())) {
[10:26:08.285]                         if (exists("master", mode = "list", envir = envir, 
[10:26:08.285]                           inherits = FALSE)) {
[10:26:08.285]                           master <- get("master", mode = "list", 
[10:26:08.285]                             envir = envir, inherits = FALSE)
[10:26:08.285]                           if (inherits(master, c("SOCKnode", 
[10:26:08.285]                             "SOCK0node"))) {
[10:26:08.285]                             sendCondition <<- function(cond) {
[10:26:08.285]                               data <- list(type = "VALUE", value = cond, 
[10:26:08.285]                                 success = TRUE)
[10:26:08.285]                               parallel_sendData(master, data)
[10:26:08.285]                             }
[10:26:08.285]                             return(sendCondition)
[10:26:08.285]                           }
[10:26:08.285]                         }
[10:26:08.285]                         frame <- frame + 1L
[10:26:08.285]                         envir <- sys.frame(frame)
[10:26:08.285]                       }
[10:26:08.285]                     }
[10:26:08.285]                     sendCondition <<- function(cond) NULL
[10:26:08.285]                   }
[10:26:08.285]                 })
[10:26:08.285]                 withCallingHandlers({
[10:26:08.285]                   {
[10:26:08.285]                     x["a"] <- list(1)
[10:26:08.285]                     x
[10:26:08.285]                   }
[10:26:08.285]                 }, immediateCondition = function(cond) {
[10:26:08.285]                   sendCondition <- ...future.makeSendCondition()
[10:26:08.285]                   sendCondition(cond)
[10:26:08.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.285]                   {
[10:26:08.285]                     inherits <- base::inherits
[10:26:08.285]                     invokeRestart <- base::invokeRestart
[10:26:08.285]                     is.null <- base::is.null
[10:26:08.285]                     muffled <- FALSE
[10:26:08.285]                     if (inherits(cond, "message")) {
[10:26:08.285]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:08.285]                       if (muffled) 
[10:26:08.285]                         invokeRestart("muffleMessage")
[10:26:08.285]                     }
[10:26:08.285]                     else if (inherits(cond, "warning")) {
[10:26:08.285]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:08.285]                       if (muffled) 
[10:26:08.285]                         invokeRestart("muffleWarning")
[10:26:08.285]                     }
[10:26:08.285]                     else if (inherits(cond, "condition")) {
[10:26:08.285]                       if (!is.null(pattern)) {
[10:26:08.285]                         computeRestarts <- base::computeRestarts
[10:26:08.285]                         grepl <- base::grepl
[10:26:08.285]                         restarts <- computeRestarts(cond)
[10:26:08.285]                         for (restart in restarts) {
[10:26:08.285]                           name <- restart$name
[10:26:08.285]                           if (is.null(name)) 
[10:26:08.285]                             next
[10:26:08.285]                           if (!grepl(pattern, name)) 
[10:26:08.285]                             next
[10:26:08.285]                           invokeRestart(restart)
[10:26:08.285]                           muffled <- TRUE
[10:26:08.285]                           break
[10:26:08.285]                         }
[10:26:08.285]                       }
[10:26:08.285]                     }
[10:26:08.285]                     invisible(muffled)
[10:26:08.285]                   }
[10:26:08.285]                   muffleCondition(cond)
[10:26:08.285]                 })
[10:26:08.285]             }))
[10:26:08.285]             future::FutureResult(value = ...future.value$value, 
[10:26:08.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:08.285]                   ...future.rng), globalenv = if (FALSE) 
[10:26:08.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:08.285]                     ...future.globalenv.names))
[10:26:08.285]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:08.285]         }, condition = base::local({
[10:26:08.285]             c <- base::c
[10:26:08.285]             inherits <- base::inherits
[10:26:08.285]             invokeRestart <- base::invokeRestart
[10:26:08.285]             length <- base::length
[10:26:08.285]             list <- base::list
[10:26:08.285]             seq.int <- base::seq.int
[10:26:08.285]             signalCondition <- base::signalCondition
[10:26:08.285]             sys.calls <- base::sys.calls
[10:26:08.285]             `[[` <- base::`[[`
[10:26:08.285]             `+` <- base::`+`
[10:26:08.285]             `<<-` <- base::`<<-`
[10:26:08.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:08.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:08.285]                   3L)]
[10:26:08.285]             }
[10:26:08.285]             function(cond) {
[10:26:08.285]                 is_error <- inherits(cond, "error")
[10:26:08.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:08.285]                   NULL)
[10:26:08.285]                 if (is_error) {
[10:26:08.285]                   sessionInformation <- function() {
[10:26:08.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:08.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:08.285]                       search = base::search(), system = base::Sys.info())
[10:26:08.285]                   }
[10:26:08.285]                   ...future.conditions[[length(...future.conditions) + 
[10:26:08.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:08.285]                     cond$call), session = sessionInformation(), 
[10:26:08.285]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:08.285]                   signalCondition(cond)
[10:26:08.285]                 }
[10:26:08.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:08.285]                 "immediateCondition"))) {
[10:26:08.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:08.285]                   ...future.conditions[[length(...future.conditions) + 
[10:26:08.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:08.285]                   if (TRUE && !signal) {
[10:26:08.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.285]                     {
[10:26:08.285]                       inherits <- base::inherits
[10:26:08.285]                       invokeRestart <- base::invokeRestart
[10:26:08.285]                       is.null <- base::is.null
[10:26:08.285]                       muffled <- FALSE
[10:26:08.285]                       if (inherits(cond, "message")) {
[10:26:08.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:08.285]                         if (muffled) 
[10:26:08.285]                           invokeRestart("muffleMessage")
[10:26:08.285]                       }
[10:26:08.285]                       else if (inherits(cond, "warning")) {
[10:26:08.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:08.285]                         if (muffled) 
[10:26:08.285]                           invokeRestart("muffleWarning")
[10:26:08.285]                       }
[10:26:08.285]                       else if (inherits(cond, "condition")) {
[10:26:08.285]                         if (!is.null(pattern)) {
[10:26:08.285]                           computeRestarts <- base::computeRestarts
[10:26:08.285]                           grepl <- base::grepl
[10:26:08.285]                           restarts <- computeRestarts(cond)
[10:26:08.285]                           for (restart in restarts) {
[10:26:08.285]                             name <- restart$name
[10:26:08.285]                             if (is.null(name)) 
[10:26:08.285]                               next
[10:26:08.285]                             if (!grepl(pattern, name)) 
[10:26:08.285]                               next
[10:26:08.285]                             invokeRestart(restart)
[10:26:08.285]                             muffled <- TRUE
[10:26:08.285]                             break
[10:26:08.285]                           }
[10:26:08.285]                         }
[10:26:08.285]                       }
[10:26:08.285]                       invisible(muffled)
[10:26:08.285]                     }
[10:26:08.285]                     muffleCondition(cond, pattern = "^muffle")
[10:26:08.285]                   }
[10:26:08.285]                 }
[10:26:08.285]                 else {
[10:26:08.285]                   if (TRUE) {
[10:26:08.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.285]                     {
[10:26:08.285]                       inherits <- base::inherits
[10:26:08.285]                       invokeRestart <- base::invokeRestart
[10:26:08.285]                       is.null <- base::is.null
[10:26:08.285]                       muffled <- FALSE
[10:26:08.285]                       if (inherits(cond, "message")) {
[10:26:08.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:08.285]                         if (muffled) 
[10:26:08.285]                           invokeRestart("muffleMessage")
[10:26:08.285]                       }
[10:26:08.285]                       else if (inherits(cond, "warning")) {
[10:26:08.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:08.285]                         if (muffled) 
[10:26:08.285]                           invokeRestart("muffleWarning")
[10:26:08.285]                       }
[10:26:08.285]                       else if (inherits(cond, "condition")) {
[10:26:08.285]                         if (!is.null(pattern)) {
[10:26:08.285]                           computeRestarts <- base::computeRestarts
[10:26:08.285]                           grepl <- base::grepl
[10:26:08.285]                           restarts <- computeRestarts(cond)
[10:26:08.285]                           for (restart in restarts) {
[10:26:08.285]                             name <- restart$name
[10:26:08.285]                             if (is.null(name)) 
[10:26:08.285]                               next
[10:26:08.285]                             if (!grepl(pattern, name)) 
[10:26:08.285]                               next
[10:26:08.285]                             invokeRestart(restart)
[10:26:08.285]                             muffled <- TRUE
[10:26:08.285]                             break
[10:26:08.285]                           }
[10:26:08.285]                         }
[10:26:08.285]                       }
[10:26:08.285]                       invisible(muffled)
[10:26:08.285]                     }
[10:26:08.285]                     muffleCondition(cond, pattern = "^muffle")
[10:26:08.285]                   }
[10:26:08.285]                 }
[10:26:08.285]             }
[10:26:08.285]         }))
[10:26:08.285]     }, error = function(ex) {
[10:26:08.285]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:08.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:08.285]                 ...future.rng), started = ...future.startTime, 
[10:26:08.285]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:08.285]             version = "1.8"), class = "FutureResult")
[10:26:08.285]     }, finally = {
[10:26:08.285]         if (!identical(...future.workdir, getwd())) 
[10:26:08.285]             setwd(...future.workdir)
[10:26:08.285]         {
[10:26:08.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:08.285]                 ...future.oldOptions$nwarnings <- NULL
[10:26:08.285]             }
[10:26:08.285]             base::options(...future.oldOptions)
[10:26:08.285]             if (.Platform$OS.type == "windows") {
[10:26:08.285]                 old_names <- names(...future.oldEnvVars)
[10:26:08.285]                 envs <- base::Sys.getenv()
[10:26:08.285]                 names <- names(envs)
[10:26:08.285]                 common <- intersect(names, old_names)
[10:26:08.285]                 added <- setdiff(names, old_names)
[10:26:08.285]                 removed <- setdiff(old_names, names)
[10:26:08.285]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:08.285]                   envs[common]]
[10:26:08.285]                 NAMES <- toupper(changed)
[10:26:08.285]                 args <- list()
[10:26:08.285]                 for (kk in seq_along(NAMES)) {
[10:26:08.285]                   name <- changed[[kk]]
[10:26:08.285]                   NAME <- NAMES[[kk]]
[10:26:08.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.285]                     next
[10:26:08.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:08.285]                 }
[10:26:08.285]                 NAMES <- toupper(added)
[10:26:08.285]                 for (kk in seq_along(NAMES)) {
[10:26:08.285]                   name <- added[[kk]]
[10:26:08.285]                   NAME <- NAMES[[kk]]
[10:26:08.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.285]                     next
[10:26:08.285]                   args[[name]] <- ""
[10:26:08.285]                 }
[10:26:08.285]                 NAMES <- toupper(removed)
[10:26:08.285]                 for (kk in seq_along(NAMES)) {
[10:26:08.285]                   name <- removed[[kk]]
[10:26:08.285]                   NAME <- NAMES[[kk]]
[10:26:08.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.285]                     next
[10:26:08.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:08.285]                 }
[10:26:08.285]                 if (length(args) > 0) 
[10:26:08.285]                   base::do.call(base::Sys.setenv, args = args)
[10:26:08.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:08.285]             }
[10:26:08.285]             else {
[10:26:08.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:08.285]             }
[10:26:08.285]             {
[10:26:08.285]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:08.285]                   0L) {
[10:26:08.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:08.285]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:08.285]                   base::options(opts)
[10:26:08.285]                 }
[10:26:08.285]                 {
[10:26:08.285]                   {
[10:26:08.285]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:08.285]                     NULL
[10:26:08.285]                   }
[10:26:08.285]                   options(future.plan = NULL)
[10:26:08.285]                   if (is.na(NA_character_)) 
[10:26:08.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:08.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:08.285]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:08.285]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:08.285]                     envir = parent.frame()) 
[10:26:08.285]                   {
[10:26:08.285]                     if (is.function(workers)) 
[10:26:08.285]                       workers <- workers()
[10:26:08.285]                     workers <- structure(as.integer(workers), 
[10:26:08.285]                       class = class(workers))
[10:26:08.285]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:08.285]                       workers >= 1)
[10:26:08.285]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:08.285]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:08.285]                     }
[10:26:08.285]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:08.285]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:08.285]                       envir = envir)
[10:26:08.285]                     if (!future$lazy) 
[10:26:08.285]                       future <- run(future)
[10:26:08.285]                     invisible(future)
[10:26:08.285]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:08.285]                 }
[10:26:08.285]             }
[10:26:08.285]         }
[10:26:08.285]     })
[10:26:08.285]     if (TRUE) {
[10:26:08.285]         base::sink(type = "output", split = FALSE)
[10:26:08.285]         if (TRUE) {
[10:26:08.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:08.285]         }
[10:26:08.285]         else {
[10:26:08.285]             ...future.result["stdout"] <- base::list(NULL)
[10:26:08.285]         }
[10:26:08.285]         base::close(...future.stdout)
[10:26:08.285]         ...future.stdout <- NULL
[10:26:08.285]     }
[10:26:08.285]     ...future.result$conditions <- ...future.conditions
[10:26:08.285]     ...future.result$finished <- base::Sys.time()
[10:26:08.285]     ...future.result
[10:26:08.285] }
[10:26:08.288] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:26:08.288] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:26:08.288] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:26:08.288] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:26:08.289] MultisessionFuture started
[10:26:08.289] - Launch lazy future ... done
[10:26:08.289] run() for ‘MultisessionFuture’ ... done
[10:26:08.289] result() for ClusterFuture ...
[10:26:08.289] receiveMessageFromWorker() for ClusterFuture ...
[10:26:08.289] - Validating connection of MultisessionFuture
[10:26:08.334] - received message: FutureResult
[10:26:08.334] - Received FutureResult
[10:26:08.334] - Erased future from FutureRegistry
[10:26:08.334] result() for ClusterFuture ...
[10:26:08.334] - result already collected: FutureResult
[10:26:08.335] result() for ClusterFuture ... done
[10:26:08.335] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:08.335] result() for ClusterFuture ... done
[10:26:08.335] result() for ClusterFuture ...
[10:26:08.335] - result already collected: FutureResult
[10:26:08.335] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:08.335] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:08.336] Searching for globals...
[10:26:08.338] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:08.338] Searching for globals ... DONE
[10:26:08.338] Resolving globals: TRUE
[10:26:08.338] Resolving any globals that are futures ...
[10:26:08.338] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:26:08.338] Resolving any globals that are futures ... DONE
[10:26:08.339] Resolving futures part of globals (recursively) ...
[10:26:08.339] resolve() on list ...
[10:26:08.339]  recursive: 99
[10:26:08.339]  length: 1
[10:26:08.339]  elements: ‘x’
[10:26:08.339]  length: 0 (resolved future 1)
[10:26:08.339] resolve() on list ... DONE
[10:26:08.339] - globals: [1] ‘x’
[10:26:08.339] Resolving futures part of globals (recursively) ... DONE
[10:26:08.340] The total size of the 1 globals is 0 bytes (0 bytes)
[10:26:08.340] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:26:08.340] - globals: [1] ‘x’
[10:26:08.340] 
[10:26:08.340] getGlobalsAndPackages() ... DONE
[10:26:08.340] run() for ‘Future’ ...
[10:26:08.341] - state: ‘created’
[10:26:08.341] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:08.354] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:08.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:08.354]   - Field: ‘node’
[10:26:08.355]   - Field: ‘label’
[10:26:08.355]   - Field: ‘local’
[10:26:08.355]   - Field: ‘owner’
[10:26:08.355]   - Field: ‘envir’
[10:26:08.355]   - Field: ‘workers’
[10:26:08.355]   - Field: ‘packages’
[10:26:08.355]   - Field: ‘gc’
[10:26:08.355]   - Field: ‘conditions’
[10:26:08.355]   - Field: ‘persistent’
[10:26:08.355]   - Field: ‘expr’
[10:26:08.355]   - Field: ‘uuid’
[10:26:08.356]   - Field: ‘seed’
[10:26:08.356]   - Field: ‘version’
[10:26:08.356]   - Field: ‘result’
[10:26:08.356]   - Field: ‘asynchronous’
[10:26:08.356]   - Field: ‘calls’
[10:26:08.356]   - Field: ‘globals’
[10:26:08.356]   - Field: ‘stdout’
[10:26:08.356]   - Field: ‘earlySignal’
[10:26:08.356]   - Field: ‘lazy’
[10:26:08.356]   - Field: ‘state’
[10:26:08.356] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:08.357] - Launch lazy future ...
[10:26:08.357] Packages needed by the future expression (n = 0): <none>
[10:26:08.357] Packages needed by future strategies (n = 0): <none>
[10:26:08.357] {
[10:26:08.357]     {
[10:26:08.357]         {
[10:26:08.357]             ...future.startTime <- base::Sys.time()
[10:26:08.357]             {
[10:26:08.357]                 {
[10:26:08.357]                   {
[10:26:08.357]                     {
[10:26:08.357]                       base::local({
[10:26:08.357]                         has_future <- base::requireNamespace("future", 
[10:26:08.357]                           quietly = TRUE)
[10:26:08.357]                         if (has_future) {
[10:26:08.357]                           ns <- base::getNamespace("future")
[10:26:08.357]                           version <- ns[[".package"]][["version"]]
[10:26:08.357]                           if (is.null(version)) 
[10:26:08.357]                             version <- utils::packageVersion("future")
[10:26:08.357]                         }
[10:26:08.357]                         else {
[10:26:08.357]                           version <- NULL
[10:26:08.357]                         }
[10:26:08.357]                         if (!has_future || version < "1.8.0") {
[10:26:08.357]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:08.357]                             "", base::R.version$version.string), 
[10:26:08.357]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:08.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:08.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:08.357]                               "release", "version")], collapse = " "), 
[10:26:08.357]                             hostname = base::Sys.info()[["nodename"]])
[10:26:08.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:08.357]                             info)
[10:26:08.357]                           info <- base::paste(info, collapse = "; ")
[10:26:08.357]                           if (!has_future) {
[10:26:08.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:08.357]                               info)
[10:26:08.357]                           }
[10:26:08.357]                           else {
[10:26:08.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:08.357]                               info, version)
[10:26:08.357]                           }
[10:26:08.357]                           base::stop(msg)
[10:26:08.357]                         }
[10:26:08.357]                       })
[10:26:08.357]                     }
[10:26:08.357]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:08.357]                     base::options(mc.cores = 1L)
[10:26:08.357]                   }
[10:26:08.357]                   options(future.plan = NULL)
[10:26:08.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:08.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:08.357]                 }
[10:26:08.357]                 ...future.workdir <- getwd()
[10:26:08.357]             }
[10:26:08.357]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:08.357]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:08.357]         }
[10:26:08.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:08.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:08.357]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:08.357]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:08.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:08.357]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:08.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:08.357]             base::names(...future.oldOptions))
[10:26:08.357]     }
[10:26:08.357]     if (FALSE) {
[10:26:08.357]     }
[10:26:08.357]     else {
[10:26:08.357]         if (TRUE) {
[10:26:08.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:08.357]                 open = "w")
[10:26:08.357]         }
[10:26:08.357]         else {
[10:26:08.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:08.357]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:08.357]         }
[10:26:08.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:08.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:08.357]             base::sink(type = "output", split = FALSE)
[10:26:08.357]             base::close(...future.stdout)
[10:26:08.357]         }, add = TRUE)
[10:26:08.357]     }
[10:26:08.357]     ...future.frame <- base::sys.nframe()
[10:26:08.357]     ...future.conditions <- base::list()
[10:26:08.357]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:08.357]     if (FALSE) {
[10:26:08.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:08.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:08.357]     }
[10:26:08.357]     ...future.result <- base::tryCatch({
[10:26:08.357]         base::withCallingHandlers({
[10:26:08.357]             ...future.value <- base::withVisible(base::local({
[10:26:08.357]                 ...future.makeSendCondition <- base::local({
[10:26:08.357]                   sendCondition <- NULL
[10:26:08.357]                   function(frame = 1L) {
[10:26:08.357]                     if (is.function(sendCondition)) 
[10:26:08.357]                       return(sendCondition)
[10:26:08.357]                     ns <- getNamespace("parallel")
[10:26:08.357]                     if (exists("sendData", mode = "function", 
[10:26:08.357]                       envir = ns)) {
[10:26:08.357]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:08.357]                         envir = ns)
[10:26:08.357]                       envir <- sys.frame(frame)
[10:26:08.357]                       master <- NULL
[10:26:08.357]                       while (!identical(envir, .GlobalEnv) && 
[10:26:08.357]                         !identical(envir, emptyenv())) {
[10:26:08.357]                         if (exists("master", mode = "list", envir = envir, 
[10:26:08.357]                           inherits = FALSE)) {
[10:26:08.357]                           master <- get("master", mode = "list", 
[10:26:08.357]                             envir = envir, inherits = FALSE)
[10:26:08.357]                           if (inherits(master, c("SOCKnode", 
[10:26:08.357]                             "SOCK0node"))) {
[10:26:08.357]                             sendCondition <<- function(cond) {
[10:26:08.357]                               data <- list(type = "VALUE", value = cond, 
[10:26:08.357]                                 success = TRUE)
[10:26:08.357]                               parallel_sendData(master, data)
[10:26:08.357]                             }
[10:26:08.357]                             return(sendCondition)
[10:26:08.357]                           }
[10:26:08.357]                         }
[10:26:08.357]                         frame <- frame + 1L
[10:26:08.357]                         envir <- sys.frame(frame)
[10:26:08.357]                       }
[10:26:08.357]                     }
[10:26:08.357]                     sendCondition <<- function(cond) NULL
[10:26:08.357]                   }
[10:26:08.357]                 })
[10:26:08.357]                 withCallingHandlers({
[10:26:08.357]                   {
[10:26:08.357]                     x["a"] <- list(1)
[10:26:08.357]                     x
[10:26:08.357]                   }
[10:26:08.357]                 }, immediateCondition = function(cond) {
[10:26:08.357]                   sendCondition <- ...future.makeSendCondition()
[10:26:08.357]                   sendCondition(cond)
[10:26:08.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.357]                   {
[10:26:08.357]                     inherits <- base::inherits
[10:26:08.357]                     invokeRestart <- base::invokeRestart
[10:26:08.357]                     is.null <- base::is.null
[10:26:08.357]                     muffled <- FALSE
[10:26:08.357]                     if (inherits(cond, "message")) {
[10:26:08.357]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:08.357]                       if (muffled) 
[10:26:08.357]                         invokeRestart("muffleMessage")
[10:26:08.357]                     }
[10:26:08.357]                     else if (inherits(cond, "warning")) {
[10:26:08.357]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:08.357]                       if (muffled) 
[10:26:08.357]                         invokeRestart("muffleWarning")
[10:26:08.357]                     }
[10:26:08.357]                     else if (inherits(cond, "condition")) {
[10:26:08.357]                       if (!is.null(pattern)) {
[10:26:08.357]                         computeRestarts <- base::computeRestarts
[10:26:08.357]                         grepl <- base::grepl
[10:26:08.357]                         restarts <- computeRestarts(cond)
[10:26:08.357]                         for (restart in restarts) {
[10:26:08.357]                           name <- restart$name
[10:26:08.357]                           if (is.null(name)) 
[10:26:08.357]                             next
[10:26:08.357]                           if (!grepl(pattern, name)) 
[10:26:08.357]                             next
[10:26:08.357]                           invokeRestart(restart)
[10:26:08.357]                           muffled <- TRUE
[10:26:08.357]                           break
[10:26:08.357]                         }
[10:26:08.357]                       }
[10:26:08.357]                     }
[10:26:08.357]                     invisible(muffled)
[10:26:08.357]                   }
[10:26:08.357]                   muffleCondition(cond)
[10:26:08.357]                 })
[10:26:08.357]             }))
[10:26:08.357]             future::FutureResult(value = ...future.value$value, 
[10:26:08.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:08.357]                   ...future.rng), globalenv = if (FALSE) 
[10:26:08.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:08.357]                     ...future.globalenv.names))
[10:26:08.357]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:08.357]         }, condition = base::local({
[10:26:08.357]             c <- base::c
[10:26:08.357]             inherits <- base::inherits
[10:26:08.357]             invokeRestart <- base::invokeRestart
[10:26:08.357]             length <- base::length
[10:26:08.357]             list <- base::list
[10:26:08.357]             seq.int <- base::seq.int
[10:26:08.357]             signalCondition <- base::signalCondition
[10:26:08.357]             sys.calls <- base::sys.calls
[10:26:08.357]             `[[` <- base::`[[`
[10:26:08.357]             `+` <- base::`+`
[10:26:08.357]             `<<-` <- base::`<<-`
[10:26:08.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:08.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:08.357]                   3L)]
[10:26:08.357]             }
[10:26:08.357]             function(cond) {
[10:26:08.357]                 is_error <- inherits(cond, "error")
[10:26:08.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:08.357]                   NULL)
[10:26:08.357]                 if (is_error) {
[10:26:08.357]                   sessionInformation <- function() {
[10:26:08.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:08.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:08.357]                       search = base::search(), system = base::Sys.info())
[10:26:08.357]                   }
[10:26:08.357]                   ...future.conditions[[length(...future.conditions) + 
[10:26:08.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:08.357]                     cond$call), session = sessionInformation(), 
[10:26:08.357]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:08.357]                   signalCondition(cond)
[10:26:08.357]                 }
[10:26:08.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:08.357]                 "immediateCondition"))) {
[10:26:08.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:08.357]                   ...future.conditions[[length(...future.conditions) + 
[10:26:08.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:08.357]                   if (TRUE && !signal) {
[10:26:08.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.357]                     {
[10:26:08.357]                       inherits <- base::inherits
[10:26:08.357]                       invokeRestart <- base::invokeRestart
[10:26:08.357]                       is.null <- base::is.null
[10:26:08.357]                       muffled <- FALSE
[10:26:08.357]                       if (inherits(cond, "message")) {
[10:26:08.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:08.357]                         if (muffled) 
[10:26:08.357]                           invokeRestart("muffleMessage")
[10:26:08.357]                       }
[10:26:08.357]                       else if (inherits(cond, "warning")) {
[10:26:08.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:08.357]                         if (muffled) 
[10:26:08.357]                           invokeRestart("muffleWarning")
[10:26:08.357]                       }
[10:26:08.357]                       else if (inherits(cond, "condition")) {
[10:26:08.357]                         if (!is.null(pattern)) {
[10:26:08.357]                           computeRestarts <- base::computeRestarts
[10:26:08.357]                           grepl <- base::grepl
[10:26:08.357]                           restarts <- computeRestarts(cond)
[10:26:08.357]                           for (restart in restarts) {
[10:26:08.357]                             name <- restart$name
[10:26:08.357]                             if (is.null(name)) 
[10:26:08.357]                               next
[10:26:08.357]                             if (!grepl(pattern, name)) 
[10:26:08.357]                               next
[10:26:08.357]                             invokeRestart(restart)
[10:26:08.357]                             muffled <- TRUE
[10:26:08.357]                             break
[10:26:08.357]                           }
[10:26:08.357]                         }
[10:26:08.357]                       }
[10:26:08.357]                       invisible(muffled)
[10:26:08.357]                     }
[10:26:08.357]                     muffleCondition(cond, pattern = "^muffle")
[10:26:08.357]                   }
[10:26:08.357]                 }
[10:26:08.357]                 else {
[10:26:08.357]                   if (TRUE) {
[10:26:08.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.357]                     {
[10:26:08.357]                       inherits <- base::inherits
[10:26:08.357]                       invokeRestart <- base::invokeRestart
[10:26:08.357]                       is.null <- base::is.null
[10:26:08.357]                       muffled <- FALSE
[10:26:08.357]                       if (inherits(cond, "message")) {
[10:26:08.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:08.357]                         if (muffled) 
[10:26:08.357]                           invokeRestart("muffleMessage")
[10:26:08.357]                       }
[10:26:08.357]                       else if (inherits(cond, "warning")) {
[10:26:08.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:08.357]                         if (muffled) 
[10:26:08.357]                           invokeRestart("muffleWarning")
[10:26:08.357]                       }
[10:26:08.357]                       else if (inherits(cond, "condition")) {
[10:26:08.357]                         if (!is.null(pattern)) {
[10:26:08.357]                           computeRestarts <- base::computeRestarts
[10:26:08.357]                           grepl <- base::grepl
[10:26:08.357]                           restarts <- computeRestarts(cond)
[10:26:08.357]                           for (restart in restarts) {
[10:26:08.357]                             name <- restart$name
[10:26:08.357]                             if (is.null(name)) 
[10:26:08.357]                               next
[10:26:08.357]                             if (!grepl(pattern, name)) 
[10:26:08.357]                               next
[10:26:08.357]                             invokeRestart(restart)
[10:26:08.357]                             muffled <- TRUE
[10:26:08.357]                             break
[10:26:08.357]                           }
[10:26:08.357]                         }
[10:26:08.357]                       }
[10:26:08.357]                       invisible(muffled)
[10:26:08.357]                     }
[10:26:08.357]                     muffleCondition(cond, pattern = "^muffle")
[10:26:08.357]                   }
[10:26:08.357]                 }
[10:26:08.357]             }
[10:26:08.357]         }))
[10:26:08.357]     }, error = function(ex) {
[10:26:08.357]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:08.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:08.357]                 ...future.rng), started = ...future.startTime, 
[10:26:08.357]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:08.357]             version = "1.8"), class = "FutureResult")
[10:26:08.357]     }, finally = {
[10:26:08.357]         if (!identical(...future.workdir, getwd())) 
[10:26:08.357]             setwd(...future.workdir)
[10:26:08.357]         {
[10:26:08.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:08.357]                 ...future.oldOptions$nwarnings <- NULL
[10:26:08.357]             }
[10:26:08.357]             base::options(...future.oldOptions)
[10:26:08.357]             if (.Platform$OS.type == "windows") {
[10:26:08.357]                 old_names <- names(...future.oldEnvVars)
[10:26:08.357]                 envs <- base::Sys.getenv()
[10:26:08.357]                 names <- names(envs)
[10:26:08.357]                 common <- intersect(names, old_names)
[10:26:08.357]                 added <- setdiff(names, old_names)
[10:26:08.357]                 removed <- setdiff(old_names, names)
[10:26:08.357]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:08.357]                   envs[common]]
[10:26:08.357]                 NAMES <- toupper(changed)
[10:26:08.357]                 args <- list()
[10:26:08.357]                 for (kk in seq_along(NAMES)) {
[10:26:08.357]                   name <- changed[[kk]]
[10:26:08.357]                   NAME <- NAMES[[kk]]
[10:26:08.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.357]                     next
[10:26:08.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:08.357]                 }
[10:26:08.357]                 NAMES <- toupper(added)
[10:26:08.357]                 for (kk in seq_along(NAMES)) {
[10:26:08.357]                   name <- added[[kk]]
[10:26:08.357]                   NAME <- NAMES[[kk]]
[10:26:08.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.357]                     next
[10:26:08.357]                   args[[name]] <- ""
[10:26:08.357]                 }
[10:26:08.357]                 NAMES <- toupper(removed)
[10:26:08.357]                 for (kk in seq_along(NAMES)) {
[10:26:08.357]                   name <- removed[[kk]]
[10:26:08.357]                   NAME <- NAMES[[kk]]
[10:26:08.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.357]                     next
[10:26:08.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:08.357]                 }
[10:26:08.357]                 if (length(args) > 0) 
[10:26:08.357]                   base::do.call(base::Sys.setenv, args = args)
[10:26:08.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:08.357]             }
[10:26:08.357]             else {
[10:26:08.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:08.357]             }
[10:26:08.357]             {
[10:26:08.357]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:08.357]                   0L) {
[10:26:08.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:08.357]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:08.357]                   base::options(opts)
[10:26:08.357]                 }
[10:26:08.357]                 {
[10:26:08.357]                   {
[10:26:08.357]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:08.357]                     NULL
[10:26:08.357]                   }
[10:26:08.357]                   options(future.plan = NULL)
[10:26:08.357]                   if (is.na(NA_character_)) 
[10:26:08.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:08.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:08.357]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:08.357]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:08.357]                     envir = parent.frame()) 
[10:26:08.357]                   {
[10:26:08.357]                     if (is.function(workers)) 
[10:26:08.357]                       workers <- workers()
[10:26:08.357]                     workers <- structure(as.integer(workers), 
[10:26:08.357]                       class = class(workers))
[10:26:08.357]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:08.357]                       workers >= 1)
[10:26:08.357]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:08.357]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:08.357]                     }
[10:26:08.357]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:08.357]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:08.357]                       envir = envir)
[10:26:08.357]                     if (!future$lazy) 
[10:26:08.357]                       future <- run(future)
[10:26:08.357]                     invisible(future)
[10:26:08.357]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:08.357]                 }
[10:26:08.357]             }
[10:26:08.357]         }
[10:26:08.357]     })
[10:26:08.357]     if (TRUE) {
[10:26:08.357]         base::sink(type = "output", split = FALSE)
[10:26:08.357]         if (TRUE) {
[10:26:08.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:08.357]         }
[10:26:08.357]         else {
[10:26:08.357]             ...future.result["stdout"] <- base::list(NULL)
[10:26:08.357]         }
[10:26:08.357]         base::close(...future.stdout)
[10:26:08.357]         ...future.stdout <- NULL
[10:26:08.357]     }
[10:26:08.357]     ...future.result$conditions <- ...future.conditions
[10:26:08.357]     ...future.result$finished <- base::Sys.time()
[10:26:08.357]     ...future.result
[10:26:08.357] }
[10:26:08.360] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:26:08.360] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:26:08.360] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:26:08.361] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:26:08.361] MultisessionFuture started
[10:26:08.361] - Launch lazy future ... done
[10:26:08.361] run() for ‘MultisessionFuture’ ... done
[10:26:08.361] result() for ClusterFuture ...
[10:26:08.362] receiveMessageFromWorker() for ClusterFuture ...
[10:26:08.362] - Validating connection of MultisessionFuture
[10:26:08.406] - received message: FutureResult
[10:26:08.406] - Received FutureResult
[10:26:08.406] - Erased future from FutureRegistry
[10:26:08.406] result() for ClusterFuture ...
[10:26:08.407] - result already collected: FutureResult
[10:26:08.407] result() for ClusterFuture ... done
[10:26:08.407] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:08.407] result() for ClusterFuture ... done
[10:26:08.407] result() for ClusterFuture ...
[10:26:08.407] - result already collected: FutureResult
[10:26:08.407] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:08.408] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:08.408] Searching for globals...
[10:26:08.410] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:26:08.410] Searching for globals ... DONE
[10:26:08.410] Resolving globals: TRUE
[10:26:08.410] Resolving any globals that are futures ...
[10:26:08.410] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:26:08.410] Resolving any globals that are futures ... DONE
[10:26:08.411] Resolving futures part of globals (recursively) ...
[10:26:08.411] resolve() on list ...
[10:26:08.411]  recursive: 99
[10:26:08.411]  length: 2
[10:26:08.411]  elements: ‘x’, ‘name’
[10:26:08.411]  length: 1 (resolved future 1)
[10:26:08.412]  length: 0 (resolved future 2)
[10:26:08.412] resolve() on list ... DONE
[10:26:08.412] - globals: [2] ‘x’, ‘name’
[10:26:08.412] Resolving futures part of globals (recursively) ... DONE
[10:26:08.412] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:08.412] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[10:26:08.413] - globals: [2] ‘x’, ‘name’
[10:26:08.413] 
[10:26:08.413] getGlobalsAndPackages() ... DONE
[10:26:08.413] run() for ‘Future’ ...
[10:26:08.413] - state: ‘created’
[10:26:08.413] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:08.427] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:08.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:08.427]   - Field: ‘node’
[10:26:08.427]   - Field: ‘label’
[10:26:08.427]   - Field: ‘local’
[10:26:08.427]   - Field: ‘owner’
[10:26:08.428]   - Field: ‘envir’
[10:26:08.428]   - Field: ‘workers’
[10:26:08.428]   - Field: ‘packages’
[10:26:08.428]   - Field: ‘gc’
[10:26:08.428]   - Field: ‘conditions’
[10:26:08.428]   - Field: ‘persistent’
[10:26:08.428]   - Field: ‘expr’
[10:26:08.428]   - Field: ‘uuid’
[10:26:08.428]   - Field: ‘seed’
[10:26:08.428]   - Field: ‘version’
[10:26:08.428]   - Field: ‘result’
[10:26:08.429]   - Field: ‘asynchronous’
[10:26:08.429]   - Field: ‘calls’
[10:26:08.429]   - Field: ‘globals’
[10:26:08.429]   - Field: ‘stdout’
[10:26:08.429]   - Field: ‘earlySignal’
[10:26:08.429]   - Field: ‘lazy’
[10:26:08.429]   - Field: ‘state’
[10:26:08.429] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:08.429] - Launch lazy future ...
[10:26:08.430] Packages needed by the future expression (n = 0): <none>
[10:26:08.430] Packages needed by future strategies (n = 0): <none>
[10:26:08.430] {
[10:26:08.430]     {
[10:26:08.430]         {
[10:26:08.430]             ...future.startTime <- base::Sys.time()
[10:26:08.430]             {
[10:26:08.430]                 {
[10:26:08.430]                   {
[10:26:08.430]                     {
[10:26:08.430]                       base::local({
[10:26:08.430]                         has_future <- base::requireNamespace("future", 
[10:26:08.430]                           quietly = TRUE)
[10:26:08.430]                         if (has_future) {
[10:26:08.430]                           ns <- base::getNamespace("future")
[10:26:08.430]                           version <- ns[[".package"]][["version"]]
[10:26:08.430]                           if (is.null(version)) 
[10:26:08.430]                             version <- utils::packageVersion("future")
[10:26:08.430]                         }
[10:26:08.430]                         else {
[10:26:08.430]                           version <- NULL
[10:26:08.430]                         }
[10:26:08.430]                         if (!has_future || version < "1.8.0") {
[10:26:08.430]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:08.430]                             "", base::R.version$version.string), 
[10:26:08.430]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:08.430]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:08.430]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:08.430]                               "release", "version")], collapse = " "), 
[10:26:08.430]                             hostname = base::Sys.info()[["nodename"]])
[10:26:08.430]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:08.430]                             info)
[10:26:08.430]                           info <- base::paste(info, collapse = "; ")
[10:26:08.430]                           if (!has_future) {
[10:26:08.430]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:08.430]                               info)
[10:26:08.430]                           }
[10:26:08.430]                           else {
[10:26:08.430]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:08.430]                               info, version)
[10:26:08.430]                           }
[10:26:08.430]                           base::stop(msg)
[10:26:08.430]                         }
[10:26:08.430]                       })
[10:26:08.430]                     }
[10:26:08.430]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:08.430]                     base::options(mc.cores = 1L)
[10:26:08.430]                   }
[10:26:08.430]                   options(future.plan = NULL)
[10:26:08.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:08.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:08.430]                 }
[10:26:08.430]                 ...future.workdir <- getwd()
[10:26:08.430]             }
[10:26:08.430]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:08.430]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:08.430]         }
[10:26:08.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:08.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:08.430]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:08.430]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:08.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:08.430]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:08.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:08.430]             base::names(...future.oldOptions))
[10:26:08.430]     }
[10:26:08.430]     if (FALSE) {
[10:26:08.430]     }
[10:26:08.430]     else {
[10:26:08.430]         if (TRUE) {
[10:26:08.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:08.430]                 open = "w")
[10:26:08.430]         }
[10:26:08.430]         else {
[10:26:08.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:08.430]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:08.430]         }
[10:26:08.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:08.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:08.430]             base::sink(type = "output", split = FALSE)
[10:26:08.430]             base::close(...future.stdout)
[10:26:08.430]         }, add = TRUE)
[10:26:08.430]     }
[10:26:08.430]     ...future.frame <- base::sys.nframe()
[10:26:08.430]     ...future.conditions <- base::list()
[10:26:08.430]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:08.430]     if (FALSE) {
[10:26:08.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:08.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:08.430]     }
[10:26:08.430]     ...future.result <- base::tryCatch({
[10:26:08.430]         base::withCallingHandlers({
[10:26:08.430]             ...future.value <- base::withVisible(base::local({
[10:26:08.430]                 ...future.makeSendCondition <- base::local({
[10:26:08.430]                   sendCondition <- NULL
[10:26:08.430]                   function(frame = 1L) {
[10:26:08.430]                     if (is.function(sendCondition)) 
[10:26:08.430]                       return(sendCondition)
[10:26:08.430]                     ns <- getNamespace("parallel")
[10:26:08.430]                     if (exists("sendData", mode = "function", 
[10:26:08.430]                       envir = ns)) {
[10:26:08.430]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:08.430]                         envir = ns)
[10:26:08.430]                       envir <- sys.frame(frame)
[10:26:08.430]                       master <- NULL
[10:26:08.430]                       while (!identical(envir, .GlobalEnv) && 
[10:26:08.430]                         !identical(envir, emptyenv())) {
[10:26:08.430]                         if (exists("master", mode = "list", envir = envir, 
[10:26:08.430]                           inherits = FALSE)) {
[10:26:08.430]                           master <- get("master", mode = "list", 
[10:26:08.430]                             envir = envir, inherits = FALSE)
[10:26:08.430]                           if (inherits(master, c("SOCKnode", 
[10:26:08.430]                             "SOCK0node"))) {
[10:26:08.430]                             sendCondition <<- function(cond) {
[10:26:08.430]                               data <- list(type = "VALUE", value = cond, 
[10:26:08.430]                                 success = TRUE)
[10:26:08.430]                               parallel_sendData(master, data)
[10:26:08.430]                             }
[10:26:08.430]                             return(sendCondition)
[10:26:08.430]                           }
[10:26:08.430]                         }
[10:26:08.430]                         frame <- frame + 1L
[10:26:08.430]                         envir <- sys.frame(frame)
[10:26:08.430]                       }
[10:26:08.430]                     }
[10:26:08.430]                     sendCondition <<- function(cond) NULL
[10:26:08.430]                   }
[10:26:08.430]                 })
[10:26:08.430]                 withCallingHandlers({
[10:26:08.430]                   {
[10:26:08.430]                     x[name] <- list(1)
[10:26:08.430]                     x
[10:26:08.430]                   }
[10:26:08.430]                 }, immediateCondition = function(cond) {
[10:26:08.430]                   sendCondition <- ...future.makeSendCondition()
[10:26:08.430]                   sendCondition(cond)
[10:26:08.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.430]                   {
[10:26:08.430]                     inherits <- base::inherits
[10:26:08.430]                     invokeRestart <- base::invokeRestart
[10:26:08.430]                     is.null <- base::is.null
[10:26:08.430]                     muffled <- FALSE
[10:26:08.430]                     if (inherits(cond, "message")) {
[10:26:08.430]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:08.430]                       if (muffled) 
[10:26:08.430]                         invokeRestart("muffleMessage")
[10:26:08.430]                     }
[10:26:08.430]                     else if (inherits(cond, "warning")) {
[10:26:08.430]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:08.430]                       if (muffled) 
[10:26:08.430]                         invokeRestart("muffleWarning")
[10:26:08.430]                     }
[10:26:08.430]                     else if (inherits(cond, "condition")) {
[10:26:08.430]                       if (!is.null(pattern)) {
[10:26:08.430]                         computeRestarts <- base::computeRestarts
[10:26:08.430]                         grepl <- base::grepl
[10:26:08.430]                         restarts <- computeRestarts(cond)
[10:26:08.430]                         for (restart in restarts) {
[10:26:08.430]                           name <- restart$name
[10:26:08.430]                           if (is.null(name)) 
[10:26:08.430]                             next
[10:26:08.430]                           if (!grepl(pattern, name)) 
[10:26:08.430]                             next
[10:26:08.430]                           invokeRestart(restart)
[10:26:08.430]                           muffled <- TRUE
[10:26:08.430]                           break
[10:26:08.430]                         }
[10:26:08.430]                       }
[10:26:08.430]                     }
[10:26:08.430]                     invisible(muffled)
[10:26:08.430]                   }
[10:26:08.430]                   muffleCondition(cond)
[10:26:08.430]                 })
[10:26:08.430]             }))
[10:26:08.430]             future::FutureResult(value = ...future.value$value, 
[10:26:08.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:08.430]                   ...future.rng), globalenv = if (FALSE) 
[10:26:08.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:08.430]                     ...future.globalenv.names))
[10:26:08.430]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:08.430]         }, condition = base::local({
[10:26:08.430]             c <- base::c
[10:26:08.430]             inherits <- base::inherits
[10:26:08.430]             invokeRestart <- base::invokeRestart
[10:26:08.430]             length <- base::length
[10:26:08.430]             list <- base::list
[10:26:08.430]             seq.int <- base::seq.int
[10:26:08.430]             signalCondition <- base::signalCondition
[10:26:08.430]             sys.calls <- base::sys.calls
[10:26:08.430]             `[[` <- base::`[[`
[10:26:08.430]             `+` <- base::`+`
[10:26:08.430]             `<<-` <- base::`<<-`
[10:26:08.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:08.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:08.430]                   3L)]
[10:26:08.430]             }
[10:26:08.430]             function(cond) {
[10:26:08.430]                 is_error <- inherits(cond, "error")
[10:26:08.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:08.430]                   NULL)
[10:26:08.430]                 if (is_error) {
[10:26:08.430]                   sessionInformation <- function() {
[10:26:08.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:08.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:08.430]                       search = base::search(), system = base::Sys.info())
[10:26:08.430]                   }
[10:26:08.430]                   ...future.conditions[[length(...future.conditions) + 
[10:26:08.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:08.430]                     cond$call), session = sessionInformation(), 
[10:26:08.430]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:08.430]                   signalCondition(cond)
[10:26:08.430]                 }
[10:26:08.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:08.430]                 "immediateCondition"))) {
[10:26:08.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:08.430]                   ...future.conditions[[length(...future.conditions) + 
[10:26:08.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:08.430]                   if (TRUE && !signal) {
[10:26:08.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.430]                     {
[10:26:08.430]                       inherits <- base::inherits
[10:26:08.430]                       invokeRestart <- base::invokeRestart
[10:26:08.430]                       is.null <- base::is.null
[10:26:08.430]                       muffled <- FALSE
[10:26:08.430]                       if (inherits(cond, "message")) {
[10:26:08.430]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:08.430]                         if (muffled) 
[10:26:08.430]                           invokeRestart("muffleMessage")
[10:26:08.430]                       }
[10:26:08.430]                       else if (inherits(cond, "warning")) {
[10:26:08.430]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:08.430]                         if (muffled) 
[10:26:08.430]                           invokeRestart("muffleWarning")
[10:26:08.430]                       }
[10:26:08.430]                       else if (inherits(cond, "condition")) {
[10:26:08.430]                         if (!is.null(pattern)) {
[10:26:08.430]                           computeRestarts <- base::computeRestarts
[10:26:08.430]                           grepl <- base::grepl
[10:26:08.430]                           restarts <- computeRestarts(cond)
[10:26:08.430]                           for (restart in restarts) {
[10:26:08.430]                             name <- restart$name
[10:26:08.430]                             if (is.null(name)) 
[10:26:08.430]                               next
[10:26:08.430]                             if (!grepl(pattern, name)) 
[10:26:08.430]                               next
[10:26:08.430]                             invokeRestart(restart)
[10:26:08.430]                             muffled <- TRUE
[10:26:08.430]                             break
[10:26:08.430]                           }
[10:26:08.430]                         }
[10:26:08.430]                       }
[10:26:08.430]                       invisible(muffled)
[10:26:08.430]                     }
[10:26:08.430]                     muffleCondition(cond, pattern = "^muffle")
[10:26:08.430]                   }
[10:26:08.430]                 }
[10:26:08.430]                 else {
[10:26:08.430]                   if (TRUE) {
[10:26:08.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:08.430]                     {
[10:26:08.430]                       inherits <- base::inherits
[10:26:08.430]                       invokeRestart <- base::invokeRestart
[10:26:08.430]                       is.null <- base::is.null
[10:26:08.430]                       muffled <- FALSE
[10:26:08.430]                       if (inherits(cond, "message")) {
[10:26:08.430]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:08.430]                         if (muffled) 
[10:26:08.430]                           invokeRestart("muffleMessage")
[10:26:08.430]                       }
[10:26:08.430]                       else if (inherits(cond, "warning")) {
[10:26:08.430]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:08.430]                         if (muffled) 
[10:26:08.430]                           invokeRestart("muffleWarning")
[10:26:08.430]                       }
[10:26:08.430]                       else if (inherits(cond, "condition")) {
[10:26:08.430]                         if (!is.null(pattern)) {
[10:26:08.430]                           computeRestarts <- base::computeRestarts
[10:26:08.430]                           grepl <- base::grepl
[10:26:08.430]                           restarts <- computeRestarts(cond)
[10:26:08.430]                           for (restart in restarts) {
[10:26:08.430]                             name <- restart$name
[10:26:08.430]                             if (is.null(name)) 
[10:26:08.430]                               next
[10:26:08.430]                             if (!grepl(pattern, name)) 
[10:26:08.430]                               next
[10:26:08.430]                             invokeRestart(restart)
[10:26:08.430]                             muffled <- TRUE
[10:26:08.430]                             break
[10:26:08.430]                           }
[10:26:08.430]                         }
[10:26:08.430]                       }
[10:26:08.430]                       invisible(muffled)
[10:26:08.430]                     }
[10:26:08.430]                     muffleCondition(cond, pattern = "^muffle")
[10:26:08.430]                   }
[10:26:08.430]                 }
[10:26:08.430]             }
[10:26:08.430]         }))
[10:26:08.430]     }, error = function(ex) {
[10:26:08.430]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:08.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:08.430]                 ...future.rng), started = ...future.startTime, 
[10:26:08.430]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:08.430]             version = "1.8"), class = "FutureResult")
[10:26:08.430]     }, finally = {
[10:26:08.430]         if (!identical(...future.workdir, getwd())) 
[10:26:08.430]             setwd(...future.workdir)
[10:26:08.430]         {
[10:26:08.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:08.430]                 ...future.oldOptions$nwarnings <- NULL
[10:26:08.430]             }
[10:26:08.430]             base::options(...future.oldOptions)
[10:26:08.430]             if (.Platform$OS.type == "windows") {
[10:26:08.430]                 old_names <- names(...future.oldEnvVars)
[10:26:08.430]                 envs <- base::Sys.getenv()
[10:26:08.430]                 names <- names(envs)
[10:26:08.430]                 common <- intersect(names, old_names)
[10:26:08.430]                 added <- setdiff(names, old_names)
[10:26:08.430]                 removed <- setdiff(old_names, names)
[10:26:08.430]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:08.430]                   envs[common]]
[10:26:08.430]                 NAMES <- toupper(changed)
[10:26:08.430]                 args <- list()
[10:26:08.430]                 for (kk in seq_along(NAMES)) {
[10:26:08.430]                   name <- changed[[kk]]
[10:26:08.430]                   NAME <- NAMES[[kk]]
[10:26:08.430]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.430]                     next
[10:26:08.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:08.430]                 }
[10:26:08.430]                 NAMES <- toupper(added)
[10:26:08.430]                 for (kk in seq_along(NAMES)) {
[10:26:08.430]                   name <- added[[kk]]
[10:26:08.430]                   NAME <- NAMES[[kk]]
[10:26:08.430]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.430]                     next
[10:26:08.430]                   args[[name]] <- ""
[10:26:08.430]                 }
[10:26:08.430]                 NAMES <- toupper(removed)
[10:26:08.430]                 for (kk in seq_along(NAMES)) {
[10:26:08.430]                   name <- removed[[kk]]
[10:26:08.430]                   NAME <- NAMES[[kk]]
[10:26:08.430]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:08.430]                     next
[10:26:08.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:08.430]                 }
[10:26:08.430]                 if (length(args) > 0) 
[10:26:08.430]                   base::do.call(base::Sys.setenv, args = args)
[10:26:08.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:08.430]             }
[10:26:08.430]             else {
[10:26:08.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:08.430]             }
[10:26:08.430]             {
[10:26:08.430]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:08.430]                   0L) {
[10:26:08.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:08.430]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:08.430]                   base::options(opts)
[10:26:08.430]                 }
[10:26:08.430]                 {
[10:26:08.430]                   {
[10:26:08.430]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:08.430]                     NULL
[10:26:08.430]                   }
[10:26:08.430]                   options(future.plan = NULL)
[10:26:08.430]                   if (is.na(NA_character_)) 
[10:26:08.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:08.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:08.430]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:08.430]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:08.430]                     envir = parent.frame()) 
[10:26:08.430]                   {
[10:26:08.430]                     if (is.function(workers)) 
[10:26:08.430]                       workers <- workers()
[10:26:08.430]                     workers <- structure(as.integer(workers), 
[10:26:08.430]                       class = class(workers))
[10:26:08.430]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:08.430]                       workers >= 1)
[10:26:08.430]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:08.430]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:08.430]                     }
[10:26:08.430]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:08.430]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:08.430]                       envir = envir)
[10:26:08.430]                     if (!future$lazy) 
[10:26:08.430]                       future <- run(future)
[10:26:08.430]                     invisible(future)
[10:26:08.430]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:08.430]                 }
[10:26:08.430]             }
[10:26:08.430]         }
[10:26:08.430]     })
[10:26:08.430]     if (TRUE) {
[10:26:08.430]         base::sink(type = "output", split = FALSE)
[10:26:08.430]         if (TRUE) {
[10:26:08.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:08.430]         }
[10:26:08.430]         else {
[10:26:08.430]             ...future.result["stdout"] <- base::list(NULL)
[10:26:08.430]         }
[10:26:08.430]         base::close(...future.stdout)
[10:26:08.430]         ...future.stdout <- NULL
[10:26:08.430]     }
[10:26:08.430]     ...future.result$conditions <- ...future.conditions
[10:26:08.430]     ...future.result$finished <- base::Sys.time()
[10:26:08.430]     ...future.result
[10:26:08.430] }
[10:26:08.433] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:26:08.433] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:26:08.436] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:26:08.436] Exporting ‘name’ (112 bytes) to cluster node #1 ...
[10:26:08.436] Exporting ‘name’ (112 bytes) to cluster node #1 ... DONE
[10:26:08.436] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:26:08.437] MultisessionFuture started
[10:26:08.437] - Launch lazy future ... done
[10:26:08.437] run() for ‘MultisessionFuture’ ... done
[10:26:08.437] result() for ClusterFuture ...
[10:26:08.437] receiveMessageFromWorker() for ClusterFuture ...
[10:26:08.437] - Validating connection of MultisessionFuture
[10:26:08.482] - received message: FutureResult
[10:26:08.482] - Received FutureResult
[10:26:08.482] - Erased future from FutureRegistry
[10:26:08.482] result() for ClusterFuture ...
[10:26:08.483] - result already collected: FutureResult
[10:26:08.483] result() for ClusterFuture ... done
[10:26:08.483] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:08.483] result() for ClusterFuture ... done
[10:26:08.483] result() for ClusterFuture ...
[10:26:08.483] - result already collected: FutureResult
[10:26:08.483] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[10:26:08.484] plan(): Setting new future strategy stack:
[10:26:08.484] List of future strategies:
[10:26:08.484] 1. FutureStrategy:
[10:26:08.484]    - args: function (..., envir = parent.frame())
[10:26:08.484]    - tweaked: FALSE
[10:26:08.484]    - call: future::plan(oplan)
[10:26:08.485] plan(): nbrOfWorkers() = 1
> 
