
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:25:15.505] plan(): Setting new future strategy stack:
[10:25:15.505] List of future strategies:
[10:25:15.505] 1. sequential:
[10:25:15.505]    - args: function (..., envir = parent.frame())
[10:25:15.505]    - tweaked: FALSE
[10:25:15.505]    - call: future::plan("sequential")
[10:25:15.519] plan(): nbrOfWorkers() = 1
> 
> message("*** Demos ...")
*** Demos ...
> 
> message("*** Fibonacci demo of the 'future' package ...")
*** Fibonacci demo of the 'future' package ...
> demo("fibonacci", package = "future", ask = FALSE)


	demo(fibonacci)
	---- ~~~~~~~~~

> library("future")

> library("listenv")

> ## IMPORTANT:
> ## 1. The below usage of lazy futures will only work when they are
> ##    all evaluated in the same process.
> ## 2. We disable the capturing of standard output (stdout=NA) to avoid
> ##    'sink stack is full' errors
> ## 3. We disable the capturing of most conditions (condition="error") to
> ##    avoid stacking up too many conditions
> oplan <- plan(sequential)
[10:25:15.533] plan(): Setting new future strategy stack:
[10:25:15.534] List of future strategies:
[10:25:15.534] 1. sequential:
[10:25:15.534]    - args: function (..., envir = parent.frame())
[10:25:15.534]    - tweaked: FALSE
[10:25:15.534]    - call: plan(sequential)
[10:25:15.544] plan(): nbrOfWorkers() = 1

> ## Defines the first 100 Fibonacci numbers
> ## (0, 1, 1, 2, 3, 5, 8, ...)
> ## but calculate only the ones need when
> ## a number is actually requested.
> 
> x <- listenv()

> x[[1]] <- 0

> x[[2]] <- 1

> for (i in 3:100) {
+   x[[i]] %<-% { x[[i - 2]] + x[[i - 1]] } %lazy% TRUE %stdout% NA %conditions% "error"
+ }
[10:25:15.551] getGlobalsAndPackages() ...
[10:25:15.551] Searching for globals...
[10:25:15.559] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.560] Searching for globals ... DONE
[10:25:15.560] Resolving globals: FALSE
[10:25:15.561] The total size of the 2 globals is 224 bytes (224 bytes)
[10:25:15.561] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 224 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (168 bytes of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.562] - globals: [2] ‘x’, ‘i’
[10:25:15.562] 
[10:25:15.562] getGlobalsAndPackages() ... DONE
[10:25:15.563] getGlobalsAndPackages() ...
[10:25:15.563] Searching for globals...
[10:25:15.564] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.564] Searching for globals ... DONE
[10:25:15.564] Resolving globals: FALSE
[10:25:15.565] The total size of the 2 globals is 8.41 KiB (8608 bytes)
[10:25:15.565] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 8.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (8.35 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.566] - globals: [2] ‘x’, ‘i’
[10:25:15.566] 
[10:25:15.566] getGlobalsAndPackages() ... DONE
[10:25:15.566] getGlobalsAndPackages() ...
[10:25:15.566] Searching for globals...
[10:25:15.568] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.568] Searching for globals ... DONE
[10:25:15.568] Resolving globals: FALSE
[10:25:15.569] The total size of the 2 globals is 16.76 KiB (17160 bytes)
[10:25:15.569] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 16.76 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (16.70 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.569] - globals: [2] ‘x’, ‘i’
[10:25:15.570] 
[10:25:15.570] getGlobalsAndPackages() ... DONE
[10:25:15.570] getGlobalsAndPackages() ...
[10:25:15.570] Searching for globals...
[10:25:15.572] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.572] Searching for globals ... DONE
[10:25:15.572] Resolving globals: FALSE
[10:25:15.573] The total size of the 2 globals is 25.11 KiB (25712 bytes)
[10:25:15.573] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 25.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (25.05 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.574] - globals: [2] ‘x’, ‘i’
[10:25:15.574] 
[10:25:15.574] getGlobalsAndPackages() ... DONE
[10:25:15.574] getGlobalsAndPackages() ...
[10:25:15.574] Searching for globals...
[10:25:15.576] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.576] Searching for globals ... DONE
[10:25:15.576] Resolving globals: FALSE
[10:25:15.577] The total size of the 2 globals is 33.46 KiB (34264 bytes)
[10:25:15.578] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 33.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (33.41 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.578] - globals: [2] ‘x’, ‘i’
[10:25:15.578] 
[10:25:15.578] getGlobalsAndPackages() ... DONE
[10:25:15.579] getGlobalsAndPackages() ...
[10:25:15.579] Searching for globals...
[10:25:15.580] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.580] Searching for globals ... DONE
[10:25:15.580] Resolving globals: FALSE
[10:25:15.583] The total size of the 2 globals is 41.81 KiB (42816 bytes)
[10:25:15.583] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 41.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (41.76 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.583] - globals: [2] ‘x’, ‘i’
[10:25:15.583] 
[10:25:15.584] getGlobalsAndPackages() ... DONE
[10:25:15.584] getGlobalsAndPackages() ...
[10:25:15.584] Searching for globals...
[10:25:15.586] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.586] Searching for globals ... DONE
[10:25:15.586] Resolving globals: FALSE
[10:25:15.588] The total size of the 2 globals is 50.16 KiB (51368 bytes)
[10:25:15.588] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 50.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (50.11 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.588] - globals: [2] ‘x’, ‘i’
[10:25:15.588] 
[10:25:15.588] getGlobalsAndPackages() ... DONE
[10:25:15.589] getGlobalsAndPackages() ...
[10:25:15.589] Searching for globals...
[10:25:15.590] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.590] Searching for globals ... DONE
[10:25:15.591] Resolving globals: FALSE
[10:25:15.593] The total size of the 2 globals is 58.52 KiB (59920 bytes)
[10:25:15.593] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 58.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (58.46 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.593] - globals: [2] ‘x’, ‘i’
[10:25:15.593] 
[10:25:15.593] getGlobalsAndPackages() ... DONE
[10:25:15.594] getGlobalsAndPackages() ...
[10:25:15.594] Searching for globals...
[10:25:15.595] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.595] Searching for globals ... DONE
[10:25:15.596] Resolving globals: FALSE
[10:25:15.598] The total size of the 2 globals is 66.87 KiB (68472 bytes)
[10:25:15.598] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 66.87 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (66.81 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.599] - globals: [2] ‘x’, ‘i’
[10:25:15.599] 
[10:25:15.599] getGlobalsAndPackages() ... DONE
[10:25:15.599] getGlobalsAndPackages() ...
[10:25:15.599] Searching for globals...
[10:25:15.601] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.601] Searching for globals ... DONE
[10:25:15.601] Resolving globals: FALSE
[10:25:15.604] The total size of the 2 globals is 75.22 KiB (77024 bytes)
[10:25:15.605] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 75.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (75.16 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.605] - globals: [2] ‘x’, ‘i’
[10:25:15.605] 
[10:25:15.605] getGlobalsAndPackages() ... DONE
[10:25:15.606] getGlobalsAndPackages() ...
[10:25:15.606] Searching for globals...
[10:25:15.607] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.607] Searching for globals ... DONE
[10:25:15.607] Resolving globals: FALSE
[10:25:15.610] The total size of the 2 globals is 83.57 KiB (85576 bytes)
[10:25:15.611] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 83.57 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (83.52 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.611] - globals: [2] ‘x’, ‘i’
[10:25:15.611] 
[10:25:15.611] getGlobalsAndPackages() ... DONE
[10:25:15.611] getGlobalsAndPackages() ...
[10:25:15.612] Searching for globals...
[10:25:15.613] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.613] Searching for globals ... DONE
[10:25:15.613] Resolving globals: FALSE
[10:25:15.616] The total size of the 2 globals is 91.92 KiB (94128 bytes)
[10:25:15.617] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 91.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (91.87 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.617] - globals: [2] ‘x’, ‘i’
[10:25:15.617] 
[10:25:15.617] getGlobalsAndPackages() ... DONE
[10:25:15.618] getGlobalsAndPackages() ...
[10:25:15.618] Searching for globals...
[10:25:15.619] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.619] Searching for globals ... DONE
[10:25:15.619] Resolving globals: FALSE
[10:25:15.624] The total size of the 2 globals is 100.27 KiB (102680 bytes)
[10:25:15.624] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 100.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (100.22 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.625] - globals: [2] ‘x’, ‘i’
[10:25:15.625] 
[10:25:15.625] getGlobalsAndPackages() ... DONE
[10:25:15.625] getGlobalsAndPackages() ...
[10:25:15.625] Searching for globals...
[10:25:15.627] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.627] Searching for globals ... DONE
[10:25:15.627] Resolving globals: FALSE
[10:25:15.631] The total size of the 2 globals is 108.62 KiB (111232 bytes)
[10:25:15.631] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 108.62 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (108.57 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.631] - globals: [2] ‘x’, ‘i’
[10:25:15.631] 
[10:25:15.631] getGlobalsAndPackages() ... DONE
[10:25:15.632] getGlobalsAndPackages() ...
[10:25:15.632] Searching for globals...
[10:25:15.633] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.634] Searching for globals ... DONE
[10:25:15.634] Resolving globals: FALSE
[10:25:15.638] The total size of the 2 globals is 116.98 KiB (119784 bytes)
[10:25:15.638] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 116.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (116.92 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.638] - globals: [2] ‘x’, ‘i’
[10:25:15.638] 
[10:25:15.638] getGlobalsAndPackages() ... DONE
[10:25:15.639] getGlobalsAndPackages() ...
[10:25:15.639] Searching for globals...
[10:25:15.640] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.640] Searching for globals ... DONE
[10:25:15.641] Resolving globals: FALSE
[10:25:15.646] The total size of the 2 globals is 125.33 KiB (128336 bytes)
[10:25:15.646] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 125.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (125.27 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.646] - globals: [2] ‘x’, ‘i’
[10:25:15.646] 
[10:25:15.647] getGlobalsAndPackages() ... DONE
[10:25:15.647] getGlobalsAndPackages() ...
[10:25:15.647] Searching for globals...
[10:25:15.648] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.649] Searching for globals ... DONE
[10:25:15.649] Resolving globals: FALSE
[10:25:15.653] The total size of the 2 globals is 133.68 KiB (136888 bytes)
[10:25:15.653] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 133.68 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133.62 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.654] - globals: [2] ‘x’, ‘i’
[10:25:15.654] 
[10:25:15.654] getGlobalsAndPackages() ... DONE
[10:25:15.654] getGlobalsAndPackages() ...
[10:25:15.654] Searching for globals...
[10:25:15.656] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.656] Searching for globals ... DONE
[10:25:15.656] Resolving globals: FALSE
[10:25:15.662] The total size of the 2 globals is 142.03 KiB (145440 bytes)
[10:25:15.662] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 142.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (141.98 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.662] - globals: [2] ‘x’, ‘i’
[10:25:15.662] 
[10:25:15.662] getGlobalsAndPackages() ... DONE
[10:25:15.663] getGlobalsAndPackages() ...
[10:25:15.663] Searching for globals...
[10:25:15.664] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.665] Searching for globals ... DONE
[10:25:15.665] Resolving globals: FALSE
[10:25:15.670] The total size of the 2 globals is 150.38 KiB (153992 bytes)
[10:25:15.670] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 150.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (150.33 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.670] - globals: [2] ‘x’, ‘i’
[10:25:15.670] 
[10:25:15.670] getGlobalsAndPackages() ... DONE
[10:25:15.671] getGlobalsAndPackages() ...
[10:25:15.671] Searching for globals...
[10:25:15.672] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.672] Searching for globals ... DONE
[10:25:15.672] Resolving globals: FALSE
[10:25:15.678] The total size of the 2 globals is 158.73 KiB (162544 bytes)
[10:25:15.679] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 158.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (158.68 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.679] - globals: [2] ‘x’, ‘i’
[10:25:15.679] 
[10:25:15.679] getGlobalsAndPackages() ... DONE
[10:25:15.680] getGlobalsAndPackages() ...
[10:25:15.680] Searching for globals...
[10:25:15.681] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.681] Searching for globals ... DONE
[10:25:15.681] Resolving globals: FALSE
[10:25:15.687] The total size of the 2 globals is 167.09 KiB (171096 bytes)
[10:25:15.687] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 167.09 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (167.03 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.687] - globals: [2] ‘x’, ‘i’
[10:25:15.687] 
[10:25:15.687] getGlobalsAndPackages() ... DONE
[10:25:15.688] getGlobalsAndPackages() ...
[10:25:15.688] Searching for globals...
[10:25:15.689] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.689] Searching for globals ... DONE
[10:25:15.690] Resolving globals: FALSE
[10:25:15.696] The total size of the 2 globals is 175.44 KiB (179648 bytes)
[10:25:15.696] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 175.44 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (175.38 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.697] - globals: [2] ‘x’, ‘i’
[10:25:15.697] 
[10:25:15.697] getGlobalsAndPackages() ... DONE
[10:25:15.697] getGlobalsAndPackages() ...
[10:25:15.697] Searching for globals...
[10:25:15.699] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.699] Searching for globals ... DONE
[10:25:15.699] Resolving globals: FALSE
[10:25:15.705] The total size of the 2 globals is 183.79 KiB (188200 bytes)
[10:25:15.705] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 183.79 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (183.73 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.705] - globals: [2] ‘x’, ‘i’
[10:25:15.706] 
[10:25:15.706] getGlobalsAndPackages() ... DONE
[10:25:15.706] getGlobalsAndPackages() ...
[10:25:15.706] Searching for globals...
[10:25:15.708] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.708] Searching for globals ... DONE
[10:25:15.708] Resolving globals: FALSE
[10:25:15.715] The total size of the 2 globals is 192.14 KiB (196752 bytes)
[10:25:15.715] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 192.14 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (192.09 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.715] - globals: [2] ‘x’, ‘i’
[10:25:15.716] 
[10:25:15.716] getGlobalsAndPackages() ... DONE
[10:25:15.716] getGlobalsAndPackages() ...
[10:25:15.716] Searching for globals...
[10:25:15.718] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.718] Searching for globals ... DONE
[10:25:15.718] Resolving globals: FALSE
[10:25:15.724] The total size of the 2 globals is 200.49 KiB (205304 bytes)
[10:25:15.725] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 200.49 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (200.44 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.725] - globals: [2] ‘x’, ‘i’
[10:25:15.725] 
[10:25:15.725] getGlobalsAndPackages() ... DONE
[10:25:15.725] getGlobalsAndPackages() ...
[10:25:15.725] Searching for globals...
[10:25:15.727] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.727] Searching for globals ... DONE
[10:25:15.727] Resolving globals: FALSE
[10:25:15.735] The total size of the 2 globals is 208.84 KiB (213856 bytes)
[10:25:15.735] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 208.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (208.79 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.735] - globals: [2] ‘x’, ‘i’
[10:25:15.735] 
[10:25:15.736] getGlobalsAndPackages() ... DONE
[10:25:15.736] getGlobalsAndPackages() ...
[10:25:15.736] Searching for globals...
[10:25:15.738] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.738] Searching for globals ... DONE
[10:25:15.738] Resolving globals: FALSE
[10:25:15.745] The total size of the 2 globals is 217.20 KiB (222408 bytes)
[10:25:15.745] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 217.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (217.14 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.745] - globals: [2] ‘x’, ‘i’
[10:25:15.745] 
[10:25:15.745] getGlobalsAndPackages() ... DONE
[10:25:15.747] getGlobalsAndPackages() ...
[10:25:15.747] Searching for globals...
[10:25:15.748] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.748] Searching for globals ... DONE
[10:25:15.748] Resolving globals: FALSE
[10:25:15.755] The total size of the 2 globals is 225.55 KiB (230960 bytes)
[10:25:15.756] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 225.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (225.49 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.756] - globals: [2] ‘x’, ‘i’
[10:25:15.756] 
[10:25:15.756] getGlobalsAndPackages() ... DONE
[10:25:15.757] getGlobalsAndPackages() ...
[10:25:15.757] Searching for globals...
[10:25:15.758] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.758] Searching for globals ... DONE
[10:25:15.758] Resolving globals: FALSE
[10:25:15.767] The total size of the 2 globals is 233.90 KiB (239512 bytes)
[10:25:15.767] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 233.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (233.84 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.767] - globals: [2] ‘x’, ‘i’
[10:25:15.767] 
[10:25:15.767] getGlobalsAndPackages() ... DONE
[10:25:15.768] getGlobalsAndPackages() ...
[10:25:15.768] Searching for globals...
[10:25:15.769] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.769] Searching for globals ... DONE
[10:25:15.769] Resolving globals: FALSE
[10:25:15.777] The total size of the 2 globals is 242.25 KiB (248064 bytes)
[10:25:15.777] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 242.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (242.20 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.778] - globals: [2] ‘x’, ‘i’
[10:25:15.778] 
[10:25:15.778] getGlobalsAndPackages() ... DONE
[10:25:15.778] getGlobalsAndPackages() ...
[10:25:15.779] Searching for globals...
[10:25:15.780] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.781] Searching for globals ... DONE
[10:25:15.781] Resolving globals: FALSE
[10:25:15.789] The total size of the 2 globals is 250.60 KiB (256616 bytes)
[10:25:15.789] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 250.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (250.55 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.789] - globals: [2] ‘x’, ‘i’
[10:25:15.789] 
[10:25:15.789] getGlobalsAndPackages() ... DONE
[10:25:15.790] getGlobalsAndPackages() ...
[10:25:15.790] Searching for globals...
[10:25:15.791] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.791] Searching for globals ... DONE
[10:25:15.791] Resolving globals: FALSE
[10:25:15.800] The total size of the 2 globals is 258.95 KiB (265168 bytes)
[10:25:15.801] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 258.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (258.90 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.801] - globals: [2] ‘x’, ‘i’
[10:25:15.801] 
[10:25:15.801] getGlobalsAndPackages() ... DONE
[10:25:15.802] getGlobalsAndPackages() ...
[10:25:15.802] Searching for globals...
[10:25:15.803] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.803] Searching for globals ... DONE
[10:25:15.803] Resolving globals: FALSE
[10:25:15.812] The total size of the 2 globals is 267.30 KiB (273720 bytes)
[10:25:15.813] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 267.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (267.25 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.813] - globals: [2] ‘x’, ‘i’
[10:25:15.813] 
[10:25:15.813] getGlobalsAndPackages() ... DONE
[10:25:15.814] getGlobalsAndPackages() ...
[10:25:15.814] Searching for globals...
[10:25:15.815] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.815] Searching for globals ... DONE
[10:25:15.815] Resolving globals: FALSE
[10:25:15.824] The total size of the 2 globals is 275.66 KiB (282272 bytes)
[10:25:15.824] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 275.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (275.60 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.825] - globals: [2] ‘x’, ‘i’
[10:25:15.825] 
[10:25:15.825] getGlobalsAndPackages() ... DONE
[10:25:15.825] getGlobalsAndPackages() ...
[10:25:15.825] Searching for globals...
[10:25:15.828] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.828] Searching for globals ... DONE
[10:25:15.828] Resolving globals: FALSE
[10:25:15.837] The total size of the 2 globals is 284.01 KiB (290824 bytes)
[10:25:15.837] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 284.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (283.95 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.837] - globals: [2] ‘x’, ‘i’
[10:25:15.837] 
[10:25:15.837] getGlobalsAndPackages() ... DONE
[10:25:15.838] getGlobalsAndPackages() ...
[10:25:15.838] Searching for globals...
[10:25:15.839] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.839] Searching for globals ... DONE
[10:25:15.840] Resolving globals: FALSE
[10:25:15.849] The total size of the 2 globals is 292.36 KiB (299376 bytes)
[10:25:15.850] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 292.36 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (292.30 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.850] - globals: [2] ‘x’, ‘i’
[10:25:15.850] 
[10:25:15.850] getGlobalsAndPackages() ... DONE
[10:25:15.851] getGlobalsAndPackages() ...
[10:25:15.851] Searching for globals...
[10:25:15.852] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.852] Searching for globals ... DONE
[10:25:15.852] Resolving globals: FALSE
[10:25:15.863] The total size of the 2 globals is 300.71 KiB (307928 bytes)
[10:25:15.863] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 300.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (300.66 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.863] - globals: [2] ‘x’, ‘i’
[10:25:15.863] 
[10:25:15.863] getGlobalsAndPackages() ... DONE
[10:25:15.864] getGlobalsAndPackages() ...
[10:25:15.864] Searching for globals...
[10:25:15.865] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.865] Searching for globals ... DONE
[10:25:15.865] Resolving globals: FALSE
[10:25:15.896] The total size of the 2 globals is 309.06 KiB (316480 bytes)
[10:25:15.897] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 309.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (309.01 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.897] - globals: [2] ‘x’, ‘i’
[10:25:15.897] 
[10:25:15.897] getGlobalsAndPackages() ... DONE
[10:25:15.898] getGlobalsAndPackages() ...
[10:25:15.898] Searching for globals...
[10:25:15.899] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.900] Searching for globals ... DONE
[10:25:15.900] Resolving globals: FALSE
[10:25:15.911] The total size of the 2 globals is 317.41 KiB (325032 bytes)
[10:25:15.911] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 317.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (317.36 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.911] - globals: [2] ‘x’, ‘i’
[10:25:15.912] 
[10:25:15.912] getGlobalsAndPackages() ... DONE
[10:25:15.912] getGlobalsAndPackages() ...
[10:25:15.912] Searching for globals...
[10:25:15.914] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.914] Searching for globals ... DONE
[10:25:15.914] Resolving globals: FALSE
[10:25:15.924] The total size of the 2 globals is 325.77 KiB (333584 bytes)
[10:25:15.925] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 325.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (325.71 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.925] - globals: [2] ‘x’, ‘i’
[10:25:15.925] 
[10:25:15.925] getGlobalsAndPackages() ... DONE
[10:25:15.926] getGlobalsAndPackages() ...
[10:25:15.926] Searching for globals...
[10:25:15.928] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.928] Searching for globals ... DONE
[10:25:15.928] Resolving globals: FALSE
[10:25:15.939] The total size of the 2 globals is 334.12 KiB (342136 bytes)
[10:25:15.939] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 334.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (334.06 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.939] - globals: [2] ‘x’, ‘i’
[10:25:15.939] 
[10:25:15.940] getGlobalsAndPackages() ... DONE
[10:25:15.940] getGlobalsAndPackages() ...
[10:25:15.940] Searching for globals...
[10:25:15.942] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.942] Searching for globals ... DONE
[10:25:15.942] Resolving globals: FALSE
[10:25:15.953] The total size of the 2 globals is 342.47 KiB (350688 bytes)
[10:25:15.954] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 342.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (342.41 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.954] - globals: [2] ‘x’, ‘i’
[10:25:15.954] 
[10:25:15.954] getGlobalsAndPackages() ... DONE
[10:25:15.955] getGlobalsAndPackages() ...
[10:25:15.955] Searching for globals...
[10:25:15.956] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.956] Searching for globals ... DONE
[10:25:15.956] Resolving globals: FALSE
[10:25:15.968] The total size of the 2 globals is 350.82 KiB (359240 bytes)
[10:25:15.968] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 350.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (350.77 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.969] - globals: [2] ‘x’, ‘i’
[10:25:15.969] 
[10:25:15.969] getGlobalsAndPackages() ... DONE
[10:25:15.969] getGlobalsAndPackages() ...
[10:25:15.969] Searching for globals...
[10:25:15.971] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.971] Searching for globals ... DONE
[10:25:15.971] Resolving globals: FALSE
[10:25:15.983] The total size of the 2 globals is 359.17 KiB (367792 bytes)
[10:25:15.984] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 359.17 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (359.12 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.984] - globals: [2] ‘x’, ‘i’
[10:25:15.984] 
[10:25:15.984] getGlobalsAndPackages() ... DONE
[10:25:15.984] getGlobalsAndPackages() ...
[10:25:15.984] Searching for globals...
[10:25:15.986] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:15.986] Searching for globals ... DONE
[10:25:15.986] Resolving globals: FALSE
[10:25:15.998] The total size of the 2 globals is 367.52 KiB (376344 bytes)
[10:25:15.999] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 367.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (367.47 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:15.999] - globals: [2] ‘x’, ‘i’
[10:25:15.999] 
[10:25:15.999] getGlobalsAndPackages() ... DONE
[10:25:16.000] getGlobalsAndPackages() ...
[10:25:16.000] Searching for globals...
[10:25:16.001] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.001] Searching for globals ... DONE
[10:25:16.001] Resolving globals: FALSE
[10:25:16.014] The total size of the 2 globals is 375.88 KiB (384896 bytes)
[10:25:16.014] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 375.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (375.82 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.014] - globals: [2] ‘x’, ‘i’
[10:25:16.015] 
[10:25:16.015] getGlobalsAndPackages() ... DONE
[10:25:16.015] getGlobalsAndPackages() ...
[10:25:16.015] Searching for globals...
[10:25:16.017] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.017] Searching for globals ... DONE
[10:25:16.017] Resolving globals: FALSE
[10:25:16.030] The total size of the 2 globals is 384.23 KiB (393448 bytes)
[10:25:16.030] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 384.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (384.17 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.030] - globals: [2] ‘x’, ‘i’
[10:25:16.030] 
[10:25:16.030] getGlobalsAndPackages() ... DONE
[10:25:16.031] getGlobalsAndPackages() ...
[10:25:16.031] Searching for globals...
[10:25:16.032] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.032] Searching for globals ... DONE
[10:25:16.033] Resolving globals: FALSE
[10:25:16.046] The total size of the 2 globals is 392.58 KiB (402000 bytes)
[10:25:16.046] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 392.58 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (392.52 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.046] - globals: [2] ‘x’, ‘i’
[10:25:16.046] 
[10:25:16.046] getGlobalsAndPackages() ... DONE
[10:25:16.047] getGlobalsAndPackages() ...
[10:25:16.047] Searching for globals...
[10:25:16.048] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.049] Searching for globals ... DONE
[10:25:16.049] Resolving globals: FALSE
[10:25:16.062] The total size of the 2 globals is 400.93 KiB (410552 bytes)
[10:25:16.063] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 400.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (400.88 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.063] - globals: [2] ‘x’, ‘i’
[10:25:16.063] 
[10:25:16.063] getGlobalsAndPackages() ... DONE
[10:25:16.063] getGlobalsAndPackages() ...
[10:25:16.064] Searching for globals...
[10:25:16.065] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.065] Searching for globals ... DONE
[10:25:16.065] Resolving globals: FALSE
[10:25:16.079] The total size of the 2 globals is 409.28 KiB (419104 bytes)
[10:25:16.080] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 409.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (409.23 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.080] - globals: [2] ‘x’, ‘i’
[10:25:16.080] 
[10:25:16.080] getGlobalsAndPackages() ... DONE
[10:25:16.080] getGlobalsAndPackages() ...
[10:25:16.080] Searching for globals...
[10:25:16.082] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.082] Searching for globals ... DONE
[10:25:16.082] Resolving globals: FALSE
[10:25:16.096] The total size of the 2 globals is 417.63 KiB (427656 bytes)
[10:25:16.096] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 417.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (417.58 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.097] - globals: [2] ‘x’, ‘i’
[10:25:16.097] 
[10:25:16.097] getGlobalsAndPackages() ... DONE
[10:25:16.097] getGlobalsAndPackages() ...
[10:25:16.097] Searching for globals...
[10:25:16.099] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.100] Searching for globals ... DONE
[10:25:16.100] Resolving globals: FALSE
[10:25:16.114] The total size of the 2 globals is 425.98 KiB (436208 bytes)
[10:25:16.114] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 425.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (425.93 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.115] - globals: [2] ‘x’, ‘i’
[10:25:16.115] 
[10:25:16.115] getGlobalsAndPackages() ... DONE
[10:25:16.115] getGlobalsAndPackages() ...
[10:25:16.115] Searching for globals...
[10:25:16.117] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.117] Searching for globals ... DONE
[10:25:16.117] Resolving globals: FALSE
[10:25:16.131] The total size of the 2 globals is 434.34 KiB (444760 bytes)
[10:25:16.132] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 434.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (434.28 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.132] - globals: [2] ‘x’, ‘i’
[10:25:16.132] 
[10:25:16.132] getGlobalsAndPackages() ... DONE
[10:25:16.133] getGlobalsAndPackages() ...
[10:25:16.133] Searching for globals...
[10:25:16.134] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.134] Searching for globals ... DONE
[10:25:16.134] Resolving globals: FALSE
[10:25:16.149] The total size of the 2 globals is 442.69 KiB (453312 bytes)
[10:25:16.150] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 442.69 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (442.63 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.150] - globals: [2] ‘x’, ‘i’
[10:25:16.150] 
[10:25:16.150] getGlobalsAndPackages() ... DONE
[10:25:16.150] getGlobalsAndPackages() ...
[10:25:16.150] Searching for globals...
[10:25:16.152] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.152] Searching for globals ... DONE
[10:25:16.152] Resolving globals: FALSE
[10:25:16.168] The total size of the 2 globals is 451.04 KiB (461864 bytes)
[10:25:16.169] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 451.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (450.98 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.169] - globals: [2] ‘x’, ‘i’
[10:25:16.169] 
[10:25:16.169] getGlobalsAndPackages() ... DONE
[10:25:16.170] getGlobalsAndPackages() ...
[10:25:16.170] Searching for globals...
[10:25:16.171] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.171] Searching for globals ... DONE
[10:25:16.171] Resolving globals: FALSE
[10:25:16.187] The total size of the 2 globals is 459.39 KiB (470416 bytes)
[10:25:16.187] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 459.39 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (459.34 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.188] - globals: [2] ‘x’, ‘i’
[10:25:16.188] 
[10:25:16.188] getGlobalsAndPackages() ... DONE
[10:25:16.188] getGlobalsAndPackages() ...
[10:25:16.188] Searching for globals...
[10:25:16.191] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.191] Searching for globals ... DONE
[10:25:16.191] Resolving globals: FALSE
[10:25:16.209] The total size of the 2 globals is 467.74 KiB (478968 bytes)
[10:25:16.210] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 467.74 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (467.69 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.210] - globals: [2] ‘x’, ‘i’
[10:25:16.210] 
[10:25:16.210] getGlobalsAndPackages() ... DONE
[10:25:16.211] getGlobalsAndPackages() ...
[10:25:16.211] Searching for globals...
[10:25:16.213] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.213] Searching for globals ... DONE
[10:25:16.213] Resolving globals: FALSE
[10:25:16.233] The total size of the 2 globals is 476.09 KiB (487520 bytes)
[10:25:16.233] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 476.09 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (476.04 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.233] - globals: [2] ‘x’, ‘i’
[10:25:16.233] 
[10:25:16.234] getGlobalsAndPackages() ... DONE
[10:25:16.234] getGlobalsAndPackages() ...
[10:25:16.234] Searching for globals...
[10:25:16.236] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.236] Searching for globals ... DONE
[10:25:16.236] Resolving globals: FALSE
[10:25:16.255] The total size of the 2 globals is 484.45 KiB (496072 bytes)
[10:25:16.255] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 484.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (484.39 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.255] - globals: [2] ‘x’, ‘i’
[10:25:16.256] 
[10:25:16.256] getGlobalsAndPackages() ... DONE
[10:25:16.256] getGlobalsAndPackages() ...
[10:25:16.256] Searching for globals...
[10:25:16.258] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.258] Searching for globals ... DONE
[10:25:16.258] Resolving globals: FALSE
[10:25:16.275] The total size of the 2 globals is 492.80 KiB (504624 bytes)
[10:25:16.275] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 492.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (492.74 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.276] - globals: [2] ‘x’, ‘i’
[10:25:16.276] 
[10:25:16.276] getGlobalsAndPackages() ... DONE
[10:25:16.276] getGlobalsAndPackages() ...
[10:25:16.276] Searching for globals...
[10:25:16.278] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.278] Searching for globals ... DONE
[10:25:16.278] Resolving globals: FALSE
[10:25:16.295] The total size of the 2 globals is 501.15 KiB (513176 bytes)
[10:25:16.296] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 501.15 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (501.09 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.296] - globals: [2] ‘x’, ‘i’
[10:25:16.296] 
[10:25:16.296] getGlobalsAndPackages() ... DONE
[10:25:16.297] getGlobalsAndPackages() ...
[10:25:16.297] Searching for globals...
[10:25:16.298] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.298] Searching for globals ... DONE
[10:25:16.298] Resolving globals: FALSE
[10:25:16.315] The total size of the 2 globals is 509.50 KiB (521728 bytes)
[10:25:16.316] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 509.50 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (509.45 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.316] - globals: [2] ‘x’, ‘i’
[10:25:16.316] 
[10:25:16.316] getGlobalsAndPackages() ... DONE
[10:25:16.316] getGlobalsAndPackages() ...
[10:25:16.316] Searching for globals...
[10:25:16.318] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.318] Searching for globals ... DONE
[10:25:16.318] Resolving globals: FALSE
[10:25:16.336] The total size of the 2 globals is 517.85 KiB (530280 bytes)
[10:25:16.337] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 517.85 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (517.80 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.337] - globals: [2] ‘x’, ‘i’
[10:25:16.337] 
[10:25:16.337] getGlobalsAndPackages() ... DONE
[10:25:16.337] getGlobalsAndPackages() ...
[10:25:16.337] Searching for globals...
[10:25:16.339] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.339] Searching for globals ... DONE
[10:25:16.339] Resolving globals: FALSE
[10:25:16.357] The total size of the 2 globals is 526.20 KiB (538832 bytes)
[10:25:16.357] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 526.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (526.15 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.357] - globals: [2] ‘x’, ‘i’
[10:25:16.358] 
[10:25:16.358] getGlobalsAndPackages() ... DONE
[10:25:16.358] getGlobalsAndPackages() ...
[10:25:16.358] Searching for globals...
[10:25:16.360] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.360] Searching for globals ... DONE
[10:25:16.360] Resolving globals: FALSE
[10:25:16.378] The total size of the 2 globals is 534.55 KiB (547384 bytes)
[10:25:16.379] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 534.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (534.50 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.379] - globals: [2] ‘x’, ‘i’
[10:25:16.379] 
[10:25:16.379] getGlobalsAndPackages() ... DONE
[10:25:16.380] getGlobalsAndPackages() ...
[10:25:16.380] Searching for globals...
[10:25:16.381] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.381] Searching for globals ... DONE
[10:25:16.381] Resolving globals: FALSE
[10:25:16.399] The total size of the 2 globals is 542.91 KiB (555936 bytes)
[10:25:16.400] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 542.91 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (542.85 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.400] - globals: [2] ‘x’, ‘i’
[10:25:16.400] 
[10:25:16.400] getGlobalsAndPackages() ... DONE
[10:25:16.401] getGlobalsAndPackages() ...
[10:25:16.401] Searching for globals...
[10:25:16.402] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.402] Searching for globals ... DONE
[10:25:16.402] Resolving globals: FALSE
[10:25:16.432] The total size of the 2 globals is 551.26 KiB (564488 bytes)
[10:25:16.432] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 551.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (551.20 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.432] - globals: [2] ‘x’, ‘i’
[10:25:16.432] 
[10:25:16.433] getGlobalsAndPackages() ... DONE
[10:25:16.433] getGlobalsAndPackages() ...
[10:25:16.434] Searching for globals...
[10:25:16.435] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.436] Searching for globals ... DONE
[10:25:16.436] Resolving globals: FALSE
[10:25:16.459] The total size of the 2 globals is 559.61 KiB (573040 bytes)
[10:25:16.460] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 559.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (559.55 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.460] - globals: [2] ‘x’, ‘i’
[10:25:16.460] 
[10:25:16.460] getGlobalsAndPackages() ... DONE
[10:25:16.460] getGlobalsAndPackages() ...
[10:25:16.461] Searching for globals...
[10:25:16.462] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.463] Searching for globals ... DONE
[10:25:16.463] Resolving globals: FALSE
[10:25:16.487] The total size of the 2 globals is 567.96 KiB (581592 bytes)
[10:25:16.488] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 567.96 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (567.91 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.488] - globals: [2] ‘x’, ‘i’
[10:25:16.488] 
[10:25:16.488] getGlobalsAndPackages() ... DONE
[10:25:16.489] getGlobalsAndPackages() ...
[10:25:16.489] Searching for globals...
[10:25:16.491] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.491] Searching for globals ... DONE
[10:25:16.491] Resolving globals: FALSE
[10:25:16.512] The total size of the 2 globals is 576.31 KiB (590144 bytes)
[10:25:16.513] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 576.31 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (576.26 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.513] - globals: [2] ‘x’, ‘i’
[10:25:16.513] 
[10:25:16.513] getGlobalsAndPackages() ... DONE
[10:25:16.513] getGlobalsAndPackages() ...
[10:25:16.514] Searching for globals...
[10:25:16.515] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.515] Searching for globals ... DONE
[10:25:16.515] Resolving globals: FALSE
[10:25:16.536] The total size of the 2 globals is 584.66 KiB (598696 bytes)
[10:25:16.536] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 584.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (584.61 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.536] - globals: [2] ‘x’, ‘i’
[10:25:16.536] 
[10:25:16.536] getGlobalsAndPackages() ... DONE
[10:25:16.537] getGlobalsAndPackages() ...
[10:25:16.537] Searching for globals...
[10:25:16.538] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.538] Searching for globals ... DONE
[10:25:16.539] Resolving globals: FALSE
[10:25:16.559] The total size of the 2 globals is 593.02 KiB (607248 bytes)
[10:25:16.560] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 593.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (592.96 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.560] - globals: [2] ‘x’, ‘i’
[10:25:16.560] 
[10:25:16.560] getGlobalsAndPackages() ... DONE
[10:25:16.561] getGlobalsAndPackages() ...
[10:25:16.561] Searching for globals...
[10:25:16.562] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.562] Searching for globals ... DONE
[10:25:16.562] Resolving globals: FALSE
[10:25:16.582] The total size of the 2 globals is 601.37 KiB (615800 bytes)
[10:25:16.583] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 601.37 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (601.31 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.583] - globals: [2] ‘x’, ‘i’
[10:25:16.583] 
[10:25:16.583] getGlobalsAndPackages() ... DONE
[10:25:16.584] getGlobalsAndPackages() ...
[10:25:16.584] Searching for globals...
[10:25:16.585] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.585] Searching for globals ... DONE
[10:25:16.585] Resolving globals: FALSE
[10:25:16.607] The total size of the 2 globals is 609.72 KiB (624352 bytes)
[10:25:16.607] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 609.72 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (609.66 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.607] - globals: [2] ‘x’, ‘i’
[10:25:16.607] 
[10:25:16.607] getGlobalsAndPackages() ... DONE
[10:25:16.608] getGlobalsAndPackages() ...
[10:25:16.608] Searching for globals...
[10:25:16.609] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.609] Searching for globals ... DONE
[10:25:16.609] Resolving globals: FALSE
[10:25:16.631] The total size of the 2 globals is 618.07 KiB (632904 bytes)
[10:25:16.631] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 618.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (618.02 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.631] - globals: [2] ‘x’, ‘i’
[10:25:16.631] 
[10:25:16.632] getGlobalsAndPackages() ... DONE
[10:25:16.632] getGlobalsAndPackages() ...
[10:25:16.632] Searching for globals...
[10:25:16.634] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.634] Searching for globals ... DONE
[10:25:16.634] Resolving globals: FALSE
[10:25:16.655] The total size of the 2 globals is 626.42 KiB (641456 bytes)
[10:25:16.655] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 626.42 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (626.37 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.656] - globals: [2] ‘x’, ‘i’
[10:25:16.656] 
[10:25:16.656] getGlobalsAndPackages() ... DONE
[10:25:16.656] getGlobalsAndPackages() ...
[10:25:16.656] Searching for globals...
[10:25:16.658] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.658] Searching for globals ... DONE
[10:25:16.658] Resolving globals: FALSE
[10:25:16.680] The total size of the 2 globals is 634.77 KiB (650008 bytes)
[10:25:16.681] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 634.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (634.72 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.684] - globals: [2] ‘x’, ‘i’
[10:25:16.684] 
[10:25:16.684] getGlobalsAndPackages() ... DONE
[10:25:16.685] getGlobalsAndPackages() ...
[10:25:16.685] Searching for globals...
[10:25:16.687] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.687] Searching for globals ... DONE
[10:25:16.687] Resolving globals: FALSE
[10:25:16.710] The total size of the 2 globals is 643.12 KiB (658560 bytes)
[10:25:16.710] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 643.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (643.07 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.710] - globals: [2] ‘x’, ‘i’
[10:25:16.710] 
[10:25:16.711] getGlobalsAndPackages() ... DONE
[10:25:16.711] getGlobalsAndPackages() ...
[10:25:16.711] Searching for globals...
[10:25:16.713] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.713] Searching for globals ... DONE
[10:25:16.713] Resolving globals: FALSE
[10:25:16.736] The total size of the 2 globals is 651.48 KiB (667112 bytes)
[10:25:16.736] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 651.48 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (651.42 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.736] - globals: [2] ‘x’, ‘i’
[10:25:16.737] 
[10:25:16.737] getGlobalsAndPackages() ... DONE
[10:25:16.737] getGlobalsAndPackages() ...
[10:25:16.737] Searching for globals...
[10:25:16.739] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.739] Searching for globals ... DONE
[10:25:16.739] Resolving globals: FALSE
[10:25:16.761] The total size of the 2 globals is 659.83 KiB (675664 bytes)
[10:25:16.762] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 659.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (659.77 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.762] - globals: [2] ‘x’, ‘i’
[10:25:16.762] 
[10:25:16.762] getGlobalsAndPackages() ... DONE
[10:25:16.763] getGlobalsAndPackages() ...
[10:25:16.763] Searching for globals...
[10:25:16.765] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.765] Searching for globals ... DONE
[10:25:16.765] Resolving globals: FALSE
[10:25:16.788] The total size of the 2 globals is 668.18 KiB (684216 bytes)
[10:25:16.788] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 668.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (668.12 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.789] - globals: [2] ‘x’, ‘i’
[10:25:16.789] 
[10:25:16.789] getGlobalsAndPackages() ... DONE
[10:25:16.789] getGlobalsAndPackages() ...
[10:25:16.789] Searching for globals...
[10:25:16.791] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.791] Searching for globals ... DONE
[10:25:16.792] Resolving globals: FALSE
[10:25:16.815] The total size of the 2 globals is 676.53 KiB (692768 bytes)
[10:25:16.816] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 676.53 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (676.48 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.816] - globals: [2] ‘x’, ‘i’
[10:25:16.816] 
[10:25:16.816] getGlobalsAndPackages() ... DONE
[10:25:16.816] getGlobalsAndPackages() ...
[10:25:16.817] Searching for globals...
[10:25:16.818] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.818] Searching for globals ... DONE
[10:25:16.818] Resolving globals: FALSE
[10:25:16.842] The total size of the 2 globals is 684.88 KiB (701320 bytes)
[10:25:16.843] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 684.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (684.83 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.843] - globals: [2] ‘x’, ‘i’
[10:25:16.843] 
[10:25:16.843] getGlobalsAndPackages() ... DONE
[10:25:16.844] getGlobalsAndPackages() ...
[10:25:16.844] Searching for globals...
[10:25:16.845] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.845] Searching for globals ... DONE
[10:25:16.845] Resolving globals: FALSE
[10:25:16.870] The total size of the 2 globals is 693.23 KiB (709872 bytes)
[10:25:16.871] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 693.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (693.18 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.871] - globals: [2] ‘x’, ‘i’
[10:25:16.871] 
[10:25:16.871] getGlobalsAndPackages() ... DONE
[10:25:16.872] getGlobalsAndPackages() ...
[10:25:16.872] Searching for globals...
[10:25:16.873] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.873] Searching for globals ... DONE
[10:25:16.873] Resolving globals: FALSE
[10:25:16.898] The total size of the 2 globals is 701.59 KiB (718424 bytes)
[10:25:16.898] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 701.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (701.53 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.899] - globals: [2] ‘x’, ‘i’
[10:25:16.899] 
[10:25:16.899] getGlobalsAndPackages() ... DONE
[10:25:16.899] getGlobalsAndPackages() ...
[10:25:16.899] Searching for globals...
[10:25:16.901] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.901] Searching for globals ... DONE
[10:25:16.901] Resolving globals: FALSE
[10:25:16.926] The total size of the 2 globals is 709.94 KiB (726976 bytes)
[10:25:16.927] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 709.94 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (709.88 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.927] - globals: [2] ‘x’, ‘i’
[10:25:16.927] 
[10:25:16.927] getGlobalsAndPackages() ... DONE
[10:25:16.927] getGlobalsAndPackages() ...
[10:25:16.927] Searching for globals...
[10:25:16.929] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.929] Searching for globals ... DONE
[10:25:16.929] Resolving globals: FALSE
[10:25:16.955] The total size of the 2 globals is 718.29 KiB (735528 bytes)
[10:25:16.955] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 718.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (718.23 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.955] - globals: [2] ‘x’, ‘i’
[10:25:16.955] 
[10:25:16.955] getGlobalsAndPackages() ... DONE
[10:25:16.956] getGlobalsAndPackages() ...
[10:25:16.956] Searching for globals...
[10:25:16.957] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.957] Searching for globals ... DONE
[10:25:16.958] Resolving globals: FALSE
[10:25:16.983] The total size of the 2 globals is 726.64 KiB (744080 bytes)
[10:25:16.984] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 726.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (726.59 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:16.984] - globals: [2] ‘x’, ‘i’
[10:25:16.984] 
[10:25:16.984] getGlobalsAndPackages() ... DONE
[10:25:16.985] getGlobalsAndPackages() ...
[10:25:16.985] Searching for globals...
[10:25:16.986] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:16.986] Searching for globals ... DONE
[10:25:16.986] Resolving globals: FALSE
[10:25:17.013] The total size of the 2 globals is 734.99 KiB (752632 bytes)
[10:25:17.013] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 734.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (734.94 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:17.013] - globals: [2] ‘x’, ‘i’
[10:25:17.013] 
[10:25:17.013] getGlobalsAndPackages() ... DONE
[10:25:17.014] getGlobalsAndPackages() ...
[10:25:17.014] Searching for globals...
[10:25:17.016] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:17.016] Searching for globals ... DONE
[10:25:17.017] Resolving globals: FALSE
[10:25:17.043] The total size of the 2 globals is 743.34 KiB (761184 bytes)
[10:25:17.043] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 743.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (743.29 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:17.043] - globals: [2] ‘x’, ‘i’
[10:25:17.043] 
[10:25:17.043] getGlobalsAndPackages() ... DONE
[10:25:17.044] getGlobalsAndPackages() ...
[10:25:17.044] Searching for globals...
[10:25:17.046] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:17.046] Searching for globals ... DONE
[10:25:17.046] Resolving globals: FALSE
[10:25:17.073] The total size of the 2 globals is 751.70 KiB (769736 bytes)
[10:25:17.074] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 751.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (751.64 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:17.074] - globals: [2] ‘x’, ‘i’
[10:25:17.074] 
[10:25:17.074] getGlobalsAndPackages() ... DONE
[10:25:17.075] getGlobalsAndPackages() ...
[10:25:17.075] Searching for globals...
[10:25:17.076] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:17.076] Searching for globals ... DONE
[10:25:17.077] Resolving globals: FALSE
[10:25:17.104] The total size of the 2 globals is 760.05 KiB (778288 bytes)
[10:25:17.105] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 760.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (759.99 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:17.105] - globals: [2] ‘x’, ‘i’
[10:25:17.105] 
[10:25:17.105] getGlobalsAndPackages() ... DONE
[10:25:17.105] getGlobalsAndPackages() ...
[10:25:17.106] Searching for globals...
[10:25:17.107] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:17.107] Searching for globals ... DONE
[10:25:17.107] Resolving globals: FALSE
[10:25:17.135] The total size of the 2 globals is 768.40 KiB (786840 bytes)
[10:25:17.135] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 768.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (768.34 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:17.135] - globals: [2] ‘x’, ‘i’
[10:25:17.136] 
[10:25:17.136] getGlobalsAndPackages() ... DONE
[10:25:17.136] getGlobalsAndPackages() ...
[10:25:17.136] Searching for globals...
[10:25:17.138] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:17.138] Searching for globals ... DONE
[10:25:17.138] Resolving globals: FALSE
[10:25:17.168] The total size of the 2 globals is 776.75 KiB (795392 bytes)
[10:25:17.169] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 776.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (776.70 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:17.169] - globals: [2] ‘x’, ‘i’
[10:25:17.169] 
[10:25:17.169] getGlobalsAndPackages() ... DONE
[10:25:17.170] getGlobalsAndPackages() ...
[10:25:17.170] Searching for globals...
[10:25:17.171] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:17.171] Searching for globals ... DONE
[10:25:17.171] Resolving globals: FALSE
[10:25:17.200] The total size of the 2 globals is 785.10 KiB (803944 bytes)
[10:25:17.200] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 785.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (785.05 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:17.200] - globals: [2] ‘x’, ‘i’
[10:25:17.200] 
[10:25:17.201] getGlobalsAndPackages() ... DONE
[10:25:17.201] getGlobalsAndPackages() ...
[10:25:17.201] Searching for globals...
[10:25:17.203] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:17.203] Searching for globals ... DONE
[10:25:17.203] Resolving globals: FALSE
[10:25:17.231] The total size of the 2 globals is 793.45 KiB (812496 bytes)
[10:25:17.232] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 793.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (793.40 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:17.232] - globals: [2] ‘x’, ‘i’
[10:25:17.232] 
[10:25:17.232] getGlobalsAndPackages() ... DONE
[10:25:17.232] getGlobalsAndPackages() ...
[10:25:17.233] Searching for globals...
[10:25:17.234] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:17.234] Searching for globals ... DONE
[10:25:17.234] Resolving globals: FALSE
[10:25:17.263] The total size of the 2 globals is 801.80 KiB (821048 bytes)
[10:25:17.263] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 801.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (801.75 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:17.263] - globals: [2] ‘x’, ‘i’
[10:25:17.263] 
[10:25:17.263] getGlobalsAndPackages() ... DONE
[10:25:17.265] getGlobalsAndPackages() ...
[10:25:17.265] Searching for globals...
[10:25:17.266] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:25:17.266] Searching for globals ... DONE
[10:25:17.266] Resolving globals: FALSE
[10:25:17.295] The total size of the 2 globals is 810.16 KiB (829600 bytes)
[10:25:17.296] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 810.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (810.10 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:25:17.296] - globals: [2] ‘x’, ‘i’
[10:25:17.296] 
[10:25:17.296] getGlobalsAndPackages() ... DONE

> ## At this point nothing has been calculated,
> ## because lazy evaluation is in place.
> 
> ## Get the 7:th Fibonnaci numbers (should be 8)
> print(x[[7]])
[10:25:17.297] run() for ‘Future’ ...
[10:25:17.297] - state: ‘created’
[10:25:17.297] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:17.298] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:17.298] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:17.298]   - Field: ‘label’
[10:25:17.298]   - Field: ‘local’
[10:25:17.298]   - Field: ‘owner’
[10:25:17.298]   - Field: ‘envir’
[10:25:17.298]   - Field: ‘packages’
[10:25:17.298]   - Field: ‘gc’
[10:25:17.298]   - Field: ‘conditions’
[10:25:17.299]   - Field: ‘expr’
[10:25:17.299]   - Field: ‘uuid’
[10:25:17.299]   - Field: ‘seed’
[10:25:17.299]   - Field: ‘version’
[10:25:17.299]   - Field: ‘result’
[10:25:17.299]   - Field: ‘asynchronous’
[10:25:17.299]   - Field: ‘calls’
[10:25:17.299]   - Field: ‘globals’
[10:25:17.299]   - Field: ‘stdout’
[10:25:17.299]   - Field: ‘earlySignal’
[10:25:17.299]   - Field: ‘lazy’
[10:25:17.299]   - Field: ‘state’
[10:25:17.300] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:17.300] - Launch lazy future ...
[10:25:17.300] Packages needed by the future expression (n = 0): <none>
[10:25:17.301] Packages needed by future strategies (n = 0): <none>
[10:25:17.301] {
[10:25:17.301]     {
[10:25:17.301]         {
[10:25:17.301]             ...future.startTime <- base::Sys.time()
[10:25:17.301]             {
[10:25:17.301]                 {
[10:25:17.301]                   {
[10:25:17.301]                     base::local({
[10:25:17.301]                       has_future <- base::requireNamespace("future", 
[10:25:17.301]                         quietly = TRUE)
[10:25:17.301]                       if (has_future) {
[10:25:17.301]                         ns <- base::getNamespace("future")
[10:25:17.301]                         version <- ns[[".package"]][["version"]]
[10:25:17.301]                         if (is.null(version)) 
[10:25:17.301]                           version <- utils::packageVersion("future")
[10:25:17.301]                       }
[10:25:17.301]                       else {
[10:25:17.301]                         version <- NULL
[10:25:17.301]                       }
[10:25:17.301]                       if (!has_future || version < "1.8.0") {
[10:25:17.301]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:17.301]                           "", base::R.version$version.string), 
[10:25:17.301]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:17.301]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:17.301]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:17.301]                             "release", "version")], collapse = " "), 
[10:25:17.301]                           hostname = base::Sys.info()[["nodename"]])
[10:25:17.301]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:17.301]                           info)
[10:25:17.301]                         info <- base::paste(info, collapse = "; ")
[10:25:17.301]                         if (!has_future) {
[10:25:17.301]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:17.301]                             info)
[10:25:17.301]                         }
[10:25:17.301]                         else {
[10:25:17.301]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:17.301]                             info, version)
[10:25:17.301]                         }
[10:25:17.301]                         base::stop(msg)
[10:25:17.301]                       }
[10:25:17.301]                     })
[10:25:17.301]                   }
[10:25:17.301]                   options(future.plan = NULL)
[10:25:17.301]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:17.301]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:17.301]                 }
[10:25:17.301]                 ...future.workdir <- getwd()
[10:25:17.301]             }
[10:25:17.301]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:17.301]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:17.301]         }
[10:25:17.301]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:17.301]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:17.301]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:17.301]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:17.301]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:17.301]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:17.301]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:17.301]             base::names(...future.oldOptions))
[10:25:17.301]     }
[10:25:17.301]     if (TRUE) {
[10:25:17.301]     }
[10:25:17.301]     else {
[10:25:17.301]         if (NA) {
[10:25:17.301]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:17.301]                 open = "w")
[10:25:17.301]         }
[10:25:17.301]         else {
[10:25:17.301]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:17.301]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:17.301]         }
[10:25:17.301]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:17.301]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:17.301]             base::sink(type = "output", split = FALSE)
[10:25:17.301]             base::close(...future.stdout)
[10:25:17.301]         }, add = TRUE)
[10:25:17.301]     }
[10:25:17.301]     ...future.frame <- base::sys.nframe()
[10:25:17.301]     ...future.conditions <- base::list()
[10:25:17.301]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:17.301]     if (FALSE) {
[10:25:17.301]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:17.301]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:17.301]     }
[10:25:17.301]     ...future.result <- base::tryCatch({
[10:25:17.301]         base::withCallingHandlers({
[10:25:17.301]             ...future.value <- base::withVisible(base::local({
[10:25:17.301]                 x[[i - 2]] + x[[i - 1]]
[10:25:17.301]             }))
[10:25:17.301]             future::FutureResult(value = ...future.value$value, 
[10:25:17.301]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:17.301]                   ...future.rng), globalenv = if (FALSE) 
[10:25:17.301]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:17.301]                     ...future.globalenv.names))
[10:25:17.301]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:17.301]         }, condition = base::local({
[10:25:17.301]             c <- base::c
[10:25:17.301]             inherits <- base::inherits
[10:25:17.301]             invokeRestart <- base::invokeRestart
[10:25:17.301]             length <- base::length
[10:25:17.301]             list <- base::list
[10:25:17.301]             seq.int <- base::seq.int
[10:25:17.301]             signalCondition <- base::signalCondition
[10:25:17.301]             sys.calls <- base::sys.calls
[10:25:17.301]             `[[` <- base::`[[`
[10:25:17.301]             `+` <- base::`+`
[10:25:17.301]             `<<-` <- base::`<<-`
[10:25:17.301]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:17.301]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:17.301]                   3L)]
[10:25:17.301]             }
[10:25:17.301]             function(cond) {
[10:25:17.301]                 is_error <- inherits(cond, "error")
[10:25:17.301]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:17.301]                   NULL)
[10:25:17.301]                 if (is_error) {
[10:25:17.301]                   sessionInformation <- function() {
[10:25:17.301]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:17.301]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:17.301]                       search = base::search(), system = base::Sys.info())
[10:25:17.301]                   }
[10:25:17.301]                   ...future.conditions[[length(...future.conditions) + 
[10:25:17.301]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:17.301]                     cond$call), session = sessionInformation(), 
[10:25:17.301]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:17.301]                   signalCondition(cond)
[10:25:17.301]                 }
[10:25:17.301]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[10:25:17.301]                 "immediateCondition"))) {
[10:25:17.301]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:17.301]                   ...future.conditions[[length(...future.conditions) + 
[10:25:17.301]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:17.301]                   if (TRUE && !signal) {
[10:25:17.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:17.301]                     {
[10:25:17.301]                       inherits <- base::inherits
[10:25:17.301]                       invokeRestart <- base::invokeRestart
[10:25:17.301]                       is.null <- base::is.null
[10:25:17.301]                       muffled <- FALSE
[10:25:17.301]                       if (inherits(cond, "message")) {
[10:25:17.301]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:17.301]                         if (muffled) 
[10:25:17.301]                           invokeRestart("muffleMessage")
[10:25:17.301]                       }
[10:25:17.301]                       else if (inherits(cond, "warning")) {
[10:25:17.301]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:17.301]                         if (muffled) 
[10:25:17.301]                           invokeRestart("muffleWarning")
[10:25:17.301]                       }
[10:25:17.301]                       else if (inherits(cond, "condition")) {
[10:25:17.301]                         if (!is.null(pattern)) {
[10:25:17.301]                           computeRestarts <- base::computeRestarts
[10:25:17.301]                           grepl <- base::grepl
[10:25:17.301]                           restarts <- computeRestarts(cond)
[10:25:17.301]                           for (restart in restarts) {
[10:25:17.301]                             name <- restart$name
[10:25:17.301]                             if (is.null(name)) 
[10:25:17.301]                               next
[10:25:17.301]                             if (!grepl(pattern, name)) 
[10:25:17.301]                               next
[10:25:17.301]                             invokeRestart(restart)
[10:25:17.301]                             muffled <- TRUE
[10:25:17.301]                             break
[10:25:17.301]                           }
[10:25:17.301]                         }
[10:25:17.301]                       }
[10:25:17.301]                       invisible(muffled)
[10:25:17.301]                     }
[10:25:17.301]                     muffleCondition(cond, pattern = "^muffle")
[10:25:17.301]                   }
[10:25:17.301]                 }
[10:25:17.301]                 else {
[10:25:17.301]                   if (TRUE) {
[10:25:17.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:17.301]                     {
[10:25:17.301]                       inherits <- base::inherits
[10:25:17.301]                       invokeRestart <- base::invokeRestart
[10:25:17.301]                       is.null <- base::is.null
[10:25:17.301]                       muffled <- FALSE
[10:25:17.301]                       if (inherits(cond, "message")) {
[10:25:17.301]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:17.301]                         if (muffled) 
[10:25:17.301]                           invokeRestart("muffleMessage")
[10:25:17.301]                       }
[10:25:17.301]                       else if (inherits(cond, "warning")) {
[10:25:17.301]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:17.301]                         if (muffled) 
[10:25:17.301]                           invokeRestart("muffleWarning")
[10:25:17.301]                       }
[10:25:17.301]                       else if (inherits(cond, "condition")) {
[10:25:17.301]                         if (!is.null(pattern)) {
[10:25:17.301]                           computeRestarts <- base::computeRestarts
[10:25:17.301]                           grepl <- base::grepl
[10:25:17.301]                           restarts <- computeRestarts(cond)
[10:25:17.301]                           for (restart in restarts) {
[10:25:17.301]                             name <- restart$name
[10:25:17.301]                             if (is.null(name)) 
[10:25:17.301]                               next
[10:25:17.301]                             if (!grepl(pattern, name)) 
[10:25:17.301]                               next
[10:25:17.301]                             invokeRestart(restart)
[10:25:17.301]                             muffled <- TRUE
[10:25:17.301]                             break
[10:25:17.301]                           }
[10:25:17.301]                         }
[10:25:17.301]                       }
[10:25:17.301]                       invisible(muffled)
[10:25:17.301]                     }
[10:25:17.301]                     muffleCondition(cond, pattern = "^muffle")
[10:25:17.301]                   }
[10:25:17.301]                 }
[10:25:17.301]             }
[10:25:17.301]         }))
[10:25:17.301]     }, error = function(ex) {
[10:25:17.301]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:17.301]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:17.301]                 ...future.rng), started = ...future.startTime, 
[10:25:17.301]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:17.301]             version = "1.8"), class = "FutureResult")
[10:25:17.301]     }, finally = {
[10:25:17.301]         if (!identical(...future.workdir, getwd())) 
[10:25:17.301]             setwd(...future.workdir)
[10:25:17.301]         {
[10:25:17.301]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:17.301]                 ...future.oldOptions$nwarnings <- NULL
[10:25:17.301]             }
[10:25:17.301]             base::options(...future.oldOptions)
[10:25:17.301]             if (.Platform$OS.type == "windows") {
[10:25:17.301]                 old_names <- names(...future.oldEnvVars)
[10:25:17.301]                 envs <- base::Sys.getenv()
[10:25:17.301]                 names <- names(envs)
[10:25:17.301]                 common <- intersect(names, old_names)
[10:25:17.301]                 added <- setdiff(names, old_names)
[10:25:17.301]                 removed <- setdiff(old_names, names)
[10:25:17.301]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:17.301]                   envs[common]]
[10:25:17.301]                 NAMES <- toupper(changed)
[10:25:17.301]                 args <- list()
[10:25:17.301]                 for (kk in seq_along(NAMES)) {
[10:25:17.301]                   name <- changed[[kk]]
[10:25:17.301]                   NAME <- NAMES[[kk]]
[10:25:17.301]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:17.301]                     next
[10:25:17.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:17.301]                 }
[10:25:17.301]                 NAMES <- toupper(added)
[10:25:17.301]                 for (kk in seq_along(NAMES)) {
[10:25:17.301]                   name <- added[[kk]]
[10:25:17.301]                   NAME <- NAMES[[kk]]
[10:25:17.301]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:17.301]                     next
[10:25:17.301]                   args[[name]] <- ""
[10:25:17.301]                 }
[10:25:17.301]                 NAMES <- toupper(removed)
[10:25:17.301]                 for (kk in seq_along(NAMES)) {
[10:25:17.301]                   name <- removed[[kk]]
[10:25:17.301]                   NAME <- NAMES[[kk]]
[10:25:17.301]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:17.301]                     next
[10:25:17.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:17.301]                 }
[10:25:17.301]                 if (length(args) > 0) 
[10:25:17.301]                   base::do.call(base::Sys.setenv, args = args)
[10:25:17.301]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:17.301]             }
[10:25:17.301]             else {
[10:25:17.301]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:17.301]             }
[10:25:17.301]             {
[10:25:17.301]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:17.301]                   0L) {
[10:25:17.301]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:17.301]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:17.301]                   base::options(opts)
[10:25:17.301]                 }
[10:25:17.301]                 {
[10:25:17.301]                   {
[10:25:17.301]                     NULL
[10:25:17.301]                     RNGkind("Mersenne-Twister")
[10:25:17.301]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:17.301]                       inherits = FALSE)
[10:25:17.301]                   }
[10:25:17.301]                   options(future.plan = NULL)
[10:25:17.301]                   if (is.na(NA_character_)) 
[10:25:17.301]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:17.301]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:17.301]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:17.301]                   {
[10:25:17.301]                     future <- SequentialFuture(..., envir = envir)
[10:25:17.301]                     if (!future$lazy) 
[10:25:17.301]                       future <- run(future)
[10:25:17.301]                     invisible(future)
[10:25:17.301]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:17.301]                 }
[10:25:17.301]             }
[10:25:17.301]         }
[10:25:17.301]     })
[10:25:17.301]     if (FALSE) {
[10:25:17.301]         base::sink(type = "output", split = FALSE)
[10:25:17.301]         if (NA) {
[10:25:17.301]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:17.301]         }
[10:25:17.301]         else {
[10:25:17.301]             ...future.result["stdout"] <- base::list(NULL)
[10:25:17.301]         }
[10:25:17.301]         base::close(...future.stdout)
[10:25:17.301]         ...future.stdout <- NULL
[10:25:17.301]     }
[10:25:17.301]     ...future.result$conditions <- ...future.conditions
[10:25:17.301]     ...future.result$finished <- base::Sys.time()
[10:25:17.301]     ...future.result
[10:25:17.301] }
[10:25:17.303] assign_globals() ...
[10:25:17.303] List of 2
[10:25:17.303]  $ x:Classes 'listenv', 'environment' <environment: 0x563911c54760> 
[10:25:17.303]  $ i: int 7
[10:25:17.303]  - attr(*, "where")=List of 2
[10:25:17.303]   ..$ x:<environment: R_EmptyEnv> 
[10:25:17.303]   ..$ i:<environment: R_EmptyEnv> 
[10:25:17.303]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:17.303]  - attr(*, "resolved")= logi FALSE
[10:25:17.303]  - attr(*, "total_size")= num 34264
[10:25:17.303]  - attr(*, "already-done")= logi TRUE
[10:25:17.309] - copied ‘x’ to environment
[10:25:17.309] - copied ‘i’ to environment
[10:25:17.309] assign_globals() ... done
[10:25:17.309] plan(): Setting new future strategy stack:
[10:25:17.309] List of future strategies:
[10:25:17.309] 1. sequential:
[10:25:17.309]    - args: function (..., envir = parent.frame())
[10:25:17.309]    - tweaked: FALSE
[10:25:17.309]    - call: NULL
[10:25:17.310] plan(): nbrOfWorkers() = 1
[10:25:17.384] plan(): Setting new future strategy stack:
[10:25:17.384] List of future strategies:
[10:25:17.384] 1. sequential:
[10:25:17.384]    - args: function (..., envir = parent.frame())
[10:25:17.384]    - tweaked: FALSE
[10:25:17.384]    - call: plan(sequential)
[10:25:17.384] plan(): nbrOfWorkers() = 1
[10:25:17.385] SequentialFuture started (and completed)
[10:25:17.385] - Launch lazy future ... done
[10:25:17.385] run() for ‘SequentialFuture’ ... done
[1] 8

> ## At this point x[1:7] have been calculated,
> ## but nothing beyond.
> 
> ## Let's get the 50:th number.
> print(x[[50]])
[10:25:17.385] run() for ‘Future’ ...
[10:25:17.385] - state: ‘created’
[10:25:17.385] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:17.386] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:17.386] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:17.386]   - Field: ‘label’
[10:25:17.386]   - Field: ‘local’
[10:25:17.386]   - Field: ‘owner’
[10:25:17.386]   - Field: ‘envir’
[10:25:17.386]   - Field: ‘packages’
[10:25:17.386]   - Field: ‘gc’
[10:25:17.386]   - Field: ‘conditions’
[10:25:17.386]   - Field: ‘expr’
[10:25:17.387]   - Field: ‘uuid’
[10:25:17.387]   - Field: ‘seed’
[10:25:17.387]   - Field: ‘version’
[10:25:17.387]   - Field: ‘result’
[10:25:17.387]   - Field: ‘asynchronous’
[10:25:17.387]   - Field: ‘calls’
[10:25:17.387]   - Field: ‘globals’
[10:25:17.387]   - Field: ‘stdout’
[10:25:17.387]   - Field: ‘earlySignal’
[10:25:17.387]   - Field: ‘lazy’
[10:25:17.387]   - Field: ‘state’
[10:25:17.388] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:17.388] - Launch lazy future ...
[10:25:17.388] Packages needed by the future expression (n = 0): <none>
[10:25:17.388] Packages needed by future strategies (n = 0): <none>
[10:25:17.388] {
[10:25:17.388]     {
[10:25:17.388]         {
[10:25:17.388]             ...future.startTime <- base::Sys.time()
[10:25:17.388]             {
[10:25:17.388]                 {
[10:25:17.388]                   {
[10:25:17.388]                     base::local({
[10:25:17.388]                       has_future <- base::requireNamespace("future", 
[10:25:17.388]                         quietly = TRUE)
[10:25:17.388]                       if (has_future) {
[10:25:17.388]                         ns <- base::getNamespace("future")
[10:25:17.388]                         version <- ns[[".package"]][["version"]]
[10:25:17.388]                         if (is.null(version)) 
[10:25:17.388]                           version <- utils::packageVersion("future")
[10:25:17.388]                       }
[10:25:17.388]                       else {
[10:25:17.388]                         version <- NULL
[10:25:17.388]                       }
[10:25:17.388]                       if (!has_future || version < "1.8.0") {
[10:25:17.388]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:17.388]                           "", base::R.version$version.string), 
[10:25:17.388]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:17.388]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:17.388]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:17.388]                             "release", "version")], collapse = " "), 
[10:25:17.388]                           hostname = base::Sys.info()[["nodename"]])
[10:25:17.388]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:17.388]                           info)
[10:25:17.388]                         info <- base::paste(info, collapse = "; ")
[10:25:17.388]                         if (!has_future) {
[10:25:17.388]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:17.388]                             info)
[10:25:17.388]                         }
[10:25:17.388]                         else {
[10:25:17.388]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:17.388]                             info, version)
[10:25:17.388]                         }
[10:25:17.388]                         base::stop(msg)
[10:25:17.388]                       }
[10:25:17.388]                     })
[10:25:17.388]                   }
[10:25:17.388]                   options(future.plan = NULL)
[10:25:17.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:17.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:17.388]                 }
[10:25:17.388]                 ...future.workdir <- getwd()
[10:25:17.388]             }
[10:25:17.388]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:17.388]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:17.388]         }
[10:25:17.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:17.388]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:17.388]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:17.388]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:17.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:17.388]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:17.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:17.388]             base::names(...future.oldOptions))
[10:25:17.388]     }
[10:25:17.388]     if (TRUE) {
[10:25:17.388]     }
[10:25:17.388]     else {
[10:25:17.388]         if (NA) {
[10:25:17.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:17.388]                 open = "w")
[10:25:17.388]         }
[10:25:17.388]         else {
[10:25:17.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:17.388]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:17.388]         }
[10:25:17.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:17.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:17.388]             base::sink(type = "output", split = FALSE)
[10:25:17.388]             base::close(...future.stdout)
[10:25:17.388]         }, add = TRUE)
[10:25:17.388]     }
[10:25:17.388]     ...future.frame <- base::sys.nframe()
[10:25:17.388]     ...future.conditions <- base::list()
[10:25:17.388]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:17.388]     if (FALSE) {
[10:25:17.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:17.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:17.388]     }
[10:25:17.388]     ...future.result <- base::tryCatch({
[10:25:17.388]         base::withCallingHandlers({
[10:25:17.388]             ...future.value <- base::withVisible(base::local({
[10:25:17.388]                 x[[i - 2]] + x[[i - 1]]
[10:25:17.388]             }))
[10:25:17.388]             future::FutureResult(value = ...future.value$value, 
[10:25:17.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:17.388]                   ...future.rng), globalenv = if (FALSE) 
[10:25:17.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:17.388]                     ...future.globalenv.names))
[10:25:17.388]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:17.388]         }, condition = base::local({
[10:25:17.388]             c <- base::c
[10:25:17.388]             inherits <- base::inherits
[10:25:17.388]             invokeRestart <- base::invokeRestart
[10:25:17.388]             length <- base::length
[10:25:17.388]             list <- base::list
[10:25:17.388]             seq.int <- base::seq.int
[10:25:17.388]             signalCondition <- base::signalCondition
[10:25:17.388]             sys.calls <- base::sys.calls
[10:25:17.388]             `[[` <- base::`[[`
[10:25:17.388]             `+` <- base::`+`
[10:25:17.388]             `<<-` <- base::`<<-`
[10:25:17.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:17.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:17.388]                   3L)]
[10:25:17.388]             }
[10:25:17.388]             function(cond) {
[10:25:17.388]                 is_error <- inherits(cond, "error")
[10:25:17.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:17.388]                   NULL)
[10:25:17.388]                 if (is_error) {
[10:25:17.388]                   sessionInformation <- function() {
[10:25:17.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:17.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:17.388]                       search = base::search(), system = base::Sys.info())
[10:25:17.388]                   }
[10:25:17.388]                   ...future.conditions[[length(...future.conditions) + 
[10:25:17.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:17.388]                     cond$call), session = sessionInformation(), 
[10:25:17.388]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:17.388]                   signalCondition(cond)
[10:25:17.388]                 }
[10:25:17.388]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[10:25:17.388]                 "immediateCondition"))) {
[10:25:17.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:17.388]                   ...future.conditions[[length(...future.conditions) + 
[10:25:17.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:17.388]                   if (TRUE && !signal) {
[10:25:17.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:17.388]                     {
[10:25:17.388]                       inherits <- base::inherits
[10:25:17.388]                       invokeRestart <- base::invokeRestart
[10:25:17.388]                       is.null <- base::is.null
[10:25:17.388]                       muffled <- FALSE
[10:25:17.388]                       if (inherits(cond, "message")) {
[10:25:17.388]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:17.388]                         if (muffled) 
[10:25:17.388]                           invokeRestart("muffleMessage")
[10:25:17.388]                       }
[10:25:17.388]                       else if (inherits(cond, "warning")) {
[10:25:17.388]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:17.388]                         if (muffled) 
[10:25:17.388]                           invokeRestart("muffleWarning")
[10:25:17.388]                       }
[10:25:17.388]                       else if (inherits(cond, "condition")) {
[10:25:17.388]                         if (!is.null(pattern)) {
[10:25:17.388]                           computeRestarts <- base::computeRestarts
[10:25:17.388]                           grepl <- base::grepl
[10:25:17.388]                           restarts <- computeRestarts(cond)
[10:25:17.388]                           for (restart in restarts) {
[10:25:17.388]                             name <- restart$name
[10:25:17.388]                             if (is.null(name)) 
[10:25:17.388]                               next
[10:25:17.388]                             if (!grepl(pattern, name)) 
[10:25:17.388]                               next
[10:25:17.388]                             invokeRestart(restart)
[10:25:17.388]                             muffled <- TRUE
[10:25:17.388]                             break
[10:25:17.388]                           }
[10:25:17.388]                         }
[10:25:17.388]                       }
[10:25:17.388]                       invisible(muffled)
[10:25:17.388]                     }
[10:25:17.388]                     muffleCondition(cond, pattern = "^muffle")
[10:25:17.388]                   }
[10:25:17.388]                 }
[10:25:17.388]                 else {
[10:25:17.388]                   if (TRUE) {
[10:25:17.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:17.388]                     {
[10:25:17.388]                       inherits <- base::inherits
[10:25:17.388]                       invokeRestart <- base::invokeRestart
[10:25:17.388]                       is.null <- base::is.null
[10:25:17.388]                       muffled <- FALSE
[10:25:17.388]                       if (inherits(cond, "message")) {
[10:25:17.388]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:17.388]                         if (muffled) 
[10:25:17.388]                           invokeRestart("muffleMessage")
[10:25:17.388]                       }
[10:25:17.388]                       else if (inherits(cond, "warning")) {
[10:25:17.388]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:17.388]                         if (muffled) 
[10:25:17.388]                           invokeRestart("muffleWarning")
[10:25:17.388]                       }
[10:25:17.388]                       else if (inherits(cond, "condition")) {
[10:25:17.388]                         if (!is.null(pattern)) {
[10:25:17.388]                           computeRestarts <- base::computeRestarts
[10:25:17.388]                           grepl <- base::grepl
[10:25:17.388]                           restarts <- computeRestarts(cond)
[10:25:17.388]                           for (restart in restarts) {
[10:25:17.388]                             name <- restart$name
[10:25:17.388]                             if (is.null(name)) 
[10:25:17.388]                               next
[10:25:17.388]                             if (!grepl(pattern, name)) 
[10:25:17.388]                               next
[10:25:17.388]                             invokeRestart(restart)
[10:25:17.388]                             muffled <- TRUE
[10:25:17.388]                             break
[10:25:17.388]                           }
[10:25:17.388]                         }
[10:25:17.388]                       }
[10:25:17.388]                       invisible(muffled)
[10:25:17.388]                     }
[10:25:17.388]                     muffleCondition(cond, pattern = "^muffle")
[10:25:17.388]                   }
[10:25:17.388]                 }
[10:25:17.388]             }
[10:25:17.388]         }))
[10:25:17.388]     }, error = function(ex) {
[10:25:17.388]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:17.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:17.388]                 ...future.rng), started = ...future.startTime, 
[10:25:17.388]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:17.388]             version = "1.8"), class = "FutureResult")
[10:25:17.388]     }, finally = {
[10:25:17.388]         if (!identical(...future.workdir, getwd())) 
[10:25:17.388]             setwd(...future.workdir)
[10:25:17.388]         {
[10:25:17.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:17.388]                 ...future.oldOptions$nwarnings <- NULL
[10:25:17.388]             }
[10:25:17.388]             base::options(...future.oldOptions)
[10:25:17.388]             if (.Platform$OS.type == "windows") {
[10:25:17.388]                 old_names <- names(...future.oldEnvVars)
[10:25:17.388]                 envs <- base::Sys.getenv()
[10:25:17.388]                 names <- names(envs)
[10:25:17.388]                 common <- intersect(names, old_names)
[10:25:17.388]                 added <- setdiff(names, old_names)
[10:25:17.388]                 removed <- setdiff(old_names, names)
[10:25:17.388]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:17.388]                   envs[common]]
[10:25:17.388]                 NAMES <- toupper(changed)
[10:25:17.388]                 args <- list()
[10:25:17.388]                 for (kk in seq_along(NAMES)) {
[10:25:17.388]                   name <- changed[[kk]]
[10:25:17.388]                   NAME <- NAMES[[kk]]
[10:25:17.388]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:17.388]                     next
[10:25:17.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:17.388]                 }
[10:25:17.388]                 NAMES <- toupper(added)
[10:25:17.388]                 for (kk in seq_along(NAMES)) {
[10:25:17.388]                   name <- added[[kk]]
[10:25:17.388]                   NAME <- NAMES[[kk]]
[10:25:17.388]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:17.388]                     next
[10:25:17.388]                   args[[name]] <- ""
[10:25:17.388]                 }
[10:25:17.388]                 NAMES <- toupper(removed)
[10:25:17.388]                 for (kk in seq_along(NAMES)) {
[10:25:17.388]                   name <- removed[[kk]]
[10:25:17.388]                   NAME <- NAMES[[kk]]
[10:25:17.388]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:17.388]                     next
[10:25:17.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:17.388]                 }
[10:25:17.388]                 if (length(args) > 0) 
[10:25:17.388]                   base::do.call(base::Sys.setenv, args = args)
[10:25:17.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:17.388]             }
[10:25:17.388]             else {
[10:25:17.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:17.388]             }
[10:25:17.388]             {
[10:25:17.388]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:17.388]                   0L) {
[10:25:17.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:17.388]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:17.388]                   base::options(opts)
[10:25:17.388]                 }
[10:25:17.388]                 {
[10:25:17.388]                   {
[10:25:17.388]                     NULL
[10:25:17.388]                     RNGkind("Mersenne-Twister")
[10:25:17.388]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:17.388]                       inherits = FALSE)
[10:25:17.388]                   }
[10:25:17.388]                   options(future.plan = NULL)
[10:25:17.388]                   if (is.na(NA_character_)) 
[10:25:17.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:17.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:17.388]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:17.388]                   {
[10:25:17.388]                     future <- SequentialFuture(..., envir = envir)
[10:25:17.388]                     if (!future$lazy) 
[10:25:17.388]                       future <- run(future)
[10:25:17.388]                     invisible(future)
[10:25:17.388]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:17.388]                 }
[10:25:17.388]             }
[10:25:17.388]         }
[10:25:17.388]     })
[10:25:17.388]     if (FALSE) {
[10:25:17.388]         base::sink(type = "output", split = FALSE)
[10:25:17.388]         if (NA) {
[10:25:17.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:17.388]         }
[10:25:17.388]         else {
[10:25:17.388]             ...future.result["stdout"] <- base::list(NULL)
[10:25:17.388]         }
[10:25:17.388]         base::close(...future.stdout)
[10:25:17.388]         ...future.stdout <- NULL
[10:25:17.388]     }
[10:25:17.388]     ...future.result$conditions <- ...future.conditions
[10:25:17.388]     ...future.result$finished <- base::Sys.time()
[10:25:17.388]     ...future.result
[10:25:17.388] }
[10:25:17.390] assign_globals() ...
[10:25:17.390] List of 2
[10:25:17.390]  $ x:Classes 'listenv', 'environment' <environment: 0x563911c54760> 
[10:25:17.390]  $ i: int 50
[10:25:17.390]  - attr(*, "where")=List of 2
[10:25:17.390]   ..$ x:<environment: R_EmptyEnv> 
[10:25:17.390]   ..$ i:<environment: R_EmptyEnv> 
[10:25:17.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:17.390]  - attr(*, "resolved")= logi FALSE
[10:25:17.390]  - attr(*, "total_size")= num 402000
[10:25:17.390]  - attr(*, "already-done")= logi TRUE
[10:25:17.393] - copied ‘x’ to environment
[10:25:17.393] - copied ‘i’ to environment
[10:25:17.393] assign_globals() ... done
[10:25:17.393] plan(): Setting new future strategy stack:
[10:25:17.393] List of future strategies:
[10:25:17.393] 1. sequential:
[10:25:17.393]    - args: function (..., envir = parent.frame())
[10:25:17.393]    - tweaked: FALSE
[10:25:17.393]    - call: NULL
[10:25:17.394] plan(): nbrOfWorkers() = 1
[10:25:18.243] plan(): Setting new future strategy stack:
[10:25:18.243] List of future strategies:
[10:25:18.243] 1. sequential:
[10:25:18.243]    - args: function (..., envir = parent.frame())
[10:25:18.243]    - tweaked: FALSE
[10:25:18.243]    - call: plan(sequential)
[10:25:18.244] plan(): nbrOfWorkers() = 1
[10:25:18.244] SequentialFuture started (and completed)
[10:25:18.244] - Launch lazy future ... done
[10:25:18.244] run() for ‘SequentialFuture’ ... done
[1] 7778742049

> ## Reset plan
> plan(oplan)
[10:25:18.245] plan(): Setting new future strategy stack:
[10:25:18.245] List of future strategies:
[10:25:18.245] 1. sequential:
[10:25:18.245]    - args: function (..., envir = parent.frame())
[10:25:18.245]    - tweaked: FALSE
[10:25:18.245]    - call: future::plan("sequential")
[10:25:18.245] plan(): nbrOfWorkers() = 1
> message("*** Fibonacci demo of the 'future' package ... DONE")
*** Fibonacci demo of the 'future' package ... DONE
> 
> 
> message("*** Mandelbrot demo of the 'future' package ...")
*** Mandelbrot demo of the 'future' package ...
> if (getRversion() >= "3.2.0" && !isWin32) {
+   options(future.demo.mandelbrot.nrow = 2L)
+   options(future.demo.mandelbrot.resolution = 50L)
+   options(future.demo.mandelbrot.delay = FALSE)
+   
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+   
+     for (strategy in supportedStrategies(cores)) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+       demo("mandelbrot", package = "future", ask = FALSE)
+       message(sprintf("- plan('%s') ... DONE", strategy))
+     }
+   
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } else {
+   message(" - This demo requires R (>= 3.2.0). Skipping test. (Skipping also on Win32 i386 for speed)")
+ }
Testing with 1 cores ...
- plan('sequential') ...
[10:25:18.252] plan(): Setting new future strategy stack:
[10:25:18.252] List of future strategies:
[10:25:18.252] 1. sequential:
[10:25:18.252]    - args: function (..., envir = parent.frame())
[10:25:18.252]    - tweaked: FALSE
[10:25:18.252]    - call: plan(strategy)
[10:25:18.252] plan(): nbrOfWorkers() = 1


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 1 2 3 4

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[10:25:18.286] getGlobalsAndPackages() ...
[10:25:18.286] Searching for globals...
[10:25:18.291] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:25:18.291] Searching for globals ... DONE
[10:25:18.291] Resolving globals: FALSE
[10:25:18.292] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:25:18.292] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:25:18.292] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:25:18.293] - packages: [1] ‘future’
[10:25:18.293] getGlobalsAndPackages() ... DONE
 2[10:25:18.301] getGlobalsAndPackages() ...
[10:25:18.301] Searching for globals...
[10:25:18.304] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:25:18.305] Searching for globals ... DONE
[10:25:18.305] Resolving globals: FALSE
[10:25:18.305] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:25:18.306] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:25:18.306] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:25:18.306] - packages: [1] ‘future’
[10:25:18.306] getGlobalsAndPackages() ... DONE
 3[10:25:18.306] getGlobalsAndPackages() ...
[10:25:18.307] Searching for globals...
[10:25:18.310] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:25:18.310] Searching for globals ... DONE
[10:25:18.310] Resolving globals: FALSE
[10:25:18.311] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:25:18.311] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:25:18.311] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:25:18.311] - packages: [1] ‘future’
[10:25:18.312] getGlobalsAndPackages() ... DONE
 4[10:25:18.312] getGlobalsAndPackages() ...
[10:25:18.312] Searching for globals...
[10:25:18.315] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:25:18.316] Searching for globals ... DONE
[10:25:18.316] Resolving globals: FALSE
[10:25:18.316] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:25:18.317] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:25:18.317] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:25:18.317] - packages: [1] ‘future’
[10:25:18.317] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[10:25:18.326] resolved() for ‘Future’ ...
[10:25:18.326] - state: ‘created’
[10:25:18.327] - run: TRUE
[10:25:18.327] - run() ...
[10:25:18.327] run() for ‘Future’ ...
[10:25:18.327] - state: ‘created’
[10:25:18.327] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:18.327] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:18.327] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:18.328]   - Field: ‘label’
[10:25:18.328]   - Field: ‘local’
[10:25:18.328]   - Field: ‘owner’
[10:25:18.328]   - Field: ‘envir’
[10:25:18.328]   - Field: ‘packages’
[10:25:18.328]   - Field: ‘gc’
[10:25:18.328]   - Field: ‘conditions’
[10:25:18.328]   - Field: ‘expr’
[10:25:18.328]   - Field: ‘uuid’
[10:25:18.328]   - Field: ‘seed’
[10:25:18.329]   - Field: ‘version’
[10:25:18.329]   - Field: ‘result’
[10:25:18.329]   - Field: ‘asynchronous’
[10:25:18.329]   - Field: ‘calls’
[10:25:18.329]   - Field: ‘globals’
[10:25:18.329]   - Field: ‘stdout’
[10:25:18.329]   - Field: ‘earlySignal’
[10:25:18.329]   - Field: ‘lazy’
[10:25:18.329]   - Field: ‘state’
[10:25:18.329] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:18.330] - Launch lazy future ...
[10:25:18.330] Packages needed by the future expression (n = 1): ‘future’
[10:25:18.330] Packages needed by future strategies (n = 0): <none>
[10:25:18.330] {
[10:25:18.330]     {
[10:25:18.330]         {
[10:25:18.330]             ...future.startTime <- base::Sys.time()
[10:25:18.330]             {
[10:25:18.330]                 {
[10:25:18.330]                   {
[10:25:18.330]                     {
[10:25:18.330]                       base::local({
[10:25:18.330]                         has_future <- base::requireNamespace("future", 
[10:25:18.330]                           quietly = TRUE)
[10:25:18.330]                         if (has_future) {
[10:25:18.330]                           ns <- base::getNamespace("future")
[10:25:18.330]                           version <- ns[[".package"]][["version"]]
[10:25:18.330]                           if (is.null(version)) 
[10:25:18.330]                             version <- utils::packageVersion("future")
[10:25:18.330]                         }
[10:25:18.330]                         else {
[10:25:18.330]                           version <- NULL
[10:25:18.330]                         }
[10:25:18.330]                         if (!has_future || version < "1.8.0") {
[10:25:18.330]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:18.330]                             "", base::R.version$version.string), 
[10:25:18.330]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:18.330]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:18.330]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:18.330]                               "release", "version")], collapse = " "), 
[10:25:18.330]                             hostname = base::Sys.info()[["nodename"]])
[10:25:18.330]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:18.330]                             info)
[10:25:18.330]                           info <- base::paste(info, collapse = "; ")
[10:25:18.330]                           if (!has_future) {
[10:25:18.330]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:18.330]                               info)
[10:25:18.330]                           }
[10:25:18.330]                           else {
[10:25:18.330]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:18.330]                               info, version)
[10:25:18.330]                           }
[10:25:18.330]                           base::stop(msg)
[10:25:18.330]                         }
[10:25:18.330]                       })
[10:25:18.330]                     }
[10:25:18.330]                     base::local({
[10:25:18.330]                       for (pkg in "future") {
[10:25:18.330]                         base::loadNamespace(pkg)
[10:25:18.330]                         base::library(pkg, character.only = TRUE)
[10:25:18.330]                       }
[10:25:18.330]                     })
[10:25:18.330]                   }
[10:25:18.330]                   options(future.plan = NULL)
[10:25:18.330]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.330]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:18.330]                 }
[10:25:18.330]                 ...future.workdir <- getwd()
[10:25:18.330]             }
[10:25:18.330]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:18.330]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:18.330]         }
[10:25:18.330]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:18.330]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:18.330]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:18.330]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:18.330]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:18.330]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:18.330]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:18.330]             base::names(...future.oldOptions))
[10:25:18.330]     }
[10:25:18.330]     if (FALSE) {
[10:25:18.330]     }
[10:25:18.330]     else {
[10:25:18.330]         if (TRUE) {
[10:25:18.330]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:18.330]                 open = "w")
[10:25:18.330]         }
[10:25:18.330]         else {
[10:25:18.330]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:18.330]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:18.330]         }
[10:25:18.330]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:18.330]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:18.330]             base::sink(type = "output", split = FALSE)
[10:25:18.330]             base::close(...future.stdout)
[10:25:18.330]         }, add = TRUE)
[10:25:18.330]     }
[10:25:18.330]     ...future.frame <- base::sys.nframe()
[10:25:18.330]     ...future.conditions <- base::list()
[10:25:18.330]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:18.330]     if (FALSE) {
[10:25:18.330]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:18.330]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:18.330]     }
[10:25:18.330]     ...future.result <- base::tryCatch({
[10:25:18.330]         base::withCallingHandlers({
[10:25:18.330]             ...future.value <- base::withVisible(base::local({
[10:25:18.330]                 message(sprintf("Calculating tile #%d of %d ...", 
[10:25:18.330]                   ii, n), appendLF = FALSE)
[10:25:18.330]                 fit <- mandelbrot(C)
[10:25:18.330]                 delay(fit)
[10:25:18.330]                 message(" done")
[10:25:18.330]                 fit
[10:25:18.330]             }))
[10:25:18.330]             future::FutureResult(value = ...future.value$value, 
[10:25:18.330]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.330]                   ...future.rng), globalenv = if (FALSE) 
[10:25:18.330]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:18.330]                     ...future.globalenv.names))
[10:25:18.330]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:18.330]         }, condition = base::local({
[10:25:18.330]             c <- base::c
[10:25:18.330]             inherits <- base::inherits
[10:25:18.330]             invokeRestart <- base::invokeRestart
[10:25:18.330]             length <- base::length
[10:25:18.330]             list <- base::list
[10:25:18.330]             seq.int <- base::seq.int
[10:25:18.330]             signalCondition <- base::signalCondition
[10:25:18.330]             sys.calls <- base::sys.calls
[10:25:18.330]             `[[` <- base::`[[`
[10:25:18.330]             `+` <- base::`+`
[10:25:18.330]             `<<-` <- base::`<<-`
[10:25:18.330]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:18.330]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:18.330]                   3L)]
[10:25:18.330]             }
[10:25:18.330]             function(cond) {
[10:25:18.330]                 is_error <- inherits(cond, "error")
[10:25:18.330]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:18.330]                   NULL)
[10:25:18.330]                 if (is_error) {
[10:25:18.330]                   sessionInformation <- function() {
[10:25:18.330]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:18.330]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:18.330]                       search = base::search(), system = base::Sys.info())
[10:25:18.330]                   }
[10:25:18.330]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.330]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:18.330]                     cond$call), session = sessionInformation(), 
[10:25:18.330]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:18.330]                   signalCondition(cond)
[10:25:18.330]                 }
[10:25:18.330]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:18.330]                 "immediateCondition"))) {
[10:25:18.330]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:18.330]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.330]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:18.330]                   if (TRUE && !signal) {
[10:25:18.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.330]                     {
[10:25:18.330]                       inherits <- base::inherits
[10:25:18.330]                       invokeRestart <- base::invokeRestart
[10:25:18.330]                       is.null <- base::is.null
[10:25:18.330]                       muffled <- FALSE
[10:25:18.330]                       if (inherits(cond, "message")) {
[10:25:18.330]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.330]                         if (muffled) 
[10:25:18.330]                           invokeRestart("muffleMessage")
[10:25:18.330]                       }
[10:25:18.330]                       else if (inherits(cond, "warning")) {
[10:25:18.330]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.330]                         if (muffled) 
[10:25:18.330]                           invokeRestart("muffleWarning")
[10:25:18.330]                       }
[10:25:18.330]                       else if (inherits(cond, "condition")) {
[10:25:18.330]                         if (!is.null(pattern)) {
[10:25:18.330]                           computeRestarts <- base::computeRestarts
[10:25:18.330]                           grepl <- base::grepl
[10:25:18.330]                           restarts <- computeRestarts(cond)
[10:25:18.330]                           for (restart in restarts) {
[10:25:18.330]                             name <- restart$name
[10:25:18.330]                             if (is.null(name)) 
[10:25:18.330]                               next
[10:25:18.330]                             if (!grepl(pattern, name)) 
[10:25:18.330]                               next
[10:25:18.330]                             invokeRestart(restart)
[10:25:18.330]                             muffled <- TRUE
[10:25:18.330]                             break
[10:25:18.330]                           }
[10:25:18.330]                         }
[10:25:18.330]                       }
[10:25:18.330]                       invisible(muffled)
[10:25:18.330]                     }
[10:25:18.330]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.330]                   }
[10:25:18.330]                 }
[10:25:18.330]                 else {
[10:25:18.330]                   if (TRUE) {
[10:25:18.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.330]                     {
[10:25:18.330]                       inherits <- base::inherits
[10:25:18.330]                       invokeRestart <- base::invokeRestart
[10:25:18.330]                       is.null <- base::is.null
[10:25:18.330]                       muffled <- FALSE
[10:25:18.330]                       if (inherits(cond, "message")) {
[10:25:18.330]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.330]                         if (muffled) 
[10:25:18.330]                           invokeRestart("muffleMessage")
[10:25:18.330]                       }
[10:25:18.330]                       else if (inherits(cond, "warning")) {
[10:25:18.330]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.330]                         if (muffled) 
[10:25:18.330]                           invokeRestart("muffleWarning")
[10:25:18.330]                       }
[10:25:18.330]                       else if (inherits(cond, "condition")) {
[10:25:18.330]                         if (!is.null(pattern)) {
[10:25:18.330]                           computeRestarts <- base::computeRestarts
[10:25:18.330]                           grepl <- base::grepl
[10:25:18.330]                           restarts <- computeRestarts(cond)
[10:25:18.330]                           for (restart in restarts) {
[10:25:18.330]                             name <- restart$name
[10:25:18.330]                             if (is.null(name)) 
[10:25:18.330]                               next
[10:25:18.330]                             if (!grepl(pattern, name)) 
[10:25:18.330]                               next
[10:25:18.330]                             invokeRestart(restart)
[10:25:18.330]                             muffled <- TRUE
[10:25:18.330]                             break
[10:25:18.330]                           }
[10:25:18.330]                         }
[10:25:18.330]                       }
[10:25:18.330]                       invisible(muffled)
[10:25:18.330]                     }
[10:25:18.330]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.330]                   }
[10:25:18.330]                 }
[10:25:18.330]             }
[10:25:18.330]         }))
[10:25:18.330]     }, error = function(ex) {
[10:25:18.330]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:18.330]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.330]                 ...future.rng), started = ...future.startTime, 
[10:25:18.330]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:18.330]             version = "1.8"), class = "FutureResult")
[10:25:18.330]     }, finally = {
[10:25:18.330]         if (!identical(...future.workdir, getwd())) 
[10:25:18.330]             setwd(...future.workdir)
[10:25:18.330]         {
[10:25:18.330]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:18.330]                 ...future.oldOptions$nwarnings <- NULL
[10:25:18.330]             }
[10:25:18.330]             base::options(...future.oldOptions)
[10:25:18.330]             if (.Platform$OS.type == "windows") {
[10:25:18.330]                 old_names <- names(...future.oldEnvVars)
[10:25:18.330]                 envs <- base::Sys.getenv()
[10:25:18.330]                 names <- names(envs)
[10:25:18.330]                 common <- intersect(names, old_names)
[10:25:18.330]                 added <- setdiff(names, old_names)
[10:25:18.330]                 removed <- setdiff(old_names, names)
[10:25:18.330]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:18.330]                   envs[common]]
[10:25:18.330]                 NAMES <- toupper(changed)
[10:25:18.330]                 args <- list()
[10:25:18.330]                 for (kk in seq_along(NAMES)) {
[10:25:18.330]                   name <- changed[[kk]]
[10:25:18.330]                   NAME <- NAMES[[kk]]
[10:25:18.330]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.330]                     next
[10:25:18.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.330]                 }
[10:25:18.330]                 NAMES <- toupper(added)
[10:25:18.330]                 for (kk in seq_along(NAMES)) {
[10:25:18.330]                   name <- added[[kk]]
[10:25:18.330]                   NAME <- NAMES[[kk]]
[10:25:18.330]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.330]                     next
[10:25:18.330]                   args[[name]] <- ""
[10:25:18.330]                 }
[10:25:18.330]                 NAMES <- toupper(removed)
[10:25:18.330]                 for (kk in seq_along(NAMES)) {
[10:25:18.330]                   name <- removed[[kk]]
[10:25:18.330]                   NAME <- NAMES[[kk]]
[10:25:18.330]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.330]                     next
[10:25:18.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.330]                 }
[10:25:18.330]                 if (length(args) > 0) 
[10:25:18.330]                   base::do.call(base::Sys.setenv, args = args)
[10:25:18.330]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:18.330]             }
[10:25:18.330]             else {
[10:25:18.330]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:18.330]             }
[10:25:18.330]             {
[10:25:18.330]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:18.330]                   0L) {
[10:25:18.330]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:18.330]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:18.330]                   base::options(opts)
[10:25:18.330]                 }
[10:25:18.330]                 {
[10:25:18.330]                   {
[10:25:18.330]                     NULL
[10:25:18.330]                     RNGkind("Mersenne-Twister")
[10:25:18.330]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:18.330]                       inherits = FALSE)
[10:25:18.330]                   }
[10:25:18.330]                   options(future.plan = NULL)
[10:25:18.330]                   if (is.na(NA_character_)) 
[10:25:18.330]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.330]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:18.330]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:18.330]                   {
[10:25:18.330]                     future <- SequentialFuture(..., envir = envir)
[10:25:18.330]                     if (!future$lazy) 
[10:25:18.330]                       future <- run(future)
[10:25:18.330]                     invisible(future)
[10:25:18.330]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:18.330]                 }
[10:25:18.330]             }
[10:25:18.330]         }
[10:25:18.330]     })
[10:25:18.330]     if (TRUE) {
[10:25:18.330]         base::sink(type = "output", split = FALSE)
[10:25:18.330]         if (TRUE) {
[10:25:18.330]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:18.330]         }
[10:25:18.330]         else {
[10:25:18.330]             ...future.result["stdout"] <- base::list(NULL)
[10:25:18.330]         }
[10:25:18.330]         base::close(...future.stdout)
[10:25:18.330]         ...future.stdout <- NULL
[10:25:18.330]     }
[10:25:18.330]     ...future.result$conditions <- ...future.conditions
[10:25:18.330]     ...future.result$finished <- base::Sys.time()
[10:25:18.330]     ...future.result
[10:25:18.330] }
[10:25:18.332] assign_globals() ...
[10:25:18.332] List of 4
[10:25:18.332]  $ ii   : int 1
[10:25:18.332]  $ n    : int 4
[10:25:18.332]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[10:25:18.332]   ..- attr(*, "region")=List of 2
[10:25:18.332]   .. ..$ xrange: num [1:2] -2.25 -0.781
[10:25:18.332]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[10:25:18.332]   ..- attr(*, "tile")= int [1:2] 1 1
[10:25:18.332]  $ delay:function (counts)  
[10:25:18.332]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:25:18.332]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x563913565410> 
[10:25:18.332]  - attr(*, "where")=List of 4
[10:25:18.332]   ..$ ii   :<environment: R_EmptyEnv> 
[10:25:18.332]   ..$ n    :<environment: R_EmptyEnv> 
[10:25:18.332]   ..$ C    :<environment: R_EmptyEnv> 
[10:25:18.332]   ..$ delay:<environment: R_EmptyEnv> 
[10:25:18.332]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:18.332]  - attr(*, "resolved")= logi FALSE
[10:25:18.332]  - attr(*, "total_size")= num 14584
[10:25:18.332]  - attr(*, "already-done")= logi TRUE
[10:25:18.339] - copied ‘ii’ to environment
[10:25:18.339] - copied ‘n’ to environment
[10:25:18.339] - copied ‘C’ to environment
[10:25:18.339] - reassign environment for ‘delay’
[10:25:18.339] - copied ‘delay’ to environment
[10:25:18.339] assign_globals() ... done
[10:25:18.340] plan(): Setting new future strategy stack:
[10:25:18.340] List of future strategies:
[10:25:18.340] 1. sequential:
[10:25:18.340]    - args: function (..., envir = parent.frame())
[10:25:18.340]    - tweaked: FALSE
[10:25:18.340]    - call: NULL
[10:25:18.340] plan(): nbrOfWorkers() = 1
[10:25:18.354] plan(): Setting new future strategy stack:
[10:25:18.355] List of future strategies:
[10:25:18.355] 1. sequential:
[10:25:18.355]    - args: function (..., envir = parent.frame())
[10:25:18.355]    - tweaked: FALSE
[10:25:18.355]    - call: plan(strategy)
[10:25:18.355] plan(): nbrOfWorkers() = 1
[10:25:18.355] SequentialFuture started (and completed)
[10:25:18.355] signalConditions() ...
[10:25:18.355]  - include = ‘immediateCondition’
[10:25:18.355]  - exclude = 
[10:25:18.356]  - resignal = FALSE
[10:25:18.358]  - Number of conditions: 2
[10:25:18.358] signalConditions() ... done
[10:25:18.358] - Launch lazy future ... done
[10:25:18.359] run() for ‘SequentialFuture’ ... done
[10:25:18.359] - run() ... done
[10:25:18.359] - resolved() ...
[10:25:18.359] resolved() for ‘SequentialFuture’ ...
[10:25:18.359] - state: ‘finished’
[10:25:18.359] - run: TRUE
[10:25:18.359] - result: ‘FutureResult’
[10:25:18.359] resolved() for ‘SequentialFuture’ ... done
[10:25:18.359] - resolved: TRUE
[10:25:18.359] - resolved() ... done
[10:25:18.359] resolved() for ‘SequentialFuture’ ... done
Plotting tile #1 of 4 ...
[10:25:18.360] signalConditions() ...
[10:25:18.360]  - include = ‘immediateCondition’
[10:25:18.360]  - exclude = 
[10:25:18.360]  - resignal = FALSE
[10:25:18.360]  - Number of conditions: 2
[10:25:18.360] signalConditions() ... done
[10:25:18.360] Future state: ‘finished’
[10:25:18.360] signalConditions() ...
[10:25:18.360]  - include = ‘condition’
[10:25:18.361]  - exclude = ‘immediateCondition’
[10:25:18.361]  - resignal = TRUE
[10:25:18.361]  - Number of conditions: 2
[10:25:18.361]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[10:25:18.361]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:25:18.361] signalConditions() ... done
[10:25:18.363] resolved() for ‘Future’ ...
[10:25:18.363] - state: ‘created’
[10:25:18.363] - run: TRUE
[10:25:18.363] - run() ...
[10:25:18.363] run() for ‘Future’ ...
[10:25:18.363] - state: ‘created’
[10:25:18.363] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:18.364] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:18.364] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:18.364]   - Field: ‘label’
[10:25:18.364]   - Field: ‘local’
[10:25:18.364]   - Field: ‘owner’
[10:25:18.364]   - Field: ‘envir’
[10:25:18.364]   - Field: ‘packages’
[10:25:18.364]   - Field: ‘gc’
[10:25:18.364]   - Field: ‘conditions’
[10:25:18.365]   - Field: ‘expr’
[10:25:18.365]   - Field: ‘uuid’
[10:25:18.365]   - Field: ‘seed’
[10:25:18.365]   - Field: ‘version’
[10:25:18.365]   - Field: ‘result’
[10:25:18.365]   - Field: ‘asynchronous’
[10:25:18.365]   - Field: ‘calls’
[10:25:18.365]   - Field: ‘globals’
[10:25:18.365]   - Field: ‘stdout’
[10:25:18.365]   - Field: ‘earlySignal’
[10:25:18.365]   - Field: ‘lazy’
[10:25:18.366]   - Field: ‘state’
[10:25:18.366] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:18.366] - Launch lazy future ...
[10:25:18.366] Packages needed by the future expression (n = 1): ‘future’
[10:25:18.366] Packages needed by future strategies (n = 0): <none>
[10:25:18.367] {
[10:25:18.367]     {
[10:25:18.367]         {
[10:25:18.367]             ...future.startTime <- base::Sys.time()
[10:25:18.367]             {
[10:25:18.367]                 {
[10:25:18.367]                   {
[10:25:18.367]                     {
[10:25:18.367]                       base::local({
[10:25:18.367]                         has_future <- base::requireNamespace("future", 
[10:25:18.367]                           quietly = TRUE)
[10:25:18.367]                         if (has_future) {
[10:25:18.367]                           ns <- base::getNamespace("future")
[10:25:18.367]                           version <- ns[[".package"]][["version"]]
[10:25:18.367]                           if (is.null(version)) 
[10:25:18.367]                             version <- utils::packageVersion("future")
[10:25:18.367]                         }
[10:25:18.367]                         else {
[10:25:18.367]                           version <- NULL
[10:25:18.367]                         }
[10:25:18.367]                         if (!has_future || version < "1.8.0") {
[10:25:18.367]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:18.367]                             "", base::R.version$version.string), 
[10:25:18.367]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:18.367]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:18.367]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:18.367]                               "release", "version")], collapse = " "), 
[10:25:18.367]                             hostname = base::Sys.info()[["nodename"]])
[10:25:18.367]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:18.367]                             info)
[10:25:18.367]                           info <- base::paste(info, collapse = "; ")
[10:25:18.367]                           if (!has_future) {
[10:25:18.367]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:18.367]                               info)
[10:25:18.367]                           }
[10:25:18.367]                           else {
[10:25:18.367]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:18.367]                               info, version)
[10:25:18.367]                           }
[10:25:18.367]                           base::stop(msg)
[10:25:18.367]                         }
[10:25:18.367]                       })
[10:25:18.367]                     }
[10:25:18.367]                     base::local({
[10:25:18.367]                       for (pkg in "future") {
[10:25:18.367]                         base::loadNamespace(pkg)
[10:25:18.367]                         base::library(pkg, character.only = TRUE)
[10:25:18.367]                       }
[10:25:18.367]                     })
[10:25:18.367]                   }
[10:25:18.367]                   options(future.plan = NULL)
[10:25:18.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:18.367]                 }
[10:25:18.367]                 ...future.workdir <- getwd()
[10:25:18.367]             }
[10:25:18.367]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:18.367]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:18.367]         }
[10:25:18.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:18.367]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:18.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:18.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:18.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:18.367]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:18.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:18.367]             base::names(...future.oldOptions))
[10:25:18.367]     }
[10:25:18.367]     if (FALSE) {
[10:25:18.367]     }
[10:25:18.367]     else {
[10:25:18.367]         if (TRUE) {
[10:25:18.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:18.367]                 open = "w")
[10:25:18.367]         }
[10:25:18.367]         else {
[10:25:18.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:18.367]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:18.367]         }
[10:25:18.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:18.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:18.367]             base::sink(type = "output", split = FALSE)
[10:25:18.367]             base::close(...future.stdout)
[10:25:18.367]         }, add = TRUE)
[10:25:18.367]     }
[10:25:18.367]     ...future.frame <- base::sys.nframe()
[10:25:18.367]     ...future.conditions <- base::list()
[10:25:18.367]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:18.367]     if (FALSE) {
[10:25:18.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:18.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:18.367]     }
[10:25:18.367]     ...future.result <- base::tryCatch({
[10:25:18.367]         base::withCallingHandlers({
[10:25:18.367]             ...future.value <- base::withVisible(base::local({
[10:25:18.367]                 message(sprintf("Calculating tile #%d of %d ...", 
[10:25:18.367]                   ii, n), appendLF = FALSE)
[10:25:18.367]                 fit <- mandelbrot(C)
[10:25:18.367]                 delay(fit)
[10:25:18.367]                 message(" done")
[10:25:18.367]                 fit
[10:25:18.367]             }))
[10:25:18.367]             future::FutureResult(value = ...future.value$value, 
[10:25:18.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.367]                   ...future.rng), globalenv = if (FALSE) 
[10:25:18.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:18.367]                     ...future.globalenv.names))
[10:25:18.367]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:18.367]         }, condition = base::local({
[10:25:18.367]             c <- base::c
[10:25:18.367]             inherits <- base::inherits
[10:25:18.367]             invokeRestart <- base::invokeRestart
[10:25:18.367]             length <- base::length
[10:25:18.367]             list <- base::list
[10:25:18.367]             seq.int <- base::seq.int
[10:25:18.367]             signalCondition <- base::signalCondition
[10:25:18.367]             sys.calls <- base::sys.calls
[10:25:18.367]             `[[` <- base::`[[`
[10:25:18.367]             `+` <- base::`+`
[10:25:18.367]             `<<-` <- base::`<<-`
[10:25:18.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:18.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:18.367]                   3L)]
[10:25:18.367]             }
[10:25:18.367]             function(cond) {
[10:25:18.367]                 is_error <- inherits(cond, "error")
[10:25:18.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:18.367]                   NULL)
[10:25:18.367]                 if (is_error) {
[10:25:18.367]                   sessionInformation <- function() {
[10:25:18.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:18.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:18.367]                       search = base::search(), system = base::Sys.info())
[10:25:18.367]                   }
[10:25:18.367]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:18.367]                     cond$call), session = sessionInformation(), 
[10:25:18.367]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:18.367]                   signalCondition(cond)
[10:25:18.367]                 }
[10:25:18.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:18.367]                 "immediateCondition"))) {
[10:25:18.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:18.367]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:18.367]                   if (TRUE && !signal) {
[10:25:18.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.367]                     {
[10:25:18.367]                       inherits <- base::inherits
[10:25:18.367]                       invokeRestart <- base::invokeRestart
[10:25:18.367]                       is.null <- base::is.null
[10:25:18.367]                       muffled <- FALSE
[10:25:18.367]                       if (inherits(cond, "message")) {
[10:25:18.367]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.367]                         if (muffled) 
[10:25:18.367]                           invokeRestart("muffleMessage")
[10:25:18.367]                       }
[10:25:18.367]                       else if (inherits(cond, "warning")) {
[10:25:18.367]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.367]                         if (muffled) 
[10:25:18.367]                           invokeRestart("muffleWarning")
[10:25:18.367]                       }
[10:25:18.367]                       else if (inherits(cond, "condition")) {
[10:25:18.367]                         if (!is.null(pattern)) {
[10:25:18.367]                           computeRestarts <- base::computeRestarts
[10:25:18.367]                           grepl <- base::grepl
[10:25:18.367]                           restarts <- computeRestarts(cond)
[10:25:18.367]                           for (restart in restarts) {
[10:25:18.367]                             name <- restart$name
[10:25:18.367]                             if (is.null(name)) 
[10:25:18.367]                               next
[10:25:18.367]                             if (!grepl(pattern, name)) 
[10:25:18.367]                               next
[10:25:18.367]                             invokeRestart(restart)
[10:25:18.367]                             muffled <- TRUE
[10:25:18.367]                             break
[10:25:18.367]                           }
[10:25:18.367]                         }
[10:25:18.367]                       }
[10:25:18.367]                       invisible(muffled)
[10:25:18.367]                     }
[10:25:18.367]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.367]                   }
[10:25:18.367]                 }
[10:25:18.367]                 else {
[10:25:18.367]                   if (TRUE) {
[10:25:18.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.367]                     {
[10:25:18.367]                       inherits <- base::inherits
[10:25:18.367]                       invokeRestart <- base::invokeRestart
[10:25:18.367]                       is.null <- base::is.null
[10:25:18.367]                       muffled <- FALSE
[10:25:18.367]                       if (inherits(cond, "message")) {
[10:25:18.367]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.367]                         if (muffled) 
[10:25:18.367]                           invokeRestart("muffleMessage")
[10:25:18.367]                       }
[10:25:18.367]                       else if (inherits(cond, "warning")) {
[10:25:18.367]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.367]                         if (muffled) 
[10:25:18.367]                           invokeRestart("muffleWarning")
[10:25:18.367]                       }
[10:25:18.367]                       else if (inherits(cond, "condition")) {
[10:25:18.367]                         if (!is.null(pattern)) {
[10:25:18.367]                           computeRestarts <- base::computeRestarts
[10:25:18.367]                           grepl <- base::grepl
[10:25:18.367]                           restarts <- computeRestarts(cond)
[10:25:18.367]                           for (restart in restarts) {
[10:25:18.367]                             name <- restart$name
[10:25:18.367]                             if (is.null(name)) 
[10:25:18.367]                               next
[10:25:18.367]                             if (!grepl(pattern, name)) 
[10:25:18.367]                               next
[10:25:18.367]                             invokeRestart(restart)
[10:25:18.367]                             muffled <- TRUE
[10:25:18.367]                             break
[10:25:18.367]                           }
[10:25:18.367]                         }
[10:25:18.367]                       }
[10:25:18.367]                       invisible(muffled)
[10:25:18.367]                     }
[10:25:18.367]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.367]                   }
[10:25:18.367]                 }
[10:25:18.367]             }
[10:25:18.367]         }))
[10:25:18.367]     }, error = function(ex) {
[10:25:18.367]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:18.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.367]                 ...future.rng), started = ...future.startTime, 
[10:25:18.367]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:18.367]             version = "1.8"), class = "FutureResult")
[10:25:18.367]     }, finally = {
[10:25:18.367]         if (!identical(...future.workdir, getwd())) 
[10:25:18.367]             setwd(...future.workdir)
[10:25:18.367]         {
[10:25:18.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:18.367]                 ...future.oldOptions$nwarnings <- NULL
[10:25:18.367]             }
[10:25:18.367]             base::options(...future.oldOptions)
[10:25:18.367]             if (.Platform$OS.type == "windows") {
[10:25:18.367]                 old_names <- names(...future.oldEnvVars)
[10:25:18.367]                 envs <- base::Sys.getenv()
[10:25:18.367]                 names <- names(envs)
[10:25:18.367]                 common <- intersect(names, old_names)
[10:25:18.367]                 added <- setdiff(names, old_names)
[10:25:18.367]                 removed <- setdiff(old_names, names)
[10:25:18.367]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:18.367]                   envs[common]]
[10:25:18.367]                 NAMES <- toupper(changed)
[10:25:18.367]                 args <- list()
[10:25:18.367]                 for (kk in seq_along(NAMES)) {
[10:25:18.367]                   name <- changed[[kk]]
[10:25:18.367]                   NAME <- NAMES[[kk]]
[10:25:18.367]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.367]                     next
[10:25:18.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.367]                 }
[10:25:18.367]                 NAMES <- toupper(added)
[10:25:18.367]                 for (kk in seq_along(NAMES)) {
[10:25:18.367]                   name <- added[[kk]]
[10:25:18.367]                   NAME <- NAMES[[kk]]
[10:25:18.367]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.367]                     next
[10:25:18.367]                   args[[name]] <- ""
[10:25:18.367]                 }
[10:25:18.367]                 NAMES <- toupper(removed)
[10:25:18.367]                 for (kk in seq_along(NAMES)) {
[10:25:18.367]                   name <- removed[[kk]]
[10:25:18.367]                   NAME <- NAMES[[kk]]
[10:25:18.367]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.367]                     next
[10:25:18.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.367]                 }
[10:25:18.367]                 if (length(args) > 0) 
[10:25:18.367]                   base::do.call(base::Sys.setenv, args = args)
[10:25:18.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:18.367]             }
[10:25:18.367]             else {
[10:25:18.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:18.367]             }
[10:25:18.367]             {
[10:25:18.367]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:18.367]                   0L) {
[10:25:18.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:18.367]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:18.367]                   base::options(opts)
[10:25:18.367]                 }
[10:25:18.367]                 {
[10:25:18.367]                   {
[10:25:18.367]                     NULL
[10:25:18.367]                     RNGkind("Mersenne-Twister")
[10:25:18.367]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:18.367]                       inherits = FALSE)
[10:25:18.367]                   }
[10:25:18.367]                   options(future.plan = NULL)
[10:25:18.367]                   if (is.na(NA_character_)) 
[10:25:18.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:18.367]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:18.367]                   {
[10:25:18.367]                     future <- SequentialFuture(..., envir = envir)
[10:25:18.367]                     if (!future$lazy) 
[10:25:18.367]                       future <- run(future)
[10:25:18.367]                     invisible(future)
[10:25:18.367]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:18.367]                 }
[10:25:18.367]             }
[10:25:18.367]         }
[10:25:18.367]     })
[10:25:18.367]     if (TRUE) {
[10:25:18.367]         base::sink(type = "output", split = FALSE)
[10:25:18.367]         if (TRUE) {
[10:25:18.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:18.367]         }
[10:25:18.367]         else {
[10:25:18.367]             ...future.result["stdout"] <- base::list(NULL)
[10:25:18.367]         }
[10:25:18.367]         base::close(...future.stdout)
[10:25:18.367]         ...future.stdout <- NULL
[10:25:18.367]     }
[10:25:18.367]     ...future.result$conditions <- ...future.conditions
[10:25:18.367]     ...future.result$finished <- base::Sys.time()
[10:25:18.367]     ...future.result
[10:25:18.367] }
[10:25:18.368] assign_globals() ...
[10:25:18.368] List of 4
[10:25:18.368]  $ ii   : int 2
[10:25:18.368]  $ n    : int 4
[10:25:18.368]  $ C    : cplx [1:25, 1:25] -0.72-1.5i -0.72-1.44i -0.72-1.38i ...
[10:25:18.368]   ..- attr(*, "region")=List of 2
[10:25:18.368]   .. ..$ xrange: num [1:2] -0.719 0.75
[10:25:18.368]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[10:25:18.368]   ..- attr(*, "tile")= int [1:2] 1 2
[10:25:18.368]  $ delay:function (counts)  
[10:25:18.368]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:25:18.368]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x563913565410> 
[10:25:18.368]  - attr(*, "where")=List of 4
[10:25:18.368]   ..$ ii   :<environment: R_EmptyEnv> 
[10:25:18.368]   ..$ n    :<environment: R_EmptyEnv> 
[10:25:18.368]   ..$ C    :<environment: R_EmptyEnv> 
[10:25:18.368]   ..$ delay:<environment: R_EmptyEnv> 
[10:25:18.368]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:18.368]  - attr(*, "resolved")= logi FALSE
[10:25:18.368]  - attr(*, "total_size")= num 14584
[10:25:18.368]  - attr(*, "already-done")= logi TRUE
[10:25:18.374] - copied ‘ii’ to environment
[10:25:18.375] - copied ‘n’ to environment
[10:25:18.375] - copied ‘C’ to environment
[10:25:18.375] - reassign environment for ‘delay’
[10:25:18.375] - copied ‘delay’ to environment
[10:25:18.375] assign_globals() ... done
[10:25:18.375] plan(): Setting new future strategy stack:
[10:25:18.375] List of future strategies:
[10:25:18.375] 1. sequential:
[10:25:18.375]    - args: function (..., envir = parent.frame())
[10:25:18.375]    - tweaked: FALSE
[10:25:18.375]    - call: NULL
[10:25:18.376] plan(): nbrOfWorkers() = 1
[10:25:18.390] plan(): Setting new future strategy stack:
[10:25:18.391] List of future strategies:
[10:25:18.391] 1. sequential:
[10:25:18.391]    - args: function (..., envir = parent.frame())
[10:25:18.391]    - tweaked: FALSE
[10:25:18.391]    - call: plan(strategy)
[10:25:18.391] plan(): nbrOfWorkers() = 1
[10:25:18.391] SequentialFuture started (and completed)
[10:25:18.391] signalConditions() ...
[10:25:18.391]  - include = ‘immediateCondition’
[10:25:18.391]  - exclude = 
[10:25:18.391]  - resignal = FALSE
[10:25:18.392]  - Number of conditions: 2
[10:25:18.392] signalConditions() ... done
[10:25:18.392] - Launch lazy future ... done
[10:25:18.392] run() for ‘SequentialFuture’ ... done
[10:25:18.392] - run() ... done
[10:25:18.392] - resolved() ...
[10:25:18.392] resolved() for ‘SequentialFuture’ ...
[10:25:18.392] - state: ‘finished’
[10:25:18.392] - run: TRUE
[10:25:18.392] - result: ‘FutureResult’
[10:25:18.392] resolved() for ‘SequentialFuture’ ... done
[10:25:18.393] - resolved: TRUE
[10:25:18.393] - resolved() ... done
[10:25:18.393] resolved() for ‘SequentialFuture’ ... done
Plotting tile #2 of 4 ...
[10:25:18.393] signalConditions() ...
[10:25:18.393]  - include = ‘immediateCondition’
[10:25:18.393]  - exclude = 
[10:25:18.393]  - resignal = FALSE
[10:25:18.393]  - Number of conditions: 2
[10:25:18.393] signalConditions() ... done
[10:25:18.393] Future state: ‘finished’
[10:25:18.394] signalConditions() ...
[10:25:18.394]  - include = ‘condition’
[10:25:18.394]  - exclude = ‘immediateCondition’
[10:25:18.394]  - resignal = TRUE
[10:25:18.394]  - Number of conditions: 2
[10:25:18.394]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[10:25:18.394]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:25:18.394] signalConditions() ... done
[10:25:18.395] resolved() for ‘Future’ ...
[10:25:18.395] - state: ‘created’
[10:25:18.395] - run: TRUE
[10:25:18.395] - run() ...
[10:25:18.395] run() for ‘Future’ ...
[10:25:18.395] - state: ‘created’
[10:25:18.395] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:18.396] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:18.396] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:18.396]   - Field: ‘label’
[10:25:18.396]   - Field: ‘local’
[10:25:18.396]   - Field: ‘owner’
[10:25:18.396]   - Field: ‘envir’
[10:25:18.396]   - Field: ‘packages’
[10:25:18.397]   - Field: ‘gc’
[10:25:18.397]   - Field: ‘conditions’
[10:25:18.397]   - Field: ‘expr’
[10:25:18.397]   - Field: ‘uuid’
[10:25:18.397]   - Field: ‘seed’
[10:25:18.397]   - Field: ‘version’
[10:25:18.397]   - Field: ‘result’
[10:25:18.397]   - Field: ‘asynchronous’
[10:25:18.397]   - Field: ‘calls’
[10:25:18.397]   - Field: ‘globals’
[10:25:18.397]   - Field: ‘stdout’
[10:25:18.398]   - Field: ‘earlySignal’
[10:25:18.398]   - Field: ‘lazy’
[10:25:18.398]   - Field: ‘state’
[10:25:18.398] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:18.398] - Launch lazy future ...
[10:25:18.398] Packages needed by the future expression (n = 1): ‘future’
[10:25:18.398] Packages needed by future strategies (n = 0): <none>
[10:25:18.399] {
[10:25:18.399]     {
[10:25:18.399]         {
[10:25:18.399]             ...future.startTime <- base::Sys.time()
[10:25:18.399]             {
[10:25:18.399]                 {
[10:25:18.399]                   {
[10:25:18.399]                     {
[10:25:18.399]                       base::local({
[10:25:18.399]                         has_future <- base::requireNamespace("future", 
[10:25:18.399]                           quietly = TRUE)
[10:25:18.399]                         if (has_future) {
[10:25:18.399]                           ns <- base::getNamespace("future")
[10:25:18.399]                           version <- ns[[".package"]][["version"]]
[10:25:18.399]                           if (is.null(version)) 
[10:25:18.399]                             version <- utils::packageVersion("future")
[10:25:18.399]                         }
[10:25:18.399]                         else {
[10:25:18.399]                           version <- NULL
[10:25:18.399]                         }
[10:25:18.399]                         if (!has_future || version < "1.8.0") {
[10:25:18.399]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:18.399]                             "", base::R.version$version.string), 
[10:25:18.399]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:18.399]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:18.399]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:18.399]                               "release", "version")], collapse = " "), 
[10:25:18.399]                             hostname = base::Sys.info()[["nodename"]])
[10:25:18.399]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:18.399]                             info)
[10:25:18.399]                           info <- base::paste(info, collapse = "; ")
[10:25:18.399]                           if (!has_future) {
[10:25:18.399]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:18.399]                               info)
[10:25:18.399]                           }
[10:25:18.399]                           else {
[10:25:18.399]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:18.399]                               info, version)
[10:25:18.399]                           }
[10:25:18.399]                           base::stop(msg)
[10:25:18.399]                         }
[10:25:18.399]                       })
[10:25:18.399]                     }
[10:25:18.399]                     base::local({
[10:25:18.399]                       for (pkg in "future") {
[10:25:18.399]                         base::loadNamespace(pkg)
[10:25:18.399]                         base::library(pkg, character.only = TRUE)
[10:25:18.399]                       }
[10:25:18.399]                     })
[10:25:18.399]                   }
[10:25:18.399]                   options(future.plan = NULL)
[10:25:18.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.399]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:18.399]                 }
[10:25:18.399]                 ...future.workdir <- getwd()
[10:25:18.399]             }
[10:25:18.399]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:18.399]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:18.399]         }
[10:25:18.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:18.399]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:18.399]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:18.399]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:18.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:18.399]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:18.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:18.399]             base::names(...future.oldOptions))
[10:25:18.399]     }
[10:25:18.399]     if (FALSE) {
[10:25:18.399]     }
[10:25:18.399]     else {
[10:25:18.399]         if (TRUE) {
[10:25:18.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:18.399]                 open = "w")
[10:25:18.399]         }
[10:25:18.399]         else {
[10:25:18.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:18.399]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:18.399]         }
[10:25:18.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:18.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:18.399]             base::sink(type = "output", split = FALSE)
[10:25:18.399]             base::close(...future.stdout)
[10:25:18.399]         }, add = TRUE)
[10:25:18.399]     }
[10:25:18.399]     ...future.frame <- base::sys.nframe()
[10:25:18.399]     ...future.conditions <- base::list()
[10:25:18.399]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:18.399]     if (FALSE) {
[10:25:18.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:18.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:18.399]     }
[10:25:18.399]     ...future.result <- base::tryCatch({
[10:25:18.399]         base::withCallingHandlers({
[10:25:18.399]             ...future.value <- base::withVisible(base::local({
[10:25:18.399]                 message(sprintf("Calculating tile #%d of %d ...", 
[10:25:18.399]                   ii, n), appendLF = FALSE)
[10:25:18.399]                 fit <- mandelbrot(C)
[10:25:18.399]                 delay(fit)
[10:25:18.399]                 message(" done")
[10:25:18.399]                 fit
[10:25:18.399]             }))
[10:25:18.399]             future::FutureResult(value = ...future.value$value, 
[10:25:18.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.399]                   ...future.rng), globalenv = if (FALSE) 
[10:25:18.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:18.399]                     ...future.globalenv.names))
[10:25:18.399]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:18.399]         }, condition = base::local({
[10:25:18.399]             c <- base::c
[10:25:18.399]             inherits <- base::inherits
[10:25:18.399]             invokeRestart <- base::invokeRestart
[10:25:18.399]             length <- base::length
[10:25:18.399]             list <- base::list
[10:25:18.399]             seq.int <- base::seq.int
[10:25:18.399]             signalCondition <- base::signalCondition
[10:25:18.399]             sys.calls <- base::sys.calls
[10:25:18.399]             `[[` <- base::`[[`
[10:25:18.399]             `+` <- base::`+`
[10:25:18.399]             `<<-` <- base::`<<-`
[10:25:18.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:18.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:18.399]                   3L)]
[10:25:18.399]             }
[10:25:18.399]             function(cond) {
[10:25:18.399]                 is_error <- inherits(cond, "error")
[10:25:18.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:18.399]                   NULL)
[10:25:18.399]                 if (is_error) {
[10:25:18.399]                   sessionInformation <- function() {
[10:25:18.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:18.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:18.399]                       search = base::search(), system = base::Sys.info())
[10:25:18.399]                   }
[10:25:18.399]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:18.399]                     cond$call), session = sessionInformation(), 
[10:25:18.399]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:18.399]                   signalCondition(cond)
[10:25:18.399]                 }
[10:25:18.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:18.399]                 "immediateCondition"))) {
[10:25:18.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:18.399]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:18.399]                   if (TRUE && !signal) {
[10:25:18.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.399]                     {
[10:25:18.399]                       inherits <- base::inherits
[10:25:18.399]                       invokeRestart <- base::invokeRestart
[10:25:18.399]                       is.null <- base::is.null
[10:25:18.399]                       muffled <- FALSE
[10:25:18.399]                       if (inherits(cond, "message")) {
[10:25:18.399]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.399]                         if (muffled) 
[10:25:18.399]                           invokeRestart("muffleMessage")
[10:25:18.399]                       }
[10:25:18.399]                       else if (inherits(cond, "warning")) {
[10:25:18.399]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.399]                         if (muffled) 
[10:25:18.399]                           invokeRestart("muffleWarning")
[10:25:18.399]                       }
[10:25:18.399]                       else if (inherits(cond, "condition")) {
[10:25:18.399]                         if (!is.null(pattern)) {
[10:25:18.399]                           computeRestarts <- base::computeRestarts
[10:25:18.399]                           grepl <- base::grepl
[10:25:18.399]                           restarts <- computeRestarts(cond)
[10:25:18.399]                           for (restart in restarts) {
[10:25:18.399]                             name <- restart$name
[10:25:18.399]                             if (is.null(name)) 
[10:25:18.399]                               next
[10:25:18.399]                             if (!grepl(pattern, name)) 
[10:25:18.399]                               next
[10:25:18.399]                             invokeRestart(restart)
[10:25:18.399]                             muffled <- TRUE
[10:25:18.399]                             break
[10:25:18.399]                           }
[10:25:18.399]                         }
[10:25:18.399]                       }
[10:25:18.399]                       invisible(muffled)
[10:25:18.399]                     }
[10:25:18.399]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.399]                   }
[10:25:18.399]                 }
[10:25:18.399]                 else {
[10:25:18.399]                   if (TRUE) {
[10:25:18.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.399]                     {
[10:25:18.399]                       inherits <- base::inherits
[10:25:18.399]                       invokeRestart <- base::invokeRestart
[10:25:18.399]                       is.null <- base::is.null
[10:25:18.399]                       muffled <- FALSE
[10:25:18.399]                       if (inherits(cond, "message")) {
[10:25:18.399]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.399]                         if (muffled) 
[10:25:18.399]                           invokeRestart("muffleMessage")
[10:25:18.399]                       }
[10:25:18.399]                       else if (inherits(cond, "warning")) {
[10:25:18.399]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.399]                         if (muffled) 
[10:25:18.399]                           invokeRestart("muffleWarning")
[10:25:18.399]                       }
[10:25:18.399]                       else if (inherits(cond, "condition")) {
[10:25:18.399]                         if (!is.null(pattern)) {
[10:25:18.399]                           computeRestarts <- base::computeRestarts
[10:25:18.399]                           grepl <- base::grepl
[10:25:18.399]                           restarts <- computeRestarts(cond)
[10:25:18.399]                           for (restart in restarts) {
[10:25:18.399]                             name <- restart$name
[10:25:18.399]                             if (is.null(name)) 
[10:25:18.399]                               next
[10:25:18.399]                             if (!grepl(pattern, name)) 
[10:25:18.399]                               next
[10:25:18.399]                             invokeRestart(restart)
[10:25:18.399]                             muffled <- TRUE
[10:25:18.399]                             break
[10:25:18.399]                           }
[10:25:18.399]                         }
[10:25:18.399]                       }
[10:25:18.399]                       invisible(muffled)
[10:25:18.399]                     }
[10:25:18.399]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.399]                   }
[10:25:18.399]                 }
[10:25:18.399]             }
[10:25:18.399]         }))
[10:25:18.399]     }, error = function(ex) {
[10:25:18.399]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:18.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.399]                 ...future.rng), started = ...future.startTime, 
[10:25:18.399]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:18.399]             version = "1.8"), class = "FutureResult")
[10:25:18.399]     }, finally = {
[10:25:18.399]         if (!identical(...future.workdir, getwd())) 
[10:25:18.399]             setwd(...future.workdir)
[10:25:18.399]         {
[10:25:18.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:18.399]                 ...future.oldOptions$nwarnings <- NULL
[10:25:18.399]             }
[10:25:18.399]             base::options(...future.oldOptions)
[10:25:18.399]             if (.Platform$OS.type == "windows") {
[10:25:18.399]                 old_names <- names(...future.oldEnvVars)
[10:25:18.399]                 envs <- base::Sys.getenv()
[10:25:18.399]                 names <- names(envs)
[10:25:18.399]                 common <- intersect(names, old_names)
[10:25:18.399]                 added <- setdiff(names, old_names)
[10:25:18.399]                 removed <- setdiff(old_names, names)
[10:25:18.399]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:18.399]                   envs[common]]
[10:25:18.399]                 NAMES <- toupper(changed)
[10:25:18.399]                 args <- list()
[10:25:18.399]                 for (kk in seq_along(NAMES)) {
[10:25:18.399]                   name <- changed[[kk]]
[10:25:18.399]                   NAME <- NAMES[[kk]]
[10:25:18.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.399]                     next
[10:25:18.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.399]                 }
[10:25:18.399]                 NAMES <- toupper(added)
[10:25:18.399]                 for (kk in seq_along(NAMES)) {
[10:25:18.399]                   name <- added[[kk]]
[10:25:18.399]                   NAME <- NAMES[[kk]]
[10:25:18.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.399]                     next
[10:25:18.399]                   args[[name]] <- ""
[10:25:18.399]                 }
[10:25:18.399]                 NAMES <- toupper(removed)
[10:25:18.399]                 for (kk in seq_along(NAMES)) {
[10:25:18.399]                   name <- removed[[kk]]
[10:25:18.399]                   NAME <- NAMES[[kk]]
[10:25:18.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.399]                     next
[10:25:18.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.399]                 }
[10:25:18.399]                 if (length(args) > 0) 
[10:25:18.399]                   base::do.call(base::Sys.setenv, args = args)
[10:25:18.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:18.399]             }
[10:25:18.399]             else {
[10:25:18.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:18.399]             }
[10:25:18.399]             {
[10:25:18.399]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:18.399]                   0L) {
[10:25:18.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:18.399]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:18.399]                   base::options(opts)
[10:25:18.399]                 }
[10:25:18.399]                 {
[10:25:18.399]                   {
[10:25:18.399]                     NULL
[10:25:18.399]                     RNGkind("Mersenne-Twister")
[10:25:18.399]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:18.399]                       inherits = FALSE)
[10:25:18.399]                   }
[10:25:18.399]                   options(future.plan = NULL)
[10:25:18.399]                   if (is.na(NA_character_)) 
[10:25:18.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:18.399]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:18.399]                   {
[10:25:18.399]                     future <- SequentialFuture(..., envir = envir)
[10:25:18.399]                     if (!future$lazy) 
[10:25:18.399]                       future <- run(future)
[10:25:18.399]                     invisible(future)
[10:25:18.399]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:18.399]                 }
[10:25:18.399]             }
[10:25:18.399]         }
[10:25:18.399]     })
[10:25:18.399]     if (TRUE) {
[10:25:18.399]         base::sink(type = "output", split = FALSE)
[10:25:18.399]         if (TRUE) {
[10:25:18.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:18.399]         }
[10:25:18.399]         else {
[10:25:18.399]             ...future.result["stdout"] <- base::list(NULL)
[10:25:18.399]         }
[10:25:18.399]         base::close(...future.stdout)
[10:25:18.399]         ...future.stdout <- NULL
[10:25:18.399]     }
[10:25:18.399]     ...future.result$conditions <- ...future.conditions
[10:25:18.399]     ...future.result$finished <- base::Sys.time()
[10:25:18.399]     ...future.result
[10:25:18.399] }
[10:25:18.401] assign_globals() ...
[10:25:18.401] List of 4
[10:25:18.401]  $ ii   : int 3
[10:25:18.401]  $ n    : int 4
[10:25:18.401]  $ C    : cplx [1:25, 1:25] -2.25+0.03i -2.25+0.09i -2.25+0.15i ...
[10:25:18.401]   ..- attr(*, "region")=List of 2
[10:25:18.401]   .. ..$ xrange: num [1:2] -2.25 -0.781
[10:25:18.401]   .. ..$ yrange: num [1:2] 0.0306 1.5
[10:25:18.401]   ..- attr(*, "tile")= int [1:2] 2 1
[10:25:18.401]  $ delay:function (counts)  
[10:25:18.401]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:25:18.401]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x563913565410> 
[10:25:18.401]  - attr(*, "where")=List of 4
[10:25:18.401]   ..$ ii   :<environment: R_EmptyEnv> 
[10:25:18.401]   ..$ n    :<environment: R_EmptyEnv> 
[10:25:18.401]   ..$ C    :<environment: R_EmptyEnv> 
[10:25:18.401]   ..$ delay:<environment: R_EmptyEnv> 
[10:25:18.401]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:18.401]  - attr(*, "resolved")= logi FALSE
[10:25:18.401]  - attr(*, "total_size")= num 14584
[10:25:18.401]  - attr(*, "already-done")= logi TRUE
[10:25:18.407] - copied ‘ii’ to environment
[10:25:18.407] - copied ‘n’ to environment
[10:25:18.407] - copied ‘C’ to environment
[10:25:18.407] - reassign environment for ‘delay’
[10:25:18.407] - copied ‘delay’ to environment
[10:25:18.407] assign_globals() ... done
[10:25:18.407] plan(): Setting new future strategy stack:
[10:25:18.408] List of future strategies:
[10:25:18.408] 1. sequential:
[10:25:18.408]    - args: function (..., envir = parent.frame())
[10:25:18.408]    - tweaked: FALSE
[10:25:18.408]    - call: NULL
[10:25:18.408] plan(): nbrOfWorkers() = 1
[10:25:18.425] plan(): Setting new future strategy stack:
[10:25:18.425] List of future strategies:
[10:25:18.425] 1. sequential:
[10:25:18.425]    - args: function (..., envir = parent.frame())
[10:25:18.425]    - tweaked: FALSE
[10:25:18.425]    - call: plan(strategy)
[10:25:18.425] plan(): nbrOfWorkers() = 1
[10:25:18.426] SequentialFuture started (and completed)
[10:25:18.426] signalConditions() ...
[10:25:18.426]  - include = ‘immediateCondition’
[10:25:18.426]  - exclude = 
[10:25:18.426]  - resignal = FALSE
[10:25:18.426]  - Number of conditions: 2
[10:25:18.426] signalConditions() ... done
[10:25:18.426] - Launch lazy future ... done
[10:25:18.426] run() for ‘SequentialFuture’ ... done
[10:25:18.427] - run() ... done
[10:25:18.427] - resolved() ...
[10:25:18.427] resolved() for ‘SequentialFuture’ ...
[10:25:18.427] - state: ‘finished’
[10:25:18.427] - run: TRUE
[10:25:18.427] - result: ‘FutureResult’
[10:25:18.427] resolved() for ‘SequentialFuture’ ... done
[10:25:18.427] - resolved: TRUE
[10:25:18.427] - resolved() ... done
[10:25:18.427] resolved() for ‘SequentialFuture’ ... done
Plotting tile #3 of 4 ...
[10:25:18.428] signalConditions() ...
[10:25:18.428]  - include = ‘immediateCondition’
[10:25:18.428]  - exclude = 
[10:25:18.428]  - resignal = FALSE
[10:25:18.428]  - Number of conditions: 2
[10:25:18.428] signalConditions() ... done
[10:25:18.428] Future state: ‘finished’
[10:25:18.428] signalConditions() ...
[10:25:18.428]  - include = ‘condition’
[10:25:18.428]  - exclude = ‘immediateCondition’
[10:25:18.429]  - resignal = TRUE
[10:25:18.429]  - Number of conditions: 2
[10:25:18.429]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[10:25:18.429]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:25:18.429] signalConditions() ... done
[10:25:18.430] resolved() for ‘Future’ ...
[10:25:18.430] - state: ‘created’
[10:25:18.430] - run: TRUE
[10:25:18.430] - run() ...
[10:25:18.430] run() for ‘Future’ ...
[10:25:18.430] - state: ‘created’
[10:25:18.430] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:18.431] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:18.431] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:18.431]   - Field: ‘label’
[10:25:18.431]   - Field: ‘local’
[10:25:18.431]   - Field: ‘owner’
[10:25:18.431]   - Field: ‘envir’
[10:25:18.431]   - Field: ‘packages’
[10:25:18.431]   - Field: ‘gc’
[10:25:18.431]   - Field: ‘conditions’
[10:25:18.431]   - Field: ‘expr’
[10:25:18.432]   - Field: ‘uuid’
[10:25:18.432]   - Field: ‘seed’
[10:25:18.432]   - Field: ‘version’
[10:25:18.432]   - Field: ‘result’
[10:25:18.432]   - Field: ‘asynchronous’
[10:25:18.432]   - Field: ‘calls’
[10:25:18.432]   - Field: ‘globals’
[10:25:18.432]   - Field: ‘stdout’
[10:25:18.432]   - Field: ‘earlySignal’
[10:25:18.432]   - Field: ‘lazy’
[10:25:18.432]   - Field: ‘state’
[10:25:18.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:18.433] - Launch lazy future ...
[10:25:18.433] Packages needed by the future expression (n = 1): ‘future’
[10:25:18.433] Packages needed by future strategies (n = 0): <none>
[10:25:18.434] {
[10:25:18.434]     {
[10:25:18.434]         {
[10:25:18.434]             ...future.startTime <- base::Sys.time()
[10:25:18.434]             {
[10:25:18.434]                 {
[10:25:18.434]                   {
[10:25:18.434]                     {
[10:25:18.434]                       base::local({
[10:25:18.434]                         has_future <- base::requireNamespace("future", 
[10:25:18.434]                           quietly = TRUE)
[10:25:18.434]                         if (has_future) {
[10:25:18.434]                           ns <- base::getNamespace("future")
[10:25:18.434]                           version <- ns[[".package"]][["version"]]
[10:25:18.434]                           if (is.null(version)) 
[10:25:18.434]                             version <- utils::packageVersion("future")
[10:25:18.434]                         }
[10:25:18.434]                         else {
[10:25:18.434]                           version <- NULL
[10:25:18.434]                         }
[10:25:18.434]                         if (!has_future || version < "1.8.0") {
[10:25:18.434]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:18.434]                             "", base::R.version$version.string), 
[10:25:18.434]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:18.434]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:18.434]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:18.434]                               "release", "version")], collapse = " "), 
[10:25:18.434]                             hostname = base::Sys.info()[["nodename"]])
[10:25:18.434]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:18.434]                             info)
[10:25:18.434]                           info <- base::paste(info, collapse = "; ")
[10:25:18.434]                           if (!has_future) {
[10:25:18.434]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:18.434]                               info)
[10:25:18.434]                           }
[10:25:18.434]                           else {
[10:25:18.434]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:18.434]                               info, version)
[10:25:18.434]                           }
[10:25:18.434]                           base::stop(msg)
[10:25:18.434]                         }
[10:25:18.434]                       })
[10:25:18.434]                     }
[10:25:18.434]                     base::local({
[10:25:18.434]                       for (pkg in "future") {
[10:25:18.434]                         base::loadNamespace(pkg)
[10:25:18.434]                         base::library(pkg, character.only = TRUE)
[10:25:18.434]                       }
[10:25:18.434]                     })
[10:25:18.434]                   }
[10:25:18.434]                   options(future.plan = NULL)
[10:25:18.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:18.434]                 }
[10:25:18.434]                 ...future.workdir <- getwd()
[10:25:18.434]             }
[10:25:18.434]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:18.434]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:18.434]         }
[10:25:18.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:18.434]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:18.434]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:18.434]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:18.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:18.434]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:18.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:18.434]             base::names(...future.oldOptions))
[10:25:18.434]     }
[10:25:18.434]     if (FALSE) {
[10:25:18.434]     }
[10:25:18.434]     else {
[10:25:18.434]         if (TRUE) {
[10:25:18.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:18.434]                 open = "w")
[10:25:18.434]         }
[10:25:18.434]         else {
[10:25:18.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:18.434]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:18.434]         }
[10:25:18.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:18.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:18.434]             base::sink(type = "output", split = FALSE)
[10:25:18.434]             base::close(...future.stdout)
[10:25:18.434]         }, add = TRUE)
[10:25:18.434]     }
[10:25:18.434]     ...future.frame <- base::sys.nframe()
[10:25:18.434]     ...future.conditions <- base::list()
[10:25:18.434]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:18.434]     if (FALSE) {
[10:25:18.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:18.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:18.434]     }
[10:25:18.434]     ...future.result <- base::tryCatch({
[10:25:18.434]         base::withCallingHandlers({
[10:25:18.434]             ...future.value <- base::withVisible(base::local({
[10:25:18.434]                 message(sprintf("Calculating tile #%d of %d ...", 
[10:25:18.434]                   ii, n), appendLF = FALSE)
[10:25:18.434]                 fit <- mandelbrot(C)
[10:25:18.434]                 delay(fit)
[10:25:18.434]                 message(" done")
[10:25:18.434]                 fit
[10:25:18.434]             }))
[10:25:18.434]             future::FutureResult(value = ...future.value$value, 
[10:25:18.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.434]                   ...future.rng), globalenv = if (FALSE) 
[10:25:18.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:18.434]                     ...future.globalenv.names))
[10:25:18.434]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:18.434]         }, condition = base::local({
[10:25:18.434]             c <- base::c
[10:25:18.434]             inherits <- base::inherits
[10:25:18.434]             invokeRestart <- base::invokeRestart
[10:25:18.434]             length <- base::length
[10:25:18.434]             list <- base::list
[10:25:18.434]             seq.int <- base::seq.int
[10:25:18.434]             signalCondition <- base::signalCondition
[10:25:18.434]             sys.calls <- base::sys.calls
[10:25:18.434]             `[[` <- base::`[[`
[10:25:18.434]             `+` <- base::`+`
[10:25:18.434]             `<<-` <- base::`<<-`
[10:25:18.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:18.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:18.434]                   3L)]
[10:25:18.434]             }
[10:25:18.434]             function(cond) {
[10:25:18.434]                 is_error <- inherits(cond, "error")
[10:25:18.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:18.434]                   NULL)
[10:25:18.434]                 if (is_error) {
[10:25:18.434]                   sessionInformation <- function() {
[10:25:18.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:18.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:18.434]                       search = base::search(), system = base::Sys.info())
[10:25:18.434]                   }
[10:25:18.434]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:18.434]                     cond$call), session = sessionInformation(), 
[10:25:18.434]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:18.434]                   signalCondition(cond)
[10:25:18.434]                 }
[10:25:18.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:18.434]                 "immediateCondition"))) {
[10:25:18.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:18.434]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:18.434]                   if (TRUE && !signal) {
[10:25:18.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.434]                     {
[10:25:18.434]                       inherits <- base::inherits
[10:25:18.434]                       invokeRestart <- base::invokeRestart
[10:25:18.434]                       is.null <- base::is.null
[10:25:18.434]                       muffled <- FALSE
[10:25:18.434]                       if (inherits(cond, "message")) {
[10:25:18.434]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.434]                         if (muffled) 
[10:25:18.434]                           invokeRestart("muffleMessage")
[10:25:18.434]                       }
[10:25:18.434]                       else if (inherits(cond, "warning")) {
[10:25:18.434]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.434]                         if (muffled) 
[10:25:18.434]                           invokeRestart("muffleWarning")
[10:25:18.434]                       }
[10:25:18.434]                       else if (inherits(cond, "condition")) {
[10:25:18.434]                         if (!is.null(pattern)) {
[10:25:18.434]                           computeRestarts <- base::computeRestarts
[10:25:18.434]                           grepl <- base::grepl
[10:25:18.434]                           restarts <- computeRestarts(cond)
[10:25:18.434]                           for (restart in restarts) {
[10:25:18.434]                             name <- restart$name
[10:25:18.434]                             if (is.null(name)) 
[10:25:18.434]                               next
[10:25:18.434]                             if (!grepl(pattern, name)) 
[10:25:18.434]                               next
[10:25:18.434]                             invokeRestart(restart)
[10:25:18.434]                             muffled <- TRUE
[10:25:18.434]                             break
[10:25:18.434]                           }
[10:25:18.434]                         }
[10:25:18.434]                       }
[10:25:18.434]                       invisible(muffled)
[10:25:18.434]                     }
[10:25:18.434]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.434]                   }
[10:25:18.434]                 }
[10:25:18.434]                 else {
[10:25:18.434]                   if (TRUE) {
[10:25:18.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.434]                     {
[10:25:18.434]                       inherits <- base::inherits
[10:25:18.434]                       invokeRestart <- base::invokeRestart
[10:25:18.434]                       is.null <- base::is.null
[10:25:18.434]                       muffled <- FALSE
[10:25:18.434]                       if (inherits(cond, "message")) {
[10:25:18.434]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.434]                         if (muffled) 
[10:25:18.434]                           invokeRestart("muffleMessage")
[10:25:18.434]                       }
[10:25:18.434]                       else if (inherits(cond, "warning")) {
[10:25:18.434]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.434]                         if (muffled) 
[10:25:18.434]                           invokeRestart("muffleWarning")
[10:25:18.434]                       }
[10:25:18.434]                       else if (inherits(cond, "condition")) {
[10:25:18.434]                         if (!is.null(pattern)) {
[10:25:18.434]                           computeRestarts <- base::computeRestarts
[10:25:18.434]                           grepl <- base::grepl
[10:25:18.434]                           restarts <- computeRestarts(cond)
[10:25:18.434]                           for (restart in restarts) {
[10:25:18.434]                             name <- restart$name
[10:25:18.434]                             if (is.null(name)) 
[10:25:18.434]                               next
[10:25:18.434]                             if (!grepl(pattern, name)) 
[10:25:18.434]                               next
[10:25:18.434]                             invokeRestart(restart)
[10:25:18.434]                             muffled <- TRUE
[10:25:18.434]                             break
[10:25:18.434]                           }
[10:25:18.434]                         }
[10:25:18.434]                       }
[10:25:18.434]                       invisible(muffled)
[10:25:18.434]                     }
[10:25:18.434]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.434]                   }
[10:25:18.434]                 }
[10:25:18.434]             }
[10:25:18.434]         }))
[10:25:18.434]     }, error = function(ex) {
[10:25:18.434]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:18.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.434]                 ...future.rng), started = ...future.startTime, 
[10:25:18.434]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:18.434]             version = "1.8"), class = "FutureResult")
[10:25:18.434]     }, finally = {
[10:25:18.434]         if (!identical(...future.workdir, getwd())) 
[10:25:18.434]             setwd(...future.workdir)
[10:25:18.434]         {
[10:25:18.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:18.434]                 ...future.oldOptions$nwarnings <- NULL
[10:25:18.434]             }
[10:25:18.434]             base::options(...future.oldOptions)
[10:25:18.434]             if (.Platform$OS.type == "windows") {
[10:25:18.434]                 old_names <- names(...future.oldEnvVars)
[10:25:18.434]                 envs <- base::Sys.getenv()
[10:25:18.434]                 names <- names(envs)
[10:25:18.434]                 common <- intersect(names, old_names)
[10:25:18.434]                 added <- setdiff(names, old_names)
[10:25:18.434]                 removed <- setdiff(old_names, names)
[10:25:18.434]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:18.434]                   envs[common]]
[10:25:18.434]                 NAMES <- toupper(changed)
[10:25:18.434]                 args <- list()
[10:25:18.434]                 for (kk in seq_along(NAMES)) {
[10:25:18.434]                   name <- changed[[kk]]
[10:25:18.434]                   NAME <- NAMES[[kk]]
[10:25:18.434]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.434]                     next
[10:25:18.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.434]                 }
[10:25:18.434]                 NAMES <- toupper(added)
[10:25:18.434]                 for (kk in seq_along(NAMES)) {
[10:25:18.434]                   name <- added[[kk]]
[10:25:18.434]                   NAME <- NAMES[[kk]]
[10:25:18.434]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.434]                     next
[10:25:18.434]                   args[[name]] <- ""
[10:25:18.434]                 }
[10:25:18.434]                 NAMES <- toupper(removed)
[10:25:18.434]                 for (kk in seq_along(NAMES)) {
[10:25:18.434]                   name <- removed[[kk]]
[10:25:18.434]                   NAME <- NAMES[[kk]]
[10:25:18.434]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.434]                     next
[10:25:18.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.434]                 }
[10:25:18.434]                 if (length(args) > 0) 
[10:25:18.434]                   base::do.call(base::Sys.setenv, args = args)
[10:25:18.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:18.434]             }
[10:25:18.434]             else {
[10:25:18.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:18.434]             }
[10:25:18.434]             {
[10:25:18.434]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:18.434]                   0L) {
[10:25:18.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:18.434]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:18.434]                   base::options(opts)
[10:25:18.434]                 }
[10:25:18.434]                 {
[10:25:18.434]                   {
[10:25:18.434]                     NULL
[10:25:18.434]                     RNGkind("Mersenne-Twister")
[10:25:18.434]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:18.434]                       inherits = FALSE)
[10:25:18.434]                   }
[10:25:18.434]                   options(future.plan = NULL)
[10:25:18.434]                   if (is.na(NA_character_)) 
[10:25:18.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:18.434]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:18.434]                   {
[10:25:18.434]                     future <- SequentialFuture(..., envir = envir)
[10:25:18.434]                     if (!future$lazy) 
[10:25:18.434]                       future <- run(future)
[10:25:18.434]                     invisible(future)
[10:25:18.434]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:18.434]                 }
[10:25:18.434]             }
[10:25:18.434]         }
[10:25:18.434]     })
[10:25:18.434]     if (TRUE) {
[10:25:18.434]         base::sink(type = "output", split = FALSE)
[10:25:18.434]         if (TRUE) {
[10:25:18.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:18.434]         }
[10:25:18.434]         else {
[10:25:18.434]             ...future.result["stdout"] <- base::list(NULL)
[10:25:18.434]         }
[10:25:18.434]         base::close(...future.stdout)
[10:25:18.434]         ...future.stdout <- NULL
[10:25:18.434]     }
[10:25:18.434]     ...future.result$conditions <- ...future.conditions
[10:25:18.434]     ...future.result$finished <- base::Sys.time()
[10:25:18.434]     ...future.result
[10:25:18.434] }
[10:25:18.435] assign_globals() ...
[10:25:18.435] List of 4
[10:25:18.435]  $ ii   : int 4
[10:25:18.435]  $ n    : int 4
[10:25:18.435]  $ C    : cplx [1:25, 1:25] -0.719+0.031i -0.719+0.092i -0.719+0.153i ...
[10:25:18.435]   ..- attr(*, "region")=List of 2
[10:25:18.435]   .. ..$ xrange: num [1:2] -0.719 0.75
[10:25:18.435]   .. ..$ yrange: num [1:2] 0.0306 1.5
[10:25:18.435]   ..- attr(*, "tile")= int [1:2] 2 2
[10:25:18.435]  $ delay:function (counts)  
[10:25:18.435]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:25:18.435]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x563913565410> 
[10:25:18.435]  - attr(*, "where")=List of 4
[10:25:18.435]   ..$ ii   :<environment: R_EmptyEnv> 
[10:25:18.435]   ..$ n    :<environment: R_EmptyEnv> 
[10:25:18.435]   ..$ C    :<environment: R_EmptyEnv> 
[10:25:18.435]   ..$ delay:<environment: R_EmptyEnv> 
[10:25:18.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:18.435]  - attr(*, "resolved")= logi FALSE
[10:25:18.435]  - attr(*, "total_size")= num 14584
[10:25:18.435]  - attr(*, "already-done")= logi TRUE
[10:25:18.442] - copied ‘ii’ to environment
[10:25:18.442] - copied ‘n’ to environment
[10:25:18.442] - copied ‘C’ to environment
[10:25:18.442] - reassign environment for ‘delay’
[10:25:18.442] - copied ‘delay’ to environment
[10:25:18.442] assign_globals() ... done
[10:25:18.442] plan(): Setting new future strategy stack:
[10:25:18.443] List of future strategies:
[10:25:18.443] 1. sequential:
[10:25:18.443]    - args: function (..., envir = parent.frame())
[10:25:18.443]    - tweaked: FALSE
[10:25:18.443]    - call: NULL
[10:25:18.443] plan(): nbrOfWorkers() = 1
[10:25:18.458] plan(): Setting new future strategy stack:
[10:25:18.458] List of future strategies:
[10:25:18.458] 1. sequential:
[10:25:18.458]    - args: function (..., envir = parent.frame())
[10:25:18.458]    - tweaked: FALSE
[10:25:18.458]    - call: plan(strategy)
[10:25:18.458] plan(): nbrOfWorkers() = 1
[10:25:18.458] SequentialFuture started (and completed)
[10:25:18.459] signalConditions() ...
[10:25:18.459]  - include = ‘immediateCondition’
[10:25:18.459]  - exclude = 
[10:25:18.459]  - resignal = FALSE
[10:25:18.459]  - Number of conditions: 2
[10:25:18.459] signalConditions() ... done
[10:25:18.459] - Launch lazy future ... done
[10:25:18.459] run() for ‘SequentialFuture’ ... done
[10:25:18.459] - run() ... done
[10:25:18.459] - resolved() ...
[10:25:18.460] resolved() for ‘SequentialFuture’ ...
[10:25:18.460] - state: ‘finished’
[10:25:18.460] - run: TRUE
[10:25:18.460] - result: ‘FutureResult’
[10:25:18.460] resolved() for ‘SequentialFuture’ ... done
[10:25:18.460] - resolved: TRUE
[10:25:18.460] - resolved() ... done
[10:25:18.460] resolved() for ‘SequentialFuture’ ... done
Plotting tile #4 of 4 ...
[10:25:18.460] signalConditions() ...
[10:25:18.460]  - include = ‘immediateCondition’
[10:25:18.461]  - exclude = 
[10:25:18.461]  - resignal = FALSE
[10:25:18.461]  - Number of conditions: 2
[10:25:18.461] signalConditions() ... done
[10:25:18.461] Future state: ‘finished’
[10:25:18.461] signalConditions() ...
[10:25:18.461]  - include = ‘condition’
[10:25:18.461]  - exclude = ‘immediateCondition’
[10:25:18.461]  - resignal = TRUE
[10:25:18.461]  - Number of conditions: 2
[10:25:18.461]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[10:25:18.462]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:25:18.462] signalConditions() ... done

> close.screen()
[1] 1 2 3 4

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('sequential') ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('multicore') ...
[10:25:18.468] plan(): Setting new future strategy stack:
[10:25:18.468] List of future strategies:
[10:25:18.468] 1. multicore:
[10:25:18.468]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:18.468]    - tweaked: FALSE
[10:25:18.468]    - call: plan(strategy)
[10:25:18.472] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 5 6 7 8

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[10:25:18.476] getGlobalsAndPackages() ...
[10:25:18.476] Searching for globals...
[10:25:18.479] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:25:18.480] Searching for globals ... DONE
[10:25:18.480] Resolving globals: FALSE
[10:25:18.480] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:25:18.481] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:25:18.481] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:25:18.481] - packages: [1] ‘future’
[10:25:18.481] getGlobalsAndPackages() ... DONE
 2[10:25:18.488] getGlobalsAndPackages() ...
[10:25:18.488] Searching for globals...
[10:25:18.491] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:25:18.491] Searching for globals ... DONE
[10:25:18.491] Resolving globals: FALSE
[10:25:18.492] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:25:18.492] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:25:18.493] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:25:18.493] - packages: [1] ‘future’
[10:25:18.493] getGlobalsAndPackages() ... DONE
 3[10:25:18.493] getGlobalsAndPackages() ...
[10:25:18.493] Searching for globals...
[10:25:18.497] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:25:18.497] Searching for globals ... DONE
[10:25:18.497] Resolving globals: FALSE
[10:25:18.497] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:25:18.498] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:25:18.498] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:25:18.498] - packages: [1] ‘future’
[10:25:18.498] getGlobalsAndPackages() ... DONE
 4[10:25:18.498] getGlobalsAndPackages() ...
[10:25:18.499] Searching for globals...
[10:25:18.502] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:25:18.502] Searching for globals ... DONE
[10:25:18.502] Resolving globals: FALSE
[10:25:18.503] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:25:18.503] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:25:18.503] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:25:18.503] - packages: [1] ‘future’
[10:25:18.503] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[10:25:18.512] resolved() for ‘Future’ ...
[10:25:18.512] - state: ‘created’
[10:25:18.512] - run: TRUE
[10:25:18.512] - run() ...
[10:25:18.512] run() for ‘Future’ ...
[10:25:18.513] - state: ‘created’
[10:25:18.513] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:18.517] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:18.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:18.517]   - Field: ‘label’
[10:25:18.517]   - Field: ‘local’
[10:25:18.517]   - Field: ‘owner’
[10:25:18.517]   - Field: ‘envir’
[10:25:18.518]   - Field: ‘workers’
[10:25:18.518]   - Field: ‘packages’
[10:25:18.518]   - Field: ‘gc’
[10:25:18.518]   - Field: ‘job’
[10:25:18.518]   - Field: ‘conditions’
[10:25:18.518]   - Field: ‘expr’
[10:25:18.518]   - Field: ‘uuid’
[10:25:18.518]   - Field: ‘seed’
[10:25:18.518]   - Field: ‘version’
[10:25:18.518]   - Field: ‘result’
[10:25:18.519]   - Field: ‘asynchronous’
[10:25:18.519]   - Field: ‘calls’
[10:25:18.519]   - Field: ‘globals’
[10:25:18.519]   - Field: ‘stdout’
[10:25:18.519]   - Field: ‘earlySignal’
[10:25:18.519]   - Field: ‘lazy’
[10:25:18.519]   - Field: ‘state’
[10:25:18.519] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:18.519] - Launch lazy future ...
[10:25:18.520] Packages needed by the future expression (n = 1): ‘future’
[10:25:18.521] Packages needed by future strategies (n = 0): <none>
[10:25:18.521] {
[10:25:18.521]     {
[10:25:18.521]         {
[10:25:18.521]             ...future.startTime <- base::Sys.time()
[10:25:18.521]             {
[10:25:18.521]                 {
[10:25:18.521]                   {
[10:25:18.521]                     {
[10:25:18.521]                       {
[10:25:18.521]                         base::local({
[10:25:18.521]                           has_future <- base::requireNamespace("future", 
[10:25:18.521]                             quietly = TRUE)
[10:25:18.521]                           if (has_future) {
[10:25:18.521]                             ns <- base::getNamespace("future")
[10:25:18.521]                             version <- ns[[".package"]][["version"]]
[10:25:18.521]                             if (is.null(version)) 
[10:25:18.521]                               version <- utils::packageVersion("future")
[10:25:18.521]                           }
[10:25:18.521]                           else {
[10:25:18.521]                             version <- NULL
[10:25:18.521]                           }
[10:25:18.521]                           if (!has_future || version < "1.8.0") {
[10:25:18.521]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:18.521]                               "", base::R.version$version.string), 
[10:25:18.521]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:18.521]                                 base::R.version$platform, 8 * 
[10:25:18.521]                                   base::.Machine$sizeof.pointer), 
[10:25:18.521]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:18.521]                                 "release", "version")], collapse = " "), 
[10:25:18.521]                               hostname = base::Sys.info()[["nodename"]])
[10:25:18.521]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:18.521]                               info)
[10:25:18.521]                             info <- base::paste(info, collapse = "; ")
[10:25:18.521]                             if (!has_future) {
[10:25:18.521]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:18.521]                                 info)
[10:25:18.521]                             }
[10:25:18.521]                             else {
[10:25:18.521]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:18.521]                                 info, version)
[10:25:18.521]                             }
[10:25:18.521]                             base::stop(msg)
[10:25:18.521]                           }
[10:25:18.521]                         })
[10:25:18.521]                       }
[10:25:18.521]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:18.521]                       base::options(mc.cores = 1L)
[10:25:18.521]                     }
[10:25:18.521]                     base::local({
[10:25:18.521]                       for (pkg in "future") {
[10:25:18.521]                         base::loadNamespace(pkg)
[10:25:18.521]                         base::library(pkg, character.only = TRUE)
[10:25:18.521]                       }
[10:25:18.521]                     })
[10:25:18.521]                   }
[10:25:18.521]                   options(future.plan = NULL)
[10:25:18.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:18.521]                 }
[10:25:18.521]                 ...future.workdir <- getwd()
[10:25:18.521]             }
[10:25:18.521]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:18.521]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:18.521]         }
[10:25:18.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:18.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:18.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:18.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:18.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:18.521]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:18.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:18.521]             base::names(...future.oldOptions))
[10:25:18.521]     }
[10:25:18.521]     if (FALSE) {
[10:25:18.521]     }
[10:25:18.521]     else {
[10:25:18.521]         if (TRUE) {
[10:25:18.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:18.521]                 open = "w")
[10:25:18.521]         }
[10:25:18.521]         else {
[10:25:18.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:18.521]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:18.521]         }
[10:25:18.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:18.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:18.521]             base::sink(type = "output", split = FALSE)
[10:25:18.521]             base::close(...future.stdout)
[10:25:18.521]         }, add = TRUE)
[10:25:18.521]     }
[10:25:18.521]     ...future.frame <- base::sys.nframe()
[10:25:18.521]     ...future.conditions <- base::list()
[10:25:18.521]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:18.521]     if (FALSE) {
[10:25:18.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:18.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:18.521]     }
[10:25:18.521]     ...future.result <- base::tryCatch({
[10:25:18.521]         base::withCallingHandlers({
[10:25:18.521]             ...future.value <- base::withVisible(base::local({
[10:25:18.521]                 withCallingHandlers({
[10:25:18.521]                   {
[10:25:18.521]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:25:18.521]                       ii, n), appendLF = FALSE)
[10:25:18.521]                     fit <- mandelbrot(C)
[10:25:18.521]                     delay(fit)
[10:25:18.521]                     message(" done")
[10:25:18.521]                     fit
[10:25:18.521]                   }
[10:25:18.521]                 }, immediateCondition = function(cond) {
[10:25:18.521]                   save_rds <- function (object, pathname, ...) 
[10:25:18.521]                   {
[10:25:18.521]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:18.521]                     if (file_test("-f", pathname_tmp)) {
[10:25:18.521]                       fi_tmp <- file.info(pathname_tmp)
[10:25:18.521]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:18.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:18.521]                         fi_tmp[["mtime"]])
[10:25:18.521]                     }
[10:25:18.521]                     tryCatch({
[10:25:18.521]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:18.521]                     }, error = function(ex) {
[10:25:18.521]                       msg <- conditionMessage(ex)
[10:25:18.521]                       fi_tmp <- file.info(pathname_tmp)
[10:25:18.521]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:18.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:18.521]                         fi_tmp[["mtime"]], msg)
[10:25:18.521]                       ex$message <- msg
[10:25:18.521]                       stop(ex)
[10:25:18.521]                     })
[10:25:18.521]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:18.521]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:18.521]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:18.521]                       fi_tmp <- file.info(pathname_tmp)
[10:25:18.521]                       fi <- file.info(pathname)
[10:25:18.521]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:18.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:18.521]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:18.521]                         fi[["size"]], fi[["mtime"]])
[10:25:18.521]                       stop(msg)
[10:25:18.521]                     }
[10:25:18.521]                     invisible(pathname)
[10:25:18.521]                   }
[10:25:18.521]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:18.521]                     rootPath = tempdir()) 
[10:25:18.521]                   {
[10:25:18.521]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:18.521]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:18.521]                       tmpdir = path, fileext = ".rds")
[10:25:18.521]                     save_rds(obj, file)
[10:25:18.521]                   }
[10:25:18.521]                   saveImmediateCondition(cond, path = "/tmp/RtmpLPVRk0/.future/immediateConditions")
[10:25:18.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.521]                   {
[10:25:18.521]                     inherits <- base::inherits
[10:25:18.521]                     invokeRestart <- base::invokeRestart
[10:25:18.521]                     is.null <- base::is.null
[10:25:18.521]                     muffled <- FALSE
[10:25:18.521]                     if (inherits(cond, "message")) {
[10:25:18.521]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:18.521]                       if (muffled) 
[10:25:18.521]                         invokeRestart("muffleMessage")
[10:25:18.521]                     }
[10:25:18.521]                     else if (inherits(cond, "warning")) {
[10:25:18.521]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:18.521]                       if (muffled) 
[10:25:18.521]                         invokeRestart("muffleWarning")
[10:25:18.521]                     }
[10:25:18.521]                     else if (inherits(cond, "condition")) {
[10:25:18.521]                       if (!is.null(pattern)) {
[10:25:18.521]                         computeRestarts <- base::computeRestarts
[10:25:18.521]                         grepl <- base::grepl
[10:25:18.521]                         restarts <- computeRestarts(cond)
[10:25:18.521]                         for (restart in restarts) {
[10:25:18.521]                           name <- restart$name
[10:25:18.521]                           if (is.null(name)) 
[10:25:18.521]                             next
[10:25:18.521]                           if (!grepl(pattern, name)) 
[10:25:18.521]                             next
[10:25:18.521]                           invokeRestart(restart)
[10:25:18.521]                           muffled <- TRUE
[10:25:18.521]                           break
[10:25:18.521]                         }
[10:25:18.521]                       }
[10:25:18.521]                     }
[10:25:18.521]                     invisible(muffled)
[10:25:18.521]                   }
[10:25:18.521]                   muffleCondition(cond)
[10:25:18.521]                 })
[10:25:18.521]             }))
[10:25:18.521]             future::FutureResult(value = ...future.value$value, 
[10:25:18.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.521]                   ...future.rng), globalenv = if (FALSE) 
[10:25:18.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:18.521]                     ...future.globalenv.names))
[10:25:18.521]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:18.521]         }, condition = base::local({
[10:25:18.521]             c <- base::c
[10:25:18.521]             inherits <- base::inherits
[10:25:18.521]             invokeRestart <- base::invokeRestart
[10:25:18.521]             length <- base::length
[10:25:18.521]             list <- base::list
[10:25:18.521]             seq.int <- base::seq.int
[10:25:18.521]             signalCondition <- base::signalCondition
[10:25:18.521]             sys.calls <- base::sys.calls
[10:25:18.521]             `[[` <- base::`[[`
[10:25:18.521]             `+` <- base::`+`
[10:25:18.521]             `<<-` <- base::`<<-`
[10:25:18.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:18.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:18.521]                   3L)]
[10:25:18.521]             }
[10:25:18.521]             function(cond) {
[10:25:18.521]                 is_error <- inherits(cond, "error")
[10:25:18.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:18.521]                   NULL)
[10:25:18.521]                 if (is_error) {
[10:25:18.521]                   sessionInformation <- function() {
[10:25:18.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:18.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:18.521]                       search = base::search(), system = base::Sys.info())
[10:25:18.521]                   }
[10:25:18.521]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:18.521]                     cond$call), session = sessionInformation(), 
[10:25:18.521]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:18.521]                   signalCondition(cond)
[10:25:18.521]                 }
[10:25:18.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:18.521]                 "immediateCondition"))) {
[10:25:18.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:18.521]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:18.521]                   if (TRUE && !signal) {
[10:25:18.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.521]                     {
[10:25:18.521]                       inherits <- base::inherits
[10:25:18.521]                       invokeRestart <- base::invokeRestart
[10:25:18.521]                       is.null <- base::is.null
[10:25:18.521]                       muffled <- FALSE
[10:25:18.521]                       if (inherits(cond, "message")) {
[10:25:18.521]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.521]                         if (muffled) 
[10:25:18.521]                           invokeRestart("muffleMessage")
[10:25:18.521]                       }
[10:25:18.521]                       else if (inherits(cond, "warning")) {
[10:25:18.521]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.521]                         if (muffled) 
[10:25:18.521]                           invokeRestart("muffleWarning")
[10:25:18.521]                       }
[10:25:18.521]                       else if (inherits(cond, "condition")) {
[10:25:18.521]                         if (!is.null(pattern)) {
[10:25:18.521]                           computeRestarts <- base::computeRestarts
[10:25:18.521]                           grepl <- base::grepl
[10:25:18.521]                           restarts <- computeRestarts(cond)
[10:25:18.521]                           for (restart in restarts) {
[10:25:18.521]                             name <- restart$name
[10:25:18.521]                             if (is.null(name)) 
[10:25:18.521]                               next
[10:25:18.521]                             if (!grepl(pattern, name)) 
[10:25:18.521]                               next
[10:25:18.521]                             invokeRestart(restart)
[10:25:18.521]                             muffled <- TRUE
[10:25:18.521]                             break
[10:25:18.521]                           }
[10:25:18.521]                         }
[10:25:18.521]                       }
[10:25:18.521]                       invisible(muffled)
[10:25:18.521]                     }
[10:25:18.521]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.521]                   }
[10:25:18.521]                 }
[10:25:18.521]                 else {
[10:25:18.521]                   if (TRUE) {
[10:25:18.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.521]                     {
[10:25:18.521]                       inherits <- base::inherits
[10:25:18.521]                       invokeRestart <- base::invokeRestart
[10:25:18.521]                       is.null <- base::is.null
[10:25:18.521]                       muffled <- FALSE
[10:25:18.521]                       if (inherits(cond, "message")) {
[10:25:18.521]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.521]                         if (muffled) 
[10:25:18.521]                           invokeRestart("muffleMessage")
[10:25:18.521]                       }
[10:25:18.521]                       else if (inherits(cond, "warning")) {
[10:25:18.521]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.521]                         if (muffled) 
[10:25:18.521]                           invokeRestart("muffleWarning")
[10:25:18.521]                       }
[10:25:18.521]                       else if (inherits(cond, "condition")) {
[10:25:18.521]                         if (!is.null(pattern)) {
[10:25:18.521]                           computeRestarts <- base::computeRestarts
[10:25:18.521]                           grepl <- base::grepl
[10:25:18.521]                           restarts <- computeRestarts(cond)
[10:25:18.521]                           for (restart in restarts) {
[10:25:18.521]                             name <- restart$name
[10:25:18.521]                             if (is.null(name)) 
[10:25:18.521]                               next
[10:25:18.521]                             if (!grepl(pattern, name)) 
[10:25:18.521]                               next
[10:25:18.521]                             invokeRestart(restart)
[10:25:18.521]                             muffled <- TRUE
[10:25:18.521]                             break
[10:25:18.521]                           }
[10:25:18.521]                         }
[10:25:18.521]                       }
[10:25:18.521]                       invisible(muffled)
[10:25:18.521]                     }
[10:25:18.521]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.521]                   }
[10:25:18.521]                 }
[10:25:18.521]             }
[10:25:18.521]         }))
[10:25:18.521]     }, error = function(ex) {
[10:25:18.521]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:18.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.521]                 ...future.rng), started = ...future.startTime, 
[10:25:18.521]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:18.521]             version = "1.8"), class = "FutureResult")
[10:25:18.521]     }, finally = {
[10:25:18.521]         if (!identical(...future.workdir, getwd())) 
[10:25:18.521]             setwd(...future.workdir)
[10:25:18.521]         {
[10:25:18.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:18.521]                 ...future.oldOptions$nwarnings <- NULL
[10:25:18.521]             }
[10:25:18.521]             base::options(...future.oldOptions)
[10:25:18.521]             if (.Platform$OS.type == "windows") {
[10:25:18.521]                 old_names <- names(...future.oldEnvVars)
[10:25:18.521]                 envs <- base::Sys.getenv()
[10:25:18.521]                 names <- names(envs)
[10:25:18.521]                 common <- intersect(names, old_names)
[10:25:18.521]                 added <- setdiff(names, old_names)
[10:25:18.521]                 removed <- setdiff(old_names, names)
[10:25:18.521]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:18.521]                   envs[common]]
[10:25:18.521]                 NAMES <- toupper(changed)
[10:25:18.521]                 args <- list()
[10:25:18.521]                 for (kk in seq_along(NAMES)) {
[10:25:18.521]                   name <- changed[[kk]]
[10:25:18.521]                   NAME <- NAMES[[kk]]
[10:25:18.521]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.521]                     next
[10:25:18.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.521]                 }
[10:25:18.521]                 NAMES <- toupper(added)
[10:25:18.521]                 for (kk in seq_along(NAMES)) {
[10:25:18.521]                   name <- added[[kk]]
[10:25:18.521]                   NAME <- NAMES[[kk]]
[10:25:18.521]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.521]                     next
[10:25:18.521]                   args[[name]] <- ""
[10:25:18.521]                 }
[10:25:18.521]                 NAMES <- toupper(removed)
[10:25:18.521]                 for (kk in seq_along(NAMES)) {
[10:25:18.521]                   name <- removed[[kk]]
[10:25:18.521]                   NAME <- NAMES[[kk]]
[10:25:18.521]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.521]                     next
[10:25:18.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.521]                 }
[10:25:18.521]                 if (length(args) > 0) 
[10:25:18.521]                   base::do.call(base::Sys.setenv, args = args)
[10:25:18.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:18.521]             }
[10:25:18.521]             else {
[10:25:18.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:18.521]             }
[10:25:18.521]             {
[10:25:18.521]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:18.521]                   0L) {
[10:25:18.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:18.521]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:18.521]                   base::options(opts)
[10:25:18.521]                 }
[10:25:18.521]                 {
[10:25:18.521]                   {
[10:25:18.521]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:18.521]                     NULL
[10:25:18.521]                   }
[10:25:18.521]                   options(future.plan = NULL)
[10:25:18.521]                   if (is.na(NA_character_)) 
[10:25:18.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:18.521]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:18.521]                     envir = parent.frame()) 
[10:25:18.521]                   {
[10:25:18.521]                     default_workers <- missing(workers)
[10:25:18.521]                     if (is.function(workers)) 
[10:25:18.521]                       workers <- workers()
[10:25:18.521]                     workers <- structure(as.integer(workers), 
[10:25:18.521]                       class = class(workers))
[10:25:18.521]                     stop_if_not(is.finite(workers), workers >= 
[10:25:18.521]                       1L)
[10:25:18.521]                     if ((workers == 1L && !inherits(workers, 
[10:25:18.521]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:18.521]                       if (default_workers) 
[10:25:18.521]                         supportsMulticore(warn = TRUE)
[10:25:18.521]                       return(sequential(..., envir = envir))
[10:25:18.521]                     }
[10:25:18.521]                     oopts <- options(mc.cores = workers)
[10:25:18.521]                     on.exit(options(oopts))
[10:25:18.521]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:18.521]                       envir = envir)
[10:25:18.521]                     if (!future$lazy) 
[10:25:18.521]                       future <- run(future)
[10:25:18.521]                     invisible(future)
[10:25:18.521]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:18.521]                 }
[10:25:18.521]             }
[10:25:18.521]         }
[10:25:18.521]     })
[10:25:18.521]     if (TRUE) {
[10:25:18.521]         base::sink(type = "output", split = FALSE)
[10:25:18.521]         if (TRUE) {
[10:25:18.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:18.521]         }
[10:25:18.521]         else {
[10:25:18.521]             ...future.result["stdout"] <- base::list(NULL)
[10:25:18.521]         }
[10:25:18.521]         base::close(...future.stdout)
[10:25:18.521]         ...future.stdout <- NULL
[10:25:18.521]     }
[10:25:18.521]     ...future.result$conditions <- ...future.conditions
[10:25:18.521]     ...future.result$finished <- base::Sys.time()
[10:25:18.521]     ...future.result
[10:25:18.521] }
[10:25:18.524] assign_globals() ...
[10:25:18.524] List of 4
[10:25:18.524]  $ ii   : int 1
[10:25:18.524]  $ n    : int 4
[10:25:18.524]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[10:25:18.524]   ..- attr(*, "region")=List of 2
[10:25:18.524]   .. ..$ xrange: num [1:2] -2.25 -0.781
[10:25:18.524]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[10:25:18.524]   ..- attr(*, "tile")= int [1:2] 1 1
[10:25:18.524]  $ delay:function (counts)  
[10:25:18.524]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:25:18.524]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x563913686678> 
[10:25:18.524]  - attr(*, "where")=List of 4
[10:25:18.524]   ..$ ii   :<environment: R_EmptyEnv> 
[10:25:18.524]   ..$ n    :<environment: R_EmptyEnv> 
[10:25:18.524]   ..$ C    :<environment: R_EmptyEnv> 
[10:25:18.524]   ..$ delay:<environment: R_EmptyEnv> 
[10:25:18.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:18.524]  - attr(*, "resolved")= logi FALSE
[10:25:18.524]  - attr(*, "total_size")= num 14584
[10:25:18.524]  - attr(*, "already-done")= logi TRUE
[10:25:18.530] - copied ‘ii’ to environment
[10:25:18.530] - copied ‘n’ to environment
[10:25:18.530] - copied ‘C’ to environment
[10:25:18.530] - reassign environment for ‘delay’
[10:25:18.530] - copied ‘delay’ to environment
[10:25:18.530] assign_globals() ... done
[10:25:18.530] requestCore(): workers = 2
[10:25:18.534] MulticoreFuture started
[10:25:18.534] - Launch lazy future ... done
[10:25:18.534] run() for ‘MulticoreFuture’ ... done
[10:25:18.535] - run() ... done
[10:25:18.535] - resolved() ...
[10:25:18.535] plan(): Setting new future strategy stack:
[10:25:18.535] List of future strategies:
[10:25:18.535] 1. sequential:
[10:25:18.535]    - args: function (..., envir = parent.frame())
[10:25:18.535]    - tweaked: FALSE
[10:25:18.535]    - call: NULL
[10:25:18.536] plan(): nbrOfWorkers() = 1
[10:25:18.539] plan(): Setting new future strategy stack:
[10:25:18.540] List of future strategies:
[10:25:18.540] 1. multicore:
[10:25:18.540]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:18.540]    - tweaked: FALSE
[10:25:18.540]    - call: plan(strategy)
[10:25:18.545] plan(): nbrOfWorkers() = 2
[10:25:18.546] - resolved: TRUE
[10:25:18.546] - resolved() ... done
[10:25:18.546] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #1 of 4 ...
[10:25:18.547] result() for MulticoreFuture ...
[10:25:18.552] result() for MulticoreFuture ...
[10:25:18.552] result() for MulticoreFuture ... done
[10:25:18.552] signalConditions() ...
[10:25:18.552]  - include = ‘immediateCondition’
[10:25:18.552]  - exclude = 
[10:25:18.552]  - resignal = FALSE
[10:25:18.553]  - Number of conditions: 2
[10:25:18.553] signalConditions() ... done
[10:25:18.553] result() for MulticoreFuture ... done
[10:25:18.553] result() for MulticoreFuture ...
[10:25:18.553] result() for MulticoreFuture ... done
[10:25:18.553] signalConditions() ...
[10:25:18.553]  - include = ‘immediateCondition’
[10:25:18.553]  - exclude = 
[10:25:18.553]  - resignal = FALSE
[10:25:18.554]  - Number of conditions: 2
[10:25:18.554] signalConditions() ... done
[10:25:18.554] Future state: ‘finished’
[10:25:18.554] result() for MulticoreFuture ...
[10:25:18.554] result() for MulticoreFuture ... done
[10:25:18.554] signalConditions() ...
[10:25:18.554]  - include = ‘condition’
[10:25:18.554]  - exclude = ‘immediateCondition’
[10:25:18.555]  - resignal = TRUE
[10:25:18.555]  - Number of conditions: 2
[10:25:18.555]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[10:25:18.555]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:25:18.555] signalConditions() ... done
[10:25:18.556] resolved() for ‘Future’ ...
[10:25:18.556] - state: ‘created’
[10:25:18.556] - run: TRUE
[10:25:18.556] - run() ...
[10:25:18.556] run() for ‘Future’ ...
[10:25:18.557] - state: ‘created’
[10:25:18.557] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:18.561] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:18.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:18.561]   - Field: ‘label’
[10:25:18.561]   - Field: ‘local’
[10:25:18.561]   - Field: ‘owner’
[10:25:18.561]   - Field: ‘envir’
[10:25:18.562]   - Field: ‘workers’
[10:25:18.562]   - Field: ‘packages’
[10:25:18.562]   - Field: ‘gc’
[10:25:18.562]   - Field: ‘job’
[10:25:18.562]   - Field: ‘conditions’
[10:25:18.562]   - Field: ‘expr’
[10:25:18.562]   - Field: ‘uuid’
[10:25:18.562]   - Field: ‘seed’
[10:25:18.563]   - Field: ‘version’
[10:25:18.563]   - Field: ‘result’
[10:25:18.563]   - Field: ‘asynchronous’
[10:25:18.563]   - Field: ‘calls’
[10:25:18.563]   - Field: ‘globals’
[10:25:18.563]   - Field: ‘stdout’
[10:25:18.563]   - Field: ‘earlySignal’
[10:25:18.563]   - Field: ‘lazy’
[10:25:18.563]   - Field: ‘state’
[10:25:18.563] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:18.564] - Launch lazy future ...
[10:25:18.564] Packages needed by the future expression (n = 1): ‘future’
[10:25:18.564] Packages needed by future strategies (n = 0): <none>
[10:25:18.565] {
[10:25:18.565]     {
[10:25:18.565]         {
[10:25:18.565]             ...future.startTime <- base::Sys.time()
[10:25:18.565]             {
[10:25:18.565]                 {
[10:25:18.565]                   {
[10:25:18.565]                     {
[10:25:18.565]                       {
[10:25:18.565]                         base::local({
[10:25:18.565]                           has_future <- base::requireNamespace("future", 
[10:25:18.565]                             quietly = TRUE)
[10:25:18.565]                           if (has_future) {
[10:25:18.565]                             ns <- base::getNamespace("future")
[10:25:18.565]                             version <- ns[[".package"]][["version"]]
[10:25:18.565]                             if (is.null(version)) 
[10:25:18.565]                               version <- utils::packageVersion("future")
[10:25:18.565]                           }
[10:25:18.565]                           else {
[10:25:18.565]                             version <- NULL
[10:25:18.565]                           }
[10:25:18.565]                           if (!has_future || version < "1.8.0") {
[10:25:18.565]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:18.565]                               "", base::R.version$version.string), 
[10:25:18.565]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:18.565]                                 base::R.version$platform, 8 * 
[10:25:18.565]                                   base::.Machine$sizeof.pointer), 
[10:25:18.565]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:18.565]                                 "release", "version")], collapse = " "), 
[10:25:18.565]                               hostname = base::Sys.info()[["nodename"]])
[10:25:18.565]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:18.565]                               info)
[10:25:18.565]                             info <- base::paste(info, collapse = "; ")
[10:25:18.565]                             if (!has_future) {
[10:25:18.565]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:18.565]                                 info)
[10:25:18.565]                             }
[10:25:18.565]                             else {
[10:25:18.565]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:18.565]                                 info, version)
[10:25:18.565]                             }
[10:25:18.565]                             base::stop(msg)
[10:25:18.565]                           }
[10:25:18.565]                         })
[10:25:18.565]                       }
[10:25:18.565]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:18.565]                       base::options(mc.cores = 1L)
[10:25:18.565]                     }
[10:25:18.565]                     base::local({
[10:25:18.565]                       for (pkg in "future") {
[10:25:18.565]                         base::loadNamespace(pkg)
[10:25:18.565]                         base::library(pkg, character.only = TRUE)
[10:25:18.565]                       }
[10:25:18.565]                     })
[10:25:18.565]                   }
[10:25:18.565]                   options(future.plan = NULL)
[10:25:18.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:18.565]                 }
[10:25:18.565]                 ...future.workdir <- getwd()
[10:25:18.565]             }
[10:25:18.565]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:18.565]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:18.565]         }
[10:25:18.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:18.565]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:18.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:18.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:18.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:18.565]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:18.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:18.565]             base::names(...future.oldOptions))
[10:25:18.565]     }
[10:25:18.565]     if (FALSE) {
[10:25:18.565]     }
[10:25:18.565]     else {
[10:25:18.565]         if (TRUE) {
[10:25:18.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:18.565]                 open = "w")
[10:25:18.565]         }
[10:25:18.565]         else {
[10:25:18.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:18.565]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:18.565]         }
[10:25:18.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:18.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:18.565]             base::sink(type = "output", split = FALSE)
[10:25:18.565]             base::close(...future.stdout)
[10:25:18.565]         }, add = TRUE)
[10:25:18.565]     }
[10:25:18.565]     ...future.frame <- base::sys.nframe()
[10:25:18.565]     ...future.conditions <- base::list()
[10:25:18.565]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:18.565]     if (FALSE) {
[10:25:18.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:18.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:18.565]     }
[10:25:18.565]     ...future.result <- base::tryCatch({
[10:25:18.565]         base::withCallingHandlers({
[10:25:18.565]             ...future.value <- base::withVisible(base::local({
[10:25:18.565]                 withCallingHandlers({
[10:25:18.565]                   {
[10:25:18.565]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:25:18.565]                       ii, n), appendLF = FALSE)
[10:25:18.565]                     fit <- mandelbrot(C)
[10:25:18.565]                     delay(fit)
[10:25:18.565]                     message(" done")
[10:25:18.565]                     fit
[10:25:18.565]                   }
[10:25:18.565]                 }, immediateCondition = function(cond) {
[10:25:18.565]                   save_rds <- function (object, pathname, ...) 
[10:25:18.565]                   {
[10:25:18.565]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:18.565]                     if (file_test("-f", pathname_tmp)) {
[10:25:18.565]                       fi_tmp <- file.info(pathname_tmp)
[10:25:18.565]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:18.565]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:18.565]                         fi_tmp[["mtime"]])
[10:25:18.565]                     }
[10:25:18.565]                     tryCatch({
[10:25:18.565]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:18.565]                     }, error = function(ex) {
[10:25:18.565]                       msg <- conditionMessage(ex)
[10:25:18.565]                       fi_tmp <- file.info(pathname_tmp)
[10:25:18.565]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:18.565]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:18.565]                         fi_tmp[["mtime"]], msg)
[10:25:18.565]                       ex$message <- msg
[10:25:18.565]                       stop(ex)
[10:25:18.565]                     })
[10:25:18.565]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:18.565]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:18.565]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:18.565]                       fi_tmp <- file.info(pathname_tmp)
[10:25:18.565]                       fi <- file.info(pathname)
[10:25:18.565]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:18.565]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:18.565]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:18.565]                         fi[["size"]], fi[["mtime"]])
[10:25:18.565]                       stop(msg)
[10:25:18.565]                     }
[10:25:18.565]                     invisible(pathname)
[10:25:18.565]                   }
[10:25:18.565]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:18.565]                     rootPath = tempdir()) 
[10:25:18.565]                   {
[10:25:18.565]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:18.565]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:18.565]                       tmpdir = path, fileext = ".rds")
[10:25:18.565]                     save_rds(obj, file)
[10:25:18.565]                   }
[10:25:18.565]                   saveImmediateCondition(cond, path = "/tmp/RtmpLPVRk0/.future/immediateConditions")
[10:25:18.565]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.565]                   {
[10:25:18.565]                     inherits <- base::inherits
[10:25:18.565]                     invokeRestart <- base::invokeRestart
[10:25:18.565]                     is.null <- base::is.null
[10:25:18.565]                     muffled <- FALSE
[10:25:18.565]                     if (inherits(cond, "message")) {
[10:25:18.565]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:18.565]                       if (muffled) 
[10:25:18.565]                         invokeRestart("muffleMessage")
[10:25:18.565]                     }
[10:25:18.565]                     else if (inherits(cond, "warning")) {
[10:25:18.565]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:18.565]                       if (muffled) 
[10:25:18.565]                         invokeRestart("muffleWarning")
[10:25:18.565]                     }
[10:25:18.565]                     else if (inherits(cond, "condition")) {
[10:25:18.565]                       if (!is.null(pattern)) {
[10:25:18.565]                         computeRestarts <- base::computeRestarts
[10:25:18.565]                         grepl <- base::grepl
[10:25:18.565]                         restarts <- computeRestarts(cond)
[10:25:18.565]                         for (restart in restarts) {
[10:25:18.565]                           name <- restart$name
[10:25:18.565]                           if (is.null(name)) 
[10:25:18.565]                             next
[10:25:18.565]                           if (!grepl(pattern, name)) 
[10:25:18.565]                             next
[10:25:18.565]                           invokeRestart(restart)
[10:25:18.565]                           muffled <- TRUE
[10:25:18.565]                           break
[10:25:18.565]                         }
[10:25:18.565]                       }
[10:25:18.565]                     }
[10:25:18.565]                     invisible(muffled)
[10:25:18.565]                   }
[10:25:18.565]                   muffleCondition(cond)
[10:25:18.565]                 })
[10:25:18.565]             }))
[10:25:18.565]             future::FutureResult(value = ...future.value$value, 
[10:25:18.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.565]                   ...future.rng), globalenv = if (FALSE) 
[10:25:18.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:18.565]                     ...future.globalenv.names))
[10:25:18.565]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:18.565]         }, condition = base::local({
[10:25:18.565]             c <- base::c
[10:25:18.565]             inherits <- base::inherits
[10:25:18.565]             invokeRestart <- base::invokeRestart
[10:25:18.565]             length <- base::length
[10:25:18.565]             list <- base::list
[10:25:18.565]             seq.int <- base::seq.int
[10:25:18.565]             signalCondition <- base::signalCondition
[10:25:18.565]             sys.calls <- base::sys.calls
[10:25:18.565]             `[[` <- base::`[[`
[10:25:18.565]             `+` <- base::`+`
[10:25:18.565]             `<<-` <- base::`<<-`
[10:25:18.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:18.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:18.565]                   3L)]
[10:25:18.565]             }
[10:25:18.565]             function(cond) {
[10:25:18.565]                 is_error <- inherits(cond, "error")
[10:25:18.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:18.565]                   NULL)
[10:25:18.565]                 if (is_error) {
[10:25:18.565]                   sessionInformation <- function() {
[10:25:18.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:18.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:18.565]                       search = base::search(), system = base::Sys.info())
[10:25:18.565]                   }
[10:25:18.565]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:18.565]                     cond$call), session = sessionInformation(), 
[10:25:18.565]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:18.565]                   signalCondition(cond)
[10:25:18.565]                 }
[10:25:18.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:18.565]                 "immediateCondition"))) {
[10:25:18.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:18.565]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:18.565]                   if (TRUE && !signal) {
[10:25:18.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.565]                     {
[10:25:18.565]                       inherits <- base::inherits
[10:25:18.565]                       invokeRestart <- base::invokeRestart
[10:25:18.565]                       is.null <- base::is.null
[10:25:18.565]                       muffled <- FALSE
[10:25:18.565]                       if (inherits(cond, "message")) {
[10:25:18.565]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.565]                         if (muffled) 
[10:25:18.565]                           invokeRestart("muffleMessage")
[10:25:18.565]                       }
[10:25:18.565]                       else if (inherits(cond, "warning")) {
[10:25:18.565]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.565]                         if (muffled) 
[10:25:18.565]                           invokeRestart("muffleWarning")
[10:25:18.565]                       }
[10:25:18.565]                       else if (inherits(cond, "condition")) {
[10:25:18.565]                         if (!is.null(pattern)) {
[10:25:18.565]                           computeRestarts <- base::computeRestarts
[10:25:18.565]                           grepl <- base::grepl
[10:25:18.565]                           restarts <- computeRestarts(cond)
[10:25:18.565]                           for (restart in restarts) {
[10:25:18.565]                             name <- restart$name
[10:25:18.565]                             if (is.null(name)) 
[10:25:18.565]                               next
[10:25:18.565]                             if (!grepl(pattern, name)) 
[10:25:18.565]                               next
[10:25:18.565]                             invokeRestart(restart)
[10:25:18.565]                             muffled <- TRUE
[10:25:18.565]                             break
[10:25:18.565]                           }
[10:25:18.565]                         }
[10:25:18.565]                       }
[10:25:18.565]                       invisible(muffled)
[10:25:18.565]                     }
[10:25:18.565]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.565]                   }
[10:25:18.565]                 }
[10:25:18.565]                 else {
[10:25:18.565]                   if (TRUE) {
[10:25:18.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.565]                     {
[10:25:18.565]                       inherits <- base::inherits
[10:25:18.565]                       invokeRestart <- base::invokeRestart
[10:25:18.565]                       is.null <- base::is.null
[10:25:18.565]                       muffled <- FALSE
[10:25:18.565]                       if (inherits(cond, "message")) {
[10:25:18.565]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.565]                         if (muffled) 
[10:25:18.565]                           invokeRestart("muffleMessage")
[10:25:18.565]                       }
[10:25:18.565]                       else if (inherits(cond, "warning")) {
[10:25:18.565]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.565]                         if (muffled) 
[10:25:18.565]                           invokeRestart("muffleWarning")
[10:25:18.565]                       }
[10:25:18.565]                       else if (inherits(cond, "condition")) {
[10:25:18.565]                         if (!is.null(pattern)) {
[10:25:18.565]                           computeRestarts <- base::computeRestarts
[10:25:18.565]                           grepl <- base::grepl
[10:25:18.565]                           restarts <- computeRestarts(cond)
[10:25:18.565]                           for (restart in restarts) {
[10:25:18.565]                             name <- restart$name
[10:25:18.565]                             if (is.null(name)) 
[10:25:18.565]                               next
[10:25:18.565]                             if (!grepl(pattern, name)) 
[10:25:18.565]                               next
[10:25:18.565]                             invokeRestart(restart)
[10:25:18.565]                             muffled <- TRUE
[10:25:18.565]                             break
[10:25:18.565]                           }
[10:25:18.565]                         }
[10:25:18.565]                       }
[10:25:18.565]                       invisible(muffled)
[10:25:18.565]                     }
[10:25:18.565]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.565]                   }
[10:25:18.565]                 }
[10:25:18.565]             }
[10:25:18.565]         }))
[10:25:18.565]     }, error = function(ex) {
[10:25:18.565]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:18.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.565]                 ...future.rng), started = ...future.startTime, 
[10:25:18.565]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:18.565]             version = "1.8"), class = "FutureResult")
[10:25:18.565]     }, finally = {
[10:25:18.565]         if (!identical(...future.workdir, getwd())) 
[10:25:18.565]             setwd(...future.workdir)
[10:25:18.565]         {
[10:25:18.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:18.565]                 ...future.oldOptions$nwarnings <- NULL
[10:25:18.565]             }
[10:25:18.565]             base::options(...future.oldOptions)
[10:25:18.565]             if (.Platform$OS.type == "windows") {
[10:25:18.565]                 old_names <- names(...future.oldEnvVars)
[10:25:18.565]                 envs <- base::Sys.getenv()
[10:25:18.565]                 names <- names(envs)
[10:25:18.565]                 common <- intersect(names, old_names)
[10:25:18.565]                 added <- setdiff(names, old_names)
[10:25:18.565]                 removed <- setdiff(old_names, names)
[10:25:18.565]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:18.565]                   envs[common]]
[10:25:18.565]                 NAMES <- toupper(changed)
[10:25:18.565]                 args <- list()
[10:25:18.565]                 for (kk in seq_along(NAMES)) {
[10:25:18.565]                   name <- changed[[kk]]
[10:25:18.565]                   NAME <- NAMES[[kk]]
[10:25:18.565]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.565]                     next
[10:25:18.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.565]                 }
[10:25:18.565]                 NAMES <- toupper(added)
[10:25:18.565]                 for (kk in seq_along(NAMES)) {
[10:25:18.565]                   name <- added[[kk]]
[10:25:18.565]                   NAME <- NAMES[[kk]]
[10:25:18.565]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.565]                     next
[10:25:18.565]                   args[[name]] <- ""
[10:25:18.565]                 }
[10:25:18.565]                 NAMES <- toupper(removed)
[10:25:18.565]                 for (kk in seq_along(NAMES)) {
[10:25:18.565]                   name <- removed[[kk]]
[10:25:18.565]                   NAME <- NAMES[[kk]]
[10:25:18.565]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.565]                     next
[10:25:18.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.565]                 }
[10:25:18.565]                 if (length(args) > 0) 
[10:25:18.565]                   base::do.call(base::Sys.setenv, args = args)
[10:25:18.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:18.565]             }
[10:25:18.565]             else {
[10:25:18.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:18.565]             }
[10:25:18.565]             {
[10:25:18.565]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:18.565]                   0L) {
[10:25:18.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:18.565]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:18.565]                   base::options(opts)
[10:25:18.565]                 }
[10:25:18.565]                 {
[10:25:18.565]                   {
[10:25:18.565]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:18.565]                     NULL
[10:25:18.565]                   }
[10:25:18.565]                   options(future.plan = NULL)
[10:25:18.565]                   if (is.na(NA_character_)) 
[10:25:18.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:18.565]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:18.565]                     envir = parent.frame()) 
[10:25:18.565]                   {
[10:25:18.565]                     default_workers <- missing(workers)
[10:25:18.565]                     if (is.function(workers)) 
[10:25:18.565]                       workers <- workers()
[10:25:18.565]                     workers <- structure(as.integer(workers), 
[10:25:18.565]                       class = class(workers))
[10:25:18.565]                     stop_if_not(is.finite(workers), workers >= 
[10:25:18.565]                       1L)
[10:25:18.565]                     if ((workers == 1L && !inherits(workers, 
[10:25:18.565]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:18.565]                       if (default_workers) 
[10:25:18.565]                         supportsMulticore(warn = TRUE)
[10:25:18.565]                       return(sequential(..., envir = envir))
[10:25:18.565]                     }
[10:25:18.565]                     oopts <- options(mc.cores = workers)
[10:25:18.565]                     on.exit(options(oopts))
[10:25:18.565]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:18.565]                       envir = envir)
[10:25:18.565]                     if (!future$lazy) 
[10:25:18.565]                       future <- run(future)
[10:25:18.565]                     invisible(future)
[10:25:18.565]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:18.565]                 }
[10:25:18.565]             }
[10:25:18.565]         }
[10:25:18.565]     })
[10:25:18.565]     if (TRUE) {
[10:25:18.565]         base::sink(type = "output", split = FALSE)
[10:25:18.565]         if (TRUE) {
[10:25:18.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:18.565]         }
[10:25:18.565]         else {
[10:25:18.565]             ...future.result["stdout"] <- base::list(NULL)
[10:25:18.565]         }
[10:25:18.565]         base::close(...future.stdout)
[10:25:18.565]         ...future.stdout <- NULL
[10:25:18.565]     }
[10:25:18.565]     ...future.result$conditions <- ...future.conditions
[10:25:18.565]     ...future.result$finished <- base::Sys.time()
[10:25:18.565]     ...future.result
[10:25:18.565] }
[10:25:18.568] assign_globals() ...
[10:25:18.568] List of 4
[10:25:18.568]  $ ii   : int 2
[10:25:18.568]  $ n    : int 4
[10:25:18.568]  $ C    : cplx [1:25, 1:25] -0.72-1.5i -0.72-1.44i -0.72-1.38i ...
[10:25:18.568]   ..- attr(*, "region")=List of 2
[10:25:18.568]   .. ..$ xrange: num [1:2] -0.719 0.75
[10:25:18.568]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[10:25:18.568]   ..- attr(*, "tile")= int [1:2] 1 2
[10:25:18.568]  $ delay:function (counts)  
[10:25:18.568]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:25:18.568]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x563913686678> 
[10:25:18.568]  - attr(*, "where")=List of 4
[10:25:18.568]   ..$ ii   :<environment: R_EmptyEnv> 
[10:25:18.568]   ..$ n    :<environment: R_EmptyEnv> 
[10:25:18.568]   ..$ C    :<environment: R_EmptyEnv> 
[10:25:18.568]   ..$ delay:<environment: R_EmptyEnv> 
[10:25:18.568]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:18.568]  - attr(*, "resolved")= logi FALSE
[10:25:18.568]  - attr(*, "total_size")= num 14584
[10:25:18.568]  - attr(*, "already-done")= logi TRUE
[10:25:18.579] - copied ‘ii’ to environment
[10:25:18.579] - copied ‘n’ to environment
[10:25:18.579] - copied ‘C’ to environment
[10:25:18.579] - reassign environment for ‘delay’
[10:25:18.579] - copied ‘delay’ to environment
[10:25:18.579] assign_globals() ... done
[10:25:18.579] requestCore(): workers = 2
[10:25:18.582] MulticoreFuture started
[10:25:18.582] - Launch lazy future ... done
[10:25:18.582] run() for ‘MulticoreFuture’ ... done
[10:25:18.583] - run() ... done
[10:25:18.583] - resolved() ...
[10:25:18.583] plan(): Setting new future strategy stack:
[10:25:18.584] List of future strategies:
[10:25:18.584] 1. sequential:
[10:25:18.584]    - args: function (..., envir = parent.frame())
[10:25:18.584]    - tweaked: FALSE
[10:25:18.584]    - call: NULL
[10:25:18.585] plan(): nbrOfWorkers() = 1
[10:25:18.590] plan(): Setting new future strategy stack:
[10:25:18.590] List of future strategies:
[10:25:18.590] 1. multicore:
[10:25:18.590]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:18.590]    - tweaked: FALSE
[10:25:18.590]    - call: plan(strategy)
[10:25:18.593] - resolved: FALSE
[10:25:18.594] - resolved() ... done
[10:25:18.594] resolved() for ‘MulticoreFuture’ ... done
[10:25:18.594] resolved() for ‘Future’ ...
[10:25:18.594] - state: ‘created’
[10:25:18.594] - run: TRUE
[10:25:18.594] - run() ...
[10:25:18.594] run() for ‘Future’ ...
[10:25:18.595] - state: ‘created’
[10:25:18.595] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:18.595] plan(): nbrOfWorkers() = 2
[10:25:18.599] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:18.600] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:18.600]   - Field: ‘label’
[10:25:18.600]   - Field: ‘local’
[10:25:18.600]   - Field: ‘owner’
[10:25:18.600]   - Field: ‘envir’
[10:25:18.600]   - Field: ‘workers’
[10:25:18.601]   - Field: ‘packages’
[10:25:18.601]   - Field: ‘gc’
[10:25:18.601]   - Field: ‘job’
[10:25:18.601]   - Field: ‘conditions’
[10:25:18.601]   - Field: ‘expr’
[10:25:18.601]   - Field: ‘uuid’
[10:25:18.602]   - Field: ‘seed’
[10:25:18.602]   - Field: ‘version’
[10:25:18.602]   - Field: ‘result’
[10:25:18.602]   - Field: ‘asynchronous’
[10:25:18.602]   - Field: ‘calls’
[10:25:18.602]   - Field: ‘globals’
[10:25:18.603]   - Field: ‘stdout’
[10:25:18.603]   - Field: ‘earlySignal’
[10:25:18.603]   - Field: ‘lazy’
[10:25:18.603]   - Field: ‘state’
[10:25:18.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:18.603] - Launch lazy future ...
[10:25:18.604] Packages needed by the future expression (n = 1): ‘future’
[10:25:18.604] Packages needed by future strategies (n = 0): <none>
[10:25:18.605] {
[10:25:18.605]     {
[10:25:18.605]         {
[10:25:18.605]             ...future.startTime <- base::Sys.time()
[10:25:18.605]             {
[10:25:18.605]                 {
[10:25:18.605]                   {
[10:25:18.605]                     {
[10:25:18.605]                       {
[10:25:18.605]                         base::local({
[10:25:18.605]                           has_future <- base::requireNamespace("future", 
[10:25:18.605]                             quietly = TRUE)
[10:25:18.605]                           if (has_future) {
[10:25:18.605]                             ns <- base::getNamespace("future")
[10:25:18.605]                             version <- ns[[".package"]][["version"]]
[10:25:18.605]                             if (is.null(version)) 
[10:25:18.605]                               version <- utils::packageVersion("future")
[10:25:18.605]                           }
[10:25:18.605]                           else {
[10:25:18.605]                             version <- NULL
[10:25:18.605]                           }
[10:25:18.605]                           if (!has_future || version < "1.8.0") {
[10:25:18.605]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:18.605]                               "", base::R.version$version.string), 
[10:25:18.605]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:18.605]                                 base::R.version$platform, 8 * 
[10:25:18.605]                                   base::.Machine$sizeof.pointer), 
[10:25:18.605]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:18.605]                                 "release", "version")], collapse = " "), 
[10:25:18.605]                               hostname = base::Sys.info()[["nodename"]])
[10:25:18.605]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:18.605]                               info)
[10:25:18.605]                             info <- base::paste(info, collapse = "; ")
[10:25:18.605]                             if (!has_future) {
[10:25:18.605]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:18.605]                                 info)
[10:25:18.605]                             }
[10:25:18.605]                             else {
[10:25:18.605]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:18.605]                                 info, version)
[10:25:18.605]                             }
[10:25:18.605]                             base::stop(msg)
[10:25:18.605]                           }
[10:25:18.605]                         })
[10:25:18.605]                       }
[10:25:18.605]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:18.605]                       base::options(mc.cores = 1L)
[10:25:18.605]                     }
[10:25:18.605]                     base::local({
[10:25:18.605]                       for (pkg in "future") {
[10:25:18.605]                         base::loadNamespace(pkg)
[10:25:18.605]                         base::library(pkg, character.only = TRUE)
[10:25:18.605]                       }
[10:25:18.605]                     })
[10:25:18.605]                   }
[10:25:18.605]                   options(future.plan = NULL)
[10:25:18.605]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.605]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:18.605]                 }
[10:25:18.605]                 ...future.workdir <- getwd()
[10:25:18.605]             }
[10:25:18.605]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:18.605]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:18.605]         }
[10:25:18.605]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:18.605]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:18.605]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:18.605]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:18.605]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:18.605]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:18.605]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:18.605]             base::names(...future.oldOptions))
[10:25:18.605]     }
[10:25:18.605]     if (FALSE) {
[10:25:18.605]     }
[10:25:18.605]     else {
[10:25:18.605]         if (TRUE) {
[10:25:18.605]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:18.605]                 open = "w")
[10:25:18.605]         }
[10:25:18.605]         else {
[10:25:18.605]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:18.605]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:18.605]         }
[10:25:18.605]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:18.605]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:18.605]             base::sink(type = "output", split = FALSE)
[10:25:18.605]             base::close(...future.stdout)
[10:25:18.605]         }, add = TRUE)
[10:25:18.605]     }
[10:25:18.605]     ...future.frame <- base::sys.nframe()
[10:25:18.605]     ...future.conditions <- base::list()
[10:25:18.605]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:18.605]     if (FALSE) {
[10:25:18.605]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:18.605]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:18.605]     }
[10:25:18.605]     ...future.result <- base::tryCatch({
[10:25:18.605]         base::withCallingHandlers({
[10:25:18.605]             ...future.value <- base::withVisible(base::local({
[10:25:18.605]                 withCallingHandlers({
[10:25:18.605]                   {
[10:25:18.605]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:25:18.605]                       ii, n), appendLF = FALSE)
[10:25:18.605]                     fit <- mandelbrot(C)
[10:25:18.605]                     delay(fit)
[10:25:18.605]                     message(" done")
[10:25:18.605]                     fit
[10:25:18.605]                   }
[10:25:18.605]                 }, immediateCondition = function(cond) {
[10:25:18.605]                   save_rds <- function (object, pathname, ...) 
[10:25:18.605]                   {
[10:25:18.605]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:18.605]                     if (file_test("-f", pathname_tmp)) {
[10:25:18.605]                       fi_tmp <- file.info(pathname_tmp)
[10:25:18.605]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:18.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:18.605]                         fi_tmp[["mtime"]])
[10:25:18.605]                     }
[10:25:18.605]                     tryCatch({
[10:25:18.605]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:18.605]                     }, error = function(ex) {
[10:25:18.605]                       msg <- conditionMessage(ex)
[10:25:18.605]                       fi_tmp <- file.info(pathname_tmp)
[10:25:18.605]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:18.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:18.605]                         fi_tmp[["mtime"]], msg)
[10:25:18.605]                       ex$message <- msg
[10:25:18.605]                       stop(ex)
[10:25:18.605]                     })
[10:25:18.605]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:18.605]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:18.605]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:18.605]                       fi_tmp <- file.info(pathname_tmp)
[10:25:18.605]                       fi <- file.info(pathname)
[10:25:18.605]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:18.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:18.605]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:18.605]                         fi[["size"]], fi[["mtime"]])
[10:25:18.605]                       stop(msg)
[10:25:18.605]                     }
[10:25:18.605]                     invisible(pathname)
[10:25:18.605]                   }
[10:25:18.605]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:18.605]                     rootPath = tempdir()) 
[10:25:18.605]                   {
[10:25:18.605]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:18.605]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:18.605]                       tmpdir = path, fileext = ".rds")
[10:25:18.605]                     save_rds(obj, file)
[10:25:18.605]                   }
[10:25:18.605]                   saveImmediateCondition(cond, path = "/tmp/RtmpLPVRk0/.future/immediateConditions")
[10:25:18.605]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.605]                   {
[10:25:18.605]                     inherits <- base::inherits
[10:25:18.605]                     invokeRestart <- base::invokeRestart
[10:25:18.605]                     is.null <- base::is.null
[10:25:18.605]                     muffled <- FALSE
[10:25:18.605]                     if (inherits(cond, "message")) {
[10:25:18.605]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:18.605]                       if (muffled) 
[10:25:18.605]                         invokeRestart("muffleMessage")
[10:25:18.605]                     }
[10:25:18.605]                     else if (inherits(cond, "warning")) {
[10:25:18.605]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:18.605]                       if (muffled) 
[10:25:18.605]                         invokeRestart("muffleWarning")
[10:25:18.605]                     }
[10:25:18.605]                     else if (inherits(cond, "condition")) {
[10:25:18.605]                       if (!is.null(pattern)) {
[10:25:18.605]                         computeRestarts <- base::computeRestarts
[10:25:18.605]                         grepl <- base::grepl
[10:25:18.605]                         restarts <- computeRestarts(cond)
[10:25:18.605]                         for (restart in restarts) {
[10:25:18.605]                           name <- restart$name
[10:25:18.605]                           if (is.null(name)) 
[10:25:18.605]                             next
[10:25:18.605]                           if (!grepl(pattern, name)) 
[10:25:18.605]                             next
[10:25:18.605]                           invokeRestart(restart)
[10:25:18.605]                           muffled <- TRUE
[10:25:18.605]                           break
[10:25:18.605]                         }
[10:25:18.605]                       }
[10:25:18.605]                     }
[10:25:18.605]                     invisible(muffled)
[10:25:18.605]                   }
[10:25:18.605]                   muffleCondition(cond)
[10:25:18.605]                 })
[10:25:18.605]             }))
[10:25:18.605]             future::FutureResult(value = ...future.value$value, 
[10:25:18.605]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.605]                   ...future.rng), globalenv = if (FALSE) 
[10:25:18.605]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:18.605]                     ...future.globalenv.names))
[10:25:18.605]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:18.605]         }, condition = base::local({
[10:25:18.605]             c <- base::c
[10:25:18.605]             inherits <- base::inherits
[10:25:18.605]             invokeRestart <- base::invokeRestart
[10:25:18.605]             length <- base::length
[10:25:18.605]             list <- base::list
[10:25:18.605]             seq.int <- base::seq.int
[10:25:18.605]             signalCondition <- base::signalCondition
[10:25:18.605]             sys.calls <- base::sys.calls
[10:25:18.605]             `[[` <- base::`[[`
[10:25:18.605]             `+` <- base::`+`
[10:25:18.605]             `<<-` <- base::`<<-`
[10:25:18.605]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:18.605]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:18.605]                   3L)]
[10:25:18.605]             }
[10:25:18.605]             function(cond) {
[10:25:18.605]                 is_error <- inherits(cond, "error")
[10:25:18.605]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:18.605]                   NULL)
[10:25:18.605]                 if (is_error) {
[10:25:18.605]                   sessionInformation <- function() {
[10:25:18.605]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:18.605]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:18.605]                       search = base::search(), system = base::Sys.info())
[10:25:18.605]                   }
[10:25:18.605]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.605]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:18.605]                     cond$call), session = sessionInformation(), 
[10:25:18.605]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:18.605]                   signalCondition(cond)
[10:25:18.605]                 }
[10:25:18.605]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:18.605]                 "immediateCondition"))) {
[10:25:18.605]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:18.605]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.605]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:18.605]                   if (TRUE && !signal) {
[10:25:18.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.605]                     {
[10:25:18.605]                       inherits <- base::inherits
[10:25:18.605]                       invokeRestart <- base::invokeRestart
[10:25:18.605]                       is.null <- base::is.null
[10:25:18.605]                       muffled <- FALSE
[10:25:18.605]                       if (inherits(cond, "message")) {
[10:25:18.605]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.605]                         if (muffled) 
[10:25:18.605]                           invokeRestart("muffleMessage")
[10:25:18.605]                       }
[10:25:18.605]                       else if (inherits(cond, "warning")) {
[10:25:18.605]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.605]                         if (muffled) 
[10:25:18.605]                           invokeRestart("muffleWarning")
[10:25:18.605]                       }
[10:25:18.605]                       else if (inherits(cond, "condition")) {
[10:25:18.605]                         if (!is.null(pattern)) {
[10:25:18.605]                           computeRestarts <- base::computeRestarts
[10:25:18.605]                           grepl <- base::grepl
[10:25:18.605]                           restarts <- computeRestarts(cond)
[10:25:18.605]                           for (restart in restarts) {
[10:25:18.605]                             name <- restart$name
[10:25:18.605]                             if (is.null(name)) 
[10:25:18.605]                               next
[10:25:18.605]                             if (!grepl(pattern, name)) 
[10:25:18.605]                               next
[10:25:18.605]                             invokeRestart(restart)
[10:25:18.605]                             muffled <- TRUE
[10:25:18.605]                             break
[10:25:18.605]                           }
[10:25:18.605]                         }
[10:25:18.605]                       }
[10:25:18.605]                       invisible(muffled)
[10:25:18.605]                     }
[10:25:18.605]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.605]                   }
[10:25:18.605]                 }
[10:25:18.605]                 else {
[10:25:18.605]                   if (TRUE) {
[10:25:18.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.605]                     {
[10:25:18.605]                       inherits <- base::inherits
[10:25:18.605]                       invokeRestart <- base::invokeRestart
[10:25:18.605]                       is.null <- base::is.null
[10:25:18.605]                       muffled <- FALSE
[10:25:18.605]                       if (inherits(cond, "message")) {
[10:25:18.605]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.605]                         if (muffled) 
[10:25:18.605]                           invokeRestart("muffleMessage")
[10:25:18.605]                       }
[10:25:18.605]                       else if (inherits(cond, "warning")) {
[10:25:18.605]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.605]                         if (muffled) 
[10:25:18.605]                           invokeRestart("muffleWarning")
[10:25:18.605]                       }
[10:25:18.605]                       else if (inherits(cond, "condition")) {
[10:25:18.605]                         if (!is.null(pattern)) {
[10:25:18.605]                           computeRestarts <- base::computeRestarts
[10:25:18.605]                           grepl <- base::grepl
[10:25:18.605]                           restarts <- computeRestarts(cond)
[10:25:18.605]                           for (restart in restarts) {
[10:25:18.605]                             name <- restart$name
[10:25:18.605]                             if (is.null(name)) 
[10:25:18.605]                               next
[10:25:18.605]                             if (!grepl(pattern, name)) 
[10:25:18.605]                               next
[10:25:18.605]                             invokeRestart(restart)
[10:25:18.605]                             muffled <- TRUE
[10:25:18.605]                             break
[10:25:18.605]                           }
[10:25:18.605]                         }
[10:25:18.605]                       }
[10:25:18.605]                       invisible(muffled)
[10:25:18.605]                     }
[10:25:18.605]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.605]                   }
[10:25:18.605]                 }
[10:25:18.605]             }
[10:25:18.605]         }))
[10:25:18.605]     }, error = function(ex) {
[10:25:18.605]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:18.605]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.605]                 ...future.rng), started = ...future.startTime, 
[10:25:18.605]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:18.605]             version = "1.8"), class = "FutureResult")
[10:25:18.605]     }, finally = {
[10:25:18.605]         if (!identical(...future.workdir, getwd())) 
[10:25:18.605]             setwd(...future.workdir)
[10:25:18.605]         {
[10:25:18.605]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:18.605]                 ...future.oldOptions$nwarnings <- NULL
[10:25:18.605]             }
[10:25:18.605]             base::options(...future.oldOptions)
[10:25:18.605]             if (.Platform$OS.type == "windows") {
[10:25:18.605]                 old_names <- names(...future.oldEnvVars)
[10:25:18.605]                 envs <- base::Sys.getenv()
[10:25:18.605]                 names <- names(envs)
[10:25:18.605]                 common <- intersect(names, old_names)
[10:25:18.605]                 added <- setdiff(names, old_names)
[10:25:18.605]                 removed <- setdiff(old_names, names)
[10:25:18.605]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:18.605]                   envs[common]]
[10:25:18.605]                 NAMES <- toupper(changed)
[10:25:18.605]                 args <- list()
[10:25:18.605]                 for (kk in seq_along(NAMES)) {
[10:25:18.605]                   name <- changed[[kk]]
[10:25:18.605]                   NAME <- NAMES[[kk]]
[10:25:18.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.605]                     next
[10:25:18.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.605]                 }
[10:25:18.605]                 NAMES <- toupper(added)
[10:25:18.605]                 for (kk in seq_along(NAMES)) {
[10:25:18.605]                   name <- added[[kk]]
[10:25:18.605]                   NAME <- NAMES[[kk]]
[10:25:18.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.605]                     next
[10:25:18.605]                   args[[name]] <- ""
[10:25:18.605]                 }
[10:25:18.605]                 NAMES <- toupper(removed)
[10:25:18.605]                 for (kk in seq_along(NAMES)) {
[10:25:18.605]                   name <- removed[[kk]]
[10:25:18.605]                   NAME <- NAMES[[kk]]
[10:25:18.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.605]                     next
[10:25:18.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.605]                 }
[10:25:18.605]                 if (length(args) > 0) 
[10:25:18.605]                   base::do.call(base::Sys.setenv, args = args)
[10:25:18.605]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:18.605]             }
[10:25:18.605]             else {
[10:25:18.605]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:18.605]             }
[10:25:18.605]             {
[10:25:18.605]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:18.605]                   0L) {
[10:25:18.605]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:18.605]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:18.605]                   base::options(opts)
[10:25:18.605]                 }
[10:25:18.605]                 {
[10:25:18.605]                   {
[10:25:18.605]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:18.605]                     NULL
[10:25:18.605]                   }
[10:25:18.605]                   options(future.plan = NULL)
[10:25:18.605]                   if (is.na(NA_character_)) 
[10:25:18.605]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.605]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:18.605]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:18.605]                     envir = parent.frame()) 
[10:25:18.605]                   {
[10:25:18.605]                     default_workers <- missing(workers)
[10:25:18.605]                     if (is.function(workers)) 
[10:25:18.605]                       workers <- workers()
[10:25:18.605]                     workers <- structure(as.integer(workers), 
[10:25:18.605]                       class = class(workers))
[10:25:18.605]                     stop_if_not(is.finite(workers), workers >= 
[10:25:18.605]                       1L)
[10:25:18.605]                     if ((workers == 1L && !inherits(workers, 
[10:25:18.605]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:18.605]                       if (default_workers) 
[10:25:18.605]                         supportsMulticore(warn = TRUE)
[10:25:18.605]                       return(sequential(..., envir = envir))
[10:25:18.605]                     }
[10:25:18.605]                     oopts <- options(mc.cores = workers)
[10:25:18.605]                     on.exit(options(oopts))
[10:25:18.605]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:18.605]                       envir = envir)
[10:25:18.605]                     if (!future$lazy) 
[10:25:18.605]                       future <- run(future)
[10:25:18.605]                     invisible(future)
[10:25:18.605]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:18.605]                 }
[10:25:18.605]             }
[10:25:18.605]         }
[10:25:18.605]     })
[10:25:18.605]     if (TRUE) {
[10:25:18.605]         base::sink(type = "output", split = FALSE)
[10:25:18.605]         if (TRUE) {
[10:25:18.605]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:18.605]         }
[10:25:18.605]         else {
[10:25:18.605]             ...future.result["stdout"] <- base::list(NULL)
[10:25:18.605]         }
[10:25:18.605]         base::close(...future.stdout)
[10:25:18.605]         ...future.stdout <- NULL
[10:25:18.605]     }
[10:25:18.605]     ...future.result$conditions <- ...future.conditions
[10:25:18.605]     ...future.result$finished <- base::Sys.time()
[10:25:18.605]     ...future.result
[10:25:18.605] }
[10:25:18.609] assign_globals() ...
[10:25:18.609] List of 4
[10:25:18.609]  $ ii   : int 3
[10:25:18.609]  $ n    : int 4
[10:25:18.609]  $ C    : cplx [1:25, 1:25] -2.25+0.03i -2.25+0.09i -2.25+0.15i ...
[10:25:18.609]   ..- attr(*, "region")=List of 2
[10:25:18.609]   .. ..$ xrange: num [1:2] -2.25 -0.781
[10:25:18.609]   .. ..$ yrange: num [1:2] 0.0306 1.5
[10:25:18.609]   ..- attr(*, "tile")= int [1:2] 2 1
[10:25:18.609]  $ delay:function (counts)  
[10:25:18.609]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:25:18.609]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x563913686678> 
[10:25:18.609]  - attr(*, "where")=List of 4
[10:25:18.609]   ..$ ii   :<environment: R_EmptyEnv> 
[10:25:18.609]   ..$ n    :<environment: R_EmptyEnv> 
[10:25:18.609]   ..$ C    :<environment: R_EmptyEnv> 
[10:25:18.609]   ..$ delay:<environment: R_EmptyEnv> 
[10:25:18.609]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:18.609]  - attr(*, "resolved")= logi FALSE
[10:25:18.609]  - attr(*, "total_size")= num 14584
[10:25:18.609]  - attr(*, "already-done")= logi TRUE
[10:25:18.619] - copied ‘ii’ to environment
[10:25:18.619] - copied ‘n’ to environment
[10:25:18.619] - copied ‘C’ to environment
[10:25:18.620] - reassign environment for ‘delay’
[10:25:18.620] - copied ‘delay’ to environment
[10:25:18.620] assign_globals() ... done
[10:25:18.620] requestCore(): workers = 2
[10:25:18.623] MulticoreFuture started
[10:25:18.623] - Launch lazy future ... done
[10:25:18.624] run() for ‘MulticoreFuture’ ... done
[10:25:18.624] - run() ... done
[10:25:18.624] - resolved() ...
[10:25:18.625] plan(): Setting new future strategy stack:
[10:25:18.625] List of future strategies:
[10:25:18.625] 1. sequential:
[10:25:18.625]    - args: function (..., envir = parent.frame())
[10:25:18.625]    - tweaked: FALSE
[10:25:18.625]    - call: NULL
[10:25:18.626] plan(): nbrOfWorkers() = 1
[10:25:18.630] plan(): Setting new future strategy stack:
[10:25:18.631] List of future strategies:
[10:25:18.631] 1. multicore:
[10:25:18.631]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:18.631]    - tweaked: FALSE
[10:25:18.631]    - call: plan(strategy)
[10:25:18.635] - resolved: FALSE
[10:25:18.635] - resolved() ... done
[10:25:18.635] resolved() for ‘MulticoreFuture’ ... done
[10:25:18.635] resolved() for ‘Future’ ...
[10:25:18.636] - state: ‘created’
[10:25:18.636] - run: TRUE
[10:25:18.636] - run() ...
[10:25:18.637] run() for ‘Future’ ...
[10:25:18.637] - state: ‘created’
[10:25:18.637] plan(): nbrOfWorkers() = 2
[10:25:18.637] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:18.643] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:18.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:18.643]   - Field: ‘label’
[10:25:18.643]   - Field: ‘local’
[10:25:18.644]   - Field: ‘owner’
[10:25:18.644]   - Field: ‘envir’
[10:25:18.644]   - Field: ‘workers’
[10:25:18.644]   - Field: ‘packages’
[10:25:18.644]   - Field: ‘gc’
[10:25:18.645]   - Field: ‘job’
[10:25:18.645]   - Field: ‘conditions’
[10:25:18.645]   - Field: ‘expr’
[10:25:18.645]   - Field: ‘uuid’
[10:25:18.645]   - Field: ‘seed’
[10:25:18.645]   - Field: ‘version’
[10:25:18.646]   - Field: ‘result’
[10:25:18.646]   - Field: ‘asynchronous’
[10:25:18.646]   - Field: ‘calls’
[10:25:18.646]   - Field: ‘globals’
[10:25:18.646]   - Field: ‘stdout’
[10:25:18.646]   - Field: ‘earlySignal’
[10:25:18.646]   - Field: ‘lazy’
[10:25:18.647]   - Field: ‘state’
[10:25:18.647] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:18.647] - Launch lazy future ...
[10:25:18.647] Packages needed by the future expression (n = 1): ‘future’
[10:25:18.648] Packages needed by future strategies (n = 0): <none>
[10:25:18.649] {
[10:25:18.649]     {
[10:25:18.649]         {
[10:25:18.649]             ...future.startTime <- base::Sys.time()
[10:25:18.649]             {
[10:25:18.649]                 {
[10:25:18.649]                   {
[10:25:18.649]                     {
[10:25:18.649]                       {
[10:25:18.649]                         base::local({
[10:25:18.649]                           has_future <- base::requireNamespace("future", 
[10:25:18.649]                             quietly = TRUE)
[10:25:18.649]                           if (has_future) {
[10:25:18.649]                             ns <- base::getNamespace("future")
[10:25:18.649]                             version <- ns[[".package"]][["version"]]
[10:25:18.649]                             if (is.null(version)) 
[10:25:18.649]                               version <- utils::packageVersion("future")
[10:25:18.649]                           }
[10:25:18.649]                           else {
[10:25:18.649]                             version <- NULL
[10:25:18.649]                           }
[10:25:18.649]                           if (!has_future || version < "1.8.0") {
[10:25:18.649]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:18.649]                               "", base::R.version$version.string), 
[10:25:18.649]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:18.649]                                 base::R.version$platform, 8 * 
[10:25:18.649]                                   base::.Machine$sizeof.pointer), 
[10:25:18.649]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:18.649]                                 "release", "version")], collapse = " "), 
[10:25:18.649]                               hostname = base::Sys.info()[["nodename"]])
[10:25:18.649]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:18.649]                               info)
[10:25:18.649]                             info <- base::paste(info, collapse = "; ")
[10:25:18.649]                             if (!has_future) {
[10:25:18.649]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:18.649]                                 info)
[10:25:18.649]                             }
[10:25:18.649]                             else {
[10:25:18.649]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:18.649]                                 info, version)
[10:25:18.649]                             }
[10:25:18.649]                             base::stop(msg)
[10:25:18.649]                           }
[10:25:18.649]                         })
[10:25:18.649]                       }
[10:25:18.649]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:18.649]                       base::options(mc.cores = 1L)
[10:25:18.649]                     }
[10:25:18.649]                     base::local({
[10:25:18.649]                       for (pkg in "future") {
[10:25:18.649]                         base::loadNamespace(pkg)
[10:25:18.649]                         base::library(pkg, character.only = TRUE)
[10:25:18.649]                       }
[10:25:18.649]                     })
[10:25:18.649]                   }
[10:25:18.649]                   options(future.plan = NULL)
[10:25:18.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:18.649]                 }
[10:25:18.649]                 ...future.workdir <- getwd()
[10:25:18.649]             }
[10:25:18.649]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:18.649]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:18.649]         }
[10:25:18.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:18.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:18.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:18.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:18.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:18.649]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:18.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:18.649]             base::names(...future.oldOptions))
[10:25:18.649]     }
[10:25:18.649]     if (FALSE) {
[10:25:18.649]     }
[10:25:18.649]     else {
[10:25:18.649]         if (TRUE) {
[10:25:18.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:18.649]                 open = "w")
[10:25:18.649]         }
[10:25:18.649]         else {
[10:25:18.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:18.649]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:18.649]         }
[10:25:18.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:18.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:18.649]             base::sink(type = "output", split = FALSE)
[10:25:18.649]             base::close(...future.stdout)
[10:25:18.649]         }, add = TRUE)
[10:25:18.649]     }
[10:25:18.649]     ...future.frame <- base::sys.nframe()
[10:25:18.649]     ...future.conditions <- base::list()
[10:25:18.649]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:18.649]     if (FALSE) {
[10:25:18.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:18.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:18.649]     }
[10:25:18.649]     ...future.result <- base::tryCatch({
[10:25:18.649]         base::withCallingHandlers({
[10:25:18.649]             ...future.value <- base::withVisible(base::local({
[10:25:18.649]                 withCallingHandlers({
[10:25:18.649]                   {
[10:25:18.649]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:25:18.649]                       ii, n), appendLF = FALSE)
[10:25:18.649]                     fit <- mandelbrot(C)
[10:25:18.649]                     delay(fit)
[10:25:18.649]                     message(" done")
[10:25:18.649]                     fit
[10:25:18.649]                   }
[10:25:18.649]                 }, immediateCondition = function(cond) {
[10:25:18.649]                   save_rds <- function (object, pathname, ...) 
[10:25:18.649]                   {
[10:25:18.649]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:18.649]                     if (file_test("-f", pathname_tmp)) {
[10:25:18.649]                       fi_tmp <- file.info(pathname_tmp)
[10:25:18.649]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:18.649]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:18.649]                         fi_tmp[["mtime"]])
[10:25:18.649]                     }
[10:25:18.649]                     tryCatch({
[10:25:18.649]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:18.649]                     }, error = function(ex) {
[10:25:18.649]                       msg <- conditionMessage(ex)
[10:25:18.649]                       fi_tmp <- file.info(pathname_tmp)
[10:25:18.649]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:18.649]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:18.649]                         fi_tmp[["mtime"]], msg)
[10:25:18.649]                       ex$message <- msg
[10:25:18.649]                       stop(ex)
[10:25:18.649]                     })
[10:25:18.649]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:18.649]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:18.649]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:18.649]                       fi_tmp <- file.info(pathname_tmp)
[10:25:18.649]                       fi <- file.info(pathname)
[10:25:18.649]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:18.649]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:18.649]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:18.649]                         fi[["size"]], fi[["mtime"]])
[10:25:18.649]                       stop(msg)
[10:25:18.649]                     }
[10:25:18.649]                     invisible(pathname)
[10:25:18.649]                   }
[10:25:18.649]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:18.649]                     rootPath = tempdir()) 
[10:25:18.649]                   {
[10:25:18.649]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:18.649]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:18.649]                       tmpdir = path, fileext = ".rds")
[10:25:18.649]                     save_rds(obj, file)
[10:25:18.649]                   }
[10:25:18.649]                   saveImmediateCondition(cond, path = "/tmp/RtmpLPVRk0/.future/immediateConditions")
[10:25:18.649]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.649]                   {
[10:25:18.649]                     inherits <- base::inherits
[10:25:18.649]                     invokeRestart <- base::invokeRestart
[10:25:18.649]                     is.null <- base::is.null
[10:25:18.649]                     muffled <- FALSE
[10:25:18.649]                     if (inherits(cond, "message")) {
[10:25:18.649]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:18.649]                       if (muffled) 
[10:25:18.649]                         invokeRestart("muffleMessage")
[10:25:18.649]                     }
[10:25:18.649]                     else if (inherits(cond, "warning")) {
[10:25:18.649]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:18.649]                       if (muffled) 
[10:25:18.649]                         invokeRestart("muffleWarning")
[10:25:18.649]                     }
[10:25:18.649]                     else if (inherits(cond, "condition")) {
[10:25:18.649]                       if (!is.null(pattern)) {
[10:25:18.649]                         computeRestarts <- base::computeRestarts
[10:25:18.649]                         grepl <- base::grepl
[10:25:18.649]                         restarts <- computeRestarts(cond)
[10:25:18.649]                         for (restart in restarts) {
[10:25:18.649]                           name <- restart$name
[10:25:18.649]                           if (is.null(name)) 
[10:25:18.649]                             next
[10:25:18.649]                           if (!grepl(pattern, name)) 
[10:25:18.649]                             next
[10:25:18.649]                           invokeRestart(restart)
[10:25:18.649]                           muffled <- TRUE
[10:25:18.649]                           break
[10:25:18.649]                         }
[10:25:18.649]                       }
[10:25:18.649]                     }
[10:25:18.649]                     invisible(muffled)
[10:25:18.649]                   }
[10:25:18.649]                   muffleCondition(cond)
[10:25:18.649]                 })
[10:25:18.649]             }))
[10:25:18.649]             future::FutureResult(value = ...future.value$value, 
[10:25:18.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.649]                   ...future.rng), globalenv = if (FALSE) 
[10:25:18.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:18.649]                     ...future.globalenv.names))
[10:25:18.649]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:18.649]         }, condition = base::local({
[10:25:18.649]             c <- base::c
[10:25:18.649]             inherits <- base::inherits
[10:25:18.649]             invokeRestart <- base::invokeRestart
[10:25:18.649]             length <- base::length
[10:25:18.649]             list <- base::list
[10:25:18.649]             seq.int <- base::seq.int
[10:25:18.649]             signalCondition <- base::signalCondition
[10:25:18.649]             sys.calls <- base::sys.calls
[10:25:18.649]             `[[` <- base::`[[`
[10:25:18.649]             `+` <- base::`+`
[10:25:18.649]             `<<-` <- base::`<<-`
[10:25:18.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:18.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:18.649]                   3L)]
[10:25:18.649]             }
[10:25:18.649]             function(cond) {
[10:25:18.649]                 is_error <- inherits(cond, "error")
[10:25:18.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:18.649]                   NULL)
[10:25:18.649]                 if (is_error) {
[10:25:18.649]                   sessionInformation <- function() {
[10:25:18.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:18.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:18.649]                       search = base::search(), system = base::Sys.info())
[10:25:18.649]                   }
[10:25:18.649]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:18.649]                     cond$call), session = sessionInformation(), 
[10:25:18.649]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:18.649]                   signalCondition(cond)
[10:25:18.649]                 }
[10:25:18.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:18.649]                 "immediateCondition"))) {
[10:25:18.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:18.649]                   ...future.conditions[[length(...future.conditions) + 
[10:25:18.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:18.649]                   if (TRUE && !signal) {
[10:25:18.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.649]                     {
[10:25:18.649]                       inherits <- base::inherits
[10:25:18.649]                       invokeRestart <- base::invokeRestart
[10:25:18.649]                       is.null <- base::is.null
[10:25:18.649]                       muffled <- FALSE
[10:25:18.649]                       if (inherits(cond, "message")) {
[10:25:18.649]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.649]                         if (muffled) 
[10:25:18.649]                           invokeRestart("muffleMessage")
[10:25:18.649]                       }
[10:25:18.649]                       else if (inherits(cond, "warning")) {
[10:25:18.649]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.649]                         if (muffled) 
[10:25:18.649]                           invokeRestart("muffleWarning")
[10:25:18.649]                       }
[10:25:18.649]                       else if (inherits(cond, "condition")) {
[10:25:18.649]                         if (!is.null(pattern)) {
[10:25:18.649]                           computeRestarts <- base::computeRestarts
[10:25:18.649]                           grepl <- base::grepl
[10:25:18.649]                           restarts <- computeRestarts(cond)
[10:25:18.649]                           for (restart in restarts) {
[10:25:18.649]                             name <- restart$name
[10:25:18.649]                             if (is.null(name)) 
[10:25:18.649]                               next
[10:25:18.649]                             if (!grepl(pattern, name)) 
[10:25:18.649]                               next
[10:25:18.649]                             invokeRestart(restart)
[10:25:18.649]                             muffled <- TRUE
[10:25:18.649]                             break
[10:25:18.649]                           }
[10:25:18.649]                         }
[10:25:18.649]                       }
[10:25:18.649]                       invisible(muffled)
[10:25:18.649]                     }
[10:25:18.649]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.649]                   }
[10:25:18.649]                 }
[10:25:18.649]                 else {
[10:25:18.649]                   if (TRUE) {
[10:25:18.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:18.649]                     {
[10:25:18.649]                       inherits <- base::inherits
[10:25:18.649]                       invokeRestart <- base::invokeRestart
[10:25:18.649]                       is.null <- base::is.null
[10:25:18.649]                       muffled <- FALSE
[10:25:18.649]                       if (inherits(cond, "message")) {
[10:25:18.649]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:18.649]                         if (muffled) 
[10:25:18.649]                           invokeRestart("muffleMessage")
[10:25:18.649]                       }
[10:25:18.649]                       else if (inherits(cond, "warning")) {
[10:25:18.649]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:18.649]                         if (muffled) 
[10:25:18.649]                           invokeRestart("muffleWarning")
[10:25:18.649]                       }
[10:25:18.649]                       else if (inherits(cond, "condition")) {
[10:25:18.649]                         if (!is.null(pattern)) {
[10:25:18.649]                           computeRestarts <- base::computeRestarts
[10:25:18.649]                           grepl <- base::grepl
[10:25:18.649]                           restarts <- computeRestarts(cond)
[10:25:18.649]                           for (restart in restarts) {
[10:25:18.649]                             name <- restart$name
[10:25:18.649]                             if (is.null(name)) 
[10:25:18.649]                               next
[10:25:18.649]                             if (!grepl(pattern, name)) 
[10:25:18.649]                               next
[10:25:18.649]                             invokeRestart(restart)
[10:25:18.649]                             muffled <- TRUE
[10:25:18.649]                             break
[10:25:18.649]                           }
[10:25:18.649]                         }
[10:25:18.649]                       }
[10:25:18.649]                       invisible(muffled)
[10:25:18.649]                     }
[10:25:18.649]                     muffleCondition(cond, pattern = "^muffle")
[10:25:18.649]                   }
[10:25:18.649]                 }
[10:25:18.649]             }
[10:25:18.649]         }))
[10:25:18.649]     }, error = function(ex) {
[10:25:18.649]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:18.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:18.649]                 ...future.rng), started = ...future.startTime, 
[10:25:18.649]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:18.649]             version = "1.8"), class = "FutureResult")
[10:25:18.649]     }, finally = {
[10:25:18.649]         if (!identical(...future.workdir, getwd())) 
[10:25:18.649]             setwd(...future.workdir)
[10:25:18.649]         {
[10:25:18.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:18.649]                 ...future.oldOptions$nwarnings <- NULL
[10:25:18.649]             }
[10:25:18.649]             base::options(...future.oldOptions)
[10:25:18.649]             if (.Platform$OS.type == "windows") {
[10:25:18.649]                 old_names <- names(...future.oldEnvVars)
[10:25:18.649]                 envs <- base::Sys.getenv()
[10:25:18.649]                 names <- names(envs)
[10:25:18.649]                 common <- intersect(names, old_names)
[10:25:18.649]                 added <- setdiff(names, old_names)
[10:25:18.649]                 removed <- setdiff(old_names, names)
[10:25:18.649]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:18.649]                   envs[common]]
[10:25:18.649]                 NAMES <- toupper(changed)
[10:25:18.649]                 args <- list()
[10:25:18.649]                 for (kk in seq_along(NAMES)) {
[10:25:18.649]                   name <- changed[[kk]]
[10:25:18.649]                   NAME <- NAMES[[kk]]
[10:25:18.649]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.649]                     next
[10:25:18.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.649]                 }
[10:25:18.649]                 NAMES <- toupper(added)
[10:25:18.649]                 for (kk in seq_along(NAMES)) {
[10:25:18.649]                   name <- added[[kk]]
[10:25:18.649]                   NAME <- NAMES[[kk]]
[10:25:18.649]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.649]                     next
[10:25:18.649]                   args[[name]] <- ""
[10:25:18.649]                 }
[10:25:18.649]                 NAMES <- toupper(removed)
[10:25:18.649]                 for (kk in seq_along(NAMES)) {
[10:25:18.649]                   name <- removed[[kk]]
[10:25:18.649]                   NAME <- NAMES[[kk]]
[10:25:18.649]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:18.649]                     next
[10:25:18.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:18.649]                 }
[10:25:18.649]                 if (length(args) > 0) 
[10:25:18.649]                   base::do.call(base::Sys.setenv, args = args)
[10:25:18.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:18.649]             }
[10:25:18.649]             else {
[10:25:18.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:18.649]             }
[10:25:18.649]             {
[10:25:18.649]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:18.649]                   0L) {
[10:25:18.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:18.649]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:18.649]                   base::options(opts)
[10:25:18.649]                 }
[10:25:18.649]                 {
[10:25:18.649]                   {
[10:25:18.649]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:18.649]                     NULL
[10:25:18.649]                   }
[10:25:18.649]                   options(future.plan = NULL)
[10:25:18.649]                   if (is.na(NA_character_)) 
[10:25:18.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:18.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:18.649]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:18.649]                     envir = parent.frame()) 
[10:25:18.649]                   {
[10:25:18.649]                     default_workers <- missing(workers)
[10:25:18.649]                     if (is.function(workers)) 
[10:25:18.649]                       workers <- workers()
[10:25:18.649]                     workers <- structure(as.integer(workers), 
[10:25:18.649]                       class = class(workers))
[10:25:18.649]                     stop_if_not(is.finite(workers), workers >= 
[10:25:18.649]                       1L)
[10:25:18.649]                     if ((workers == 1L && !inherits(workers, 
[10:25:18.649]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:18.649]                       if (default_workers) 
[10:25:18.649]                         supportsMulticore(warn = TRUE)
[10:25:18.649]                       return(sequential(..., envir = envir))
[10:25:18.649]                     }
[10:25:18.649]                     oopts <- options(mc.cores = workers)
[10:25:18.649]                     on.exit(options(oopts))
[10:25:18.649]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:18.649]                       envir = envir)
[10:25:18.649]                     if (!future$lazy) 
[10:25:18.649]                       future <- run(future)
[10:25:18.649]                     invisible(future)
[10:25:18.649]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:18.649]                 }
[10:25:18.649]             }
[10:25:18.649]         }
[10:25:18.649]     })
[10:25:18.649]     if (TRUE) {
[10:25:18.649]         base::sink(type = "output", split = FALSE)
[10:25:18.649]         if (TRUE) {
[10:25:18.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:18.649]         }
[10:25:18.649]         else {
[10:25:18.649]             ...future.result["stdout"] <- base::list(NULL)
[10:25:18.649]         }
[10:25:18.649]         base::close(...future.stdout)
[10:25:18.649]         ...future.stdout <- NULL
[10:25:18.649]     }
[10:25:18.649]     ...future.result$conditions <- ...future.conditions
[10:25:18.649]     ...future.result$finished <- base::Sys.time()
[10:25:18.649]     ...future.result
[10:25:18.649] }
[10:25:18.652] assign_globals() ...
[10:25:18.652] List of 4
[10:25:18.652]  $ ii   : int 4
[10:25:18.652]  $ n    : int 4
[10:25:18.652]  $ C    : cplx [1:25, 1:25] -0.719+0.031i -0.719+0.092i -0.719+0.153i ...
[10:25:18.652]   ..- attr(*, "region")=List of 2
[10:25:18.652]   .. ..$ xrange: num [1:2] -0.719 0.75
[10:25:18.652]   .. ..$ yrange: num [1:2] 0.0306 1.5
[10:25:18.652]   ..- attr(*, "tile")= int [1:2] 2 2
[10:25:18.652]  $ delay:function (counts)  
[10:25:18.652]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:25:18.652]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x563913686678> 
[10:25:18.652]  - attr(*, "where")=List of 4
[10:25:18.652]   ..$ ii   :<environment: R_EmptyEnv> 
[10:25:18.652]   ..$ n    :<environment: R_EmptyEnv> 
[10:25:18.652]   ..$ C    :<environment: R_EmptyEnv> 
[10:25:18.652]   ..$ delay:<environment: R_EmptyEnv> 
[10:25:18.652]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:18.652]  - attr(*, "resolved")= logi FALSE
[10:25:18.652]  - attr(*, "total_size")= num 14584
[10:25:18.652]  - attr(*, "already-done")= logi TRUE
[10:25:18.662] - copied ‘ii’ to environment
[10:25:18.663] - copied ‘n’ to environment
[10:25:18.663] - copied ‘C’ to environment
[10:25:18.663] - reassign environment for ‘delay’
[10:25:18.663] - copied ‘delay’ to environment
[10:25:18.663] assign_globals() ... done
[10:25:18.663] requestCore(): workers = 2
[10:25:18.664] Poll #1 (0): usedCores() = 2, workers = 2
[10:25:18.674] result() for MulticoreFuture ...
[10:25:18.676] result() for MulticoreFuture ...
[10:25:18.676] result() for MulticoreFuture ... done
[10:25:18.676] signalConditions() ...
[10:25:18.676]  - include = ‘immediateCondition’
[10:25:18.676]  - exclude = 
[10:25:18.676]  - resignal = FALSE
[10:25:18.676]  - Number of conditions: 2
[10:25:18.676] signalConditions() ... done
[10:25:18.677] result() for MulticoreFuture ... done
[10:25:18.677] result() for MulticoreFuture ...
[10:25:18.677] result() for MulticoreFuture ... done
[10:25:18.677] signalConditions() ...
[10:25:18.677]  - include = ‘immediateCondition’
[10:25:18.677]  - exclude = 
[10:25:18.677]  - resignal = FALSE
[10:25:18.678]  - Number of conditions: 2
[10:25:18.678] signalConditions() ... done
[10:25:18.681] MulticoreFuture started
[10:25:18.681] - Launch lazy future ... done
[10:25:18.681] run() for ‘MulticoreFuture’ ... done
[10:25:18.682] - run() ... done
[10:25:18.682] - resolved() ...
[10:25:18.682] plan(): Setting new future strategy stack:
[10:25:18.683] List of future strategies:
[10:25:18.683] 1. sequential:
[10:25:18.683]    - args: function (..., envir = parent.frame())
[10:25:18.683]    - tweaked: FALSE
[10:25:18.683]    - call: NULL
[10:25:18.683] plan(): nbrOfWorkers() = 1
[10:25:18.688] plan(): Setting new future strategy stack:
[10:25:18.688] List of future strategies:
[10:25:18.688] 1. multicore:
[10:25:18.688]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:18.688]    - tweaked: FALSE
[10:25:18.688]    - call: plan(strategy)
[10:25:18.692] - resolved: FALSE
[10:25:18.692] - resolved() ... done
[10:25:18.693] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #2 of 4 ...
[10:25:18.693] result() for MulticoreFuture ...
[10:25:18.693] plan(): nbrOfWorkers() = 2
[10:25:18.693] result() for MulticoreFuture ... done
[10:25:18.693] result() for MulticoreFuture ...
[10:25:18.694] result() for MulticoreFuture ... done
[10:25:18.694] signalConditions() ...
[10:25:18.694]  - include = ‘immediateCondition’
[10:25:18.694]  - exclude = 
[10:25:18.694]  - resignal = FALSE
[10:25:18.694]  - Number of conditions: 2
[10:25:18.694] signalConditions() ... done
[10:25:18.694] Future state: ‘finished’
[10:25:18.695] result() for MulticoreFuture ...
[10:25:18.695] result() for MulticoreFuture ... done
[10:25:18.695] signalConditions() ...
[10:25:18.695]  - include = ‘condition’
[10:25:18.695]  - exclude = ‘immediateCondition’
[10:25:18.695]  - resignal = TRUE
[10:25:18.695]  - Number of conditions: 2
[10:25:18.696]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[10:25:18.696]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:25:18.696] signalConditions() ... done
Plotting tile #3 of 4 ...
[10:25:18.697] result() for MulticoreFuture ...
[10:25:18.699] result() for MulticoreFuture ...
[10:25:18.699] result() for MulticoreFuture ... done
[10:25:18.699] signalConditions() ...
[10:25:18.699]  - include = ‘immediateCondition’
[10:25:18.699]  - exclude = 
[10:25:18.700]  - resignal = FALSE
[10:25:18.700]  - Number of conditions: 2
[10:25:18.700] signalConditions() ... done
[10:25:18.700] result() for MulticoreFuture ... done
[10:25:18.700] result() for MulticoreFuture ...
[10:25:18.700] result() for MulticoreFuture ... done
[10:25:18.701] signalConditions() ...
[10:25:18.701]  - include = ‘immediateCondition’
[10:25:18.701]  - exclude = 
[10:25:18.701]  - resignal = FALSE
[10:25:18.701]  - Number of conditions: 2
[10:25:18.701] signalConditions() ... done
[10:25:18.702] Future state: ‘finished’
[10:25:18.702] result() for MulticoreFuture ...
[10:25:18.702] result() for MulticoreFuture ... done
[10:25:18.702] signalConditions() ...
[10:25:18.702]  - include = ‘condition’
[10:25:18.703]  - exclude = ‘immediateCondition’
[10:25:18.703]  - resignal = TRUE
[10:25:18.703]  - Number of conditions: 2
[10:25:18.703]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[10:25:18.703]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:25:18.703] signalConditions() ... done
Plotting tile #4 of 4 ...
[10:25:18.704] result() for MulticoreFuture ...
[10:25:18.705] result() for MulticoreFuture ...
[10:25:18.705] result() for MulticoreFuture ... done
[10:25:18.706] signalConditions() ...
[10:25:18.706]  - include = ‘immediateCondition’
[10:25:18.706]  - exclude = 
[10:25:18.706]  - resignal = FALSE
[10:25:18.706]  - Number of conditions: 2
[10:25:18.706] signalConditions() ... done
[10:25:18.706] result() for MulticoreFuture ... done
[10:25:18.706] result() for MulticoreFuture ...
[10:25:18.707] result() for MulticoreFuture ... done
[10:25:18.707] signalConditions() ...
[10:25:18.707]  - include = ‘immediateCondition’
[10:25:18.707]  - exclude = 
[10:25:18.707]  - resignal = FALSE
[10:25:18.707]  - Number of conditions: 2
[10:25:18.707] signalConditions() ... done
[10:25:18.707] Future state: ‘finished’
[10:25:18.708] result() for MulticoreFuture ...
[10:25:18.708] result() for MulticoreFuture ... done
[10:25:18.708] signalConditions() ...
[10:25:18.708]  - include = ‘condition’
[10:25:18.708]  - exclude = ‘immediateCondition’
[10:25:18.708]  - resignal = TRUE
[10:25:18.708]  - Number of conditions: 2
[10:25:18.708]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[10:25:18.708]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:25:18.709] signalConditions() ... done

> close.screen()
[1] 1 2 3 4 5 6 7 8

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multicore') ... DONE
- plan('multisession') ...
[10:25:18.710] plan(): Setting new future strategy stack:
[10:25:18.711] List of future strategies:
[10:25:18.711] 1. multisession:
[10:25:18.711]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:25:18.711]    - tweaked: FALSE
[10:25:18.711]    - call: plan(strategy)
[10:25:18.711] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:25:18.711] multisession:
[10:25:18.711] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:25:18.711] - tweaked: FALSE
[10:25:18.711] - call: plan(strategy)
[10:25:18.718] getGlobalsAndPackages() ...
[10:25:18.718] Not searching for globals
[10:25:18.718] - globals: [0] <none>
[10:25:18.719] getGlobalsAndPackages() ... DONE
[10:25:18.719] [local output] makeClusterPSOCK() ...
[10:25:18.776] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:25:18.777] [local output] Base port: 11660
[10:25:18.777] [local output] Getting setup options for 2 cluster nodes ...
[10:25:18.778] [local output]  - Node 1 of 2 ...
[10:25:18.778] [local output] localMachine=TRUE => revtunnel=FALSE

[10:25:18.779] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLPVRk0/worker.rank=1.parallelly.parent=81245.13d5d3e9d6386.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpLPVRk0/worker.rank=1.parallelly.parent=81245.13d5d3e9d6386.pid")'’
[10:25:18.967] - Possible to infer worker's PID: TRUE
[10:25:18.968] [local output] Rscript port: 11660

[10:25:18.968] [local output]  - Node 2 of 2 ...
[10:25:18.968] [local output] localMachine=TRUE => revtunnel=FALSE

[10:25:18.969] [local output] Rscript port: 11660

[10:25:18.969] [local output] Getting setup options for 2 cluster nodes ... done
[10:25:18.969] [local output]  - Parallel setup requested for some PSOCK nodes
[10:25:18.970] [local output] Setting up PSOCK nodes in parallel
[10:25:18.970] List of 36
[10:25:18.970]  $ worker          : chr "localhost"
[10:25:18.970]   ..- attr(*, "localhost")= logi TRUE
[10:25:18.970]  $ master          : chr "localhost"
[10:25:18.970]  $ port            : int 11660
[10:25:18.970]  $ connectTimeout  : num 120
[10:25:18.970]  $ timeout         : num 2592000
[10:25:18.970]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:25:18.970]  $ homogeneous     : logi TRUE
[10:25:18.970]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:25:18.970]  $ rscript_envs    : NULL
[10:25:18.970]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:25:18.970]  $ rscript_startup : NULL
[10:25:18.970]  $ rscript_sh      : chr "sh"
[10:25:18.970]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:25:18.970]  $ methods         : logi TRUE
[10:25:18.970]  $ socketOptions   : chr "no-delay"
[10:25:18.970]  $ useXDR          : logi FALSE
[10:25:18.970]  $ outfile         : chr "/dev/null"
[10:25:18.970]  $ renice          : int NA
[10:25:18.970]  $ rshcmd          : NULL
[10:25:18.970]  $ user            : chr(0) 
[10:25:18.970]  $ revtunnel       : logi FALSE
[10:25:18.970]  $ rshlogfile      : NULL
[10:25:18.970]  $ rshopts         : chr(0) 
[10:25:18.970]  $ rank            : int 1
[10:25:18.970]  $ manual          : logi FALSE
[10:25:18.970]  $ dryrun          : logi FALSE
[10:25:18.970]  $ quiet           : logi FALSE
[10:25:18.970]  $ setup_strategy  : chr "parallel"
[10:25:18.970]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:25:18.970]  $ pidfile         : chr "/tmp/RtmpLPVRk0/worker.rank=1.parallelly.parent=81245.13d5d3e9d6386.pid"
[10:25:18.970]  $ rshcmd_label    : NULL
[10:25:18.970]  $ rsh_call        : NULL
[10:25:18.970]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:25:18.970]  $ localMachine    : logi TRUE
[10:25:18.970]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:25:18.970]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:25:18.970]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:25:18.970]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:25:18.970]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:25:18.970]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:25:18.970]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:25:18.970]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:25:18.970]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:25:18.970]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:25:18.970]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:25:18.970]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:25:18.970]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:25:18.970]  $ arguments       :List of 28
[10:25:18.970]   ..$ worker          : chr "localhost"
[10:25:18.970]   ..$ master          : NULL
[10:25:18.970]   ..$ port            : int 11660
[10:25:18.970]   ..$ connectTimeout  : num 120
[10:25:18.970]   ..$ timeout         : num 2592000
[10:25:18.970]   ..$ rscript         : NULL
[10:25:18.970]   ..$ homogeneous     : NULL
[10:25:18.970]   ..$ rscript_args    : NULL
[10:25:18.970]   ..$ rscript_envs    : NULL
[10:25:18.970]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:25:18.970]   ..$ rscript_startup : NULL
[10:25:18.970]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:25:18.970]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:25:18.970]   ..$ methods         : logi TRUE
[10:25:18.970]   ..$ socketOptions   : chr "no-delay"
[10:25:18.970]   ..$ useXDR          : logi FALSE
[10:25:18.970]   ..$ outfile         : chr "/dev/null"
[10:25:18.970]   ..$ renice          : int NA
[10:25:18.970]   ..$ rshcmd          : NULL
[10:25:18.970]   ..$ user            : NULL
[10:25:18.970]   ..$ revtunnel       : logi NA
[10:25:18.970]   ..$ rshlogfile      : NULL
[10:25:18.970]   ..$ rshopts         : NULL
[10:25:18.970]   ..$ rank            : int 1
[10:25:18.970]   ..$ manual          : logi FALSE
[10:25:18.970]   ..$ dryrun          : logi FALSE
[10:25:18.970]   ..$ quiet           : logi FALSE
[10:25:18.970]   ..$ setup_strategy  : chr "parallel"
[10:25:18.970]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:25:18.987] [local output] System call to launch all workers:
[10:25:18.987] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLPVRk0/worker.rank=1.parallelly.parent=81245.13d5d3e9d6386.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11660 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:25:18.987] [local output] Starting PSOCK main server
[10:25:18.993] [local output] Workers launched
[10:25:18.993] [local output] Waiting for workers to connect back
[10:25:18.993]  - [local output] 0 workers out of 2 ready
[10:25:19.240]  - [local output] 0 workers out of 2 ready
[10:25:19.241]  - [local output] 1 workers out of 2 ready
[10:25:19.241]  - [local output] 2 workers out of 2 ready
[10:25:19.241] [local output] Launching of workers completed
[10:25:19.241] [local output] Collecting session information from workers
[10:25:19.242] [local output]  - Worker #1 of 2
[10:25:19.243] [local output]  - Worker #2 of 2
[10:25:19.243] [local output] makeClusterPSOCK() ... done
[10:25:19.254] Packages needed by the future expression (n = 0): <none>
[10:25:19.254] Packages needed by future strategies (n = 0): <none>
[10:25:19.254] {
[10:25:19.254]     {
[10:25:19.254]         {
[10:25:19.254]             ...future.startTime <- base::Sys.time()
[10:25:19.254]             {
[10:25:19.254]                 {
[10:25:19.254]                   {
[10:25:19.254]                     {
[10:25:19.254]                       base::local({
[10:25:19.254]                         has_future <- base::requireNamespace("future", 
[10:25:19.254]                           quietly = TRUE)
[10:25:19.254]                         if (has_future) {
[10:25:19.254]                           ns <- base::getNamespace("future")
[10:25:19.254]                           version <- ns[[".package"]][["version"]]
[10:25:19.254]                           if (is.null(version)) 
[10:25:19.254]                             version <- utils::packageVersion("future")
[10:25:19.254]                         }
[10:25:19.254]                         else {
[10:25:19.254]                           version <- NULL
[10:25:19.254]                         }
[10:25:19.254]                         if (!has_future || version < "1.8.0") {
[10:25:19.254]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:19.254]                             "", base::R.version$version.string), 
[10:25:19.254]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:19.254]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:19.254]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:19.254]                               "release", "version")], collapse = " "), 
[10:25:19.254]                             hostname = base::Sys.info()[["nodename"]])
[10:25:19.254]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:19.254]                             info)
[10:25:19.254]                           info <- base::paste(info, collapse = "; ")
[10:25:19.254]                           if (!has_future) {
[10:25:19.254]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:19.254]                               info)
[10:25:19.254]                           }
[10:25:19.254]                           else {
[10:25:19.254]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:19.254]                               info, version)
[10:25:19.254]                           }
[10:25:19.254]                           base::stop(msg)
[10:25:19.254]                         }
[10:25:19.254]                       })
[10:25:19.254]                     }
[10:25:19.254]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:19.254]                     base::options(mc.cores = 1L)
[10:25:19.254]                   }
[10:25:19.254]                   options(future.plan = NULL)
[10:25:19.254]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:19.254]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:19.254]                 }
[10:25:19.254]                 ...future.workdir <- getwd()
[10:25:19.254]             }
[10:25:19.254]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:19.254]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:19.254]         }
[10:25:19.254]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:19.254]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:19.254]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:19.254]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:19.254]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:19.254]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:19.254]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:19.254]             base::names(...future.oldOptions))
[10:25:19.254]     }
[10:25:19.254]     if (FALSE) {
[10:25:19.254]     }
[10:25:19.254]     else {
[10:25:19.254]         if (TRUE) {
[10:25:19.254]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:19.254]                 open = "w")
[10:25:19.254]         }
[10:25:19.254]         else {
[10:25:19.254]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:19.254]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:19.254]         }
[10:25:19.254]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:19.254]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:19.254]             base::sink(type = "output", split = FALSE)
[10:25:19.254]             base::close(...future.stdout)
[10:25:19.254]         }, add = TRUE)
[10:25:19.254]     }
[10:25:19.254]     ...future.frame <- base::sys.nframe()
[10:25:19.254]     ...future.conditions <- base::list()
[10:25:19.254]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:19.254]     if (FALSE) {
[10:25:19.254]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:19.254]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:19.254]     }
[10:25:19.254]     ...future.result <- base::tryCatch({
[10:25:19.254]         base::withCallingHandlers({
[10:25:19.254]             ...future.value <- base::withVisible(base::local({
[10:25:19.254]                 ...future.makeSendCondition <- base::local({
[10:25:19.254]                   sendCondition <- NULL
[10:25:19.254]                   function(frame = 1L) {
[10:25:19.254]                     if (is.function(sendCondition)) 
[10:25:19.254]                       return(sendCondition)
[10:25:19.254]                     ns <- getNamespace("parallel")
[10:25:19.254]                     if (exists("sendData", mode = "function", 
[10:25:19.254]                       envir = ns)) {
[10:25:19.254]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:19.254]                         envir = ns)
[10:25:19.254]                       envir <- sys.frame(frame)
[10:25:19.254]                       master <- NULL
[10:25:19.254]                       while (!identical(envir, .GlobalEnv) && 
[10:25:19.254]                         !identical(envir, emptyenv())) {
[10:25:19.254]                         if (exists("master", mode = "list", envir = envir, 
[10:25:19.254]                           inherits = FALSE)) {
[10:25:19.254]                           master <- get("master", mode = "list", 
[10:25:19.254]                             envir = envir, inherits = FALSE)
[10:25:19.254]                           if (inherits(master, c("SOCKnode", 
[10:25:19.254]                             "SOCK0node"))) {
[10:25:19.254]                             sendCondition <<- function(cond) {
[10:25:19.254]                               data <- list(type = "VALUE", value = cond, 
[10:25:19.254]                                 success = TRUE)
[10:25:19.254]                               parallel_sendData(master, data)
[10:25:19.254]                             }
[10:25:19.254]                             return(sendCondition)
[10:25:19.254]                           }
[10:25:19.254]                         }
[10:25:19.254]                         frame <- frame + 1L
[10:25:19.254]                         envir <- sys.frame(frame)
[10:25:19.254]                       }
[10:25:19.254]                     }
[10:25:19.254]                     sendCondition <<- function(cond) NULL
[10:25:19.254]                   }
[10:25:19.254]                 })
[10:25:19.254]                 withCallingHandlers({
[10:25:19.254]                   NA
[10:25:19.254]                 }, immediateCondition = function(cond) {
[10:25:19.254]                   sendCondition <- ...future.makeSendCondition()
[10:25:19.254]                   sendCondition(cond)
[10:25:19.254]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.254]                   {
[10:25:19.254]                     inherits <- base::inherits
[10:25:19.254]                     invokeRestart <- base::invokeRestart
[10:25:19.254]                     is.null <- base::is.null
[10:25:19.254]                     muffled <- FALSE
[10:25:19.254]                     if (inherits(cond, "message")) {
[10:25:19.254]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:19.254]                       if (muffled) 
[10:25:19.254]                         invokeRestart("muffleMessage")
[10:25:19.254]                     }
[10:25:19.254]                     else if (inherits(cond, "warning")) {
[10:25:19.254]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:19.254]                       if (muffled) 
[10:25:19.254]                         invokeRestart("muffleWarning")
[10:25:19.254]                     }
[10:25:19.254]                     else if (inherits(cond, "condition")) {
[10:25:19.254]                       if (!is.null(pattern)) {
[10:25:19.254]                         computeRestarts <- base::computeRestarts
[10:25:19.254]                         grepl <- base::grepl
[10:25:19.254]                         restarts <- computeRestarts(cond)
[10:25:19.254]                         for (restart in restarts) {
[10:25:19.254]                           name <- restart$name
[10:25:19.254]                           if (is.null(name)) 
[10:25:19.254]                             next
[10:25:19.254]                           if (!grepl(pattern, name)) 
[10:25:19.254]                             next
[10:25:19.254]                           invokeRestart(restart)
[10:25:19.254]                           muffled <- TRUE
[10:25:19.254]                           break
[10:25:19.254]                         }
[10:25:19.254]                       }
[10:25:19.254]                     }
[10:25:19.254]                     invisible(muffled)
[10:25:19.254]                   }
[10:25:19.254]                   muffleCondition(cond)
[10:25:19.254]                 })
[10:25:19.254]             }))
[10:25:19.254]             future::FutureResult(value = ...future.value$value, 
[10:25:19.254]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:19.254]                   ...future.rng), globalenv = if (FALSE) 
[10:25:19.254]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:19.254]                     ...future.globalenv.names))
[10:25:19.254]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:19.254]         }, condition = base::local({
[10:25:19.254]             c <- base::c
[10:25:19.254]             inherits <- base::inherits
[10:25:19.254]             invokeRestart <- base::invokeRestart
[10:25:19.254]             length <- base::length
[10:25:19.254]             list <- base::list
[10:25:19.254]             seq.int <- base::seq.int
[10:25:19.254]             signalCondition <- base::signalCondition
[10:25:19.254]             sys.calls <- base::sys.calls
[10:25:19.254]             `[[` <- base::`[[`
[10:25:19.254]             `+` <- base::`+`
[10:25:19.254]             `<<-` <- base::`<<-`
[10:25:19.254]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:19.254]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:19.254]                   3L)]
[10:25:19.254]             }
[10:25:19.254]             function(cond) {
[10:25:19.254]                 is_error <- inherits(cond, "error")
[10:25:19.254]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:19.254]                   NULL)
[10:25:19.254]                 if (is_error) {
[10:25:19.254]                   sessionInformation <- function() {
[10:25:19.254]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:19.254]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:19.254]                       search = base::search(), system = base::Sys.info())
[10:25:19.254]                   }
[10:25:19.254]                   ...future.conditions[[length(...future.conditions) + 
[10:25:19.254]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:19.254]                     cond$call), session = sessionInformation(), 
[10:25:19.254]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:19.254]                   signalCondition(cond)
[10:25:19.254]                 }
[10:25:19.254]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:19.254]                 "immediateCondition"))) {
[10:25:19.254]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:19.254]                   ...future.conditions[[length(...future.conditions) + 
[10:25:19.254]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:19.254]                   if (TRUE && !signal) {
[10:25:19.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.254]                     {
[10:25:19.254]                       inherits <- base::inherits
[10:25:19.254]                       invokeRestart <- base::invokeRestart
[10:25:19.254]                       is.null <- base::is.null
[10:25:19.254]                       muffled <- FALSE
[10:25:19.254]                       if (inherits(cond, "message")) {
[10:25:19.254]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:19.254]                         if (muffled) 
[10:25:19.254]                           invokeRestart("muffleMessage")
[10:25:19.254]                       }
[10:25:19.254]                       else if (inherits(cond, "warning")) {
[10:25:19.254]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:19.254]                         if (muffled) 
[10:25:19.254]                           invokeRestart("muffleWarning")
[10:25:19.254]                       }
[10:25:19.254]                       else if (inherits(cond, "condition")) {
[10:25:19.254]                         if (!is.null(pattern)) {
[10:25:19.254]                           computeRestarts <- base::computeRestarts
[10:25:19.254]                           grepl <- base::grepl
[10:25:19.254]                           restarts <- computeRestarts(cond)
[10:25:19.254]                           for (restart in restarts) {
[10:25:19.254]                             name <- restart$name
[10:25:19.254]                             if (is.null(name)) 
[10:25:19.254]                               next
[10:25:19.254]                             if (!grepl(pattern, name)) 
[10:25:19.254]                               next
[10:25:19.254]                             invokeRestart(restart)
[10:25:19.254]                             muffled <- TRUE
[10:25:19.254]                             break
[10:25:19.254]                           }
[10:25:19.254]                         }
[10:25:19.254]                       }
[10:25:19.254]                       invisible(muffled)
[10:25:19.254]                     }
[10:25:19.254]                     muffleCondition(cond, pattern = "^muffle")
[10:25:19.254]                   }
[10:25:19.254]                 }
[10:25:19.254]                 else {
[10:25:19.254]                   if (TRUE) {
[10:25:19.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.254]                     {
[10:25:19.254]                       inherits <- base::inherits
[10:25:19.254]                       invokeRestart <- base::invokeRestart
[10:25:19.254]                       is.null <- base::is.null
[10:25:19.254]                       muffled <- FALSE
[10:25:19.254]                       if (inherits(cond, "message")) {
[10:25:19.254]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:19.254]                         if (muffled) 
[10:25:19.254]                           invokeRestart("muffleMessage")
[10:25:19.254]                       }
[10:25:19.254]                       else if (inherits(cond, "warning")) {
[10:25:19.254]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:19.254]                         if (muffled) 
[10:25:19.254]                           invokeRestart("muffleWarning")
[10:25:19.254]                       }
[10:25:19.254]                       else if (inherits(cond, "condition")) {
[10:25:19.254]                         if (!is.null(pattern)) {
[10:25:19.254]                           computeRestarts <- base::computeRestarts
[10:25:19.254]                           grepl <- base::grepl
[10:25:19.254]                           restarts <- computeRestarts(cond)
[10:25:19.254]                           for (restart in restarts) {
[10:25:19.254]                             name <- restart$name
[10:25:19.254]                             if (is.null(name)) 
[10:25:19.254]                               next
[10:25:19.254]                             if (!grepl(pattern, name)) 
[10:25:19.254]                               next
[10:25:19.254]                             invokeRestart(restart)
[10:25:19.254]                             muffled <- TRUE
[10:25:19.254]                             break
[10:25:19.254]                           }
[10:25:19.254]                         }
[10:25:19.254]                       }
[10:25:19.254]                       invisible(muffled)
[10:25:19.254]                     }
[10:25:19.254]                     muffleCondition(cond, pattern = "^muffle")
[10:25:19.254]                   }
[10:25:19.254]                 }
[10:25:19.254]             }
[10:25:19.254]         }))
[10:25:19.254]     }, error = function(ex) {
[10:25:19.254]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:19.254]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:19.254]                 ...future.rng), started = ...future.startTime, 
[10:25:19.254]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:19.254]             version = "1.8"), class = "FutureResult")
[10:25:19.254]     }, finally = {
[10:25:19.254]         if (!identical(...future.workdir, getwd())) 
[10:25:19.254]             setwd(...future.workdir)
[10:25:19.254]         {
[10:25:19.254]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:19.254]                 ...future.oldOptions$nwarnings <- NULL
[10:25:19.254]             }
[10:25:19.254]             base::options(...future.oldOptions)
[10:25:19.254]             if (.Platform$OS.type == "windows") {
[10:25:19.254]                 old_names <- names(...future.oldEnvVars)
[10:25:19.254]                 envs <- base::Sys.getenv()
[10:25:19.254]                 names <- names(envs)
[10:25:19.254]                 common <- intersect(names, old_names)
[10:25:19.254]                 added <- setdiff(names, old_names)
[10:25:19.254]                 removed <- setdiff(old_names, names)
[10:25:19.254]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:19.254]                   envs[common]]
[10:25:19.254]                 NAMES <- toupper(changed)
[10:25:19.254]                 args <- list()
[10:25:19.254]                 for (kk in seq_along(NAMES)) {
[10:25:19.254]                   name <- changed[[kk]]
[10:25:19.254]                   NAME <- NAMES[[kk]]
[10:25:19.254]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.254]                     next
[10:25:19.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:19.254]                 }
[10:25:19.254]                 NAMES <- toupper(added)
[10:25:19.254]                 for (kk in seq_along(NAMES)) {
[10:25:19.254]                   name <- added[[kk]]
[10:25:19.254]                   NAME <- NAMES[[kk]]
[10:25:19.254]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.254]                     next
[10:25:19.254]                   args[[name]] <- ""
[10:25:19.254]                 }
[10:25:19.254]                 NAMES <- toupper(removed)
[10:25:19.254]                 for (kk in seq_along(NAMES)) {
[10:25:19.254]                   name <- removed[[kk]]
[10:25:19.254]                   NAME <- NAMES[[kk]]
[10:25:19.254]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.254]                     next
[10:25:19.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:19.254]                 }
[10:25:19.254]                 if (length(args) > 0) 
[10:25:19.254]                   base::do.call(base::Sys.setenv, args = args)
[10:25:19.254]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:19.254]             }
[10:25:19.254]             else {
[10:25:19.254]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:19.254]             }
[10:25:19.254]             {
[10:25:19.254]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:19.254]                   0L) {
[10:25:19.254]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:19.254]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:19.254]                   base::options(opts)
[10:25:19.254]                 }
[10:25:19.254]                 {
[10:25:19.254]                   {
[10:25:19.254]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:19.254]                     NULL
[10:25:19.254]                   }
[10:25:19.254]                   options(future.plan = NULL)
[10:25:19.254]                   if (is.na(NA_character_)) 
[10:25:19.254]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:19.254]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:19.254]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:19.254]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:19.254]                     envir = parent.frame()) 
[10:25:19.254]                   {
[10:25:19.254]                     if (is.function(workers)) 
[10:25:19.254]                       workers <- workers()
[10:25:19.254]                     workers <- structure(as.integer(workers), 
[10:25:19.254]                       class = class(workers))
[10:25:19.254]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:19.254]                       workers >= 1)
[10:25:19.254]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:19.254]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:19.254]                     }
[10:25:19.254]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:19.254]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:19.254]                       envir = envir)
[10:25:19.254]                     if (!future$lazy) 
[10:25:19.254]                       future <- run(future)
[10:25:19.254]                     invisible(future)
[10:25:19.254]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:19.254]                 }
[10:25:19.254]             }
[10:25:19.254]         }
[10:25:19.254]     })
[10:25:19.254]     if (TRUE) {
[10:25:19.254]         base::sink(type = "output", split = FALSE)
[10:25:19.254]         if (TRUE) {
[10:25:19.254]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:19.254]         }
[10:25:19.254]         else {
[10:25:19.254]             ...future.result["stdout"] <- base::list(NULL)
[10:25:19.254]         }
[10:25:19.254]         base::close(...future.stdout)
[10:25:19.254]         ...future.stdout <- NULL
[10:25:19.254]     }
[10:25:19.254]     ...future.result$conditions <- ...future.conditions
[10:25:19.254]     ...future.result$finished <- base::Sys.time()
[10:25:19.254]     ...future.result
[10:25:19.254] }
[10:25:19.308] MultisessionFuture started
[10:25:19.308] result() for ClusterFuture ...
[10:25:19.309] receiveMessageFromWorker() for ClusterFuture ...
[10:25:19.309] - Validating connection of MultisessionFuture
[10:25:19.353] - received message: FutureResult
[10:25:19.353] - Received FutureResult
[10:25:19.353] - Erased future from FutureRegistry
[10:25:19.353] result() for ClusterFuture ...
[10:25:19.354] - result already collected: FutureResult
[10:25:19.354] result() for ClusterFuture ... done
[10:25:19.354] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:19.354] result() for ClusterFuture ... done
[10:25:19.354] result() for ClusterFuture ...
[10:25:19.354] - result already collected: FutureResult
[10:25:19.354] result() for ClusterFuture ... done
[10:25:19.354] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:25:19.358] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1]  9 10 11 12

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[10:25:19.362] getGlobalsAndPackages() ...
[10:25:19.362] Searching for globals...
[10:25:19.365] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:25:19.365] Searching for globals ... DONE
[10:25:19.366] Resolving globals: FALSE
[10:25:19.366] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:25:19.367] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:25:19.367] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:25:19.367] - packages: [1] ‘future’
[10:25:19.367] getGlobalsAndPackages() ... DONE
 2[10:25:19.371] getGlobalsAndPackages() ...
[10:25:19.371] Searching for globals...
[10:25:19.374] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:25:19.374] Searching for globals ... DONE
[10:25:19.375] Resolving globals: FALSE
[10:25:19.375] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:25:19.376] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:25:19.376] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:25:19.376] - packages: [1] ‘future’
[10:25:19.376] getGlobalsAndPackages() ... DONE
 3[10:25:19.376] getGlobalsAndPackages() ...
[10:25:19.376] Searching for globals...
[10:25:19.380] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:25:19.380] Searching for globals ... DONE
[10:25:19.380] Resolving globals: FALSE
[10:25:19.381] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:25:19.381] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:25:19.381] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:25:19.382] - packages: [1] ‘future’
[10:25:19.382] getGlobalsAndPackages() ... DONE
 4[10:25:19.382] getGlobalsAndPackages() ...
[10:25:19.382] Searching for globals...
[10:25:19.385] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:25:19.386] Searching for globals ... DONE
[10:25:19.386] Resolving globals: FALSE
[10:25:19.386] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:25:19.387] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:25:19.387] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:25:19.387] - packages: [1] ‘future’
[10:25:19.387] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[10:25:19.398] resolved() for ‘Future’ ...
[10:25:19.399] - state: ‘created’
[10:25:19.399] - run: TRUE
[10:25:19.399] - run() ...
[10:25:19.399] run() for ‘Future’ ...
[10:25:19.399] - state: ‘created’
[10:25:19.399] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:19.413] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:19.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:19.413]   - Field: ‘node’
[10:25:19.413]   - Field: ‘label’
[10:25:19.414]   - Field: ‘local’
[10:25:19.414]   - Field: ‘owner’
[10:25:19.414]   - Field: ‘envir’
[10:25:19.414]   - Field: ‘workers’
[10:25:19.414]   - Field: ‘packages’
[10:25:19.414]   - Field: ‘gc’
[10:25:19.414]   - Field: ‘conditions’
[10:25:19.414]   - Field: ‘persistent’
[10:25:19.414]   - Field: ‘expr’
[10:25:19.414]   - Field: ‘uuid’
[10:25:19.414]   - Field: ‘seed’
[10:25:19.415]   - Field: ‘version’
[10:25:19.415]   - Field: ‘result’
[10:25:19.415]   - Field: ‘asynchronous’
[10:25:19.415]   - Field: ‘calls’
[10:25:19.415]   - Field: ‘globals’
[10:25:19.415]   - Field: ‘stdout’
[10:25:19.415]   - Field: ‘earlySignal’
[10:25:19.415]   - Field: ‘lazy’
[10:25:19.415]   - Field: ‘state’
[10:25:19.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:19.415] - Launch lazy future ...
[10:25:19.416] Packages needed by the future expression (n = 1): ‘future’
[10:25:19.416] Packages needed by future strategies (n = 0): <none>
[10:25:19.416] {
[10:25:19.416]     {
[10:25:19.416]         {
[10:25:19.416]             ...future.startTime <- base::Sys.time()
[10:25:19.416]             {
[10:25:19.416]                 {
[10:25:19.416]                   {
[10:25:19.416]                     {
[10:25:19.416]                       {
[10:25:19.416]                         base::local({
[10:25:19.416]                           has_future <- base::requireNamespace("future", 
[10:25:19.416]                             quietly = TRUE)
[10:25:19.416]                           if (has_future) {
[10:25:19.416]                             ns <- base::getNamespace("future")
[10:25:19.416]                             version <- ns[[".package"]][["version"]]
[10:25:19.416]                             if (is.null(version)) 
[10:25:19.416]                               version <- utils::packageVersion("future")
[10:25:19.416]                           }
[10:25:19.416]                           else {
[10:25:19.416]                             version <- NULL
[10:25:19.416]                           }
[10:25:19.416]                           if (!has_future || version < "1.8.0") {
[10:25:19.416]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:19.416]                               "", base::R.version$version.string), 
[10:25:19.416]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:19.416]                                 base::R.version$platform, 8 * 
[10:25:19.416]                                   base::.Machine$sizeof.pointer), 
[10:25:19.416]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:19.416]                                 "release", "version")], collapse = " "), 
[10:25:19.416]                               hostname = base::Sys.info()[["nodename"]])
[10:25:19.416]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:19.416]                               info)
[10:25:19.416]                             info <- base::paste(info, collapse = "; ")
[10:25:19.416]                             if (!has_future) {
[10:25:19.416]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:19.416]                                 info)
[10:25:19.416]                             }
[10:25:19.416]                             else {
[10:25:19.416]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:19.416]                                 info, version)
[10:25:19.416]                             }
[10:25:19.416]                             base::stop(msg)
[10:25:19.416]                           }
[10:25:19.416]                         })
[10:25:19.416]                       }
[10:25:19.416]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:19.416]                       base::options(mc.cores = 1L)
[10:25:19.416]                     }
[10:25:19.416]                     base::local({
[10:25:19.416]                       for (pkg in "future") {
[10:25:19.416]                         base::loadNamespace(pkg)
[10:25:19.416]                         base::library(pkg, character.only = TRUE)
[10:25:19.416]                       }
[10:25:19.416]                     })
[10:25:19.416]                   }
[10:25:19.416]                   options(future.plan = NULL)
[10:25:19.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:19.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:19.416]                 }
[10:25:19.416]                 ...future.workdir <- getwd()
[10:25:19.416]             }
[10:25:19.416]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:19.416]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:19.416]         }
[10:25:19.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:19.416]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:19.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:19.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:19.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:19.416]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:19.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:19.416]             base::names(...future.oldOptions))
[10:25:19.416]     }
[10:25:19.416]     if (FALSE) {
[10:25:19.416]     }
[10:25:19.416]     else {
[10:25:19.416]         if (TRUE) {
[10:25:19.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:19.416]                 open = "w")
[10:25:19.416]         }
[10:25:19.416]         else {
[10:25:19.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:19.416]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:19.416]         }
[10:25:19.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:19.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:19.416]             base::sink(type = "output", split = FALSE)
[10:25:19.416]             base::close(...future.stdout)
[10:25:19.416]         }, add = TRUE)
[10:25:19.416]     }
[10:25:19.416]     ...future.frame <- base::sys.nframe()
[10:25:19.416]     ...future.conditions <- base::list()
[10:25:19.416]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:19.416]     if (FALSE) {
[10:25:19.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:19.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:19.416]     }
[10:25:19.416]     ...future.result <- base::tryCatch({
[10:25:19.416]         base::withCallingHandlers({
[10:25:19.416]             ...future.value <- base::withVisible(base::local({
[10:25:19.416]                 ...future.makeSendCondition <- base::local({
[10:25:19.416]                   sendCondition <- NULL
[10:25:19.416]                   function(frame = 1L) {
[10:25:19.416]                     if (is.function(sendCondition)) 
[10:25:19.416]                       return(sendCondition)
[10:25:19.416]                     ns <- getNamespace("parallel")
[10:25:19.416]                     if (exists("sendData", mode = "function", 
[10:25:19.416]                       envir = ns)) {
[10:25:19.416]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:19.416]                         envir = ns)
[10:25:19.416]                       envir <- sys.frame(frame)
[10:25:19.416]                       master <- NULL
[10:25:19.416]                       while (!identical(envir, .GlobalEnv) && 
[10:25:19.416]                         !identical(envir, emptyenv())) {
[10:25:19.416]                         if (exists("master", mode = "list", envir = envir, 
[10:25:19.416]                           inherits = FALSE)) {
[10:25:19.416]                           master <- get("master", mode = "list", 
[10:25:19.416]                             envir = envir, inherits = FALSE)
[10:25:19.416]                           if (inherits(master, c("SOCKnode", 
[10:25:19.416]                             "SOCK0node"))) {
[10:25:19.416]                             sendCondition <<- function(cond) {
[10:25:19.416]                               data <- list(type = "VALUE", value = cond, 
[10:25:19.416]                                 success = TRUE)
[10:25:19.416]                               parallel_sendData(master, data)
[10:25:19.416]                             }
[10:25:19.416]                             return(sendCondition)
[10:25:19.416]                           }
[10:25:19.416]                         }
[10:25:19.416]                         frame <- frame + 1L
[10:25:19.416]                         envir <- sys.frame(frame)
[10:25:19.416]                       }
[10:25:19.416]                     }
[10:25:19.416]                     sendCondition <<- function(cond) NULL
[10:25:19.416]                   }
[10:25:19.416]                 })
[10:25:19.416]                 withCallingHandlers({
[10:25:19.416]                   {
[10:25:19.416]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:25:19.416]                       ii, n), appendLF = FALSE)
[10:25:19.416]                     fit <- mandelbrot(C)
[10:25:19.416]                     delay(fit)
[10:25:19.416]                     message(" done")
[10:25:19.416]                     fit
[10:25:19.416]                   }
[10:25:19.416]                 }, immediateCondition = function(cond) {
[10:25:19.416]                   sendCondition <- ...future.makeSendCondition()
[10:25:19.416]                   sendCondition(cond)
[10:25:19.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.416]                   {
[10:25:19.416]                     inherits <- base::inherits
[10:25:19.416]                     invokeRestart <- base::invokeRestart
[10:25:19.416]                     is.null <- base::is.null
[10:25:19.416]                     muffled <- FALSE
[10:25:19.416]                     if (inherits(cond, "message")) {
[10:25:19.416]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:19.416]                       if (muffled) 
[10:25:19.416]                         invokeRestart("muffleMessage")
[10:25:19.416]                     }
[10:25:19.416]                     else if (inherits(cond, "warning")) {
[10:25:19.416]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:19.416]                       if (muffled) 
[10:25:19.416]                         invokeRestart("muffleWarning")
[10:25:19.416]                     }
[10:25:19.416]                     else if (inherits(cond, "condition")) {
[10:25:19.416]                       if (!is.null(pattern)) {
[10:25:19.416]                         computeRestarts <- base::computeRestarts
[10:25:19.416]                         grepl <- base::grepl
[10:25:19.416]                         restarts <- computeRestarts(cond)
[10:25:19.416]                         for (restart in restarts) {
[10:25:19.416]                           name <- restart$name
[10:25:19.416]                           if (is.null(name)) 
[10:25:19.416]                             next
[10:25:19.416]                           if (!grepl(pattern, name)) 
[10:25:19.416]                             next
[10:25:19.416]                           invokeRestart(restart)
[10:25:19.416]                           muffled <- TRUE
[10:25:19.416]                           break
[10:25:19.416]                         }
[10:25:19.416]                       }
[10:25:19.416]                     }
[10:25:19.416]                     invisible(muffled)
[10:25:19.416]                   }
[10:25:19.416]                   muffleCondition(cond)
[10:25:19.416]                 })
[10:25:19.416]             }))
[10:25:19.416]             future::FutureResult(value = ...future.value$value, 
[10:25:19.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:19.416]                   ...future.rng), globalenv = if (FALSE) 
[10:25:19.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:19.416]                     ...future.globalenv.names))
[10:25:19.416]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:19.416]         }, condition = base::local({
[10:25:19.416]             c <- base::c
[10:25:19.416]             inherits <- base::inherits
[10:25:19.416]             invokeRestart <- base::invokeRestart
[10:25:19.416]             length <- base::length
[10:25:19.416]             list <- base::list
[10:25:19.416]             seq.int <- base::seq.int
[10:25:19.416]             signalCondition <- base::signalCondition
[10:25:19.416]             sys.calls <- base::sys.calls
[10:25:19.416]             `[[` <- base::`[[`
[10:25:19.416]             `+` <- base::`+`
[10:25:19.416]             `<<-` <- base::`<<-`
[10:25:19.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:19.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:19.416]                   3L)]
[10:25:19.416]             }
[10:25:19.416]             function(cond) {
[10:25:19.416]                 is_error <- inherits(cond, "error")
[10:25:19.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:19.416]                   NULL)
[10:25:19.416]                 if (is_error) {
[10:25:19.416]                   sessionInformation <- function() {
[10:25:19.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:19.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:19.416]                       search = base::search(), system = base::Sys.info())
[10:25:19.416]                   }
[10:25:19.416]                   ...future.conditions[[length(...future.conditions) + 
[10:25:19.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:19.416]                     cond$call), session = sessionInformation(), 
[10:25:19.416]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:19.416]                   signalCondition(cond)
[10:25:19.416]                 }
[10:25:19.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:19.416]                 "immediateCondition"))) {
[10:25:19.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:19.416]                   ...future.conditions[[length(...future.conditions) + 
[10:25:19.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:19.416]                   if (TRUE && !signal) {
[10:25:19.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.416]                     {
[10:25:19.416]                       inherits <- base::inherits
[10:25:19.416]                       invokeRestart <- base::invokeRestart
[10:25:19.416]                       is.null <- base::is.null
[10:25:19.416]                       muffled <- FALSE
[10:25:19.416]                       if (inherits(cond, "message")) {
[10:25:19.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:19.416]                         if (muffled) 
[10:25:19.416]                           invokeRestart("muffleMessage")
[10:25:19.416]                       }
[10:25:19.416]                       else if (inherits(cond, "warning")) {
[10:25:19.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:19.416]                         if (muffled) 
[10:25:19.416]                           invokeRestart("muffleWarning")
[10:25:19.416]                       }
[10:25:19.416]                       else if (inherits(cond, "condition")) {
[10:25:19.416]                         if (!is.null(pattern)) {
[10:25:19.416]                           computeRestarts <- base::computeRestarts
[10:25:19.416]                           grepl <- base::grepl
[10:25:19.416]                           restarts <- computeRestarts(cond)
[10:25:19.416]                           for (restart in restarts) {
[10:25:19.416]                             name <- restart$name
[10:25:19.416]                             if (is.null(name)) 
[10:25:19.416]                               next
[10:25:19.416]                             if (!grepl(pattern, name)) 
[10:25:19.416]                               next
[10:25:19.416]                             invokeRestart(restart)
[10:25:19.416]                             muffled <- TRUE
[10:25:19.416]                             break
[10:25:19.416]                           }
[10:25:19.416]                         }
[10:25:19.416]                       }
[10:25:19.416]                       invisible(muffled)
[10:25:19.416]                     }
[10:25:19.416]                     muffleCondition(cond, pattern = "^muffle")
[10:25:19.416]                   }
[10:25:19.416]                 }
[10:25:19.416]                 else {
[10:25:19.416]                   if (TRUE) {
[10:25:19.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.416]                     {
[10:25:19.416]                       inherits <- base::inherits
[10:25:19.416]                       invokeRestart <- base::invokeRestart
[10:25:19.416]                       is.null <- base::is.null
[10:25:19.416]                       muffled <- FALSE
[10:25:19.416]                       if (inherits(cond, "message")) {
[10:25:19.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:19.416]                         if (muffled) 
[10:25:19.416]                           invokeRestart("muffleMessage")
[10:25:19.416]                       }
[10:25:19.416]                       else if (inherits(cond, "warning")) {
[10:25:19.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:19.416]                         if (muffled) 
[10:25:19.416]                           invokeRestart("muffleWarning")
[10:25:19.416]                       }
[10:25:19.416]                       else if (inherits(cond, "condition")) {
[10:25:19.416]                         if (!is.null(pattern)) {
[10:25:19.416]                           computeRestarts <- base::computeRestarts
[10:25:19.416]                           grepl <- base::grepl
[10:25:19.416]                           restarts <- computeRestarts(cond)
[10:25:19.416]                           for (restart in restarts) {
[10:25:19.416]                             name <- restart$name
[10:25:19.416]                             if (is.null(name)) 
[10:25:19.416]                               next
[10:25:19.416]                             if (!grepl(pattern, name)) 
[10:25:19.416]                               next
[10:25:19.416]                             invokeRestart(restart)
[10:25:19.416]                             muffled <- TRUE
[10:25:19.416]                             break
[10:25:19.416]                           }
[10:25:19.416]                         }
[10:25:19.416]                       }
[10:25:19.416]                       invisible(muffled)
[10:25:19.416]                     }
[10:25:19.416]                     muffleCondition(cond, pattern = "^muffle")
[10:25:19.416]                   }
[10:25:19.416]                 }
[10:25:19.416]             }
[10:25:19.416]         }))
[10:25:19.416]     }, error = function(ex) {
[10:25:19.416]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:19.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:19.416]                 ...future.rng), started = ...future.startTime, 
[10:25:19.416]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:19.416]             version = "1.8"), class = "FutureResult")
[10:25:19.416]     }, finally = {
[10:25:19.416]         if (!identical(...future.workdir, getwd())) 
[10:25:19.416]             setwd(...future.workdir)
[10:25:19.416]         {
[10:25:19.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:19.416]                 ...future.oldOptions$nwarnings <- NULL
[10:25:19.416]             }
[10:25:19.416]             base::options(...future.oldOptions)
[10:25:19.416]             if (.Platform$OS.type == "windows") {
[10:25:19.416]                 old_names <- names(...future.oldEnvVars)
[10:25:19.416]                 envs <- base::Sys.getenv()
[10:25:19.416]                 names <- names(envs)
[10:25:19.416]                 common <- intersect(names, old_names)
[10:25:19.416]                 added <- setdiff(names, old_names)
[10:25:19.416]                 removed <- setdiff(old_names, names)
[10:25:19.416]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:19.416]                   envs[common]]
[10:25:19.416]                 NAMES <- toupper(changed)
[10:25:19.416]                 args <- list()
[10:25:19.416]                 for (kk in seq_along(NAMES)) {
[10:25:19.416]                   name <- changed[[kk]]
[10:25:19.416]                   NAME <- NAMES[[kk]]
[10:25:19.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.416]                     next
[10:25:19.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:19.416]                 }
[10:25:19.416]                 NAMES <- toupper(added)
[10:25:19.416]                 for (kk in seq_along(NAMES)) {
[10:25:19.416]                   name <- added[[kk]]
[10:25:19.416]                   NAME <- NAMES[[kk]]
[10:25:19.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.416]                     next
[10:25:19.416]                   args[[name]] <- ""
[10:25:19.416]                 }
[10:25:19.416]                 NAMES <- toupper(removed)
[10:25:19.416]                 for (kk in seq_along(NAMES)) {
[10:25:19.416]                   name <- removed[[kk]]
[10:25:19.416]                   NAME <- NAMES[[kk]]
[10:25:19.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.416]                     next
[10:25:19.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:19.416]                 }
[10:25:19.416]                 if (length(args) > 0) 
[10:25:19.416]                   base::do.call(base::Sys.setenv, args = args)
[10:25:19.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:19.416]             }
[10:25:19.416]             else {
[10:25:19.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:19.416]             }
[10:25:19.416]             {
[10:25:19.416]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:19.416]                   0L) {
[10:25:19.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:19.416]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:19.416]                   base::options(opts)
[10:25:19.416]                 }
[10:25:19.416]                 {
[10:25:19.416]                   {
[10:25:19.416]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:19.416]                     NULL
[10:25:19.416]                   }
[10:25:19.416]                   options(future.plan = NULL)
[10:25:19.416]                   if (is.na(NA_character_)) 
[10:25:19.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:19.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:19.416]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:19.416]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:19.416]                     envir = parent.frame()) 
[10:25:19.416]                   {
[10:25:19.416]                     if (is.function(workers)) 
[10:25:19.416]                       workers <- workers()
[10:25:19.416]                     workers <- structure(as.integer(workers), 
[10:25:19.416]                       class = class(workers))
[10:25:19.416]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:19.416]                       workers >= 1)
[10:25:19.416]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:19.416]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:19.416]                     }
[10:25:19.416]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:19.416]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:19.416]                       envir = envir)
[10:25:19.416]                     if (!future$lazy) 
[10:25:19.416]                       future <- run(future)
[10:25:19.416]                     invisible(future)
[10:25:19.416]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:19.416]                 }
[10:25:19.416]             }
[10:25:19.416]         }
[10:25:19.416]     })
[10:25:19.416]     if (TRUE) {
[10:25:19.416]         base::sink(type = "output", split = FALSE)
[10:25:19.416]         if (TRUE) {
[10:25:19.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:19.416]         }
[10:25:19.416]         else {
[10:25:19.416]             ...future.result["stdout"] <- base::list(NULL)
[10:25:19.416]         }
[10:25:19.416]         base::close(...future.stdout)
[10:25:19.416]         ...future.stdout <- NULL
[10:25:19.416]     }
[10:25:19.416]     ...future.result$conditions <- ...future.conditions
[10:25:19.416]     ...future.result$finished <- base::Sys.time()
[10:25:19.416]     ...future.result
[10:25:19.416] }
[10:25:19.419] Exporting 4 global objects (14.24 KiB) to cluster node #1 ...
[10:25:19.419] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:25:19.420] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:25:19.420] Exporting ‘n’ (56 bytes) to cluster node #1 ...
[10:25:19.420] Exporting ‘n’ (56 bytes) to cluster node #1 ... DONE
[10:25:19.420] Exporting ‘C’ (10.72 KiB) to cluster node #1 ...
[10:25:19.462] Exporting ‘C’ (10.72 KiB) to cluster node #1 ... DONE
[10:25:19.462] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ...
[10:25:19.506] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ... DONE
[10:25:19.506] Exporting 4 global objects (14.24 KiB) to cluster node #1 ... DONE
[10:25:19.507] MultisessionFuture started
[10:25:19.507] - Launch lazy future ... done
[10:25:19.507] run() for ‘MultisessionFuture’ ... done
[10:25:19.507] - run() ... done
[10:25:19.507] - resolved() ...
[10:25:19.518] - resolved: FALSE
[10:25:19.518] - resolved() ... done
[10:25:19.518] resolved() for ‘MultisessionFuture’ ... done
[10:25:19.518] resolved() for ‘Future’ ...
[10:25:19.518] - state: ‘created’
[10:25:19.518] - run: TRUE
[10:25:19.519] - run() ...
[10:25:19.519] run() for ‘Future’ ...
[10:25:19.519] - state: ‘created’
[10:25:19.519] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:19.533] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:19.534] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:19.534]   - Field: ‘node’
[10:25:19.534]   - Field: ‘label’
[10:25:19.534]   - Field: ‘local’
[10:25:19.534]   - Field: ‘owner’
[10:25:19.534]   - Field: ‘envir’
[10:25:19.534]   - Field: ‘workers’
[10:25:19.534]   - Field: ‘packages’
[10:25:19.534]   - Field: ‘gc’
[10:25:19.534]   - Field: ‘conditions’
[10:25:19.535]   - Field: ‘persistent’
[10:25:19.535]   - Field: ‘expr’
[10:25:19.535]   - Field: ‘uuid’
[10:25:19.535]   - Field: ‘seed’
[10:25:19.535]   - Field: ‘version’
[10:25:19.535]   - Field: ‘result’
[10:25:19.535]   - Field: ‘asynchronous’
[10:25:19.535]   - Field: ‘calls’
[10:25:19.535]   - Field: ‘globals’
[10:25:19.535]   - Field: ‘stdout’
[10:25:19.536]   - Field: ‘earlySignal’
[10:25:19.536]   - Field: ‘lazy’
[10:25:19.536]   - Field: ‘state’
[10:25:19.536] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:19.536] - Launch lazy future ...
[10:25:19.536] Packages needed by the future expression (n = 1): ‘future’
[10:25:19.536] Packages needed by future strategies (n = 0): <none>
[10:25:19.537] {
[10:25:19.537]     {
[10:25:19.537]         {
[10:25:19.537]             ...future.startTime <- base::Sys.time()
[10:25:19.537]             {
[10:25:19.537]                 {
[10:25:19.537]                   {
[10:25:19.537]                     {
[10:25:19.537]                       {
[10:25:19.537]                         base::local({
[10:25:19.537]                           has_future <- base::requireNamespace("future", 
[10:25:19.537]                             quietly = TRUE)
[10:25:19.537]                           if (has_future) {
[10:25:19.537]                             ns <- base::getNamespace("future")
[10:25:19.537]                             version <- ns[[".package"]][["version"]]
[10:25:19.537]                             if (is.null(version)) 
[10:25:19.537]                               version <- utils::packageVersion("future")
[10:25:19.537]                           }
[10:25:19.537]                           else {
[10:25:19.537]                             version <- NULL
[10:25:19.537]                           }
[10:25:19.537]                           if (!has_future || version < "1.8.0") {
[10:25:19.537]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:19.537]                               "", base::R.version$version.string), 
[10:25:19.537]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:19.537]                                 base::R.version$platform, 8 * 
[10:25:19.537]                                   base::.Machine$sizeof.pointer), 
[10:25:19.537]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:19.537]                                 "release", "version")], collapse = " "), 
[10:25:19.537]                               hostname = base::Sys.info()[["nodename"]])
[10:25:19.537]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:19.537]                               info)
[10:25:19.537]                             info <- base::paste(info, collapse = "; ")
[10:25:19.537]                             if (!has_future) {
[10:25:19.537]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:19.537]                                 info)
[10:25:19.537]                             }
[10:25:19.537]                             else {
[10:25:19.537]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:19.537]                                 info, version)
[10:25:19.537]                             }
[10:25:19.537]                             base::stop(msg)
[10:25:19.537]                           }
[10:25:19.537]                         })
[10:25:19.537]                       }
[10:25:19.537]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:19.537]                       base::options(mc.cores = 1L)
[10:25:19.537]                     }
[10:25:19.537]                     base::local({
[10:25:19.537]                       for (pkg in "future") {
[10:25:19.537]                         base::loadNamespace(pkg)
[10:25:19.537]                         base::library(pkg, character.only = TRUE)
[10:25:19.537]                       }
[10:25:19.537]                     })
[10:25:19.537]                   }
[10:25:19.537]                   options(future.plan = NULL)
[10:25:19.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:19.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:19.537]                 }
[10:25:19.537]                 ...future.workdir <- getwd()
[10:25:19.537]             }
[10:25:19.537]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:19.537]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:19.537]         }
[10:25:19.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:19.537]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:19.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:19.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:19.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:19.537]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:19.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:19.537]             base::names(...future.oldOptions))
[10:25:19.537]     }
[10:25:19.537]     if (FALSE) {
[10:25:19.537]     }
[10:25:19.537]     else {
[10:25:19.537]         if (TRUE) {
[10:25:19.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:19.537]                 open = "w")
[10:25:19.537]         }
[10:25:19.537]         else {
[10:25:19.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:19.537]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:19.537]         }
[10:25:19.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:19.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:19.537]             base::sink(type = "output", split = FALSE)
[10:25:19.537]             base::close(...future.stdout)
[10:25:19.537]         }, add = TRUE)
[10:25:19.537]     }
[10:25:19.537]     ...future.frame <- base::sys.nframe()
[10:25:19.537]     ...future.conditions <- base::list()
[10:25:19.537]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:19.537]     if (FALSE) {
[10:25:19.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:19.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:19.537]     }
[10:25:19.537]     ...future.result <- base::tryCatch({
[10:25:19.537]         base::withCallingHandlers({
[10:25:19.537]             ...future.value <- base::withVisible(base::local({
[10:25:19.537]                 ...future.makeSendCondition <- base::local({
[10:25:19.537]                   sendCondition <- NULL
[10:25:19.537]                   function(frame = 1L) {
[10:25:19.537]                     if (is.function(sendCondition)) 
[10:25:19.537]                       return(sendCondition)
[10:25:19.537]                     ns <- getNamespace("parallel")
[10:25:19.537]                     if (exists("sendData", mode = "function", 
[10:25:19.537]                       envir = ns)) {
[10:25:19.537]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:19.537]                         envir = ns)
[10:25:19.537]                       envir <- sys.frame(frame)
[10:25:19.537]                       master <- NULL
[10:25:19.537]                       while (!identical(envir, .GlobalEnv) && 
[10:25:19.537]                         !identical(envir, emptyenv())) {
[10:25:19.537]                         if (exists("master", mode = "list", envir = envir, 
[10:25:19.537]                           inherits = FALSE)) {
[10:25:19.537]                           master <- get("master", mode = "list", 
[10:25:19.537]                             envir = envir, inherits = FALSE)
[10:25:19.537]                           if (inherits(master, c("SOCKnode", 
[10:25:19.537]                             "SOCK0node"))) {
[10:25:19.537]                             sendCondition <<- function(cond) {
[10:25:19.537]                               data <- list(type = "VALUE", value = cond, 
[10:25:19.537]                                 success = TRUE)
[10:25:19.537]                               parallel_sendData(master, data)
[10:25:19.537]                             }
[10:25:19.537]                             return(sendCondition)
[10:25:19.537]                           }
[10:25:19.537]                         }
[10:25:19.537]                         frame <- frame + 1L
[10:25:19.537]                         envir <- sys.frame(frame)
[10:25:19.537]                       }
[10:25:19.537]                     }
[10:25:19.537]                     sendCondition <<- function(cond) NULL
[10:25:19.537]                   }
[10:25:19.537]                 })
[10:25:19.537]                 withCallingHandlers({
[10:25:19.537]                   {
[10:25:19.537]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:25:19.537]                       ii, n), appendLF = FALSE)
[10:25:19.537]                     fit <- mandelbrot(C)
[10:25:19.537]                     delay(fit)
[10:25:19.537]                     message(" done")
[10:25:19.537]                     fit
[10:25:19.537]                   }
[10:25:19.537]                 }, immediateCondition = function(cond) {
[10:25:19.537]                   sendCondition <- ...future.makeSendCondition()
[10:25:19.537]                   sendCondition(cond)
[10:25:19.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.537]                   {
[10:25:19.537]                     inherits <- base::inherits
[10:25:19.537]                     invokeRestart <- base::invokeRestart
[10:25:19.537]                     is.null <- base::is.null
[10:25:19.537]                     muffled <- FALSE
[10:25:19.537]                     if (inherits(cond, "message")) {
[10:25:19.537]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:19.537]                       if (muffled) 
[10:25:19.537]                         invokeRestart("muffleMessage")
[10:25:19.537]                     }
[10:25:19.537]                     else if (inherits(cond, "warning")) {
[10:25:19.537]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:19.537]                       if (muffled) 
[10:25:19.537]                         invokeRestart("muffleWarning")
[10:25:19.537]                     }
[10:25:19.537]                     else if (inherits(cond, "condition")) {
[10:25:19.537]                       if (!is.null(pattern)) {
[10:25:19.537]                         computeRestarts <- base::computeRestarts
[10:25:19.537]                         grepl <- base::grepl
[10:25:19.537]                         restarts <- computeRestarts(cond)
[10:25:19.537]                         for (restart in restarts) {
[10:25:19.537]                           name <- restart$name
[10:25:19.537]                           if (is.null(name)) 
[10:25:19.537]                             next
[10:25:19.537]                           if (!grepl(pattern, name)) 
[10:25:19.537]                             next
[10:25:19.537]                           invokeRestart(restart)
[10:25:19.537]                           muffled <- TRUE
[10:25:19.537]                           break
[10:25:19.537]                         }
[10:25:19.537]                       }
[10:25:19.537]                     }
[10:25:19.537]                     invisible(muffled)
[10:25:19.537]                   }
[10:25:19.537]                   muffleCondition(cond)
[10:25:19.537]                 })
[10:25:19.537]             }))
[10:25:19.537]             future::FutureResult(value = ...future.value$value, 
[10:25:19.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:19.537]                   ...future.rng), globalenv = if (FALSE) 
[10:25:19.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:19.537]                     ...future.globalenv.names))
[10:25:19.537]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:19.537]         }, condition = base::local({
[10:25:19.537]             c <- base::c
[10:25:19.537]             inherits <- base::inherits
[10:25:19.537]             invokeRestart <- base::invokeRestart
[10:25:19.537]             length <- base::length
[10:25:19.537]             list <- base::list
[10:25:19.537]             seq.int <- base::seq.int
[10:25:19.537]             signalCondition <- base::signalCondition
[10:25:19.537]             sys.calls <- base::sys.calls
[10:25:19.537]             `[[` <- base::`[[`
[10:25:19.537]             `+` <- base::`+`
[10:25:19.537]             `<<-` <- base::`<<-`
[10:25:19.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:19.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:19.537]                   3L)]
[10:25:19.537]             }
[10:25:19.537]             function(cond) {
[10:25:19.537]                 is_error <- inherits(cond, "error")
[10:25:19.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:19.537]                   NULL)
[10:25:19.537]                 if (is_error) {
[10:25:19.537]                   sessionInformation <- function() {
[10:25:19.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:19.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:19.537]                       search = base::search(), system = base::Sys.info())
[10:25:19.537]                   }
[10:25:19.537]                   ...future.conditions[[length(...future.conditions) + 
[10:25:19.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:19.537]                     cond$call), session = sessionInformation(), 
[10:25:19.537]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:19.537]                   signalCondition(cond)
[10:25:19.537]                 }
[10:25:19.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:19.537]                 "immediateCondition"))) {
[10:25:19.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:19.537]                   ...future.conditions[[length(...future.conditions) + 
[10:25:19.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:19.537]                   if (TRUE && !signal) {
[10:25:19.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.537]                     {
[10:25:19.537]                       inherits <- base::inherits
[10:25:19.537]                       invokeRestart <- base::invokeRestart
[10:25:19.537]                       is.null <- base::is.null
[10:25:19.537]                       muffled <- FALSE
[10:25:19.537]                       if (inherits(cond, "message")) {
[10:25:19.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:19.537]                         if (muffled) 
[10:25:19.537]                           invokeRestart("muffleMessage")
[10:25:19.537]                       }
[10:25:19.537]                       else if (inherits(cond, "warning")) {
[10:25:19.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:19.537]                         if (muffled) 
[10:25:19.537]                           invokeRestart("muffleWarning")
[10:25:19.537]                       }
[10:25:19.537]                       else if (inherits(cond, "condition")) {
[10:25:19.537]                         if (!is.null(pattern)) {
[10:25:19.537]                           computeRestarts <- base::computeRestarts
[10:25:19.537]                           grepl <- base::grepl
[10:25:19.537]                           restarts <- computeRestarts(cond)
[10:25:19.537]                           for (restart in restarts) {
[10:25:19.537]                             name <- restart$name
[10:25:19.537]                             if (is.null(name)) 
[10:25:19.537]                               next
[10:25:19.537]                             if (!grepl(pattern, name)) 
[10:25:19.537]                               next
[10:25:19.537]                             invokeRestart(restart)
[10:25:19.537]                             muffled <- TRUE
[10:25:19.537]                             break
[10:25:19.537]                           }
[10:25:19.537]                         }
[10:25:19.537]                       }
[10:25:19.537]                       invisible(muffled)
[10:25:19.537]                     }
[10:25:19.537]                     muffleCondition(cond, pattern = "^muffle")
[10:25:19.537]                   }
[10:25:19.537]                 }
[10:25:19.537]                 else {
[10:25:19.537]                   if (TRUE) {
[10:25:19.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.537]                     {
[10:25:19.537]                       inherits <- base::inherits
[10:25:19.537]                       invokeRestart <- base::invokeRestart
[10:25:19.537]                       is.null <- base::is.null
[10:25:19.537]                       muffled <- FALSE
[10:25:19.537]                       if (inherits(cond, "message")) {
[10:25:19.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:19.537]                         if (muffled) 
[10:25:19.537]                           invokeRestart("muffleMessage")
[10:25:19.537]                       }
[10:25:19.537]                       else if (inherits(cond, "warning")) {
[10:25:19.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:19.537]                         if (muffled) 
[10:25:19.537]                           invokeRestart("muffleWarning")
[10:25:19.537]                       }
[10:25:19.537]                       else if (inherits(cond, "condition")) {
[10:25:19.537]                         if (!is.null(pattern)) {
[10:25:19.537]                           computeRestarts <- base::computeRestarts
[10:25:19.537]                           grepl <- base::grepl
[10:25:19.537]                           restarts <- computeRestarts(cond)
[10:25:19.537]                           for (restart in restarts) {
[10:25:19.537]                             name <- restart$name
[10:25:19.537]                             if (is.null(name)) 
[10:25:19.537]                               next
[10:25:19.537]                             if (!grepl(pattern, name)) 
[10:25:19.537]                               next
[10:25:19.537]                             invokeRestart(restart)
[10:25:19.537]                             muffled <- TRUE
[10:25:19.537]                             break
[10:25:19.537]                           }
[10:25:19.537]                         }
[10:25:19.537]                       }
[10:25:19.537]                       invisible(muffled)
[10:25:19.537]                     }
[10:25:19.537]                     muffleCondition(cond, pattern = "^muffle")
[10:25:19.537]                   }
[10:25:19.537]                 }
[10:25:19.537]             }
[10:25:19.537]         }))
[10:25:19.537]     }, error = function(ex) {
[10:25:19.537]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:19.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:19.537]                 ...future.rng), started = ...future.startTime, 
[10:25:19.537]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:19.537]             version = "1.8"), class = "FutureResult")
[10:25:19.537]     }, finally = {
[10:25:19.537]         if (!identical(...future.workdir, getwd())) 
[10:25:19.537]             setwd(...future.workdir)
[10:25:19.537]         {
[10:25:19.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:19.537]                 ...future.oldOptions$nwarnings <- NULL
[10:25:19.537]             }
[10:25:19.537]             base::options(...future.oldOptions)
[10:25:19.537]             if (.Platform$OS.type == "windows") {
[10:25:19.537]                 old_names <- names(...future.oldEnvVars)
[10:25:19.537]                 envs <- base::Sys.getenv()
[10:25:19.537]                 names <- names(envs)
[10:25:19.537]                 common <- intersect(names, old_names)
[10:25:19.537]                 added <- setdiff(names, old_names)
[10:25:19.537]                 removed <- setdiff(old_names, names)
[10:25:19.537]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:19.537]                   envs[common]]
[10:25:19.537]                 NAMES <- toupper(changed)
[10:25:19.537]                 args <- list()
[10:25:19.537]                 for (kk in seq_along(NAMES)) {
[10:25:19.537]                   name <- changed[[kk]]
[10:25:19.537]                   NAME <- NAMES[[kk]]
[10:25:19.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.537]                     next
[10:25:19.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:19.537]                 }
[10:25:19.537]                 NAMES <- toupper(added)
[10:25:19.537]                 for (kk in seq_along(NAMES)) {
[10:25:19.537]                   name <- added[[kk]]
[10:25:19.537]                   NAME <- NAMES[[kk]]
[10:25:19.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.537]                     next
[10:25:19.537]                   args[[name]] <- ""
[10:25:19.537]                 }
[10:25:19.537]                 NAMES <- toupper(removed)
[10:25:19.537]                 for (kk in seq_along(NAMES)) {
[10:25:19.537]                   name <- removed[[kk]]
[10:25:19.537]                   NAME <- NAMES[[kk]]
[10:25:19.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.537]                     next
[10:25:19.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:19.537]                 }
[10:25:19.537]                 if (length(args) > 0) 
[10:25:19.537]                   base::do.call(base::Sys.setenv, args = args)
[10:25:19.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:19.537]             }
[10:25:19.537]             else {
[10:25:19.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:19.537]             }
[10:25:19.537]             {
[10:25:19.537]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:19.537]                   0L) {
[10:25:19.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:19.537]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:19.537]                   base::options(opts)
[10:25:19.537]                 }
[10:25:19.537]                 {
[10:25:19.537]                   {
[10:25:19.537]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:19.537]                     NULL
[10:25:19.537]                   }
[10:25:19.537]                   options(future.plan = NULL)
[10:25:19.537]                   if (is.na(NA_character_)) 
[10:25:19.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:19.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:19.537]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:19.537]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:19.537]                     envir = parent.frame()) 
[10:25:19.537]                   {
[10:25:19.537]                     if (is.function(workers)) 
[10:25:19.537]                       workers <- workers()
[10:25:19.537]                     workers <- structure(as.integer(workers), 
[10:25:19.537]                       class = class(workers))
[10:25:19.537]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:19.537]                       workers >= 1)
[10:25:19.537]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:19.537]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:19.537]                     }
[10:25:19.537]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:19.537]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:19.537]                       envir = envir)
[10:25:19.537]                     if (!future$lazy) 
[10:25:19.537]                       future <- run(future)
[10:25:19.537]                     invisible(future)
[10:25:19.537]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:19.537]                 }
[10:25:19.537]             }
[10:25:19.537]         }
[10:25:19.537]     })
[10:25:19.537]     if (TRUE) {
[10:25:19.537]         base::sink(type = "output", split = FALSE)
[10:25:19.537]         if (TRUE) {
[10:25:19.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:19.537]         }
[10:25:19.537]         else {
[10:25:19.537]             ...future.result["stdout"] <- base::list(NULL)
[10:25:19.537]         }
[10:25:19.537]         base::close(...future.stdout)
[10:25:19.537]         ...future.stdout <- NULL
[10:25:19.537]     }
[10:25:19.537]     ...future.result$conditions <- ...future.conditions
[10:25:19.537]     ...future.result$finished <- base::Sys.time()
[10:25:19.537]     ...future.result
[10:25:19.537] }
[10:25:19.593] Exporting 4 global objects (14.24 KiB) to cluster node #2 ...
[10:25:19.593] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:25:19.593] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:25:19.593] Exporting ‘n’ (56 bytes) to cluster node #2 ...
[10:25:19.594] Exporting ‘n’ (56 bytes) to cluster node #2 ... DONE
[10:25:19.594] Exporting ‘C’ (10.72 KiB) to cluster node #2 ...
[10:25:19.638] Exporting ‘C’ (10.72 KiB) to cluster node #2 ... DONE
[10:25:19.638] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ...
[10:25:19.682] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ... DONE
[10:25:19.682] Exporting 4 global objects (14.24 KiB) to cluster node #2 ... DONE
[10:25:19.683] MultisessionFuture started
[10:25:19.683] - Launch lazy future ... done
[10:25:19.683] run() for ‘MultisessionFuture’ ... done
[10:25:19.683] - run() ... done
[10:25:19.683] - resolved() ...
[10:25:19.694] - resolved: FALSE
[10:25:19.694] - resolved() ... done
[10:25:19.694] resolved() for ‘MultisessionFuture’ ... done
[10:25:19.694] resolved() for ‘Future’ ...
[10:25:19.694] - state: ‘created’
[10:25:19.694] - run: TRUE
[10:25:19.694] - run() ...
[10:25:19.695] run() for ‘Future’ ...
[10:25:19.695] - state: ‘created’
[10:25:19.695] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:19.709] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:19.709] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:19.709]   - Field: ‘node’
[10:25:19.709]   - Field: ‘label’
[10:25:19.709]   - Field: ‘local’
[10:25:19.709]   - Field: ‘owner’
[10:25:19.709]   - Field: ‘envir’
[10:25:19.709]   - Field: ‘workers’
[10:25:19.710]   - Field: ‘packages’
[10:25:19.710]   - Field: ‘gc’
[10:25:19.710]   - Field: ‘conditions’
[10:25:19.710]   - Field: ‘persistent’
[10:25:19.710]   - Field: ‘expr’
[10:25:19.710]   - Field: ‘uuid’
[10:25:19.710]   - Field: ‘seed’
[10:25:19.710]   - Field: ‘version’
[10:25:19.710]   - Field: ‘result’
[10:25:19.710]   - Field: ‘asynchronous’
[10:25:19.710]   - Field: ‘calls’
[10:25:19.711]   - Field: ‘globals’
[10:25:19.711]   - Field: ‘stdout’
[10:25:19.711]   - Field: ‘earlySignal’
[10:25:19.711]   - Field: ‘lazy’
[10:25:19.711]   - Field: ‘state’
[10:25:19.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:19.711] - Launch lazy future ...
[10:25:19.711] Packages needed by the future expression (n = 1): ‘future’
[10:25:19.711] Packages needed by future strategies (n = 0): <none>
[10:25:19.712] {
[10:25:19.712]     {
[10:25:19.712]         {
[10:25:19.712]             ...future.startTime <- base::Sys.time()
[10:25:19.712]             {
[10:25:19.712]                 {
[10:25:19.712]                   {
[10:25:19.712]                     {
[10:25:19.712]                       {
[10:25:19.712]                         base::local({
[10:25:19.712]                           has_future <- base::requireNamespace("future", 
[10:25:19.712]                             quietly = TRUE)
[10:25:19.712]                           if (has_future) {
[10:25:19.712]                             ns <- base::getNamespace("future")
[10:25:19.712]                             version <- ns[[".package"]][["version"]]
[10:25:19.712]                             if (is.null(version)) 
[10:25:19.712]                               version <- utils::packageVersion("future")
[10:25:19.712]                           }
[10:25:19.712]                           else {
[10:25:19.712]                             version <- NULL
[10:25:19.712]                           }
[10:25:19.712]                           if (!has_future || version < "1.8.0") {
[10:25:19.712]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:19.712]                               "", base::R.version$version.string), 
[10:25:19.712]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:19.712]                                 base::R.version$platform, 8 * 
[10:25:19.712]                                   base::.Machine$sizeof.pointer), 
[10:25:19.712]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:19.712]                                 "release", "version")], collapse = " "), 
[10:25:19.712]                               hostname = base::Sys.info()[["nodename"]])
[10:25:19.712]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:19.712]                               info)
[10:25:19.712]                             info <- base::paste(info, collapse = "; ")
[10:25:19.712]                             if (!has_future) {
[10:25:19.712]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:19.712]                                 info)
[10:25:19.712]                             }
[10:25:19.712]                             else {
[10:25:19.712]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:19.712]                                 info, version)
[10:25:19.712]                             }
[10:25:19.712]                             base::stop(msg)
[10:25:19.712]                           }
[10:25:19.712]                         })
[10:25:19.712]                       }
[10:25:19.712]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:19.712]                       base::options(mc.cores = 1L)
[10:25:19.712]                     }
[10:25:19.712]                     base::local({
[10:25:19.712]                       for (pkg in "future") {
[10:25:19.712]                         base::loadNamespace(pkg)
[10:25:19.712]                         base::library(pkg, character.only = TRUE)
[10:25:19.712]                       }
[10:25:19.712]                     })
[10:25:19.712]                   }
[10:25:19.712]                   options(future.plan = NULL)
[10:25:19.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:19.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:19.712]                 }
[10:25:19.712]                 ...future.workdir <- getwd()
[10:25:19.712]             }
[10:25:19.712]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:19.712]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:19.712]         }
[10:25:19.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:19.712]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:19.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:19.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:19.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:19.712]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:19.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:19.712]             base::names(...future.oldOptions))
[10:25:19.712]     }
[10:25:19.712]     if (FALSE) {
[10:25:19.712]     }
[10:25:19.712]     else {
[10:25:19.712]         if (TRUE) {
[10:25:19.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:19.712]                 open = "w")
[10:25:19.712]         }
[10:25:19.712]         else {
[10:25:19.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:19.712]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:19.712]         }
[10:25:19.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:19.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:19.712]             base::sink(type = "output", split = FALSE)
[10:25:19.712]             base::close(...future.stdout)
[10:25:19.712]         }, add = TRUE)
[10:25:19.712]     }
[10:25:19.712]     ...future.frame <- base::sys.nframe()
[10:25:19.712]     ...future.conditions <- base::list()
[10:25:19.712]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:19.712]     if (FALSE) {
[10:25:19.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:19.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:19.712]     }
[10:25:19.712]     ...future.result <- base::tryCatch({
[10:25:19.712]         base::withCallingHandlers({
[10:25:19.712]             ...future.value <- base::withVisible(base::local({
[10:25:19.712]                 ...future.makeSendCondition <- base::local({
[10:25:19.712]                   sendCondition <- NULL
[10:25:19.712]                   function(frame = 1L) {
[10:25:19.712]                     if (is.function(sendCondition)) 
[10:25:19.712]                       return(sendCondition)
[10:25:19.712]                     ns <- getNamespace("parallel")
[10:25:19.712]                     if (exists("sendData", mode = "function", 
[10:25:19.712]                       envir = ns)) {
[10:25:19.712]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:19.712]                         envir = ns)
[10:25:19.712]                       envir <- sys.frame(frame)
[10:25:19.712]                       master <- NULL
[10:25:19.712]                       while (!identical(envir, .GlobalEnv) && 
[10:25:19.712]                         !identical(envir, emptyenv())) {
[10:25:19.712]                         if (exists("master", mode = "list", envir = envir, 
[10:25:19.712]                           inherits = FALSE)) {
[10:25:19.712]                           master <- get("master", mode = "list", 
[10:25:19.712]                             envir = envir, inherits = FALSE)
[10:25:19.712]                           if (inherits(master, c("SOCKnode", 
[10:25:19.712]                             "SOCK0node"))) {
[10:25:19.712]                             sendCondition <<- function(cond) {
[10:25:19.712]                               data <- list(type = "VALUE", value = cond, 
[10:25:19.712]                                 success = TRUE)
[10:25:19.712]                               parallel_sendData(master, data)
[10:25:19.712]                             }
[10:25:19.712]                             return(sendCondition)
[10:25:19.712]                           }
[10:25:19.712]                         }
[10:25:19.712]                         frame <- frame + 1L
[10:25:19.712]                         envir <- sys.frame(frame)
[10:25:19.712]                       }
[10:25:19.712]                     }
[10:25:19.712]                     sendCondition <<- function(cond) NULL
[10:25:19.712]                   }
[10:25:19.712]                 })
[10:25:19.712]                 withCallingHandlers({
[10:25:19.712]                   {
[10:25:19.712]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:25:19.712]                       ii, n), appendLF = FALSE)
[10:25:19.712]                     fit <- mandelbrot(C)
[10:25:19.712]                     delay(fit)
[10:25:19.712]                     message(" done")
[10:25:19.712]                     fit
[10:25:19.712]                   }
[10:25:19.712]                 }, immediateCondition = function(cond) {
[10:25:19.712]                   sendCondition <- ...future.makeSendCondition()
[10:25:19.712]                   sendCondition(cond)
[10:25:19.712]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.712]                   {
[10:25:19.712]                     inherits <- base::inherits
[10:25:19.712]                     invokeRestart <- base::invokeRestart
[10:25:19.712]                     is.null <- base::is.null
[10:25:19.712]                     muffled <- FALSE
[10:25:19.712]                     if (inherits(cond, "message")) {
[10:25:19.712]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:19.712]                       if (muffled) 
[10:25:19.712]                         invokeRestart("muffleMessage")
[10:25:19.712]                     }
[10:25:19.712]                     else if (inherits(cond, "warning")) {
[10:25:19.712]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:19.712]                       if (muffled) 
[10:25:19.712]                         invokeRestart("muffleWarning")
[10:25:19.712]                     }
[10:25:19.712]                     else if (inherits(cond, "condition")) {
[10:25:19.712]                       if (!is.null(pattern)) {
[10:25:19.712]                         computeRestarts <- base::computeRestarts
[10:25:19.712]                         grepl <- base::grepl
[10:25:19.712]                         restarts <- computeRestarts(cond)
[10:25:19.712]                         for (restart in restarts) {
[10:25:19.712]                           name <- restart$name
[10:25:19.712]                           if (is.null(name)) 
[10:25:19.712]                             next
[10:25:19.712]                           if (!grepl(pattern, name)) 
[10:25:19.712]                             next
[10:25:19.712]                           invokeRestart(restart)
[10:25:19.712]                           muffled <- TRUE
[10:25:19.712]                           break
[10:25:19.712]                         }
[10:25:19.712]                       }
[10:25:19.712]                     }
[10:25:19.712]                     invisible(muffled)
[10:25:19.712]                   }
[10:25:19.712]                   muffleCondition(cond)
[10:25:19.712]                 })
[10:25:19.712]             }))
[10:25:19.712]             future::FutureResult(value = ...future.value$value, 
[10:25:19.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:19.712]                   ...future.rng), globalenv = if (FALSE) 
[10:25:19.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:19.712]                     ...future.globalenv.names))
[10:25:19.712]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:19.712]         }, condition = base::local({
[10:25:19.712]             c <- base::c
[10:25:19.712]             inherits <- base::inherits
[10:25:19.712]             invokeRestart <- base::invokeRestart
[10:25:19.712]             length <- base::length
[10:25:19.712]             list <- base::list
[10:25:19.712]             seq.int <- base::seq.int
[10:25:19.712]             signalCondition <- base::signalCondition
[10:25:19.712]             sys.calls <- base::sys.calls
[10:25:19.712]             `[[` <- base::`[[`
[10:25:19.712]             `+` <- base::`+`
[10:25:19.712]             `<<-` <- base::`<<-`
[10:25:19.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:19.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:19.712]                   3L)]
[10:25:19.712]             }
[10:25:19.712]             function(cond) {
[10:25:19.712]                 is_error <- inherits(cond, "error")
[10:25:19.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:19.712]                   NULL)
[10:25:19.712]                 if (is_error) {
[10:25:19.712]                   sessionInformation <- function() {
[10:25:19.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:19.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:19.712]                       search = base::search(), system = base::Sys.info())
[10:25:19.712]                   }
[10:25:19.712]                   ...future.conditions[[length(...future.conditions) + 
[10:25:19.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:19.712]                     cond$call), session = sessionInformation(), 
[10:25:19.712]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:19.712]                   signalCondition(cond)
[10:25:19.712]                 }
[10:25:19.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:19.712]                 "immediateCondition"))) {
[10:25:19.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:19.712]                   ...future.conditions[[length(...future.conditions) + 
[10:25:19.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:19.712]                   if (TRUE && !signal) {
[10:25:19.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.712]                     {
[10:25:19.712]                       inherits <- base::inherits
[10:25:19.712]                       invokeRestart <- base::invokeRestart
[10:25:19.712]                       is.null <- base::is.null
[10:25:19.712]                       muffled <- FALSE
[10:25:19.712]                       if (inherits(cond, "message")) {
[10:25:19.712]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:19.712]                         if (muffled) 
[10:25:19.712]                           invokeRestart("muffleMessage")
[10:25:19.712]                       }
[10:25:19.712]                       else if (inherits(cond, "warning")) {
[10:25:19.712]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:19.712]                         if (muffled) 
[10:25:19.712]                           invokeRestart("muffleWarning")
[10:25:19.712]                       }
[10:25:19.712]                       else if (inherits(cond, "condition")) {
[10:25:19.712]                         if (!is.null(pattern)) {
[10:25:19.712]                           computeRestarts <- base::computeRestarts
[10:25:19.712]                           grepl <- base::grepl
[10:25:19.712]                           restarts <- computeRestarts(cond)
[10:25:19.712]                           for (restart in restarts) {
[10:25:19.712]                             name <- restart$name
[10:25:19.712]                             if (is.null(name)) 
[10:25:19.712]                               next
[10:25:19.712]                             if (!grepl(pattern, name)) 
[10:25:19.712]                               next
[10:25:19.712]                             invokeRestart(restart)
[10:25:19.712]                             muffled <- TRUE
[10:25:19.712]                             break
[10:25:19.712]                           }
[10:25:19.712]                         }
[10:25:19.712]                       }
[10:25:19.712]                       invisible(muffled)
[10:25:19.712]                     }
[10:25:19.712]                     muffleCondition(cond, pattern = "^muffle")
[10:25:19.712]                   }
[10:25:19.712]                 }
[10:25:19.712]                 else {
[10:25:19.712]                   if (TRUE) {
[10:25:19.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.712]                     {
[10:25:19.712]                       inherits <- base::inherits
[10:25:19.712]                       invokeRestart <- base::invokeRestart
[10:25:19.712]                       is.null <- base::is.null
[10:25:19.712]                       muffled <- FALSE
[10:25:19.712]                       if (inherits(cond, "message")) {
[10:25:19.712]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:19.712]                         if (muffled) 
[10:25:19.712]                           invokeRestart("muffleMessage")
[10:25:19.712]                       }
[10:25:19.712]                       else if (inherits(cond, "warning")) {
[10:25:19.712]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:19.712]                         if (muffled) 
[10:25:19.712]                           invokeRestart("muffleWarning")
[10:25:19.712]                       }
[10:25:19.712]                       else if (inherits(cond, "condition")) {
[10:25:19.712]                         if (!is.null(pattern)) {
[10:25:19.712]                           computeRestarts <- base::computeRestarts
[10:25:19.712]                           grepl <- base::grepl
[10:25:19.712]                           restarts <- computeRestarts(cond)
[10:25:19.712]                           for (restart in restarts) {
[10:25:19.712]                             name <- restart$name
[10:25:19.712]                             if (is.null(name)) 
[10:25:19.712]                               next
[10:25:19.712]                             if (!grepl(pattern, name)) 
[10:25:19.712]                               next
[10:25:19.712]                             invokeRestart(restart)
[10:25:19.712]                             muffled <- TRUE
[10:25:19.712]                             break
[10:25:19.712]                           }
[10:25:19.712]                         }
[10:25:19.712]                       }
[10:25:19.712]                       invisible(muffled)
[10:25:19.712]                     }
[10:25:19.712]                     muffleCondition(cond, pattern = "^muffle")
[10:25:19.712]                   }
[10:25:19.712]                 }
[10:25:19.712]             }
[10:25:19.712]         }))
[10:25:19.712]     }, error = function(ex) {
[10:25:19.712]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:19.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:19.712]                 ...future.rng), started = ...future.startTime, 
[10:25:19.712]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:19.712]             version = "1.8"), class = "FutureResult")
[10:25:19.712]     }, finally = {
[10:25:19.712]         if (!identical(...future.workdir, getwd())) 
[10:25:19.712]             setwd(...future.workdir)
[10:25:19.712]         {
[10:25:19.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:19.712]                 ...future.oldOptions$nwarnings <- NULL
[10:25:19.712]             }
[10:25:19.712]             base::options(...future.oldOptions)
[10:25:19.712]             if (.Platform$OS.type == "windows") {
[10:25:19.712]                 old_names <- names(...future.oldEnvVars)
[10:25:19.712]                 envs <- base::Sys.getenv()
[10:25:19.712]                 names <- names(envs)
[10:25:19.712]                 common <- intersect(names, old_names)
[10:25:19.712]                 added <- setdiff(names, old_names)
[10:25:19.712]                 removed <- setdiff(old_names, names)
[10:25:19.712]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:19.712]                   envs[common]]
[10:25:19.712]                 NAMES <- toupper(changed)
[10:25:19.712]                 args <- list()
[10:25:19.712]                 for (kk in seq_along(NAMES)) {
[10:25:19.712]                   name <- changed[[kk]]
[10:25:19.712]                   NAME <- NAMES[[kk]]
[10:25:19.712]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.712]                     next
[10:25:19.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:19.712]                 }
[10:25:19.712]                 NAMES <- toupper(added)
[10:25:19.712]                 for (kk in seq_along(NAMES)) {
[10:25:19.712]                   name <- added[[kk]]
[10:25:19.712]                   NAME <- NAMES[[kk]]
[10:25:19.712]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.712]                     next
[10:25:19.712]                   args[[name]] <- ""
[10:25:19.712]                 }
[10:25:19.712]                 NAMES <- toupper(removed)
[10:25:19.712]                 for (kk in seq_along(NAMES)) {
[10:25:19.712]                   name <- removed[[kk]]
[10:25:19.712]                   NAME <- NAMES[[kk]]
[10:25:19.712]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.712]                     next
[10:25:19.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:19.712]                 }
[10:25:19.712]                 if (length(args) > 0) 
[10:25:19.712]                   base::do.call(base::Sys.setenv, args = args)
[10:25:19.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:19.712]             }
[10:25:19.712]             else {
[10:25:19.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:19.712]             }
[10:25:19.712]             {
[10:25:19.712]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:19.712]                   0L) {
[10:25:19.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:19.712]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:19.712]                   base::options(opts)
[10:25:19.712]                 }
[10:25:19.712]                 {
[10:25:19.712]                   {
[10:25:19.712]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:19.712]                     NULL
[10:25:19.712]                   }
[10:25:19.712]                   options(future.plan = NULL)
[10:25:19.712]                   if (is.na(NA_character_)) 
[10:25:19.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:19.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:19.712]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:19.712]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:19.712]                     envir = parent.frame()) 
[10:25:19.712]                   {
[10:25:19.712]                     if (is.function(workers)) 
[10:25:19.712]                       workers <- workers()
[10:25:19.712]                     workers <- structure(as.integer(workers), 
[10:25:19.712]                       class = class(workers))
[10:25:19.712]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:19.712]                       workers >= 1)
[10:25:19.712]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:19.712]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:19.712]                     }
[10:25:19.712]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:19.712]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:19.712]                       envir = envir)
[10:25:19.712]                     if (!future$lazy) 
[10:25:19.712]                       future <- run(future)
[10:25:19.712]                     invisible(future)
[10:25:19.712]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:19.712]                 }
[10:25:19.712]             }
[10:25:19.712]         }
[10:25:19.712]     })
[10:25:19.712]     if (TRUE) {
[10:25:19.712]         base::sink(type = "output", split = FALSE)
[10:25:19.712]         if (TRUE) {
[10:25:19.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:19.712]         }
[10:25:19.712]         else {
[10:25:19.712]             ...future.result["stdout"] <- base::list(NULL)
[10:25:19.712]         }
[10:25:19.712]         base::close(...future.stdout)
[10:25:19.712]         ...future.stdout <- NULL
[10:25:19.712]     }
[10:25:19.712]     ...future.result$conditions <- ...future.conditions
[10:25:19.712]     ...future.result$finished <- base::Sys.time()
[10:25:19.712]     ...future.result
[10:25:19.712] }
[10:25:19.714] Poll #1 (0): usedNodes() = 2, workers = 2
[10:25:19.733] receiveMessageFromWorker() for ClusterFuture ...
[10:25:19.733] - Validating connection of MultisessionFuture
[10:25:19.734] - received message: FutureResult
[10:25:19.734] - Received FutureResult
[10:25:19.734] - Erased future from FutureRegistry
[10:25:19.734] result() for ClusterFuture ...
[10:25:19.734] - result already collected: FutureResult
[10:25:19.734] result() for ClusterFuture ... done
[10:25:19.734] signalConditions() ...
[10:25:19.734]  - include = ‘immediateCondition’
[10:25:19.735]  - exclude = 
[10:25:19.735]  - resignal = FALSE
[10:25:19.735]  - Number of conditions: 2
[10:25:19.735] signalConditions() ... done
[10:25:19.735] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:19.735] result() for ClusterFuture ...
[10:25:19.735] - result already collected: FutureResult
[10:25:19.735] result() for ClusterFuture ... done
[10:25:19.735] result() for ClusterFuture ...
[10:25:19.735] - result already collected: FutureResult
[10:25:19.735] result() for ClusterFuture ... done
[10:25:19.736] signalConditions() ...
[10:25:19.736]  - include = ‘immediateCondition’
[10:25:19.736]  - exclude = 
[10:25:19.736]  - resignal = FALSE
[10:25:19.736]  - Number of conditions: 2
[10:25:19.736] signalConditions() ... done
[10:25:19.737] Exporting 4 global objects (14.24 KiB) to cluster node #1 ...
[10:25:19.737] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:25:19.737] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:25:19.738] Exporting ‘n’ (56 bytes) to cluster node #1 ...
[10:25:19.738] Exporting ‘n’ (56 bytes) to cluster node #1 ... DONE
[10:25:19.738] Exporting ‘C’ (10.72 KiB) to cluster node #1 ...
[10:25:19.782] Exporting ‘C’ (10.72 KiB) to cluster node #1 ... DONE
[10:25:19.782] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ...
[10:25:19.830] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ... DONE
[10:25:19.830] Exporting 4 global objects (14.24 KiB) to cluster node #1 ... DONE
[10:25:19.831] MultisessionFuture started
[10:25:19.831] - Launch lazy future ... done
[10:25:19.831] run() for ‘MultisessionFuture’ ... done
[10:25:19.832] - run() ... done
[10:25:19.832] - resolved() ...
[10:25:19.842] - resolved: FALSE
[10:25:19.842] - resolved() ... done
[10:25:19.842] resolved() for ‘MultisessionFuture’ ... done
[10:25:19.843] resolved() for ‘Future’ ...
[10:25:19.843] - state: ‘created’
[10:25:19.843] - run: TRUE
[10:25:19.843] - run() ...
[10:25:19.843] run() for ‘Future’ ...
[10:25:19.843] - state: ‘created’
[10:25:19.843] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:19.858] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:19.858] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:19.858]   - Field: ‘node’
[10:25:19.858]   - Field: ‘label’
[10:25:19.858]   - Field: ‘local’
[10:25:19.858]   - Field: ‘owner’
[10:25:19.858]   - Field: ‘envir’
[10:25:19.858]   - Field: ‘workers’
[10:25:19.858]   - Field: ‘packages’
[10:25:19.859]   - Field: ‘gc’
[10:25:19.859]   - Field: ‘conditions’
[10:25:19.859]   - Field: ‘persistent’
[10:25:19.859]   - Field: ‘expr’
[10:25:19.859]   - Field: ‘uuid’
[10:25:19.859]   - Field: ‘seed’
[10:25:19.859]   - Field: ‘version’
[10:25:19.859]   - Field: ‘result’
[10:25:19.859]   - Field: ‘asynchronous’
[10:25:19.859]   - Field: ‘calls’
[10:25:19.859]   - Field: ‘globals’
[10:25:19.860]   - Field: ‘stdout’
[10:25:19.860]   - Field: ‘earlySignal’
[10:25:19.860]   - Field: ‘lazy’
[10:25:19.860]   - Field: ‘state’
[10:25:19.860] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:19.860] - Launch lazy future ...
[10:25:19.860] Packages needed by the future expression (n = 1): ‘future’
[10:25:19.860] Packages needed by future strategies (n = 0): <none>
[10:25:19.861] {
[10:25:19.861]     {
[10:25:19.861]         {
[10:25:19.861]             ...future.startTime <- base::Sys.time()
[10:25:19.861]             {
[10:25:19.861]                 {
[10:25:19.861]                   {
[10:25:19.861]                     {
[10:25:19.861]                       {
[10:25:19.861]                         base::local({
[10:25:19.861]                           has_future <- base::requireNamespace("future", 
[10:25:19.861]                             quietly = TRUE)
[10:25:19.861]                           if (has_future) {
[10:25:19.861]                             ns <- base::getNamespace("future")
[10:25:19.861]                             version <- ns[[".package"]][["version"]]
[10:25:19.861]                             if (is.null(version)) 
[10:25:19.861]                               version <- utils::packageVersion("future")
[10:25:19.861]                           }
[10:25:19.861]                           else {
[10:25:19.861]                             version <- NULL
[10:25:19.861]                           }
[10:25:19.861]                           if (!has_future || version < "1.8.0") {
[10:25:19.861]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:19.861]                               "", base::R.version$version.string), 
[10:25:19.861]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:19.861]                                 base::R.version$platform, 8 * 
[10:25:19.861]                                   base::.Machine$sizeof.pointer), 
[10:25:19.861]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:19.861]                                 "release", "version")], collapse = " "), 
[10:25:19.861]                               hostname = base::Sys.info()[["nodename"]])
[10:25:19.861]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:19.861]                               info)
[10:25:19.861]                             info <- base::paste(info, collapse = "; ")
[10:25:19.861]                             if (!has_future) {
[10:25:19.861]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:19.861]                                 info)
[10:25:19.861]                             }
[10:25:19.861]                             else {
[10:25:19.861]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:19.861]                                 info, version)
[10:25:19.861]                             }
[10:25:19.861]                             base::stop(msg)
[10:25:19.861]                           }
[10:25:19.861]                         })
[10:25:19.861]                       }
[10:25:19.861]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:19.861]                       base::options(mc.cores = 1L)
[10:25:19.861]                     }
[10:25:19.861]                     base::local({
[10:25:19.861]                       for (pkg in "future") {
[10:25:19.861]                         base::loadNamespace(pkg)
[10:25:19.861]                         base::library(pkg, character.only = TRUE)
[10:25:19.861]                       }
[10:25:19.861]                     })
[10:25:19.861]                   }
[10:25:19.861]                   options(future.plan = NULL)
[10:25:19.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:19.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:19.861]                 }
[10:25:19.861]                 ...future.workdir <- getwd()
[10:25:19.861]             }
[10:25:19.861]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:19.861]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:19.861]         }
[10:25:19.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:19.861]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:19.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:19.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:19.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:19.861]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:19.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:19.861]             base::names(...future.oldOptions))
[10:25:19.861]     }
[10:25:19.861]     if (FALSE) {
[10:25:19.861]     }
[10:25:19.861]     else {
[10:25:19.861]         if (TRUE) {
[10:25:19.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:19.861]                 open = "w")
[10:25:19.861]         }
[10:25:19.861]         else {
[10:25:19.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:19.861]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:19.861]         }
[10:25:19.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:19.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:19.861]             base::sink(type = "output", split = FALSE)
[10:25:19.861]             base::close(...future.stdout)
[10:25:19.861]         }, add = TRUE)
[10:25:19.861]     }
[10:25:19.861]     ...future.frame <- base::sys.nframe()
[10:25:19.861]     ...future.conditions <- base::list()
[10:25:19.861]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:19.861]     if (FALSE) {
[10:25:19.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:19.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:19.861]     }
[10:25:19.861]     ...future.result <- base::tryCatch({
[10:25:19.861]         base::withCallingHandlers({
[10:25:19.861]             ...future.value <- base::withVisible(base::local({
[10:25:19.861]                 ...future.makeSendCondition <- base::local({
[10:25:19.861]                   sendCondition <- NULL
[10:25:19.861]                   function(frame = 1L) {
[10:25:19.861]                     if (is.function(sendCondition)) 
[10:25:19.861]                       return(sendCondition)
[10:25:19.861]                     ns <- getNamespace("parallel")
[10:25:19.861]                     if (exists("sendData", mode = "function", 
[10:25:19.861]                       envir = ns)) {
[10:25:19.861]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:19.861]                         envir = ns)
[10:25:19.861]                       envir <- sys.frame(frame)
[10:25:19.861]                       master <- NULL
[10:25:19.861]                       while (!identical(envir, .GlobalEnv) && 
[10:25:19.861]                         !identical(envir, emptyenv())) {
[10:25:19.861]                         if (exists("master", mode = "list", envir = envir, 
[10:25:19.861]                           inherits = FALSE)) {
[10:25:19.861]                           master <- get("master", mode = "list", 
[10:25:19.861]                             envir = envir, inherits = FALSE)
[10:25:19.861]                           if (inherits(master, c("SOCKnode", 
[10:25:19.861]                             "SOCK0node"))) {
[10:25:19.861]                             sendCondition <<- function(cond) {
[10:25:19.861]                               data <- list(type = "VALUE", value = cond, 
[10:25:19.861]                                 success = TRUE)
[10:25:19.861]                               parallel_sendData(master, data)
[10:25:19.861]                             }
[10:25:19.861]                             return(sendCondition)
[10:25:19.861]                           }
[10:25:19.861]                         }
[10:25:19.861]                         frame <- frame + 1L
[10:25:19.861]                         envir <- sys.frame(frame)
[10:25:19.861]                       }
[10:25:19.861]                     }
[10:25:19.861]                     sendCondition <<- function(cond) NULL
[10:25:19.861]                   }
[10:25:19.861]                 })
[10:25:19.861]                 withCallingHandlers({
[10:25:19.861]                   {
[10:25:19.861]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:25:19.861]                       ii, n), appendLF = FALSE)
[10:25:19.861]                     fit <- mandelbrot(C)
[10:25:19.861]                     delay(fit)
[10:25:19.861]                     message(" done")
[10:25:19.861]                     fit
[10:25:19.861]                   }
[10:25:19.861]                 }, immediateCondition = function(cond) {
[10:25:19.861]                   sendCondition <- ...future.makeSendCondition()
[10:25:19.861]                   sendCondition(cond)
[10:25:19.861]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.861]                   {
[10:25:19.861]                     inherits <- base::inherits
[10:25:19.861]                     invokeRestart <- base::invokeRestart
[10:25:19.861]                     is.null <- base::is.null
[10:25:19.861]                     muffled <- FALSE
[10:25:19.861]                     if (inherits(cond, "message")) {
[10:25:19.861]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:19.861]                       if (muffled) 
[10:25:19.861]                         invokeRestart("muffleMessage")
[10:25:19.861]                     }
[10:25:19.861]                     else if (inherits(cond, "warning")) {
[10:25:19.861]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:19.861]                       if (muffled) 
[10:25:19.861]                         invokeRestart("muffleWarning")
[10:25:19.861]                     }
[10:25:19.861]                     else if (inherits(cond, "condition")) {
[10:25:19.861]                       if (!is.null(pattern)) {
[10:25:19.861]                         computeRestarts <- base::computeRestarts
[10:25:19.861]                         grepl <- base::grepl
[10:25:19.861]                         restarts <- computeRestarts(cond)
[10:25:19.861]                         for (restart in restarts) {
[10:25:19.861]                           name <- restart$name
[10:25:19.861]                           if (is.null(name)) 
[10:25:19.861]                             next
[10:25:19.861]                           if (!grepl(pattern, name)) 
[10:25:19.861]                             next
[10:25:19.861]                           invokeRestart(restart)
[10:25:19.861]                           muffled <- TRUE
[10:25:19.861]                           break
[10:25:19.861]                         }
[10:25:19.861]                       }
[10:25:19.861]                     }
[10:25:19.861]                     invisible(muffled)
[10:25:19.861]                   }
[10:25:19.861]                   muffleCondition(cond)
[10:25:19.861]                 })
[10:25:19.861]             }))
[10:25:19.861]             future::FutureResult(value = ...future.value$value, 
[10:25:19.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:19.861]                   ...future.rng), globalenv = if (FALSE) 
[10:25:19.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:19.861]                     ...future.globalenv.names))
[10:25:19.861]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:19.861]         }, condition = base::local({
[10:25:19.861]             c <- base::c
[10:25:19.861]             inherits <- base::inherits
[10:25:19.861]             invokeRestart <- base::invokeRestart
[10:25:19.861]             length <- base::length
[10:25:19.861]             list <- base::list
[10:25:19.861]             seq.int <- base::seq.int
[10:25:19.861]             signalCondition <- base::signalCondition
[10:25:19.861]             sys.calls <- base::sys.calls
[10:25:19.861]             `[[` <- base::`[[`
[10:25:19.861]             `+` <- base::`+`
[10:25:19.861]             `<<-` <- base::`<<-`
[10:25:19.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:19.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:19.861]                   3L)]
[10:25:19.861]             }
[10:25:19.861]             function(cond) {
[10:25:19.861]                 is_error <- inherits(cond, "error")
[10:25:19.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:19.861]                   NULL)
[10:25:19.861]                 if (is_error) {
[10:25:19.861]                   sessionInformation <- function() {
[10:25:19.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:19.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:19.861]                       search = base::search(), system = base::Sys.info())
[10:25:19.861]                   }
[10:25:19.861]                   ...future.conditions[[length(...future.conditions) + 
[10:25:19.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:19.861]                     cond$call), session = sessionInformation(), 
[10:25:19.861]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:19.861]                   signalCondition(cond)
[10:25:19.861]                 }
[10:25:19.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:19.861]                 "immediateCondition"))) {
[10:25:19.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:19.861]                   ...future.conditions[[length(...future.conditions) + 
[10:25:19.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:19.861]                   if (TRUE && !signal) {
[10:25:19.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.861]                     {
[10:25:19.861]                       inherits <- base::inherits
[10:25:19.861]                       invokeRestart <- base::invokeRestart
[10:25:19.861]                       is.null <- base::is.null
[10:25:19.861]                       muffled <- FALSE
[10:25:19.861]                       if (inherits(cond, "message")) {
[10:25:19.861]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:19.861]                         if (muffled) 
[10:25:19.861]                           invokeRestart("muffleMessage")
[10:25:19.861]                       }
[10:25:19.861]                       else if (inherits(cond, "warning")) {
[10:25:19.861]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:19.861]                         if (muffled) 
[10:25:19.861]                           invokeRestart("muffleWarning")
[10:25:19.861]                       }
[10:25:19.861]                       else if (inherits(cond, "condition")) {
[10:25:19.861]                         if (!is.null(pattern)) {
[10:25:19.861]                           computeRestarts <- base::computeRestarts
[10:25:19.861]                           grepl <- base::grepl
[10:25:19.861]                           restarts <- computeRestarts(cond)
[10:25:19.861]                           for (restart in restarts) {
[10:25:19.861]                             name <- restart$name
[10:25:19.861]                             if (is.null(name)) 
[10:25:19.861]                               next
[10:25:19.861]                             if (!grepl(pattern, name)) 
[10:25:19.861]                               next
[10:25:19.861]                             invokeRestart(restart)
[10:25:19.861]                             muffled <- TRUE
[10:25:19.861]                             break
[10:25:19.861]                           }
[10:25:19.861]                         }
[10:25:19.861]                       }
[10:25:19.861]                       invisible(muffled)
[10:25:19.861]                     }
[10:25:19.861]                     muffleCondition(cond, pattern = "^muffle")
[10:25:19.861]                   }
[10:25:19.861]                 }
[10:25:19.861]                 else {
[10:25:19.861]                   if (TRUE) {
[10:25:19.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:19.861]                     {
[10:25:19.861]                       inherits <- base::inherits
[10:25:19.861]                       invokeRestart <- base::invokeRestart
[10:25:19.861]                       is.null <- base::is.null
[10:25:19.861]                       muffled <- FALSE
[10:25:19.861]                       if (inherits(cond, "message")) {
[10:25:19.861]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:19.861]                         if (muffled) 
[10:25:19.861]                           invokeRestart("muffleMessage")
[10:25:19.861]                       }
[10:25:19.861]                       else if (inherits(cond, "warning")) {
[10:25:19.861]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:19.861]                         if (muffled) 
[10:25:19.861]                           invokeRestart("muffleWarning")
[10:25:19.861]                       }
[10:25:19.861]                       else if (inherits(cond, "condition")) {
[10:25:19.861]                         if (!is.null(pattern)) {
[10:25:19.861]                           computeRestarts <- base::computeRestarts
[10:25:19.861]                           grepl <- base::grepl
[10:25:19.861]                           restarts <- computeRestarts(cond)
[10:25:19.861]                           for (restart in restarts) {
[10:25:19.861]                             name <- restart$name
[10:25:19.861]                             if (is.null(name)) 
[10:25:19.861]                               next
[10:25:19.861]                             if (!grepl(pattern, name)) 
[10:25:19.861]                               next
[10:25:19.861]                             invokeRestart(restart)
[10:25:19.861]                             muffled <- TRUE
[10:25:19.861]                             break
[10:25:19.861]                           }
[10:25:19.861]                         }
[10:25:19.861]                       }
[10:25:19.861]                       invisible(muffled)
[10:25:19.861]                     }
[10:25:19.861]                     muffleCondition(cond, pattern = "^muffle")
[10:25:19.861]                   }
[10:25:19.861]                 }
[10:25:19.861]             }
[10:25:19.861]         }))
[10:25:19.861]     }, error = function(ex) {
[10:25:19.861]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:19.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:19.861]                 ...future.rng), started = ...future.startTime, 
[10:25:19.861]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:19.861]             version = "1.8"), class = "FutureResult")
[10:25:19.861]     }, finally = {
[10:25:19.861]         if (!identical(...future.workdir, getwd())) 
[10:25:19.861]             setwd(...future.workdir)
[10:25:19.861]         {
[10:25:19.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:19.861]                 ...future.oldOptions$nwarnings <- NULL
[10:25:19.861]             }
[10:25:19.861]             base::options(...future.oldOptions)
[10:25:19.861]             if (.Platform$OS.type == "windows") {
[10:25:19.861]                 old_names <- names(...future.oldEnvVars)
[10:25:19.861]                 envs <- base::Sys.getenv()
[10:25:19.861]                 names <- names(envs)
[10:25:19.861]                 common <- intersect(names, old_names)
[10:25:19.861]                 added <- setdiff(names, old_names)
[10:25:19.861]                 removed <- setdiff(old_names, names)
[10:25:19.861]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:19.861]                   envs[common]]
[10:25:19.861]                 NAMES <- toupper(changed)
[10:25:19.861]                 args <- list()
[10:25:19.861]                 for (kk in seq_along(NAMES)) {
[10:25:19.861]                   name <- changed[[kk]]
[10:25:19.861]                   NAME <- NAMES[[kk]]
[10:25:19.861]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.861]                     next
[10:25:19.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:19.861]                 }
[10:25:19.861]                 NAMES <- toupper(added)
[10:25:19.861]                 for (kk in seq_along(NAMES)) {
[10:25:19.861]                   name <- added[[kk]]
[10:25:19.861]                   NAME <- NAMES[[kk]]
[10:25:19.861]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.861]                     next
[10:25:19.861]                   args[[name]] <- ""
[10:25:19.861]                 }
[10:25:19.861]                 NAMES <- toupper(removed)
[10:25:19.861]                 for (kk in seq_along(NAMES)) {
[10:25:19.861]                   name <- removed[[kk]]
[10:25:19.861]                   NAME <- NAMES[[kk]]
[10:25:19.861]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:19.861]                     next
[10:25:19.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:19.861]                 }
[10:25:19.861]                 if (length(args) > 0) 
[10:25:19.861]                   base::do.call(base::Sys.setenv, args = args)
[10:25:19.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:19.861]             }
[10:25:19.861]             else {
[10:25:19.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:19.861]             }
[10:25:19.861]             {
[10:25:19.861]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:19.861]                   0L) {
[10:25:19.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:19.861]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:19.861]                   base::options(opts)
[10:25:19.861]                 }
[10:25:19.861]                 {
[10:25:19.861]                   {
[10:25:19.861]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:19.861]                     NULL
[10:25:19.861]                   }
[10:25:19.861]                   options(future.plan = NULL)
[10:25:19.861]                   if (is.na(NA_character_)) 
[10:25:19.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:19.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:19.861]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:19.861]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:19.861]                     envir = parent.frame()) 
[10:25:19.861]                   {
[10:25:19.861]                     if (is.function(workers)) 
[10:25:19.861]                       workers <- workers()
[10:25:19.861]                     workers <- structure(as.integer(workers), 
[10:25:19.861]                       class = class(workers))
[10:25:19.861]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:19.861]                       workers >= 1)
[10:25:19.861]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:19.861]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:19.861]                     }
[10:25:19.861]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:19.861]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:19.861]                       envir = envir)
[10:25:19.861]                     if (!future$lazy) 
[10:25:19.861]                       future <- run(future)
[10:25:19.861]                     invisible(future)
[10:25:19.861]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:19.861]                 }
[10:25:19.861]             }
[10:25:19.861]         }
[10:25:19.861]     })
[10:25:19.861]     if (TRUE) {
[10:25:19.861]         base::sink(type = "output", split = FALSE)
[10:25:19.861]         if (TRUE) {
[10:25:19.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:19.861]         }
[10:25:19.861]         else {
[10:25:19.861]             ...future.result["stdout"] <- base::list(NULL)
[10:25:19.861]         }
[10:25:19.861]         base::close(...future.stdout)
[10:25:19.861]         ...future.stdout <- NULL
[10:25:19.861]     }
[10:25:19.861]     ...future.result$conditions <- ...future.conditions
[10:25:19.861]     ...future.result$finished <- base::Sys.time()
[10:25:19.861]     ...future.result
[10:25:19.861] }
[10:25:19.863] Poll #1 (0): usedNodes() = 2, workers = 2
[10:25:19.874] receiveMessageFromWorker() for ClusterFuture ...
[10:25:19.874] - Validating connection of MultisessionFuture
[10:25:19.875] - received message: FutureResult
[10:25:19.875] - Received FutureResult
[10:25:19.875] - Erased future from FutureRegistry
[10:25:19.875] result() for ClusterFuture ...
[10:25:19.875] - result already collected: FutureResult
[10:25:19.875] result() for ClusterFuture ... done
[10:25:19.875] signalConditions() ...
[10:25:19.875]  - include = ‘immediateCondition’
[10:25:19.875]  - exclude = 
[10:25:19.876]  - resignal = FALSE
[10:25:19.876]  - Number of conditions: 2
[10:25:19.876] signalConditions() ... done
[10:25:19.876] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:19.876] result() for ClusterFuture ...
[10:25:19.876] - result already collected: FutureResult
[10:25:19.876] result() for ClusterFuture ... done
[10:25:19.876] result() for ClusterFuture ...
[10:25:19.876] - result already collected: FutureResult
[10:25:19.876] result() for ClusterFuture ... done
[10:25:19.877] signalConditions() ...
[10:25:19.877]  - include = ‘immediateCondition’
[10:25:19.877]  - exclude = 
[10:25:19.877]  - resignal = FALSE
[10:25:19.877]  - Number of conditions: 2
[10:25:19.877] signalConditions() ... done
[10:25:19.878] Exporting 4 global objects (14.24 KiB) to cluster node #2 ...
[10:25:19.878] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:25:19.878] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:25:19.878] Exporting ‘n’ (56 bytes) to cluster node #2 ...
[10:25:19.879] Exporting ‘n’ (56 bytes) to cluster node #2 ... DONE
[10:25:19.879] Exporting ‘C’ (10.72 KiB) to cluster node #2 ...
[10:25:19.922] Exporting ‘C’ (10.72 KiB) to cluster node #2 ... DONE
[10:25:19.922] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ...
[10:25:19.966] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ... DONE
[10:25:19.966] Exporting 4 global objects (14.24 KiB) to cluster node #2 ... DONE
[10:25:19.967] MultisessionFuture started
[10:25:19.967] - Launch lazy future ... done
[10:25:19.967] run() for ‘MultisessionFuture’ ... done
[10:25:19.967] - run() ... done
[10:25:19.967] - resolved() ...
[10:25:19.978] - resolved: FALSE
[10:25:19.978] - resolved() ... done
[10:25:19.978] resolved() for ‘MultisessionFuture’ ... done
Plotting tile #1 of 4 ...
[10:25:19.979] result() for ClusterFuture ...
[10:25:19.979] - result already collected: FutureResult
[10:25:19.979] result() for ClusterFuture ... done
[10:25:19.979] result() for ClusterFuture ...
[10:25:19.979] - result already collected: FutureResult
[10:25:19.979] result() for ClusterFuture ... done
[10:25:19.979] signalConditions() ...
[10:25:19.979]  - include = ‘immediateCondition’
[10:25:19.979]  - exclude = 
[10:25:19.980]  - resignal = FALSE
[10:25:19.980]  - Number of conditions: 2
[10:25:19.980] signalConditions() ... done
[10:25:19.980] Future state: ‘finished’
[10:25:19.980] result() for ClusterFuture ...
[10:25:19.980] - result already collected: FutureResult
[10:25:19.980] result() for ClusterFuture ... done
[10:25:19.980] signalConditions() ...
[10:25:19.980]  - include = ‘condition’
[10:25:19.980]  - exclude = ‘immediateCondition’
[10:25:19.980]  - resignal = TRUE
[10:25:19.983]  - Number of conditions: 2
[10:25:19.983]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[10:25:19.983]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:25:19.983] signalConditions() ... done
Plotting tile #2 of 4 ...
[10:25:19.984] result() for ClusterFuture ...
[10:25:19.984] - result already collected: FutureResult
[10:25:19.984] result() for ClusterFuture ... done
[10:25:19.984] result() for ClusterFuture ...
[10:25:19.984] - result already collected: FutureResult
[10:25:19.984] result() for ClusterFuture ... done
[10:25:19.984] signalConditions() ...
[10:25:19.984]  - include = ‘immediateCondition’
[10:25:19.984]  - exclude = 
[10:25:19.984]  - resignal = FALSE
[10:25:19.985]  - Number of conditions: 2
[10:25:19.985] signalConditions() ... done
[10:25:19.985] Future state: ‘finished’
[10:25:19.985] result() for ClusterFuture ...
[10:25:19.985] - result already collected: FutureResult
[10:25:19.985] result() for ClusterFuture ... done
[10:25:19.985] signalConditions() ...
[10:25:19.985]  - include = ‘condition’
[10:25:19.985]  - exclude = ‘immediateCondition’
[10:25:19.985]  - resignal = TRUE
[10:25:19.985]  - Number of conditions: 2
[10:25:19.986]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[10:25:19.986]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:25:19.986] signalConditions() ... done
[10:25:19.987] receiveMessageFromWorker() for ClusterFuture ...
[10:25:19.987] - Validating connection of MultisessionFuture
[10:25:19.987] - received message: FutureResult
[10:25:19.987] - Received FutureResult
[10:25:19.987] - Erased future from FutureRegistry
[10:25:19.987] result() for ClusterFuture ...
[10:25:19.988] - result already collected: FutureResult
[10:25:19.988] result() for ClusterFuture ... done
[10:25:19.988] signalConditions() ...
[10:25:19.988]  - include = ‘immediateCondition’
[10:25:19.988]  - exclude = 
[10:25:19.988]  - resignal = FALSE
[10:25:19.988]  - Number of conditions: 2
[10:25:19.988] signalConditions() ... done
[10:25:19.988] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #3 of 4 ...
[10:25:19.988] result() for ClusterFuture ...
[10:25:19.988] - result already collected: FutureResult
[10:25:19.989] result() for ClusterFuture ... done
[10:25:19.989] result() for ClusterFuture ...
[10:25:19.989] - result already collected: FutureResult
[10:25:19.989] result() for ClusterFuture ... done
[10:25:19.989] signalConditions() ...
[10:25:19.989]  - include = ‘immediateCondition’
[10:25:19.989]  - exclude = 
[10:25:19.989]  - resignal = FALSE
[10:25:19.989]  - Number of conditions: 2
[10:25:19.989] signalConditions() ... done
[10:25:19.989] Future state: ‘finished’
[10:25:19.990] result() for ClusterFuture ...
[10:25:19.990] - result already collected: FutureResult
[10:25:19.990] result() for ClusterFuture ... done
[10:25:19.990] signalConditions() ...
[10:25:19.990]  - include = ‘condition’
[10:25:19.990]  - exclude = ‘immediateCondition’
[10:25:19.990]  - resignal = TRUE
[10:25:19.990]  - Number of conditions: 2
[10:25:19.990]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[10:25:19.990]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:25:19.990] signalConditions() ... done
[10:25:20.031] receiveMessageFromWorker() for ClusterFuture ...
[10:25:20.032] - Validating connection of MultisessionFuture
[10:25:20.032] - received message: FutureResult
[10:25:20.032] - Received FutureResult
[10:25:20.032] - Erased future from FutureRegistry
[10:25:20.032] result() for ClusterFuture ...
[10:25:20.032] - result already collected: FutureResult
[10:25:20.033] result() for ClusterFuture ... done
[10:25:20.033] signalConditions() ...
[10:25:20.033]  - include = ‘immediateCondition’
[10:25:20.033]  - exclude = 
[10:25:20.033]  - resignal = FALSE
[10:25:20.033]  - Number of conditions: 2
[10:25:20.033] signalConditions() ... done
[10:25:20.033] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #4 of 4 ...
[10:25:20.033] result() for ClusterFuture ...
[10:25:20.033] - result already collected: FutureResult
[10:25:20.034] result() for ClusterFuture ... done
[10:25:20.034] result() for ClusterFuture ...
[10:25:20.034] - result already collected: FutureResult
[10:25:20.034] result() for ClusterFuture ... done
[10:25:20.034] signalConditions() ...
[10:25:20.034]  - include = ‘immediateCondition’
[10:25:20.034]  - exclude = 
[10:25:20.034]  - resignal = FALSE
[10:25:20.034]  - Number of conditions: 2
[10:25:20.034] signalConditions() ... done
[10:25:20.034] Future state: ‘finished’
[10:25:20.035] result() for ClusterFuture ...
[10:25:20.035] - result already collected: FutureResult
[10:25:20.035] result() for ClusterFuture ... done
[10:25:20.035] signalConditions() ...
[10:25:20.035]  - include = ‘condition’
[10:25:20.035]  - exclude = ‘immediateCondition’
[10:25:20.035]  - resignal = TRUE
[10:25:20.035]  - Number of conditions: 2
[10:25:20.035]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[10:25:20.035]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:25:20.035] signalConditions() ... done

> close.screen()
 [1]  1  2  3  4  5  6  7  8  9 10 11 12

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multisession') ... DONE
Testing with 2 cores ... DONE
> message("*** Mandelbrot demo of the 'future' package ... DONE")
*** Mandelbrot demo of the 'future' package ... DONE
> 
> message("*** Demos ... DONE")
*** Demos ... DONE
> 
> source("incl/end.R")
[10:25:20.037] plan(): Setting new future strategy stack:
[10:25:20.037] List of future strategies:
[10:25:20.037] 1. sequential:
[10:25:20.037]    - args: function (..., envir = parent.frame())
[10:25:20.037]    - tweaked: FALSE
[10:25:20.037]    - call: future::plan("sequential")
[10:25:20.038] plan(): nbrOfWorkers() = 1
> 
