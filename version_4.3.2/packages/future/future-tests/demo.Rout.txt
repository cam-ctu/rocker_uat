
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:04:10.638] plan(): Setting new future strategy stack:
[16:04:10.639] List of future strategies:
[16:04:10.639] 1. sequential:
[16:04:10.639]    - args: function (..., envir = parent.frame())
[16:04:10.639]    - tweaked: FALSE
[16:04:10.639]    - call: future::plan("sequential")
[16:04:10.652] plan(): nbrOfWorkers() = 1
> 
> message("*** Demos ...")
*** Demos ...
> 
> message("*** Fibonacci demo of the 'future' package ...")
*** Fibonacci demo of the 'future' package ...
> demo("fibonacci", package = "future", ask = FALSE)


	demo(fibonacci)
	---- ~~~~~~~~~

> library("future")

> library("listenv")

> ## IMPORTANT:
> ## 1. The below usage of lazy futures will only work when they are
> ##    all evaluated in the same process.
> ## 2. We disable the capturing of standard output (stdout=NA) to avoid
> ##    'sink stack is full' errors
> ## 3. We disable the capturing of most conditions (condition="error") to
> ##    avoid stacking up too many conditions
> oplan <- plan(sequential)
[16:04:10.668] plan(): Setting new future strategy stack:
[16:04:10.668] List of future strategies:
[16:04:10.668] 1. sequential:
[16:04:10.668]    - args: function (..., envir = parent.frame())
[16:04:10.668]    - tweaked: FALSE
[16:04:10.668]    - call: plan(sequential)
[16:04:10.680] plan(): nbrOfWorkers() = 1

> ## Defines the first 100 Fibonacci numbers
> ## (0, 1, 1, 2, 3, 5, 8, ...)
> ## but calculate only the ones need when
> ## a number is actually requested.
> 
> x <- listenv()

> x[[1]] <- 0

> x[[2]] <- 1

> for (i in 3:100) {
+   x[[i]] %<-% { x[[i - 2]] + x[[i - 1]] } %lazy% TRUE %stdout% NA %conditions% "error"
+ }
[16:04:10.686] getGlobalsAndPackages() ...
[16:04:10.687] Searching for globals...
[16:04:10.695] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.695] Searching for globals ... DONE
[16:04:10.696] Resolving globals: FALSE
[16:04:10.697] The total size of the 2 globals is 224 bytes (224 bytes)
[16:04:10.697] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 224 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (168 bytes of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.697] - globals: [2] ‘x’, ‘i’
[16:04:10.697] 
[16:04:10.698] getGlobalsAndPackages() ... DONE
[16:04:10.698] getGlobalsAndPackages() ...
[16:04:10.698] Searching for globals...
[16:04:10.700] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.700] Searching for globals ... DONE
[16:04:10.700] Resolving globals: FALSE
[16:04:10.701] The total size of the 2 globals is 8.41 KiB (8608 bytes)
[16:04:10.701] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 8.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (8.35 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.701] - globals: [2] ‘x’, ‘i’
[16:04:10.701] 
[16:04:10.701] getGlobalsAndPackages() ... DONE
[16:04:10.702] getGlobalsAndPackages() ...
[16:04:10.702] Searching for globals...
[16:04:10.703] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.704] Searching for globals ... DONE
[16:04:10.704] Resolving globals: FALSE
[16:04:10.705] The total size of the 2 globals is 16.76 KiB (17160 bytes)
[16:04:10.705] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 16.76 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (16.70 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.705] - globals: [2] ‘x’, ‘i’
[16:04:10.705] 
[16:04:10.705] getGlobalsAndPackages() ... DONE
[16:04:10.706] getGlobalsAndPackages() ...
[16:04:10.706] Searching for globals...
[16:04:10.707] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.707] Searching for globals ... DONE
[16:04:10.708] Resolving globals: FALSE
[16:04:10.709] The total size of the 2 globals is 25.11 KiB (25712 bytes)
[16:04:10.709] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 25.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (25.05 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.709] - globals: [2] ‘x’, ‘i’
[16:04:10.709] 
[16:04:10.709] getGlobalsAndPackages() ... DONE
[16:04:10.710] getGlobalsAndPackages() ...
[16:04:10.710] Searching for globals...
[16:04:10.711] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.712] Searching for globals ... DONE
[16:04:10.712] Resolving globals: FALSE
[16:04:10.713] The total size of the 2 globals is 33.46 KiB (34264 bytes)
[16:04:10.713] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 33.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (33.41 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.714] - globals: [2] ‘x’, ‘i’
[16:04:10.714] 
[16:04:10.714] getGlobalsAndPackages() ... DONE
[16:04:10.714] getGlobalsAndPackages() ...
[16:04:10.714] Searching for globals...
[16:04:10.716] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.716] Searching for globals ... DONE
[16:04:10.716] Resolving globals: FALSE
[16:04:10.718] The total size of the 2 globals is 41.81 KiB (42816 bytes)
[16:04:10.719] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 41.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (41.76 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.719] - globals: [2] ‘x’, ‘i’
[16:04:10.719] 
[16:04:10.719] getGlobalsAndPackages() ... DONE
[16:04:10.720] getGlobalsAndPackages() ...
[16:04:10.720] Searching for globals...
[16:04:10.721] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.721] Searching for globals ... DONE
[16:04:10.721] Resolving globals: FALSE
[16:04:10.723] The total size of the 2 globals is 50.16 KiB (51368 bytes)
[16:04:10.724] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 50.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (50.11 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.724] - globals: [2] ‘x’, ‘i’
[16:04:10.724] 
[16:04:10.724] getGlobalsAndPackages() ... DONE
[16:04:10.724] getGlobalsAndPackages() ...
[16:04:10.724] Searching for globals...
[16:04:10.726] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.726] Searching for globals ... DONE
[16:04:10.726] Resolving globals: FALSE
[16:04:10.728] The total size of the 2 globals is 58.52 KiB (59920 bytes)
[16:04:10.728] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 58.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (58.46 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.729] - globals: [2] ‘x’, ‘i’
[16:04:10.729] 
[16:04:10.729] getGlobalsAndPackages() ... DONE
[16:04:10.729] getGlobalsAndPackages() ...
[16:04:10.729] Searching for globals...
[16:04:10.731] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.731] Searching for globals ... DONE
[16:04:10.731] Resolving globals: FALSE
[16:04:10.733] The total size of the 2 globals is 66.87 KiB (68472 bytes)
[16:04:10.734] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 66.87 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (66.81 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.734] - globals: [2] ‘x’, ‘i’
[16:04:10.734] 
[16:04:10.734] getGlobalsAndPackages() ... DONE
[16:04:10.734] getGlobalsAndPackages() ...
[16:04:10.735] Searching for globals...
[16:04:10.736] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.736] Searching for globals ... DONE
[16:04:10.736] Resolving globals: FALSE
[16:04:10.739] The total size of the 2 globals is 75.22 KiB (77024 bytes)
[16:04:10.740] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 75.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (75.16 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.740] - globals: [2] ‘x’, ‘i’
[16:04:10.740] 
[16:04:10.740] getGlobalsAndPackages() ... DONE
[16:04:10.741] getGlobalsAndPackages() ...
[16:04:10.741] Searching for globals...
[16:04:10.742] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.742] Searching for globals ... DONE
[16:04:10.742] Resolving globals: FALSE
[16:04:10.745] The total size of the 2 globals is 83.57 KiB (85576 bytes)
[16:04:10.745] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 83.57 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (83.52 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.746] - globals: [2] ‘x’, ‘i’
[16:04:10.746] 
[16:04:10.746] getGlobalsAndPackages() ... DONE
[16:04:10.746] getGlobalsAndPackages() ...
[16:04:10.746] Searching for globals...
[16:04:10.748] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.748] Searching for globals ... DONE
[16:04:10.748] Resolving globals: FALSE
[16:04:10.751] The total size of the 2 globals is 91.92 KiB (94128 bytes)
[16:04:10.751] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 91.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (91.87 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.751] - globals: [2] ‘x’, ‘i’
[16:04:10.751] 
[16:04:10.752] getGlobalsAndPackages() ... DONE
[16:04:10.752] getGlobalsAndPackages() ...
[16:04:10.752] Searching for globals...
[16:04:10.753] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.754] Searching for globals ... DONE
[16:04:10.754] Resolving globals: FALSE
[16:04:10.758] The total size of the 2 globals is 100.27 KiB (102680 bytes)
[16:04:10.758] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 100.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (100.22 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.758] - globals: [2] ‘x’, ‘i’
[16:04:10.758] 
[16:04:10.758] getGlobalsAndPackages() ... DONE
[16:04:10.759] getGlobalsAndPackages() ...
[16:04:10.759] Searching for globals...
[16:04:10.760] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.760] Searching for globals ... DONE
[16:04:10.761] Resolving globals: FALSE
[16:04:10.764] The total size of the 2 globals is 108.62 KiB (111232 bytes)
[16:04:10.764] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 108.62 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (108.57 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.765] - globals: [2] ‘x’, ‘i’
[16:04:10.765] 
[16:04:10.765] getGlobalsAndPackages() ... DONE
[16:04:10.765] getGlobalsAndPackages() ...
[16:04:10.765] Searching for globals...
[16:04:10.767] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.767] Searching for globals ... DONE
[16:04:10.767] Resolving globals: FALSE
[16:04:10.771] The total size of the 2 globals is 116.98 KiB (119784 bytes)
[16:04:10.771] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 116.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (116.92 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.771] - globals: [2] ‘x’, ‘i’
[16:04:10.771] 
[16:04:10.771] getGlobalsAndPackages() ... DONE
[16:04:10.772] getGlobalsAndPackages() ...
[16:04:10.772] Searching for globals...
[16:04:10.773] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.773] Searching for globals ... DONE
[16:04:10.773] Resolving globals: FALSE
[16:04:10.778] The total size of the 2 globals is 125.33 KiB (128336 bytes)
[16:04:10.778] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 125.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (125.27 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.779] - globals: [2] ‘x’, ‘i’
[16:04:10.779] 
[16:04:10.779] getGlobalsAndPackages() ... DONE
[16:04:10.779] getGlobalsAndPackages() ...
[16:04:10.779] Searching for globals...
[16:04:10.781] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.781] Searching for globals ... DONE
[16:04:10.781] Resolving globals: FALSE
[16:04:10.785] The total size of the 2 globals is 133.68 KiB (136888 bytes)
[16:04:10.786] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 133.68 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133.62 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.786] - globals: [2] ‘x’, ‘i’
[16:04:10.786] 
[16:04:10.786] getGlobalsAndPackages() ... DONE
[16:04:10.786] getGlobalsAndPackages() ...
[16:04:10.787] Searching for globals...
[16:04:10.788] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.788] Searching for globals ... DONE
[16:04:10.788] Resolving globals: FALSE
[16:04:10.793] The total size of the 2 globals is 142.03 KiB (145440 bytes)
[16:04:10.794] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 142.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (141.98 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.794] - globals: [2] ‘x’, ‘i’
[16:04:10.794] 
[16:04:10.794] getGlobalsAndPackages() ... DONE
[16:04:10.794] getGlobalsAndPackages() ...
[16:04:10.795] Searching for globals...
[16:04:10.796] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.796] Searching for globals ... DONE
[16:04:10.796] Resolving globals: FALSE
[16:04:10.801] The total size of the 2 globals is 150.38 KiB (153992 bytes)
[16:04:10.801] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 150.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (150.33 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.801] - globals: [2] ‘x’, ‘i’
[16:04:10.801] 
[16:04:10.802] getGlobalsAndPackages() ... DONE
[16:04:10.802] getGlobalsAndPackages() ...
[16:04:10.802] Searching for globals...
[16:04:10.803] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.804] Searching for globals ... DONE
[16:04:10.804] Resolving globals: FALSE
[16:04:10.809] The total size of the 2 globals is 158.73 KiB (162544 bytes)
[16:04:10.810] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 158.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (158.68 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.810] - globals: [2] ‘x’, ‘i’
[16:04:10.810] 
[16:04:10.810] getGlobalsAndPackages() ... DONE
[16:04:10.810] getGlobalsAndPackages() ...
[16:04:10.810] Searching for globals...
[16:04:10.812] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.812] Searching for globals ... DONE
[16:04:10.812] Resolving globals: FALSE
[16:04:10.817] The total size of the 2 globals is 167.09 KiB (171096 bytes)
[16:04:10.818] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 167.09 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (167.03 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.818] - globals: [2] ‘x’, ‘i’
[16:04:10.818] 
[16:04:10.818] getGlobalsAndPackages() ... DONE
[16:04:10.818] getGlobalsAndPackages() ...
[16:04:10.818] Searching for globals...
[16:04:10.820] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.820] Searching for globals ... DONE
[16:04:10.820] Resolving globals: FALSE
[16:04:10.826] The total size of the 2 globals is 175.44 KiB (179648 bytes)
[16:04:10.827] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 175.44 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (175.38 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.827] - globals: [2] ‘x’, ‘i’
[16:04:10.827] 
[16:04:10.827] getGlobalsAndPackages() ... DONE
[16:04:10.827] getGlobalsAndPackages() ...
[16:04:10.827] Searching for globals...
[16:04:10.829] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.829] Searching for globals ... DONE
[16:04:10.829] Resolving globals: FALSE
[16:04:10.835] The total size of the 2 globals is 183.79 KiB (188200 bytes)
[16:04:10.835] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 183.79 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (183.73 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.835] - globals: [2] ‘x’, ‘i’
[16:04:10.835] 
[16:04:10.836] getGlobalsAndPackages() ... DONE
[16:04:10.836] getGlobalsAndPackages() ...
[16:04:10.836] Searching for globals...
[16:04:10.838] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.838] Searching for globals ... DONE
[16:04:10.838] Resolving globals: FALSE
[16:04:10.845] The total size of the 2 globals is 192.14 KiB (196752 bytes)
[16:04:10.846] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 192.14 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (192.09 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.846] - globals: [2] ‘x’, ‘i’
[16:04:10.846] 
[16:04:10.846] getGlobalsAndPackages() ... DONE
[16:04:10.846] getGlobalsAndPackages() ...
[16:04:10.847] Searching for globals...
[16:04:10.848] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.848] Searching for globals ... DONE
[16:04:10.848] Resolving globals: FALSE
[16:04:10.855] The total size of the 2 globals is 200.49 KiB (205304 bytes)
[16:04:10.855] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 200.49 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (200.44 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.855] - globals: [2] ‘x’, ‘i’
[16:04:10.855] 
[16:04:10.855] getGlobalsAndPackages() ... DONE
[16:04:10.856] getGlobalsAndPackages() ...
[16:04:10.856] Searching for globals...
[16:04:10.857] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.858] Searching for globals ... DONE
[16:04:10.858] Resolving globals: FALSE
[16:04:10.865] The total size of the 2 globals is 208.84 KiB (213856 bytes)
[16:04:10.866] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 208.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (208.79 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.866] - globals: [2] ‘x’, ‘i’
[16:04:10.866] 
[16:04:10.866] getGlobalsAndPackages() ... DONE
[16:04:10.866] getGlobalsAndPackages() ...
[16:04:10.867] Searching for globals...
[16:04:10.868] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.868] Searching for globals ... DONE
[16:04:10.868] Resolving globals: FALSE
[16:04:10.875] The total size of the 2 globals is 217.20 KiB (222408 bytes)
[16:04:10.876] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 217.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (217.14 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.876] - globals: [2] ‘x’, ‘i’
[16:04:10.876] 
[16:04:10.876] getGlobalsAndPackages() ... DONE
[16:04:10.877] getGlobalsAndPackages() ...
[16:04:10.877] Searching for globals...
[16:04:10.879] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.879] Searching for globals ... DONE
[16:04:10.879] Resolving globals: FALSE
[16:04:10.886] The total size of the 2 globals is 225.55 KiB (230960 bytes)
[16:04:10.887] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 225.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (225.49 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.887] - globals: [2] ‘x’, ‘i’
[16:04:10.887] 
[16:04:10.887] getGlobalsAndPackages() ... DONE
[16:04:10.887] getGlobalsAndPackages() ...
[16:04:10.888] Searching for globals...
[16:04:10.889] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.889] Searching for globals ... DONE
[16:04:10.889] Resolving globals: FALSE
[16:04:10.898] The total size of the 2 globals is 233.90 KiB (239512 bytes)
[16:04:10.898] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 233.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (233.84 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.898] - globals: [2] ‘x’, ‘i’
[16:04:10.898] 
[16:04:10.898] getGlobalsAndPackages() ... DONE
[16:04:10.899] getGlobalsAndPackages() ...
[16:04:10.899] Searching for globals...
[16:04:10.900] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.901] Searching for globals ... DONE
[16:04:10.901] Resolving globals: FALSE
[16:04:10.908] The total size of the 2 globals is 242.25 KiB (248064 bytes)
[16:04:10.909] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 242.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (242.20 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.909] - globals: [2] ‘x’, ‘i’
[16:04:10.909] 
[16:04:10.909] getGlobalsAndPackages() ... DONE
[16:04:10.909] getGlobalsAndPackages() ...
[16:04:10.910] Searching for globals...
[16:04:10.912] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.912] Searching for globals ... DONE
[16:04:10.912] Resolving globals: FALSE
[16:04:10.920] The total size of the 2 globals is 250.60 KiB (256616 bytes)
[16:04:10.920] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 250.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (250.55 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.921] - globals: [2] ‘x’, ‘i’
[16:04:10.921] 
[16:04:10.921] getGlobalsAndPackages() ... DONE
[16:04:10.921] getGlobalsAndPackages() ...
[16:04:10.921] Searching for globals...
[16:04:10.923] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.923] Searching for globals ... DONE
[16:04:10.923] Resolving globals: FALSE
[16:04:10.932] The total size of the 2 globals is 258.95 KiB (265168 bytes)
[16:04:10.933] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 258.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (258.90 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.933] - globals: [2] ‘x’, ‘i’
[16:04:10.933] 
[16:04:10.933] getGlobalsAndPackages() ... DONE
[16:04:10.934] getGlobalsAndPackages() ...
[16:04:10.934] Searching for globals...
[16:04:10.935] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.935] Searching for globals ... DONE
[16:04:10.935] Resolving globals: FALSE
[16:04:10.945] The total size of the 2 globals is 267.30 KiB (273720 bytes)
[16:04:10.945] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 267.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (267.25 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.945] - globals: [2] ‘x’, ‘i’
[16:04:10.945] 
[16:04:10.946] getGlobalsAndPackages() ... DONE
[16:04:10.946] getGlobalsAndPackages() ...
[16:04:10.946] Searching for globals...
[16:04:10.948] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.948] Searching for globals ... DONE
[16:04:10.948] Resolving globals: FALSE
[16:04:10.956] The total size of the 2 globals is 275.66 KiB (282272 bytes)
[16:04:10.957] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 275.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (275.60 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.957] - globals: [2] ‘x’, ‘i’
[16:04:10.957] 
[16:04:10.957] getGlobalsAndPackages() ... DONE
[16:04:10.958] getGlobalsAndPackages() ...
[16:04:10.958] Searching for globals...
[16:04:10.960] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.960] Searching for globals ... DONE
[16:04:10.960] Resolving globals: FALSE
[16:04:10.969] The total size of the 2 globals is 284.01 KiB (290824 bytes)
[16:04:10.970] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 284.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (283.95 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.970] - globals: [2] ‘x’, ‘i’
[16:04:10.970] 
[16:04:10.970] getGlobalsAndPackages() ... DONE
[16:04:10.970] getGlobalsAndPackages() ...
[16:04:10.971] Searching for globals...
[16:04:10.972] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.972] Searching for globals ... DONE
[16:04:10.972] Resolving globals: FALSE
[16:04:10.983] The total size of the 2 globals is 292.36 KiB (299376 bytes)
[16:04:10.983] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 292.36 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (292.30 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.983] - globals: [2] ‘x’, ‘i’
[16:04:10.983] 
[16:04:10.983] getGlobalsAndPackages() ... DONE
[16:04:10.984] getGlobalsAndPackages() ...
[16:04:10.984] Searching for globals...
[16:04:10.985] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.986] Searching for globals ... DONE
[16:04:10.986] Resolving globals: FALSE
[16:04:10.996] The total size of the 2 globals is 300.71 KiB (307928 bytes)
[16:04:10.997] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 300.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (300.66 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:10.997] - globals: [2] ‘x’, ‘i’
[16:04:10.997] 
[16:04:10.997] getGlobalsAndPackages() ... DONE
[16:04:10.997] getGlobalsAndPackages() ...
[16:04:10.997] Searching for globals...
[16:04:10.999] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:10.999] Searching for globals ... DONE
[16:04:10.999] Resolving globals: FALSE
[16:04:11.030] The total size of the 2 globals is 309.06 KiB (316480 bytes)
[16:04:11.031] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 309.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (309.01 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.031] - globals: [2] ‘x’, ‘i’
[16:04:11.031] 
[16:04:11.031] getGlobalsAndPackages() ... DONE
[16:04:11.032] getGlobalsAndPackages() ...
[16:04:11.032] Searching for globals...
[16:04:11.033] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.033] Searching for globals ... DONE
[16:04:11.033] Resolving globals: FALSE
[16:04:11.045] The total size of the 2 globals is 317.41 KiB (325032 bytes)
[16:04:11.045] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 317.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (317.36 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.045] - globals: [2] ‘x’, ‘i’
[16:04:11.045] 
[16:04:11.045] getGlobalsAndPackages() ... DONE
[16:04:11.046] getGlobalsAndPackages() ...
[16:04:11.046] Searching for globals...
[16:04:11.047] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.047] Searching for globals ... DONE
[16:04:11.048] Resolving globals: FALSE
[16:04:11.058] The total size of the 2 globals is 325.77 KiB (333584 bytes)
[16:04:11.058] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 325.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (325.71 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.059] - globals: [2] ‘x’, ‘i’
[16:04:11.059] 
[16:04:11.059] getGlobalsAndPackages() ... DONE
[16:04:11.059] getGlobalsAndPackages() ...
[16:04:11.059] Searching for globals...
[16:04:11.062] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.062] Searching for globals ... DONE
[16:04:11.062] Resolving globals: FALSE
[16:04:11.072] The total size of the 2 globals is 334.12 KiB (342136 bytes)
[16:04:11.073] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 334.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (334.06 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.073] - globals: [2] ‘x’, ‘i’
[16:04:11.073] 
[16:04:11.073] getGlobalsAndPackages() ... DONE
[16:04:11.074] getGlobalsAndPackages() ...
[16:04:11.074] Searching for globals...
[16:04:11.075] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.075] Searching for globals ... DONE
[16:04:11.075] Resolving globals: FALSE
[16:04:11.087] The total size of the 2 globals is 342.47 KiB (350688 bytes)
[16:04:11.088] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 342.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (342.41 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.088] - globals: [2] ‘x’, ‘i’
[16:04:11.088] 
[16:04:11.088] getGlobalsAndPackages() ... DONE
[16:04:11.089] getGlobalsAndPackages() ...
[16:04:11.089] Searching for globals...
[16:04:11.090] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.090] Searching for globals ... DONE
[16:04:11.090] Resolving globals: FALSE
[16:04:11.102] The total size of the 2 globals is 350.82 KiB (359240 bytes)
[16:04:11.103] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 350.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (350.77 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.103] - globals: [2] ‘x’, ‘i’
[16:04:11.103] 
[16:04:11.103] getGlobalsAndPackages() ... DONE
[16:04:11.104] getGlobalsAndPackages() ...
[16:04:11.104] Searching for globals...
[16:04:11.105] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.105] Searching for globals ... DONE
[16:04:11.105] Resolving globals: FALSE
[16:04:11.118] The total size of the 2 globals is 359.17 KiB (367792 bytes)
[16:04:11.118] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 359.17 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (359.12 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.119] - globals: [2] ‘x’, ‘i’
[16:04:11.119] 
[16:04:11.119] getGlobalsAndPackages() ... DONE
[16:04:11.119] getGlobalsAndPackages() ...
[16:04:11.119] Searching for globals...
[16:04:11.121] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.121] Searching for globals ... DONE
[16:04:11.121] Resolving globals: FALSE
[16:04:11.134] The total size of the 2 globals is 367.52 KiB (376344 bytes)
[16:04:11.134] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 367.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (367.47 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.134] - globals: [2] ‘x’, ‘i’
[16:04:11.135] 
[16:04:11.135] getGlobalsAndPackages() ... DONE
[16:04:11.135] getGlobalsAndPackages() ...
[16:04:11.135] Searching for globals...
[16:04:11.137] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.137] Searching for globals ... DONE
[16:04:11.137] Resolving globals: FALSE
[16:04:11.150] The total size of the 2 globals is 375.88 KiB (384896 bytes)
[16:04:11.150] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 375.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (375.82 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.151] - globals: [2] ‘x’, ‘i’
[16:04:11.151] 
[16:04:11.151] getGlobalsAndPackages() ... DONE
[16:04:11.151] getGlobalsAndPackages() ...
[16:04:11.151] Searching for globals...
[16:04:11.153] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.153] Searching for globals ... DONE
[16:04:11.153] Resolving globals: FALSE
[16:04:11.166] The total size of the 2 globals is 384.23 KiB (393448 bytes)
[16:04:11.167] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 384.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (384.17 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.167] - globals: [2] ‘x’, ‘i’
[16:04:11.167] 
[16:04:11.167] getGlobalsAndPackages() ... DONE
[16:04:11.167] getGlobalsAndPackages() ...
[16:04:11.168] Searching for globals...
[16:04:11.169] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.169] Searching for globals ... DONE
[16:04:11.169] Resolving globals: FALSE
[16:04:11.182] The total size of the 2 globals is 392.58 KiB (402000 bytes)
[16:04:11.183] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 392.58 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (392.52 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.183] - globals: [2] ‘x’, ‘i’
[16:04:11.183] 
[16:04:11.183] getGlobalsAndPackages() ... DONE
[16:04:11.184] getGlobalsAndPackages() ...
[16:04:11.184] Searching for globals...
[16:04:11.185] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.185] Searching for globals ... DONE
[16:04:11.185] Resolving globals: FALSE
[16:04:11.199] The total size of the 2 globals is 400.93 KiB (410552 bytes)
[16:04:11.199] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 400.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (400.88 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.200] - globals: [2] ‘x’, ‘i’
[16:04:11.200] 
[16:04:11.200] getGlobalsAndPackages() ... DONE
[16:04:11.200] getGlobalsAndPackages() ...
[16:04:11.200] Searching for globals...
[16:04:11.202] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.202] Searching for globals ... DONE
[16:04:11.202] Resolving globals: FALSE
[16:04:11.216] The total size of the 2 globals is 409.28 KiB (419104 bytes)
[16:04:11.216] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 409.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (409.23 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.216] - globals: [2] ‘x’, ‘i’
[16:04:11.217] 
[16:04:11.217] getGlobalsAndPackages() ... DONE
[16:04:11.217] getGlobalsAndPackages() ...
[16:04:11.217] Searching for globals...
[16:04:11.219] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.219] Searching for globals ... DONE
[16:04:11.219] Resolving globals: FALSE
[16:04:11.233] The total size of the 2 globals is 417.63 KiB (427656 bytes)
[16:04:11.234] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 417.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (417.58 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.234] - globals: [2] ‘x’, ‘i’
[16:04:11.234] 
[16:04:11.234] getGlobalsAndPackages() ... DONE
[16:04:11.234] getGlobalsAndPackages() ...
[16:04:11.234] Searching for globals...
[16:04:11.236] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.237] Searching for globals ... DONE
[16:04:11.237] Resolving globals: FALSE
[16:04:11.251] The total size of the 2 globals is 425.98 KiB (436208 bytes)
[16:04:11.252] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 425.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (425.93 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.252] - globals: [2] ‘x’, ‘i’
[16:04:11.252] 
[16:04:11.252] getGlobalsAndPackages() ... DONE
[16:04:11.253] getGlobalsAndPackages() ...
[16:04:11.253] Searching for globals...
[16:04:11.254] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.254] Searching for globals ... DONE
[16:04:11.255] Resolving globals: FALSE
[16:04:11.270] The total size of the 2 globals is 434.34 KiB (444760 bytes)
[16:04:11.270] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 434.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (434.28 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.270] - globals: [2] ‘x’, ‘i’
[16:04:11.270] 
[16:04:11.270] getGlobalsAndPackages() ... DONE
[16:04:11.271] getGlobalsAndPackages() ...
[16:04:11.271] Searching for globals...
[16:04:11.273] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.273] Searching for globals ... DONE
[16:04:11.273] Resolving globals: FALSE
[16:04:11.288] The total size of the 2 globals is 442.69 KiB (453312 bytes)
[16:04:11.288] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 442.69 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (442.63 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.288] - globals: [2] ‘x’, ‘i’
[16:04:11.289] 
[16:04:11.289] getGlobalsAndPackages() ... DONE
[16:04:11.289] getGlobalsAndPackages() ...
[16:04:11.289] Searching for globals...
[16:04:11.291] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.291] Searching for globals ... DONE
[16:04:11.291] Resolving globals: FALSE
[16:04:11.306] The total size of the 2 globals is 451.04 KiB (461864 bytes)
[16:04:11.307] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 451.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (450.98 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.307] - globals: [2] ‘x’, ‘i’
[16:04:11.307] 
[16:04:11.307] getGlobalsAndPackages() ... DONE
[16:04:11.307] getGlobalsAndPackages() ...
[16:04:11.307] Searching for globals...
[16:04:11.309] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.309] Searching for globals ... DONE
[16:04:11.309] Resolving globals: FALSE
[16:04:11.325] The total size of the 2 globals is 459.39 KiB (470416 bytes)
[16:04:11.325] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 459.39 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (459.34 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.325] - globals: [2] ‘x’, ‘i’
[16:04:11.325] 
[16:04:11.325] getGlobalsAndPackages() ... DONE
[16:04:11.326] getGlobalsAndPackages() ...
[16:04:11.326] Searching for globals...
[16:04:11.328] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.328] Searching for globals ... DONE
[16:04:11.328] Resolving globals: FALSE
[16:04:11.344] The total size of the 2 globals is 467.74 KiB (478968 bytes)
[16:04:11.344] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 467.74 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (467.69 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.344] - globals: [2] ‘x’, ‘i’
[16:04:11.344] 
[16:04:11.344] getGlobalsAndPackages() ... DONE
[16:04:11.345] getGlobalsAndPackages() ...
[16:04:11.345] Searching for globals...
[16:04:11.346] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.347] Searching for globals ... DONE
[16:04:11.347] Resolving globals: FALSE
[16:04:11.363] The total size of the 2 globals is 476.09 KiB (487520 bytes)
[16:04:11.364] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 476.09 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (476.04 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.364] - globals: [2] ‘x’, ‘i’
[16:04:11.364] 
[16:04:11.364] getGlobalsAndPackages() ... DONE
[16:04:11.364] getGlobalsAndPackages() ...
[16:04:11.364] Searching for globals...
[16:04:11.366] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.366] Searching for globals ... DONE
[16:04:11.366] Resolving globals: FALSE
[16:04:11.382] The total size of the 2 globals is 484.45 KiB (496072 bytes)
[16:04:11.383] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 484.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (484.39 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.383] - globals: [2] ‘x’, ‘i’
[16:04:11.383] 
[16:04:11.383] getGlobalsAndPackages() ... DONE
[16:04:11.383] getGlobalsAndPackages() ...
[16:04:11.383] Searching for globals...
[16:04:11.385] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.385] Searching for globals ... DONE
[16:04:11.385] Resolving globals: FALSE
[16:04:11.402] The total size of the 2 globals is 492.80 KiB (504624 bytes)
[16:04:11.402] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 492.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (492.74 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.402] - globals: [2] ‘x’, ‘i’
[16:04:11.403] 
[16:04:11.403] getGlobalsAndPackages() ... DONE
[16:04:11.403] getGlobalsAndPackages() ...
[16:04:11.403] Searching for globals...
[16:04:11.405] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.405] Searching for globals ... DONE
[16:04:11.405] Resolving globals: FALSE
[16:04:11.421] The total size of the 2 globals is 501.15 KiB (513176 bytes)
[16:04:11.422] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 501.15 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (501.09 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.422] - globals: [2] ‘x’, ‘i’
[16:04:11.422] 
[16:04:11.422] getGlobalsAndPackages() ... DONE
[16:04:11.422] getGlobalsAndPackages() ...
[16:04:11.423] Searching for globals...
[16:04:11.424] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.424] Searching for globals ... DONE
[16:04:11.424] Resolving globals: FALSE
[16:04:11.441] The total size of the 2 globals is 509.50 KiB (521728 bytes)
[16:04:11.441] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 509.50 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (509.45 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.441] - globals: [2] ‘x’, ‘i’
[16:04:11.441] 
[16:04:11.442] getGlobalsAndPackages() ... DONE
[16:04:11.442] getGlobalsAndPackages() ...
[16:04:11.442] Searching for globals...
[16:04:11.444] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.444] Searching for globals ... DONE
[16:04:11.444] Resolving globals: FALSE
[16:04:11.462] The total size of the 2 globals is 517.85 KiB (530280 bytes)
[16:04:11.462] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 517.85 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (517.80 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.462] - globals: [2] ‘x’, ‘i’
[16:04:11.462] 
[16:04:11.462] getGlobalsAndPackages() ... DONE
[16:04:11.463] getGlobalsAndPackages() ...
[16:04:11.463] Searching for globals...
[16:04:11.464] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.464] Searching for globals ... DONE
[16:04:11.465] Resolving globals: FALSE
[16:04:11.482] The total size of the 2 globals is 526.20 KiB (538832 bytes)
[16:04:11.482] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 526.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (526.15 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.482] - globals: [2] ‘x’, ‘i’
[16:04:11.483] 
[16:04:11.483] getGlobalsAndPackages() ... DONE
[16:04:11.483] getGlobalsAndPackages() ...
[16:04:11.483] Searching for globals...
[16:04:11.485] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.485] Searching for globals ... DONE
[16:04:11.485] Resolving globals: FALSE
[16:04:11.503] The total size of the 2 globals is 534.55 KiB (547384 bytes)
[16:04:11.503] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 534.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (534.50 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.503] - globals: [2] ‘x’, ‘i’
[16:04:11.504] 
[16:04:11.504] getGlobalsAndPackages() ... DONE
[16:04:11.504] getGlobalsAndPackages() ...
[16:04:11.504] Searching for globals...
[16:04:11.506] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.506] Searching for globals ... DONE
[16:04:11.506] Resolving globals: FALSE
[16:04:11.524] The total size of the 2 globals is 542.91 KiB (555936 bytes)
[16:04:11.524] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 542.91 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (542.85 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.524] - globals: [2] ‘x’, ‘i’
[16:04:11.524] 
[16:04:11.524] getGlobalsAndPackages() ... DONE
[16:04:11.525] getGlobalsAndPackages() ...
[16:04:11.525] Searching for globals...
[16:04:11.526] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.526] Searching for globals ... DONE
[16:04:11.527] Resolving globals: FALSE
[16:04:11.545] The total size of the 2 globals is 551.26 KiB (564488 bytes)
[16:04:11.546] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 551.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (551.20 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.546] - globals: [2] ‘x’, ‘i’
[16:04:11.546] 
[16:04:11.546] getGlobalsAndPackages() ... DONE
[16:04:11.546] getGlobalsAndPackages() ...
[16:04:11.547] Searching for globals...
[16:04:11.548] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.548] Searching for globals ... DONE
[16:04:11.548] Resolving globals: FALSE
[16:04:11.567] The total size of the 2 globals is 559.61 KiB (573040 bytes)
[16:04:11.567] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 559.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (559.55 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.567] - globals: [2] ‘x’, ‘i’
[16:04:11.567] 
[16:04:11.567] getGlobalsAndPackages() ... DONE
[16:04:11.568] getGlobalsAndPackages() ...
[16:04:11.568] Searching for globals...
[16:04:11.569] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.569] Searching for globals ... DONE
[16:04:11.570] Resolving globals: FALSE
[16:04:11.589] The total size of the 2 globals is 567.96 KiB (581592 bytes)
[16:04:11.589] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 567.96 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (567.91 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.589] - globals: [2] ‘x’, ‘i’
[16:04:11.590] 
[16:04:11.590] getGlobalsAndPackages() ... DONE
[16:04:11.590] getGlobalsAndPackages() ...
[16:04:11.590] Searching for globals...
[16:04:11.592] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.592] Searching for globals ... DONE
[16:04:11.592] Resolving globals: FALSE
[16:04:11.612] The total size of the 2 globals is 576.31 KiB (590144 bytes)
[16:04:11.612] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 576.31 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (576.26 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.612] - globals: [2] ‘x’, ‘i’
[16:04:11.612] 
[16:04:11.612] getGlobalsAndPackages() ... DONE
[16:04:11.613] getGlobalsAndPackages() ...
[16:04:11.613] Searching for globals...
[16:04:11.614] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.615] Searching for globals ... DONE
[16:04:11.615] Resolving globals: FALSE
[16:04:11.636] The total size of the 2 globals is 584.66 KiB (598696 bytes)
[16:04:11.636] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 584.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (584.61 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.636] - globals: [2] ‘x’, ‘i’
[16:04:11.636] 
[16:04:11.636] getGlobalsAndPackages() ... DONE
[16:04:11.637] getGlobalsAndPackages() ...
[16:04:11.637] Searching for globals...
[16:04:11.638] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.638] Searching for globals ... DONE
[16:04:11.639] Resolving globals: FALSE
[16:04:11.659] The total size of the 2 globals is 593.02 KiB (607248 bytes)
[16:04:11.660] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 593.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (592.96 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.660] - globals: [2] ‘x’, ‘i’
[16:04:11.660] 
[16:04:11.660] getGlobalsAndPackages() ... DONE
[16:04:11.661] getGlobalsAndPackages() ...
[16:04:11.661] Searching for globals...
[16:04:11.662] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.662] Searching for globals ... DONE
[16:04:11.663] Resolving globals: FALSE
[16:04:11.684] The total size of the 2 globals is 601.37 KiB (615800 bytes)
[16:04:11.684] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 601.37 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (601.31 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.684] - globals: [2] ‘x’, ‘i’
[16:04:11.684] 
[16:04:11.684] getGlobalsAndPackages() ... DONE
[16:04:11.685] getGlobalsAndPackages() ...
[16:04:11.685] Searching for globals...
[16:04:11.687] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.687] Searching for globals ... DONE
[16:04:11.687] Resolving globals: FALSE
[16:04:11.709] The total size of the 2 globals is 609.72 KiB (624352 bytes)
[16:04:11.709] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 609.72 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (609.66 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.709] - globals: [2] ‘x’, ‘i’
[16:04:11.709] 
[16:04:11.709] getGlobalsAndPackages() ... DONE
[16:04:11.710] getGlobalsAndPackages() ...
[16:04:11.710] Searching for globals...
[16:04:11.711] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.711] Searching for globals ... DONE
[16:04:11.712] Resolving globals: FALSE
[16:04:11.734] The total size of the 2 globals is 618.07 KiB (632904 bytes)
[16:04:11.735] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 618.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (618.02 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.735] - globals: [2] ‘x’, ‘i’
[16:04:11.735] 
[16:04:11.735] getGlobalsAndPackages() ... DONE
[16:04:11.736] getGlobalsAndPackages() ...
[16:04:11.736] Searching for globals...
[16:04:11.737] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.738] Searching for globals ... DONE
[16:04:11.738] Resolving globals: FALSE
[16:04:11.761] The total size of the 2 globals is 626.42 KiB (641456 bytes)
[16:04:11.761] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 626.42 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (626.37 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.762] - globals: [2] ‘x’, ‘i’
[16:04:11.762] 
[16:04:11.762] getGlobalsAndPackages() ... DONE
[16:04:11.762] getGlobalsAndPackages() ...
[16:04:11.762] Searching for globals...
[16:04:11.764] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.764] Searching for globals ... DONE
[16:04:11.764] Resolving globals: FALSE
[16:04:11.788] The total size of the 2 globals is 634.77 KiB (650008 bytes)
[16:04:11.789] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 634.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (634.72 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.789] - globals: [2] ‘x’, ‘i’
[16:04:11.789] 
[16:04:11.789] getGlobalsAndPackages() ... DONE
[16:04:11.790] getGlobalsAndPackages() ...
[16:04:11.790] Searching for globals...
[16:04:11.791] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.791] Searching for globals ... DONE
[16:04:11.791] Resolving globals: FALSE
[16:04:11.815] The total size of the 2 globals is 643.12 KiB (658560 bytes)
[16:04:11.815] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 643.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (643.07 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.816] - globals: [2] ‘x’, ‘i’
[16:04:11.816] 
[16:04:11.816] getGlobalsAndPackages() ... DONE
[16:04:11.816] getGlobalsAndPackages() ...
[16:04:11.816] Searching for globals...
[16:04:11.818] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.818] Searching for globals ... DONE
[16:04:11.818] Resolving globals: FALSE
[16:04:11.842] The total size of the 2 globals is 651.48 KiB (667112 bytes)
[16:04:11.842] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 651.48 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (651.42 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.842] - globals: [2] ‘x’, ‘i’
[16:04:11.843] 
[16:04:11.843] getGlobalsAndPackages() ... DONE
[16:04:11.843] getGlobalsAndPackages() ...
[16:04:11.843] Searching for globals...
[16:04:11.845] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.845] Searching for globals ... DONE
[16:04:11.845] Resolving globals: FALSE
[16:04:11.869] The total size of the 2 globals is 659.83 KiB (675664 bytes)
[16:04:11.869] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 659.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (659.77 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.869] - globals: [2] ‘x’, ‘i’
[16:04:11.871] 
[16:04:11.871] getGlobalsAndPackages() ... DONE
[16:04:11.871] getGlobalsAndPackages() ...
[16:04:11.871] Searching for globals...
[16:04:11.873] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.873] Searching for globals ... DONE
[16:04:11.873] Resolving globals: FALSE
[16:04:11.898] The total size of the 2 globals is 668.18 KiB (684216 bytes)
[16:04:11.898] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 668.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (668.12 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.898] - globals: [2] ‘x’, ‘i’
[16:04:11.898] 
[16:04:11.899] getGlobalsAndPackages() ... DONE
[16:04:11.899] getGlobalsAndPackages() ...
[16:04:11.899] Searching for globals...
[16:04:11.902] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.902] Searching for globals ... DONE
[16:04:11.902] Resolving globals: FALSE
[16:04:11.927] The total size of the 2 globals is 676.53 KiB (692768 bytes)
[16:04:11.928] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 676.53 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (676.48 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.928] - globals: [2] ‘x’, ‘i’
[16:04:11.928] 
[16:04:11.928] getGlobalsAndPackages() ... DONE
[16:04:11.929] getGlobalsAndPackages() ...
[16:04:11.929] Searching for globals...
[16:04:11.930] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.930] Searching for globals ... DONE
[16:04:11.930] Resolving globals: FALSE
[16:04:11.957] The total size of the 2 globals is 684.88 KiB (701320 bytes)
[16:04:11.958] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 684.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (684.83 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:11.958] - globals: [2] ‘x’, ‘i’
[16:04:11.958] 
[16:04:11.958] getGlobalsAndPackages() ... DONE
[16:04:11.959] getGlobalsAndPackages() ...
[16:04:11.959] Searching for globals...
[16:04:11.960] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:11.960] Searching for globals ... DONE
[16:04:11.961] Resolving globals: FALSE
[16:04:12.010] The total size of the 2 globals is 693.23 KiB (709872 bytes)
[16:04:12.011] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 693.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (693.18 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.011] - globals: [2] ‘x’, ‘i’
[16:04:12.011] 
[16:04:12.011] getGlobalsAndPackages() ... DONE
[16:04:12.012] getGlobalsAndPackages() ...
[16:04:12.012] Searching for globals...
[16:04:12.014] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.014] Searching for globals ... DONE
[16:04:12.014] Resolving globals: FALSE
[16:04:12.044] The total size of the 2 globals is 701.59 KiB (718424 bytes)
[16:04:12.044] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 701.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (701.53 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.044] - globals: [2] ‘x’, ‘i’
[16:04:12.045] 
[16:04:12.045] getGlobalsAndPackages() ... DONE
[16:04:12.045] getGlobalsAndPackages() ...
[16:04:12.045] Searching for globals...
[16:04:12.047] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.047] Searching for globals ... DONE
[16:04:12.048] Resolving globals: FALSE
[16:04:12.077] The total size of the 2 globals is 709.94 KiB (726976 bytes)
[16:04:12.078] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 709.94 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (709.88 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.078] - globals: [2] ‘x’, ‘i’
[16:04:12.078] 
[16:04:12.078] getGlobalsAndPackages() ... DONE
[16:04:12.079] getGlobalsAndPackages() ...
[16:04:12.079] Searching for globals...
[16:04:12.080] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.080] Searching for globals ... DONE
[16:04:12.081] Resolving globals: FALSE
[16:04:12.108] The total size of the 2 globals is 718.29 KiB (735528 bytes)
[16:04:12.109] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 718.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (718.23 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.109] - globals: [2] ‘x’, ‘i’
[16:04:12.109] 
[16:04:12.109] getGlobalsAndPackages() ... DONE
[16:04:12.110] getGlobalsAndPackages() ...
[16:04:12.110] Searching for globals...
[16:04:12.112] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.112] Searching for globals ... DONE
[16:04:12.112] Resolving globals: FALSE
[16:04:12.140] The total size of the 2 globals is 726.64 KiB (744080 bytes)
[16:04:12.140] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 726.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (726.59 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.141] - globals: [2] ‘x’, ‘i’
[16:04:12.141] 
[16:04:12.141] getGlobalsAndPackages() ... DONE
[16:04:12.141] getGlobalsAndPackages() ...
[16:04:12.141] Searching for globals...
[16:04:12.143] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.143] Searching for globals ... DONE
[16:04:12.143] Resolving globals: FALSE
[16:04:12.172] The total size of the 2 globals is 734.99 KiB (752632 bytes)
[16:04:12.172] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 734.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (734.94 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.172] - globals: [2] ‘x’, ‘i’
[16:04:12.172] 
[16:04:12.172] getGlobalsAndPackages() ... DONE
[16:04:12.174] getGlobalsAndPackages() ...
[16:04:12.174] Searching for globals...
[16:04:12.176] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.176] Searching for globals ... DONE
[16:04:12.176] Resolving globals: FALSE
[16:04:12.205] The total size of the 2 globals is 743.34 KiB (761184 bytes)
[16:04:12.205] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 743.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (743.29 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.205] - globals: [2] ‘x’, ‘i’
[16:04:12.206] 
[16:04:12.206] getGlobalsAndPackages() ... DONE
[16:04:12.206] getGlobalsAndPackages() ...
[16:04:12.206] Searching for globals...
[16:04:12.208] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.208] Searching for globals ... DONE
[16:04:12.208] Resolving globals: FALSE
[16:04:12.237] The total size of the 2 globals is 751.70 KiB (769736 bytes)
[16:04:12.237] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 751.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (751.64 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.237] - globals: [2] ‘x’, ‘i’
[16:04:12.238] 
[16:04:12.238] getGlobalsAndPackages() ... DONE
[16:04:12.238] getGlobalsAndPackages() ...
[16:04:12.238] Searching for globals...
[16:04:12.240] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.240] Searching for globals ... DONE
[16:04:12.240] Resolving globals: FALSE
[16:04:12.270] The total size of the 2 globals is 760.05 KiB (778288 bytes)
[16:04:12.270] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 760.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (759.99 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.270] - globals: [2] ‘x’, ‘i’
[16:04:12.270] 
[16:04:12.270] getGlobalsAndPackages() ... DONE
[16:04:12.271] getGlobalsAndPackages() ...
[16:04:12.271] Searching for globals...
[16:04:12.273] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.273] Searching for globals ... DONE
[16:04:12.273] Resolving globals: FALSE
[16:04:12.303] The total size of the 2 globals is 768.40 KiB (786840 bytes)
[16:04:12.303] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 768.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (768.34 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.304] - globals: [2] ‘x’, ‘i’
[16:04:12.304] 
[16:04:12.304] getGlobalsAndPackages() ... DONE
[16:04:12.304] getGlobalsAndPackages() ...
[16:04:12.305] Searching for globals...
[16:04:12.306] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.306] Searching for globals ... DONE
[16:04:12.306] Resolving globals: FALSE
[16:04:12.337] The total size of the 2 globals is 776.75 KiB (795392 bytes)
[16:04:12.338] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 776.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (776.70 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.338] - globals: [2] ‘x’, ‘i’
[16:04:12.338] 
[16:04:12.338] getGlobalsAndPackages() ... DONE
[16:04:12.339] getGlobalsAndPackages() ...
[16:04:12.339] Searching for globals...
[16:04:12.341] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.341] Searching for globals ... DONE
[16:04:12.341] Resolving globals: FALSE
[16:04:12.372] The total size of the 2 globals is 785.10 KiB (803944 bytes)
[16:04:12.372] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 785.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (785.05 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.372] - globals: [2] ‘x’, ‘i’
[16:04:12.372] 
[16:04:12.373] getGlobalsAndPackages() ... DONE
[16:04:12.373] getGlobalsAndPackages() ...
[16:04:12.373] Searching for globals...
[16:04:12.375] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.375] Searching for globals ... DONE
[16:04:12.375] Resolving globals: FALSE
[16:04:12.406] The total size of the 2 globals is 793.45 KiB (812496 bytes)
[16:04:12.407] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 793.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (793.40 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.407] - globals: [2] ‘x’, ‘i’
[16:04:12.407] 
[16:04:12.407] getGlobalsAndPackages() ... DONE
[16:04:12.407] getGlobalsAndPackages() ...
[16:04:12.408] Searching for globals...
[16:04:12.409] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.409] Searching for globals ... DONE
[16:04:12.409] Resolving globals: FALSE
[16:04:12.440] The total size of the 2 globals is 801.80 KiB (821048 bytes)
[16:04:12.441] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 801.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (801.75 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.441] - globals: [2] ‘x’, ‘i’
[16:04:12.441] 
[16:04:12.442] getGlobalsAndPackages() ... DONE
[16:04:12.443] getGlobalsAndPackages() ...
[16:04:12.443] Searching for globals...
[16:04:12.445] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:04:12.445] Searching for globals ... DONE
[16:04:12.445] Resolving globals: FALSE
[16:04:12.477] The total size of the 2 globals is 810.16 KiB (829600 bytes)
[16:04:12.477] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 810.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (810.10 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:04:12.477] - globals: [2] ‘x’, ‘i’
[16:04:12.477] 
[16:04:12.477] getGlobalsAndPackages() ... DONE

> ## At this point nothing has been calculated,
> ## because lazy evaluation is in place.
> 
> ## Get the 7:th Fibonnaci numbers (should be 8)
> print(x[[7]])
[16:04:12.478] run() for ‘Future’ ...
[16:04:12.479] - state: ‘created’
[16:04:12.479] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:12.479] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:12.479] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:12.479]   - Field: ‘label’
[16:04:12.480]   - Field: ‘local’
[16:04:12.480]   - Field: ‘owner’
[16:04:12.480]   - Field: ‘envir’
[16:04:12.480]   - Field: ‘packages’
[16:04:12.480]   - Field: ‘gc’
[16:04:12.480]   - Field: ‘conditions’
[16:04:12.480]   - Field: ‘expr’
[16:04:12.480]   - Field: ‘uuid’
[16:04:12.480]   - Field: ‘seed’
[16:04:12.480]   - Field: ‘version’
[16:04:12.481]   - Field: ‘result’
[16:04:12.481]   - Field: ‘asynchronous’
[16:04:12.481]   - Field: ‘calls’
[16:04:12.481]   - Field: ‘globals’
[16:04:12.481]   - Field: ‘stdout’
[16:04:12.481]   - Field: ‘earlySignal’
[16:04:12.481]   - Field: ‘lazy’
[16:04:12.481]   - Field: ‘state’
[16:04:12.481] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:12.481] - Launch lazy future ...
[16:04:12.482] Packages needed by the future expression (n = 0): <none>
[16:04:12.482] Packages needed by future strategies (n = 0): <none>
[16:04:12.483] {
[16:04:12.483]     {
[16:04:12.483]         {
[16:04:12.483]             ...future.startTime <- base::Sys.time()
[16:04:12.483]             {
[16:04:12.483]                 {
[16:04:12.483]                   {
[16:04:12.483]                     base::local({
[16:04:12.483]                       has_future <- base::requireNamespace("future", 
[16:04:12.483]                         quietly = TRUE)
[16:04:12.483]                       if (has_future) {
[16:04:12.483]                         ns <- base::getNamespace("future")
[16:04:12.483]                         version <- ns[[".package"]][["version"]]
[16:04:12.483]                         if (is.null(version)) 
[16:04:12.483]                           version <- utils::packageVersion("future")
[16:04:12.483]                       }
[16:04:12.483]                       else {
[16:04:12.483]                         version <- NULL
[16:04:12.483]                       }
[16:04:12.483]                       if (!has_future || version < "1.8.0") {
[16:04:12.483]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:12.483]                           "", base::R.version$version.string), 
[16:04:12.483]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:12.483]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:12.483]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:12.483]                             "release", "version")], collapse = " "), 
[16:04:12.483]                           hostname = base::Sys.info()[["nodename"]])
[16:04:12.483]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:12.483]                           info)
[16:04:12.483]                         info <- base::paste(info, collapse = "; ")
[16:04:12.483]                         if (!has_future) {
[16:04:12.483]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:12.483]                             info)
[16:04:12.483]                         }
[16:04:12.483]                         else {
[16:04:12.483]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:12.483]                             info, version)
[16:04:12.483]                         }
[16:04:12.483]                         base::stop(msg)
[16:04:12.483]                       }
[16:04:12.483]                     })
[16:04:12.483]                   }
[16:04:12.483]                   options(future.plan = NULL)
[16:04:12.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:12.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:12.483]                 }
[16:04:12.483]                 ...future.workdir <- getwd()
[16:04:12.483]             }
[16:04:12.483]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:12.483]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:12.483]         }
[16:04:12.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:12.483]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:12.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:12.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:12.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:12.483]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:12.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:12.483]             base::names(...future.oldOptions))
[16:04:12.483]     }
[16:04:12.483]     if (TRUE) {
[16:04:12.483]     }
[16:04:12.483]     else {
[16:04:12.483]         if (NA) {
[16:04:12.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:12.483]                 open = "w")
[16:04:12.483]         }
[16:04:12.483]         else {
[16:04:12.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:12.483]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:12.483]         }
[16:04:12.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:12.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:12.483]             base::sink(type = "output", split = FALSE)
[16:04:12.483]             base::close(...future.stdout)
[16:04:12.483]         }, add = TRUE)
[16:04:12.483]     }
[16:04:12.483]     ...future.frame <- base::sys.nframe()
[16:04:12.483]     ...future.conditions <- base::list()
[16:04:12.483]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:12.483]     if (FALSE) {
[16:04:12.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:12.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:12.483]     }
[16:04:12.483]     ...future.result <- base::tryCatch({
[16:04:12.483]         base::withCallingHandlers({
[16:04:12.483]             ...future.value <- base::withVisible(base::local({
[16:04:12.483]                 x[[i - 2]] + x[[i - 1]]
[16:04:12.483]             }))
[16:04:12.483]             future::FutureResult(value = ...future.value$value, 
[16:04:12.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:12.483]                   ...future.rng), globalenv = if (FALSE) 
[16:04:12.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:12.483]                     ...future.globalenv.names))
[16:04:12.483]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:12.483]         }, condition = base::local({
[16:04:12.483]             c <- base::c
[16:04:12.483]             inherits <- base::inherits
[16:04:12.483]             invokeRestart <- base::invokeRestart
[16:04:12.483]             length <- base::length
[16:04:12.483]             list <- base::list
[16:04:12.483]             seq.int <- base::seq.int
[16:04:12.483]             signalCondition <- base::signalCondition
[16:04:12.483]             sys.calls <- base::sys.calls
[16:04:12.483]             `[[` <- base::`[[`
[16:04:12.483]             `+` <- base::`+`
[16:04:12.483]             `<<-` <- base::`<<-`
[16:04:12.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:12.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:12.483]                   3L)]
[16:04:12.483]             }
[16:04:12.483]             function(cond) {
[16:04:12.483]                 is_error <- inherits(cond, "error")
[16:04:12.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:12.483]                   NULL)
[16:04:12.483]                 if (is_error) {
[16:04:12.483]                   sessionInformation <- function() {
[16:04:12.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:12.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:12.483]                       search = base::search(), system = base::Sys.info())
[16:04:12.483]                   }
[16:04:12.483]                   ...future.conditions[[length(...future.conditions) + 
[16:04:12.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:12.483]                     cond$call), session = sessionInformation(), 
[16:04:12.483]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:12.483]                   signalCondition(cond)
[16:04:12.483]                 }
[16:04:12.483]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[16:04:12.483]                 "immediateCondition"))) {
[16:04:12.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:12.483]                   ...future.conditions[[length(...future.conditions) + 
[16:04:12.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:12.483]                   if (TRUE && !signal) {
[16:04:12.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:12.483]                     {
[16:04:12.483]                       inherits <- base::inherits
[16:04:12.483]                       invokeRestart <- base::invokeRestart
[16:04:12.483]                       is.null <- base::is.null
[16:04:12.483]                       muffled <- FALSE
[16:04:12.483]                       if (inherits(cond, "message")) {
[16:04:12.483]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:12.483]                         if (muffled) 
[16:04:12.483]                           invokeRestart("muffleMessage")
[16:04:12.483]                       }
[16:04:12.483]                       else if (inherits(cond, "warning")) {
[16:04:12.483]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:12.483]                         if (muffled) 
[16:04:12.483]                           invokeRestart("muffleWarning")
[16:04:12.483]                       }
[16:04:12.483]                       else if (inherits(cond, "condition")) {
[16:04:12.483]                         if (!is.null(pattern)) {
[16:04:12.483]                           computeRestarts <- base::computeRestarts
[16:04:12.483]                           grepl <- base::grepl
[16:04:12.483]                           restarts <- computeRestarts(cond)
[16:04:12.483]                           for (restart in restarts) {
[16:04:12.483]                             name <- restart$name
[16:04:12.483]                             if (is.null(name)) 
[16:04:12.483]                               next
[16:04:12.483]                             if (!grepl(pattern, name)) 
[16:04:12.483]                               next
[16:04:12.483]                             invokeRestart(restart)
[16:04:12.483]                             muffled <- TRUE
[16:04:12.483]                             break
[16:04:12.483]                           }
[16:04:12.483]                         }
[16:04:12.483]                       }
[16:04:12.483]                       invisible(muffled)
[16:04:12.483]                     }
[16:04:12.483]                     muffleCondition(cond, pattern = "^muffle")
[16:04:12.483]                   }
[16:04:12.483]                 }
[16:04:12.483]                 else {
[16:04:12.483]                   if (TRUE) {
[16:04:12.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:12.483]                     {
[16:04:12.483]                       inherits <- base::inherits
[16:04:12.483]                       invokeRestart <- base::invokeRestart
[16:04:12.483]                       is.null <- base::is.null
[16:04:12.483]                       muffled <- FALSE
[16:04:12.483]                       if (inherits(cond, "message")) {
[16:04:12.483]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:12.483]                         if (muffled) 
[16:04:12.483]                           invokeRestart("muffleMessage")
[16:04:12.483]                       }
[16:04:12.483]                       else if (inherits(cond, "warning")) {
[16:04:12.483]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:12.483]                         if (muffled) 
[16:04:12.483]                           invokeRestart("muffleWarning")
[16:04:12.483]                       }
[16:04:12.483]                       else if (inherits(cond, "condition")) {
[16:04:12.483]                         if (!is.null(pattern)) {
[16:04:12.483]                           computeRestarts <- base::computeRestarts
[16:04:12.483]                           grepl <- base::grepl
[16:04:12.483]                           restarts <- computeRestarts(cond)
[16:04:12.483]                           for (restart in restarts) {
[16:04:12.483]                             name <- restart$name
[16:04:12.483]                             if (is.null(name)) 
[16:04:12.483]                               next
[16:04:12.483]                             if (!grepl(pattern, name)) 
[16:04:12.483]                               next
[16:04:12.483]                             invokeRestart(restart)
[16:04:12.483]                             muffled <- TRUE
[16:04:12.483]                             break
[16:04:12.483]                           }
[16:04:12.483]                         }
[16:04:12.483]                       }
[16:04:12.483]                       invisible(muffled)
[16:04:12.483]                     }
[16:04:12.483]                     muffleCondition(cond, pattern = "^muffle")
[16:04:12.483]                   }
[16:04:12.483]                 }
[16:04:12.483]             }
[16:04:12.483]         }))
[16:04:12.483]     }, error = function(ex) {
[16:04:12.483]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:12.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:12.483]                 ...future.rng), started = ...future.startTime, 
[16:04:12.483]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:12.483]             version = "1.8"), class = "FutureResult")
[16:04:12.483]     }, finally = {
[16:04:12.483]         if (!identical(...future.workdir, getwd())) 
[16:04:12.483]             setwd(...future.workdir)
[16:04:12.483]         {
[16:04:12.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:12.483]                 ...future.oldOptions$nwarnings <- NULL
[16:04:12.483]             }
[16:04:12.483]             base::options(...future.oldOptions)
[16:04:12.483]             if (.Platform$OS.type == "windows") {
[16:04:12.483]                 old_names <- names(...future.oldEnvVars)
[16:04:12.483]                 envs <- base::Sys.getenv()
[16:04:12.483]                 names <- names(envs)
[16:04:12.483]                 common <- intersect(names, old_names)
[16:04:12.483]                 added <- setdiff(names, old_names)
[16:04:12.483]                 removed <- setdiff(old_names, names)
[16:04:12.483]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:12.483]                   envs[common]]
[16:04:12.483]                 NAMES <- toupper(changed)
[16:04:12.483]                 args <- list()
[16:04:12.483]                 for (kk in seq_along(NAMES)) {
[16:04:12.483]                   name <- changed[[kk]]
[16:04:12.483]                   NAME <- NAMES[[kk]]
[16:04:12.483]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:12.483]                     next
[16:04:12.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:12.483]                 }
[16:04:12.483]                 NAMES <- toupper(added)
[16:04:12.483]                 for (kk in seq_along(NAMES)) {
[16:04:12.483]                   name <- added[[kk]]
[16:04:12.483]                   NAME <- NAMES[[kk]]
[16:04:12.483]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:12.483]                     next
[16:04:12.483]                   args[[name]] <- ""
[16:04:12.483]                 }
[16:04:12.483]                 NAMES <- toupper(removed)
[16:04:12.483]                 for (kk in seq_along(NAMES)) {
[16:04:12.483]                   name <- removed[[kk]]
[16:04:12.483]                   NAME <- NAMES[[kk]]
[16:04:12.483]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:12.483]                     next
[16:04:12.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:12.483]                 }
[16:04:12.483]                 if (length(args) > 0) 
[16:04:12.483]                   base::do.call(base::Sys.setenv, args = args)
[16:04:12.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:12.483]             }
[16:04:12.483]             else {
[16:04:12.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:12.483]             }
[16:04:12.483]             {
[16:04:12.483]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:12.483]                   0L) {
[16:04:12.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:12.483]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:12.483]                   base::options(opts)
[16:04:12.483]                 }
[16:04:12.483]                 {
[16:04:12.483]                   {
[16:04:12.483]                     NULL
[16:04:12.483]                     RNGkind("Mersenne-Twister")
[16:04:12.483]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:12.483]                       inherits = FALSE)
[16:04:12.483]                   }
[16:04:12.483]                   options(future.plan = NULL)
[16:04:12.483]                   if (is.na(NA_character_)) 
[16:04:12.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:12.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:12.483]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:12.483]                   {
[16:04:12.483]                     future <- SequentialFuture(..., envir = envir)
[16:04:12.483]                     if (!future$lazy) 
[16:04:12.483]                       future <- run(future)
[16:04:12.483]                     invisible(future)
[16:04:12.483]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:12.483]                 }
[16:04:12.483]             }
[16:04:12.483]         }
[16:04:12.483]     })
[16:04:12.483]     if (FALSE) {
[16:04:12.483]         base::sink(type = "output", split = FALSE)
[16:04:12.483]         if (NA) {
[16:04:12.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:12.483]         }
[16:04:12.483]         else {
[16:04:12.483]             ...future.result["stdout"] <- base::list(NULL)
[16:04:12.483]         }
[16:04:12.483]         base::close(...future.stdout)
[16:04:12.483]         ...future.stdout <- NULL
[16:04:12.483]     }
[16:04:12.483]     ...future.result$conditions <- ...future.conditions
[16:04:12.483]     ...future.result$finished <- base::Sys.time()
[16:04:12.483]     ...future.result
[16:04:12.483] }
[16:04:12.485] assign_globals() ...
[16:04:12.485] List of 2
[16:04:12.485]  $ x:Classes 'listenv', 'environment' <environment: 0x557344960798> 
[16:04:12.485]  $ i: int 7
[16:04:12.485]  - attr(*, "where")=List of 2
[16:04:12.485]   ..$ x:<environment: R_EmptyEnv> 
[16:04:12.485]   ..$ i:<environment: R_EmptyEnv> 
[16:04:12.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:12.485]  - attr(*, "resolved")= logi FALSE
[16:04:12.485]  - attr(*, "total_size")= num 34264
[16:04:12.485]  - attr(*, "already-done")= logi TRUE
[16:04:12.491] - copied ‘x’ to environment
[16:04:12.491] - copied ‘i’ to environment
[16:04:12.491] assign_globals() ... done
[16:04:12.491] plan(): Setting new future strategy stack:
[16:04:12.491] List of future strategies:
[16:04:12.491] 1. sequential:
[16:04:12.491]    - args: function (..., envir = parent.frame())
[16:04:12.491]    - tweaked: FALSE
[16:04:12.491]    - call: NULL
[16:04:12.492] plan(): nbrOfWorkers() = 1
[16:04:12.573] plan(): Setting new future strategy stack:
[16:04:12.573] List of future strategies:
[16:04:12.573] 1. sequential:
[16:04:12.573]    - args: function (..., envir = parent.frame())
[16:04:12.573]    - tweaked: FALSE
[16:04:12.573]    - call: plan(sequential)
[16:04:12.574] plan(): nbrOfWorkers() = 1
[16:04:12.574] SequentialFuture started (and completed)
[16:04:12.574] - Launch lazy future ... done
[16:04:12.574] run() for ‘SequentialFuture’ ... done
[1] 8

> ## At this point x[1:7] have been calculated,
> ## but nothing beyond.
> 
> ## Let's get the 50:th number.
> print(x[[50]])
[16:04:12.574] run() for ‘Future’ ...
[16:04:12.575] - state: ‘created’
[16:04:12.575] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:12.575] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:12.575] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:12.575]   - Field: ‘label’
[16:04:12.575]   - Field: ‘local’
[16:04:12.575]   - Field: ‘owner’
[16:04:12.575]   - Field: ‘envir’
[16:04:12.576]   - Field: ‘packages’
[16:04:12.576]   - Field: ‘gc’
[16:04:12.576]   - Field: ‘conditions’
[16:04:12.576]   - Field: ‘expr’
[16:04:12.576]   - Field: ‘uuid’
[16:04:12.576]   - Field: ‘seed’
[16:04:12.576]   - Field: ‘version’
[16:04:12.576]   - Field: ‘result’
[16:04:12.576]   - Field: ‘asynchronous’
[16:04:12.576]   - Field: ‘calls’
[16:04:12.576]   - Field: ‘globals’
[16:04:12.577]   - Field: ‘stdout’
[16:04:12.577]   - Field: ‘earlySignal’
[16:04:12.577]   - Field: ‘lazy’
[16:04:12.577]   - Field: ‘state’
[16:04:12.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:12.577] - Launch lazy future ...
[16:04:12.577] Packages needed by the future expression (n = 0): <none>
[16:04:12.577] Packages needed by future strategies (n = 0): <none>
[16:04:12.578] {
[16:04:12.578]     {
[16:04:12.578]         {
[16:04:12.578]             ...future.startTime <- base::Sys.time()
[16:04:12.578]             {
[16:04:12.578]                 {
[16:04:12.578]                   {
[16:04:12.578]                     base::local({
[16:04:12.578]                       has_future <- base::requireNamespace("future", 
[16:04:12.578]                         quietly = TRUE)
[16:04:12.578]                       if (has_future) {
[16:04:12.578]                         ns <- base::getNamespace("future")
[16:04:12.578]                         version <- ns[[".package"]][["version"]]
[16:04:12.578]                         if (is.null(version)) 
[16:04:12.578]                           version <- utils::packageVersion("future")
[16:04:12.578]                       }
[16:04:12.578]                       else {
[16:04:12.578]                         version <- NULL
[16:04:12.578]                       }
[16:04:12.578]                       if (!has_future || version < "1.8.0") {
[16:04:12.578]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:12.578]                           "", base::R.version$version.string), 
[16:04:12.578]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:12.578]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:12.578]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:12.578]                             "release", "version")], collapse = " "), 
[16:04:12.578]                           hostname = base::Sys.info()[["nodename"]])
[16:04:12.578]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:12.578]                           info)
[16:04:12.578]                         info <- base::paste(info, collapse = "; ")
[16:04:12.578]                         if (!has_future) {
[16:04:12.578]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:12.578]                             info)
[16:04:12.578]                         }
[16:04:12.578]                         else {
[16:04:12.578]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:12.578]                             info, version)
[16:04:12.578]                         }
[16:04:12.578]                         base::stop(msg)
[16:04:12.578]                       }
[16:04:12.578]                     })
[16:04:12.578]                   }
[16:04:12.578]                   options(future.plan = NULL)
[16:04:12.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:12.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:12.578]                 }
[16:04:12.578]                 ...future.workdir <- getwd()
[16:04:12.578]             }
[16:04:12.578]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:12.578]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:12.578]         }
[16:04:12.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:12.578]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:12.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:12.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:12.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:12.578]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:12.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:12.578]             base::names(...future.oldOptions))
[16:04:12.578]     }
[16:04:12.578]     if (TRUE) {
[16:04:12.578]     }
[16:04:12.578]     else {
[16:04:12.578]         if (NA) {
[16:04:12.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:12.578]                 open = "w")
[16:04:12.578]         }
[16:04:12.578]         else {
[16:04:12.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:12.578]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:12.578]         }
[16:04:12.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:12.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:12.578]             base::sink(type = "output", split = FALSE)
[16:04:12.578]             base::close(...future.stdout)
[16:04:12.578]         }, add = TRUE)
[16:04:12.578]     }
[16:04:12.578]     ...future.frame <- base::sys.nframe()
[16:04:12.578]     ...future.conditions <- base::list()
[16:04:12.578]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:12.578]     if (FALSE) {
[16:04:12.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:12.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:12.578]     }
[16:04:12.578]     ...future.result <- base::tryCatch({
[16:04:12.578]         base::withCallingHandlers({
[16:04:12.578]             ...future.value <- base::withVisible(base::local({
[16:04:12.578]                 x[[i - 2]] + x[[i - 1]]
[16:04:12.578]             }))
[16:04:12.578]             future::FutureResult(value = ...future.value$value, 
[16:04:12.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:12.578]                   ...future.rng), globalenv = if (FALSE) 
[16:04:12.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:12.578]                     ...future.globalenv.names))
[16:04:12.578]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:12.578]         }, condition = base::local({
[16:04:12.578]             c <- base::c
[16:04:12.578]             inherits <- base::inherits
[16:04:12.578]             invokeRestart <- base::invokeRestart
[16:04:12.578]             length <- base::length
[16:04:12.578]             list <- base::list
[16:04:12.578]             seq.int <- base::seq.int
[16:04:12.578]             signalCondition <- base::signalCondition
[16:04:12.578]             sys.calls <- base::sys.calls
[16:04:12.578]             `[[` <- base::`[[`
[16:04:12.578]             `+` <- base::`+`
[16:04:12.578]             `<<-` <- base::`<<-`
[16:04:12.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:12.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:12.578]                   3L)]
[16:04:12.578]             }
[16:04:12.578]             function(cond) {
[16:04:12.578]                 is_error <- inherits(cond, "error")
[16:04:12.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:12.578]                   NULL)
[16:04:12.578]                 if (is_error) {
[16:04:12.578]                   sessionInformation <- function() {
[16:04:12.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:12.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:12.578]                       search = base::search(), system = base::Sys.info())
[16:04:12.578]                   }
[16:04:12.578]                   ...future.conditions[[length(...future.conditions) + 
[16:04:12.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:12.578]                     cond$call), session = sessionInformation(), 
[16:04:12.578]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:12.578]                   signalCondition(cond)
[16:04:12.578]                 }
[16:04:12.578]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[16:04:12.578]                 "immediateCondition"))) {
[16:04:12.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:12.578]                   ...future.conditions[[length(...future.conditions) + 
[16:04:12.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:12.578]                   if (TRUE && !signal) {
[16:04:12.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:12.578]                     {
[16:04:12.578]                       inherits <- base::inherits
[16:04:12.578]                       invokeRestart <- base::invokeRestart
[16:04:12.578]                       is.null <- base::is.null
[16:04:12.578]                       muffled <- FALSE
[16:04:12.578]                       if (inherits(cond, "message")) {
[16:04:12.578]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:12.578]                         if (muffled) 
[16:04:12.578]                           invokeRestart("muffleMessage")
[16:04:12.578]                       }
[16:04:12.578]                       else if (inherits(cond, "warning")) {
[16:04:12.578]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:12.578]                         if (muffled) 
[16:04:12.578]                           invokeRestart("muffleWarning")
[16:04:12.578]                       }
[16:04:12.578]                       else if (inherits(cond, "condition")) {
[16:04:12.578]                         if (!is.null(pattern)) {
[16:04:12.578]                           computeRestarts <- base::computeRestarts
[16:04:12.578]                           grepl <- base::grepl
[16:04:12.578]                           restarts <- computeRestarts(cond)
[16:04:12.578]                           for (restart in restarts) {
[16:04:12.578]                             name <- restart$name
[16:04:12.578]                             if (is.null(name)) 
[16:04:12.578]                               next
[16:04:12.578]                             if (!grepl(pattern, name)) 
[16:04:12.578]                               next
[16:04:12.578]                             invokeRestart(restart)
[16:04:12.578]                             muffled <- TRUE
[16:04:12.578]                             break
[16:04:12.578]                           }
[16:04:12.578]                         }
[16:04:12.578]                       }
[16:04:12.578]                       invisible(muffled)
[16:04:12.578]                     }
[16:04:12.578]                     muffleCondition(cond, pattern = "^muffle")
[16:04:12.578]                   }
[16:04:12.578]                 }
[16:04:12.578]                 else {
[16:04:12.578]                   if (TRUE) {
[16:04:12.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:12.578]                     {
[16:04:12.578]                       inherits <- base::inherits
[16:04:12.578]                       invokeRestart <- base::invokeRestart
[16:04:12.578]                       is.null <- base::is.null
[16:04:12.578]                       muffled <- FALSE
[16:04:12.578]                       if (inherits(cond, "message")) {
[16:04:12.578]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:12.578]                         if (muffled) 
[16:04:12.578]                           invokeRestart("muffleMessage")
[16:04:12.578]                       }
[16:04:12.578]                       else if (inherits(cond, "warning")) {
[16:04:12.578]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:12.578]                         if (muffled) 
[16:04:12.578]                           invokeRestart("muffleWarning")
[16:04:12.578]                       }
[16:04:12.578]                       else if (inherits(cond, "condition")) {
[16:04:12.578]                         if (!is.null(pattern)) {
[16:04:12.578]                           computeRestarts <- base::computeRestarts
[16:04:12.578]                           grepl <- base::grepl
[16:04:12.578]                           restarts <- computeRestarts(cond)
[16:04:12.578]                           for (restart in restarts) {
[16:04:12.578]                             name <- restart$name
[16:04:12.578]                             if (is.null(name)) 
[16:04:12.578]                               next
[16:04:12.578]                             if (!grepl(pattern, name)) 
[16:04:12.578]                               next
[16:04:12.578]                             invokeRestart(restart)
[16:04:12.578]                             muffled <- TRUE
[16:04:12.578]                             break
[16:04:12.578]                           }
[16:04:12.578]                         }
[16:04:12.578]                       }
[16:04:12.578]                       invisible(muffled)
[16:04:12.578]                     }
[16:04:12.578]                     muffleCondition(cond, pattern = "^muffle")
[16:04:12.578]                   }
[16:04:12.578]                 }
[16:04:12.578]             }
[16:04:12.578]         }))
[16:04:12.578]     }, error = function(ex) {
[16:04:12.578]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:12.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:12.578]                 ...future.rng), started = ...future.startTime, 
[16:04:12.578]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:12.578]             version = "1.8"), class = "FutureResult")
[16:04:12.578]     }, finally = {
[16:04:12.578]         if (!identical(...future.workdir, getwd())) 
[16:04:12.578]             setwd(...future.workdir)
[16:04:12.578]         {
[16:04:12.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:12.578]                 ...future.oldOptions$nwarnings <- NULL
[16:04:12.578]             }
[16:04:12.578]             base::options(...future.oldOptions)
[16:04:12.578]             if (.Platform$OS.type == "windows") {
[16:04:12.578]                 old_names <- names(...future.oldEnvVars)
[16:04:12.578]                 envs <- base::Sys.getenv()
[16:04:12.578]                 names <- names(envs)
[16:04:12.578]                 common <- intersect(names, old_names)
[16:04:12.578]                 added <- setdiff(names, old_names)
[16:04:12.578]                 removed <- setdiff(old_names, names)
[16:04:12.578]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:12.578]                   envs[common]]
[16:04:12.578]                 NAMES <- toupper(changed)
[16:04:12.578]                 args <- list()
[16:04:12.578]                 for (kk in seq_along(NAMES)) {
[16:04:12.578]                   name <- changed[[kk]]
[16:04:12.578]                   NAME <- NAMES[[kk]]
[16:04:12.578]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:12.578]                     next
[16:04:12.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:12.578]                 }
[16:04:12.578]                 NAMES <- toupper(added)
[16:04:12.578]                 for (kk in seq_along(NAMES)) {
[16:04:12.578]                   name <- added[[kk]]
[16:04:12.578]                   NAME <- NAMES[[kk]]
[16:04:12.578]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:12.578]                     next
[16:04:12.578]                   args[[name]] <- ""
[16:04:12.578]                 }
[16:04:12.578]                 NAMES <- toupper(removed)
[16:04:12.578]                 for (kk in seq_along(NAMES)) {
[16:04:12.578]                   name <- removed[[kk]]
[16:04:12.578]                   NAME <- NAMES[[kk]]
[16:04:12.578]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:12.578]                     next
[16:04:12.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:12.578]                 }
[16:04:12.578]                 if (length(args) > 0) 
[16:04:12.578]                   base::do.call(base::Sys.setenv, args = args)
[16:04:12.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:12.578]             }
[16:04:12.578]             else {
[16:04:12.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:12.578]             }
[16:04:12.578]             {
[16:04:12.578]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:12.578]                   0L) {
[16:04:12.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:12.578]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:12.578]                   base::options(opts)
[16:04:12.578]                 }
[16:04:12.578]                 {
[16:04:12.578]                   {
[16:04:12.578]                     NULL
[16:04:12.578]                     RNGkind("Mersenne-Twister")
[16:04:12.578]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:12.578]                       inherits = FALSE)
[16:04:12.578]                   }
[16:04:12.578]                   options(future.plan = NULL)
[16:04:12.578]                   if (is.na(NA_character_)) 
[16:04:12.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:12.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:12.578]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:12.578]                   {
[16:04:12.578]                     future <- SequentialFuture(..., envir = envir)
[16:04:12.578]                     if (!future$lazy) 
[16:04:12.578]                       future <- run(future)
[16:04:12.578]                     invisible(future)
[16:04:12.578]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:12.578]                 }
[16:04:12.578]             }
[16:04:12.578]         }
[16:04:12.578]     })
[16:04:12.578]     if (FALSE) {
[16:04:12.578]         base::sink(type = "output", split = FALSE)
[16:04:12.578]         if (NA) {
[16:04:12.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:12.578]         }
[16:04:12.578]         else {
[16:04:12.578]             ...future.result["stdout"] <- base::list(NULL)
[16:04:12.578]         }
[16:04:12.578]         base::close(...future.stdout)
[16:04:12.578]         ...future.stdout <- NULL
[16:04:12.578]     }
[16:04:12.578]     ...future.result$conditions <- ...future.conditions
[16:04:12.578]     ...future.result$finished <- base::Sys.time()
[16:04:12.578]     ...future.result
[16:04:12.578] }
[16:04:12.579] assign_globals() ...
[16:04:12.579] List of 2
[16:04:12.579]  $ x:Classes 'listenv', 'environment' <environment: 0x557344960798> 
[16:04:12.579]  $ i: int 50
[16:04:12.579]  - attr(*, "where")=List of 2
[16:04:12.579]   ..$ x:<environment: R_EmptyEnv> 
[16:04:12.579]   ..$ i:<environment: R_EmptyEnv> 
[16:04:12.579]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:12.579]  - attr(*, "resolved")= logi FALSE
[16:04:12.579]  - attr(*, "total_size")= num 402000
[16:04:12.579]  - attr(*, "already-done")= logi TRUE
[16:04:12.582] - copied ‘x’ to environment
[16:04:12.582] - copied ‘i’ to environment
[16:04:12.583] assign_globals() ... done
[16:04:12.583] plan(): Setting new future strategy stack:
[16:04:12.583] List of future strategies:
[16:04:12.583] 1. sequential:
[16:04:12.583]    - args: function (..., envir = parent.frame())
[16:04:12.583]    - tweaked: FALSE
[16:04:12.583]    - call: NULL
[16:04:12.583] plan(): nbrOfWorkers() = 1
[16:04:13.452] plan(): Setting new future strategy stack:
[16:04:13.452] List of future strategies:
[16:04:13.452] 1. sequential:
[16:04:13.452]    - args: function (..., envir = parent.frame())
[16:04:13.452]    - tweaked: FALSE
[16:04:13.452]    - call: plan(sequential)
[16:04:13.453] plan(): nbrOfWorkers() = 1
[16:04:13.453] SequentialFuture started (and completed)
[16:04:13.453] - Launch lazy future ... done
[16:04:13.453] run() for ‘SequentialFuture’ ... done
[1] 7778742049

> ## Reset plan
> plan(oplan)
[16:04:13.454] plan(): Setting new future strategy stack:
[16:04:13.454] List of future strategies:
[16:04:13.454] 1. sequential:
[16:04:13.454]    - args: function (..., envir = parent.frame())
[16:04:13.454]    - tweaked: FALSE
[16:04:13.454]    - call: future::plan("sequential")
[16:04:13.454] plan(): nbrOfWorkers() = 1
> message("*** Fibonacci demo of the 'future' package ... DONE")
*** Fibonacci demo of the 'future' package ... DONE
> 
> 
> message("*** Mandelbrot demo of the 'future' package ...")
*** Mandelbrot demo of the 'future' package ...
> if (getRversion() >= "3.2.0" && !isWin32) {
+   options(future.demo.mandelbrot.nrow = 2L)
+   options(future.demo.mandelbrot.resolution = 50L)
+   options(future.demo.mandelbrot.delay = FALSE)
+   
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+   
+     for (strategy in supportedStrategies(cores)) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+       demo("mandelbrot", package = "future", ask = FALSE)
+       message(sprintf("- plan('%s') ... DONE", strategy))
+     }
+   
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } else {
+   message(" - This demo requires R (>= 3.2.0). Skipping test. (Skipping also on Win32 i386 for speed)")
+ }
Testing with 1 cores ...
- plan('sequential') ...
[16:04:13.460] plan(): Setting new future strategy stack:
[16:04:13.460] List of future strategies:
[16:04:13.460] 1. sequential:
[16:04:13.460]    - args: function (..., envir = parent.frame())
[16:04:13.460]    - tweaked: FALSE
[16:04:13.460]    - call: plan(strategy)
[16:04:13.461] plan(): nbrOfWorkers() = 1


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 1 2 3 4

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[16:04:13.491] getGlobalsAndPackages() ...
[16:04:13.491] Searching for globals...
[16:04:13.496] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:04:13.496] Searching for globals ... DONE
[16:04:13.496] Resolving globals: FALSE
[16:04:13.496] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:04:13.497] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:04:13.497] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:04:13.497] - packages: [1] ‘future’
[16:04:13.497] getGlobalsAndPackages() ... DONE
 2[16:04:13.504] getGlobalsAndPackages() ...
[16:04:13.504] Searching for globals...
[16:04:13.507] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:04:13.507] Searching for globals ... DONE
[16:04:13.507] Resolving globals: FALSE
[16:04:13.508] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:04:13.508] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:04:13.508] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:04:13.508] - packages: [1] ‘future’
[16:04:13.508] getGlobalsAndPackages() ... DONE
 3[16:04:13.509] getGlobalsAndPackages() ...
[16:04:13.509] Searching for globals...
[16:04:13.512] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:04:13.512] Searching for globals ... DONE
[16:04:13.512] Resolving globals: FALSE
[16:04:13.513] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:04:13.513] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:04:13.513] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:04:13.514] - packages: [1] ‘future’
[16:04:13.514] getGlobalsAndPackages() ... DONE
 4[16:04:13.514] getGlobalsAndPackages() ...
[16:04:13.514] Searching for globals...
[16:04:13.517] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:04:13.517] Searching for globals ... DONE
[16:04:13.518] Resolving globals: FALSE
[16:04:13.518] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:04:13.518] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:04:13.519] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:04:13.519] - packages: [1] ‘future’
[16:04:13.519] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[16:04:13.528] resolved() for ‘Future’ ...
[16:04:13.528] - state: ‘created’
[16:04:13.528] - run: TRUE
[16:04:13.528] - run() ...
[16:04:13.528] run() for ‘Future’ ...
[16:04:13.528] - state: ‘created’
[16:04:13.528] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:13.529] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:13.529] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:13.529]   - Field: ‘label’
[16:04:13.529]   - Field: ‘local’
[16:04:13.529]   - Field: ‘owner’
[16:04:13.529]   - Field: ‘envir’
[16:04:13.529]   - Field: ‘packages’
[16:04:13.529]   - Field: ‘gc’
[16:04:13.529]   - Field: ‘conditions’
[16:04:13.529]   - Field: ‘expr’
[16:04:13.530]   - Field: ‘uuid’
[16:04:13.530]   - Field: ‘seed’
[16:04:13.530]   - Field: ‘version’
[16:04:13.530]   - Field: ‘result’
[16:04:13.530]   - Field: ‘asynchronous’
[16:04:13.530]   - Field: ‘calls’
[16:04:13.530]   - Field: ‘globals’
[16:04:13.530]   - Field: ‘stdout’
[16:04:13.530]   - Field: ‘earlySignal’
[16:04:13.530]   - Field: ‘lazy’
[16:04:13.530]   - Field: ‘state’
[16:04:13.531] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:13.531] - Launch lazy future ...
[16:04:13.531] Packages needed by the future expression (n = 1): ‘future’
[16:04:13.531] Packages needed by future strategies (n = 0): <none>
[16:04:13.531] {
[16:04:13.531]     {
[16:04:13.531]         {
[16:04:13.531]             ...future.startTime <- base::Sys.time()
[16:04:13.531]             {
[16:04:13.531]                 {
[16:04:13.531]                   {
[16:04:13.531]                     {
[16:04:13.531]                       base::local({
[16:04:13.531]                         has_future <- base::requireNamespace("future", 
[16:04:13.531]                           quietly = TRUE)
[16:04:13.531]                         if (has_future) {
[16:04:13.531]                           ns <- base::getNamespace("future")
[16:04:13.531]                           version <- ns[[".package"]][["version"]]
[16:04:13.531]                           if (is.null(version)) 
[16:04:13.531]                             version <- utils::packageVersion("future")
[16:04:13.531]                         }
[16:04:13.531]                         else {
[16:04:13.531]                           version <- NULL
[16:04:13.531]                         }
[16:04:13.531]                         if (!has_future || version < "1.8.0") {
[16:04:13.531]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:13.531]                             "", base::R.version$version.string), 
[16:04:13.531]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:13.531]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:13.531]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:13.531]                               "release", "version")], collapse = " "), 
[16:04:13.531]                             hostname = base::Sys.info()[["nodename"]])
[16:04:13.531]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:13.531]                             info)
[16:04:13.531]                           info <- base::paste(info, collapse = "; ")
[16:04:13.531]                           if (!has_future) {
[16:04:13.531]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:13.531]                               info)
[16:04:13.531]                           }
[16:04:13.531]                           else {
[16:04:13.531]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:13.531]                               info, version)
[16:04:13.531]                           }
[16:04:13.531]                           base::stop(msg)
[16:04:13.531]                         }
[16:04:13.531]                       })
[16:04:13.531]                     }
[16:04:13.531]                     base::local({
[16:04:13.531]                       for (pkg in "future") {
[16:04:13.531]                         base::loadNamespace(pkg)
[16:04:13.531]                         base::library(pkg, character.only = TRUE)
[16:04:13.531]                       }
[16:04:13.531]                     })
[16:04:13.531]                   }
[16:04:13.531]                   options(future.plan = NULL)
[16:04:13.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:13.531]                 }
[16:04:13.531]                 ...future.workdir <- getwd()
[16:04:13.531]             }
[16:04:13.531]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:13.531]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:13.531]         }
[16:04:13.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:13.531]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:13.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:13.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:13.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:13.531]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:13.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:13.531]             base::names(...future.oldOptions))
[16:04:13.531]     }
[16:04:13.531]     if (FALSE) {
[16:04:13.531]     }
[16:04:13.531]     else {
[16:04:13.531]         if (TRUE) {
[16:04:13.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:13.531]                 open = "w")
[16:04:13.531]         }
[16:04:13.531]         else {
[16:04:13.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:13.531]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:13.531]         }
[16:04:13.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:13.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:13.531]             base::sink(type = "output", split = FALSE)
[16:04:13.531]             base::close(...future.stdout)
[16:04:13.531]         }, add = TRUE)
[16:04:13.531]     }
[16:04:13.531]     ...future.frame <- base::sys.nframe()
[16:04:13.531]     ...future.conditions <- base::list()
[16:04:13.531]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:13.531]     if (FALSE) {
[16:04:13.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:13.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:13.531]     }
[16:04:13.531]     ...future.result <- base::tryCatch({
[16:04:13.531]         base::withCallingHandlers({
[16:04:13.531]             ...future.value <- base::withVisible(base::local({
[16:04:13.531]                 message(sprintf("Calculating tile #%d of %d ...", 
[16:04:13.531]                   ii, n), appendLF = FALSE)
[16:04:13.531]                 fit <- mandelbrot(C)
[16:04:13.531]                 delay(fit)
[16:04:13.531]                 message(" done")
[16:04:13.531]                 fit
[16:04:13.531]             }))
[16:04:13.531]             future::FutureResult(value = ...future.value$value, 
[16:04:13.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.531]                   ...future.rng), globalenv = if (FALSE) 
[16:04:13.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:13.531]                     ...future.globalenv.names))
[16:04:13.531]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:13.531]         }, condition = base::local({
[16:04:13.531]             c <- base::c
[16:04:13.531]             inherits <- base::inherits
[16:04:13.531]             invokeRestart <- base::invokeRestart
[16:04:13.531]             length <- base::length
[16:04:13.531]             list <- base::list
[16:04:13.531]             seq.int <- base::seq.int
[16:04:13.531]             signalCondition <- base::signalCondition
[16:04:13.531]             sys.calls <- base::sys.calls
[16:04:13.531]             `[[` <- base::`[[`
[16:04:13.531]             `+` <- base::`+`
[16:04:13.531]             `<<-` <- base::`<<-`
[16:04:13.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:13.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:13.531]                   3L)]
[16:04:13.531]             }
[16:04:13.531]             function(cond) {
[16:04:13.531]                 is_error <- inherits(cond, "error")
[16:04:13.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:13.531]                   NULL)
[16:04:13.531]                 if (is_error) {
[16:04:13.531]                   sessionInformation <- function() {
[16:04:13.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:13.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:13.531]                       search = base::search(), system = base::Sys.info())
[16:04:13.531]                   }
[16:04:13.531]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:13.531]                     cond$call), session = sessionInformation(), 
[16:04:13.531]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:13.531]                   signalCondition(cond)
[16:04:13.531]                 }
[16:04:13.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:13.531]                 "immediateCondition"))) {
[16:04:13.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:13.531]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:13.531]                   if (TRUE && !signal) {
[16:04:13.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.531]                     {
[16:04:13.531]                       inherits <- base::inherits
[16:04:13.531]                       invokeRestart <- base::invokeRestart
[16:04:13.531]                       is.null <- base::is.null
[16:04:13.531]                       muffled <- FALSE
[16:04:13.531]                       if (inherits(cond, "message")) {
[16:04:13.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.531]                         if (muffled) 
[16:04:13.531]                           invokeRestart("muffleMessage")
[16:04:13.531]                       }
[16:04:13.531]                       else if (inherits(cond, "warning")) {
[16:04:13.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.531]                         if (muffled) 
[16:04:13.531]                           invokeRestart("muffleWarning")
[16:04:13.531]                       }
[16:04:13.531]                       else if (inherits(cond, "condition")) {
[16:04:13.531]                         if (!is.null(pattern)) {
[16:04:13.531]                           computeRestarts <- base::computeRestarts
[16:04:13.531]                           grepl <- base::grepl
[16:04:13.531]                           restarts <- computeRestarts(cond)
[16:04:13.531]                           for (restart in restarts) {
[16:04:13.531]                             name <- restart$name
[16:04:13.531]                             if (is.null(name)) 
[16:04:13.531]                               next
[16:04:13.531]                             if (!grepl(pattern, name)) 
[16:04:13.531]                               next
[16:04:13.531]                             invokeRestart(restart)
[16:04:13.531]                             muffled <- TRUE
[16:04:13.531]                             break
[16:04:13.531]                           }
[16:04:13.531]                         }
[16:04:13.531]                       }
[16:04:13.531]                       invisible(muffled)
[16:04:13.531]                     }
[16:04:13.531]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.531]                   }
[16:04:13.531]                 }
[16:04:13.531]                 else {
[16:04:13.531]                   if (TRUE) {
[16:04:13.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.531]                     {
[16:04:13.531]                       inherits <- base::inherits
[16:04:13.531]                       invokeRestart <- base::invokeRestart
[16:04:13.531]                       is.null <- base::is.null
[16:04:13.531]                       muffled <- FALSE
[16:04:13.531]                       if (inherits(cond, "message")) {
[16:04:13.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.531]                         if (muffled) 
[16:04:13.531]                           invokeRestart("muffleMessage")
[16:04:13.531]                       }
[16:04:13.531]                       else if (inherits(cond, "warning")) {
[16:04:13.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.531]                         if (muffled) 
[16:04:13.531]                           invokeRestart("muffleWarning")
[16:04:13.531]                       }
[16:04:13.531]                       else if (inherits(cond, "condition")) {
[16:04:13.531]                         if (!is.null(pattern)) {
[16:04:13.531]                           computeRestarts <- base::computeRestarts
[16:04:13.531]                           grepl <- base::grepl
[16:04:13.531]                           restarts <- computeRestarts(cond)
[16:04:13.531]                           for (restart in restarts) {
[16:04:13.531]                             name <- restart$name
[16:04:13.531]                             if (is.null(name)) 
[16:04:13.531]                               next
[16:04:13.531]                             if (!grepl(pattern, name)) 
[16:04:13.531]                               next
[16:04:13.531]                             invokeRestart(restart)
[16:04:13.531]                             muffled <- TRUE
[16:04:13.531]                             break
[16:04:13.531]                           }
[16:04:13.531]                         }
[16:04:13.531]                       }
[16:04:13.531]                       invisible(muffled)
[16:04:13.531]                     }
[16:04:13.531]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.531]                   }
[16:04:13.531]                 }
[16:04:13.531]             }
[16:04:13.531]         }))
[16:04:13.531]     }, error = function(ex) {
[16:04:13.531]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:13.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.531]                 ...future.rng), started = ...future.startTime, 
[16:04:13.531]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:13.531]             version = "1.8"), class = "FutureResult")
[16:04:13.531]     }, finally = {
[16:04:13.531]         if (!identical(...future.workdir, getwd())) 
[16:04:13.531]             setwd(...future.workdir)
[16:04:13.531]         {
[16:04:13.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:13.531]                 ...future.oldOptions$nwarnings <- NULL
[16:04:13.531]             }
[16:04:13.531]             base::options(...future.oldOptions)
[16:04:13.531]             if (.Platform$OS.type == "windows") {
[16:04:13.531]                 old_names <- names(...future.oldEnvVars)
[16:04:13.531]                 envs <- base::Sys.getenv()
[16:04:13.531]                 names <- names(envs)
[16:04:13.531]                 common <- intersect(names, old_names)
[16:04:13.531]                 added <- setdiff(names, old_names)
[16:04:13.531]                 removed <- setdiff(old_names, names)
[16:04:13.531]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:13.531]                   envs[common]]
[16:04:13.531]                 NAMES <- toupper(changed)
[16:04:13.531]                 args <- list()
[16:04:13.531]                 for (kk in seq_along(NAMES)) {
[16:04:13.531]                   name <- changed[[kk]]
[16:04:13.531]                   NAME <- NAMES[[kk]]
[16:04:13.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.531]                     next
[16:04:13.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.531]                 }
[16:04:13.531]                 NAMES <- toupper(added)
[16:04:13.531]                 for (kk in seq_along(NAMES)) {
[16:04:13.531]                   name <- added[[kk]]
[16:04:13.531]                   NAME <- NAMES[[kk]]
[16:04:13.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.531]                     next
[16:04:13.531]                   args[[name]] <- ""
[16:04:13.531]                 }
[16:04:13.531]                 NAMES <- toupper(removed)
[16:04:13.531]                 for (kk in seq_along(NAMES)) {
[16:04:13.531]                   name <- removed[[kk]]
[16:04:13.531]                   NAME <- NAMES[[kk]]
[16:04:13.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.531]                     next
[16:04:13.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.531]                 }
[16:04:13.531]                 if (length(args) > 0) 
[16:04:13.531]                   base::do.call(base::Sys.setenv, args = args)
[16:04:13.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:13.531]             }
[16:04:13.531]             else {
[16:04:13.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:13.531]             }
[16:04:13.531]             {
[16:04:13.531]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:13.531]                   0L) {
[16:04:13.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:13.531]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:13.531]                   base::options(opts)
[16:04:13.531]                 }
[16:04:13.531]                 {
[16:04:13.531]                   {
[16:04:13.531]                     NULL
[16:04:13.531]                     RNGkind("Mersenne-Twister")
[16:04:13.531]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:13.531]                       inherits = FALSE)
[16:04:13.531]                   }
[16:04:13.531]                   options(future.plan = NULL)
[16:04:13.531]                   if (is.na(NA_character_)) 
[16:04:13.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:13.531]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:13.531]                   {
[16:04:13.531]                     future <- SequentialFuture(..., envir = envir)
[16:04:13.531]                     if (!future$lazy) 
[16:04:13.531]                       future <- run(future)
[16:04:13.531]                     invisible(future)
[16:04:13.531]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:13.531]                 }
[16:04:13.531]             }
[16:04:13.531]         }
[16:04:13.531]     })
[16:04:13.531]     if (TRUE) {
[16:04:13.531]         base::sink(type = "output", split = FALSE)
[16:04:13.531]         if (TRUE) {
[16:04:13.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:13.531]         }
[16:04:13.531]         else {
[16:04:13.531]             ...future.result["stdout"] <- base::list(NULL)
[16:04:13.531]         }
[16:04:13.531]         base::close(...future.stdout)
[16:04:13.531]         ...future.stdout <- NULL
[16:04:13.531]     }
[16:04:13.531]     ...future.result$conditions <- ...future.conditions
[16:04:13.531]     ...future.result$finished <- base::Sys.time()
[16:04:13.531]     ...future.result
[16:04:13.531] }
[16:04:13.533] assign_globals() ...
[16:04:13.533] List of 4
[16:04:13.533]  $ ii   : int 1
[16:04:13.533]  $ n    : int 4
[16:04:13.533]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[16:04:13.533]   ..- attr(*, "region")=List of 2
[16:04:13.533]   .. ..$ xrange: num [1:2] -2.25 -0.781
[16:04:13.533]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[16:04:13.533]   ..- attr(*, "tile")= int [1:2] 1 1
[16:04:13.533]  $ delay:function (counts)  
[16:04:13.533]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:04:13.533]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x5573463027a8> 
[16:04:13.533]  - attr(*, "where")=List of 4
[16:04:13.533]   ..$ ii   :<environment: R_EmptyEnv> 
[16:04:13.533]   ..$ n    :<environment: R_EmptyEnv> 
[16:04:13.533]   ..$ C    :<environment: R_EmptyEnv> 
[16:04:13.533]   ..$ delay:<environment: R_EmptyEnv> 
[16:04:13.533]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:13.533]  - attr(*, "resolved")= logi FALSE
[16:04:13.533]  - attr(*, "total_size")= num 14584
[16:04:13.533]  - attr(*, "already-done")= logi TRUE
[16:04:13.539] - copied ‘ii’ to environment
[16:04:13.539] - copied ‘n’ to environment
[16:04:13.540] - copied ‘C’ to environment
[16:04:13.540] - reassign environment for ‘delay’
[16:04:13.540] - copied ‘delay’ to environment
[16:04:13.540] assign_globals() ... done
[16:04:13.540] plan(): Setting new future strategy stack:
[16:04:13.540] List of future strategies:
[16:04:13.540] 1. sequential:
[16:04:13.540]    - args: function (..., envir = parent.frame())
[16:04:13.540]    - tweaked: FALSE
[16:04:13.540]    - call: NULL
[16:04:13.541] plan(): nbrOfWorkers() = 1
[16:04:13.557] plan(): Setting new future strategy stack:
[16:04:13.557] List of future strategies:
[16:04:13.557] 1. sequential:
[16:04:13.557]    - args: function (..., envir = parent.frame())
[16:04:13.557]    - tweaked: FALSE
[16:04:13.557]    - call: plan(strategy)
[16:04:13.557] plan(): nbrOfWorkers() = 1
[16:04:13.558] SequentialFuture started (and completed)
[16:04:13.558] signalConditions() ...
[16:04:13.558]  - include = ‘immediateCondition’
[16:04:13.558]  - exclude = 
[16:04:13.558]  - resignal = FALSE
[16:04:13.558]  - Number of conditions: 2
[16:04:13.558] signalConditions() ... done
[16:04:13.558] - Launch lazy future ... done
[16:04:13.558] run() for ‘SequentialFuture’ ... done
[16:04:13.559] - run() ... done
[16:04:13.559] - resolved() ...
[16:04:13.559] resolved() for ‘SequentialFuture’ ...
[16:04:13.559] - state: ‘finished’
[16:04:13.559] - run: TRUE
[16:04:13.559] - result: ‘FutureResult’
[16:04:13.559] resolved() for ‘SequentialFuture’ ... done
[16:04:13.559] - resolved: TRUE
[16:04:13.559] - resolved() ... done
[16:04:13.559] resolved() for ‘SequentialFuture’ ... done
Plotting tile #1 of 4 ...
[16:04:13.560] signalConditions() ...
[16:04:13.560]  - include = ‘immediateCondition’
[16:04:13.560]  - exclude = 
[16:04:13.560]  - resignal = FALSE
[16:04:13.560]  - Number of conditions: 2
[16:04:13.560] signalConditions() ... done
[16:04:13.560] Future state: ‘finished’
[16:04:13.560] signalConditions() ...
[16:04:13.560]  - include = ‘condition’
[16:04:13.560]  - exclude = ‘immediateCondition’
[16:04:13.560]  - resignal = TRUE
[16:04:13.560]  - Number of conditions: 2
[16:04:13.561]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[16:04:13.561]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:04:13.561] signalConditions() ... done
[16:04:13.562] resolved() for ‘Future’ ...
[16:04:13.562] - state: ‘created’
[16:04:13.563] - run: TRUE
[16:04:13.563] - run() ...
[16:04:13.563] run() for ‘Future’ ...
[16:04:13.563] - state: ‘created’
[16:04:13.563] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:13.563] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:13.563] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:13.564]   - Field: ‘label’
[16:04:13.564]   - Field: ‘local’
[16:04:13.564]   - Field: ‘owner’
[16:04:13.564]   - Field: ‘envir’
[16:04:13.564]   - Field: ‘packages’
[16:04:13.564]   - Field: ‘gc’
[16:04:13.564]   - Field: ‘conditions’
[16:04:13.564]   - Field: ‘expr’
[16:04:13.564]   - Field: ‘uuid’
[16:04:13.564]   - Field: ‘seed’
[16:04:13.565]   - Field: ‘version’
[16:04:13.565]   - Field: ‘result’
[16:04:13.565]   - Field: ‘asynchronous’
[16:04:13.565]   - Field: ‘calls’
[16:04:13.565]   - Field: ‘globals’
[16:04:13.565]   - Field: ‘stdout’
[16:04:13.565]   - Field: ‘earlySignal’
[16:04:13.565]   - Field: ‘lazy’
[16:04:13.565]   - Field: ‘state’
[16:04:13.565] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:13.565] - Launch lazy future ...
[16:04:13.566] Packages needed by the future expression (n = 1): ‘future’
[16:04:13.566] Packages needed by future strategies (n = 0): <none>
[16:04:13.566] {
[16:04:13.566]     {
[16:04:13.566]         {
[16:04:13.566]             ...future.startTime <- base::Sys.time()
[16:04:13.566]             {
[16:04:13.566]                 {
[16:04:13.566]                   {
[16:04:13.566]                     {
[16:04:13.566]                       base::local({
[16:04:13.566]                         has_future <- base::requireNamespace("future", 
[16:04:13.566]                           quietly = TRUE)
[16:04:13.566]                         if (has_future) {
[16:04:13.566]                           ns <- base::getNamespace("future")
[16:04:13.566]                           version <- ns[[".package"]][["version"]]
[16:04:13.566]                           if (is.null(version)) 
[16:04:13.566]                             version <- utils::packageVersion("future")
[16:04:13.566]                         }
[16:04:13.566]                         else {
[16:04:13.566]                           version <- NULL
[16:04:13.566]                         }
[16:04:13.566]                         if (!has_future || version < "1.8.0") {
[16:04:13.566]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:13.566]                             "", base::R.version$version.string), 
[16:04:13.566]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:13.566]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:13.566]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:13.566]                               "release", "version")], collapse = " "), 
[16:04:13.566]                             hostname = base::Sys.info()[["nodename"]])
[16:04:13.566]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:13.566]                             info)
[16:04:13.566]                           info <- base::paste(info, collapse = "; ")
[16:04:13.566]                           if (!has_future) {
[16:04:13.566]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:13.566]                               info)
[16:04:13.566]                           }
[16:04:13.566]                           else {
[16:04:13.566]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:13.566]                               info, version)
[16:04:13.566]                           }
[16:04:13.566]                           base::stop(msg)
[16:04:13.566]                         }
[16:04:13.566]                       })
[16:04:13.566]                     }
[16:04:13.566]                     base::local({
[16:04:13.566]                       for (pkg in "future") {
[16:04:13.566]                         base::loadNamespace(pkg)
[16:04:13.566]                         base::library(pkg, character.only = TRUE)
[16:04:13.566]                       }
[16:04:13.566]                     })
[16:04:13.566]                   }
[16:04:13.566]                   options(future.plan = NULL)
[16:04:13.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:13.566]                 }
[16:04:13.566]                 ...future.workdir <- getwd()
[16:04:13.566]             }
[16:04:13.566]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:13.566]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:13.566]         }
[16:04:13.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:13.566]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:13.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:13.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:13.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:13.566]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:13.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:13.566]             base::names(...future.oldOptions))
[16:04:13.566]     }
[16:04:13.566]     if (FALSE) {
[16:04:13.566]     }
[16:04:13.566]     else {
[16:04:13.566]         if (TRUE) {
[16:04:13.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:13.566]                 open = "w")
[16:04:13.566]         }
[16:04:13.566]         else {
[16:04:13.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:13.566]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:13.566]         }
[16:04:13.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:13.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:13.566]             base::sink(type = "output", split = FALSE)
[16:04:13.566]             base::close(...future.stdout)
[16:04:13.566]         }, add = TRUE)
[16:04:13.566]     }
[16:04:13.566]     ...future.frame <- base::sys.nframe()
[16:04:13.566]     ...future.conditions <- base::list()
[16:04:13.566]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:13.566]     if (FALSE) {
[16:04:13.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:13.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:13.566]     }
[16:04:13.566]     ...future.result <- base::tryCatch({
[16:04:13.566]         base::withCallingHandlers({
[16:04:13.566]             ...future.value <- base::withVisible(base::local({
[16:04:13.566]                 message(sprintf("Calculating tile #%d of %d ...", 
[16:04:13.566]                   ii, n), appendLF = FALSE)
[16:04:13.566]                 fit <- mandelbrot(C)
[16:04:13.566]                 delay(fit)
[16:04:13.566]                 message(" done")
[16:04:13.566]                 fit
[16:04:13.566]             }))
[16:04:13.566]             future::FutureResult(value = ...future.value$value, 
[16:04:13.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.566]                   ...future.rng), globalenv = if (FALSE) 
[16:04:13.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:13.566]                     ...future.globalenv.names))
[16:04:13.566]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:13.566]         }, condition = base::local({
[16:04:13.566]             c <- base::c
[16:04:13.566]             inherits <- base::inherits
[16:04:13.566]             invokeRestart <- base::invokeRestart
[16:04:13.566]             length <- base::length
[16:04:13.566]             list <- base::list
[16:04:13.566]             seq.int <- base::seq.int
[16:04:13.566]             signalCondition <- base::signalCondition
[16:04:13.566]             sys.calls <- base::sys.calls
[16:04:13.566]             `[[` <- base::`[[`
[16:04:13.566]             `+` <- base::`+`
[16:04:13.566]             `<<-` <- base::`<<-`
[16:04:13.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:13.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:13.566]                   3L)]
[16:04:13.566]             }
[16:04:13.566]             function(cond) {
[16:04:13.566]                 is_error <- inherits(cond, "error")
[16:04:13.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:13.566]                   NULL)
[16:04:13.566]                 if (is_error) {
[16:04:13.566]                   sessionInformation <- function() {
[16:04:13.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:13.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:13.566]                       search = base::search(), system = base::Sys.info())
[16:04:13.566]                   }
[16:04:13.566]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:13.566]                     cond$call), session = sessionInformation(), 
[16:04:13.566]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:13.566]                   signalCondition(cond)
[16:04:13.566]                 }
[16:04:13.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:13.566]                 "immediateCondition"))) {
[16:04:13.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:13.566]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:13.566]                   if (TRUE && !signal) {
[16:04:13.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.566]                     {
[16:04:13.566]                       inherits <- base::inherits
[16:04:13.566]                       invokeRestart <- base::invokeRestart
[16:04:13.566]                       is.null <- base::is.null
[16:04:13.566]                       muffled <- FALSE
[16:04:13.566]                       if (inherits(cond, "message")) {
[16:04:13.566]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.566]                         if (muffled) 
[16:04:13.566]                           invokeRestart("muffleMessage")
[16:04:13.566]                       }
[16:04:13.566]                       else if (inherits(cond, "warning")) {
[16:04:13.566]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.566]                         if (muffled) 
[16:04:13.566]                           invokeRestart("muffleWarning")
[16:04:13.566]                       }
[16:04:13.566]                       else if (inherits(cond, "condition")) {
[16:04:13.566]                         if (!is.null(pattern)) {
[16:04:13.566]                           computeRestarts <- base::computeRestarts
[16:04:13.566]                           grepl <- base::grepl
[16:04:13.566]                           restarts <- computeRestarts(cond)
[16:04:13.566]                           for (restart in restarts) {
[16:04:13.566]                             name <- restart$name
[16:04:13.566]                             if (is.null(name)) 
[16:04:13.566]                               next
[16:04:13.566]                             if (!grepl(pattern, name)) 
[16:04:13.566]                               next
[16:04:13.566]                             invokeRestart(restart)
[16:04:13.566]                             muffled <- TRUE
[16:04:13.566]                             break
[16:04:13.566]                           }
[16:04:13.566]                         }
[16:04:13.566]                       }
[16:04:13.566]                       invisible(muffled)
[16:04:13.566]                     }
[16:04:13.566]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.566]                   }
[16:04:13.566]                 }
[16:04:13.566]                 else {
[16:04:13.566]                   if (TRUE) {
[16:04:13.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.566]                     {
[16:04:13.566]                       inherits <- base::inherits
[16:04:13.566]                       invokeRestart <- base::invokeRestart
[16:04:13.566]                       is.null <- base::is.null
[16:04:13.566]                       muffled <- FALSE
[16:04:13.566]                       if (inherits(cond, "message")) {
[16:04:13.566]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.566]                         if (muffled) 
[16:04:13.566]                           invokeRestart("muffleMessage")
[16:04:13.566]                       }
[16:04:13.566]                       else if (inherits(cond, "warning")) {
[16:04:13.566]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.566]                         if (muffled) 
[16:04:13.566]                           invokeRestart("muffleWarning")
[16:04:13.566]                       }
[16:04:13.566]                       else if (inherits(cond, "condition")) {
[16:04:13.566]                         if (!is.null(pattern)) {
[16:04:13.566]                           computeRestarts <- base::computeRestarts
[16:04:13.566]                           grepl <- base::grepl
[16:04:13.566]                           restarts <- computeRestarts(cond)
[16:04:13.566]                           for (restart in restarts) {
[16:04:13.566]                             name <- restart$name
[16:04:13.566]                             if (is.null(name)) 
[16:04:13.566]                               next
[16:04:13.566]                             if (!grepl(pattern, name)) 
[16:04:13.566]                               next
[16:04:13.566]                             invokeRestart(restart)
[16:04:13.566]                             muffled <- TRUE
[16:04:13.566]                             break
[16:04:13.566]                           }
[16:04:13.566]                         }
[16:04:13.566]                       }
[16:04:13.566]                       invisible(muffled)
[16:04:13.566]                     }
[16:04:13.566]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.566]                   }
[16:04:13.566]                 }
[16:04:13.566]             }
[16:04:13.566]         }))
[16:04:13.566]     }, error = function(ex) {
[16:04:13.566]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:13.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.566]                 ...future.rng), started = ...future.startTime, 
[16:04:13.566]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:13.566]             version = "1.8"), class = "FutureResult")
[16:04:13.566]     }, finally = {
[16:04:13.566]         if (!identical(...future.workdir, getwd())) 
[16:04:13.566]             setwd(...future.workdir)
[16:04:13.566]         {
[16:04:13.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:13.566]                 ...future.oldOptions$nwarnings <- NULL
[16:04:13.566]             }
[16:04:13.566]             base::options(...future.oldOptions)
[16:04:13.566]             if (.Platform$OS.type == "windows") {
[16:04:13.566]                 old_names <- names(...future.oldEnvVars)
[16:04:13.566]                 envs <- base::Sys.getenv()
[16:04:13.566]                 names <- names(envs)
[16:04:13.566]                 common <- intersect(names, old_names)
[16:04:13.566]                 added <- setdiff(names, old_names)
[16:04:13.566]                 removed <- setdiff(old_names, names)
[16:04:13.566]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:13.566]                   envs[common]]
[16:04:13.566]                 NAMES <- toupper(changed)
[16:04:13.566]                 args <- list()
[16:04:13.566]                 for (kk in seq_along(NAMES)) {
[16:04:13.566]                   name <- changed[[kk]]
[16:04:13.566]                   NAME <- NAMES[[kk]]
[16:04:13.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.566]                     next
[16:04:13.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.566]                 }
[16:04:13.566]                 NAMES <- toupper(added)
[16:04:13.566]                 for (kk in seq_along(NAMES)) {
[16:04:13.566]                   name <- added[[kk]]
[16:04:13.566]                   NAME <- NAMES[[kk]]
[16:04:13.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.566]                     next
[16:04:13.566]                   args[[name]] <- ""
[16:04:13.566]                 }
[16:04:13.566]                 NAMES <- toupper(removed)
[16:04:13.566]                 for (kk in seq_along(NAMES)) {
[16:04:13.566]                   name <- removed[[kk]]
[16:04:13.566]                   NAME <- NAMES[[kk]]
[16:04:13.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.566]                     next
[16:04:13.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.566]                 }
[16:04:13.566]                 if (length(args) > 0) 
[16:04:13.566]                   base::do.call(base::Sys.setenv, args = args)
[16:04:13.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:13.566]             }
[16:04:13.566]             else {
[16:04:13.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:13.566]             }
[16:04:13.566]             {
[16:04:13.566]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:13.566]                   0L) {
[16:04:13.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:13.566]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:13.566]                   base::options(opts)
[16:04:13.566]                 }
[16:04:13.566]                 {
[16:04:13.566]                   {
[16:04:13.566]                     NULL
[16:04:13.566]                     RNGkind("Mersenne-Twister")
[16:04:13.566]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:13.566]                       inherits = FALSE)
[16:04:13.566]                   }
[16:04:13.566]                   options(future.plan = NULL)
[16:04:13.566]                   if (is.na(NA_character_)) 
[16:04:13.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:13.566]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:13.566]                   {
[16:04:13.566]                     future <- SequentialFuture(..., envir = envir)
[16:04:13.566]                     if (!future$lazy) 
[16:04:13.566]                       future <- run(future)
[16:04:13.566]                     invisible(future)
[16:04:13.566]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:13.566]                 }
[16:04:13.566]             }
[16:04:13.566]         }
[16:04:13.566]     })
[16:04:13.566]     if (TRUE) {
[16:04:13.566]         base::sink(type = "output", split = FALSE)
[16:04:13.566]         if (TRUE) {
[16:04:13.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:13.566]         }
[16:04:13.566]         else {
[16:04:13.566]             ...future.result["stdout"] <- base::list(NULL)
[16:04:13.566]         }
[16:04:13.566]         base::close(...future.stdout)
[16:04:13.566]         ...future.stdout <- NULL
[16:04:13.566]     }
[16:04:13.566]     ...future.result$conditions <- ...future.conditions
[16:04:13.566]     ...future.result$finished <- base::Sys.time()
[16:04:13.566]     ...future.result
[16:04:13.566] }
[16:04:13.568] assign_globals() ...
[16:04:13.568] List of 4
[16:04:13.568]  $ ii   : int 2
[16:04:13.568]  $ n    : int 4
[16:04:13.568]  $ C    : cplx [1:25, 1:25] -0.72-1.5i -0.72-1.44i -0.72-1.38i ...
[16:04:13.568]   ..- attr(*, "region")=List of 2
[16:04:13.568]   .. ..$ xrange: num [1:2] -0.719 0.75
[16:04:13.568]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[16:04:13.568]   ..- attr(*, "tile")= int [1:2] 1 2
[16:04:13.568]  $ delay:function (counts)  
[16:04:13.568]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:04:13.568]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x5573463027a8> 
[16:04:13.568]  - attr(*, "where")=List of 4
[16:04:13.568]   ..$ ii   :<environment: R_EmptyEnv> 
[16:04:13.568]   ..$ n    :<environment: R_EmptyEnv> 
[16:04:13.568]   ..$ C    :<environment: R_EmptyEnv> 
[16:04:13.568]   ..$ delay:<environment: R_EmptyEnv> 
[16:04:13.568]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:13.568]  - attr(*, "resolved")= logi FALSE
[16:04:13.568]  - attr(*, "total_size")= num 14584
[16:04:13.568]  - attr(*, "already-done")= logi TRUE
[16:04:13.574] - copied ‘ii’ to environment
[16:04:13.574] - copied ‘n’ to environment
[16:04:13.574] - copied ‘C’ to environment
[16:04:13.574] - reassign environment for ‘delay’
[16:04:13.574] - copied ‘delay’ to environment
[16:04:13.574] assign_globals() ... done
[16:04:13.575] plan(): Setting new future strategy stack:
[16:04:13.575] List of future strategies:
[16:04:13.575] 1. sequential:
[16:04:13.575]    - args: function (..., envir = parent.frame())
[16:04:13.575]    - tweaked: FALSE
[16:04:13.575]    - call: NULL
[16:04:13.575] plan(): nbrOfWorkers() = 1
[16:04:13.590] plan(): Setting new future strategy stack:
[16:04:13.590] List of future strategies:
[16:04:13.590] 1. sequential:
[16:04:13.590]    - args: function (..., envir = parent.frame())
[16:04:13.590]    - tweaked: FALSE
[16:04:13.590]    - call: plan(strategy)
[16:04:13.590] plan(): nbrOfWorkers() = 1
[16:04:13.590] SequentialFuture started (and completed)
[16:04:13.590] signalConditions() ...
[16:04:13.591]  - include = ‘immediateCondition’
[16:04:13.591]  - exclude = 
[16:04:13.591]  - resignal = FALSE
[16:04:13.591]  - Number of conditions: 2
[16:04:13.591] signalConditions() ... done
[16:04:13.591] - Launch lazy future ... done
[16:04:13.591] run() for ‘SequentialFuture’ ... done
[16:04:13.591] - run() ... done
[16:04:13.591] - resolved() ...
[16:04:13.591] resolved() for ‘SequentialFuture’ ...
[16:04:13.592] - state: ‘finished’
[16:04:13.592] - run: TRUE
[16:04:13.592] - result: ‘FutureResult’
[16:04:13.592] resolved() for ‘SequentialFuture’ ... done
[16:04:13.592] - resolved: TRUE
[16:04:13.592] - resolved() ... done
[16:04:13.592] resolved() for ‘SequentialFuture’ ... done
Plotting tile #2 of 4 ...
[16:04:13.592] signalConditions() ...
[16:04:13.592]  - include = ‘immediateCondition’
[16:04:13.592]  - exclude = 
[16:04:13.592]  - resignal = FALSE
[16:04:13.593]  - Number of conditions: 2
[16:04:13.593] signalConditions() ... done
[16:04:13.593] Future state: ‘finished’
[16:04:13.593] signalConditions() ...
[16:04:13.593]  - include = ‘condition’
[16:04:13.593]  - exclude = ‘immediateCondition’
[16:04:13.593]  - resignal = TRUE
[16:04:13.593]  - Number of conditions: 2
[16:04:13.593]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[16:04:13.593]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:04:13.594] signalConditions() ... done
[16:04:13.594] resolved() for ‘Future’ ...
[16:04:13.594] - state: ‘created’
[16:04:13.594] - run: TRUE
[16:04:13.594] - run() ...
[16:04:13.595] run() for ‘Future’ ...
[16:04:13.595] - state: ‘created’
[16:04:13.595] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:13.595] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:13.595] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:13.595]   - Field: ‘label’
[16:04:13.595]   - Field: ‘local’
[16:04:13.596]   - Field: ‘owner’
[16:04:13.596]   - Field: ‘envir’
[16:04:13.596]   - Field: ‘packages’
[16:04:13.596]   - Field: ‘gc’
[16:04:13.596]   - Field: ‘conditions’
[16:04:13.596]   - Field: ‘expr’
[16:04:13.596]   - Field: ‘uuid’
[16:04:13.596]   - Field: ‘seed’
[16:04:13.596]   - Field: ‘version’
[16:04:13.596]   - Field: ‘result’
[16:04:13.596]   - Field: ‘asynchronous’
[16:04:13.597]   - Field: ‘calls’
[16:04:13.597]   - Field: ‘globals’
[16:04:13.597]   - Field: ‘stdout’
[16:04:13.597]   - Field: ‘earlySignal’
[16:04:13.597]   - Field: ‘lazy’
[16:04:13.597]   - Field: ‘state’
[16:04:13.597] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:13.597] - Launch lazy future ...
[16:04:13.597] Packages needed by the future expression (n = 1): ‘future’
[16:04:13.598] Packages needed by future strategies (n = 0): <none>
[16:04:13.598] {
[16:04:13.598]     {
[16:04:13.598]         {
[16:04:13.598]             ...future.startTime <- base::Sys.time()
[16:04:13.598]             {
[16:04:13.598]                 {
[16:04:13.598]                   {
[16:04:13.598]                     {
[16:04:13.598]                       base::local({
[16:04:13.598]                         has_future <- base::requireNamespace("future", 
[16:04:13.598]                           quietly = TRUE)
[16:04:13.598]                         if (has_future) {
[16:04:13.598]                           ns <- base::getNamespace("future")
[16:04:13.598]                           version <- ns[[".package"]][["version"]]
[16:04:13.598]                           if (is.null(version)) 
[16:04:13.598]                             version <- utils::packageVersion("future")
[16:04:13.598]                         }
[16:04:13.598]                         else {
[16:04:13.598]                           version <- NULL
[16:04:13.598]                         }
[16:04:13.598]                         if (!has_future || version < "1.8.0") {
[16:04:13.598]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:13.598]                             "", base::R.version$version.string), 
[16:04:13.598]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:13.598]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:13.598]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:13.598]                               "release", "version")], collapse = " "), 
[16:04:13.598]                             hostname = base::Sys.info()[["nodename"]])
[16:04:13.598]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:13.598]                             info)
[16:04:13.598]                           info <- base::paste(info, collapse = "; ")
[16:04:13.598]                           if (!has_future) {
[16:04:13.598]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:13.598]                               info)
[16:04:13.598]                           }
[16:04:13.598]                           else {
[16:04:13.598]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:13.598]                               info, version)
[16:04:13.598]                           }
[16:04:13.598]                           base::stop(msg)
[16:04:13.598]                         }
[16:04:13.598]                       })
[16:04:13.598]                     }
[16:04:13.598]                     base::local({
[16:04:13.598]                       for (pkg in "future") {
[16:04:13.598]                         base::loadNamespace(pkg)
[16:04:13.598]                         base::library(pkg, character.only = TRUE)
[16:04:13.598]                       }
[16:04:13.598]                     })
[16:04:13.598]                   }
[16:04:13.598]                   options(future.plan = NULL)
[16:04:13.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.598]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:13.598]                 }
[16:04:13.598]                 ...future.workdir <- getwd()
[16:04:13.598]             }
[16:04:13.598]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:13.598]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:13.598]         }
[16:04:13.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:13.598]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:13.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:13.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:13.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:13.598]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:13.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:13.598]             base::names(...future.oldOptions))
[16:04:13.598]     }
[16:04:13.598]     if (FALSE) {
[16:04:13.598]     }
[16:04:13.598]     else {
[16:04:13.598]         if (TRUE) {
[16:04:13.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:13.598]                 open = "w")
[16:04:13.598]         }
[16:04:13.598]         else {
[16:04:13.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:13.598]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:13.598]         }
[16:04:13.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:13.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:13.598]             base::sink(type = "output", split = FALSE)
[16:04:13.598]             base::close(...future.stdout)
[16:04:13.598]         }, add = TRUE)
[16:04:13.598]     }
[16:04:13.598]     ...future.frame <- base::sys.nframe()
[16:04:13.598]     ...future.conditions <- base::list()
[16:04:13.598]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:13.598]     if (FALSE) {
[16:04:13.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:13.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:13.598]     }
[16:04:13.598]     ...future.result <- base::tryCatch({
[16:04:13.598]         base::withCallingHandlers({
[16:04:13.598]             ...future.value <- base::withVisible(base::local({
[16:04:13.598]                 message(sprintf("Calculating tile #%d of %d ...", 
[16:04:13.598]                   ii, n), appendLF = FALSE)
[16:04:13.598]                 fit <- mandelbrot(C)
[16:04:13.598]                 delay(fit)
[16:04:13.598]                 message(" done")
[16:04:13.598]                 fit
[16:04:13.598]             }))
[16:04:13.598]             future::FutureResult(value = ...future.value$value, 
[16:04:13.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.598]                   ...future.rng), globalenv = if (FALSE) 
[16:04:13.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:13.598]                     ...future.globalenv.names))
[16:04:13.598]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:13.598]         }, condition = base::local({
[16:04:13.598]             c <- base::c
[16:04:13.598]             inherits <- base::inherits
[16:04:13.598]             invokeRestart <- base::invokeRestart
[16:04:13.598]             length <- base::length
[16:04:13.598]             list <- base::list
[16:04:13.598]             seq.int <- base::seq.int
[16:04:13.598]             signalCondition <- base::signalCondition
[16:04:13.598]             sys.calls <- base::sys.calls
[16:04:13.598]             `[[` <- base::`[[`
[16:04:13.598]             `+` <- base::`+`
[16:04:13.598]             `<<-` <- base::`<<-`
[16:04:13.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:13.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:13.598]                   3L)]
[16:04:13.598]             }
[16:04:13.598]             function(cond) {
[16:04:13.598]                 is_error <- inherits(cond, "error")
[16:04:13.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:13.598]                   NULL)
[16:04:13.598]                 if (is_error) {
[16:04:13.598]                   sessionInformation <- function() {
[16:04:13.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:13.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:13.598]                       search = base::search(), system = base::Sys.info())
[16:04:13.598]                   }
[16:04:13.598]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:13.598]                     cond$call), session = sessionInformation(), 
[16:04:13.598]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:13.598]                   signalCondition(cond)
[16:04:13.598]                 }
[16:04:13.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:13.598]                 "immediateCondition"))) {
[16:04:13.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:13.598]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:13.598]                   if (TRUE && !signal) {
[16:04:13.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.598]                     {
[16:04:13.598]                       inherits <- base::inherits
[16:04:13.598]                       invokeRestart <- base::invokeRestart
[16:04:13.598]                       is.null <- base::is.null
[16:04:13.598]                       muffled <- FALSE
[16:04:13.598]                       if (inherits(cond, "message")) {
[16:04:13.598]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.598]                         if (muffled) 
[16:04:13.598]                           invokeRestart("muffleMessage")
[16:04:13.598]                       }
[16:04:13.598]                       else if (inherits(cond, "warning")) {
[16:04:13.598]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.598]                         if (muffled) 
[16:04:13.598]                           invokeRestart("muffleWarning")
[16:04:13.598]                       }
[16:04:13.598]                       else if (inherits(cond, "condition")) {
[16:04:13.598]                         if (!is.null(pattern)) {
[16:04:13.598]                           computeRestarts <- base::computeRestarts
[16:04:13.598]                           grepl <- base::grepl
[16:04:13.598]                           restarts <- computeRestarts(cond)
[16:04:13.598]                           for (restart in restarts) {
[16:04:13.598]                             name <- restart$name
[16:04:13.598]                             if (is.null(name)) 
[16:04:13.598]                               next
[16:04:13.598]                             if (!grepl(pattern, name)) 
[16:04:13.598]                               next
[16:04:13.598]                             invokeRestart(restart)
[16:04:13.598]                             muffled <- TRUE
[16:04:13.598]                             break
[16:04:13.598]                           }
[16:04:13.598]                         }
[16:04:13.598]                       }
[16:04:13.598]                       invisible(muffled)
[16:04:13.598]                     }
[16:04:13.598]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.598]                   }
[16:04:13.598]                 }
[16:04:13.598]                 else {
[16:04:13.598]                   if (TRUE) {
[16:04:13.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.598]                     {
[16:04:13.598]                       inherits <- base::inherits
[16:04:13.598]                       invokeRestart <- base::invokeRestart
[16:04:13.598]                       is.null <- base::is.null
[16:04:13.598]                       muffled <- FALSE
[16:04:13.598]                       if (inherits(cond, "message")) {
[16:04:13.598]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.598]                         if (muffled) 
[16:04:13.598]                           invokeRestart("muffleMessage")
[16:04:13.598]                       }
[16:04:13.598]                       else if (inherits(cond, "warning")) {
[16:04:13.598]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.598]                         if (muffled) 
[16:04:13.598]                           invokeRestart("muffleWarning")
[16:04:13.598]                       }
[16:04:13.598]                       else if (inherits(cond, "condition")) {
[16:04:13.598]                         if (!is.null(pattern)) {
[16:04:13.598]                           computeRestarts <- base::computeRestarts
[16:04:13.598]                           grepl <- base::grepl
[16:04:13.598]                           restarts <- computeRestarts(cond)
[16:04:13.598]                           for (restart in restarts) {
[16:04:13.598]                             name <- restart$name
[16:04:13.598]                             if (is.null(name)) 
[16:04:13.598]                               next
[16:04:13.598]                             if (!grepl(pattern, name)) 
[16:04:13.598]                               next
[16:04:13.598]                             invokeRestart(restart)
[16:04:13.598]                             muffled <- TRUE
[16:04:13.598]                             break
[16:04:13.598]                           }
[16:04:13.598]                         }
[16:04:13.598]                       }
[16:04:13.598]                       invisible(muffled)
[16:04:13.598]                     }
[16:04:13.598]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.598]                   }
[16:04:13.598]                 }
[16:04:13.598]             }
[16:04:13.598]         }))
[16:04:13.598]     }, error = function(ex) {
[16:04:13.598]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:13.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.598]                 ...future.rng), started = ...future.startTime, 
[16:04:13.598]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:13.598]             version = "1.8"), class = "FutureResult")
[16:04:13.598]     }, finally = {
[16:04:13.598]         if (!identical(...future.workdir, getwd())) 
[16:04:13.598]             setwd(...future.workdir)
[16:04:13.598]         {
[16:04:13.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:13.598]                 ...future.oldOptions$nwarnings <- NULL
[16:04:13.598]             }
[16:04:13.598]             base::options(...future.oldOptions)
[16:04:13.598]             if (.Platform$OS.type == "windows") {
[16:04:13.598]                 old_names <- names(...future.oldEnvVars)
[16:04:13.598]                 envs <- base::Sys.getenv()
[16:04:13.598]                 names <- names(envs)
[16:04:13.598]                 common <- intersect(names, old_names)
[16:04:13.598]                 added <- setdiff(names, old_names)
[16:04:13.598]                 removed <- setdiff(old_names, names)
[16:04:13.598]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:13.598]                   envs[common]]
[16:04:13.598]                 NAMES <- toupper(changed)
[16:04:13.598]                 args <- list()
[16:04:13.598]                 for (kk in seq_along(NAMES)) {
[16:04:13.598]                   name <- changed[[kk]]
[16:04:13.598]                   NAME <- NAMES[[kk]]
[16:04:13.598]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.598]                     next
[16:04:13.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.598]                 }
[16:04:13.598]                 NAMES <- toupper(added)
[16:04:13.598]                 for (kk in seq_along(NAMES)) {
[16:04:13.598]                   name <- added[[kk]]
[16:04:13.598]                   NAME <- NAMES[[kk]]
[16:04:13.598]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.598]                     next
[16:04:13.598]                   args[[name]] <- ""
[16:04:13.598]                 }
[16:04:13.598]                 NAMES <- toupper(removed)
[16:04:13.598]                 for (kk in seq_along(NAMES)) {
[16:04:13.598]                   name <- removed[[kk]]
[16:04:13.598]                   NAME <- NAMES[[kk]]
[16:04:13.598]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.598]                     next
[16:04:13.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.598]                 }
[16:04:13.598]                 if (length(args) > 0) 
[16:04:13.598]                   base::do.call(base::Sys.setenv, args = args)
[16:04:13.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:13.598]             }
[16:04:13.598]             else {
[16:04:13.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:13.598]             }
[16:04:13.598]             {
[16:04:13.598]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:13.598]                   0L) {
[16:04:13.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:13.598]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:13.598]                   base::options(opts)
[16:04:13.598]                 }
[16:04:13.598]                 {
[16:04:13.598]                   {
[16:04:13.598]                     NULL
[16:04:13.598]                     RNGkind("Mersenne-Twister")
[16:04:13.598]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:13.598]                       inherits = FALSE)
[16:04:13.598]                   }
[16:04:13.598]                   options(future.plan = NULL)
[16:04:13.598]                   if (is.na(NA_character_)) 
[16:04:13.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:13.598]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:13.598]                   {
[16:04:13.598]                     future <- SequentialFuture(..., envir = envir)
[16:04:13.598]                     if (!future$lazy) 
[16:04:13.598]                       future <- run(future)
[16:04:13.598]                     invisible(future)
[16:04:13.598]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:13.598]                 }
[16:04:13.598]             }
[16:04:13.598]         }
[16:04:13.598]     })
[16:04:13.598]     if (TRUE) {
[16:04:13.598]         base::sink(type = "output", split = FALSE)
[16:04:13.598]         if (TRUE) {
[16:04:13.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:13.598]         }
[16:04:13.598]         else {
[16:04:13.598]             ...future.result["stdout"] <- base::list(NULL)
[16:04:13.598]         }
[16:04:13.598]         base::close(...future.stdout)
[16:04:13.598]         ...future.stdout <- NULL
[16:04:13.598]     }
[16:04:13.598]     ...future.result$conditions <- ...future.conditions
[16:04:13.598]     ...future.result$finished <- base::Sys.time()
[16:04:13.598]     ...future.result
[16:04:13.598] }
[16:04:13.600] assign_globals() ...
[16:04:13.600] List of 4
[16:04:13.600]  $ ii   : int 3
[16:04:13.600]  $ n    : int 4
[16:04:13.600]  $ C    : cplx [1:25, 1:25] -2.25+0.03i -2.25+0.09i -2.25+0.15i ...
[16:04:13.600]   ..- attr(*, "region")=List of 2
[16:04:13.600]   .. ..$ xrange: num [1:2] -2.25 -0.781
[16:04:13.600]   .. ..$ yrange: num [1:2] 0.0306 1.5
[16:04:13.600]   ..- attr(*, "tile")= int [1:2] 2 1
[16:04:13.600]  $ delay:function (counts)  
[16:04:13.600]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:04:13.600]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x5573463027a8> 
[16:04:13.600]  - attr(*, "where")=List of 4
[16:04:13.600]   ..$ ii   :<environment: R_EmptyEnv> 
[16:04:13.600]   ..$ n    :<environment: R_EmptyEnv> 
[16:04:13.600]   ..$ C    :<environment: R_EmptyEnv> 
[16:04:13.600]   ..$ delay:<environment: R_EmptyEnv> 
[16:04:13.600]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:13.600]  - attr(*, "resolved")= logi FALSE
[16:04:13.600]  - attr(*, "total_size")= num 14584
[16:04:13.600]  - attr(*, "already-done")= logi TRUE
[16:04:13.606] - copied ‘ii’ to environment
[16:04:13.606] - copied ‘n’ to environment
[16:04:13.606] - copied ‘C’ to environment
[16:04:13.606] - reassign environment for ‘delay’
[16:04:13.607] - copied ‘delay’ to environment
[16:04:13.607] assign_globals() ... done
[16:04:13.607] plan(): Setting new future strategy stack:
[16:04:13.607] List of future strategies:
[16:04:13.607] 1. sequential:
[16:04:13.607]    - args: function (..., envir = parent.frame())
[16:04:13.607]    - tweaked: FALSE
[16:04:13.607]    - call: NULL
[16:04:13.607] plan(): nbrOfWorkers() = 1
[16:04:13.624] plan(): Setting new future strategy stack:
[16:04:13.624] List of future strategies:
[16:04:13.624] 1. sequential:
[16:04:13.624]    - args: function (..., envir = parent.frame())
[16:04:13.624]    - tweaked: FALSE
[16:04:13.624]    - call: plan(strategy)
[16:04:13.624] plan(): nbrOfWorkers() = 1
[16:04:13.625] SequentialFuture started (and completed)
[16:04:13.625] signalConditions() ...
[16:04:13.625]  - include = ‘immediateCondition’
[16:04:13.625]  - exclude = 
[16:04:13.625]  - resignal = FALSE
[16:04:13.625]  - Number of conditions: 2
[16:04:13.625] signalConditions() ... done
[16:04:13.625] - Launch lazy future ... done
[16:04:13.625] run() for ‘SequentialFuture’ ... done
[16:04:13.625] - run() ... done
[16:04:13.626] - resolved() ...
[16:04:13.626] resolved() for ‘SequentialFuture’ ...
[16:04:13.626] - state: ‘finished’
[16:04:13.626] - run: TRUE
[16:04:13.626] - result: ‘FutureResult’
[16:04:13.626] resolved() for ‘SequentialFuture’ ... done
[16:04:13.626] - resolved: TRUE
[16:04:13.626] - resolved() ... done
[16:04:13.626] resolved() for ‘SequentialFuture’ ... done
Plotting tile #3 of 4 ...
[16:04:13.626] signalConditions() ...
[16:04:13.627]  - include = ‘immediateCondition’
[16:04:13.627]  - exclude = 
[16:04:13.627]  - resignal = FALSE
[16:04:13.627]  - Number of conditions: 2
[16:04:13.627] signalConditions() ... done
[16:04:13.627] Future state: ‘finished’
[16:04:13.627] signalConditions() ...
[16:04:13.627]  - include = ‘condition’
[16:04:13.627]  - exclude = ‘immediateCondition’
[16:04:13.627]  - resignal = TRUE
[16:04:13.627]  - Number of conditions: 2
[16:04:13.628]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[16:04:13.628]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:04:13.628] signalConditions() ... done
[16:04:13.628] resolved() for ‘Future’ ...
[16:04:13.629] - state: ‘created’
[16:04:13.629] - run: TRUE
[16:04:13.629] - run() ...
[16:04:13.629] run() for ‘Future’ ...
[16:04:13.629] - state: ‘created’
[16:04:13.629] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:13.629] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:13.629] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:13.630]   - Field: ‘label’
[16:04:13.630]   - Field: ‘local’
[16:04:13.630]   - Field: ‘owner’
[16:04:13.630]   - Field: ‘envir’
[16:04:13.630]   - Field: ‘packages’
[16:04:13.630]   - Field: ‘gc’
[16:04:13.630]   - Field: ‘conditions’
[16:04:13.630]   - Field: ‘expr’
[16:04:13.630]   - Field: ‘uuid’
[16:04:13.630]   - Field: ‘seed’
[16:04:13.630]   - Field: ‘version’
[16:04:13.631]   - Field: ‘result’
[16:04:13.631]   - Field: ‘asynchronous’
[16:04:13.631]   - Field: ‘calls’
[16:04:13.631]   - Field: ‘globals’
[16:04:13.631]   - Field: ‘stdout’
[16:04:13.631]   - Field: ‘earlySignal’
[16:04:13.631]   - Field: ‘lazy’
[16:04:13.631]   - Field: ‘state’
[16:04:13.631] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:13.631] - Launch lazy future ...
[16:04:13.632] Packages needed by the future expression (n = 1): ‘future’
[16:04:13.632] Packages needed by future strategies (n = 0): <none>
[16:04:13.632] {
[16:04:13.632]     {
[16:04:13.632]         {
[16:04:13.632]             ...future.startTime <- base::Sys.time()
[16:04:13.632]             {
[16:04:13.632]                 {
[16:04:13.632]                   {
[16:04:13.632]                     {
[16:04:13.632]                       base::local({
[16:04:13.632]                         has_future <- base::requireNamespace("future", 
[16:04:13.632]                           quietly = TRUE)
[16:04:13.632]                         if (has_future) {
[16:04:13.632]                           ns <- base::getNamespace("future")
[16:04:13.632]                           version <- ns[[".package"]][["version"]]
[16:04:13.632]                           if (is.null(version)) 
[16:04:13.632]                             version <- utils::packageVersion("future")
[16:04:13.632]                         }
[16:04:13.632]                         else {
[16:04:13.632]                           version <- NULL
[16:04:13.632]                         }
[16:04:13.632]                         if (!has_future || version < "1.8.0") {
[16:04:13.632]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:13.632]                             "", base::R.version$version.string), 
[16:04:13.632]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:13.632]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:13.632]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:13.632]                               "release", "version")], collapse = " "), 
[16:04:13.632]                             hostname = base::Sys.info()[["nodename"]])
[16:04:13.632]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:13.632]                             info)
[16:04:13.632]                           info <- base::paste(info, collapse = "; ")
[16:04:13.632]                           if (!has_future) {
[16:04:13.632]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:13.632]                               info)
[16:04:13.632]                           }
[16:04:13.632]                           else {
[16:04:13.632]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:13.632]                               info, version)
[16:04:13.632]                           }
[16:04:13.632]                           base::stop(msg)
[16:04:13.632]                         }
[16:04:13.632]                       })
[16:04:13.632]                     }
[16:04:13.632]                     base::local({
[16:04:13.632]                       for (pkg in "future") {
[16:04:13.632]                         base::loadNamespace(pkg)
[16:04:13.632]                         base::library(pkg, character.only = TRUE)
[16:04:13.632]                       }
[16:04:13.632]                     })
[16:04:13.632]                   }
[16:04:13.632]                   options(future.plan = NULL)
[16:04:13.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:13.632]                 }
[16:04:13.632]                 ...future.workdir <- getwd()
[16:04:13.632]             }
[16:04:13.632]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:13.632]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:13.632]         }
[16:04:13.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:13.632]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:13.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:13.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:13.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:13.632]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:13.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:13.632]             base::names(...future.oldOptions))
[16:04:13.632]     }
[16:04:13.632]     if (FALSE) {
[16:04:13.632]     }
[16:04:13.632]     else {
[16:04:13.632]         if (TRUE) {
[16:04:13.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:13.632]                 open = "w")
[16:04:13.632]         }
[16:04:13.632]         else {
[16:04:13.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:13.632]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:13.632]         }
[16:04:13.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:13.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:13.632]             base::sink(type = "output", split = FALSE)
[16:04:13.632]             base::close(...future.stdout)
[16:04:13.632]         }, add = TRUE)
[16:04:13.632]     }
[16:04:13.632]     ...future.frame <- base::sys.nframe()
[16:04:13.632]     ...future.conditions <- base::list()
[16:04:13.632]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:13.632]     if (FALSE) {
[16:04:13.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:13.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:13.632]     }
[16:04:13.632]     ...future.result <- base::tryCatch({
[16:04:13.632]         base::withCallingHandlers({
[16:04:13.632]             ...future.value <- base::withVisible(base::local({
[16:04:13.632]                 message(sprintf("Calculating tile #%d of %d ...", 
[16:04:13.632]                   ii, n), appendLF = FALSE)
[16:04:13.632]                 fit <- mandelbrot(C)
[16:04:13.632]                 delay(fit)
[16:04:13.632]                 message(" done")
[16:04:13.632]                 fit
[16:04:13.632]             }))
[16:04:13.632]             future::FutureResult(value = ...future.value$value, 
[16:04:13.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.632]                   ...future.rng), globalenv = if (FALSE) 
[16:04:13.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:13.632]                     ...future.globalenv.names))
[16:04:13.632]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:13.632]         }, condition = base::local({
[16:04:13.632]             c <- base::c
[16:04:13.632]             inherits <- base::inherits
[16:04:13.632]             invokeRestart <- base::invokeRestart
[16:04:13.632]             length <- base::length
[16:04:13.632]             list <- base::list
[16:04:13.632]             seq.int <- base::seq.int
[16:04:13.632]             signalCondition <- base::signalCondition
[16:04:13.632]             sys.calls <- base::sys.calls
[16:04:13.632]             `[[` <- base::`[[`
[16:04:13.632]             `+` <- base::`+`
[16:04:13.632]             `<<-` <- base::`<<-`
[16:04:13.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:13.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:13.632]                   3L)]
[16:04:13.632]             }
[16:04:13.632]             function(cond) {
[16:04:13.632]                 is_error <- inherits(cond, "error")
[16:04:13.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:13.632]                   NULL)
[16:04:13.632]                 if (is_error) {
[16:04:13.632]                   sessionInformation <- function() {
[16:04:13.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:13.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:13.632]                       search = base::search(), system = base::Sys.info())
[16:04:13.632]                   }
[16:04:13.632]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:13.632]                     cond$call), session = sessionInformation(), 
[16:04:13.632]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:13.632]                   signalCondition(cond)
[16:04:13.632]                 }
[16:04:13.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:13.632]                 "immediateCondition"))) {
[16:04:13.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:13.632]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:13.632]                   if (TRUE && !signal) {
[16:04:13.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.632]                     {
[16:04:13.632]                       inherits <- base::inherits
[16:04:13.632]                       invokeRestart <- base::invokeRestart
[16:04:13.632]                       is.null <- base::is.null
[16:04:13.632]                       muffled <- FALSE
[16:04:13.632]                       if (inherits(cond, "message")) {
[16:04:13.632]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.632]                         if (muffled) 
[16:04:13.632]                           invokeRestart("muffleMessage")
[16:04:13.632]                       }
[16:04:13.632]                       else if (inherits(cond, "warning")) {
[16:04:13.632]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.632]                         if (muffled) 
[16:04:13.632]                           invokeRestart("muffleWarning")
[16:04:13.632]                       }
[16:04:13.632]                       else if (inherits(cond, "condition")) {
[16:04:13.632]                         if (!is.null(pattern)) {
[16:04:13.632]                           computeRestarts <- base::computeRestarts
[16:04:13.632]                           grepl <- base::grepl
[16:04:13.632]                           restarts <- computeRestarts(cond)
[16:04:13.632]                           for (restart in restarts) {
[16:04:13.632]                             name <- restart$name
[16:04:13.632]                             if (is.null(name)) 
[16:04:13.632]                               next
[16:04:13.632]                             if (!grepl(pattern, name)) 
[16:04:13.632]                               next
[16:04:13.632]                             invokeRestart(restart)
[16:04:13.632]                             muffled <- TRUE
[16:04:13.632]                             break
[16:04:13.632]                           }
[16:04:13.632]                         }
[16:04:13.632]                       }
[16:04:13.632]                       invisible(muffled)
[16:04:13.632]                     }
[16:04:13.632]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.632]                   }
[16:04:13.632]                 }
[16:04:13.632]                 else {
[16:04:13.632]                   if (TRUE) {
[16:04:13.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.632]                     {
[16:04:13.632]                       inherits <- base::inherits
[16:04:13.632]                       invokeRestart <- base::invokeRestart
[16:04:13.632]                       is.null <- base::is.null
[16:04:13.632]                       muffled <- FALSE
[16:04:13.632]                       if (inherits(cond, "message")) {
[16:04:13.632]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.632]                         if (muffled) 
[16:04:13.632]                           invokeRestart("muffleMessage")
[16:04:13.632]                       }
[16:04:13.632]                       else if (inherits(cond, "warning")) {
[16:04:13.632]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.632]                         if (muffled) 
[16:04:13.632]                           invokeRestart("muffleWarning")
[16:04:13.632]                       }
[16:04:13.632]                       else if (inherits(cond, "condition")) {
[16:04:13.632]                         if (!is.null(pattern)) {
[16:04:13.632]                           computeRestarts <- base::computeRestarts
[16:04:13.632]                           grepl <- base::grepl
[16:04:13.632]                           restarts <- computeRestarts(cond)
[16:04:13.632]                           for (restart in restarts) {
[16:04:13.632]                             name <- restart$name
[16:04:13.632]                             if (is.null(name)) 
[16:04:13.632]                               next
[16:04:13.632]                             if (!grepl(pattern, name)) 
[16:04:13.632]                               next
[16:04:13.632]                             invokeRestart(restart)
[16:04:13.632]                             muffled <- TRUE
[16:04:13.632]                             break
[16:04:13.632]                           }
[16:04:13.632]                         }
[16:04:13.632]                       }
[16:04:13.632]                       invisible(muffled)
[16:04:13.632]                     }
[16:04:13.632]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.632]                   }
[16:04:13.632]                 }
[16:04:13.632]             }
[16:04:13.632]         }))
[16:04:13.632]     }, error = function(ex) {
[16:04:13.632]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:13.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.632]                 ...future.rng), started = ...future.startTime, 
[16:04:13.632]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:13.632]             version = "1.8"), class = "FutureResult")
[16:04:13.632]     }, finally = {
[16:04:13.632]         if (!identical(...future.workdir, getwd())) 
[16:04:13.632]             setwd(...future.workdir)
[16:04:13.632]         {
[16:04:13.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:13.632]                 ...future.oldOptions$nwarnings <- NULL
[16:04:13.632]             }
[16:04:13.632]             base::options(...future.oldOptions)
[16:04:13.632]             if (.Platform$OS.type == "windows") {
[16:04:13.632]                 old_names <- names(...future.oldEnvVars)
[16:04:13.632]                 envs <- base::Sys.getenv()
[16:04:13.632]                 names <- names(envs)
[16:04:13.632]                 common <- intersect(names, old_names)
[16:04:13.632]                 added <- setdiff(names, old_names)
[16:04:13.632]                 removed <- setdiff(old_names, names)
[16:04:13.632]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:13.632]                   envs[common]]
[16:04:13.632]                 NAMES <- toupper(changed)
[16:04:13.632]                 args <- list()
[16:04:13.632]                 for (kk in seq_along(NAMES)) {
[16:04:13.632]                   name <- changed[[kk]]
[16:04:13.632]                   NAME <- NAMES[[kk]]
[16:04:13.632]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.632]                     next
[16:04:13.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.632]                 }
[16:04:13.632]                 NAMES <- toupper(added)
[16:04:13.632]                 for (kk in seq_along(NAMES)) {
[16:04:13.632]                   name <- added[[kk]]
[16:04:13.632]                   NAME <- NAMES[[kk]]
[16:04:13.632]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.632]                     next
[16:04:13.632]                   args[[name]] <- ""
[16:04:13.632]                 }
[16:04:13.632]                 NAMES <- toupper(removed)
[16:04:13.632]                 for (kk in seq_along(NAMES)) {
[16:04:13.632]                   name <- removed[[kk]]
[16:04:13.632]                   NAME <- NAMES[[kk]]
[16:04:13.632]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.632]                     next
[16:04:13.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.632]                 }
[16:04:13.632]                 if (length(args) > 0) 
[16:04:13.632]                   base::do.call(base::Sys.setenv, args = args)
[16:04:13.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:13.632]             }
[16:04:13.632]             else {
[16:04:13.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:13.632]             }
[16:04:13.632]             {
[16:04:13.632]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:13.632]                   0L) {
[16:04:13.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:13.632]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:13.632]                   base::options(opts)
[16:04:13.632]                 }
[16:04:13.632]                 {
[16:04:13.632]                   {
[16:04:13.632]                     NULL
[16:04:13.632]                     RNGkind("Mersenne-Twister")
[16:04:13.632]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:13.632]                       inherits = FALSE)
[16:04:13.632]                   }
[16:04:13.632]                   options(future.plan = NULL)
[16:04:13.632]                   if (is.na(NA_character_)) 
[16:04:13.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:13.632]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:13.632]                   {
[16:04:13.632]                     future <- SequentialFuture(..., envir = envir)
[16:04:13.632]                     if (!future$lazy) 
[16:04:13.632]                       future <- run(future)
[16:04:13.632]                     invisible(future)
[16:04:13.632]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:13.632]                 }
[16:04:13.632]             }
[16:04:13.632]         }
[16:04:13.632]     })
[16:04:13.632]     if (TRUE) {
[16:04:13.632]         base::sink(type = "output", split = FALSE)
[16:04:13.632]         if (TRUE) {
[16:04:13.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:13.632]         }
[16:04:13.632]         else {
[16:04:13.632]             ...future.result["stdout"] <- base::list(NULL)
[16:04:13.632]         }
[16:04:13.632]         base::close(...future.stdout)
[16:04:13.632]         ...future.stdout <- NULL
[16:04:13.632]     }
[16:04:13.632]     ...future.result$conditions <- ...future.conditions
[16:04:13.632]     ...future.result$finished <- base::Sys.time()
[16:04:13.632]     ...future.result
[16:04:13.632] }
[16:04:13.634] assign_globals() ...
[16:04:13.634] List of 4
[16:04:13.634]  $ ii   : int 4
[16:04:13.634]  $ n    : int 4
[16:04:13.634]  $ C    : cplx [1:25, 1:25] -0.719+0.031i -0.719+0.092i -0.719+0.153i ...
[16:04:13.634]   ..- attr(*, "region")=List of 2
[16:04:13.634]   .. ..$ xrange: num [1:2] -0.719 0.75
[16:04:13.634]   .. ..$ yrange: num [1:2] 0.0306 1.5
[16:04:13.634]   ..- attr(*, "tile")= int [1:2] 2 2
[16:04:13.634]  $ delay:function (counts)  
[16:04:13.634]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:04:13.634]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x5573463027a8> 
[16:04:13.634]  - attr(*, "where")=List of 4
[16:04:13.634]   ..$ ii   :<environment: R_EmptyEnv> 
[16:04:13.634]   ..$ n    :<environment: R_EmptyEnv> 
[16:04:13.634]   ..$ C    :<environment: R_EmptyEnv> 
[16:04:13.634]   ..$ delay:<environment: R_EmptyEnv> 
[16:04:13.634]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:13.634]  - attr(*, "resolved")= logi FALSE
[16:04:13.634]  - attr(*, "total_size")= num 14584
[16:04:13.634]  - attr(*, "already-done")= logi TRUE
[16:04:13.640] - copied ‘ii’ to environment
[16:04:13.640] - copied ‘n’ to environment
[16:04:13.640] - copied ‘C’ to environment
[16:04:13.640] - reassign environment for ‘delay’
[16:04:13.640] - copied ‘delay’ to environment
[16:04:13.640] assign_globals() ... done
[16:04:13.641] plan(): Setting new future strategy stack:
[16:04:13.641] List of future strategies:
[16:04:13.641] 1. sequential:
[16:04:13.641]    - args: function (..., envir = parent.frame())
[16:04:13.641]    - tweaked: FALSE
[16:04:13.641]    - call: NULL
[16:04:13.641] plan(): nbrOfWorkers() = 1
[16:04:13.656] plan(): Setting new future strategy stack:
[16:04:13.656] List of future strategies:
[16:04:13.656] 1. sequential:
[16:04:13.656]    - args: function (..., envir = parent.frame())
[16:04:13.656]    - tweaked: FALSE
[16:04:13.656]    - call: plan(strategy)
[16:04:13.656] plan(): nbrOfWorkers() = 1
[16:04:13.656] SequentialFuture started (and completed)
[16:04:13.657] signalConditions() ...
[16:04:13.657]  - include = ‘immediateCondition’
[16:04:13.657]  - exclude = 
[16:04:13.657]  - resignal = FALSE
[16:04:13.657]  - Number of conditions: 2
[16:04:13.657] signalConditions() ... done
[16:04:13.657] - Launch lazy future ... done
[16:04:13.657] run() for ‘SequentialFuture’ ... done
[16:04:13.657] - run() ... done
[16:04:13.657] - resolved() ...
[16:04:13.657] resolved() for ‘SequentialFuture’ ...
[16:04:13.658] - state: ‘finished’
[16:04:13.658] - run: TRUE
[16:04:13.658] - result: ‘FutureResult’
[16:04:13.658] resolved() for ‘SequentialFuture’ ... done
[16:04:13.658] - resolved: TRUE
[16:04:13.658] - resolved() ... done
[16:04:13.658] resolved() for ‘SequentialFuture’ ... done
Plotting tile #4 of 4 ...
[16:04:13.658] signalConditions() ...
[16:04:13.658]  - include = ‘immediateCondition’
[16:04:13.658]  - exclude = 
[16:04:13.659]  - resignal = FALSE
[16:04:13.659]  - Number of conditions: 2
[16:04:13.659] signalConditions() ... done
[16:04:13.659] Future state: ‘finished’
[16:04:13.659] signalConditions() ...
[16:04:13.659]  - include = ‘condition’
[16:04:13.659]  - exclude = ‘immediateCondition’
[16:04:13.659]  - resignal = TRUE
[16:04:13.659]  - Number of conditions: 2
[16:04:13.659]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[16:04:13.660]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:04:13.660] signalConditions() ... done

> close.screen()
[1] 1 2 3 4

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('sequential') ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('multicore') ...
[16:04:13.666] plan(): Setting new future strategy stack:
[16:04:13.666] List of future strategies:
[16:04:13.666] 1. multicore:
[16:04:13.666]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:13.666]    - tweaked: FALSE
[16:04:13.666]    - call: plan(strategy)
[16:04:13.670] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 5 6 7 8

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[16:04:13.674] getGlobalsAndPackages() ...
[16:04:13.674] Searching for globals...
[16:04:13.677] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:04:13.677] Searching for globals ... DONE
[16:04:13.678] Resolving globals: FALSE
[16:04:13.680] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:04:13.681] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:04:13.681] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:04:13.681] - packages: [1] ‘future’
[16:04:13.681] getGlobalsAndPackages() ... DONE
 2[16:04:13.685] getGlobalsAndPackages() ...
[16:04:13.685] Searching for globals...
[16:04:13.689] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:04:13.689] Searching for globals ... DONE
[16:04:13.689] Resolving globals: FALSE
[16:04:13.690] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:04:13.691] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:04:13.691] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:04:13.691] - packages: [1] ‘future’
[16:04:13.691] getGlobalsAndPackages() ... DONE
 3[16:04:13.691] getGlobalsAndPackages() ...
[16:04:13.692] Searching for globals...
[16:04:13.695] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:04:13.695] Searching for globals ... DONE
[16:04:13.695] Resolving globals: FALSE
[16:04:13.696] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:04:13.696] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:04:13.696] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:04:13.696] - packages: [1] ‘future’
[16:04:13.696] getGlobalsAndPackages() ... DONE
 4[16:04:13.697] getGlobalsAndPackages() ...
[16:04:13.697] Searching for globals...
[16:04:13.700] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:04:13.700] Searching for globals ... DONE
[16:04:13.700] Resolving globals: FALSE
[16:04:13.701] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:04:13.701] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:04:13.701] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:04:13.702] - packages: [1] ‘future’
[16:04:13.702] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[16:04:13.710] resolved() for ‘Future’ ...
[16:04:13.710] - state: ‘created’
[16:04:13.711] - run: TRUE
[16:04:13.711] - run() ...
[16:04:13.711] run() for ‘Future’ ...
[16:04:13.711] - state: ‘created’
[16:04:13.711] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:13.715] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:13.715] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:13.715]   - Field: ‘label’
[16:04:13.715]   - Field: ‘local’
[16:04:13.715]   - Field: ‘owner’
[16:04:13.715]   - Field: ‘envir’
[16:04:13.715]   - Field: ‘workers’
[16:04:13.716]   - Field: ‘packages’
[16:04:13.716]   - Field: ‘gc’
[16:04:13.716]   - Field: ‘job’
[16:04:13.716]   - Field: ‘conditions’
[16:04:13.716]   - Field: ‘expr’
[16:04:13.716]   - Field: ‘uuid’
[16:04:13.716]   - Field: ‘seed’
[16:04:13.716]   - Field: ‘version’
[16:04:13.716]   - Field: ‘result’
[16:04:13.716]   - Field: ‘asynchronous’
[16:04:13.716]   - Field: ‘calls’
[16:04:13.717]   - Field: ‘globals’
[16:04:13.717]   - Field: ‘stdout’
[16:04:13.717]   - Field: ‘earlySignal’
[16:04:13.717]   - Field: ‘lazy’
[16:04:13.717]   - Field: ‘state’
[16:04:13.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:13.717] - Launch lazy future ...
[16:04:13.718] Packages needed by the future expression (n = 1): ‘future’
[16:04:13.718] Packages needed by future strategies (n = 0): <none>
[16:04:13.719] {
[16:04:13.719]     {
[16:04:13.719]         {
[16:04:13.719]             ...future.startTime <- base::Sys.time()
[16:04:13.719]             {
[16:04:13.719]                 {
[16:04:13.719]                   {
[16:04:13.719]                     {
[16:04:13.719]                       {
[16:04:13.719]                         base::local({
[16:04:13.719]                           has_future <- base::requireNamespace("future", 
[16:04:13.719]                             quietly = TRUE)
[16:04:13.719]                           if (has_future) {
[16:04:13.719]                             ns <- base::getNamespace("future")
[16:04:13.719]                             version <- ns[[".package"]][["version"]]
[16:04:13.719]                             if (is.null(version)) 
[16:04:13.719]                               version <- utils::packageVersion("future")
[16:04:13.719]                           }
[16:04:13.719]                           else {
[16:04:13.719]                             version <- NULL
[16:04:13.719]                           }
[16:04:13.719]                           if (!has_future || version < "1.8.0") {
[16:04:13.719]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:13.719]                               "", base::R.version$version.string), 
[16:04:13.719]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:13.719]                                 base::R.version$platform, 8 * 
[16:04:13.719]                                   base::.Machine$sizeof.pointer), 
[16:04:13.719]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:13.719]                                 "release", "version")], collapse = " "), 
[16:04:13.719]                               hostname = base::Sys.info()[["nodename"]])
[16:04:13.719]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:13.719]                               info)
[16:04:13.719]                             info <- base::paste(info, collapse = "; ")
[16:04:13.719]                             if (!has_future) {
[16:04:13.719]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:13.719]                                 info)
[16:04:13.719]                             }
[16:04:13.719]                             else {
[16:04:13.719]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:13.719]                                 info, version)
[16:04:13.719]                             }
[16:04:13.719]                             base::stop(msg)
[16:04:13.719]                           }
[16:04:13.719]                         })
[16:04:13.719]                       }
[16:04:13.719]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:13.719]                       base::options(mc.cores = 1L)
[16:04:13.719]                     }
[16:04:13.719]                     base::local({
[16:04:13.719]                       for (pkg in "future") {
[16:04:13.719]                         base::loadNamespace(pkg)
[16:04:13.719]                         base::library(pkg, character.only = TRUE)
[16:04:13.719]                       }
[16:04:13.719]                     })
[16:04:13.719]                   }
[16:04:13.719]                   options(future.plan = NULL)
[16:04:13.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:13.719]                 }
[16:04:13.719]                 ...future.workdir <- getwd()
[16:04:13.719]             }
[16:04:13.719]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:13.719]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:13.719]         }
[16:04:13.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:13.719]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:13.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:13.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:13.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:13.719]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:13.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:13.719]             base::names(...future.oldOptions))
[16:04:13.719]     }
[16:04:13.719]     if (FALSE) {
[16:04:13.719]     }
[16:04:13.719]     else {
[16:04:13.719]         if (TRUE) {
[16:04:13.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:13.719]                 open = "w")
[16:04:13.719]         }
[16:04:13.719]         else {
[16:04:13.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:13.719]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:13.719]         }
[16:04:13.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:13.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:13.719]             base::sink(type = "output", split = FALSE)
[16:04:13.719]             base::close(...future.stdout)
[16:04:13.719]         }, add = TRUE)
[16:04:13.719]     }
[16:04:13.719]     ...future.frame <- base::sys.nframe()
[16:04:13.719]     ...future.conditions <- base::list()
[16:04:13.719]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:13.719]     if (FALSE) {
[16:04:13.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:13.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:13.719]     }
[16:04:13.719]     ...future.result <- base::tryCatch({
[16:04:13.719]         base::withCallingHandlers({
[16:04:13.719]             ...future.value <- base::withVisible(base::local({
[16:04:13.719]                 withCallingHandlers({
[16:04:13.719]                   {
[16:04:13.719]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:04:13.719]                       ii, n), appendLF = FALSE)
[16:04:13.719]                     fit <- mandelbrot(C)
[16:04:13.719]                     delay(fit)
[16:04:13.719]                     message(" done")
[16:04:13.719]                     fit
[16:04:13.719]                   }
[16:04:13.719]                 }, immediateCondition = function(cond) {
[16:04:13.719]                   save_rds <- function (object, pathname, ...) 
[16:04:13.719]                   {
[16:04:13.719]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:13.719]                     if (file_test("-f", pathname_tmp)) {
[16:04:13.719]                       fi_tmp <- file.info(pathname_tmp)
[16:04:13.719]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:13.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:13.719]                         fi_tmp[["mtime"]])
[16:04:13.719]                     }
[16:04:13.719]                     tryCatch({
[16:04:13.719]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:13.719]                     }, error = function(ex) {
[16:04:13.719]                       msg <- conditionMessage(ex)
[16:04:13.719]                       fi_tmp <- file.info(pathname_tmp)
[16:04:13.719]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:13.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:13.719]                         fi_tmp[["mtime"]], msg)
[16:04:13.719]                       ex$message <- msg
[16:04:13.719]                       stop(ex)
[16:04:13.719]                     })
[16:04:13.719]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:13.719]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:13.719]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:13.719]                       fi_tmp <- file.info(pathname_tmp)
[16:04:13.719]                       fi <- file.info(pathname)
[16:04:13.719]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:13.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:13.719]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:13.719]                         fi[["size"]], fi[["mtime"]])
[16:04:13.719]                       stop(msg)
[16:04:13.719]                     }
[16:04:13.719]                     invisible(pathname)
[16:04:13.719]                   }
[16:04:13.719]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:13.719]                     rootPath = tempdir()) 
[16:04:13.719]                   {
[16:04:13.719]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:13.719]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:13.719]                       tmpdir = path, fileext = ".rds")
[16:04:13.719]                     save_rds(obj, file)
[16:04:13.719]                   }
[16:04:13.719]                   saveImmediateCondition(cond, path = "/tmp/RtmpugdtX0/.future/immediateConditions")
[16:04:13.719]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.719]                   {
[16:04:13.719]                     inherits <- base::inherits
[16:04:13.719]                     invokeRestart <- base::invokeRestart
[16:04:13.719]                     is.null <- base::is.null
[16:04:13.719]                     muffled <- FALSE
[16:04:13.719]                     if (inherits(cond, "message")) {
[16:04:13.719]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:13.719]                       if (muffled) 
[16:04:13.719]                         invokeRestart("muffleMessage")
[16:04:13.719]                     }
[16:04:13.719]                     else if (inherits(cond, "warning")) {
[16:04:13.719]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:13.719]                       if (muffled) 
[16:04:13.719]                         invokeRestart("muffleWarning")
[16:04:13.719]                     }
[16:04:13.719]                     else if (inherits(cond, "condition")) {
[16:04:13.719]                       if (!is.null(pattern)) {
[16:04:13.719]                         computeRestarts <- base::computeRestarts
[16:04:13.719]                         grepl <- base::grepl
[16:04:13.719]                         restarts <- computeRestarts(cond)
[16:04:13.719]                         for (restart in restarts) {
[16:04:13.719]                           name <- restart$name
[16:04:13.719]                           if (is.null(name)) 
[16:04:13.719]                             next
[16:04:13.719]                           if (!grepl(pattern, name)) 
[16:04:13.719]                             next
[16:04:13.719]                           invokeRestart(restart)
[16:04:13.719]                           muffled <- TRUE
[16:04:13.719]                           break
[16:04:13.719]                         }
[16:04:13.719]                       }
[16:04:13.719]                     }
[16:04:13.719]                     invisible(muffled)
[16:04:13.719]                   }
[16:04:13.719]                   muffleCondition(cond)
[16:04:13.719]                 })
[16:04:13.719]             }))
[16:04:13.719]             future::FutureResult(value = ...future.value$value, 
[16:04:13.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.719]                   ...future.rng), globalenv = if (FALSE) 
[16:04:13.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:13.719]                     ...future.globalenv.names))
[16:04:13.719]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:13.719]         }, condition = base::local({
[16:04:13.719]             c <- base::c
[16:04:13.719]             inherits <- base::inherits
[16:04:13.719]             invokeRestart <- base::invokeRestart
[16:04:13.719]             length <- base::length
[16:04:13.719]             list <- base::list
[16:04:13.719]             seq.int <- base::seq.int
[16:04:13.719]             signalCondition <- base::signalCondition
[16:04:13.719]             sys.calls <- base::sys.calls
[16:04:13.719]             `[[` <- base::`[[`
[16:04:13.719]             `+` <- base::`+`
[16:04:13.719]             `<<-` <- base::`<<-`
[16:04:13.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:13.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:13.719]                   3L)]
[16:04:13.719]             }
[16:04:13.719]             function(cond) {
[16:04:13.719]                 is_error <- inherits(cond, "error")
[16:04:13.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:13.719]                   NULL)
[16:04:13.719]                 if (is_error) {
[16:04:13.719]                   sessionInformation <- function() {
[16:04:13.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:13.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:13.719]                       search = base::search(), system = base::Sys.info())
[16:04:13.719]                   }
[16:04:13.719]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:13.719]                     cond$call), session = sessionInformation(), 
[16:04:13.719]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:13.719]                   signalCondition(cond)
[16:04:13.719]                 }
[16:04:13.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:13.719]                 "immediateCondition"))) {
[16:04:13.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:13.719]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:13.719]                   if (TRUE && !signal) {
[16:04:13.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.719]                     {
[16:04:13.719]                       inherits <- base::inherits
[16:04:13.719]                       invokeRestart <- base::invokeRestart
[16:04:13.719]                       is.null <- base::is.null
[16:04:13.719]                       muffled <- FALSE
[16:04:13.719]                       if (inherits(cond, "message")) {
[16:04:13.719]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.719]                         if (muffled) 
[16:04:13.719]                           invokeRestart("muffleMessage")
[16:04:13.719]                       }
[16:04:13.719]                       else if (inherits(cond, "warning")) {
[16:04:13.719]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.719]                         if (muffled) 
[16:04:13.719]                           invokeRestart("muffleWarning")
[16:04:13.719]                       }
[16:04:13.719]                       else if (inherits(cond, "condition")) {
[16:04:13.719]                         if (!is.null(pattern)) {
[16:04:13.719]                           computeRestarts <- base::computeRestarts
[16:04:13.719]                           grepl <- base::grepl
[16:04:13.719]                           restarts <- computeRestarts(cond)
[16:04:13.719]                           for (restart in restarts) {
[16:04:13.719]                             name <- restart$name
[16:04:13.719]                             if (is.null(name)) 
[16:04:13.719]                               next
[16:04:13.719]                             if (!grepl(pattern, name)) 
[16:04:13.719]                               next
[16:04:13.719]                             invokeRestart(restart)
[16:04:13.719]                             muffled <- TRUE
[16:04:13.719]                             break
[16:04:13.719]                           }
[16:04:13.719]                         }
[16:04:13.719]                       }
[16:04:13.719]                       invisible(muffled)
[16:04:13.719]                     }
[16:04:13.719]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.719]                   }
[16:04:13.719]                 }
[16:04:13.719]                 else {
[16:04:13.719]                   if (TRUE) {
[16:04:13.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.719]                     {
[16:04:13.719]                       inherits <- base::inherits
[16:04:13.719]                       invokeRestart <- base::invokeRestart
[16:04:13.719]                       is.null <- base::is.null
[16:04:13.719]                       muffled <- FALSE
[16:04:13.719]                       if (inherits(cond, "message")) {
[16:04:13.719]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.719]                         if (muffled) 
[16:04:13.719]                           invokeRestart("muffleMessage")
[16:04:13.719]                       }
[16:04:13.719]                       else if (inherits(cond, "warning")) {
[16:04:13.719]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.719]                         if (muffled) 
[16:04:13.719]                           invokeRestart("muffleWarning")
[16:04:13.719]                       }
[16:04:13.719]                       else if (inherits(cond, "condition")) {
[16:04:13.719]                         if (!is.null(pattern)) {
[16:04:13.719]                           computeRestarts <- base::computeRestarts
[16:04:13.719]                           grepl <- base::grepl
[16:04:13.719]                           restarts <- computeRestarts(cond)
[16:04:13.719]                           for (restart in restarts) {
[16:04:13.719]                             name <- restart$name
[16:04:13.719]                             if (is.null(name)) 
[16:04:13.719]                               next
[16:04:13.719]                             if (!grepl(pattern, name)) 
[16:04:13.719]                               next
[16:04:13.719]                             invokeRestart(restart)
[16:04:13.719]                             muffled <- TRUE
[16:04:13.719]                             break
[16:04:13.719]                           }
[16:04:13.719]                         }
[16:04:13.719]                       }
[16:04:13.719]                       invisible(muffled)
[16:04:13.719]                     }
[16:04:13.719]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.719]                   }
[16:04:13.719]                 }
[16:04:13.719]             }
[16:04:13.719]         }))
[16:04:13.719]     }, error = function(ex) {
[16:04:13.719]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:13.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.719]                 ...future.rng), started = ...future.startTime, 
[16:04:13.719]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:13.719]             version = "1.8"), class = "FutureResult")
[16:04:13.719]     }, finally = {
[16:04:13.719]         if (!identical(...future.workdir, getwd())) 
[16:04:13.719]             setwd(...future.workdir)
[16:04:13.719]         {
[16:04:13.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:13.719]                 ...future.oldOptions$nwarnings <- NULL
[16:04:13.719]             }
[16:04:13.719]             base::options(...future.oldOptions)
[16:04:13.719]             if (.Platform$OS.type == "windows") {
[16:04:13.719]                 old_names <- names(...future.oldEnvVars)
[16:04:13.719]                 envs <- base::Sys.getenv()
[16:04:13.719]                 names <- names(envs)
[16:04:13.719]                 common <- intersect(names, old_names)
[16:04:13.719]                 added <- setdiff(names, old_names)
[16:04:13.719]                 removed <- setdiff(old_names, names)
[16:04:13.719]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:13.719]                   envs[common]]
[16:04:13.719]                 NAMES <- toupper(changed)
[16:04:13.719]                 args <- list()
[16:04:13.719]                 for (kk in seq_along(NAMES)) {
[16:04:13.719]                   name <- changed[[kk]]
[16:04:13.719]                   NAME <- NAMES[[kk]]
[16:04:13.719]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.719]                     next
[16:04:13.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.719]                 }
[16:04:13.719]                 NAMES <- toupper(added)
[16:04:13.719]                 for (kk in seq_along(NAMES)) {
[16:04:13.719]                   name <- added[[kk]]
[16:04:13.719]                   NAME <- NAMES[[kk]]
[16:04:13.719]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.719]                     next
[16:04:13.719]                   args[[name]] <- ""
[16:04:13.719]                 }
[16:04:13.719]                 NAMES <- toupper(removed)
[16:04:13.719]                 for (kk in seq_along(NAMES)) {
[16:04:13.719]                   name <- removed[[kk]]
[16:04:13.719]                   NAME <- NAMES[[kk]]
[16:04:13.719]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.719]                     next
[16:04:13.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.719]                 }
[16:04:13.719]                 if (length(args) > 0) 
[16:04:13.719]                   base::do.call(base::Sys.setenv, args = args)
[16:04:13.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:13.719]             }
[16:04:13.719]             else {
[16:04:13.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:13.719]             }
[16:04:13.719]             {
[16:04:13.719]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:13.719]                   0L) {
[16:04:13.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:13.719]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:13.719]                   base::options(opts)
[16:04:13.719]                 }
[16:04:13.719]                 {
[16:04:13.719]                   {
[16:04:13.719]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:13.719]                     NULL
[16:04:13.719]                   }
[16:04:13.719]                   options(future.plan = NULL)
[16:04:13.719]                   if (is.na(NA_character_)) 
[16:04:13.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:13.719]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:13.719]                     envir = parent.frame()) 
[16:04:13.719]                   {
[16:04:13.719]                     default_workers <- missing(workers)
[16:04:13.719]                     if (is.function(workers)) 
[16:04:13.719]                       workers <- workers()
[16:04:13.719]                     workers <- structure(as.integer(workers), 
[16:04:13.719]                       class = class(workers))
[16:04:13.719]                     stop_if_not(is.finite(workers), workers >= 
[16:04:13.719]                       1L)
[16:04:13.719]                     if ((workers == 1L && !inherits(workers, 
[16:04:13.719]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:13.719]                       if (default_workers) 
[16:04:13.719]                         supportsMulticore(warn = TRUE)
[16:04:13.719]                       return(sequential(..., envir = envir))
[16:04:13.719]                     }
[16:04:13.719]                     oopts <- options(mc.cores = workers)
[16:04:13.719]                     on.exit(options(oopts))
[16:04:13.719]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:13.719]                       envir = envir)
[16:04:13.719]                     if (!future$lazy) 
[16:04:13.719]                       future <- run(future)
[16:04:13.719]                     invisible(future)
[16:04:13.719]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:13.719]                 }
[16:04:13.719]             }
[16:04:13.719]         }
[16:04:13.719]     })
[16:04:13.719]     if (TRUE) {
[16:04:13.719]         base::sink(type = "output", split = FALSE)
[16:04:13.719]         if (TRUE) {
[16:04:13.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:13.719]         }
[16:04:13.719]         else {
[16:04:13.719]             ...future.result["stdout"] <- base::list(NULL)
[16:04:13.719]         }
[16:04:13.719]         base::close(...future.stdout)
[16:04:13.719]         ...future.stdout <- NULL
[16:04:13.719]     }
[16:04:13.719]     ...future.result$conditions <- ...future.conditions
[16:04:13.719]     ...future.result$finished <- base::Sys.time()
[16:04:13.719]     ...future.result
[16:04:13.719] }
[16:04:13.721] assign_globals() ...
[16:04:13.721] List of 4
[16:04:13.721]  $ ii   : int 1
[16:04:13.721]  $ n    : int 4
[16:04:13.721]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[16:04:13.721]   ..- attr(*, "region")=List of 2
[16:04:13.721]   .. ..$ xrange: num [1:2] -2.25 -0.781
[16:04:13.721]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[16:04:13.721]   ..- attr(*, "tile")= int [1:2] 1 1
[16:04:13.721]  $ delay:function (counts)  
[16:04:13.721]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:04:13.721]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55734648a950> 
[16:04:13.721]  - attr(*, "where")=List of 4
[16:04:13.721]   ..$ ii   :<environment: R_EmptyEnv> 
[16:04:13.721]   ..$ n    :<environment: R_EmptyEnv> 
[16:04:13.721]   ..$ C    :<environment: R_EmptyEnv> 
[16:04:13.721]   ..$ delay:<environment: R_EmptyEnv> 
[16:04:13.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:13.721]  - attr(*, "resolved")= logi FALSE
[16:04:13.721]  - attr(*, "total_size")= num 14584
[16:04:13.721]  - attr(*, "already-done")= logi TRUE
[16:04:13.727] - copied ‘ii’ to environment
[16:04:13.728] - copied ‘n’ to environment
[16:04:13.728] - copied ‘C’ to environment
[16:04:13.728] - reassign environment for ‘delay’
[16:04:13.728] - copied ‘delay’ to environment
[16:04:13.728] assign_globals() ... done
[16:04:13.728] requestCore(): workers = 2
[16:04:13.731] MulticoreFuture started
[16:04:13.732] - Launch lazy future ... done
[16:04:13.732] run() for ‘MulticoreFuture’ ... done
[16:04:13.732] - run() ... done
[16:04:13.732] - resolved() ...
[16:04:13.732] plan(): Setting new future strategy stack:
[16:04:13.733] List of future strategies:
[16:04:13.733] 1. sequential:
[16:04:13.733]    - args: function (..., envir = parent.frame())
[16:04:13.733]    - tweaked: FALSE
[16:04:13.733]    - call: NULL
[16:04:13.733] plan(): nbrOfWorkers() = 1
[16:04:13.737] plan(): Setting new future strategy stack:
[16:04:13.737] List of future strategies:
[16:04:13.737] 1. multicore:
[16:04:13.737]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:13.737]    - tweaked: FALSE
[16:04:13.737]    - call: plan(strategy)
[16:04:13.742] plan(): nbrOfWorkers() = 2
[16:04:13.743] - resolved: TRUE
[16:04:13.743] - resolved() ... done
[16:04:13.743] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #1 of 4 ...
[16:04:13.744] result() for MulticoreFuture ...
[16:04:13.749] result() for MulticoreFuture ...
[16:04:13.749] result() for MulticoreFuture ... done
[16:04:13.749] signalConditions() ...
[16:04:13.749]  - include = ‘immediateCondition’
[16:04:13.749]  - exclude = 
[16:04:13.749]  - resignal = FALSE
[16:04:13.749]  - Number of conditions: 2
[16:04:13.750] signalConditions() ... done
[16:04:13.750] result() for MulticoreFuture ... done
[16:04:13.750] result() for MulticoreFuture ...
[16:04:13.750] result() for MulticoreFuture ... done
[16:04:13.750] signalConditions() ...
[16:04:13.750]  - include = ‘immediateCondition’
[16:04:13.750]  - exclude = 
[16:04:13.750]  - resignal = FALSE
[16:04:13.750]  - Number of conditions: 2
[16:04:13.751] signalConditions() ... done
[16:04:13.751] Future state: ‘finished’
[16:04:13.751] result() for MulticoreFuture ...
[16:04:13.751] result() for MulticoreFuture ... done
[16:04:13.751] signalConditions() ...
[16:04:13.751]  - include = ‘condition’
[16:04:13.751]  - exclude = ‘immediateCondition’
[16:04:13.751]  - resignal = TRUE
[16:04:13.752]  - Number of conditions: 2
[16:04:13.752]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[16:04:13.752]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:04:13.752] signalConditions() ... done
[16:04:13.753] resolved() for ‘Future’ ...
[16:04:13.753] - state: ‘created’
[16:04:13.753] - run: TRUE
[16:04:13.753] - run() ...
[16:04:13.753] run() for ‘Future’ ...
[16:04:13.753] - state: ‘created’
[16:04:13.754] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:13.758] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:13.758] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:13.758]   - Field: ‘label’
[16:04:13.758]   - Field: ‘local’
[16:04:13.758]   - Field: ‘owner’
[16:04:13.759]   - Field: ‘envir’
[16:04:13.759]   - Field: ‘workers’
[16:04:13.759]   - Field: ‘packages’
[16:04:13.759]   - Field: ‘gc’
[16:04:13.759]   - Field: ‘job’
[16:04:13.759]   - Field: ‘conditions’
[16:04:13.759]   - Field: ‘expr’
[16:04:13.759]   - Field: ‘uuid’
[16:04:13.760]   - Field: ‘seed’
[16:04:13.760]   - Field: ‘version’
[16:04:13.760]   - Field: ‘result’
[16:04:13.760]   - Field: ‘asynchronous’
[16:04:13.760]   - Field: ‘calls’
[16:04:13.760]   - Field: ‘globals’
[16:04:13.760]   - Field: ‘stdout’
[16:04:13.760]   - Field: ‘earlySignal’
[16:04:13.760]   - Field: ‘lazy’
[16:04:13.760]   - Field: ‘state’
[16:04:13.761] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:13.761] - Launch lazy future ...
[16:04:13.761] Packages needed by the future expression (n = 1): ‘future’
[16:04:13.761] Packages needed by future strategies (n = 0): <none>
[16:04:13.762] {
[16:04:13.762]     {
[16:04:13.762]         {
[16:04:13.762]             ...future.startTime <- base::Sys.time()
[16:04:13.762]             {
[16:04:13.762]                 {
[16:04:13.762]                   {
[16:04:13.762]                     {
[16:04:13.762]                       {
[16:04:13.762]                         base::local({
[16:04:13.762]                           has_future <- base::requireNamespace("future", 
[16:04:13.762]                             quietly = TRUE)
[16:04:13.762]                           if (has_future) {
[16:04:13.762]                             ns <- base::getNamespace("future")
[16:04:13.762]                             version <- ns[[".package"]][["version"]]
[16:04:13.762]                             if (is.null(version)) 
[16:04:13.762]                               version <- utils::packageVersion("future")
[16:04:13.762]                           }
[16:04:13.762]                           else {
[16:04:13.762]                             version <- NULL
[16:04:13.762]                           }
[16:04:13.762]                           if (!has_future || version < "1.8.0") {
[16:04:13.762]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:13.762]                               "", base::R.version$version.string), 
[16:04:13.762]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:13.762]                                 base::R.version$platform, 8 * 
[16:04:13.762]                                   base::.Machine$sizeof.pointer), 
[16:04:13.762]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:13.762]                                 "release", "version")], collapse = " "), 
[16:04:13.762]                               hostname = base::Sys.info()[["nodename"]])
[16:04:13.762]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:13.762]                               info)
[16:04:13.762]                             info <- base::paste(info, collapse = "; ")
[16:04:13.762]                             if (!has_future) {
[16:04:13.762]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:13.762]                                 info)
[16:04:13.762]                             }
[16:04:13.762]                             else {
[16:04:13.762]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:13.762]                                 info, version)
[16:04:13.762]                             }
[16:04:13.762]                             base::stop(msg)
[16:04:13.762]                           }
[16:04:13.762]                         })
[16:04:13.762]                       }
[16:04:13.762]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:13.762]                       base::options(mc.cores = 1L)
[16:04:13.762]                     }
[16:04:13.762]                     base::local({
[16:04:13.762]                       for (pkg in "future") {
[16:04:13.762]                         base::loadNamespace(pkg)
[16:04:13.762]                         base::library(pkg, character.only = TRUE)
[16:04:13.762]                       }
[16:04:13.762]                     })
[16:04:13.762]                   }
[16:04:13.762]                   options(future.plan = NULL)
[16:04:13.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:13.762]                 }
[16:04:13.762]                 ...future.workdir <- getwd()
[16:04:13.762]             }
[16:04:13.762]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:13.762]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:13.762]         }
[16:04:13.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:13.762]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:13.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:13.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:13.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:13.762]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:13.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:13.762]             base::names(...future.oldOptions))
[16:04:13.762]     }
[16:04:13.762]     if (FALSE) {
[16:04:13.762]     }
[16:04:13.762]     else {
[16:04:13.762]         if (TRUE) {
[16:04:13.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:13.762]                 open = "w")
[16:04:13.762]         }
[16:04:13.762]         else {
[16:04:13.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:13.762]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:13.762]         }
[16:04:13.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:13.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:13.762]             base::sink(type = "output", split = FALSE)
[16:04:13.762]             base::close(...future.stdout)
[16:04:13.762]         }, add = TRUE)
[16:04:13.762]     }
[16:04:13.762]     ...future.frame <- base::sys.nframe()
[16:04:13.762]     ...future.conditions <- base::list()
[16:04:13.762]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:13.762]     if (FALSE) {
[16:04:13.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:13.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:13.762]     }
[16:04:13.762]     ...future.result <- base::tryCatch({
[16:04:13.762]         base::withCallingHandlers({
[16:04:13.762]             ...future.value <- base::withVisible(base::local({
[16:04:13.762]                 withCallingHandlers({
[16:04:13.762]                   {
[16:04:13.762]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:04:13.762]                       ii, n), appendLF = FALSE)
[16:04:13.762]                     fit <- mandelbrot(C)
[16:04:13.762]                     delay(fit)
[16:04:13.762]                     message(" done")
[16:04:13.762]                     fit
[16:04:13.762]                   }
[16:04:13.762]                 }, immediateCondition = function(cond) {
[16:04:13.762]                   save_rds <- function (object, pathname, ...) 
[16:04:13.762]                   {
[16:04:13.762]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:13.762]                     if (file_test("-f", pathname_tmp)) {
[16:04:13.762]                       fi_tmp <- file.info(pathname_tmp)
[16:04:13.762]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:13.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:13.762]                         fi_tmp[["mtime"]])
[16:04:13.762]                     }
[16:04:13.762]                     tryCatch({
[16:04:13.762]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:13.762]                     }, error = function(ex) {
[16:04:13.762]                       msg <- conditionMessage(ex)
[16:04:13.762]                       fi_tmp <- file.info(pathname_tmp)
[16:04:13.762]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:13.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:13.762]                         fi_tmp[["mtime"]], msg)
[16:04:13.762]                       ex$message <- msg
[16:04:13.762]                       stop(ex)
[16:04:13.762]                     })
[16:04:13.762]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:13.762]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:13.762]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:13.762]                       fi_tmp <- file.info(pathname_tmp)
[16:04:13.762]                       fi <- file.info(pathname)
[16:04:13.762]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:13.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:13.762]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:13.762]                         fi[["size"]], fi[["mtime"]])
[16:04:13.762]                       stop(msg)
[16:04:13.762]                     }
[16:04:13.762]                     invisible(pathname)
[16:04:13.762]                   }
[16:04:13.762]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:13.762]                     rootPath = tempdir()) 
[16:04:13.762]                   {
[16:04:13.762]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:13.762]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:13.762]                       tmpdir = path, fileext = ".rds")
[16:04:13.762]                     save_rds(obj, file)
[16:04:13.762]                   }
[16:04:13.762]                   saveImmediateCondition(cond, path = "/tmp/RtmpugdtX0/.future/immediateConditions")
[16:04:13.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.762]                   {
[16:04:13.762]                     inherits <- base::inherits
[16:04:13.762]                     invokeRestart <- base::invokeRestart
[16:04:13.762]                     is.null <- base::is.null
[16:04:13.762]                     muffled <- FALSE
[16:04:13.762]                     if (inherits(cond, "message")) {
[16:04:13.762]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:13.762]                       if (muffled) 
[16:04:13.762]                         invokeRestart("muffleMessage")
[16:04:13.762]                     }
[16:04:13.762]                     else if (inherits(cond, "warning")) {
[16:04:13.762]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:13.762]                       if (muffled) 
[16:04:13.762]                         invokeRestart("muffleWarning")
[16:04:13.762]                     }
[16:04:13.762]                     else if (inherits(cond, "condition")) {
[16:04:13.762]                       if (!is.null(pattern)) {
[16:04:13.762]                         computeRestarts <- base::computeRestarts
[16:04:13.762]                         grepl <- base::grepl
[16:04:13.762]                         restarts <- computeRestarts(cond)
[16:04:13.762]                         for (restart in restarts) {
[16:04:13.762]                           name <- restart$name
[16:04:13.762]                           if (is.null(name)) 
[16:04:13.762]                             next
[16:04:13.762]                           if (!grepl(pattern, name)) 
[16:04:13.762]                             next
[16:04:13.762]                           invokeRestart(restart)
[16:04:13.762]                           muffled <- TRUE
[16:04:13.762]                           break
[16:04:13.762]                         }
[16:04:13.762]                       }
[16:04:13.762]                     }
[16:04:13.762]                     invisible(muffled)
[16:04:13.762]                   }
[16:04:13.762]                   muffleCondition(cond)
[16:04:13.762]                 })
[16:04:13.762]             }))
[16:04:13.762]             future::FutureResult(value = ...future.value$value, 
[16:04:13.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.762]                   ...future.rng), globalenv = if (FALSE) 
[16:04:13.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:13.762]                     ...future.globalenv.names))
[16:04:13.762]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:13.762]         }, condition = base::local({
[16:04:13.762]             c <- base::c
[16:04:13.762]             inherits <- base::inherits
[16:04:13.762]             invokeRestart <- base::invokeRestart
[16:04:13.762]             length <- base::length
[16:04:13.762]             list <- base::list
[16:04:13.762]             seq.int <- base::seq.int
[16:04:13.762]             signalCondition <- base::signalCondition
[16:04:13.762]             sys.calls <- base::sys.calls
[16:04:13.762]             `[[` <- base::`[[`
[16:04:13.762]             `+` <- base::`+`
[16:04:13.762]             `<<-` <- base::`<<-`
[16:04:13.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:13.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:13.762]                   3L)]
[16:04:13.762]             }
[16:04:13.762]             function(cond) {
[16:04:13.762]                 is_error <- inherits(cond, "error")
[16:04:13.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:13.762]                   NULL)
[16:04:13.762]                 if (is_error) {
[16:04:13.762]                   sessionInformation <- function() {
[16:04:13.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:13.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:13.762]                       search = base::search(), system = base::Sys.info())
[16:04:13.762]                   }
[16:04:13.762]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:13.762]                     cond$call), session = sessionInformation(), 
[16:04:13.762]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:13.762]                   signalCondition(cond)
[16:04:13.762]                 }
[16:04:13.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:13.762]                 "immediateCondition"))) {
[16:04:13.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:13.762]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:13.762]                   if (TRUE && !signal) {
[16:04:13.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.762]                     {
[16:04:13.762]                       inherits <- base::inherits
[16:04:13.762]                       invokeRestart <- base::invokeRestart
[16:04:13.762]                       is.null <- base::is.null
[16:04:13.762]                       muffled <- FALSE
[16:04:13.762]                       if (inherits(cond, "message")) {
[16:04:13.762]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.762]                         if (muffled) 
[16:04:13.762]                           invokeRestart("muffleMessage")
[16:04:13.762]                       }
[16:04:13.762]                       else if (inherits(cond, "warning")) {
[16:04:13.762]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.762]                         if (muffled) 
[16:04:13.762]                           invokeRestart("muffleWarning")
[16:04:13.762]                       }
[16:04:13.762]                       else if (inherits(cond, "condition")) {
[16:04:13.762]                         if (!is.null(pattern)) {
[16:04:13.762]                           computeRestarts <- base::computeRestarts
[16:04:13.762]                           grepl <- base::grepl
[16:04:13.762]                           restarts <- computeRestarts(cond)
[16:04:13.762]                           for (restart in restarts) {
[16:04:13.762]                             name <- restart$name
[16:04:13.762]                             if (is.null(name)) 
[16:04:13.762]                               next
[16:04:13.762]                             if (!grepl(pattern, name)) 
[16:04:13.762]                               next
[16:04:13.762]                             invokeRestart(restart)
[16:04:13.762]                             muffled <- TRUE
[16:04:13.762]                             break
[16:04:13.762]                           }
[16:04:13.762]                         }
[16:04:13.762]                       }
[16:04:13.762]                       invisible(muffled)
[16:04:13.762]                     }
[16:04:13.762]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.762]                   }
[16:04:13.762]                 }
[16:04:13.762]                 else {
[16:04:13.762]                   if (TRUE) {
[16:04:13.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.762]                     {
[16:04:13.762]                       inherits <- base::inherits
[16:04:13.762]                       invokeRestart <- base::invokeRestart
[16:04:13.762]                       is.null <- base::is.null
[16:04:13.762]                       muffled <- FALSE
[16:04:13.762]                       if (inherits(cond, "message")) {
[16:04:13.762]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.762]                         if (muffled) 
[16:04:13.762]                           invokeRestart("muffleMessage")
[16:04:13.762]                       }
[16:04:13.762]                       else if (inherits(cond, "warning")) {
[16:04:13.762]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.762]                         if (muffled) 
[16:04:13.762]                           invokeRestart("muffleWarning")
[16:04:13.762]                       }
[16:04:13.762]                       else if (inherits(cond, "condition")) {
[16:04:13.762]                         if (!is.null(pattern)) {
[16:04:13.762]                           computeRestarts <- base::computeRestarts
[16:04:13.762]                           grepl <- base::grepl
[16:04:13.762]                           restarts <- computeRestarts(cond)
[16:04:13.762]                           for (restart in restarts) {
[16:04:13.762]                             name <- restart$name
[16:04:13.762]                             if (is.null(name)) 
[16:04:13.762]                               next
[16:04:13.762]                             if (!grepl(pattern, name)) 
[16:04:13.762]                               next
[16:04:13.762]                             invokeRestart(restart)
[16:04:13.762]                             muffled <- TRUE
[16:04:13.762]                             break
[16:04:13.762]                           }
[16:04:13.762]                         }
[16:04:13.762]                       }
[16:04:13.762]                       invisible(muffled)
[16:04:13.762]                     }
[16:04:13.762]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.762]                   }
[16:04:13.762]                 }
[16:04:13.762]             }
[16:04:13.762]         }))
[16:04:13.762]     }, error = function(ex) {
[16:04:13.762]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:13.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.762]                 ...future.rng), started = ...future.startTime, 
[16:04:13.762]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:13.762]             version = "1.8"), class = "FutureResult")
[16:04:13.762]     }, finally = {
[16:04:13.762]         if (!identical(...future.workdir, getwd())) 
[16:04:13.762]             setwd(...future.workdir)
[16:04:13.762]         {
[16:04:13.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:13.762]                 ...future.oldOptions$nwarnings <- NULL
[16:04:13.762]             }
[16:04:13.762]             base::options(...future.oldOptions)
[16:04:13.762]             if (.Platform$OS.type == "windows") {
[16:04:13.762]                 old_names <- names(...future.oldEnvVars)
[16:04:13.762]                 envs <- base::Sys.getenv()
[16:04:13.762]                 names <- names(envs)
[16:04:13.762]                 common <- intersect(names, old_names)
[16:04:13.762]                 added <- setdiff(names, old_names)
[16:04:13.762]                 removed <- setdiff(old_names, names)
[16:04:13.762]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:13.762]                   envs[common]]
[16:04:13.762]                 NAMES <- toupper(changed)
[16:04:13.762]                 args <- list()
[16:04:13.762]                 for (kk in seq_along(NAMES)) {
[16:04:13.762]                   name <- changed[[kk]]
[16:04:13.762]                   NAME <- NAMES[[kk]]
[16:04:13.762]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.762]                     next
[16:04:13.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.762]                 }
[16:04:13.762]                 NAMES <- toupper(added)
[16:04:13.762]                 for (kk in seq_along(NAMES)) {
[16:04:13.762]                   name <- added[[kk]]
[16:04:13.762]                   NAME <- NAMES[[kk]]
[16:04:13.762]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.762]                     next
[16:04:13.762]                   args[[name]] <- ""
[16:04:13.762]                 }
[16:04:13.762]                 NAMES <- toupper(removed)
[16:04:13.762]                 for (kk in seq_along(NAMES)) {
[16:04:13.762]                   name <- removed[[kk]]
[16:04:13.762]                   NAME <- NAMES[[kk]]
[16:04:13.762]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.762]                     next
[16:04:13.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.762]                 }
[16:04:13.762]                 if (length(args) > 0) 
[16:04:13.762]                   base::do.call(base::Sys.setenv, args = args)
[16:04:13.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:13.762]             }
[16:04:13.762]             else {
[16:04:13.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:13.762]             }
[16:04:13.762]             {
[16:04:13.762]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:13.762]                   0L) {
[16:04:13.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:13.762]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:13.762]                   base::options(opts)
[16:04:13.762]                 }
[16:04:13.762]                 {
[16:04:13.762]                   {
[16:04:13.762]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:13.762]                     NULL
[16:04:13.762]                   }
[16:04:13.762]                   options(future.plan = NULL)
[16:04:13.762]                   if (is.na(NA_character_)) 
[16:04:13.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:13.762]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:13.762]                     envir = parent.frame()) 
[16:04:13.762]                   {
[16:04:13.762]                     default_workers <- missing(workers)
[16:04:13.762]                     if (is.function(workers)) 
[16:04:13.762]                       workers <- workers()
[16:04:13.762]                     workers <- structure(as.integer(workers), 
[16:04:13.762]                       class = class(workers))
[16:04:13.762]                     stop_if_not(is.finite(workers), workers >= 
[16:04:13.762]                       1L)
[16:04:13.762]                     if ((workers == 1L && !inherits(workers, 
[16:04:13.762]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:13.762]                       if (default_workers) 
[16:04:13.762]                         supportsMulticore(warn = TRUE)
[16:04:13.762]                       return(sequential(..., envir = envir))
[16:04:13.762]                     }
[16:04:13.762]                     oopts <- options(mc.cores = workers)
[16:04:13.762]                     on.exit(options(oopts))
[16:04:13.762]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:13.762]                       envir = envir)
[16:04:13.762]                     if (!future$lazy) 
[16:04:13.762]                       future <- run(future)
[16:04:13.762]                     invisible(future)
[16:04:13.762]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:13.762]                 }
[16:04:13.762]             }
[16:04:13.762]         }
[16:04:13.762]     })
[16:04:13.762]     if (TRUE) {
[16:04:13.762]         base::sink(type = "output", split = FALSE)
[16:04:13.762]         if (TRUE) {
[16:04:13.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:13.762]         }
[16:04:13.762]         else {
[16:04:13.762]             ...future.result["stdout"] <- base::list(NULL)
[16:04:13.762]         }
[16:04:13.762]         base::close(...future.stdout)
[16:04:13.762]         ...future.stdout <- NULL
[16:04:13.762]     }
[16:04:13.762]     ...future.result$conditions <- ...future.conditions
[16:04:13.762]     ...future.result$finished <- base::Sys.time()
[16:04:13.762]     ...future.result
[16:04:13.762] }
[16:04:13.765] assign_globals() ...
[16:04:13.765] List of 4
[16:04:13.765]  $ ii   : int 2
[16:04:13.765]  $ n    : int 4
[16:04:13.765]  $ C    : cplx [1:25, 1:25] -0.72-1.5i -0.72-1.44i -0.72-1.38i ...
[16:04:13.765]   ..- attr(*, "region")=List of 2
[16:04:13.765]   .. ..$ xrange: num [1:2] -0.719 0.75
[16:04:13.765]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[16:04:13.765]   ..- attr(*, "tile")= int [1:2] 1 2
[16:04:13.765]  $ delay:function (counts)  
[16:04:13.765]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:04:13.765]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55734648a950> 
[16:04:13.765]  - attr(*, "where")=List of 4
[16:04:13.765]   ..$ ii   :<environment: R_EmptyEnv> 
[16:04:13.765]   ..$ n    :<environment: R_EmptyEnv> 
[16:04:13.765]   ..$ C    :<environment: R_EmptyEnv> 
[16:04:13.765]   ..$ delay:<environment: R_EmptyEnv> 
[16:04:13.765]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:13.765]  - attr(*, "resolved")= logi FALSE
[16:04:13.765]  - attr(*, "total_size")= num 14584
[16:04:13.765]  - attr(*, "already-done")= logi TRUE
[16:04:13.775] - copied ‘ii’ to environment
[16:04:13.775] - copied ‘n’ to environment
[16:04:13.776] - copied ‘C’ to environment
[16:04:13.776] - reassign environment for ‘delay’
[16:04:13.776] - copied ‘delay’ to environment
[16:04:13.776] assign_globals() ... done
[16:04:13.776] requestCore(): workers = 2
[16:04:13.778] MulticoreFuture started
[16:04:13.779] - Launch lazy future ... done
[16:04:13.779] run() for ‘MulticoreFuture’ ... done
[16:04:13.779] - run() ... done
[16:04:13.779] - resolved() ...
[16:04:13.780] plan(): Setting new future strategy stack:
[16:04:13.780] List of future strategies:
[16:04:13.780] 1. sequential:
[16:04:13.780]    - args: function (..., envir = parent.frame())
[16:04:13.780]    - tweaked: FALSE
[16:04:13.780]    - call: NULL
[16:04:13.781] plan(): nbrOfWorkers() = 1
[16:04:13.787] plan(): Setting new future strategy stack:
[16:04:13.787] List of future strategies:
[16:04:13.787] 1. multicore:
[16:04:13.787]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:13.787]    - tweaked: FALSE
[16:04:13.787]    - call: plan(strategy)
[16:04:13.790] - resolved: FALSE
[16:04:13.790] - resolved() ... done
[16:04:13.790] resolved() for ‘MulticoreFuture’ ... done
[16:04:13.791] resolved() for ‘Future’ ...
[16:04:13.791] - state: ‘created’
[16:04:13.791] - run: TRUE
[16:04:13.791] - run() ...
[16:04:13.791] run() for ‘Future’ ...
[16:04:13.791] - state: ‘created’
[16:04:13.792] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:13.792] plan(): nbrOfWorkers() = 2
[16:04:13.796] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:13.796] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:13.797]   - Field: ‘label’
[16:04:13.797]   - Field: ‘local’
[16:04:13.797]   - Field: ‘owner’
[16:04:13.797]   - Field: ‘envir’
[16:04:13.797]   - Field: ‘workers’
[16:04:13.797]   - Field: ‘packages’
[16:04:13.798]   - Field: ‘gc’
[16:04:13.798]   - Field: ‘job’
[16:04:13.798]   - Field: ‘conditions’
[16:04:13.798]   - Field: ‘expr’
[16:04:13.798]   - Field: ‘uuid’
[16:04:13.798]   - Field: ‘seed’
[16:04:13.799]   - Field: ‘version’
[16:04:13.799]   - Field: ‘result’
[16:04:13.799]   - Field: ‘asynchronous’
[16:04:13.799]   - Field: ‘calls’
[16:04:13.799]   - Field: ‘globals’
[16:04:13.799]   - Field: ‘stdout’
[16:04:13.800]   - Field: ‘earlySignal’
[16:04:13.800]   - Field: ‘lazy’
[16:04:13.800]   - Field: ‘state’
[16:04:13.800] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:13.800] - Launch lazy future ...
[16:04:13.801] Packages needed by the future expression (n = 1): ‘future’
[16:04:13.801] Packages needed by future strategies (n = 0): <none>
[16:04:13.802] {
[16:04:13.802]     {
[16:04:13.802]         {
[16:04:13.802]             ...future.startTime <- base::Sys.time()
[16:04:13.802]             {
[16:04:13.802]                 {
[16:04:13.802]                   {
[16:04:13.802]                     {
[16:04:13.802]                       {
[16:04:13.802]                         base::local({
[16:04:13.802]                           has_future <- base::requireNamespace("future", 
[16:04:13.802]                             quietly = TRUE)
[16:04:13.802]                           if (has_future) {
[16:04:13.802]                             ns <- base::getNamespace("future")
[16:04:13.802]                             version <- ns[[".package"]][["version"]]
[16:04:13.802]                             if (is.null(version)) 
[16:04:13.802]                               version <- utils::packageVersion("future")
[16:04:13.802]                           }
[16:04:13.802]                           else {
[16:04:13.802]                             version <- NULL
[16:04:13.802]                           }
[16:04:13.802]                           if (!has_future || version < "1.8.0") {
[16:04:13.802]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:13.802]                               "", base::R.version$version.string), 
[16:04:13.802]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:13.802]                                 base::R.version$platform, 8 * 
[16:04:13.802]                                   base::.Machine$sizeof.pointer), 
[16:04:13.802]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:13.802]                                 "release", "version")], collapse = " "), 
[16:04:13.802]                               hostname = base::Sys.info()[["nodename"]])
[16:04:13.802]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:13.802]                               info)
[16:04:13.802]                             info <- base::paste(info, collapse = "; ")
[16:04:13.802]                             if (!has_future) {
[16:04:13.802]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:13.802]                                 info)
[16:04:13.802]                             }
[16:04:13.802]                             else {
[16:04:13.802]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:13.802]                                 info, version)
[16:04:13.802]                             }
[16:04:13.802]                             base::stop(msg)
[16:04:13.802]                           }
[16:04:13.802]                         })
[16:04:13.802]                       }
[16:04:13.802]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:13.802]                       base::options(mc.cores = 1L)
[16:04:13.802]                     }
[16:04:13.802]                     base::local({
[16:04:13.802]                       for (pkg in "future") {
[16:04:13.802]                         base::loadNamespace(pkg)
[16:04:13.802]                         base::library(pkg, character.only = TRUE)
[16:04:13.802]                       }
[16:04:13.802]                     })
[16:04:13.802]                   }
[16:04:13.802]                   options(future.plan = NULL)
[16:04:13.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:13.802]                 }
[16:04:13.802]                 ...future.workdir <- getwd()
[16:04:13.802]             }
[16:04:13.802]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:13.802]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:13.802]         }
[16:04:13.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:13.802]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:13.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:13.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:13.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:13.802]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:13.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:13.802]             base::names(...future.oldOptions))
[16:04:13.802]     }
[16:04:13.802]     if (FALSE) {
[16:04:13.802]     }
[16:04:13.802]     else {
[16:04:13.802]         if (TRUE) {
[16:04:13.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:13.802]                 open = "w")
[16:04:13.802]         }
[16:04:13.802]         else {
[16:04:13.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:13.802]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:13.802]         }
[16:04:13.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:13.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:13.802]             base::sink(type = "output", split = FALSE)
[16:04:13.802]             base::close(...future.stdout)
[16:04:13.802]         }, add = TRUE)
[16:04:13.802]     }
[16:04:13.802]     ...future.frame <- base::sys.nframe()
[16:04:13.802]     ...future.conditions <- base::list()
[16:04:13.802]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:13.802]     if (FALSE) {
[16:04:13.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:13.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:13.802]     }
[16:04:13.802]     ...future.result <- base::tryCatch({
[16:04:13.802]         base::withCallingHandlers({
[16:04:13.802]             ...future.value <- base::withVisible(base::local({
[16:04:13.802]                 withCallingHandlers({
[16:04:13.802]                   {
[16:04:13.802]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:04:13.802]                       ii, n), appendLF = FALSE)
[16:04:13.802]                     fit <- mandelbrot(C)
[16:04:13.802]                     delay(fit)
[16:04:13.802]                     message(" done")
[16:04:13.802]                     fit
[16:04:13.802]                   }
[16:04:13.802]                 }, immediateCondition = function(cond) {
[16:04:13.802]                   save_rds <- function (object, pathname, ...) 
[16:04:13.802]                   {
[16:04:13.802]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:13.802]                     if (file_test("-f", pathname_tmp)) {
[16:04:13.802]                       fi_tmp <- file.info(pathname_tmp)
[16:04:13.802]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:13.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:13.802]                         fi_tmp[["mtime"]])
[16:04:13.802]                     }
[16:04:13.802]                     tryCatch({
[16:04:13.802]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:13.802]                     }, error = function(ex) {
[16:04:13.802]                       msg <- conditionMessage(ex)
[16:04:13.802]                       fi_tmp <- file.info(pathname_tmp)
[16:04:13.802]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:13.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:13.802]                         fi_tmp[["mtime"]], msg)
[16:04:13.802]                       ex$message <- msg
[16:04:13.802]                       stop(ex)
[16:04:13.802]                     })
[16:04:13.802]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:13.802]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:13.802]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:13.802]                       fi_tmp <- file.info(pathname_tmp)
[16:04:13.802]                       fi <- file.info(pathname)
[16:04:13.802]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:13.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:13.802]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:13.802]                         fi[["size"]], fi[["mtime"]])
[16:04:13.802]                       stop(msg)
[16:04:13.802]                     }
[16:04:13.802]                     invisible(pathname)
[16:04:13.802]                   }
[16:04:13.802]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:13.802]                     rootPath = tempdir()) 
[16:04:13.802]                   {
[16:04:13.802]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:13.802]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:13.802]                       tmpdir = path, fileext = ".rds")
[16:04:13.802]                     save_rds(obj, file)
[16:04:13.802]                   }
[16:04:13.802]                   saveImmediateCondition(cond, path = "/tmp/RtmpugdtX0/.future/immediateConditions")
[16:04:13.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.802]                   {
[16:04:13.802]                     inherits <- base::inherits
[16:04:13.802]                     invokeRestart <- base::invokeRestart
[16:04:13.802]                     is.null <- base::is.null
[16:04:13.802]                     muffled <- FALSE
[16:04:13.802]                     if (inherits(cond, "message")) {
[16:04:13.802]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:13.802]                       if (muffled) 
[16:04:13.802]                         invokeRestart("muffleMessage")
[16:04:13.802]                     }
[16:04:13.802]                     else if (inherits(cond, "warning")) {
[16:04:13.802]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:13.802]                       if (muffled) 
[16:04:13.802]                         invokeRestart("muffleWarning")
[16:04:13.802]                     }
[16:04:13.802]                     else if (inherits(cond, "condition")) {
[16:04:13.802]                       if (!is.null(pattern)) {
[16:04:13.802]                         computeRestarts <- base::computeRestarts
[16:04:13.802]                         grepl <- base::grepl
[16:04:13.802]                         restarts <- computeRestarts(cond)
[16:04:13.802]                         for (restart in restarts) {
[16:04:13.802]                           name <- restart$name
[16:04:13.802]                           if (is.null(name)) 
[16:04:13.802]                             next
[16:04:13.802]                           if (!grepl(pattern, name)) 
[16:04:13.802]                             next
[16:04:13.802]                           invokeRestart(restart)
[16:04:13.802]                           muffled <- TRUE
[16:04:13.802]                           break
[16:04:13.802]                         }
[16:04:13.802]                       }
[16:04:13.802]                     }
[16:04:13.802]                     invisible(muffled)
[16:04:13.802]                   }
[16:04:13.802]                   muffleCondition(cond)
[16:04:13.802]                 })
[16:04:13.802]             }))
[16:04:13.802]             future::FutureResult(value = ...future.value$value, 
[16:04:13.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.802]                   ...future.rng), globalenv = if (FALSE) 
[16:04:13.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:13.802]                     ...future.globalenv.names))
[16:04:13.802]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:13.802]         }, condition = base::local({
[16:04:13.802]             c <- base::c
[16:04:13.802]             inherits <- base::inherits
[16:04:13.802]             invokeRestart <- base::invokeRestart
[16:04:13.802]             length <- base::length
[16:04:13.802]             list <- base::list
[16:04:13.802]             seq.int <- base::seq.int
[16:04:13.802]             signalCondition <- base::signalCondition
[16:04:13.802]             sys.calls <- base::sys.calls
[16:04:13.802]             `[[` <- base::`[[`
[16:04:13.802]             `+` <- base::`+`
[16:04:13.802]             `<<-` <- base::`<<-`
[16:04:13.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:13.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:13.802]                   3L)]
[16:04:13.802]             }
[16:04:13.802]             function(cond) {
[16:04:13.802]                 is_error <- inherits(cond, "error")
[16:04:13.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:13.802]                   NULL)
[16:04:13.802]                 if (is_error) {
[16:04:13.802]                   sessionInformation <- function() {
[16:04:13.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:13.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:13.802]                       search = base::search(), system = base::Sys.info())
[16:04:13.802]                   }
[16:04:13.802]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:13.802]                     cond$call), session = sessionInformation(), 
[16:04:13.802]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:13.802]                   signalCondition(cond)
[16:04:13.802]                 }
[16:04:13.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:13.802]                 "immediateCondition"))) {
[16:04:13.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:13.802]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:13.802]                   if (TRUE && !signal) {
[16:04:13.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.802]                     {
[16:04:13.802]                       inherits <- base::inherits
[16:04:13.802]                       invokeRestart <- base::invokeRestart
[16:04:13.802]                       is.null <- base::is.null
[16:04:13.802]                       muffled <- FALSE
[16:04:13.802]                       if (inherits(cond, "message")) {
[16:04:13.802]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.802]                         if (muffled) 
[16:04:13.802]                           invokeRestart("muffleMessage")
[16:04:13.802]                       }
[16:04:13.802]                       else if (inherits(cond, "warning")) {
[16:04:13.802]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.802]                         if (muffled) 
[16:04:13.802]                           invokeRestart("muffleWarning")
[16:04:13.802]                       }
[16:04:13.802]                       else if (inherits(cond, "condition")) {
[16:04:13.802]                         if (!is.null(pattern)) {
[16:04:13.802]                           computeRestarts <- base::computeRestarts
[16:04:13.802]                           grepl <- base::grepl
[16:04:13.802]                           restarts <- computeRestarts(cond)
[16:04:13.802]                           for (restart in restarts) {
[16:04:13.802]                             name <- restart$name
[16:04:13.802]                             if (is.null(name)) 
[16:04:13.802]                               next
[16:04:13.802]                             if (!grepl(pattern, name)) 
[16:04:13.802]                               next
[16:04:13.802]                             invokeRestart(restart)
[16:04:13.802]                             muffled <- TRUE
[16:04:13.802]                             break
[16:04:13.802]                           }
[16:04:13.802]                         }
[16:04:13.802]                       }
[16:04:13.802]                       invisible(muffled)
[16:04:13.802]                     }
[16:04:13.802]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.802]                   }
[16:04:13.802]                 }
[16:04:13.802]                 else {
[16:04:13.802]                   if (TRUE) {
[16:04:13.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.802]                     {
[16:04:13.802]                       inherits <- base::inherits
[16:04:13.802]                       invokeRestart <- base::invokeRestart
[16:04:13.802]                       is.null <- base::is.null
[16:04:13.802]                       muffled <- FALSE
[16:04:13.802]                       if (inherits(cond, "message")) {
[16:04:13.802]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.802]                         if (muffled) 
[16:04:13.802]                           invokeRestart("muffleMessage")
[16:04:13.802]                       }
[16:04:13.802]                       else if (inherits(cond, "warning")) {
[16:04:13.802]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.802]                         if (muffled) 
[16:04:13.802]                           invokeRestart("muffleWarning")
[16:04:13.802]                       }
[16:04:13.802]                       else if (inherits(cond, "condition")) {
[16:04:13.802]                         if (!is.null(pattern)) {
[16:04:13.802]                           computeRestarts <- base::computeRestarts
[16:04:13.802]                           grepl <- base::grepl
[16:04:13.802]                           restarts <- computeRestarts(cond)
[16:04:13.802]                           for (restart in restarts) {
[16:04:13.802]                             name <- restart$name
[16:04:13.802]                             if (is.null(name)) 
[16:04:13.802]                               next
[16:04:13.802]                             if (!grepl(pattern, name)) 
[16:04:13.802]                               next
[16:04:13.802]                             invokeRestart(restart)
[16:04:13.802]                             muffled <- TRUE
[16:04:13.802]                             break
[16:04:13.802]                           }
[16:04:13.802]                         }
[16:04:13.802]                       }
[16:04:13.802]                       invisible(muffled)
[16:04:13.802]                     }
[16:04:13.802]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.802]                   }
[16:04:13.802]                 }
[16:04:13.802]             }
[16:04:13.802]         }))
[16:04:13.802]     }, error = function(ex) {
[16:04:13.802]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:13.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.802]                 ...future.rng), started = ...future.startTime, 
[16:04:13.802]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:13.802]             version = "1.8"), class = "FutureResult")
[16:04:13.802]     }, finally = {
[16:04:13.802]         if (!identical(...future.workdir, getwd())) 
[16:04:13.802]             setwd(...future.workdir)
[16:04:13.802]         {
[16:04:13.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:13.802]                 ...future.oldOptions$nwarnings <- NULL
[16:04:13.802]             }
[16:04:13.802]             base::options(...future.oldOptions)
[16:04:13.802]             if (.Platform$OS.type == "windows") {
[16:04:13.802]                 old_names <- names(...future.oldEnvVars)
[16:04:13.802]                 envs <- base::Sys.getenv()
[16:04:13.802]                 names <- names(envs)
[16:04:13.802]                 common <- intersect(names, old_names)
[16:04:13.802]                 added <- setdiff(names, old_names)
[16:04:13.802]                 removed <- setdiff(old_names, names)
[16:04:13.802]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:13.802]                   envs[common]]
[16:04:13.802]                 NAMES <- toupper(changed)
[16:04:13.802]                 args <- list()
[16:04:13.802]                 for (kk in seq_along(NAMES)) {
[16:04:13.802]                   name <- changed[[kk]]
[16:04:13.802]                   NAME <- NAMES[[kk]]
[16:04:13.802]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.802]                     next
[16:04:13.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.802]                 }
[16:04:13.802]                 NAMES <- toupper(added)
[16:04:13.802]                 for (kk in seq_along(NAMES)) {
[16:04:13.802]                   name <- added[[kk]]
[16:04:13.802]                   NAME <- NAMES[[kk]]
[16:04:13.802]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.802]                     next
[16:04:13.802]                   args[[name]] <- ""
[16:04:13.802]                 }
[16:04:13.802]                 NAMES <- toupper(removed)
[16:04:13.802]                 for (kk in seq_along(NAMES)) {
[16:04:13.802]                   name <- removed[[kk]]
[16:04:13.802]                   NAME <- NAMES[[kk]]
[16:04:13.802]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.802]                     next
[16:04:13.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.802]                 }
[16:04:13.802]                 if (length(args) > 0) 
[16:04:13.802]                   base::do.call(base::Sys.setenv, args = args)
[16:04:13.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:13.802]             }
[16:04:13.802]             else {
[16:04:13.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:13.802]             }
[16:04:13.802]             {
[16:04:13.802]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:13.802]                   0L) {
[16:04:13.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:13.802]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:13.802]                   base::options(opts)
[16:04:13.802]                 }
[16:04:13.802]                 {
[16:04:13.802]                   {
[16:04:13.802]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:13.802]                     NULL
[16:04:13.802]                   }
[16:04:13.802]                   options(future.plan = NULL)
[16:04:13.802]                   if (is.na(NA_character_)) 
[16:04:13.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:13.802]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:13.802]                     envir = parent.frame()) 
[16:04:13.802]                   {
[16:04:13.802]                     default_workers <- missing(workers)
[16:04:13.802]                     if (is.function(workers)) 
[16:04:13.802]                       workers <- workers()
[16:04:13.802]                     workers <- structure(as.integer(workers), 
[16:04:13.802]                       class = class(workers))
[16:04:13.802]                     stop_if_not(is.finite(workers), workers >= 
[16:04:13.802]                       1L)
[16:04:13.802]                     if ((workers == 1L && !inherits(workers, 
[16:04:13.802]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:13.802]                       if (default_workers) 
[16:04:13.802]                         supportsMulticore(warn = TRUE)
[16:04:13.802]                       return(sequential(..., envir = envir))
[16:04:13.802]                     }
[16:04:13.802]                     oopts <- options(mc.cores = workers)
[16:04:13.802]                     on.exit(options(oopts))
[16:04:13.802]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:13.802]                       envir = envir)
[16:04:13.802]                     if (!future$lazy) 
[16:04:13.802]                       future <- run(future)
[16:04:13.802]                     invisible(future)
[16:04:13.802]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:13.802]                 }
[16:04:13.802]             }
[16:04:13.802]         }
[16:04:13.802]     })
[16:04:13.802]     if (TRUE) {
[16:04:13.802]         base::sink(type = "output", split = FALSE)
[16:04:13.802]         if (TRUE) {
[16:04:13.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:13.802]         }
[16:04:13.802]         else {
[16:04:13.802]             ...future.result["stdout"] <- base::list(NULL)
[16:04:13.802]         }
[16:04:13.802]         base::close(...future.stdout)
[16:04:13.802]         ...future.stdout <- NULL
[16:04:13.802]     }
[16:04:13.802]     ...future.result$conditions <- ...future.conditions
[16:04:13.802]     ...future.result$finished <- base::Sys.time()
[16:04:13.802]     ...future.result
[16:04:13.802] }
[16:04:13.805] assign_globals() ...
[16:04:13.805] List of 4
[16:04:13.805]  $ ii   : int 3
[16:04:13.805]  $ n    : int 4
[16:04:13.805]  $ C    : cplx [1:25, 1:25] -2.25+0.03i -2.25+0.09i -2.25+0.15i ...
[16:04:13.805]   ..- attr(*, "region")=List of 2
[16:04:13.805]   .. ..$ xrange: num [1:2] -2.25 -0.781
[16:04:13.805]   .. ..$ yrange: num [1:2] 0.0306 1.5
[16:04:13.805]   ..- attr(*, "tile")= int [1:2] 2 1
[16:04:13.805]  $ delay:function (counts)  
[16:04:13.805]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:04:13.805]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55734648a950> 
[16:04:13.805]  - attr(*, "where")=List of 4
[16:04:13.805]   ..$ ii   :<environment: R_EmptyEnv> 
[16:04:13.805]   ..$ n    :<environment: R_EmptyEnv> 
[16:04:13.805]   ..$ C    :<environment: R_EmptyEnv> 
[16:04:13.805]   ..$ delay:<environment: R_EmptyEnv> 
[16:04:13.805]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:13.805]  - attr(*, "resolved")= logi FALSE
[16:04:13.805]  - attr(*, "total_size")= num 14584
[16:04:13.805]  - attr(*, "already-done")= logi TRUE
[16:04:13.815] - copied ‘ii’ to environment
[16:04:13.815] - copied ‘n’ to environment
[16:04:13.816] - copied ‘C’ to environment
[16:04:13.816] - reassign environment for ‘delay’
[16:04:13.816] - copied ‘delay’ to environment
[16:04:13.816] assign_globals() ... done
[16:04:13.816] requestCore(): workers = 2
[16:04:13.819] MulticoreFuture started
[16:04:13.819] - Launch lazy future ... done
[16:04:13.820] run() for ‘MulticoreFuture’ ... done
[16:04:13.820] - run() ... done
[16:04:13.820] - resolved() ...
[16:04:13.821] plan(): Setting new future strategy stack:
[16:04:13.821] List of future strategies:
[16:04:13.821] 1. sequential:
[16:04:13.821]    - args: function (..., envir = parent.frame())
[16:04:13.821]    - tweaked: FALSE
[16:04:13.821]    - call: NULL
[16:04:13.822] plan(): nbrOfWorkers() = 1
[16:04:13.826] plan(): Setting new future strategy stack:
[16:04:13.826] List of future strategies:
[16:04:13.826] 1. multicore:
[16:04:13.826]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:13.826]    - tweaked: FALSE
[16:04:13.826]    - call: plan(strategy)
[16:04:13.831] - resolved: FALSE
[16:04:13.831] - resolved() ... done
[16:04:13.831] resolved() for ‘MulticoreFuture’ ... done
[16:04:13.831] plan(): nbrOfWorkers() = 2
[16:04:13.831] resolved() for ‘Future’ ...
[16:04:13.832] - state: ‘created’
[16:04:13.832] - run: TRUE
[16:04:13.832] - run() ...
[16:04:13.832] run() for ‘Future’ ...
[16:04:13.832] - state: ‘created’
[16:04:13.833] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:13.838] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:13.838] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:13.838]   - Field: ‘label’
[16:04:13.838]   - Field: ‘local’
[16:04:13.839]   - Field: ‘owner’
[16:04:13.839]   - Field: ‘envir’
[16:04:13.839]   - Field: ‘workers’
[16:04:13.839]   - Field: ‘packages’
[16:04:13.839]   - Field: ‘gc’
[16:04:13.839]   - Field: ‘job’
[16:04:13.839]   - Field: ‘conditions’
[16:04:13.840]   - Field: ‘expr’
[16:04:13.840]   - Field: ‘uuid’
[16:04:13.840]   - Field: ‘seed’
[16:04:13.840]   - Field: ‘version’
[16:04:13.840]   - Field: ‘result’
[16:04:13.840]   - Field: ‘asynchronous’
[16:04:13.840]   - Field: ‘calls’
[16:04:13.841]   - Field: ‘globals’
[16:04:13.841]   - Field: ‘stdout’
[16:04:13.841]   - Field: ‘earlySignal’
[16:04:13.841]   - Field: ‘lazy’
[16:04:13.841]   - Field: ‘state’
[16:04:13.841] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:13.841] - Launch lazy future ...
[16:04:13.842] Packages needed by the future expression (n = 1): ‘future’
[16:04:13.842] Packages needed by future strategies (n = 0): <none>
[16:04:13.843] {
[16:04:13.843]     {
[16:04:13.843]         {
[16:04:13.843]             ...future.startTime <- base::Sys.time()
[16:04:13.843]             {
[16:04:13.843]                 {
[16:04:13.843]                   {
[16:04:13.843]                     {
[16:04:13.843]                       {
[16:04:13.843]                         base::local({
[16:04:13.843]                           has_future <- base::requireNamespace("future", 
[16:04:13.843]                             quietly = TRUE)
[16:04:13.843]                           if (has_future) {
[16:04:13.843]                             ns <- base::getNamespace("future")
[16:04:13.843]                             version <- ns[[".package"]][["version"]]
[16:04:13.843]                             if (is.null(version)) 
[16:04:13.843]                               version <- utils::packageVersion("future")
[16:04:13.843]                           }
[16:04:13.843]                           else {
[16:04:13.843]                             version <- NULL
[16:04:13.843]                           }
[16:04:13.843]                           if (!has_future || version < "1.8.0") {
[16:04:13.843]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:13.843]                               "", base::R.version$version.string), 
[16:04:13.843]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:13.843]                                 base::R.version$platform, 8 * 
[16:04:13.843]                                   base::.Machine$sizeof.pointer), 
[16:04:13.843]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:13.843]                                 "release", "version")], collapse = " "), 
[16:04:13.843]                               hostname = base::Sys.info()[["nodename"]])
[16:04:13.843]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:13.843]                               info)
[16:04:13.843]                             info <- base::paste(info, collapse = "; ")
[16:04:13.843]                             if (!has_future) {
[16:04:13.843]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:13.843]                                 info)
[16:04:13.843]                             }
[16:04:13.843]                             else {
[16:04:13.843]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:13.843]                                 info, version)
[16:04:13.843]                             }
[16:04:13.843]                             base::stop(msg)
[16:04:13.843]                           }
[16:04:13.843]                         })
[16:04:13.843]                       }
[16:04:13.843]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:13.843]                       base::options(mc.cores = 1L)
[16:04:13.843]                     }
[16:04:13.843]                     base::local({
[16:04:13.843]                       for (pkg in "future") {
[16:04:13.843]                         base::loadNamespace(pkg)
[16:04:13.843]                         base::library(pkg, character.only = TRUE)
[16:04:13.843]                       }
[16:04:13.843]                     })
[16:04:13.843]                   }
[16:04:13.843]                   options(future.plan = NULL)
[16:04:13.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:13.843]                 }
[16:04:13.843]                 ...future.workdir <- getwd()
[16:04:13.843]             }
[16:04:13.843]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:13.843]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:13.843]         }
[16:04:13.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:13.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:13.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:13.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:13.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:13.843]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:13.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:13.843]             base::names(...future.oldOptions))
[16:04:13.843]     }
[16:04:13.843]     if (FALSE) {
[16:04:13.843]     }
[16:04:13.843]     else {
[16:04:13.843]         if (TRUE) {
[16:04:13.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:13.843]                 open = "w")
[16:04:13.843]         }
[16:04:13.843]         else {
[16:04:13.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:13.843]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:13.843]         }
[16:04:13.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:13.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:13.843]             base::sink(type = "output", split = FALSE)
[16:04:13.843]             base::close(...future.stdout)
[16:04:13.843]         }, add = TRUE)
[16:04:13.843]     }
[16:04:13.843]     ...future.frame <- base::sys.nframe()
[16:04:13.843]     ...future.conditions <- base::list()
[16:04:13.843]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:13.843]     if (FALSE) {
[16:04:13.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:13.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:13.843]     }
[16:04:13.843]     ...future.result <- base::tryCatch({
[16:04:13.843]         base::withCallingHandlers({
[16:04:13.843]             ...future.value <- base::withVisible(base::local({
[16:04:13.843]                 withCallingHandlers({
[16:04:13.843]                   {
[16:04:13.843]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:04:13.843]                       ii, n), appendLF = FALSE)
[16:04:13.843]                     fit <- mandelbrot(C)
[16:04:13.843]                     delay(fit)
[16:04:13.843]                     message(" done")
[16:04:13.843]                     fit
[16:04:13.843]                   }
[16:04:13.843]                 }, immediateCondition = function(cond) {
[16:04:13.843]                   save_rds <- function (object, pathname, ...) 
[16:04:13.843]                   {
[16:04:13.843]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:13.843]                     if (file_test("-f", pathname_tmp)) {
[16:04:13.843]                       fi_tmp <- file.info(pathname_tmp)
[16:04:13.843]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:13.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:13.843]                         fi_tmp[["mtime"]])
[16:04:13.843]                     }
[16:04:13.843]                     tryCatch({
[16:04:13.843]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:13.843]                     }, error = function(ex) {
[16:04:13.843]                       msg <- conditionMessage(ex)
[16:04:13.843]                       fi_tmp <- file.info(pathname_tmp)
[16:04:13.843]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:13.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:13.843]                         fi_tmp[["mtime"]], msg)
[16:04:13.843]                       ex$message <- msg
[16:04:13.843]                       stop(ex)
[16:04:13.843]                     })
[16:04:13.843]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:13.843]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:13.843]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:13.843]                       fi_tmp <- file.info(pathname_tmp)
[16:04:13.843]                       fi <- file.info(pathname)
[16:04:13.843]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:13.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:13.843]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:13.843]                         fi[["size"]], fi[["mtime"]])
[16:04:13.843]                       stop(msg)
[16:04:13.843]                     }
[16:04:13.843]                     invisible(pathname)
[16:04:13.843]                   }
[16:04:13.843]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:13.843]                     rootPath = tempdir()) 
[16:04:13.843]                   {
[16:04:13.843]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:13.843]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:13.843]                       tmpdir = path, fileext = ".rds")
[16:04:13.843]                     save_rds(obj, file)
[16:04:13.843]                   }
[16:04:13.843]                   saveImmediateCondition(cond, path = "/tmp/RtmpugdtX0/.future/immediateConditions")
[16:04:13.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.843]                   {
[16:04:13.843]                     inherits <- base::inherits
[16:04:13.843]                     invokeRestart <- base::invokeRestart
[16:04:13.843]                     is.null <- base::is.null
[16:04:13.843]                     muffled <- FALSE
[16:04:13.843]                     if (inherits(cond, "message")) {
[16:04:13.843]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:13.843]                       if (muffled) 
[16:04:13.843]                         invokeRestart("muffleMessage")
[16:04:13.843]                     }
[16:04:13.843]                     else if (inherits(cond, "warning")) {
[16:04:13.843]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:13.843]                       if (muffled) 
[16:04:13.843]                         invokeRestart("muffleWarning")
[16:04:13.843]                     }
[16:04:13.843]                     else if (inherits(cond, "condition")) {
[16:04:13.843]                       if (!is.null(pattern)) {
[16:04:13.843]                         computeRestarts <- base::computeRestarts
[16:04:13.843]                         grepl <- base::grepl
[16:04:13.843]                         restarts <- computeRestarts(cond)
[16:04:13.843]                         for (restart in restarts) {
[16:04:13.843]                           name <- restart$name
[16:04:13.843]                           if (is.null(name)) 
[16:04:13.843]                             next
[16:04:13.843]                           if (!grepl(pattern, name)) 
[16:04:13.843]                             next
[16:04:13.843]                           invokeRestart(restart)
[16:04:13.843]                           muffled <- TRUE
[16:04:13.843]                           break
[16:04:13.843]                         }
[16:04:13.843]                       }
[16:04:13.843]                     }
[16:04:13.843]                     invisible(muffled)
[16:04:13.843]                   }
[16:04:13.843]                   muffleCondition(cond)
[16:04:13.843]                 })
[16:04:13.843]             }))
[16:04:13.843]             future::FutureResult(value = ...future.value$value, 
[16:04:13.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.843]                   ...future.rng), globalenv = if (FALSE) 
[16:04:13.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:13.843]                     ...future.globalenv.names))
[16:04:13.843]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:13.843]         }, condition = base::local({
[16:04:13.843]             c <- base::c
[16:04:13.843]             inherits <- base::inherits
[16:04:13.843]             invokeRestart <- base::invokeRestart
[16:04:13.843]             length <- base::length
[16:04:13.843]             list <- base::list
[16:04:13.843]             seq.int <- base::seq.int
[16:04:13.843]             signalCondition <- base::signalCondition
[16:04:13.843]             sys.calls <- base::sys.calls
[16:04:13.843]             `[[` <- base::`[[`
[16:04:13.843]             `+` <- base::`+`
[16:04:13.843]             `<<-` <- base::`<<-`
[16:04:13.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:13.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:13.843]                   3L)]
[16:04:13.843]             }
[16:04:13.843]             function(cond) {
[16:04:13.843]                 is_error <- inherits(cond, "error")
[16:04:13.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:13.843]                   NULL)
[16:04:13.843]                 if (is_error) {
[16:04:13.843]                   sessionInformation <- function() {
[16:04:13.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:13.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:13.843]                       search = base::search(), system = base::Sys.info())
[16:04:13.843]                   }
[16:04:13.843]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:13.843]                     cond$call), session = sessionInformation(), 
[16:04:13.843]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:13.843]                   signalCondition(cond)
[16:04:13.843]                 }
[16:04:13.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:13.843]                 "immediateCondition"))) {
[16:04:13.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:13.843]                   ...future.conditions[[length(...future.conditions) + 
[16:04:13.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:13.843]                   if (TRUE && !signal) {
[16:04:13.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.843]                     {
[16:04:13.843]                       inherits <- base::inherits
[16:04:13.843]                       invokeRestart <- base::invokeRestart
[16:04:13.843]                       is.null <- base::is.null
[16:04:13.843]                       muffled <- FALSE
[16:04:13.843]                       if (inherits(cond, "message")) {
[16:04:13.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.843]                         if (muffled) 
[16:04:13.843]                           invokeRestart("muffleMessage")
[16:04:13.843]                       }
[16:04:13.843]                       else if (inherits(cond, "warning")) {
[16:04:13.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.843]                         if (muffled) 
[16:04:13.843]                           invokeRestart("muffleWarning")
[16:04:13.843]                       }
[16:04:13.843]                       else if (inherits(cond, "condition")) {
[16:04:13.843]                         if (!is.null(pattern)) {
[16:04:13.843]                           computeRestarts <- base::computeRestarts
[16:04:13.843]                           grepl <- base::grepl
[16:04:13.843]                           restarts <- computeRestarts(cond)
[16:04:13.843]                           for (restart in restarts) {
[16:04:13.843]                             name <- restart$name
[16:04:13.843]                             if (is.null(name)) 
[16:04:13.843]                               next
[16:04:13.843]                             if (!grepl(pattern, name)) 
[16:04:13.843]                               next
[16:04:13.843]                             invokeRestart(restart)
[16:04:13.843]                             muffled <- TRUE
[16:04:13.843]                             break
[16:04:13.843]                           }
[16:04:13.843]                         }
[16:04:13.843]                       }
[16:04:13.843]                       invisible(muffled)
[16:04:13.843]                     }
[16:04:13.843]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.843]                   }
[16:04:13.843]                 }
[16:04:13.843]                 else {
[16:04:13.843]                   if (TRUE) {
[16:04:13.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:13.843]                     {
[16:04:13.843]                       inherits <- base::inherits
[16:04:13.843]                       invokeRestart <- base::invokeRestart
[16:04:13.843]                       is.null <- base::is.null
[16:04:13.843]                       muffled <- FALSE
[16:04:13.843]                       if (inherits(cond, "message")) {
[16:04:13.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:13.843]                         if (muffled) 
[16:04:13.843]                           invokeRestart("muffleMessage")
[16:04:13.843]                       }
[16:04:13.843]                       else if (inherits(cond, "warning")) {
[16:04:13.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:13.843]                         if (muffled) 
[16:04:13.843]                           invokeRestart("muffleWarning")
[16:04:13.843]                       }
[16:04:13.843]                       else if (inherits(cond, "condition")) {
[16:04:13.843]                         if (!is.null(pattern)) {
[16:04:13.843]                           computeRestarts <- base::computeRestarts
[16:04:13.843]                           grepl <- base::grepl
[16:04:13.843]                           restarts <- computeRestarts(cond)
[16:04:13.843]                           for (restart in restarts) {
[16:04:13.843]                             name <- restart$name
[16:04:13.843]                             if (is.null(name)) 
[16:04:13.843]                               next
[16:04:13.843]                             if (!grepl(pattern, name)) 
[16:04:13.843]                               next
[16:04:13.843]                             invokeRestart(restart)
[16:04:13.843]                             muffled <- TRUE
[16:04:13.843]                             break
[16:04:13.843]                           }
[16:04:13.843]                         }
[16:04:13.843]                       }
[16:04:13.843]                       invisible(muffled)
[16:04:13.843]                     }
[16:04:13.843]                     muffleCondition(cond, pattern = "^muffle")
[16:04:13.843]                   }
[16:04:13.843]                 }
[16:04:13.843]             }
[16:04:13.843]         }))
[16:04:13.843]     }, error = function(ex) {
[16:04:13.843]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:13.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:13.843]                 ...future.rng), started = ...future.startTime, 
[16:04:13.843]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:13.843]             version = "1.8"), class = "FutureResult")
[16:04:13.843]     }, finally = {
[16:04:13.843]         if (!identical(...future.workdir, getwd())) 
[16:04:13.843]             setwd(...future.workdir)
[16:04:13.843]         {
[16:04:13.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:13.843]                 ...future.oldOptions$nwarnings <- NULL
[16:04:13.843]             }
[16:04:13.843]             base::options(...future.oldOptions)
[16:04:13.843]             if (.Platform$OS.type == "windows") {
[16:04:13.843]                 old_names <- names(...future.oldEnvVars)
[16:04:13.843]                 envs <- base::Sys.getenv()
[16:04:13.843]                 names <- names(envs)
[16:04:13.843]                 common <- intersect(names, old_names)
[16:04:13.843]                 added <- setdiff(names, old_names)
[16:04:13.843]                 removed <- setdiff(old_names, names)
[16:04:13.843]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:13.843]                   envs[common]]
[16:04:13.843]                 NAMES <- toupper(changed)
[16:04:13.843]                 args <- list()
[16:04:13.843]                 for (kk in seq_along(NAMES)) {
[16:04:13.843]                   name <- changed[[kk]]
[16:04:13.843]                   NAME <- NAMES[[kk]]
[16:04:13.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.843]                     next
[16:04:13.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.843]                 }
[16:04:13.843]                 NAMES <- toupper(added)
[16:04:13.843]                 for (kk in seq_along(NAMES)) {
[16:04:13.843]                   name <- added[[kk]]
[16:04:13.843]                   NAME <- NAMES[[kk]]
[16:04:13.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.843]                     next
[16:04:13.843]                   args[[name]] <- ""
[16:04:13.843]                 }
[16:04:13.843]                 NAMES <- toupper(removed)
[16:04:13.843]                 for (kk in seq_along(NAMES)) {
[16:04:13.843]                   name <- removed[[kk]]
[16:04:13.843]                   NAME <- NAMES[[kk]]
[16:04:13.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:13.843]                     next
[16:04:13.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:13.843]                 }
[16:04:13.843]                 if (length(args) > 0) 
[16:04:13.843]                   base::do.call(base::Sys.setenv, args = args)
[16:04:13.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:13.843]             }
[16:04:13.843]             else {
[16:04:13.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:13.843]             }
[16:04:13.843]             {
[16:04:13.843]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:13.843]                   0L) {
[16:04:13.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:13.843]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:13.843]                   base::options(opts)
[16:04:13.843]                 }
[16:04:13.843]                 {
[16:04:13.843]                   {
[16:04:13.843]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:13.843]                     NULL
[16:04:13.843]                   }
[16:04:13.843]                   options(future.plan = NULL)
[16:04:13.843]                   if (is.na(NA_character_)) 
[16:04:13.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:13.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:13.843]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:13.843]                     envir = parent.frame()) 
[16:04:13.843]                   {
[16:04:13.843]                     default_workers <- missing(workers)
[16:04:13.843]                     if (is.function(workers)) 
[16:04:13.843]                       workers <- workers()
[16:04:13.843]                     workers <- structure(as.integer(workers), 
[16:04:13.843]                       class = class(workers))
[16:04:13.843]                     stop_if_not(is.finite(workers), workers >= 
[16:04:13.843]                       1L)
[16:04:13.843]                     if ((workers == 1L && !inherits(workers, 
[16:04:13.843]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:13.843]                       if (default_workers) 
[16:04:13.843]                         supportsMulticore(warn = TRUE)
[16:04:13.843]                       return(sequential(..., envir = envir))
[16:04:13.843]                     }
[16:04:13.843]                     oopts <- options(mc.cores = workers)
[16:04:13.843]                     on.exit(options(oopts))
[16:04:13.843]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:13.843]                       envir = envir)
[16:04:13.843]                     if (!future$lazy) 
[16:04:13.843]                       future <- run(future)
[16:04:13.843]                     invisible(future)
[16:04:13.843]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:13.843]                 }
[16:04:13.843]             }
[16:04:13.843]         }
[16:04:13.843]     })
[16:04:13.843]     if (TRUE) {
[16:04:13.843]         base::sink(type = "output", split = FALSE)
[16:04:13.843]         if (TRUE) {
[16:04:13.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:13.843]         }
[16:04:13.843]         else {
[16:04:13.843]             ...future.result["stdout"] <- base::list(NULL)
[16:04:13.843]         }
[16:04:13.843]         base::close(...future.stdout)
[16:04:13.843]         ...future.stdout <- NULL
[16:04:13.843]     }
[16:04:13.843]     ...future.result$conditions <- ...future.conditions
[16:04:13.843]     ...future.result$finished <- base::Sys.time()
[16:04:13.843]     ...future.result
[16:04:13.843] }
[16:04:13.847] assign_globals() ...
[16:04:13.847] List of 4
[16:04:13.847]  $ ii   : int 4
[16:04:13.847]  $ n    : int 4
[16:04:13.847]  $ C    : cplx [1:25, 1:25] -0.719+0.031i -0.719+0.092i -0.719+0.153i ...
[16:04:13.847]   ..- attr(*, "region")=List of 2
[16:04:13.847]   .. ..$ xrange: num [1:2] -0.719 0.75
[16:04:13.847]   .. ..$ yrange: num [1:2] 0.0306 1.5
[16:04:13.847]   ..- attr(*, "tile")= int [1:2] 2 2
[16:04:13.847]  $ delay:function (counts)  
[16:04:13.847]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:04:13.847]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55734648a950> 
[16:04:13.847]  - attr(*, "where")=List of 4
[16:04:13.847]   ..$ ii   :<environment: R_EmptyEnv> 
[16:04:13.847]   ..$ n    :<environment: R_EmptyEnv> 
[16:04:13.847]   ..$ C    :<environment: R_EmptyEnv> 
[16:04:13.847]   ..$ delay:<environment: R_EmptyEnv> 
[16:04:13.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:13.847]  - attr(*, "resolved")= logi FALSE
[16:04:13.847]  - attr(*, "total_size")= num 14584
[16:04:13.847]  - attr(*, "already-done")= logi TRUE
[16:04:13.856] - copied ‘ii’ to environment
[16:04:13.856] - copied ‘n’ to environment
[16:04:13.857] - copied ‘C’ to environment
[16:04:13.857] - reassign environment for ‘delay’
[16:04:13.857] - copied ‘delay’ to environment
[16:04:13.857] assign_globals() ... done
[16:04:13.857] requestCore(): workers = 2
[16:04:13.858] Poll #1 (0): usedCores() = 2, workers = 2
[16:04:13.868] result() for MulticoreFuture ...
[16:04:13.869] result() for MulticoreFuture ...
[16:04:13.869] result() for MulticoreFuture ... done
[16:04:13.870] signalConditions() ...
[16:04:13.870]  - include = ‘immediateCondition’
[16:04:13.870]  - exclude = 
[16:04:13.870]  - resignal = FALSE
[16:04:13.870]  - Number of conditions: 2
[16:04:13.870] signalConditions() ... done
[16:04:13.870] result() for MulticoreFuture ... done
[16:04:13.870] result() for MulticoreFuture ...
[16:04:13.871] result() for MulticoreFuture ... done
[16:04:13.871] signalConditions() ...
[16:04:13.871]  - include = ‘immediateCondition’
[16:04:13.871]  - exclude = 
[16:04:13.871]  - resignal = FALSE
[16:04:13.871]  - Number of conditions: 2
[16:04:13.871] signalConditions() ... done
[16:04:13.874] MulticoreFuture started
[16:04:13.875] - Launch lazy future ... done
[16:04:13.875] run() for ‘MulticoreFuture’ ... done
[16:04:13.875] - run() ... done
[16:04:13.875] - resolved() ...
[16:04:13.876] plan(): Setting new future strategy stack:
[16:04:13.876] List of future strategies:
[16:04:13.876] 1. sequential:
[16:04:13.876]    - args: function (..., envir = parent.frame())
[16:04:13.876]    - tweaked: FALSE
[16:04:13.876]    - call: NULL
[16:04:13.877] plan(): nbrOfWorkers() = 1
[16:04:13.881] plan(): Setting new future strategy stack:
[16:04:13.882] List of future strategies:
[16:04:13.882] 1. multicore:
[16:04:13.882]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:13.882]    - tweaked: FALSE
[16:04:13.882]    - call: plan(strategy)
[16:04:13.886] - resolved: FALSE
[16:04:13.886] - resolved() ... done
[16:04:13.886] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #2 of 4 ...
[16:04:13.887] result() for MulticoreFuture ...
[16:04:13.887] result() for MulticoreFuture ... done
[16:04:13.887] result() for MulticoreFuture ...
[16:04:13.887] plan(): nbrOfWorkers() = 2
[16:04:13.887] result() for MulticoreFuture ... done
[16:04:13.887] signalConditions() ...
[16:04:13.887]  - include = ‘immediateCondition’
[16:04:13.888]  - exclude = 
[16:04:13.888]  - resignal = FALSE
[16:04:13.888]  - Number of conditions: 2
[16:04:13.888] signalConditions() ... done
[16:04:13.888] Future state: ‘finished’
[16:04:13.888] result() for MulticoreFuture ...
[16:04:13.888] result() for MulticoreFuture ... done
[16:04:13.888] signalConditions() ...
[16:04:13.889]  - include = ‘condition’
[16:04:13.889]  - exclude = ‘immediateCondition’
[16:04:13.889]  - resignal = TRUE
[16:04:13.889]  - Number of conditions: 2
[16:04:13.889]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[16:04:13.889]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:04:13.889] signalConditions() ... done
Plotting tile #3 of 4 ...
[16:04:13.891] result() for MulticoreFuture ...
[16:04:13.892] result() for MulticoreFuture ...
[16:04:13.892] result() for MulticoreFuture ... done
[16:04:13.892] signalConditions() ...
[16:04:13.893]  - include = ‘immediateCondition’
[16:04:13.893]  - exclude = 
[16:04:13.893]  - resignal = FALSE
[16:04:13.893]  - Number of conditions: 2
[16:04:13.893] signalConditions() ... done
[16:04:13.893] result() for MulticoreFuture ... done
[16:04:13.893] result() for MulticoreFuture ...
[16:04:13.893] result() for MulticoreFuture ... done
[16:04:13.894] signalConditions() ...
[16:04:13.894]  - include = ‘immediateCondition’
[16:04:13.894]  - exclude = 
[16:04:13.894]  - resignal = FALSE
[16:04:13.894]  - Number of conditions: 2
[16:04:13.894] signalConditions() ... done
[16:04:13.894] Future state: ‘finished’
[16:04:13.895] result() for MulticoreFuture ...
[16:04:13.895] result() for MulticoreFuture ... done
[16:04:13.895] signalConditions() ...
[16:04:13.895]  - include = ‘condition’
[16:04:13.895]  - exclude = ‘immediateCondition’
[16:04:13.895]  - resignal = TRUE
[16:04:13.895]  - Number of conditions: 2
[16:04:13.895]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[16:04:13.896]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:04:13.896] signalConditions() ... done
Plotting tile #4 of 4 ...
[16:04:13.897] result() for MulticoreFuture ...
[16:04:13.898] result() for MulticoreFuture ...
[16:04:13.898] result() for MulticoreFuture ... done
[16:04:13.898] signalConditions() ...
[16:04:13.898]  - include = ‘immediateCondition’
[16:04:13.898]  - exclude = 
[16:04:13.898]  - resignal = FALSE
[16:04:13.898]  - Number of conditions: 2
[16:04:13.899] signalConditions() ... done
[16:04:13.899] result() for MulticoreFuture ... done
[16:04:13.899] result() for MulticoreFuture ...
[16:04:13.899] result() for MulticoreFuture ... done
[16:04:13.899] signalConditions() ...
[16:04:13.899]  - include = ‘immediateCondition’
[16:04:13.899]  - exclude = 
[16:04:13.900]  - resignal = FALSE
[16:04:13.900]  - Number of conditions: 2
[16:04:13.900] signalConditions() ... done
[16:04:13.900] Future state: ‘finished’
[16:04:13.900] result() for MulticoreFuture ...
[16:04:13.900] result() for MulticoreFuture ... done
[16:04:13.900] signalConditions() ...
[16:04:13.900]  - include = ‘condition’
[16:04:13.900]  - exclude = ‘immediateCondition’
[16:04:13.901]  - resignal = TRUE
[16:04:13.901]  - Number of conditions: 2
[16:04:13.901]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[16:04:13.901]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:04:13.901] signalConditions() ... done

> close.screen()
[1] 1 2 3 4 5 6 7 8

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multicore') ... DONE
- plan('multisession') ...
[16:04:13.903] plan(): Setting new future strategy stack:
[16:04:13.903] List of future strategies:
[16:04:13.903] 1. multisession:
[16:04:13.903]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:13.903]    - tweaked: FALSE
[16:04:13.903]    - call: plan(strategy)
[16:04:13.904] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:04:13.904] multisession:
[16:04:13.904] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:13.904] - tweaked: FALSE
[16:04:13.904] - call: plan(strategy)
[16:04:13.911] getGlobalsAndPackages() ...
[16:04:13.911] Not searching for globals
[16:04:13.911] - globals: [0] <none>
[16:04:13.911] getGlobalsAndPackages() ... DONE
[16:04:13.912] [local output] makeClusterPSOCK() ...
[16:04:13.969] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:04:13.970] [local output] Base port: 11589
[16:04:13.970] [local output] Getting setup options for 2 cluster nodes ...
[16:04:13.970] [local output]  - Node 1 of 2 ...
[16:04:13.971] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:13.972] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpugdtX0/worker.rank=1.parallelly.parent=80982.13c56c842c7d.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpugdtX0/worker.rank=1.parallelly.parent=80982.13c56c842c7d.pid")'’
[16:04:14.160] - Possible to infer worker's PID: TRUE
[16:04:14.161] [local output] Rscript port: 11589

[16:04:14.161] [local output]  - Node 2 of 2 ...
[16:04:14.161] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:14.162] [local output] Rscript port: 11589

[16:04:14.162] [local output] Getting setup options for 2 cluster nodes ... done
[16:04:14.162] [local output]  - Parallel setup requested for some PSOCK nodes
[16:04:14.163] [local output] Setting up PSOCK nodes in parallel
[16:04:14.163] List of 36
[16:04:14.163]  $ worker          : chr "localhost"
[16:04:14.163]   ..- attr(*, "localhost")= logi TRUE
[16:04:14.163]  $ master          : chr "localhost"
[16:04:14.163]  $ port            : int 11589
[16:04:14.163]  $ connectTimeout  : num 120
[16:04:14.163]  $ timeout         : num 2592000
[16:04:14.163]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:04:14.163]  $ homogeneous     : logi TRUE
[16:04:14.163]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:04:14.163]  $ rscript_envs    : NULL
[16:04:14.163]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:14.163]  $ rscript_startup : NULL
[16:04:14.163]  $ rscript_sh      : chr "sh"
[16:04:14.163]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:14.163]  $ methods         : logi TRUE
[16:04:14.163]  $ socketOptions   : chr "no-delay"
[16:04:14.163]  $ useXDR          : logi FALSE
[16:04:14.163]  $ outfile         : chr "/dev/null"
[16:04:14.163]  $ renice          : int NA
[16:04:14.163]  $ rshcmd          : NULL
[16:04:14.163]  $ user            : chr(0) 
[16:04:14.163]  $ revtunnel       : logi FALSE
[16:04:14.163]  $ rshlogfile      : NULL
[16:04:14.163]  $ rshopts         : chr(0) 
[16:04:14.163]  $ rank            : int 1
[16:04:14.163]  $ manual          : logi FALSE
[16:04:14.163]  $ dryrun          : logi FALSE
[16:04:14.163]  $ quiet           : logi FALSE
[16:04:14.163]  $ setup_strategy  : chr "parallel"
[16:04:14.163]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:14.163]  $ pidfile         : chr "/tmp/RtmpugdtX0/worker.rank=1.parallelly.parent=80982.13c56c842c7d.pid"
[16:04:14.163]  $ rshcmd_label    : NULL
[16:04:14.163]  $ rsh_call        : NULL
[16:04:14.163]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:14.163]  $ localMachine    : logi TRUE
[16:04:14.163]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:04:14.163]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:04:14.163]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:04:14.163]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:04:14.163]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:04:14.163]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:04:14.163]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:04:14.163]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:04:14.163]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:04:14.163]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:04:14.163]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:04:14.163]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:04:14.163]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:04:14.163]  $ arguments       :List of 28
[16:04:14.163]   ..$ worker          : chr "localhost"
[16:04:14.163]   ..$ master          : NULL
[16:04:14.163]   ..$ port            : int 11589
[16:04:14.163]   ..$ connectTimeout  : num 120
[16:04:14.163]   ..$ timeout         : num 2592000
[16:04:14.163]   ..$ rscript         : NULL
[16:04:14.163]   ..$ homogeneous     : NULL
[16:04:14.163]   ..$ rscript_args    : NULL
[16:04:14.163]   ..$ rscript_envs    : NULL
[16:04:14.163]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:14.163]   ..$ rscript_startup : NULL
[16:04:14.163]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:04:14.163]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:14.163]   ..$ methods         : logi TRUE
[16:04:14.163]   ..$ socketOptions   : chr "no-delay"
[16:04:14.163]   ..$ useXDR          : logi FALSE
[16:04:14.163]   ..$ outfile         : chr "/dev/null"
[16:04:14.163]   ..$ renice          : int NA
[16:04:14.163]   ..$ rshcmd          : NULL
[16:04:14.163]   ..$ user            : NULL
[16:04:14.163]   ..$ revtunnel       : logi NA
[16:04:14.163]   ..$ rshlogfile      : NULL
[16:04:14.163]   ..$ rshopts         : NULL
[16:04:14.163]   ..$ rank            : int 1
[16:04:14.163]   ..$ manual          : logi FALSE
[16:04:14.163]   ..$ dryrun          : logi FALSE
[16:04:14.163]   ..$ quiet           : logi FALSE
[16:04:14.163]   ..$ setup_strategy  : chr "parallel"
[16:04:14.163]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:04:14.180] [local output] System call to launch all workers:
[16:04:14.180] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpugdtX0/worker.rank=1.parallelly.parent=80982.13c56c842c7d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11589 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:04:14.180] [local output] Starting PSOCK main server
[16:04:14.186] [local output] Workers launched
[16:04:14.186] [local output] Waiting for workers to connect back
[16:04:14.186]  - [local output] 0 workers out of 2 ready
[16:04:14.424]  - [local output] 0 workers out of 2 ready
[16:04:14.425]  - [local output] 1 workers out of 2 ready
[16:04:14.437]  - [local output] 1 workers out of 2 ready
[16:04:14.438]  - [local output] 2 workers out of 2 ready
[16:04:14.438] [local output] Launching of workers completed
[16:04:14.438] [local output] Collecting session information from workers
[16:04:14.439] [local output]  - Worker #1 of 2
[16:04:14.439] [local output]  - Worker #2 of 2
[16:04:14.440] [local output] makeClusterPSOCK() ... done
[16:04:14.451] Packages needed by the future expression (n = 0): <none>
[16:04:14.451] Packages needed by future strategies (n = 0): <none>
[16:04:14.451] {
[16:04:14.451]     {
[16:04:14.451]         {
[16:04:14.451]             ...future.startTime <- base::Sys.time()
[16:04:14.451]             {
[16:04:14.451]                 {
[16:04:14.451]                   {
[16:04:14.451]                     {
[16:04:14.451]                       base::local({
[16:04:14.451]                         has_future <- base::requireNamespace("future", 
[16:04:14.451]                           quietly = TRUE)
[16:04:14.451]                         if (has_future) {
[16:04:14.451]                           ns <- base::getNamespace("future")
[16:04:14.451]                           version <- ns[[".package"]][["version"]]
[16:04:14.451]                           if (is.null(version)) 
[16:04:14.451]                             version <- utils::packageVersion("future")
[16:04:14.451]                         }
[16:04:14.451]                         else {
[16:04:14.451]                           version <- NULL
[16:04:14.451]                         }
[16:04:14.451]                         if (!has_future || version < "1.8.0") {
[16:04:14.451]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:14.451]                             "", base::R.version$version.string), 
[16:04:14.451]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:14.451]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:14.451]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:14.451]                               "release", "version")], collapse = " "), 
[16:04:14.451]                             hostname = base::Sys.info()[["nodename"]])
[16:04:14.451]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:14.451]                             info)
[16:04:14.451]                           info <- base::paste(info, collapse = "; ")
[16:04:14.451]                           if (!has_future) {
[16:04:14.451]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:14.451]                               info)
[16:04:14.451]                           }
[16:04:14.451]                           else {
[16:04:14.451]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:14.451]                               info, version)
[16:04:14.451]                           }
[16:04:14.451]                           base::stop(msg)
[16:04:14.451]                         }
[16:04:14.451]                       })
[16:04:14.451]                     }
[16:04:14.451]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:14.451]                     base::options(mc.cores = 1L)
[16:04:14.451]                   }
[16:04:14.451]                   options(future.plan = NULL)
[16:04:14.451]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:14.451]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:14.451]                 }
[16:04:14.451]                 ...future.workdir <- getwd()
[16:04:14.451]             }
[16:04:14.451]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:14.451]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:14.451]         }
[16:04:14.451]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:14.451]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:14.451]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:14.451]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:14.451]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:14.451]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:14.451]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:14.451]             base::names(...future.oldOptions))
[16:04:14.451]     }
[16:04:14.451]     if (FALSE) {
[16:04:14.451]     }
[16:04:14.451]     else {
[16:04:14.451]         if (TRUE) {
[16:04:14.451]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:14.451]                 open = "w")
[16:04:14.451]         }
[16:04:14.451]         else {
[16:04:14.451]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:14.451]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:14.451]         }
[16:04:14.451]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:14.451]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:14.451]             base::sink(type = "output", split = FALSE)
[16:04:14.451]             base::close(...future.stdout)
[16:04:14.451]         }, add = TRUE)
[16:04:14.451]     }
[16:04:14.451]     ...future.frame <- base::sys.nframe()
[16:04:14.451]     ...future.conditions <- base::list()
[16:04:14.451]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:14.451]     if (FALSE) {
[16:04:14.451]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:14.451]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:14.451]     }
[16:04:14.451]     ...future.result <- base::tryCatch({
[16:04:14.451]         base::withCallingHandlers({
[16:04:14.451]             ...future.value <- base::withVisible(base::local({
[16:04:14.451]                 ...future.makeSendCondition <- base::local({
[16:04:14.451]                   sendCondition <- NULL
[16:04:14.451]                   function(frame = 1L) {
[16:04:14.451]                     if (is.function(sendCondition)) 
[16:04:14.451]                       return(sendCondition)
[16:04:14.451]                     ns <- getNamespace("parallel")
[16:04:14.451]                     if (exists("sendData", mode = "function", 
[16:04:14.451]                       envir = ns)) {
[16:04:14.451]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:14.451]                         envir = ns)
[16:04:14.451]                       envir <- sys.frame(frame)
[16:04:14.451]                       master <- NULL
[16:04:14.451]                       while (!identical(envir, .GlobalEnv) && 
[16:04:14.451]                         !identical(envir, emptyenv())) {
[16:04:14.451]                         if (exists("master", mode = "list", envir = envir, 
[16:04:14.451]                           inherits = FALSE)) {
[16:04:14.451]                           master <- get("master", mode = "list", 
[16:04:14.451]                             envir = envir, inherits = FALSE)
[16:04:14.451]                           if (inherits(master, c("SOCKnode", 
[16:04:14.451]                             "SOCK0node"))) {
[16:04:14.451]                             sendCondition <<- function(cond) {
[16:04:14.451]                               data <- list(type = "VALUE", value = cond, 
[16:04:14.451]                                 success = TRUE)
[16:04:14.451]                               parallel_sendData(master, data)
[16:04:14.451]                             }
[16:04:14.451]                             return(sendCondition)
[16:04:14.451]                           }
[16:04:14.451]                         }
[16:04:14.451]                         frame <- frame + 1L
[16:04:14.451]                         envir <- sys.frame(frame)
[16:04:14.451]                       }
[16:04:14.451]                     }
[16:04:14.451]                     sendCondition <<- function(cond) NULL
[16:04:14.451]                   }
[16:04:14.451]                 })
[16:04:14.451]                 withCallingHandlers({
[16:04:14.451]                   NA
[16:04:14.451]                 }, immediateCondition = function(cond) {
[16:04:14.451]                   sendCondition <- ...future.makeSendCondition()
[16:04:14.451]                   sendCondition(cond)
[16:04:14.451]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:14.451]                   {
[16:04:14.451]                     inherits <- base::inherits
[16:04:14.451]                     invokeRestart <- base::invokeRestart
[16:04:14.451]                     is.null <- base::is.null
[16:04:14.451]                     muffled <- FALSE
[16:04:14.451]                     if (inherits(cond, "message")) {
[16:04:14.451]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:14.451]                       if (muffled) 
[16:04:14.451]                         invokeRestart("muffleMessage")
[16:04:14.451]                     }
[16:04:14.451]                     else if (inherits(cond, "warning")) {
[16:04:14.451]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:14.451]                       if (muffled) 
[16:04:14.451]                         invokeRestart("muffleWarning")
[16:04:14.451]                     }
[16:04:14.451]                     else if (inherits(cond, "condition")) {
[16:04:14.451]                       if (!is.null(pattern)) {
[16:04:14.451]                         computeRestarts <- base::computeRestarts
[16:04:14.451]                         grepl <- base::grepl
[16:04:14.451]                         restarts <- computeRestarts(cond)
[16:04:14.451]                         for (restart in restarts) {
[16:04:14.451]                           name <- restart$name
[16:04:14.451]                           if (is.null(name)) 
[16:04:14.451]                             next
[16:04:14.451]                           if (!grepl(pattern, name)) 
[16:04:14.451]                             next
[16:04:14.451]                           invokeRestart(restart)
[16:04:14.451]                           muffled <- TRUE
[16:04:14.451]                           break
[16:04:14.451]                         }
[16:04:14.451]                       }
[16:04:14.451]                     }
[16:04:14.451]                     invisible(muffled)
[16:04:14.451]                   }
[16:04:14.451]                   muffleCondition(cond)
[16:04:14.451]                 })
[16:04:14.451]             }))
[16:04:14.451]             future::FutureResult(value = ...future.value$value, 
[16:04:14.451]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:14.451]                   ...future.rng), globalenv = if (FALSE) 
[16:04:14.451]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:14.451]                     ...future.globalenv.names))
[16:04:14.451]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:14.451]         }, condition = base::local({
[16:04:14.451]             c <- base::c
[16:04:14.451]             inherits <- base::inherits
[16:04:14.451]             invokeRestart <- base::invokeRestart
[16:04:14.451]             length <- base::length
[16:04:14.451]             list <- base::list
[16:04:14.451]             seq.int <- base::seq.int
[16:04:14.451]             signalCondition <- base::signalCondition
[16:04:14.451]             sys.calls <- base::sys.calls
[16:04:14.451]             `[[` <- base::`[[`
[16:04:14.451]             `+` <- base::`+`
[16:04:14.451]             `<<-` <- base::`<<-`
[16:04:14.451]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:14.451]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:14.451]                   3L)]
[16:04:14.451]             }
[16:04:14.451]             function(cond) {
[16:04:14.451]                 is_error <- inherits(cond, "error")
[16:04:14.451]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:14.451]                   NULL)
[16:04:14.451]                 if (is_error) {
[16:04:14.451]                   sessionInformation <- function() {
[16:04:14.451]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:14.451]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:14.451]                       search = base::search(), system = base::Sys.info())
[16:04:14.451]                   }
[16:04:14.451]                   ...future.conditions[[length(...future.conditions) + 
[16:04:14.451]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:14.451]                     cond$call), session = sessionInformation(), 
[16:04:14.451]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:14.451]                   signalCondition(cond)
[16:04:14.451]                 }
[16:04:14.451]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:14.451]                 "immediateCondition"))) {
[16:04:14.451]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:14.451]                   ...future.conditions[[length(...future.conditions) + 
[16:04:14.451]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:14.451]                   if (TRUE && !signal) {
[16:04:14.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:14.451]                     {
[16:04:14.451]                       inherits <- base::inherits
[16:04:14.451]                       invokeRestart <- base::invokeRestart
[16:04:14.451]                       is.null <- base::is.null
[16:04:14.451]                       muffled <- FALSE
[16:04:14.451]                       if (inherits(cond, "message")) {
[16:04:14.451]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:14.451]                         if (muffled) 
[16:04:14.451]                           invokeRestart("muffleMessage")
[16:04:14.451]                       }
[16:04:14.451]                       else if (inherits(cond, "warning")) {
[16:04:14.451]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:14.451]                         if (muffled) 
[16:04:14.451]                           invokeRestart("muffleWarning")
[16:04:14.451]                       }
[16:04:14.451]                       else if (inherits(cond, "condition")) {
[16:04:14.451]                         if (!is.null(pattern)) {
[16:04:14.451]                           computeRestarts <- base::computeRestarts
[16:04:14.451]                           grepl <- base::grepl
[16:04:14.451]                           restarts <- computeRestarts(cond)
[16:04:14.451]                           for (restart in restarts) {
[16:04:14.451]                             name <- restart$name
[16:04:14.451]                             if (is.null(name)) 
[16:04:14.451]                               next
[16:04:14.451]                             if (!grepl(pattern, name)) 
[16:04:14.451]                               next
[16:04:14.451]                             invokeRestart(restart)
[16:04:14.451]                             muffled <- TRUE
[16:04:14.451]                             break
[16:04:14.451]                           }
[16:04:14.451]                         }
[16:04:14.451]                       }
[16:04:14.451]                       invisible(muffled)
[16:04:14.451]                     }
[16:04:14.451]                     muffleCondition(cond, pattern = "^muffle")
[16:04:14.451]                   }
[16:04:14.451]                 }
[16:04:14.451]                 else {
[16:04:14.451]                   if (TRUE) {
[16:04:14.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:14.451]                     {
[16:04:14.451]                       inherits <- base::inherits
[16:04:14.451]                       invokeRestart <- base::invokeRestart
[16:04:14.451]                       is.null <- base::is.null
[16:04:14.451]                       muffled <- FALSE
[16:04:14.451]                       if (inherits(cond, "message")) {
[16:04:14.451]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:14.451]                         if (muffled) 
[16:04:14.451]                           invokeRestart("muffleMessage")
[16:04:14.451]                       }
[16:04:14.451]                       else if (inherits(cond, "warning")) {
[16:04:14.451]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:14.451]                         if (muffled) 
[16:04:14.451]                           invokeRestart("muffleWarning")
[16:04:14.451]                       }
[16:04:14.451]                       else if (inherits(cond, "condition")) {
[16:04:14.451]                         if (!is.null(pattern)) {
[16:04:14.451]                           computeRestarts <- base::computeRestarts
[16:04:14.451]                           grepl <- base::grepl
[16:04:14.451]                           restarts <- computeRestarts(cond)
[16:04:14.451]                           for (restart in restarts) {
[16:04:14.451]                             name <- restart$name
[16:04:14.451]                             if (is.null(name)) 
[16:04:14.451]                               next
[16:04:14.451]                             if (!grepl(pattern, name)) 
[16:04:14.451]                               next
[16:04:14.451]                             invokeRestart(restart)
[16:04:14.451]                             muffled <- TRUE
[16:04:14.451]                             break
[16:04:14.451]                           }
[16:04:14.451]                         }
[16:04:14.451]                       }
[16:04:14.451]                       invisible(muffled)
[16:04:14.451]                     }
[16:04:14.451]                     muffleCondition(cond, pattern = "^muffle")
[16:04:14.451]                   }
[16:04:14.451]                 }
[16:04:14.451]             }
[16:04:14.451]         }))
[16:04:14.451]     }, error = function(ex) {
[16:04:14.451]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:14.451]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:14.451]                 ...future.rng), started = ...future.startTime, 
[16:04:14.451]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:14.451]             version = "1.8"), class = "FutureResult")
[16:04:14.451]     }, finally = {
[16:04:14.451]         if (!identical(...future.workdir, getwd())) 
[16:04:14.451]             setwd(...future.workdir)
[16:04:14.451]         {
[16:04:14.451]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:14.451]                 ...future.oldOptions$nwarnings <- NULL
[16:04:14.451]             }
[16:04:14.451]             base::options(...future.oldOptions)
[16:04:14.451]             if (.Platform$OS.type == "windows") {
[16:04:14.451]                 old_names <- names(...future.oldEnvVars)
[16:04:14.451]                 envs <- base::Sys.getenv()
[16:04:14.451]                 names <- names(envs)
[16:04:14.451]                 common <- intersect(names, old_names)
[16:04:14.451]                 added <- setdiff(names, old_names)
[16:04:14.451]                 removed <- setdiff(old_names, names)
[16:04:14.451]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:14.451]                   envs[common]]
[16:04:14.451]                 NAMES <- toupper(changed)
[16:04:14.451]                 args <- list()
[16:04:14.451]                 for (kk in seq_along(NAMES)) {
[16:04:14.451]                   name <- changed[[kk]]
[16:04:14.451]                   NAME <- NAMES[[kk]]
[16:04:14.451]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:14.451]                     next
[16:04:14.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:14.451]                 }
[16:04:14.451]                 NAMES <- toupper(added)
[16:04:14.451]                 for (kk in seq_along(NAMES)) {
[16:04:14.451]                   name <- added[[kk]]
[16:04:14.451]                   NAME <- NAMES[[kk]]
[16:04:14.451]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:14.451]                     next
[16:04:14.451]                   args[[name]] <- ""
[16:04:14.451]                 }
[16:04:14.451]                 NAMES <- toupper(removed)
[16:04:14.451]                 for (kk in seq_along(NAMES)) {
[16:04:14.451]                   name <- removed[[kk]]
[16:04:14.451]                   NAME <- NAMES[[kk]]
[16:04:14.451]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:14.451]                     next
[16:04:14.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:14.451]                 }
[16:04:14.451]                 if (length(args) > 0) 
[16:04:14.451]                   base::do.call(base::Sys.setenv, args = args)
[16:04:14.451]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:14.451]             }
[16:04:14.451]             else {
[16:04:14.451]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:14.451]             }
[16:04:14.451]             {
[16:04:14.451]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:14.451]                   0L) {
[16:04:14.451]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:14.451]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:14.451]                   base::options(opts)
[16:04:14.451]                 }
[16:04:14.451]                 {
[16:04:14.451]                   {
[16:04:14.451]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:14.451]                     NULL
[16:04:14.451]                   }
[16:04:14.451]                   options(future.plan = NULL)
[16:04:14.451]                   if (is.na(NA_character_)) 
[16:04:14.451]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:14.451]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:14.451]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:14.451]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:14.451]                     envir = parent.frame()) 
[16:04:14.451]                   {
[16:04:14.451]                     if (is.function(workers)) 
[16:04:14.451]                       workers <- workers()
[16:04:14.451]                     workers <- structure(as.integer(workers), 
[16:04:14.451]                       class = class(workers))
[16:04:14.451]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:14.451]                       workers >= 1)
[16:04:14.451]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:14.451]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:14.451]                     }
[16:04:14.451]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:14.451]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:14.451]                       envir = envir)
[16:04:14.451]                     if (!future$lazy) 
[16:04:14.451]                       future <- run(future)
[16:04:14.451]                     invisible(future)
[16:04:14.451]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:14.451]                 }
[16:04:14.451]             }
[16:04:14.451]         }
[16:04:14.451]     })
[16:04:14.451]     if (TRUE) {
[16:04:14.451]         base::sink(type = "output", split = FALSE)
[16:04:14.451]         if (TRUE) {
[16:04:14.451]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:14.451]         }
[16:04:14.451]         else {
[16:04:14.451]             ...future.result["stdout"] <- base::list(NULL)
[16:04:14.451]         }
[16:04:14.451]         base::close(...future.stdout)
[16:04:14.451]         ...future.stdout <- NULL
[16:04:14.451]     }
[16:04:14.451]     ...future.result$conditions <- ...future.conditions
[16:04:14.451]     ...future.result$finished <- base::Sys.time()
[16:04:14.451]     ...future.result
[16:04:14.451] }
[16:04:14.505] MultisessionFuture started
[16:04:14.505] result() for ClusterFuture ...
[16:04:14.506] receiveMessageFromWorker() for ClusterFuture ...
[16:04:14.506] - Validating connection of MultisessionFuture
[16:04:14.549] - received message: FutureResult
[16:04:14.550] - Received FutureResult
[16:04:14.550] - Erased future from FutureRegistry
[16:04:14.550] result() for ClusterFuture ...
[16:04:14.550] - result already collected: FutureResult
[16:04:14.550] result() for ClusterFuture ... done
[16:04:14.550] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:14.550] result() for ClusterFuture ... done
[16:04:14.550] result() for ClusterFuture ...
[16:04:14.550] - result already collected: FutureResult
[16:04:14.550] result() for ClusterFuture ... done
[16:04:14.551] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:04:14.554] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1]  9 10 11 12

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[16:04:14.558] getGlobalsAndPackages() ...
[16:04:14.558] Searching for globals...
[16:04:14.561] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:04:14.561] Searching for globals ... DONE
[16:04:14.562] Resolving globals: FALSE
[16:04:14.562] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:04:14.563] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:04:14.563] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:04:14.563] - packages: [1] ‘future’
[16:04:14.563] getGlobalsAndPackages() ... DONE
 2[16:04:14.567] getGlobalsAndPackages() ...
[16:04:14.567] Searching for globals...
[16:04:14.570] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:04:14.570] Searching for globals ... DONE
[16:04:14.570] Resolving globals: FALSE
[16:04:14.571] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:04:14.571] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:04:14.571] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:04:14.572] - packages: [1] ‘future’
[16:04:14.572] getGlobalsAndPackages() ... DONE
 3[16:04:14.572] getGlobalsAndPackages() ...
[16:04:14.572] Searching for globals...
[16:04:14.575] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:04:14.576] Searching for globals ... DONE
[16:04:14.576] Resolving globals: FALSE
[16:04:14.576] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:04:14.576] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:04:14.577] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:04:14.577] - packages: [1] ‘future’
[16:04:14.577] getGlobalsAndPackages() ... DONE
 4[16:04:14.577] getGlobalsAndPackages() ...
[16:04:14.577] Searching for globals...
[16:04:14.580] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:04:14.581] Searching for globals ... DONE
[16:04:14.581] Resolving globals: FALSE
[16:04:14.581] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:04:14.582] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:04:14.582] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:04:14.582] - packages: [1] ‘future’
[16:04:14.582] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[16:04:14.592] resolved() for ‘Future’ ...
[16:04:14.593] - state: ‘created’
[16:04:14.593] - run: TRUE
[16:04:14.593] - run() ...
[16:04:14.593] run() for ‘Future’ ...
[16:04:14.593] - state: ‘created’
[16:04:14.593] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:14.607] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:14.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:14.608]   - Field: ‘node’
[16:04:14.608]   - Field: ‘label’
[16:04:14.608]   - Field: ‘local’
[16:04:14.608]   - Field: ‘owner’
[16:04:14.608]   - Field: ‘envir’
[16:04:14.608]   - Field: ‘workers’
[16:04:14.608]   - Field: ‘packages’
[16:04:14.608]   - Field: ‘gc’
[16:04:14.608]   - Field: ‘conditions’
[16:04:14.609]   - Field: ‘persistent’
[16:04:14.609]   - Field: ‘expr’
[16:04:14.609]   - Field: ‘uuid’
[16:04:14.609]   - Field: ‘seed’
[16:04:14.609]   - Field: ‘version’
[16:04:14.609]   - Field: ‘result’
[16:04:14.609]   - Field: ‘asynchronous’
[16:04:14.609]   - Field: ‘calls’
[16:04:14.609]   - Field: ‘globals’
[16:04:14.609]   - Field: ‘stdout’
[16:04:14.609]   - Field: ‘earlySignal’
[16:04:14.610]   - Field: ‘lazy’
[16:04:14.610]   - Field: ‘state’
[16:04:14.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:14.610] - Launch lazy future ...
[16:04:14.610] Packages needed by the future expression (n = 1): ‘future’
[16:04:14.610] Packages needed by future strategies (n = 0): <none>
[16:04:14.611] {
[16:04:14.611]     {
[16:04:14.611]         {
[16:04:14.611]             ...future.startTime <- base::Sys.time()
[16:04:14.611]             {
[16:04:14.611]                 {
[16:04:14.611]                   {
[16:04:14.611]                     {
[16:04:14.611]                       {
[16:04:14.611]                         base::local({
[16:04:14.611]                           has_future <- base::requireNamespace("future", 
[16:04:14.611]                             quietly = TRUE)
[16:04:14.611]                           if (has_future) {
[16:04:14.611]                             ns <- base::getNamespace("future")
[16:04:14.611]                             version <- ns[[".package"]][["version"]]
[16:04:14.611]                             if (is.null(version)) 
[16:04:14.611]                               version <- utils::packageVersion("future")
[16:04:14.611]                           }
[16:04:14.611]                           else {
[16:04:14.611]                             version <- NULL
[16:04:14.611]                           }
[16:04:14.611]                           if (!has_future || version < "1.8.0") {
[16:04:14.611]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:14.611]                               "", base::R.version$version.string), 
[16:04:14.611]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:14.611]                                 base::R.version$platform, 8 * 
[16:04:14.611]                                   base::.Machine$sizeof.pointer), 
[16:04:14.611]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:14.611]                                 "release", "version")], collapse = " "), 
[16:04:14.611]                               hostname = base::Sys.info()[["nodename"]])
[16:04:14.611]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:14.611]                               info)
[16:04:14.611]                             info <- base::paste(info, collapse = "; ")
[16:04:14.611]                             if (!has_future) {
[16:04:14.611]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:14.611]                                 info)
[16:04:14.611]                             }
[16:04:14.611]                             else {
[16:04:14.611]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:14.611]                                 info, version)
[16:04:14.611]                             }
[16:04:14.611]                             base::stop(msg)
[16:04:14.611]                           }
[16:04:14.611]                         })
[16:04:14.611]                       }
[16:04:14.611]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:14.611]                       base::options(mc.cores = 1L)
[16:04:14.611]                     }
[16:04:14.611]                     base::local({
[16:04:14.611]                       for (pkg in "future") {
[16:04:14.611]                         base::loadNamespace(pkg)
[16:04:14.611]                         base::library(pkg, character.only = TRUE)
[16:04:14.611]                       }
[16:04:14.611]                     })
[16:04:14.611]                   }
[16:04:14.611]                   options(future.plan = NULL)
[16:04:14.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:14.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:14.611]                 }
[16:04:14.611]                 ...future.workdir <- getwd()
[16:04:14.611]             }
[16:04:14.611]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:14.611]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:14.611]         }
[16:04:14.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:14.611]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:14.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:14.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:14.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:14.611]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:14.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:14.611]             base::names(...future.oldOptions))
[16:04:14.611]     }
[16:04:14.611]     if (FALSE) {
[16:04:14.611]     }
[16:04:14.611]     else {
[16:04:14.611]         if (TRUE) {
[16:04:14.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:14.611]                 open = "w")
[16:04:14.611]         }
[16:04:14.611]         else {
[16:04:14.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:14.611]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:14.611]         }
[16:04:14.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:14.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:14.611]             base::sink(type = "output", split = FALSE)
[16:04:14.611]             base::close(...future.stdout)
[16:04:14.611]         }, add = TRUE)
[16:04:14.611]     }
[16:04:14.611]     ...future.frame <- base::sys.nframe()
[16:04:14.611]     ...future.conditions <- base::list()
[16:04:14.611]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:14.611]     if (FALSE) {
[16:04:14.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:14.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:14.611]     }
[16:04:14.611]     ...future.result <- base::tryCatch({
[16:04:14.611]         base::withCallingHandlers({
[16:04:14.611]             ...future.value <- base::withVisible(base::local({
[16:04:14.611]                 ...future.makeSendCondition <- base::local({
[16:04:14.611]                   sendCondition <- NULL
[16:04:14.611]                   function(frame = 1L) {
[16:04:14.611]                     if (is.function(sendCondition)) 
[16:04:14.611]                       return(sendCondition)
[16:04:14.611]                     ns <- getNamespace("parallel")
[16:04:14.611]                     if (exists("sendData", mode = "function", 
[16:04:14.611]                       envir = ns)) {
[16:04:14.611]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:14.611]                         envir = ns)
[16:04:14.611]                       envir <- sys.frame(frame)
[16:04:14.611]                       master <- NULL
[16:04:14.611]                       while (!identical(envir, .GlobalEnv) && 
[16:04:14.611]                         !identical(envir, emptyenv())) {
[16:04:14.611]                         if (exists("master", mode = "list", envir = envir, 
[16:04:14.611]                           inherits = FALSE)) {
[16:04:14.611]                           master <- get("master", mode = "list", 
[16:04:14.611]                             envir = envir, inherits = FALSE)
[16:04:14.611]                           if (inherits(master, c("SOCKnode", 
[16:04:14.611]                             "SOCK0node"))) {
[16:04:14.611]                             sendCondition <<- function(cond) {
[16:04:14.611]                               data <- list(type = "VALUE", value = cond, 
[16:04:14.611]                                 success = TRUE)
[16:04:14.611]                               parallel_sendData(master, data)
[16:04:14.611]                             }
[16:04:14.611]                             return(sendCondition)
[16:04:14.611]                           }
[16:04:14.611]                         }
[16:04:14.611]                         frame <- frame + 1L
[16:04:14.611]                         envir <- sys.frame(frame)
[16:04:14.611]                       }
[16:04:14.611]                     }
[16:04:14.611]                     sendCondition <<- function(cond) NULL
[16:04:14.611]                   }
[16:04:14.611]                 })
[16:04:14.611]                 withCallingHandlers({
[16:04:14.611]                   {
[16:04:14.611]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:04:14.611]                       ii, n), appendLF = FALSE)
[16:04:14.611]                     fit <- mandelbrot(C)
[16:04:14.611]                     delay(fit)
[16:04:14.611]                     message(" done")
[16:04:14.611]                     fit
[16:04:14.611]                   }
[16:04:14.611]                 }, immediateCondition = function(cond) {
[16:04:14.611]                   sendCondition <- ...future.makeSendCondition()
[16:04:14.611]                   sendCondition(cond)
[16:04:14.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:14.611]                   {
[16:04:14.611]                     inherits <- base::inherits
[16:04:14.611]                     invokeRestart <- base::invokeRestart
[16:04:14.611]                     is.null <- base::is.null
[16:04:14.611]                     muffled <- FALSE
[16:04:14.611]                     if (inherits(cond, "message")) {
[16:04:14.611]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:14.611]                       if (muffled) 
[16:04:14.611]                         invokeRestart("muffleMessage")
[16:04:14.611]                     }
[16:04:14.611]                     else if (inherits(cond, "warning")) {
[16:04:14.611]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:14.611]                       if (muffled) 
[16:04:14.611]                         invokeRestart("muffleWarning")
[16:04:14.611]                     }
[16:04:14.611]                     else if (inherits(cond, "condition")) {
[16:04:14.611]                       if (!is.null(pattern)) {
[16:04:14.611]                         computeRestarts <- base::computeRestarts
[16:04:14.611]                         grepl <- base::grepl
[16:04:14.611]                         restarts <- computeRestarts(cond)
[16:04:14.611]                         for (restart in restarts) {
[16:04:14.611]                           name <- restart$name
[16:04:14.611]                           if (is.null(name)) 
[16:04:14.611]                             next
[16:04:14.611]                           if (!grepl(pattern, name)) 
[16:04:14.611]                             next
[16:04:14.611]                           invokeRestart(restart)
[16:04:14.611]                           muffled <- TRUE
[16:04:14.611]                           break
[16:04:14.611]                         }
[16:04:14.611]                       }
[16:04:14.611]                     }
[16:04:14.611]                     invisible(muffled)
[16:04:14.611]                   }
[16:04:14.611]                   muffleCondition(cond)
[16:04:14.611]                 })
[16:04:14.611]             }))
[16:04:14.611]             future::FutureResult(value = ...future.value$value, 
[16:04:14.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:14.611]                   ...future.rng), globalenv = if (FALSE) 
[16:04:14.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:14.611]                     ...future.globalenv.names))
[16:04:14.611]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:14.611]         }, condition = base::local({
[16:04:14.611]             c <- base::c
[16:04:14.611]             inherits <- base::inherits
[16:04:14.611]             invokeRestart <- base::invokeRestart
[16:04:14.611]             length <- base::length
[16:04:14.611]             list <- base::list
[16:04:14.611]             seq.int <- base::seq.int
[16:04:14.611]             signalCondition <- base::signalCondition
[16:04:14.611]             sys.calls <- base::sys.calls
[16:04:14.611]             `[[` <- base::`[[`
[16:04:14.611]             `+` <- base::`+`
[16:04:14.611]             `<<-` <- base::`<<-`
[16:04:14.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:14.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:14.611]                   3L)]
[16:04:14.611]             }
[16:04:14.611]             function(cond) {
[16:04:14.611]                 is_error <- inherits(cond, "error")
[16:04:14.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:14.611]                   NULL)
[16:04:14.611]                 if (is_error) {
[16:04:14.611]                   sessionInformation <- function() {
[16:04:14.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:14.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:14.611]                       search = base::search(), system = base::Sys.info())
[16:04:14.611]                   }
[16:04:14.611]                   ...future.conditions[[length(...future.conditions) + 
[16:04:14.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:14.611]                     cond$call), session = sessionInformation(), 
[16:04:14.611]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:14.611]                   signalCondition(cond)
[16:04:14.611]                 }
[16:04:14.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:14.611]                 "immediateCondition"))) {
[16:04:14.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:14.611]                   ...future.conditions[[length(...future.conditions) + 
[16:04:14.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:14.611]                   if (TRUE && !signal) {
[16:04:14.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:14.611]                     {
[16:04:14.611]                       inherits <- base::inherits
[16:04:14.611]                       invokeRestart <- base::invokeRestart
[16:04:14.611]                       is.null <- base::is.null
[16:04:14.611]                       muffled <- FALSE
[16:04:14.611]                       if (inherits(cond, "message")) {
[16:04:14.611]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:14.611]                         if (muffled) 
[16:04:14.611]                           invokeRestart("muffleMessage")
[16:04:14.611]                       }
[16:04:14.611]                       else if (inherits(cond, "warning")) {
[16:04:14.611]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:14.611]                         if (muffled) 
[16:04:14.611]                           invokeRestart("muffleWarning")
[16:04:14.611]                       }
[16:04:14.611]                       else if (inherits(cond, "condition")) {
[16:04:14.611]                         if (!is.null(pattern)) {
[16:04:14.611]                           computeRestarts <- base::computeRestarts
[16:04:14.611]                           grepl <- base::grepl
[16:04:14.611]                           restarts <- computeRestarts(cond)
[16:04:14.611]                           for (restart in restarts) {
[16:04:14.611]                             name <- restart$name
[16:04:14.611]                             if (is.null(name)) 
[16:04:14.611]                               next
[16:04:14.611]                             if (!grepl(pattern, name)) 
[16:04:14.611]                               next
[16:04:14.611]                             invokeRestart(restart)
[16:04:14.611]                             muffled <- TRUE
[16:04:14.611]                             break
[16:04:14.611]                           }
[16:04:14.611]                         }
[16:04:14.611]                       }
[16:04:14.611]                       invisible(muffled)
[16:04:14.611]                     }
[16:04:14.611]                     muffleCondition(cond, pattern = "^muffle")
[16:04:14.611]                   }
[16:04:14.611]                 }
[16:04:14.611]                 else {
[16:04:14.611]                   if (TRUE) {
[16:04:14.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:14.611]                     {
[16:04:14.611]                       inherits <- base::inherits
[16:04:14.611]                       invokeRestart <- base::invokeRestart
[16:04:14.611]                       is.null <- base::is.null
[16:04:14.611]                       muffled <- FALSE
[16:04:14.611]                       if (inherits(cond, "message")) {
[16:04:14.611]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:14.611]                         if (muffled) 
[16:04:14.611]                           invokeRestart("muffleMessage")
[16:04:14.611]                       }
[16:04:14.611]                       else if (inherits(cond, "warning")) {
[16:04:14.611]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:14.611]                         if (muffled) 
[16:04:14.611]                           invokeRestart("muffleWarning")
[16:04:14.611]                       }
[16:04:14.611]                       else if (inherits(cond, "condition")) {
[16:04:14.611]                         if (!is.null(pattern)) {
[16:04:14.611]                           computeRestarts <- base::computeRestarts
[16:04:14.611]                           grepl <- base::grepl
[16:04:14.611]                           restarts <- computeRestarts(cond)
[16:04:14.611]                           for (restart in restarts) {
[16:04:14.611]                             name <- restart$name
[16:04:14.611]                             if (is.null(name)) 
[16:04:14.611]                               next
[16:04:14.611]                             if (!grepl(pattern, name)) 
[16:04:14.611]                               next
[16:04:14.611]                             invokeRestart(restart)
[16:04:14.611]                             muffled <- TRUE
[16:04:14.611]                             break
[16:04:14.611]                           }
[16:04:14.611]                         }
[16:04:14.611]                       }
[16:04:14.611]                       invisible(muffled)
[16:04:14.611]                     }
[16:04:14.611]                     muffleCondition(cond, pattern = "^muffle")
[16:04:14.611]                   }
[16:04:14.611]                 }
[16:04:14.611]             }
[16:04:14.611]         }))
[16:04:14.611]     }, error = function(ex) {
[16:04:14.611]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:14.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:14.611]                 ...future.rng), started = ...future.startTime, 
[16:04:14.611]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:14.611]             version = "1.8"), class = "FutureResult")
[16:04:14.611]     }, finally = {
[16:04:14.611]         if (!identical(...future.workdir, getwd())) 
[16:04:14.611]             setwd(...future.workdir)
[16:04:14.611]         {
[16:04:14.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:14.611]                 ...future.oldOptions$nwarnings <- NULL
[16:04:14.611]             }
[16:04:14.611]             base::options(...future.oldOptions)
[16:04:14.611]             if (.Platform$OS.type == "windows") {
[16:04:14.611]                 old_names <- names(...future.oldEnvVars)
[16:04:14.611]                 envs <- base::Sys.getenv()
[16:04:14.611]                 names <- names(envs)
[16:04:14.611]                 common <- intersect(names, old_names)
[16:04:14.611]                 added <- setdiff(names, old_names)
[16:04:14.611]                 removed <- setdiff(old_names, names)
[16:04:14.611]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:14.611]                   envs[common]]
[16:04:14.611]                 NAMES <- toupper(changed)
[16:04:14.611]                 args <- list()
[16:04:14.611]                 for (kk in seq_along(NAMES)) {
[16:04:14.611]                   name <- changed[[kk]]
[16:04:14.611]                   NAME <- NAMES[[kk]]
[16:04:14.611]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:14.611]                     next
[16:04:14.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:14.611]                 }
[16:04:14.611]                 NAMES <- toupper(added)
[16:04:14.611]                 for (kk in seq_along(NAMES)) {
[16:04:14.611]                   name <- added[[kk]]
[16:04:14.611]                   NAME <- NAMES[[kk]]
[16:04:14.611]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:14.611]                     next
[16:04:14.611]                   args[[name]] <- ""
[16:04:14.611]                 }
[16:04:14.611]                 NAMES <- toupper(removed)
[16:04:14.611]                 for (kk in seq_along(NAMES)) {
[16:04:14.611]                   name <- removed[[kk]]
[16:04:14.611]                   NAME <- NAMES[[kk]]
[16:04:14.611]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:14.611]                     next
[16:04:14.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:14.611]                 }
[16:04:14.611]                 if (length(args) > 0) 
[16:04:14.611]                   base::do.call(base::Sys.setenv, args = args)
[16:04:14.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:14.611]             }
[16:04:14.611]             else {
[16:04:14.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:14.611]             }
[16:04:14.611]             {
[16:04:14.611]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:14.611]                   0L) {
[16:04:14.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:14.611]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:14.611]                   base::options(opts)
[16:04:14.611]                 }
[16:04:14.611]                 {
[16:04:14.611]                   {
[16:04:14.611]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:14.611]                     NULL
[16:04:14.611]                   }
[16:04:14.611]                   options(future.plan = NULL)
[16:04:14.611]                   if (is.na(NA_character_)) 
[16:04:14.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:14.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:14.611]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:14.611]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:14.611]                     envir = parent.frame()) 
[16:04:14.611]                   {
[16:04:14.611]                     if (is.function(workers)) 
[16:04:14.611]                       workers <- workers()
[16:04:14.611]                     workers <- structure(as.integer(workers), 
[16:04:14.611]                       class = class(workers))
[16:04:14.611]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:14.611]                       workers >= 1)
[16:04:14.611]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:14.611]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:14.611]                     }
[16:04:14.611]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:14.611]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:14.611]                       envir = envir)
[16:04:14.611]                     if (!future$lazy) 
[16:04:14.611]                       future <- run(future)
[16:04:14.611]                     invisible(future)
[16:04:14.611]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:14.611]                 }
[16:04:14.611]             }
[16:04:14.611]         }
[16:04:14.611]     })
[16:04:14.611]     if (TRUE) {
[16:04:14.611]         base::sink(type = "output", split = FALSE)
[16:04:14.611]         if (TRUE) {
[16:04:14.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:14.611]         }
[16:04:14.611]         else {
[16:04:14.611]             ...future.result["stdout"] <- base::list(NULL)
[16:04:14.611]         }
[16:04:14.611]         base::close(...future.stdout)
[16:04:14.611]         ...future.stdout <- NULL
[16:04:14.611]     }
[16:04:14.611]     ...future.result$conditions <- ...future.conditions
[16:04:14.611]     ...future.result$finished <- base::Sys.time()
[16:04:14.611]     ...future.result
[16:04:14.611] }
[16:04:14.614] Exporting 4 global objects (14.24 KiB) to cluster node #1 ...
[16:04:14.614] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:04:14.614] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:04:14.614] Exporting ‘n’ (56 bytes) to cluster node #1 ...
[16:04:14.614] Exporting ‘n’ (56 bytes) to cluster node #1 ... DONE
[16:04:14.615] Exporting ‘C’ (10.72 KiB) to cluster node #1 ...
[16:04:14.655] Exporting ‘C’ (10.72 KiB) to cluster node #1 ... DONE
[16:04:14.655] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ...
[16:04:14.699] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ... DONE
[16:04:14.700] Exporting 4 global objects (14.24 KiB) to cluster node #1 ... DONE
[16:04:14.701] MultisessionFuture started
[16:04:14.701] - Launch lazy future ... done
[16:04:14.701] run() for ‘MultisessionFuture’ ... done
[16:04:14.701] - run() ... done
[16:04:14.701] - resolved() ...
[16:04:14.712] - resolved: FALSE
[16:04:14.712] - resolved() ... done
[16:04:14.712] resolved() for ‘MultisessionFuture’ ... done
[16:04:14.712] resolved() for ‘Future’ ...
[16:04:14.713] - state: ‘created’
[16:04:14.713] - run: TRUE
[16:04:14.713] - run() ...
[16:04:14.713] run() for ‘Future’ ...
[16:04:14.713] - state: ‘created’
[16:04:14.713] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:14.727] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:14.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:14.727]   - Field: ‘node’
[16:04:14.727]   - Field: ‘label’
[16:04:14.727]   - Field: ‘local’
[16:04:14.727]   - Field: ‘owner’
[16:04:14.727]   - Field: ‘envir’
[16:04:14.728]   - Field: ‘workers’
[16:04:14.728]   - Field: ‘packages’
[16:04:14.728]   - Field: ‘gc’
[16:04:14.728]   - Field: ‘conditions’
[16:04:14.728]   - Field: ‘persistent’
[16:04:14.728]   - Field: ‘expr’
[16:04:14.728]   - Field: ‘uuid’
[16:04:14.728]   - Field: ‘seed’
[16:04:14.728]   - Field: ‘version’
[16:04:14.728]   - Field: ‘result’
[16:04:14.728]   - Field: ‘asynchronous’
[16:04:14.729]   - Field: ‘calls’
[16:04:14.729]   - Field: ‘globals’
[16:04:14.729]   - Field: ‘stdout’
[16:04:14.729]   - Field: ‘earlySignal’
[16:04:14.729]   - Field: ‘lazy’
[16:04:14.729]   - Field: ‘state’
[16:04:14.729] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:14.729] - Launch lazy future ...
[16:04:14.729] Packages needed by the future expression (n = 1): ‘future’
[16:04:14.730] Packages needed by future strategies (n = 0): <none>
[16:04:14.730] {
[16:04:14.730]     {
[16:04:14.730]         {
[16:04:14.730]             ...future.startTime <- base::Sys.time()
[16:04:14.730]             {
[16:04:14.730]                 {
[16:04:14.730]                   {
[16:04:14.730]                     {
[16:04:14.730]                       {
[16:04:14.730]                         base::local({
[16:04:14.730]                           has_future <- base::requireNamespace("future", 
[16:04:14.730]                             quietly = TRUE)
[16:04:14.730]                           if (has_future) {
[16:04:14.730]                             ns <- base::getNamespace("future")
[16:04:14.730]                             version <- ns[[".package"]][["version"]]
[16:04:14.730]                             if (is.null(version)) 
[16:04:14.730]                               version <- utils::packageVersion("future")
[16:04:14.730]                           }
[16:04:14.730]                           else {
[16:04:14.730]                             version <- NULL
[16:04:14.730]                           }
[16:04:14.730]                           if (!has_future || version < "1.8.0") {
[16:04:14.730]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:14.730]                               "", base::R.version$version.string), 
[16:04:14.730]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:14.730]                                 base::R.version$platform, 8 * 
[16:04:14.730]                                   base::.Machine$sizeof.pointer), 
[16:04:14.730]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:14.730]                                 "release", "version")], collapse = " "), 
[16:04:14.730]                               hostname = base::Sys.info()[["nodename"]])
[16:04:14.730]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:14.730]                               info)
[16:04:14.730]                             info <- base::paste(info, collapse = "; ")
[16:04:14.730]                             if (!has_future) {
[16:04:14.730]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:14.730]                                 info)
[16:04:14.730]                             }
[16:04:14.730]                             else {
[16:04:14.730]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:14.730]                                 info, version)
[16:04:14.730]                             }
[16:04:14.730]                             base::stop(msg)
[16:04:14.730]                           }
[16:04:14.730]                         })
[16:04:14.730]                       }
[16:04:14.730]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:14.730]                       base::options(mc.cores = 1L)
[16:04:14.730]                     }
[16:04:14.730]                     base::local({
[16:04:14.730]                       for (pkg in "future") {
[16:04:14.730]                         base::loadNamespace(pkg)
[16:04:14.730]                         base::library(pkg, character.only = TRUE)
[16:04:14.730]                       }
[16:04:14.730]                     })
[16:04:14.730]                   }
[16:04:14.730]                   options(future.plan = NULL)
[16:04:14.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:14.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:14.730]                 }
[16:04:14.730]                 ...future.workdir <- getwd()
[16:04:14.730]             }
[16:04:14.730]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:14.730]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:14.730]         }
[16:04:14.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:14.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:14.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:14.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:14.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:14.730]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:14.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:14.730]             base::names(...future.oldOptions))
[16:04:14.730]     }
[16:04:14.730]     if (FALSE) {
[16:04:14.730]     }
[16:04:14.730]     else {
[16:04:14.730]         if (TRUE) {
[16:04:14.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:14.730]                 open = "w")
[16:04:14.730]         }
[16:04:14.730]         else {
[16:04:14.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:14.730]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:14.730]         }
[16:04:14.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:14.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:14.730]             base::sink(type = "output", split = FALSE)
[16:04:14.730]             base::close(...future.stdout)
[16:04:14.730]         }, add = TRUE)
[16:04:14.730]     }
[16:04:14.730]     ...future.frame <- base::sys.nframe()
[16:04:14.730]     ...future.conditions <- base::list()
[16:04:14.730]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:14.730]     if (FALSE) {
[16:04:14.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:14.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:14.730]     }
[16:04:14.730]     ...future.result <- base::tryCatch({
[16:04:14.730]         base::withCallingHandlers({
[16:04:14.730]             ...future.value <- base::withVisible(base::local({
[16:04:14.730]                 ...future.makeSendCondition <- base::local({
[16:04:14.730]                   sendCondition <- NULL
[16:04:14.730]                   function(frame = 1L) {
[16:04:14.730]                     if (is.function(sendCondition)) 
[16:04:14.730]                       return(sendCondition)
[16:04:14.730]                     ns <- getNamespace("parallel")
[16:04:14.730]                     if (exists("sendData", mode = "function", 
[16:04:14.730]                       envir = ns)) {
[16:04:14.730]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:14.730]                         envir = ns)
[16:04:14.730]                       envir <- sys.frame(frame)
[16:04:14.730]                       master <- NULL
[16:04:14.730]                       while (!identical(envir, .GlobalEnv) && 
[16:04:14.730]                         !identical(envir, emptyenv())) {
[16:04:14.730]                         if (exists("master", mode = "list", envir = envir, 
[16:04:14.730]                           inherits = FALSE)) {
[16:04:14.730]                           master <- get("master", mode = "list", 
[16:04:14.730]                             envir = envir, inherits = FALSE)
[16:04:14.730]                           if (inherits(master, c("SOCKnode", 
[16:04:14.730]                             "SOCK0node"))) {
[16:04:14.730]                             sendCondition <<- function(cond) {
[16:04:14.730]                               data <- list(type = "VALUE", value = cond, 
[16:04:14.730]                                 success = TRUE)
[16:04:14.730]                               parallel_sendData(master, data)
[16:04:14.730]                             }
[16:04:14.730]                             return(sendCondition)
[16:04:14.730]                           }
[16:04:14.730]                         }
[16:04:14.730]                         frame <- frame + 1L
[16:04:14.730]                         envir <- sys.frame(frame)
[16:04:14.730]                       }
[16:04:14.730]                     }
[16:04:14.730]                     sendCondition <<- function(cond) NULL
[16:04:14.730]                   }
[16:04:14.730]                 })
[16:04:14.730]                 withCallingHandlers({
[16:04:14.730]                   {
[16:04:14.730]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:04:14.730]                       ii, n), appendLF = FALSE)
[16:04:14.730]                     fit <- mandelbrot(C)
[16:04:14.730]                     delay(fit)
[16:04:14.730]                     message(" done")
[16:04:14.730]                     fit
[16:04:14.730]                   }
[16:04:14.730]                 }, immediateCondition = function(cond) {
[16:04:14.730]                   sendCondition <- ...future.makeSendCondition()
[16:04:14.730]                   sendCondition(cond)
[16:04:14.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:14.730]                   {
[16:04:14.730]                     inherits <- base::inherits
[16:04:14.730]                     invokeRestart <- base::invokeRestart
[16:04:14.730]                     is.null <- base::is.null
[16:04:14.730]                     muffled <- FALSE
[16:04:14.730]                     if (inherits(cond, "message")) {
[16:04:14.730]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:14.730]                       if (muffled) 
[16:04:14.730]                         invokeRestart("muffleMessage")
[16:04:14.730]                     }
[16:04:14.730]                     else if (inherits(cond, "warning")) {
[16:04:14.730]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:14.730]                       if (muffled) 
[16:04:14.730]                         invokeRestart("muffleWarning")
[16:04:14.730]                     }
[16:04:14.730]                     else if (inherits(cond, "condition")) {
[16:04:14.730]                       if (!is.null(pattern)) {
[16:04:14.730]                         computeRestarts <- base::computeRestarts
[16:04:14.730]                         grepl <- base::grepl
[16:04:14.730]                         restarts <- computeRestarts(cond)
[16:04:14.730]                         for (restart in restarts) {
[16:04:14.730]                           name <- restart$name
[16:04:14.730]                           if (is.null(name)) 
[16:04:14.730]                             next
[16:04:14.730]                           if (!grepl(pattern, name)) 
[16:04:14.730]                             next
[16:04:14.730]                           invokeRestart(restart)
[16:04:14.730]                           muffled <- TRUE
[16:04:14.730]                           break
[16:04:14.730]                         }
[16:04:14.730]                       }
[16:04:14.730]                     }
[16:04:14.730]                     invisible(muffled)
[16:04:14.730]                   }
[16:04:14.730]                   muffleCondition(cond)
[16:04:14.730]                 })
[16:04:14.730]             }))
[16:04:14.730]             future::FutureResult(value = ...future.value$value, 
[16:04:14.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:14.730]                   ...future.rng), globalenv = if (FALSE) 
[16:04:14.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:14.730]                     ...future.globalenv.names))
[16:04:14.730]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:14.730]         }, condition = base::local({
[16:04:14.730]             c <- base::c
[16:04:14.730]             inherits <- base::inherits
[16:04:14.730]             invokeRestart <- base::invokeRestart
[16:04:14.730]             length <- base::length
[16:04:14.730]             list <- base::list
[16:04:14.730]             seq.int <- base::seq.int
[16:04:14.730]             signalCondition <- base::signalCondition
[16:04:14.730]             sys.calls <- base::sys.calls
[16:04:14.730]             `[[` <- base::`[[`
[16:04:14.730]             `+` <- base::`+`
[16:04:14.730]             `<<-` <- base::`<<-`
[16:04:14.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:14.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:14.730]                   3L)]
[16:04:14.730]             }
[16:04:14.730]             function(cond) {
[16:04:14.730]                 is_error <- inherits(cond, "error")
[16:04:14.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:14.730]                   NULL)
[16:04:14.730]                 if (is_error) {
[16:04:14.730]                   sessionInformation <- function() {
[16:04:14.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:14.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:14.730]                       search = base::search(), system = base::Sys.info())
[16:04:14.730]                   }
[16:04:14.730]                   ...future.conditions[[length(...future.conditions) + 
[16:04:14.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:14.730]                     cond$call), session = sessionInformation(), 
[16:04:14.730]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:14.730]                   signalCondition(cond)
[16:04:14.730]                 }
[16:04:14.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:14.730]                 "immediateCondition"))) {
[16:04:14.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:14.730]                   ...future.conditions[[length(...future.conditions) + 
[16:04:14.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:14.730]                   if (TRUE && !signal) {
[16:04:14.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:14.730]                     {
[16:04:14.730]                       inherits <- base::inherits
[16:04:14.730]                       invokeRestart <- base::invokeRestart
[16:04:14.730]                       is.null <- base::is.null
[16:04:14.730]                       muffled <- FALSE
[16:04:14.730]                       if (inherits(cond, "message")) {
[16:04:14.730]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:14.730]                         if (muffled) 
[16:04:14.730]                           invokeRestart("muffleMessage")
[16:04:14.730]                       }
[16:04:14.730]                       else if (inherits(cond, "warning")) {
[16:04:14.730]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:14.730]                         if (muffled) 
[16:04:14.730]                           invokeRestart("muffleWarning")
[16:04:14.730]                       }
[16:04:14.730]                       else if (inherits(cond, "condition")) {
[16:04:14.730]                         if (!is.null(pattern)) {
[16:04:14.730]                           computeRestarts <- base::computeRestarts
[16:04:14.730]                           grepl <- base::grepl
[16:04:14.730]                           restarts <- computeRestarts(cond)
[16:04:14.730]                           for (restart in restarts) {
[16:04:14.730]                             name <- restart$name
[16:04:14.730]                             if (is.null(name)) 
[16:04:14.730]                               next
[16:04:14.730]                             if (!grepl(pattern, name)) 
[16:04:14.730]                               next
[16:04:14.730]                             invokeRestart(restart)
[16:04:14.730]                             muffled <- TRUE
[16:04:14.730]                             break
[16:04:14.730]                           }
[16:04:14.730]                         }
[16:04:14.730]                       }
[16:04:14.730]                       invisible(muffled)
[16:04:14.730]                     }
[16:04:14.730]                     muffleCondition(cond, pattern = "^muffle")
[16:04:14.730]                   }
[16:04:14.730]                 }
[16:04:14.730]                 else {
[16:04:14.730]                   if (TRUE) {
[16:04:14.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:14.730]                     {
[16:04:14.730]                       inherits <- base::inherits
[16:04:14.730]                       invokeRestart <- base::invokeRestart
[16:04:14.730]                       is.null <- base::is.null
[16:04:14.730]                       muffled <- FALSE
[16:04:14.730]                       if (inherits(cond, "message")) {
[16:04:14.730]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:14.730]                         if (muffled) 
[16:04:14.730]                           invokeRestart("muffleMessage")
[16:04:14.730]                       }
[16:04:14.730]                       else if (inherits(cond, "warning")) {
[16:04:14.730]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:14.730]                         if (muffled) 
[16:04:14.730]                           invokeRestart("muffleWarning")
[16:04:14.730]                       }
[16:04:14.730]                       else if (inherits(cond, "condition")) {
[16:04:14.730]                         if (!is.null(pattern)) {
[16:04:14.730]                           computeRestarts <- base::computeRestarts
[16:04:14.730]                           grepl <- base::grepl
[16:04:14.730]                           restarts <- computeRestarts(cond)
[16:04:14.730]                           for (restart in restarts) {
[16:04:14.730]                             name <- restart$name
[16:04:14.730]                             if (is.null(name)) 
[16:04:14.730]                               next
[16:04:14.730]                             if (!grepl(pattern, name)) 
[16:04:14.730]                               next
[16:04:14.730]                             invokeRestart(restart)
[16:04:14.730]                             muffled <- TRUE
[16:04:14.730]                             break
[16:04:14.730]                           }
[16:04:14.730]                         }
[16:04:14.730]                       }
[16:04:14.730]                       invisible(muffled)
[16:04:14.730]                     }
[16:04:14.730]                     muffleCondition(cond, pattern = "^muffle")
[16:04:14.730]                   }
[16:04:14.730]                 }
[16:04:14.730]             }
[16:04:14.730]         }))
[16:04:14.730]     }, error = function(ex) {
[16:04:14.730]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:14.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:14.730]                 ...future.rng), started = ...future.startTime, 
[16:04:14.730]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:14.730]             version = "1.8"), class = "FutureResult")
[16:04:14.730]     }, finally = {
[16:04:14.730]         if (!identical(...future.workdir, getwd())) 
[16:04:14.730]             setwd(...future.workdir)
[16:04:14.730]         {
[16:04:14.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:14.730]                 ...future.oldOptions$nwarnings <- NULL
[16:04:14.730]             }
[16:04:14.730]             base::options(...future.oldOptions)
[16:04:14.730]             if (.Platform$OS.type == "windows") {
[16:04:14.730]                 old_names <- names(...future.oldEnvVars)
[16:04:14.730]                 envs <- base::Sys.getenv()
[16:04:14.730]                 names <- names(envs)
[16:04:14.730]                 common <- intersect(names, old_names)
[16:04:14.730]                 added <- setdiff(names, old_names)
[16:04:14.730]                 removed <- setdiff(old_names, names)
[16:04:14.730]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:14.730]                   envs[common]]
[16:04:14.730]                 NAMES <- toupper(changed)
[16:04:14.730]                 args <- list()
[16:04:14.730]                 for (kk in seq_along(NAMES)) {
[16:04:14.730]                   name <- changed[[kk]]
[16:04:14.730]                   NAME <- NAMES[[kk]]
[16:04:14.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:14.730]                     next
[16:04:14.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:14.730]                 }
[16:04:14.730]                 NAMES <- toupper(added)
[16:04:14.730]                 for (kk in seq_along(NAMES)) {
[16:04:14.730]                   name <- added[[kk]]
[16:04:14.730]                   NAME <- NAMES[[kk]]
[16:04:14.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:14.730]                     next
[16:04:14.730]                   args[[name]] <- ""
[16:04:14.730]                 }
[16:04:14.730]                 NAMES <- toupper(removed)
[16:04:14.730]                 for (kk in seq_along(NAMES)) {
[16:04:14.730]                   name <- removed[[kk]]
[16:04:14.730]                   NAME <- NAMES[[kk]]
[16:04:14.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:14.730]                     next
[16:04:14.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:14.730]                 }
[16:04:14.730]                 if (length(args) > 0) 
[16:04:14.730]                   base::do.call(base::Sys.setenv, args = args)
[16:04:14.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:14.730]             }
[16:04:14.730]             else {
[16:04:14.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:14.730]             }
[16:04:14.730]             {
[16:04:14.730]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:14.730]                   0L) {
[16:04:14.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:14.730]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:14.730]                   base::options(opts)
[16:04:14.730]                 }
[16:04:14.730]                 {
[16:04:14.730]                   {
[16:04:14.730]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:14.730]                     NULL
[16:04:14.730]                   }
[16:04:14.730]                   options(future.plan = NULL)
[16:04:14.730]                   if (is.na(NA_character_)) 
[16:04:14.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:14.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:14.730]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:14.730]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:14.730]                     envir = parent.frame()) 
[16:04:14.730]                   {
[16:04:14.730]                     if (is.function(workers)) 
[16:04:14.730]                       workers <- workers()
[16:04:14.730]                     workers <- structure(as.integer(workers), 
[16:04:14.730]                       class = class(workers))
[16:04:14.730]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:14.730]                       workers >= 1)
[16:04:14.730]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:14.730]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:14.730]                     }
[16:04:14.730]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:14.730]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:14.730]                       envir = envir)
[16:04:14.730]                     if (!future$lazy) 
[16:04:14.730]                       future <- run(future)
[16:04:14.730]                     invisible(future)
[16:04:14.730]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:14.730]                 }
[16:04:14.730]             }
[16:04:14.730]         }
[16:04:14.730]     })
[16:04:14.730]     if (TRUE) {
[16:04:14.730]         base::sink(type = "output", split = FALSE)
[16:04:14.730]         if (TRUE) {
[16:04:14.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:14.730]         }
[16:04:14.730]         else {
[16:04:14.730]             ...future.result["stdout"] <- base::list(NULL)
[16:04:14.730]         }
[16:04:14.730]         base::close(...future.stdout)
[16:04:14.730]         ...future.stdout <- NULL
[16:04:14.730]     }
[16:04:14.730]     ...future.result$conditions <- ...future.conditions
[16:04:14.730]     ...future.result$finished <- base::Sys.time()
[16:04:14.730]     ...future.result
[16:04:14.730] }
[16:04:14.784] Exporting 4 global objects (14.24 KiB) to cluster node #2 ...
[16:04:14.784] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:04:14.784] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:04:14.785] Exporting ‘n’ (56 bytes) to cluster node #2 ...
[16:04:14.785] Exporting ‘n’ (56 bytes) to cluster node #2 ... DONE
[16:04:14.785] Exporting ‘C’ (10.72 KiB) to cluster node #2 ...
[16:04:14.827] Exporting ‘C’ (10.72 KiB) to cluster node #2 ... DONE
[16:04:14.827] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ...
[16:04:14.871] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ... DONE
[16:04:14.871] Exporting 4 global objects (14.24 KiB) to cluster node #2 ... DONE
[16:04:14.872] MultisessionFuture started
[16:04:14.873] - Launch lazy future ... done
[16:04:14.873] run() for ‘MultisessionFuture’ ... done
[16:04:14.873] - run() ... done
[16:04:14.873] - resolved() ...
[16:04:14.884] - resolved: FALSE
[16:04:14.884] - resolved() ... done
[16:04:14.884] resolved() for ‘MultisessionFuture’ ... done
[16:04:14.884] resolved() for ‘Future’ ...
[16:04:14.884] - state: ‘created’
[16:04:14.884] - run: TRUE
[16:04:14.884] - run() ...
[16:04:14.884] run() for ‘Future’ ...
[16:04:14.884] - state: ‘created’
[16:04:14.885] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:14.899] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:14.899] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:14.899]   - Field: ‘node’
[16:04:14.899]   - Field: ‘label’
[16:04:14.899]   - Field: ‘local’
[16:04:14.899]   - Field: ‘owner’
[16:04:14.899]   - Field: ‘envir’
[16:04:14.900]   - Field: ‘workers’
[16:04:14.900]   - Field: ‘packages’
[16:04:14.900]   - Field: ‘gc’
[16:04:14.900]   - Field: ‘conditions’
[16:04:14.900]   - Field: ‘persistent’
[16:04:14.900]   - Field: ‘expr’
[16:04:14.900]   - Field: ‘uuid’
[16:04:14.900]   - Field: ‘seed’
[16:04:14.900]   - Field: ‘version’
[16:04:14.900]   - Field: ‘result’
[16:04:14.900]   - Field: ‘asynchronous’
[16:04:14.901]   - Field: ‘calls’
[16:04:14.901]   - Field: ‘globals’
[16:04:14.901]   - Field: ‘stdout’
[16:04:14.901]   - Field: ‘earlySignal’
[16:04:14.901]   - Field: ‘lazy’
[16:04:14.901]   - Field: ‘state’
[16:04:14.901] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:14.901] - Launch lazy future ...
[16:04:14.901] Packages needed by the future expression (n = 1): ‘future’
[16:04:14.902] Packages needed by future strategies (n = 0): <none>
[16:04:14.902] {
[16:04:14.902]     {
[16:04:14.902]         {
[16:04:14.902]             ...future.startTime <- base::Sys.time()
[16:04:14.902]             {
[16:04:14.902]                 {
[16:04:14.902]                   {
[16:04:14.902]                     {
[16:04:14.902]                       {
[16:04:14.902]                         base::local({
[16:04:14.902]                           has_future <- base::requireNamespace("future", 
[16:04:14.902]                             quietly = TRUE)
[16:04:14.902]                           if (has_future) {
[16:04:14.902]                             ns <- base::getNamespace("future")
[16:04:14.902]                             version <- ns[[".package"]][["version"]]
[16:04:14.902]                             if (is.null(version)) 
[16:04:14.902]                               version <- utils::packageVersion("future")
[16:04:14.902]                           }
[16:04:14.902]                           else {
[16:04:14.902]                             version <- NULL
[16:04:14.902]                           }
[16:04:14.902]                           if (!has_future || version < "1.8.0") {
[16:04:14.902]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:14.902]                               "", base::R.version$version.string), 
[16:04:14.902]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:14.902]                                 base::R.version$platform, 8 * 
[16:04:14.902]                                   base::.Machine$sizeof.pointer), 
[16:04:14.902]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:14.902]                                 "release", "version")], collapse = " "), 
[16:04:14.902]                               hostname = base::Sys.info()[["nodename"]])
[16:04:14.902]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:14.902]                               info)
[16:04:14.902]                             info <- base::paste(info, collapse = "; ")
[16:04:14.902]                             if (!has_future) {
[16:04:14.902]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:14.902]                                 info)
[16:04:14.902]                             }
[16:04:14.902]                             else {
[16:04:14.902]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:14.902]                                 info, version)
[16:04:14.902]                             }
[16:04:14.902]                             base::stop(msg)
[16:04:14.902]                           }
[16:04:14.902]                         })
[16:04:14.902]                       }
[16:04:14.902]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:14.902]                       base::options(mc.cores = 1L)
[16:04:14.902]                     }
[16:04:14.902]                     base::local({
[16:04:14.902]                       for (pkg in "future") {
[16:04:14.902]                         base::loadNamespace(pkg)
[16:04:14.902]                         base::library(pkg, character.only = TRUE)
[16:04:14.902]                       }
[16:04:14.902]                     })
[16:04:14.902]                   }
[16:04:14.902]                   options(future.plan = NULL)
[16:04:14.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:14.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:14.902]                 }
[16:04:14.902]                 ...future.workdir <- getwd()
[16:04:14.902]             }
[16:04:14.902]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:14.902]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:14.902]         }
[16:04:14.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:14.902]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:14.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:14.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:14.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:14.902]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:14.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:14.902]             base::names(...future.oldOptions))
[16:04:14.902]     }
[16:04:14.902]     if (FALSE) {
[16:04:14.902]     }
[16:04:14.902]     else {
[16:04:14.902]         if (TRUE) {
[16:04:14.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:14.902]                 open = "w")
[16:04:14.902]         }
[16:04:14.902]         else {
[16:04:14.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:14.902]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:14.902]         }
[16:04:14.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:14.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:14.902]             base::sink(type = "output", split = FALSE)
[16:04:14.902]             base::close(...future.stdout)
[16:04:14.902]         }, add = TRUE)
[16:04:14.902]     }
[16:04:14.902]     ...future.frame <- base::sys.nframe()
[16:04:14.902]     ...future.conditions <- base::list()
[16:04:14.902]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:14.902]     if (FALSE) {
[16:04:14.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:14.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:14.902]     }
[16:04:14.902]     ...future.result <- base::tryCatch({
[16:04:14.902]         base::withCallingHandlers({
[16:04:14.902]             ...future.value <- base::withVisible(base::local({
[16:04:14.902]                 ...future.makeSendCondition <- base::local({
[16:04:14.902]                   sendCondition <- NULL
[16:04:14.902]                   function(frame = 1L) {
[16:04:14.902]                     if (is.function(sendCondition)) 
[16:04:14.902]                       return(sendCondition)
[16:04:14.902]                     ns <- getNamespace("parallel")
[16:04:14.902]                     if (exists("sendData", mode = "function", 
[16:04:14.902]                       envir = ns)) {
[16:04:14.902]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:14.902]                         envir = ns)
[16:04:14.902]                       envir <- sys.frame(frame)
[16:04:14.902]                       master <- NULL
[16:04:14.902]                       while (!identical(envir, .GlobalEnv) && 
[16:04:14.902]                         !identical(envir, emptyenv())) {
[16:04:14.902]                         if (exists("master", mode = "list", envir = envir, 
[16:04:14.902]                           inherits = FALSE)) {
[16:04:14.902]                           master <- get("master", mode = "list", 
[16:04:14.902]                             envir = envir, inherits = FALSE)
[16:04:14.902]                           if (inherits(master, c("SOCKnode", 
[16:04:14.902]                             "SOCK0node"))) {
[16:04:14.902]                             sendCondition <<- function(cond) {
[16:04:14.902]                               data <- list(type = "VALUE", value = cond, 
[16:04:14.902]                                 success = TRUE)
[16:04:14.902]                               parallel_sendData(master, data)
[16:04:14.902]                             }
[16:04:14.902]                             return(sendCondition)
[16:04:14.902]                           }
[16:04:14.902]                         }
[16:04:14.902]                         frame <- frame + 1L
[16:04:14.902]                         envir <- sys.frame(frame)
[16:04:14.902]                       }
[16:04:14.902]                     }
[16:04:14.902]                     sendCondition <<- function(cond) NULL
[16:04:14.902]                   }
[16:04:14.902]                 })
[16:04:14.902]                 withCallingHandlers({
[16:04:14.902]                   {
[16:04:14.902]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:04:14.902]                       ii, n), appendLF = FALSE)
[16:04:14.902]                     fit <- mandelbrot(C)
[16:04:14.902]                     delay(fit)
[16:04:14.902]                     message(" done")
[16:04:14.902]                     fit
[16:04:14.902]                   }
[16:04:14.902]                 }, immediateCondition = function(cond) {
[16:04:14.902]                   sendCondition <- ...future.makeSendCondition()
[16:04:14.902]                   sendCondition(cond)
[16:04:14.902]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:14.902]                   {
[16:04:14.902]                     inherits <- base::inherits
[16:04:14.902]                     invokeRestart <- base::invokeRestart
[16:04:14.902]                     is.null <- base::is.null
[16:04:14.902]                     muffled <- FALSE
[16:04:14.902]                     if (inherits(cond, "message")) {
[16:04:14.902]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:14.902]                       if (muffled) 
[16:04:14.902]                         invokeRestart("muffleMessage")
[16:04:14.902]                     }
[16:04:14.902]                     else if (inherits(cond, "warning")) {
[16:04:14.902]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:14.902]                       if (muffled) 
[16:04:14.902]                         invokeRestart("muffleWarning")
[16:04:14.902]                     }
[16:04:14.902]                     else if (inherits(cond, "condition")) {
[16:04:14.902]                       if (!is.null(pattern)) {
[16:04:14.902]                         computeRestarts <- base::computeRestarts
[16:04:14.902]                         grepl <- base::grepl
[16:04:14.902]                         restarts <- computeRestarts(cond)
[16:04:14.902]                         for (restart in restarts) {
[16:04:14.902]                           name <- restart$name
[16:04:14.902]                           if (is.null(name)) 
[16:04:14.902]                             next
[16:04:14.902]                           if (!grepl(pattern, name)) 
[16:04:14.902]                             next
[16:04:14.902]                           invokeRestart(restart)
[16:04:14.902]                           muffled <- TRUE
[16:04:14.902]                           break
[16:04:14.902]                         }
[16:04:14.902]                       }
[16:04:14.902]                     }
[16:04:14.902]                     invisible(muffled)
[16:04:14.902]                   }
[16:04:14.902]                   muffleCondition(cond)
[16:04:14.902]                 })
[16:04:14.902]             }))
[16:04:14.902]             future::FutureResult(value = ...future.value$value, 
[16:04:14.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:14.902]                   ...future.rng), globalenv = if (FALSE) 
[16:04:14.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:14.902]                     ...future.globalenv.names))
[16:04:14.902]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:14.902]         }, condition = base::local({
[16:04:14.902]             c <- base::c
[16:04:14.902]             inherits <- base::inherits
[16:04:14.902]             invokeRestart <- base::invokeRestart
[16:04:14.902]             length <- base::length
[16:04:14.902]             list <- base::list
[16:04:14.902]             seq.int <- base::seq.int
[16:04:14.902]             signalCondition <- base::signalCondition
[16:04:14.902]             sys.calls <- base::sys.calls
[16:04:14.902]             `[[` <- base::`[[`
[16:04:14.902]             `+` <- base::`+`
[16:04:14.902]             `<<-` <- base::`<<-`
[16:04:14.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:14.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:14.902]                   3L)]
[16:04:14.902]             }
[16:04:14.902]             function(cond) {
[16:04:14.902]                 is_error <- inherits(cond, "error")
[16:04:14.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:14.902]                   NULL)
[16:04:14.902]                 if (is_error) {
[16:04:14.902]                   sessionInformation <- function() {
[16:04:14.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:14.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:14.902]                       search = base::search(), system = base::Sys.info())
[16:04:14.902]                   }
[16:04:14.902]                   ...future.conditions[[length(...future.conditions) + 
[16:04:14.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:14.902]                     cond$call), session = sessionInformation(), 
[16:04:14.902]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:14.902]                   signalCondition(cond)
[16:04:14.902]                 }
[16:04:14.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:14.902]                 "immediateCondition"))) {
[16:04:14.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:14.902]                   ...future.conditions[[length(...future.conditions) + 
[16:04:14.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:14.902]                   if (TRUE && !signal) {
[16:04:14.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:14.902]                     {
[16:04:14.902]                       inherits <- base::inherits
[16:04:14.902]                       invokeRestart <- base::invokeRestart
[16:04:14.902]                       is.null <- base::is.null
[16:04:14.902]                       muffled <- FALSE
[16:04:14.902]                       if (inherits(cond, "message")) {
[16:04:14.902]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:14.902]                         if (muffled) 
[16:04:14.902]                           invokeRestart("muffleMessage")
[16:04:14.902]                       }
[16:04:14.902]                       else if (inherits(cond, "warning")) {
[16:04:14.902]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:14.902]                         if (muffled) 
[16:04:14.902]                           invokeRestart("muffleWarning")
[16:04:14.902]                       }
[16:04:14.902]                       else if (inherits(cond, "condition")) {
[16:04:14.902]                         if (!is.null(pattern)) {
[16:04:14.902]                           computeRestarts <- base::computeRestarts
[16:04:14.902]                           grepl <- base::grepl
[16:04:14.902]                           restarts <- computeRestarts(cond)
[16:04:14.902]                           for (restart in restarts) {
[16:04:14.902]                             name <- restart$name
[16:04:14.902]                             if (is.null(name)) 
[16:04:14.902]                               next
[16:04:14.902]                             if (!grepl(pattern, name)) 
[16:04:14.902]                               next
[16:04:14.902]                             invokeRestart(restart)
[16:04:14.902]                             muffled <- TRUE
[16:04:14.902]                             break
[16:04:14.902]                           }
[16:04:14.902]                         }
[16:04:14.902]                       }
[16:04:14.902]                       invisible(muffled)
[16:04:14.902]                     }
[16:04:14.902]                     muffleCondition(cond, pattern = "^muffle")
[16:04:14.902]                   }
[16:04:14.902]                 }
[16:04:14.902]                 else {
[16:04:14.902]                   if (TRUE) {
[16:04:14.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:14.902]                     {
[16:04:14.902]                       inherits <- base::inherits
[16:04:14.902]                       invokeRestart <- base::invokeRestart
[16:04:14.902]                       is.null <- base::is.null
[16:04:14.902]                       muffled <- FALSE
[16:04:14.902]                       if (inherits(cond, "message")) {
[16:04:14.902]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:14.902]                         if (muffled) 
[16:04:14.902]                           invokeRestart("muffleMessage")
[16:04:14.902]                       }
[16:04:14.902]                       else if (inherits(cond, "warning")) {
[16:04:14.902]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:14.902]                         if (muffled) 
[16:04:14.902]                           invokeRestart("muffleWarning")
[16:04:14.902]                       }
[16:04:14.902]                       else if (inherits(cond, "condition")) {
[16:04:14.902]                         if (!is.null(pattern)) {
[16:04:14.902]                           computeRestarts <- base::computeRestarts
[16:04:14.902]                           grepl <- base::grepl
[16:04:14.902]                           restarts <- computeRestarts(cond)
[16:04:14.902]                           for (restart in restarts) {
[16:04:14.902]                             name <- restart$name
[16:04:14.902]                             if (is.null(name)) 
[16:04:14.902]                               next
[16:04:14.902]                             if (!grepl(pattern, name)) 
[16:04:14.902]                               next
[16:04:14.902]                             invokeRestart(restart)
[16:04:14.902]                             muffled <- TRUE
[16:04:14.902]                             break
[16:04:14.902]                           }
[16:04:14.902]                         }
[16:04:14.902]                       }
[16:04:14.902]                       invisible(muffled)
[16:04:14.902]                     }
[16:04:14.902]                     muffleCondition(cond, pattern = "^muffle")
[16:04:14.902]                   }
[16:04:14.902]                 }
[16:04:14.902]             }
[16:04:14.902]         }))
[16:04:14.902]     }, error = function(ex) {
[16:04:14.902]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:14.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:14.902]                 ...future.rng), started = ...future.startTime, 
[16:04:14.902]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:14.902]             version = "1.8"), class = "FutureResult")
[16:04:14.902]     }, finally = {
[16:04:14.902]         if (!identical(...future.workdir, getwd())) 
[16:04:14.902]             setwd(...future.workdir)
[16:04:14.902]         {
[16:04:14.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:14.902]                 ...future.oldOptions$nwarnings <- NULL
[16:04:14.902]             }
[16:04:14.902]             base::options(...future.oldOptions)
[16:04:14.902]             if (.Platform$OS.type == "windows") {
[16:04:14.902]                 old_names <- names(...future.oldEnvVars)
[16:04:14.902]                 envs <- base::Sys.getenv()
[16:04:14.902]                 names <- names(envs)
[16:04:14.902]                 common <- intersect(names, old_names)
[16:04:14.902]                 added <- setdiff(names, old_names)
[16:04:14.902]                 removed <- setdiff(old_names, names)
[16:04:14.902]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:14.902]                   envs[common]]
[16:04:14.902]                 NAMES <- toupper(changed)
[16:04:14.902]                 args <- list()
[16:04:14.902]                 for (kk in seq_along(NAMES)) {
[16:04:14.902]                   name <- changed[[kk]]
[16:04:14.902]                   NAME <- NAMES[[kk]]
[16:04:14.902]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:14.902]                     next
[16:04:14.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:14.902]                 }
[16:04:14.902]                 NAMES <- toupper(added)
[16:04:14.902]                 for (kk in seq_along(NAMES)) {
[16:04:14.902]                   name <- added[[kk]]
[16:04:14.902]                   NAME <- NAMES[[kk]]
[16:04:14.902]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:14.902]                     next
[16:04:14.902]                   args[[name]] <- ""
[16:04:14.902]                 }
[16:04:14.902]                 NAMES <- toupper(removed)
[16:04:14.902]                 for (kk in seq_along(NAMES)) {
[16:04:14.902]                   name <- removed[[kk]]
[16:04:14.902]                   NAME <- NAMES[[kk]]
[16:04:14.902]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:14.902]                     next
[16:04:14.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:14.902]                 }
[16:04:14.902]                 if (length(args) > 0) 
[16:04:14.902]                   base::do.call(base::Sys.setenv, args = args)
[16:04:14.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:14.902]             }
[16:04:14.902]             else {
[16:04:14.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:14.902]             }
[16:04:14.902]             {
[16:04:14.902]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:14.902]                   0L) {
[16:04:14.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:14.902]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:14.902]                   base::options(opts)
[16:04:14.902]                 }
[16:04:14.902]                 {
[16:04:14.902]                   {
[16:04:14.902]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:14.902]                     NULL
[16:04:14.902]                   }
[16:04:14.902]                   options(future.plan = NULL)
[16:04:14.902]                   if (is.na(NA_character_)) 
[16:04:14.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:14.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:14.902]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:14.902]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:14.902]                     envir = parent.frame()) 
[16:04:14.902]                   {
[16:04:14.902]                     if (is.function(workers)) 
[16:04:14.902]                       workers <- workers()
[16:04:14.902]                     workers <- structure(as.integer(workers), 
[16:04:14.902]                       class = class(workers))
[16:04:14.902]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:14.902]                       workers >= 1)
[16:04:14.902]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:14.902]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:14.902]                     }
[16:04:14.902]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:14.902]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:14.902]                       envir = envir)
[16:04:14.902]                     if (!future$lazy) 
[16:04:14.902]                       future <- run(future)
[16:04:14.902]                     invisible(future)
[16:04:14.902]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:14.902]                 }
[16:04:14.902]             }
[16:04:14.902]         }
[16:04:14.902]     })
[16:04:14.902]     if (TRUE) {
[16:04:14.902]         base::sink(type = "output", split = FALSE)
[16:04:14.902]         if (TRUE) {
[16:04:14.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:14.902]         }
[16:04:14.902]         else {
[16:04:14.902]             ...future.result["stdout"] <- base::list(NULL)
[16:04:14.902]         }
[16:04:14.902]         base::close(...future.stdout)
[16:04:14.902]         ...future.stdout <- NULL
[16:04:14.902]     }
[16:04:14.902]     ...future.result$conditions <- ...future.conditions
[16:04:14.902]     ...future.result$finished <- base::Sys.time()
[16:04:14.902]     ...future.result
[16:04:14.902] }
[16:04:14.905] Poll #1 (0): usedNodes() = 2, workers = 2
[16:04:14.923] receiveMessageFromWorker() for ClusterFuture ...
[16:04:14.923] - Validating connection of MultisessionFuture
[16:04:14.924] - received message: FutureResult
[16:04:14.924] - Received FutureResult
[16:04:14.924] - Erased future from FutureRegistry
[16:04:14.924] result() for ClusterFuture ...
[16:04:14.924] - result already collected: FutureResult
[16:04:14.924] result() for ClusterFuture ... done
[16:04:14.924] signalConditions() ...
[16:04:14.925]  - include = ‘immediateCondition’
[16:04:14.925]  - exclude = 
[16:04:14.925]  - resignal = FALSE
[16:04:14.925]  - Number of conditions: 2
[16:04:14.925] signalConditions() ... done
[16:04:14.925] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:14.925] result() for ClusterFuture ...
[16:04:14.925] - result already collected: FutureResult
[16:04:14.925] result() for ClusterFuture ... done
[16:04:14.925] result() for ClusterFuture ...
[16:04:14.925] - result already collected: FutureResult
[16:04:14.926] result() for ClusterFuture ... done
[16:04:14.926] signalConditions() ...
[16:04:14.926]  - include = ‘immediateCondition’
[16:04:14.926]  - exclude = 
[16:04:14.926]  - resignal = FALSE
[16:04:14.926]  - Number of conditions: 2
[16:04:14.926] signalConditions() ... done
[16:04:14.927] Exporting 4 global objects (14.24 KiB) to cluster node #1 ...
[16:04:14.927] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:04:14.927] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:04:14.928] Exporting ‘n’ (56 bytes) to cluster node #1 ...
[16:04:14.928] Exporting ‘n’ (56 bytes) to cluster node #1 ... DONE
[16:04:14.928] Exporting ‘C’ (10.72 KiB) to cluster node #1 ...
[16:04:14.971] Exporting ‘C’ (10.72 KiB) to cluster node #1 ... DONE
[16:04:14.972] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ...
[16:04:15.015] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ... DONE
[16:04:15.016] Exporting 4 global objects (14.24 KiB) to cluster node #1 ... DONE
[16:04:15.017] MultisessionFuture started
[16:04:15.017] - Launch lazy future ... done
[16:04:15.017] run() for ‘MultisessionFuture’ ... done
[16:04:15.017] - run() ... done
[16:04:15.017] - resolved() ...
[16:04:15.028] - resolved: FALSE
[16:04:15.028] - resolved() ... done
[16:04:15.028] resolved() for ‘MultisessionFuture’ ... done
[16:04:15.028] resolved() for ‘Future’ ...
[16:04:15.028] - state: ‘created’
[16:04:15.028] - run: TRUE
[16:04:15.029] - run() ...
[16:04:15.029] run() for ‘Future’ ...
[16:04:15.029] - state: ‘created’
[16:04:15.029] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:15.043] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:15.043] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:15.043]   - Field: ‘node’
[16:04:15.043]   - Field: ‘label’
[16:04:15.043]   - Field: ‘local’
[16:04:15.043]   - Field: ‘owner’
[16:04:15.044]   - Field: ‘envir’
[16:04:15.044]   - Field: ‘workers’
[16:04:15.044]   - Field: ‘packages’
[16:04:15.044]   - Field: ‘gc’
[16:04:15.044]   - Field: ‘conditions’
[16:04:15.044]   - Field: ‘persistent’
[16:04:15.044]   - Field: ‘expr’
[16:04:15.044]   - Field: ‘uuid’
[16:04:15.044]   - Field: ‘seed’
[16:04:15.044]   - Field: ‘version’
[16:04:15.045]   - Field: ‘result’
[16:04:15.045]   - Field: ‘asynchronous’
[16:04:15.045]   - Field: ‘calls’
[16:04:15.045]   - Field: ‘globals’
[16:04:15.045]   - Field: ‘stdout’
[16:04:15.045]   - Field: ‘earlySignal’
[16:04:15.045]   - Field: ‘lazy’
[16:04:15.045]   - Field: ‘state’
[16:04:15.045] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:15.045] - Launch lazy future ...
[16:04:15.046] Packages needed by the future expression (n = 1): ‘future’
[16:04:15.046] Packages needed by future strategies (n = 0): <none>
[16:04:15.046] {
[16:04:15.046]     {
[16:04:15.046]         {
[16:04:15.046]             ...future.startTime <- base::Sys.time()
[16:04:15.046]             {
[16:04:15.046]                 {
[16:04:15.046]                   {
[16:04:15.046]                     {
[16:04:15.046]                       {
[16:04:15.046]                         base::local({
[16:04:15.046]                           has_future <- base::requireNamespace("future", 
[16:04:15.046]                             quietly = TRUE)
[16:04:15.046]                           if (has_future) {
[16:04:15.046]                             ns <- base::getNamespace("future")
[16:04:15.046]                             version <- ns[[".package"]][["version"]]
[16:04:15.046]                             if (is.null(version)) 
[16:04:15.046]                               version <- utils::packageVersion("future")
[16:04:15.046]                           }
[16:04:15.046]                           else {
[16:04:15.046]                             version <- NULL
[16:04:15.046]                           }
[16:04:15.046]                           if (!has_future || version < "1.8.0") {
[16:04:15.046]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.046]                               "", base::R.version$version.string), 
[16:04:15.046]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:15.046]                                 base::R.version$platform, 8 * 
[16:04:15.046]                                   base::.Machine$sizeof.pointer), 
[16:04:15.046]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.046]                                 "release", "version")], collapse = " "), 
[16:04:15.046]                               hostname = base::Sys.info()[["nodename"]])
[16:04:15.046]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.046]                               info)
[16:04:15.046]                             info <- base::paste(info, collapse = "; ")
[16:04:15.046]                             if (!has_future) {
[16:04:15.046]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.046]                                 info)
[16:04:15.046]                             }
[16:04:15.046]                             else {
[16:04:15.046]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.046]                                 info, version)
[16:04:15.046]                             }
[16:04:15.046]                             base::stop(msg)
[16:04:15.046]                           }
[16:04:15.046]                         })
[16:04:15.046]                       }
[16:04:15.046]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:15.046]                       base::options(mc.cores = 1L)
[16:04:15.046]                     }
[16:04:15.046]                     base::local({
[16:04:15.046]                       for (pkg in "future") {
[16:04:15.046]                         base::loadNamespace(pkg)
[16:04:15.046]                         base::library(pkg, character.only = TRUE)
[16:04:15.046]                       }
[16:04:15.046]                     })
[16:04:15.046]                   }
[16:04:15.046]                   options(future.plan = NULL)
[16:04:15.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.046]                 }
[16:04:15.046]                 ...future.workdir <- getwd()
[16:04:15.046]             }
[16:04:15.046]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.046]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.046]         }
[16:04:15.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.046]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.046]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.046]             base::names(...future.oldOptions))
[16:04:15.046]     }
[16:04:15.046]     if (FALSE) {
[16:04:15.046]     }
[16:04:15.046]     else {
[16:04:15.046]         if (TRUE) {
[16:04:15.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.046]                 open = "w")
[16:04:15.046]         }
[16:04:15.046]         else {
[16:04:15.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.046]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.046]         }
[16:04:15.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.046]             base::sink(type = "output", split = FALSE)
[16:04:15.046]             base::close(...future.stdout)
[16:04:15.046]         }, add = TRUE)
[16:04:15.046]     }
[16:04:15.046]     ...future.frame <- base::sys.nframe()
[16:04:15.046]     ...future.conditions <- base::list()
[16:04:15.046]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.046]     if (FALSE) {
[16:04:15.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.046]     }
[16:04:15.046]     ...future.result <- base::tryCatch({
[16:04:15.046]         base::withCallingHandlers({
[16:04:15.046]             ...future.value <- base::withVisible(base::local({
[16:04:15.046]                 ...future.makeSendCondition <- base::local({
[16:04:15.046]                   sendCondition <- NULL
[16:04:15.046]                   function(frame = 1L) {
[16:04:15.046]                     if (is.function(sendCondition)) 
[16:04:15.046]                       return(sendCondition)
[16:04:15.046]                     ns <- getNamespace("parallel")
[16:04:15.046]                     if (exists("sendData", mode = "function", 
[16:04:15.046]                       envir = ns)) {
[16:04:15.046]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:15.046]                         envir = ns)
[16:04:15.046]                       envir <- sys.frame(frame)
[16:04:15.046]                       master <- NULL
[16:04:15.046]                       while (!identical(envir, .GlobalEnv) && 
[16:04:15.046]                         !identical(envir, emptyenv())) {
[16:04:15.046]                         if (exists("master", mode = "list", envir = envir, 
[16:04:15.046]                           inherits = FALSE)) {
[16:04:15.046]                           master <- get("master", mode = "list", 
[16:04:15.046]                             envir = envir, inherits = FALSE)
[16:04:15.046]                           if (inherits(master, c("SOCKnode", 
[16:04:15.046]                             "SOCK0node"))) {
[16:04:15.046]                             sendCondition <<- function(cond) {
[16:04:15.046]                               data <- list(type = "VALUE", value = cond, 
[16:04:15.046]                                 success = TRUE)
[16:04:15.046]                               parallel_sendData(master, data)
[16:04:15.046]                             }
[16:04:15.046]                             return(sendCondition)
[16:04:15.046]                           }
[16:04:15.046]                         }
[16:04:15.046]                         frame <- frame + 1L
[16:04:15.046]                         envir <- sys.frame(frame)
[16:04:15.046]                       }
[16:04:15.046]                     }
[16:04:15.046]                     sendCondition <<- function(cond) NULL
[16:04:15.046]                   }
[16:04:15.046]                 })
[16:04:15.046]                 withCallingHandlers({
[16:04:15.046]                   {
[16:04:15.046]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:04:15.046]                       ii, n), appendLF = FALSE)
[16:04:15.046]                     fit <- mandelbrot(C)
[16:04:15.046]                     delay(fit)
[16:04:15.046]                     message(" done")
[16:04:15.046]                     fit
[16:04:15.046]                   }
[16:04:15.046]                 }, immediateCondition = function(cond) {
[16:04:15.046]                   sendCondition <- ...future.makeSendCondition()
[16:04:15.046]                   sendCondition(cond)
[16:04:15.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.046]                   {
[16:04:15.046]                     inherits <- base::inherits
[16:04:15.046]                     invokeRestart <- base::invokeRestart
[16:04:15.046]                     is.null <- base::is.null
[16:04:15.046]                     muffled <- FALSE
[16:04:15.046]                     if (inherits(cond, "message")) {
[16:04:15.046]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:15.046]                       if (muffled) 
[16:04:15.046]                         invokeRestart("muffleMessage")
[16:04:15.046]                     }
[16:04:15.046]                     else if (inherits(cond, "warning")) {
[16:04:15.046]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:15.046]                       if (muffled) 
[16:04:15.046]                         invokeRestart("muffleWarning")
[16:04:15.046]                     }
[16:04:15.046]                     else if (inherits(cond, "condition")) {
[16:04:15.046]                       if (!is.null(pattern)) {
[16:04:15.046]                         computeRestarts <- base::computeRestarts
[16:04:15.046]                         grepl <- base::grepl
[16:04:15.046]                         restarts <- computeRestarts(cond)
[16:04:15.046]                         for (restart in restarts) {
[16:04:15.046]                           name <- restart$name
[16:04:15.046]                           if (is.null(name)) 
[16:04:15.046]                             next
[16:04:15.046]                           if (!grepl(pattern, name)) 
[16:04:15.046]                             next
[16:04:15.046]                           invokeRestart(restart)
[16:04:15.046]                           muffled <- TRUE
[16:04:15.046]                           break
[16:04:15.046]                         }
[16:04:15.046]                       }
[16:04:15.046]                     }
[16:04:15.046]                     invisible(muffled)
[16:04:15.046]                   }
[16:04:15.046]                   muffleCondition(cond)
[16:04:15.046]                 })
[16:04:15.046]             }))
[16:04:15.046]             future::FutureResult(value = ...future.value$value, 
[16:04:15.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.046]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.046]                     ...future.globalenv.names))
[16:04:15.046]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.046]         }, condition = base::local({
[16:04:15.046]             c <- base::c
[16:04:15.046]             inherits <- base::inherits
[16:04:15.046]             invokeRestart <- base::invokeRestart
[16:04:15.046]             length <- base::length
[16:04:15.046]             list <- base::list
[16:04:15.046]             seq.int <- base::seq.int
[16:04:15.046]             signalCondition <- base::signalCondition
[16:04:15.046]             sys.calls <- base::sys.calls
[16:04:15.046]             `[[` <- base::`[[`
[16:04:15.046]             `+` <- base::`+`
[16:04:15.046]             `<<-` <- base::`<<-`
[16:04:15.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.046]                   3L)]
[16:04:15.046]             }
[16:04:15.046]             function(cond) {
[16:04:15.046]                 is_error <- inherits(cond, "error")
[16:04:15.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.046]                   NULL)
[16:04:15.046]                 if (is_error) {
[16:04:15.046]                   sessionInformation <- function() {
[16:04:15.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.046]                       search = base::search(), system = base::Sys.info())
[16:04:15.046]                   }
[16:04:15.046]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.046]                     cond$call), session = sessionInformation(), 
[16:04:15.046]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.046]                   signalCondition(cond)
[16:04:15.046]                 }
[16:04:15.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.046]                 "immediateCondition"))) {
[16:04:15.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.046]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.046]                   if (TRUE && !signal) {
[16:04:15.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.046]                     {
[16:04:15.046]                       inherits <- base::inherits
[16:04:15.046]                       invokeRestart <- base::invokeRestart
[16:04:15.046]                       is.null <- base::is.null
[16:04:15.046]                       muffled <- FALSE
[16:04:15.046]                       if (inherits(cond, "message")) {
[16:04:15.046]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.046]                         if (muffled) 
[16:04:15.046]                           invokeRestart("muffleMessage")
[16:04:15.046]                       }
[16:04:15.046]                       else if (inherits(cond, "warning")) {
[16:04:15.046]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.046]                         if (muffled) 
[16:04:15.046]                           invokeRestart("muffleWarning")
[16:04:15.046]                       }
[16:04:15.046]                       else if (inherits(cond, "condition")) {
[16:04:15.046]                         if (!is.null(pattern)) {
[16:04:15.046]                           computeRestarts <- base::computeRestarts
[16:04:15.046]                           grepl <- base::grepl
[16:04:15.046]                           restarts <- computeRestarts(cond)
[16:04:15.046]                           for (restart in restarts) {
[16:04:15.046]                             name <- restart$name
[16:04:15.046]                             if (is.null(name)) 
[16:04:15.046]                               next
[16:04:15.046]                             if (!grepl(pattern, name)) 
[16:04:15.046]                               next
[16:04:15.046]                             invokeRestart(restart)
[16:04:15.046]                             muffled <- TRUE
[16:04:15.046]                             break
[16:04:15.046]                           }
[16:04:15.046]                         }
[16:04:15.046]                       }
[16:04:15.046]                       invisible(muffled)
[16:04:15.046]                     }
[16:04:15.046]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.046]                   }
[16:04:15.046]                 }
[16:04:15.046]                 else {
[16:04:15.046]                   if (TRUE) {
[16:04:15.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.046]                     {
[16:04:15.046]                       inherits <- base::inherits
[16:04:15.046]                       invokeRestart <- base::invokeRestart
[16:04:15.046]                       is.null <- base::is.null
[16:04:15.046]                       muffled <- FALSE
[16:04:15.046]                       if (inherits(cond, "message")) {
[16:04:15.046]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.046]                         if (muffled) 
[16:04:15.046]                           invokeRestart("muffleMessage")
[16:04:15.046]                       }
[16:04:15.046]                       else if (inherits(cond, "warning")) {
[16:04:15.046]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.046]                         if (muffled) 
[16:04:15.046]                           invokeRestart("muffleWarning")
[16:04:15.046]                       }
[16:04:15.046]                       else if (inherits(cond, "condition")) {
[16:04:15.046]                         if (!is.null(pattern)) {
[16:04:15.046]                           computeRestarts <- base::computeRestarts
[16:04:15.046]                           grepl <- base::grepl
[16:04:15.046]                           restarts <- computeRestarts(cond)
[16:04:15.046]                           for (restart in restarts) {
[16:04:15.046]                             name <- restart$name
[16:04:15.046]                             if (is.null(name)) 
[16:04:15.046]                               next
[16:04:15.046]                             if (!grepl(pattern, name)) 
[16:04:15.046]                               next
[16:04:15.046]                             invokeRestart(restart)
[16:04:15.046]                             muffled <- TRUE
[16:04:15.046]                             break
[16:04:15.046]                           }
[16:04:15.046]                         }
[16:04:15.046]                       }
[16:04:15.046]                       invisible(muffled)
[16:04:15.046]                     }
[16:04:15.046]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.046]                   }
[16:04:15.046]                 }
[16:04:15.046]             }
[16:04:15.046]         }))
[16:04:15.046]     }, error = function(ex) {
[16:04:15.046]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.046]                 ...future.rng), started = ...future.startTime, 
[16:04:15.046]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.046]             version = "1.8"), class = "FutureResult")
[16:04:15.046]     }, finally = {
[16:04:15.046]         if (!identical(...future.workdir, getwd())) 
[16:04:15.046]             setwd(...future.workdir)
[16:04:15.046]         {
[16:04:15.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.046]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.046]             }
[16:04:15.046]             base::options(...future.oldOptions)
[16:04:15.046]             if (.Platform$OS.type == "windows") {
[16:04:15.046]                 old_names <- names(...future.oldEnvVars)
[16:04:15.046]                 envs <- base::Sys.getenv()
[16:04:15.046]                 names <- names(envs)
[16:04:15.046]                 common <- intersect(names, old_names)
[16:04:15.046]                 added <- setdiff(names, old_names)
[16:04:15.046]                 removed <- setdiff(old_names, names)
[16:04:15.046]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.046]                   envs[common]]
[16:04:15.046]                 NAMES <- toupper(changed)
[16:04:15.046]                 args <- list()
[16:04:15.046]                 for (kk in seq_along(NAMES)) {
[16:04:15.046]                   name <- changed[[kk]]
[16:04:15.046]                   NAME <- NAMES[[kk]]
[16:04:15.046]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.046]                     next
[16:04:15.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.046]                 }
[16:04:15.046]                 NAMES <- toupper(added)
[16:04:15.046]                 for (kk in seq_along(NAMES)) {
[16:04:15.046]                   name <- added[[kk]]
[16:04:15.046]                   NAME <- NAMES[[kk]]
[16:04:15.046]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.046]                     next
[16:04:15.046]                   args[[name]] <- ""
[16:04:15.046]                 }
[16:04:15.046]                 NAMES <- toupper(removed)
[16:04:15.046]                 for (kk in seq_along(NAMES)) {
[16:04:15.046]                   name <- removed[[kk]]
[16:04:15.046]                   NAME <- NAMES[[kk]]
[16:04:15.046]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.046]                     next
[16:04:15.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.046]                 }
[16:04:15.046]                 if (length(args) > 0) 
[16:04:15.046]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.046]             }
[16:04:15.046]             else {
[16:04:15.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.046]             }
[16:04:15.046]             {
[16:04:15.046]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.046]                   0L) {
[16:04:15.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.046]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.046]                   base::options(opts)
[16:04:15.046]                 }
[16:04:15.046]                 {
[16:04:15.046]                   {
[16:04:15.046]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:15.046]                     NULL
[16:04:15.046]                   }
[16:04:15.046]                   options(future.plan = NULL)
[16:04:15.046]                   if (is.na(NA_character_)) 
[16:04:15.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.046]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:15.046]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:15.046]                     envir = parent.frame()) 
[16:04:15.046]                   {
[16:04:15.046]                     if (is.function(workers)) 
[16:04:15.046]                       workers <- workers()
[16:04:15.046]                     workers <- structure(as.integer(workers), 
[16:04:15.046]                       class = class(workers))
[16:04:15.046]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:15.046]                       workers >= 1)
[16:04:15.046]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:15.046]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:15.046]                     }
[16:04:15.046]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:15.046]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:15.046]                       envir = envir)
[16:04:15.046]                     if (!future$lazy) 
[16:04:15.046]                       future <- run(future)
[16:04:15.046]                     invisible(future)
[16:04:15.046]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.046]                 }
[16:04:15.046]             }
[16:04:15.046]         }
[16:04:15.046]     })
[16:04:15.046]     if (TRUE) {
[16:04:15.046]         base::sink(type = "output", split = FALSE)
[16:04:15.046]         if (TRUE) {
[16:04:15.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.046]         }
[16:04:15.046]         else {
[16:04:15.046]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.046]         }
[16:04:15.046]         base::close(...future.stdout)
[16:04:15.046]         ...future.stdout <- NULL
[16:04:15.046]     }
[16:04:15.046]     ...future.result$conditions <- ...future.conditions
[16:04:15.046]     ...future.result$finished <- base::Sys.time()
[16:04:15.046]     ...future.result
[16:04:15.046] }
[16:04:15.049] Poll #1 (0): usedNodes() = 2, workers = 2
[16:04:15.060] receiveMessageFromWorker() for ClusterFuture ...
[16:04:15.060] - Validating connection of MultisessionFuture
[16:04:15.061] - received message: FutureResult
[16:04:15.061] - Received FutureResult
[16:04:15.061] - Erased future from FutureRegistry
[16:04:15.061] result() for ClusterFuture ...
[16:04:15.061] - result already collected: FutureResult
[16:04:15.061] result() for ClusterFuture ... done
[16:04:15.062] signalConditions() ...
[16:04:15.062]  - include = ‘immediateCondition’
[16:04:15.062]  - exclude = 
[16:04:15.062]  - resignal = FALSE
[16:04:15.062]  - Number of conditions: 2
[16:04:15.062] signalConditions() ... done
[16:04:15.063] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:15.063] result() for ClusterFuture ...
[16:04:15.063] - result already collected: FutureResult
[16:04:15.063] result() for ClusterFuture ... done
[16:04:15.063] result() for ClusterFuture ...
[16:04:15.063] - result already collected: FutureResult
[16:04:15.064] result() for ClusterFuture ... done
[16:04:15.064] signalConditions() ...
[16:04:15.064]  - include = ‘immediateCondition’
[16:04:15.064]  - exclude = 
[16:04:15.064]  - resignal = FALSE
[16:04:15.064]  - Number of conditions: 2
[16:04:15.065] signalConditions() ... done
[16:04:15.065] Exporting 4 global objects (14.24 KiB) to cluster node #2 ...
[16:04:15.066] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:04:15.066] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:04:15.066] Exporting ‘n’ (56 bytes) to cluster node #2 ...
[16:04:15.067] Exporting ‘n’ (56 bytes) to cluster node #2 ... DONE
[16:04:15.067] Exporting ‘C’ (10.72 KiB) to cluster node #2 ...
[16:04:15.115] Exporting ‘C’ (10.72 KiB) to cluster node #2 ... DONE
[16:04:15.115] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ...
[16:04:15.159] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ... DONE
[16:04:15.160] Exporting 4 global objects (14.24 KiB) to cluster node #2 ... DONE
[16:04:15.160] MultisessionFuture started
[16:04:15.160] - Launch lazy future ... done
[16:04:15.161] run() for ‘MultisessionFuture’ ... done
[16:04:15.161] - run() ... done
[16:04:15.161] - resolved() ...
[16:04:15.171] - resolved: FALSE
[16:04:15.172] - resolved() ... done
[16:04:15.172] resolved() for ‘MultisessionFuture’ ... done
Plotting tile #1 of 4 ...
[16:04:15.172] result() for ClusterFuture ...
[16:04:15.172] - result already collected: FutureResult
[16:04:15.172] result() for ClusterFuture ... done
[16:04:15.172] result() for ClusterFuture ...
[16:04:15.172] - result already collected: FutureResult
[16:04:15.172] result() for ClusterFuture ... done
[16:04:15.172] signalConditions() ...
[16:04:15.173]  - include = ‘immediateCondition’
[16:04:15.173]  - exclude = 
[16:04:15.173]  - resignal = FALSE
[16:04:15.173]  - Number of conditions: 2
[16:04:15.173] signalConditions() ... done
[16:04:15.173] Future state: ‘finished’
[16:04:15.173] result() for ClusterFuture ...
[16:04:15.173] - result already collected: FutureResult
[16:04:15.173] result() for ClusterFuture ... done
[16:04:15.173] signalConditions() ...
[16:04:15.173]  - include = ‘condition’
[16:04:15.176]  - exclude = ‘immediateCondition’
[16:04:15.176]  - resignal = TRUE
[16:04:15.176]  - Number of conditions: 2
[16:04:15.176]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[16:04:15.176]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:04:15.176] signalConditions() ... done
Plotting tile #2 of 4 ...
[16:04:15.177] result() for ClusterFuture ...
[16:04:15.177] - result already collected: FutureResult
[16:04:15.177] result() for ClusterFuture ... done
[16:04:15.177] result() for ClusterFuture ...
[16:04:15.177] - result already collected: FutureResult
[16:04:15.177] result() for ClusterFuture ... done
[16:04:15.177] signalConditions() ...
[16:04:15.177]  - include = ‘immediateCondition’
[16:04:15.178]  - exclude = 
[16:04:15.178]  - resignal = FALSE
[16:04:15.178]  - Number of conditions: 2
[16:04:15.178] signalConditions() ... done
[16:04:15.178] Future state: ‘finished’
[16:04:15.178] result() for ClusterFuture ...
[16:04:15.178] - result already collected: FutureResult
[16:04:15.178] result() for ClusterFuture ... done
[16:04:15.178] signalConditions() ...
[16:04:15.178]  - include = ‘condition’
[16:04:15.178]  - exclude = ‘immediateCondition’
[16:04:15.178]  - resignal = TRUE
[16:04:15.179]  - Number of conditions: 2
[16:04:15.179]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[16:04:15.179]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:04:15.179] signalConditions() ... done
[16:04:15.180] receiveMessageFromWorker() for ClusterFuture ...
[16:04:15.180] - Validating connection of MultisessionFuture
[16:04:15.180] - received message: FutureResult
[16:04:15.180] - Received FutureResult
[16:04:15.181] - Erased future from FutureRegistry
[16:04:15.181] result() for ClusterFuture ...
[16:04:15.181] - result already collected: FutureResult
[16:04:15.181] result() for ClusterFuture ... done
[16:04:15.181] signalConditions() ...
[16:04:15.181]  - include = ‘immediateCondition’
[16:04:15.181]  - exclude = 
[16:04:15.181]  - resignal = FALSE
[16:04:15.181]  - Number of conditions: 2
[16:04:15.181] signalConditions() ... done
[16:04:15.181] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #3 of 4 ...
[16:04:15.181] result() for ClusterFuture ...
[16:04:15.182] - result already collected: FutureResult
[16:04:15.182] result() for ClusterFuture ... done
[16:04:15.182] result() for ClusterFuture ...
[16:04:15.182] - result already collected: FutureResult
[16:04:15.182] result() for ClusterFuture ... done
[16:04:15.182] signalConditions() ...
[16:04:15.182]  - include = ‘immediateCondition’
[16:04:15.182]  - exclude = 
[16:04:15.182]  - resignal = FALSE
[16:04:15.182]  - Number of conditions: 2
[16:04:15.182] signalConditions() ... done
[16:04:15.182] Future state: ‘finished’
[16:04:15.183] result() for ClusterFuture ...
[16:04:15.183] - result already collected: FutureResult
[16:04:15.183] result() for ClusterFuture ... done
[16:04:15.183] signalConditions() ...
[16:04:15.183]  - include = ‘condition’
[16:04:15.183]  - exclude = ‘immediateCondition’
[16:04:15.183]  - resignal = TRUE
[16:04:15.183]  - Number of conditions: 2
[16:04:15.183]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[16:04:15.183]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:04:15.184] signalConditions() ... done
[16:04:15.223] receiveMessageFromWorker() for ClusterFuture ...
[16:04:15.224] - Validating connection of MultisessionFuture
[16:04:15.224] - received message: FutureResult
[16:04:15.224] - Received FutureResult
[16:04:15.224] - Erased future from FutureRegistry
[16:04:15.225] result() for ClusterFuture ...
[16:04:15.225] - result already collected: FutureResult
[16:04:15.225] result() for ClusterFuture ... done
[16:04:15.225] signalConditions() ...
[16:04:15.225]  - include = ‘immediateCondition’
[16:04:15.225]  - exclude = 
[16:04:15.225]  - resignal = FALSE
[16:04:15.225]  - Number of conditions: 2
[16:04:15.225] signalConditions() ... done
[16:04:15.225] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #4 of 4 ...
[16:04:15.225] result() for ClusterFuture ...
[16:04:15.226] - result already collected: FutureResult
[16:04:15.226] result() for ClusterFuture ... done
[16:04:15.226] result() for ClusterFuture ...
[16:04:15.226] - result already collected: FutureResult
[16:04:15.226] result() for ClusterFuture ... done
[16:04:15.226] signalConditions() ...
[16:04:15.226]  - include = ‘immediateCondition’
[16:04:15.226]  - exclude = 
[16:04:15.226]  - resignal = FALSE
[16:04:15.226]  - Number of conditions: 2
[16:04:15.226] signalConditions() ... done
[16:04:15.226] Future state: ‘finished’
[16:04:15.227] result() for ClusterFuture ...
[16:04:15.227] - result already collected: FutureResult
[16:04:15.227] result() for ClusterFuture ... done
[16:04:15.227] signalConditions() ...
[16:04:15.227]  - include = ‘condition’
[16:04:15.227]  - exclude = ‘immediateCondition’
[16:04:15.227]  - resignal = TRUE
[16:04:15.227]  - Number of conditions: 2
[16:04:15.227]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[16:04:15.227]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:04:15.228] signalConditions() ... done

> close.screen()
 [1]  1  2  3  4  5  6  7  8  9 10 11 12

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multisession') ... DONE
Testing with 2 cores ... DONE
> message("*** Mandelbrot demo of the 'future' package ... DONE")
*** Mandelbrot demo of the 'future' package ... DONE
> 
> message("*** Demos ... DONE")
*** Demos ... DONE
> 
> source("incl/end.R")
[16:04:15.229] plan(): Setting new future strategy stack:
[16:04:15.230] List of future strategies:
[16:04:15.230] 1. sequential:
[16:04:15.230]    - args: function (..., envir = parent.frame())
[16:04:15.230]    - tweaked: FALSE
[16:04:15.230]    - call: future::plan("sequential")
[16:04:15.230] plan(): nbrOfWorkers() = 1
> 
